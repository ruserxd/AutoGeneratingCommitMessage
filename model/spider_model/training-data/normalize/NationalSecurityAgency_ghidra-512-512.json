[
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/ReferenceCountToAddressTableColumn.java b/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/ReferenceCountToAddressTableColumn.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/ReferenceCountToAddressTableColumn.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/ReferenceCountToAddressTableColumn.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -40,6 +40,12 @@ public String getColumnName() {\n \t@Override\n \tpublic Integer getValue(Address rowObject, Settings settings, Program pgm,\n \t\t\tServiceProvider serviceProvider) throws IllegalArgumentException {\n+\n+\t\tif (rowObject.isStackAddress() || rowObject.isRegisterAddress()) {\n+\t\t\t// the ReferenceManager will throw an exception if we pass this address\n+\t\t\treturn 0;\n+\t\t}\n+\n \t\tReferenceManager referenceManager = pgm.getReferenceManager();\n \t\tint referenceCount = referenceManager.getReferenceCountTo(rowObject);\n \t\tif (referenceCount != 0) {",
    "output": "Fix table column exception seen when using Version Tracking"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/actions/RenameAction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/actions/RenameAction.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/actions/RenameAction.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/actions/RenameAction.java\n@@ -27,6 +27,7 @@ public RenameAction(SymbolTreePlugin plugin) {\n \t\tsuper(\"Rename Symbol\", plugin.getName());\n \t\tsetPopupMenuData(\n \t\t\tnew MenuData(new String[] { \"Rename\" }, null, \"xxx\", MenuData.NO_MNEMONIC, \"1\"));\n+\t\tsetKeyBindingData(new KeyBindingData(\"L\"));\n \t}\n \n \t@Override",
    "output": "Use L as a default shortcut for renaming symbols in symbol tree"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/WindowActionManager.java b/Ghidra/Framework/Docking/src/main/java/docking/WindowActionManager.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/WindowActionManager.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/WindowActionManager.java\n@@ -116,6 +116,7 @@ void dispose() {\n \n \tvoid contextChanged(Map<Class<? extends ActionContext>, ActionContext> defaultContextMap,\n \t\t\tActionContext localContext, Set<DockingActionIf> excluded) {\n+\n \t\t/**\n \t\t * We need the guard against reentrant changes to the actionToProxyMap, lest the iterator\n \t\t * throw a ConcurrentModificationException. If the guard finds a violation, i.e., the map\n@@ -145,8 +146,8 @@ void contextChanged(Map<Class<? extends ActionContext>, ActionContext> defaultCo\n \t\t\t\tActionContext context =\n \t\t\t\t\tgetContextForAction(action, localContext, defaultContextMap);\n \t\t\t\t// Reentry point 2\n-\t\t\t\tboolean enabled =\n-\t\t\t\t\tcontext == null ? false : proxyAction.isEnabledForContext(context);\n+\n+\t\t\t\tboolean enabled = proxyAction.isEnabledForContext(context);\n \t\t\t\t// Reentry point 3, which we check\n \t\t\t\tproxyAction.setEnabled(enabled);\n \t\t\t\tif (reentryGuard.isViolated()) {\n@@ -168,7 +169,7 @@ private ActionContext getContextForAction(DockingActionIf action, ActionContext\n \t\t\t\treturn context;\n \t\t\t}\n \t\t}\n-\t\treturn null;\n+\t\treturn new DefaultActionContext();\n \t}\n \n \t/**",
    "output": "Fix for null context and actions that do not use action context, but rely on managed enablement"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/AddressEvaluator.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/AddressEvaluator.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/AddressEvaluator.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/AddressEvaluator.java\n@@ -148,7 +148,7 @@ public Address parseAsRelativeAddress(String input, Address baseAddress)\n \t\t\tlong offset = longValue.getLongValue();\n \t\t\tAddressSpace space = getAddressSpace();\n \t\t\ttry {\n-\t\t\t\treturn space.getAddressInThisSpaceOnly(offset);\n+\t\t\t\treturn space.getAddressInThisSpaceOnly(offset*space.getAddressableUnitSize());\n \t\t\t}\n \t\t\tcatch (AddressOutOfBoundsException e) {\n \t\t\t\tthrow new ExpressionException(e.getMessage());",
    "output": "Add reference dialog fix for address spaces that have a wordsize greater than one byte"
  },
  {
    "input": "diff --git a/Ghidra/Features/CodeCompare/src/main/java/ghidra/features/codecompare/graphanalysis/DataGraph.java b/Ghidra/Features/CodeCompare/src/main/java/ghidra/features/codecompare/graphanalysis/DataGraph.java\n--- a/Ghidra/Features/CodeCompare/src/main/java/ghidra/features/codecompare/graphanalysis/DataGraph.java\n+++ b/Ghidra/Features/CodeCompare/src/main/java/ghidra/features/codecompare/graphanalysis/DataGraph.java\n@@ -231,13 +231,7 @@ private void eliminateCasts(ArrayList<DataVertex> casts) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\n-\t\t\tboolean outCast = true;\n-\t\t\tif ((out.sinks.size() == 1 && out.vn.isUnique()) || in.sources.size() == 0) {\n-\t\t\t\toutCast = false;\n-\t\t\t}\n-\n-\t\t\tif (outCast) {\n+\t\t\tif (in.sources.size() == 1 && in.sinks.size() == 1 && in.vn.isUnique()) {\n \t\t\t\t// PcodeOp defining CAST input, now defines CAST output\n \t\t\t\t// input is isolated\n \t\t\t\tDataVertex topOp = in.sources.get(0);",
    "output": "Fix indexoutofboundsexception in decompiler code comparison"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationAnalyzer.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationAnalyzer.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationAnalyzer.java\n@@ -435,6 +435,11 @@ public void analyzeSet(Program program, AddressSet todoSet, TaskMonitor monitor)\n \t\t\t\t// now get rid of all the instructions that were analyzed\n \t\t\t\ttodoSet.delete(resultSet);\n \t\t\t}\n+\t\t\t\n+\t\t\t// make sure todoSet removes start address if no results\n+\t\t\tif (resultSet == null || resultSet.isEmpty()) {\n+\t\t\t\ttodoSet.delete(start,start);\n+\t\t\t}\n \t\t}\n \t}\n ",
    "output": "Fix possible inifinite loop during constant analysis on mips platforms."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/DomainFileNode.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/DomainFileNode.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/DomainFileNode.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/DomainFileNode.java\n@@ -44,7 +44,7 @@\n public class DomainFileNode extends DataTreeNode {\n \n \tprivate static final Icon UNKNOWN_FILE_ICON = new GIcon(\"icon.datatree.node.domain.file\");\n-\tprivate static final String RIGHT_ARROW = \"\\u2b95\";\n+\tprivate static final String RIGHT_ARROW = Character.isDefined(0x2192) ? \"\\u2192\" : \"->\";\n \n \tprivate final DomainFile domainFile;\n \n\ndiff --git a/Ghidra/Test/IntegrationTest/src/screen/java/help/screenshot/FrontEndPluginScreenShots.java b/Ghidra/Test/IntegrationTest/src/screen/java/help/screenshot/FrontEndPluginScreenShots.java\n--- a/Ghidra/Test/IntegrationTest/src/screen/java/help/screenshot/FrontEndPluginScreenShots.java\n+++ b/Ghidra/Test/IntegrationTest/src/screen/java/help/screenshot/FrontEndPluginScreenShots.java\n@@ -59,7 +59,7 @@\n \n public class FrontEndPluginScreenShots extends GhidraScreenShotGenerator {\n \n-\tprivate static final String RIGHT_ARROW = \"\\u2b95\";\n+\tprivate static final String RIGHT_ARROW = \"\\u2192\";\n \tprivate static final String OTHER_PROJECT = \"Other_Project\";\n \tprivate Icon icon =\n \t\t(Icon) getInstanceField(\"CONVERT_ICON\", ProjectChooseRepositoryWizardModel.class);",
    "output": "Upgrade link arrow character used"
  },
  {
    "input": "diff --git a/Ghidra/Features/DataGraph/src/test/java/datagraph/graph/DataGraphProviderTest.java b/Ghidra/Features/DataGraph/src/test/java/datagraph/graph/DataGraphProviderTest.java\n--- a/Ghidra/Features/DataGraph/src/test/java/datagraph/graph/DataGraphProviderTest.java\n+++ b/Ghidra/Features/DataGraph/src/test/java/datagraph/graph/DataGraphProviderTest.java\n@@ -21,8 +21,7 @@\n import java.util.stream.Collectors;\n \n import org.apache.commons.lang3.StringUtils;\n-import org.junit.Before;\n-import org.junit.Test;\n+import org.junit.*;\n \n import datagraph.*;\n import datagraph.data.graph.*;\n@@ -72,6 +71,11 @@ public void setUp() throws Exception {\n \t\tturnOffAnimation();\n \t}\n \n+\t@After\n+\tpublic void tearDown() {\n+\t\tenv.dispose();\n+\t}\n+\n \t@Test\n \tpublic void testGraphHasInitialVertex() {\n ",
    "output": "Fix data graph tests"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java b/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java\n@@ -207,6 +207,7 @@ public void analyzeAll(Program program) {\n \n \t\tAutoAnalysisManager mgr = AutoAnalysisManager.getAnalysisManager(program);\n \n+\t\tmgr.initializeOptions();\n \t\tmgr.reAnalyzeAll(null);\n \n \t\tanalyzeChanges(program);",
    "output": "Fix a timing issue that prevented FlatProgramAPI.analyzeAll(Program) from picking up analyzer options set in the script"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesProvider.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesProvider.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesProvider.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesProvider.java\n@@ -1113,6 +1113,10 @@ private void activatedSelectCurrent(ActionContext ignored) {\n \t\t\t\t}\n \t\t\t\tbestModule = module;\n \t\t\t}\n+\t\t\tif (bestModule == null) {\n+\t\t\t\tsetSelectedModules(Set.of());\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t\tif (bestModule.getSections(snap).isEmpty()) {\n \t\t\t\tsetSelectedModules(Set.of(bestModule));\n \t\t\t\treturn;",
    "output": "Fix NPE on \"Select Current Module\" when cursor is not in a module."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/DWARFUtil.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/DWARFUtil.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/DWARFUtil.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/DWARFUtil.java\n@@ -486,7 +486,7 @@ public static String getLanguageExternalNameValue(Language lang, String name)\n \t}\n \n \tpublic static void packCompositeIfPossible(Composite original, DataTypeManager dtm) {\n-\t\tif (original.isZeroLength() || original.getNumComponents() == 0) {\n+\t\tif (original.isZeroLength() || original.getNumDefinedComponents() == 0) {\n \t\t\t// don't try to pack empty structs, this would throw off conflicthandler logic.\n \t\t\t// also don't pack sized structs with no fields because when packed down to 0 bytes they\n \t\t\t// cause errors when used as a param type",
    "output": "Fix issue in DWARF struct/union packing logic If struct was sized, but had no defined fields, the check meant to detect this and avoid packing was incorrect, and packed anyway."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DtFilterState.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DtFilterState.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DtFilterState.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DtFilterState.java\n@@ -187,6 +187,9 @@ public void save(SaveState parentSaveState) {\n \tpublic void restore(SaveState parentSaveState) {\n \n \t\tSaveState ss = parentSaveState.getSaveState(XML_NAME);\n+\t\tif (ss == null) {\n+\t\t\treturn;\n+\t\t}\n \n \t\tarraysFilter = DtTypeFilter.restore(\"Arrays\", ss.getSaveState(\"Arrays\"));\n \t\tenumsFilter = DtTypeFilter.restore(\"Enums\", ss.getSaveState(\"Enums\"));",
    "output": "Fix potential NPE when restoring tool state"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/CommentTypes.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/CommentTypes.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/CommentTypes.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/CommentTypes.java\n@@ -16,6 +16,7 @@\n package ghidra.app.util;\n \n import ghidra.program.model.listing.CodeUnit;\n+import ghidra.program.model.listing.CommentType;\n \n /**\n  * Class with a convenience method to get an array of the CodeUnit\n@@ -42,7 +43,7 @@ public class CommentTypes {\n \t}\n \n \t/**\n-\t * Get an array containing the comment types on a code unit.\n+\t * {@return an array containing the comment types on a code unit}\n \t */\n \tpublic static int[] getTypes() {\n \t\treturn COMMENT_TYPES;",
    "output": "Fix javadoc warning"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ControlFlowGuard.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ControlFlowGuard.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ControlFlowGuard.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ControlFlowGuard.java\n@@ -150,7 +150,13 @@ private static void createCfgFunctions(Program program, Data tableData, MessageL\n \t\t}\n \n \t\tfor (Address target : getFunctionAddressesFromTable(program, tableData)) {\n-\t\t\tAbstractProgramLoader.markAsFunction(program, null, target);\n+\t\t\tif (program.getListing().getDefinedDataAt(target) == null) {\n+\t\t\t\tAbstractProgramLoader.markAsFunction(program, null, target);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tlog.appendMsg(\"Unable to mark Control Flow Guard function at \" + target + \n+\t\t\t\t\t\". Data is already defined there.\");\n+\t\t\t}\n \t\t}\n \t}\n ",
    "output": "Fix analysis fail with function entryPoint may not be created on defined data error"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/data/DataPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/data/DataPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/data/DataPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/data/DataPlugin.java\n@@ -842,8 +842,15 @@ public boolean isCreateDataAllowed(ListingActionContext context) {\n \n \tprivate boolean canEditField(ListingActionContext context) {\n \t\tProgramLocation location = context.getLocation();\n-\t\tint[] componentPath = location.getComponentPath();\n-\t\treturn componentPath != null && componentPath.length > 0;\n+\t\tint[] path = location.getComponentPath();\n+\t\tif (path == null || path.length == 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tProgram program = context.getProgram();\n+\t\tAddress address = location.getAddress();\n+\t\tDataTypeComponent dtc = DataTypeUtils.getDataTypeComponent(program, address, path);\n+\t\treturn dtc != null;\n \t}\n \n \tprivate void editField(ListingActionContext context) {\n@@ -854,10 +861,6 @@ private void editField(ListingActionContext context) {\n \t\tint[] path = location.getComponentPath();\n \n \t\tDataTypeComponent dtc = DataTypeUtils.getDataTypeComponent(program, address, path);\n-\t\tif (dtc == null) {\n-\t\t\treturn;\n-\t\t}\n-\n \t\tDataType parent = dtc.getParent();\n \t\tComposite composite = (Composite) parent;\n \t\tint ordinal = dtc.getOrdinal();",
    "output": "Fix missing help; fixed action enablement"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompositeEditorModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompositeEditorModel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompositeEditorModel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompositeEditorModel.java\n@@ -504,7 +504,7 @@ else if (dataTypeObject instanceof String dtString) {\n \t\t\t\tnewLength = 0;\n \t\t\t}\n \n-\t\t\tDataType dataType = newDt.clone(originalDTM);\n+\t\t\tnewDt = newDt.clone(viewDTM);\n \t\t\tnewLength = newDt.getLength();\n \n \t\t\tcheckIsAllowableDataType(newDt);",
    "output": "Fix composite editor data type cloning"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiHandler.java b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiHandler.java\n--- a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiHandler.java\n+++ b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiHandler.java\n@@ -69,7 +69,11 @@\n import ghidra.util.exception.DuplicateFileException;\n \n public class TraceRmiHandler extends AbstractTraceRmiConnection {\n-\tpublic static final String VERSION = \"11.4\";\n+\t/**\n+\t * NOTE: This can't just be Application.getApplicationVersion(), because the Python client only\n+\t * specifies up to the minor, not patch, release.\n+\t */\n+\tpublic static final String VERSION = \"11.5\";\n \n \tprotected static class VersionMismatchError extends TraceRmiError {\n \t\tpublic VersionMismatchError(String remote) {",
    "output": "Upgrade protobuf to 4.31.0 (java) and 6.31.0 (python)"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/rtti/GoPcHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/rtti/GoPcHeader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/rtti/GoPcHeader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/rtti/GoPcHeader.java\n@@ -47,6 +47,7 @@ public class GoPcHeader {\n \tpublic static final int GO_1_2_MAGIC = 0xfffffffb;\n \tpublic static final int GO_1_16_MAGIC = 0xfffffffa;\n \tpublic static final int GO_1_18_MAGIC = 0xfffffff0;\n+\tpublic static final int GO_1_20_MAGIC = 0xfffffff1;\n \n \t/**\n \t * Returns the {@link Address} (if present) of the go pclntab section or symbol.\n@@ -314,6 +315,7 @@ private static GoVer magicToVer(int magicInt) {\n \t\t\tcase GO_1_2_MAGIC -> new GoVer(1, 2, 0);\n \t\t\tcase GO_1_16_MAGIC -> new GoVer(1, 16, 0);\n \t\t\tcase GO_1_18_MAGIC -> new GoVer(1, 18, 0);\n+\t\t\tcase GO_1_20_MAGIC -> new GoVer(1, 20, 0);\n \t\t\tdefault -> GoVer.INVALID;\n \t\t};\n \t\t",
    "output": "Fix magic bytes to resolve Golang (v1.20+) functions."
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RenameStructFieldTask.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RenameStructFieldTask.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RenameStructFieldTask.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RenameStructFieldTask.java\n@@ -50,7 +50,7 @@ public void commit() throws DuplicateNameException, InvalidInputException {\n \t\tDataTypeComponent comp = structure.getComponentAt(offset);\n \t\tif (comp.getDataType() == DataType.DEFAULT) {\t\t// Is this just a placeholder\n \t\t\tDataType newtype = new Undefined1DataType();\n-\t\t\tstructure.replaceAtOffset(offset, newtype, 1, newName, \"Created by retype action\");\n+\t\t\tstructure.replaceAtOffset(offset, newtype, 1, newName, \"Created by Rename Structure Field action\");\n \t\t}\n \t\telse {\n \t\t\tcomp.setFieldName(newName);",
    "output": "Fix typo in RenameStructureFieldTask comment: \"Created by retype action\" -> \"Created by Rename Structure Field action\""
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DomainFileArchiveNode.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DomainFileArchiveNode.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DomainFileArchiveNode.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DomainFileArchiveNode.java\n@@ -57,7 +57,7 @@ private void updateDomainFileInfo() {\n \t\tDomainFile domainFile = ((DomainFileArchive) archive).getDomainFile();\n \n \t\tisChanged = domainObject.isChanged();\n-\t\tisReadOnly = domainFile.isReadOnly();\n+\t\tisReadOnly = domainFile.isReadOnly() || !domainFile.isInWritableProject();\n \t\tisHijacked = domainFile.isHijacked();\n \t\tisVersioned = domainFile.isVersioned();\n \t\tversion = (isVersioned || !domainFile.canSave()) ? domainFile.getVersion()",
    "output": "Fix node icon to show read-only status for archives from other projects"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java b/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java\n@@ -24,7 +24,8 @@\n \n import ghidra.app.plugin.processors.sleigh.SleighLanguage;\n import ghidra.program.model.address.*;\n-import ghidra.program.model.data.*;\n+import ghidra.program.model.data.DataType;\n+import ghidra.program.model.data.Undefined;\n import ghidra.program.model.lang.*;\n import ghidra.program.model.listing.*;\n import ghidra.program.model.mem.MemoryAccessException;\n@@ -35,7 +36,8 @@\n import ghidra.program.model.symbol.Reference;\n import ghidra.program.model.symbol.ReferenceIterator;\n import ghidra.util.Msg;\n-import ghidra.util.exception.*;\n+import ghidra.util.exception.AssertException;\n+import ghidra.util.exception.DuplicateNameException;\n \n \n public class VarnodeContext implements ProcessorContext {\n@@ -1863,7 +1865,7 @@ public boolean isConstant(Varnode varnode) {\n \t/**\n \t * Check if this is a bad address, or offset from a bad address\n \t * \n-\t * @param varnode to check\n+\t * @param v to check\n \t * @return true if should be treated as a constant for most purposes\n \t */\n \tpublic boolean isBadAddress(Varnode v) {",
    "output": "Fix javadoc error"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/register/DebuggerRegistersProvider.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/register/DebuggerRegistersProvider.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/register/DebuggerRegistersProvider.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/register/DebuggerRegistersProvider.java\n@@ -1262,22 +1262,26 @@ public DebuggerRegistersProvider cloneAsDisconnected() {\n \n \tprotected void displaySelectedRegisters(Set<Register> selected) {\n \t\tList<Register> regs = current.getPlatform().getLanguage().getRegisters();\n+\t\tList<RegisterRow> toDelete = new ArrayList<>();\n \t\tfor (Iterator<Entry<Register, RegisterRow>> it = regMap.entrySet().iterator(); it\n \t\t\t\t.hasNext();) {\n \t\t\tMap.Entry<Register, RegisterRow> ent = it.next();\n \t\t\tif (!selected.contains(ent.getKey())) {\n-\t\t\t\tregsTableModel.delete(ent.getValue());\n+\t\t\t\ttoDelete.add(ent.getValue());\n \t\t\t\tit.remove();\n \t\t\t}\n \t\t}\n+\t\tregsTableModel.deleteWith(toDelete::contains);\n \n+\t\tList<RegisterRow> toAdd = new ArrayList<>();\n \t\tfor (Register reg : selected) {\n \t\t\tregMap.computeIfAbsent(reg, r -> {\n \t\t\t\tRegisterRow row = new RegisterRow(this, regs.indexOf(reg), reg);\n-\t\t\t\tregsTableModel.add(row);\n+\t\t\t\ttoAdd.add(row);\n \t\t\t\treturn row;\n \t\t\t});\n \t\t}\n+\t\tregsTableModel.addAll(toAdd);\n \t}\n \n \tprotected CompletableFuture<Void> loadRegistersAndValues() {",
    "output": "Fix hang at launch caused by repeated filtering of registers table."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/util/DataTypeTreeCopyMoveTask.java\n@@ -157,7 +157,8 @@ private void reportErrors() {\n \t\tif (n > 1) {\n \t\t\tmessage = \"Encountered \" + n + \" errors copying/moving.  See the log for details\";\n \n-\t\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\tint max = n < 10 ? n : 10;\n+\t\t\tfor (int i = 0; i < max; i++) {\n \t\t\t\tMsg.error(this, errors.get(i));\n \t\t\t}\n \t\t}",
    "output": "Fix loop counter"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/InstructionDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/InstructionDB.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/InstructionDB.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/InstructionDB.java\n@@ -938,7 +938,7 @@ public Address getDefaultFallThrough() {\n \t\tFlowType myFlowType = getFlowType(); // getFlowType will validate\n \t\tif (myFlowType.hasFallthrough()) {\n \t\t\ttry {\n-\t\t\t\treturn address.addNoWrap(getDefaultFallThroughOffset());\n+\t\t\t\treturn getAddress().addNoWrap(proto.getFallThroughOffset(this));\n \t\t\t}\n \t\t\tcatch (AddressOverflowException e) {\n \t\t\t\t// ignore",
    "output": "Fix for minor instruction length override regression"
  },
  {
    "input": "diff --git a/Ghidra/Features/GnuDemangler/src/main/java/ghidra/app/util/demangler/gnu/GnuDemanglerNativeProcess.java b/Ghidra/Features/GnuDemangler/src/main/java/ghidra/app/util/demangler/gnu/GnuDemanglerNativeProcess.java\n--- a/Ghidra/Features/GnuDemangler/src/main/java/ghidra/app/util/demangler/gnu/GnuDemanglerNativeProcess.java\n+++ b/Ghidra/Features/GnuDemangler/src/main/java/ghidra/app/util/demangler/gnu/GnuDemanglerNativeProcess.java\n@@ -238,7 +238,7 @@ private void checkForError(String[] command) throws IOException {\n \t\t\tList<String> errorLines = IOUtils.readLines(err, Charset.defaultCharset());\n \t\t\terror = StringUtils.join(errorLines, '\\n');\n \t\t}\n-\t\tcatch (IOException e) {\n+\t\tcatch (UncheckedIOException e) {\n \t\t\tthrow new IOException(\"Unable to read process error stream: \", e);\n \t\t}\n ",
    "output": "Upgrade some jars"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java\n@@ -756,9 +756,12 @@ public boolean applyTo(Program obj, TaskMonitor monitor) {\n \t\t\t}\n \t\t\t// mark the 4 bytes of the flag with a data type and set it to constant mutability.\n \t\t\ttry {\n+\t\t\t\t// this will overwrite any DWARF discovered struct (that encompasses the flag) \n+\t\t\t\t// that was placed here, which is necessary to allow the decompiler to determine\n+\t\t\t\t// that the flag is a constant value.\n \t\t\t\tData flagData = DataUtilities.createData(program, flagAddr,\n \t\t\t\t\tAbstractIntegerDataType.getUnsignedDataType(4, null), 4,\n-\t\t\t\t\tClearDataMode.CLEAR_ALL_UNDEFINED_CONFLICT_DATA);\n+\t\t\t\t\tClearDataMode.CLEAR_ALL_CONFLICT_DATA);\n \t\t\t\tMutabilitySettingsDefinition.DEF.setChoice(flagData,\n \t\t\t\t\tMutabilitySettingsDefinition.CONSTANT);\n \t\t\t\tmarkupSession.labelAddress(flagAddr, \"runtime.writeBarrier.discovered\");",
    "output": "Fix markup of gcwritebarrier enabled flag when dwarf is present DWARF can lay down a more detailed struct that encompasses the enabled flag, but it prevents the decompiler from simplifying its output. This change clears any DWARF struct laid down over the enabled flag."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/model/Project.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/model/Project.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/model/Project.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/model/Project.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -29,7 +29,7 @@\n  * and tools to work together.\n  * \n  */\n-public interface Project {\n+public interface Project extends AutoCloseable {\n \n \t/**\n \t * Convenience method to get the name of this project.\n@@ -106,6 +106,7 @@ public interface Project {\n \t/**\n \t * Close the project.\n \t */\n+\t@Override\n \tpublic void close();\n \n \t/**",
    "output": "Make Project AutoCloseable"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/chained/DyldChainedImport.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/chained/DyldChainedImport.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/chained/DyldChainedImport.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/chained/DyldChainedImport.java\n@@ -63,7 +63,7 @@ public class DyldChainedImport implements StructConverter {\n \t\t\tcase DYLD_CHAINED_IMPORT_ADDEND64: {\n \t\t\t\tlong ival = reader.readNextLong();\n \t\t\t\tlib_ordinal = (int) (ival & 0xffff);\n-\t\t\t\tweak_import = ((ival >> 8) & 1) == 1;\n+\t\t\t\tweak_import = ((ival >> 16) & 1) == 1;\n \t\t\t\tname_offset = ((ival >> 32) & 0xffffffffL);\n \t\t\t\taddend = reader.readNextLong();\n \t\t\t\tbreak;",
    "output": "Fix Mach-O DYLD_CHAINED_IMPORT_ADDEND64 weak_import value"
  },
  {
    "input": "diff --git a/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_Finder.java b/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_Finder.java\n--- a/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_Finder.java\n+++ b/Ghidra/Features/GnuDemangler/ghidra_scripts/VxWorksSymTab_Finder.java\n@@ -415,7 +415,12 @@ private void clearString(Address addr) throws Exception {\n \t// Test is weak.\n \t//------------------------------------------------------------------------\n \tprivate boolean isSymTblEntry(Address entry, VxSymbol vxSymbol) throws Exception {\n-\n+\t\t\n+\t\t// Make sure there's data for the symbol\n+\t\tif ( !isAddress(entry.getOffset() + vxSymbol.length() - 1) ) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n \t\t// First dword must be null or a valid ptr (typically into the sym table)\n \t\tlong value = getInt(entry) & 0xffffffffL;\n \t\tif ((value != 0) && !isAddress(value)) {",
    "output": "Fix VxWorksSymTab_Finder.java edge case Fixes MemoryAccessException that occurs if a candidate entry goes into invalid memory."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/features/base/memsearch/format/StringSearchFormat.java b/Ghidra/Features/Base/src/main/java/ghidra/features/base/memsearch/format/StringSearchFormat.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/features/base/memsearch/format/StringSearchFormat.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/features/base/memsearch/format/StringSearchFormat.java\n@@ -48,12 +48,12 @@ public ByteMatcher parse(String input, SearchSettings settings) {\n \t\tif (charset == StandardCharsets.UTF_16) {\n \t\t\tcharset = isBigEndian ? StandardCharsets.UTF_16BE : StandardCharsets.UTF_16LE;\n \t\t}\n-\n \t\t// Escape sequences in the \"input\" are 2 Characters long.\n+\t\tString converted = input;\n \t\tif (settings.useEscapeSequences() && inputLength >= 2) {\n-\t\t\tinput = StringUtilities.convertEscapeSequences(input);\n+\t\t\tconverted = StringUtilities.convertEscapeSequences(input);\n \t\t}\n-\t\tbyte[] bytes = input.getBytes(charset);\n+\t\tbyte[] bytes = converted.getBytes(charset);\n \t\tbyte[] maskArray = new byte[bytes.length];\n \t\tArrays.fill(maskArray, (byte) 0xff);\n ",
    "output": "Fix bug where memory search title with control chars breaks saving tools."
  },
  {
    "input": "diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/generic/depends/DependentServiceResolver.java b/Ghidra/Debug/ProposedUtils/src/main/java/generic/depends/DependentServiceResolver.java\n--- a/Ghidra/Debug/ProposedUtils/src/main/java/generic/depends/DependentServiceResolver.java\n+++ b/Ghidra/Debug/ProposedUtils/src/main/java/generic/depends/DependentServiceResolver.java\n@@ -144,12 +144,15 @@ public void injectServices(T obj) throws ServiceConstructionException {\n \t\t\t\tconstructed.put(cons.method, service);\n \t\t\t}\n \t\t\tinstancesByClass.put(cons.cls, service);\n-\t\t\tfor (Field f : fieldsByClass.remove(cons.cls)) {\n-\t\t\t\ttry {\n-\t\t\t\t\tf.set(obj, service);\n-\t\t\t\t}\n-\t\t\t\tcatch (IllegalArgumentException | IllegalAccessException e) {\n-\t\t\t\t\tthrow new AssertionError(e);\n+\t\t\tSet<Field> fields = fieldsByClass.remove(cons.cls);\n+\t\t\tif (fields != null) {\n+\t\t\t\tfor (Field f : fields) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tf.set(obj, service);\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (IllegalArgumentException | IllegalAccessException e) {\n+\t\t\t\t\t\tthrow new AssertionError(e);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}",
    "output": "Fix NPE in DependentServiceResolver"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java b/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java\n--- a/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java\n+++ b/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java\n@@ -404,11 +404,8 @@ private static Map<String, GModule> getOrderedModules(ApplicationLayout layout)\n \t\t\tif (external1 && external2) {\n \t\t\t\treturn nameComparison;\n \t\t\t}\n-\t\t\tif (external1) {\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\t\t\tif (external2) {\n-\t\t\t\treturn 1;\n+\t\t\tif (external1 || external2) {\n+\t\t\t\treturn Boolean.compare(external1, external2);\n \t\t\t}\n \n \t\t\t// Now handle modules that are internal to the Ghidra installation.",
    "output": "Fix an issue with external extension classpath order"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n@@ -15,8 +15,7 @@\n  */\n package docking.widgets.fieldpanel;\n \n-import static docking.widgets.EventTrigger.API_CALL;\n-import static docking.widgets.EventTrigger.INTERNAL_ONLY;\n+import static docking.widgets.EventTrigger.*;\n \n import java.awt.*;\n import java.awt.event.*;\n@@ -875,7 +874,6 @@ public void scrollToCursor() {\n \t * @param fieldNum the field on the line to go to.\n \t * @param row the row in the field to go to.\n \t * @param col the column in the field to go to.\n-\t * @param trigger the cause of the go to\n \t * @param alwaysCenterCursor if true, centers cursor on screen. Otherwise, only centers cursor\n \t *            if cursor is offscreen.\n \t */",
    "output": "Fix javadoc error"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/OptionalHeaderImpl.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/OptionalHeaderImpl.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/OptionalHeaderImpl.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/OptionalHeaderImpl.java\n@@ -394,7 +394,7 @@ public void processDataDirectories(TaskMonitor monitor) throws IOException {\n \t\t\t\tthrow re;\n \t\t\t}\n \t\t}\n-\t\tif (ndata++ == numberOfRvaAndSizes) {\n+\t\tif (++ndata == numberOfRvaAndSizes) {\n \t\t\treturn;\n \t\t}\n ",
    "output": "Fix ndata post-increment instead of pre-increment causing return case to be missed (, )"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n@@ -743,7 +743,7 @@ protected void processUndefinedSymbols() throws Exception {\n \t\t\t\t\tif (name != null && name.length() > 0) {\n \t\t\t\t\t\tprogram.getSymbolTable().createLabel(addr, name, SourceType.IMPORTED);\n \t\t\t\t\t\tprogram.getExternalManager()\n-\t\t\t\t\t\t\t\t.addExtLocation(Library.UNKNOWN, name, addr, SourceType.IMPORTED);\n+\t\t\t\t\t\t\t\t.addExtLocation(Library.UNKNOWN, name, null, SourceType.IMPORTED);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {",
    "output": "Fix a bug that resulted in incorrect external addresses of Mach-O undefined symbols"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/features/base/codecompare/listing/LinearAddressCorrelation.java b/Ghidra/Features/Base/src/main/java/ghidra/features/base/codecompare/listing/LinearAddressCorrelation.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/features/base/codecompare/listing/LinearAddressCorrelation.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/features/base/codecompare/listing/LinearAddressCorrelation.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -82,9 +82,12 @@ private boolean isCodeUnitStart(Side side, Address address) {\n \tprivate Address normalizeToCodeUnitStart(Side side, Address address) {\n \t\tListing listing = getListing(side);\n \t\tCodeUnit cu = listing.getCodeUnitContaining(address);\n-\t\tAddress minAddress = cu.getMinAddress();\n-\t\tif (isValidAddress(side, minAddress)) {\n-\t\t\treturn minAddress;\n+\n+\t\tif (cu != null) {\n+\t\t\taddress = cu.getMinAddress();\n+\t\t}\n+\t\tif (isValidAddress(side, address)) {\n+\t\t\treturn address;\n \t\t}\n \t\treturn null;\n \t}",
    "output": "Add cu null check for case where address is not in memory."
  },
  {
    "input": "diff --git a/Ghidra/Features/GhidraGo/src/main/java/ghidra/GhidraGo.java b/Ghidra/Features/GhidraGo/src/main/java/ghidra/GhidraGo.java\n--- a/Ghidra/Features/GhidraGo/src/main/java/ghidra/GhidraGo.java\n+++ b/Ghidra/Features/GhidraGo/src/main/java/ghidra/GhidraGo.java\n@@ -49,8 +49,8 @@ public class GhidraGo implements GhidraLaunchable {\n \t */\n \t@Override\n \tpublic void launch(GhidraApplicationLayout layout, String[] args) throws Exception {\n+\t\tApplicationConfiguration configuration = null;\n \t\ttry {\n-\t\t\tApplicationConfiguration configuration = null;\n \t\t\tif (!Application.isInitialized()) {\n \t\t\t\tSystem.setProperty(ApplicationProperties.APPLICATION_NAME_PROPERTY, \"GhidraGo\");\n \t\t\t\tconfiguration = new DockingApplicationConfiguration();\n@@ -92,7 +92,12 @@ public void launch(GhidraApplicationLayout layout, String[] args) throws Excepti\n \t\tcatch (Exception e) {\n \t\t\tlogOrShowError(\"GhidraGo Exception\", \"An unexpected exception occurred in GhidraGo\", e);\n \t\t}\n-\t\tSystem.exit(-1);\n+\t\t// if configuration is null, probably running inside a test\n+\t\tif (configuration != null) {\n+\t\t\t// calling System.exit explicitly is necessary, otherwise the Loading... screen\n+\t\t\t// persists instead of closing when complete.\n+\t\t\tSystem.exit(-1);\n+\t\t}\n \t}\n \n \tprivate void logOrShowError(String errorTitle, String errorMessage, Exception e) {",
    "output": "Fix test issue for GhidraGo"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/data/GhidraFileData.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/data/GhidraFileData.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/data/GhidraFileData.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/data/GhidraFileData.java\n@@ -1145,7 +1145,8 @@ else if (folderItem instanceof DataFileItem) {\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\telse {\n-\t\t\t\t\t\tthrow new AssertException(\"Unknown folder item type\");\n+\t\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\t\"Unable to add unsupported content to version control\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (InvalidNameException e) {\n@@ -1291,7 +1292,7 @@ else if (versionedFolderItem instanceof DataFileItem) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tthrow new AssertException(\"Can't checkout - unknown file type\");\n+\t\t\t\t\tthrow new IOException(\"Unable to Check Out unsupported content\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (InvalidNameException e) {\n@@ -2233,7 +2234,7 @@ else if (item instanceof DataFileItem) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tthrow new AssertException(\"Unknown Item in copyTo\");\n+\t\t\t\t\tthrow new IOException(\"Unable to copy unsupported content\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (InvalidNameException e) {",
    "output": "Improve some unsupported content error handling."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n@@ -1023,8 +1023,7 @@ protected boolean isValidSearchPath(FSRL fsrl, LoadSpec loadSpec, TaskMonitor mo\n \t */\n \tprotected List<LibrarySearchPath> getLibrarySearchPaths(Program program, LoadSpec loadSpec,\n \t\t\tList<Option> options, MessageLog log, TaskMonitor monitor) throws CancelledException {\n-\t\tif (!isLoadLibraries(options) && !isLinkExistingLibraries(options) &&\n-\t\t\t!shouldSearchAllPaths(program, options)) {\n+\t\tif (!isLoadLibraries(options) && !shouldSearchAllPaths(program, options)) {\n \t\t\treturn List.of();\n \t\t}\n ",
    "output": "Fix issue from cleanup effort"
  },
  {
    "input": "diff --git a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/search/DecompilerTextFinder.java b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/search/DecompilerTextFinder.java\n--- a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/search/DecompilerTextFinder.java\n+++ b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/plugin/core/search/DecompilerTextFinder.java\n@@ -158,6 +158,9 @@ public Void process(DecompileResults results, TaskMonitor monitor) throws Except\n \t\t\t}\n \n \t\t\tClangTokenGroup tokens = results.getCCodeMarkup();\n+\t\t\tif (tokens == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n \t\t\tList<ClangLine> lines = DecompilerUtils.toLines(tokens);\n \n \t\t\t// (?s) - enable dot all mode",
    "output": "Fix NPE in decompiler text finder when decompiler errors"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeBrowserSelectionPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeBrowserSelectionPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeBrowserSelectionPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeBrowserSelectionPlugin.java\n@@ -92,6 +92,7 @@ private void createActions() {\n \t\t\t\t.helpLocation(new HelpLocation(HelpTopics.SELECTION, \"Clear Selection\"))\n \t\t\t\t.withContext(CodeViewerActionContext.class, true)\n \t\t\t\t.inWindow(ActionBuilder.When.CONTEXT_MATCHES)\n+\t\t\t\t.enabledWhen(c -> c.hasSelection())\n \t\t\t\t.onAction(c -> ((CodeViewerProvider) c.getComponentProvider())\n \t\t\t\t\t\t.setSelection(new ProgramSelection()))\n \t\t\t\t.buildAndInstall(tool);",
    "output": "Fix escape key binding collision with closing windows by only enabling the action when there is a selection"
  },
  {
    "input": "diff --git a/Ghidra/Processors/tricore/src/main/java/ghidra/app/util/bin/format/elf/relocation/Tricore_ElfRelocationHandler.java b/Ghidra/Processors/tricore/src/main/java/ghidra/app/util/bin/format/elf/relocation/Tricore_ElfRelocationHandler.java\n--- a/Ghidra/Processors/tricore/src/main/java/ghidra/app/util/bin/format/elf/relocation/Tricore_ElfRelocationHandler.java\n+++ b/Ghidra/Processors/tricore/src/main/java/ghidra/app/util/bin/format/elf/relocation/Tricore_ElfRelocationHandler.java\n@@ -355,8 +355,7 @@ private int relocate_word16(Memory memory, Address relocationAddress, long rv)\n \t */\n \tprivate int relocate_relB(Memory memory, Address relocationAddress, long rv)\n \t\t\tthrows MemoryAccessException {\n-\t\t// TODO ff000000..00fffffe?\n-\t\tlong mask = 0xfffffffeL;\n+\t\tlong mask = 0x00000001L;\n \t\tlong val = ~mask & rv;\n \t\tint iw = memory.getInt(relocationAddress) & 0xff;\n \t\tiw |= ((val & 0x1fffe) << 15);",
    "output": "Fix tricore relocation 24REL handling"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ImageRuntimeFunctionEntries_X86.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ImageRuntimeFunctionEntries_X86.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ImageRuntimeFunctionEntries_X86.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ImageRuntimeFunctionEntries_X86.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -109,7 +109,8 @@ public void markup(Program program, Address headerStart) throws CodeUnitInsertio\n \t\t\tIOException, DuplicateNameException {\n \t\tStructureDataType struct = new StructureDataType(\"_IMAGE_RUNTIME_FUNCTION_ENTRY\", 0);\n \t\tstruct.add(StructConverter.IBO32, \"BeginAddress\", null);\n-\t\tstruct.add(StructConverter.IBO32, \"EndAddress\", null);\n+\t\tstruct.add(StructConverter.DWORD, \"EndAddress\",\n+\t\t\t\"Apply ImageBaseOffset32 to see reference\");\n \t\tstruct.add(StructConverter.IBO32, \"UnwindInfoAddressOrData\", null);\n \n \t\tArrayDataType arr = new ArrayDataType(struct, functionEntries.size(), struct.getLength());",
    "output": "Upgrade the PE ImageRuntimeFunctionEntry structures to make EndAddress a Dword since it is really the address after the end of the given function and was causing bad references and code to be created."
  },
  {
    "input": "diff --git a/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/ByteViewerComponent.java b/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/ByteViewerComponent.java\n--- a/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/ByteViewerComponent.java\n+++ b/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/ByteViewerComponent.java\n@@ -537,7 +537,7 @@ int setViewerCursorLocation(ByteBlock block, BigInteger index, int characterOffs\n \t\t\tint row = location.getRow();\n \t\t\tsetCursorPosition(fieldIndex, fieldNum, row, column, EventTrigger.INTERNAL_ONLY);\n \t\t\tif (panel.getCurrentComponent() == this) {\n-\t\t\t\tscrollToCursor();\n+\t\t\t\tgoTo(fieldIndex, fieldNum, row, column, false, EventTrigger.INTERNAL_ONLY);\n \t\t\t}\n \n \t\t\treturn fieldIndex.intValue();",
    "output": "Change Byteviewer to center cursor on screen when jumping to offscreen location to be consistent with listing"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DefaultWatchRow.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DefaultWatchRow.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DefaultWatchRow.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DefaultWatchRow.java\n@@ -133,7 +133,14 @@ protected void reevaluate() {\n \t\t\t}\n \t\t\t// Do not accidentally hang the Swing thread on evaluation\n \t\t\tWatchValue fullValue = compiled.evaluate(executor);\n-\t\t\tbyte[] prevValue = prevExec == null ? null : compiled.evaluate(prevExec);\n+\t\t\tbyte[] prevValue;\n+\t\t\ttry {\n+\t\t\t\tprevValue = prevExec == null ? null : compiled.evaluate(prevExec);\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n+\t\t\t\tMsg.trace(this, \"Error in evaluating previous value. Ignoring.\", e);\n+\t\t\t\tprevValue = null;\n+\t\t\t}\n \t\t\tsynchronized (lock) {\n \t\t\t\tif (executor != provider.asyncWatchExecutor) {\n \t\t\t\t\treturn;",
    "output": "Fix issue evaluating watches when no thread (on previous coords)"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/terminal/TerminalPanel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/terminal/TerminalPanel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/terminal/TerminalPanel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/terminal/TerminalPanel.java\n@@ -39,8 +39,7 @@\n import ghidra.app.plugin.core.terminal.vt.*;\n import ghidra.app.plugin.core.terminal.vt.VtHandler.*;\n import ghidra.app.services.ClipboardService;\n-import ghidra.util.ColorUtils;\n-import ghidra.util.Msg;\n+import ghidra.util.*;\n \n /**\n  * A VT100 terminal emulator in a panel.\n@@ -466,9 +465,13 @@ public void fieldLocationChanged(FieldLocation location, Field field, EventTrigg\n \t\t * Prevent the user from doing this. Cursor location is controlled by pty. While we've\n \t\t * prevented key strokes from causing this, we've not prevented mouse clicks from doing it.\n \t\t * Next best thing is to just move it back.\n+\t\t * \n+\t\t * NOTE: We schedule the cursor re-placement for later, because the FieldPanel may be about\n+\t\t * to scroll to the cursor. If we re-place immediately, it will likely scroll to the bottom\n+\t\t * of the terminal. This is especially annoying when the user is trying to make a selection.\n \t\t */\n \t\tif (trigger == EventTrigger.GUI_ACTION) {\n-\t\t\tplaceCursor(false);\n+\t\t\tSwing.runLater(() -> placeCursor(false));\n \t\t}\n \t}\n ",
    "output": "Fix annoying Terminal scrolling when selecting."
  },
  {
    "input": "diff --git a/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/cmd/data/rtti/RttiUtil.java b/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/cmd/data/rtti/RttiUtil.java\n--- a/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/cmd/data/rtti/RttiUtil.java\n+++ b/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/cmd/data/rtti/RttiUtil.java\n@@ -164,6 +164,10 @@ private static boolean replaceSymbolWithNoTicks(Symbol symbol) {\n \t\t\tname = name.replace(\"'\", \"\").replace(\"`\", \"\");\n \t\t\ttry {\n \t\t\t\tsymbol.setName(name, symbol.getSource());\n+\n+\t\t\t\t//do this in case the mangled name is currently primary which will cause demangler\n+\t\t\t\t//to replace the ticks again once demangled since demangler only demangles primary \n+\t\t\t\tsymbol.setPrimary();\n \t\t\t\treturn true;\n \t\t\t}\n \t\t\tcatch (DuplicateNameException e) {",
    "output": "Fix RTTIAnalyzer replace tick after just removed issue"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/ShowComponentAction.java b/Ghidra/Framework/Docking/src/main/java/docking/ShowComponentAction.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/ShowComponentAction.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/ShowComponentAction.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -122,7 +122,13 @@ private static KeyBindingType createKeyBindingType(boolean isTransient,\n \n \t@Override\n \tpublic void actionPerformed(ActionContext context) {\n-\t\twinMgr.showComponent(info, true, true, true);\n+\t\t// Note: we use the emphasize feature as a callout when users are frustratedly pressing the\n+\t\t// button to show a provider, as it implies they are not seeing the provider as it is being\n+\t\t// shown.  Since this action is a menu item, the user cannot click it fast enough to show\n+\t\t// frustration.   For now, turn off the emphasis.  We can think of a better way to determine\n+\t\t// frustration in this use case later if we think it improves the user experience.\n+\t\tboolean emphasize = false;\n+\t\twinMgr.showComponent(info, true, true, emphasize);\n \t}\n \n \t@Override",
    "output": "Upgrade the Window menu actions to not show frustration"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/chained/DyldChainedFixups.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/chained/DyldChainedFixups.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/chained/DyldChainedFixups.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/chained/DyldChainedFixups.java\n@@ -110,7 +110,7 @@ public static List<DyldFixup> getChainedFixups(BinaryReader reader,\n \t\t\t}\n \n \t\t\tfixups.add(new DyldFixup(chainLoc, newChainValue, DyldChainedPtr.getSize(pointerFormat),\n-\t\t\t\tsymbol.getName(), libOrdinal));\n+\t\t\t\tsymbol != null ? symbol.getName() : null, libOrdinal));\n \n \t\t\tnext = DyldChainedPtr.getNext(pointerFormat, chainValue);\n \t\t\tnextOff += next * DyldChainedPtr.getStride(pointerFormat);",
    "output": "Fix a recent regression in DyldChainedFixups.java"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java\n--- a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java\n+++ b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java\n@@ -2371,6 +2371,7 @@ else if (specialVtable.getNamespace()\n \n \t\t\t\tif (newStructure == null) {\n \t\t\t\t\t// is a typeinfo that inherits a non class typeinfo so skip it\n+\t\t\t\t\t// or there was an issue creating it so skip it\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \n@@ -2741,6 +2742,12 @@ private Structure getOrCreateVmiTypeinfoStructure(Address typeinfoAddress,\n \t\tint numBases;\n \t\ttry {\n \t\t\tnumBases = api.getInt(typeinfoAddress.add(offsetOfNumBases));\n+\n+\t\t\tif (numBases <= 0) {\n+\t\t\t\tMsg.debug(this, typeinfoAddress.toString() +\n+\t\t\t\t\t\": VmiTypeinfoStructure has invalid number of bases: \" + numBases);\n+\t\t\t\treturn null;\n+\t\t\t}\n \t\t}\n \t\t// if there isn't enough memory to get the int then return null\n \t\tcatch (MemoryAccessException | AddressOutOfBoundsException e) {",
    "output": "Add check in vmi structure creation so numBases is valid"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n@@ -1850,7 +1850,7 @@ public void actionPerformed(ActionContext context) {\n \t\t\t\tInteger.toString(subGroupIndex++)\n \t\t\t)\n \t\t);\n-\t\tcopyFormattedAction.setHelpLocation(new HelpLocation(\"Trees\", \"Copy_Special\"));\n+\t\tcopyFormattedAction.setHelpLocation(new HelpLocation(\"Trees\", \"Copy_Formatted\"));\n \t\t//@formatter:on\n \n \t\tGTreeAction activateFilterAction = new GTreeAction(\"Table/Tree Activate Filter\", owner) {",
    "output": "Fix bad help location"
  },
  {
    "input": "diff --git a/Ghidra/Framework/FileSystem/src/main/java/ghidra/framework/client/RepositoryAdapter.java b/Ghidra/Framework/FileSystem/src/main/java/ghidra/framework/client/RepositoryAdapter.java\n--- a/Ghidra/Framework/FileSystem/src/main/java/ghidra/framework/client/RepositoryAdapter.java\n+++ b/Ghidra/Framework/FileSystem/src/main/java/ghidra/framework/client/RepositoryAdapter.java\n@@ -58,7 +58,6 @@ public class RepositoryAdapter implements RemoteAdapterListener {\n \t * @param name repository name\n \t */\n \tpublic RepositoryAdapter(RepositoryServerAdapter serverAdapter, String name) {\n-\t\t(new Exception(\"CONSTRUCTED \" + name)).printStackTrace();\n \t\tthis.serverAdapter = serverAdapter;\n \t\tthis.name = name;\n \t\tchangeDispatcher = new RepositoryChangeDispatcher(this);\n@@ -179,7 +178,6 @@ public void connect() throws RepositoryNotFoundException, IOException {\n \t\t\t\tserverAdapter.connect(); // may cause auto-reconnect of repository\n \t\t\t}\n \t\t\tif (repository == null) {\n-\t\t\t\t(new Exception(\"CONNECTION\")).printStackTrace();\n \t\t\t\trepository = serverAdapter.getRepositoryHandle(name);\n \t\t\t\tunexpectedDisconnect = false;\n \t\t\t\tif (repository == null) {",
    "output": "Remove server related debug stacktraces"
  },
  {
    "input": "diff --git a/GhidraBuild/LaunchSupport/src/main/java/LaunchSupport.java b/GhidraBuild/LaunchSupport/src/main/java/LaunchSupport.java\n--- a/GhidraBuild/LaunchSupport/src/main/java/LaunchSupport.java\n+++ b/GhidraBuild/LaunchSupport/src/main/java/LaunchSupport.java\n@@ -202,6 +202,9 @@ private static int findJavaHome(AppConfig appConfig, JavaFinder javaFinder,\n \t\tif (javaHome != null) {\n \t\t\tjavaHomeDir = new File(javaHome);\n \t\t\tif (appConfig.isSupportedJavaHomeDir(javaHomeDir, javaFilter)) {\n+\t\t\t\tif (save) {\n+\t\t\t\t\tappConfig.saveJavaHome(javaHomeDir);\n+\t\t\t\t}\n \t\t\t\tSystem.out.println(javaHomeDir);\n \t\t\t\treturn EXIT_SUCCESS;\n \t\t\t}",
    "output": "Fix a bug that prevented Ghidra from remembering the last-used JDK when the JAVA_HOME environment variable was set"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-rmi-trace/src/test/java/ghidra/app/plugin/core/debug/gui/tracermi/RemoteMethodInvocationDialogTest.java b/Ghidra/Debug/Debugger-rmi-trace/src/test/java/ghidra/app/plugin/core/debug/gui/tracermi/RemoteMethodInvocationDialogTest.java\n--- a/Ghidra/Debug/Debugger-rmi-trace/src/test/java/ghidra/app/plugin/core/debug/gui/tracermi/RemoteMethodInvocationDialogTest.java\n+++ b/Ghidra/Debug/Debugger-rmi-trace/src/test/java/ghidra/app/plugin/core/debug/gui/tracermi/RemoteMethodInvocationDialogTest.java\n@@ -33,6 +33,7 @@\n import ghidra.app.plugin.core.debug.service.tracermi.TestTraceRmiConnection.TestRemoteParameter;\n import ghidra.async.SwingExecutorService;\n import ghidra.debug.api.ValStr;\n+import ghidra.debug.api.target.ActionName;\n import ghidra.debug.api.tracermi.RemoteMethod;\n import ghidra.debug.api.tracermi.RemoteParameter;\n import ghidra.framework.options.PropertyBoolean;\n@@ -52,7 +53,8 @@ public static TestRemoteMethod createTestMethod(Method m) {\n \t\t\tTestRemoteParameter parameter = createParameter(p);\n \t\t\tparams.put(parameter.name(), parameter);\n \t\t}\n-\t\treturn new TestRemoteMethod(m.getName(), null, \"Test\", \"A test method\", params,\n+\t\treturn new TestRemoteMethod(m.getName(), ActionName.name(m.getName()), \"Test\",\n+\t\t\t\"A test method\", params,\n \t\t\tPrimitiveTraceObjectSchema.schemaForPrimitive(m.getReturnType()));\n \t}\n ",
    "output": "Fix MethodInvocation dialog tests."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/plugins/fsbrowser/FSBComponentProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/plugins/fsbrowser/FSBComponentProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/plugins/fsbrowser/FSBComponentProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/plugins/fsbrowser/FSBComponentProvider.java\n@@ -27,6 +27,8 @@\n import javax.swing.tree.TreePath;\n import javax.swing.tree.TreeSelectionModel;\n \n+import org.apache.commons.io.FilenameUtils;\n+\n import docking.*;\n import docking.action.DockingAction;\n import docking.action.DockingActionIf;\n@@ -544,9 +546,13 @@ public boolean fileDefaultAction(FSBFileNode fileNode) {\n \t\t\t\t\t\tSwing.runLater(() -> openWithTarget.open(List.of(df)));\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n-\t\t\t\t\tImporterUtilities.showImportSingleFileDialog(fullFsrl, null,\n-\t\t\t\t\t\tfileNode.getFormattedTreePath(), plugin.getTool(), openWithTarget.getPm(),\n-\t\t\t\t\t\tmonitor);\n+\n+\t\t\t\t\tString suggestedPath =\n+\t\t\t\t\t\tFilenameUtils.getFullPathNoEndSeparator(fileNode.getFormattedTreePath())\n+\t\t\t\t\t\t\t\t.replaceAll(\":/\", \"/\");\n+\n+\t\t\t\t\tImporterUtilities.showImportSingleFileDialog(fullFsrl, null, suggestedPath,\n+\t\t\t\t\t\tplugin.getTool(), openWithTarget.getPm(), monitor);\n \t\t\t\t}\n \t\t\t\tcatch (IOException | CancelledException e) {\n \t\t\t\t\t// fall thru\n@@ -581,5 +587,4 @@ private void gotoSymlinkDest(FSBFileNode fileNode) {\n \t\t}\n \n \t}\n-\n }",
    "output": "Fix default path suggested during import Fix suggested import path when double-clicking to start import (vs. right click import action)"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeOp.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeOp.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeOp.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeOp.java\n@@ -689,6 +689,8 @@ public final static String getMnemonic(int op) {\n \t\t\t\treturn \"PTRADD\";\n \t\t\tcase PTRSUB:\n \t\t\t\treturn \"PTRSUB\";\n+\t\t\tcase SEGMENTOP:\n+\t\t\t\treturn \"SEGMENTOP\";\n \t\t\tcase CPOOLREF:\n \t\t\t\treturn \"CPOOLREF\";\n \t\t\tcase NEW:",
    "output": "Add missing switch case in PcodeOp.toString for SEGMENTOP"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n@@ -880,7 +880,9 @@ public void setPreviewWindowVisible(boolean visible) {\n \t\t}\n \n \t\tGTreeNode node = (GTreeNode) path.getLastPathComponent();\n-\t\tpreviewPane.setText(node.getToolTip());\n+\t\tif (node instanceof DataTypeNode dtNode) {\n+\t\t\tshowDataTypePreview(dtNode);\n+\t\t}\n \t}\n \n \tString getPreviewText() {",
    "output": "Upgrade the preview pane to correctly use html when first shown"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n@@ -29,7 +29,6 @@\n import ghidra.app.util.Option;\n import ghidra.app.util.OptionUtils;\n import ghidra.app.util.bin.ByteProvider;\n-import ghidra.app.util.bin.FileBytesProvider;\n import ghidra.app.util.importer.*;\n import ghidra.formats.gfilesystem.*;\n import ghidra.framework.model.*;\n@@ -101,9 +100,6 @@ protected List<Loaded<Program>> loadProgram(ByteProvider provider, String loaded\n \t\t\t// Load (or get) the primary program\n \t\t\tProgram program = null;\n \t\t\tif (!shouldLoadOnlyLibraries(options)) {\n-\t\t\t\tif (provider instanceof FileBytesProvider) {\n-\t\t\t\t\tthrow new LoadException(\"Cannot load an already loaded program\");\n-\t\t\t\t}\n \t\t\t\tprogram = doLoad(provider, loadedName, loadSpec, libraryNameList, options, consumer,\n \t\t\t\t\tlog, monitor);\n \t\t\t\tloadedProgramList.add(new Loaded<>(program, loadedName, projectFolderPath));",
    "output": "Remove FileBytesProvider check from AbstractLibrarySupportLoader"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java b/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java\n@@ -2389,7 +2389,10 @@ public static void createSharedActions(Tool tool, ToolActions toolActions, Strin\n \t\t\t\t\t}\n \t\t\t\t\tTool t = provider.getTool();\n \t\t\t\t\tDockingWindowManager dwm = t.getWindowManager();\n-\t\t\t\t\treturn dwm.isLastProviderInDetachedWindow(provider);\n+\t\t\t\t\tif (!dwm.isLastProviderInDetachedWindow(provider)) {\n+\t\t\t\t\t\treturn false; // not the only provider\n+\t\t\t\t\t}\n+\t\t\t\t\treturn containsFocusOwner(provider);\n \t\t\t\t})\n \t\t\t\t.onAction(c -> {\n \t\t\t\t\tComponentProvider provider = getComponentProviderForContext(c);\n@@ -2399,6 +2402,16 @@ public static void createSharedActions(Tool tool, ToolActions toolActions, Strin\n \t\ttoolActions.addGlobalAction(closeAction);\n \t}\n \n+\tprivate static boolean containsFocusOwner(ComponentProvider provider) {\n+\t\tKeyboardFocusManager kfm = KeyboardFocusManager.getCurrentKeyboardFocusManager();\n+\t\tComponent focusOwner = kfm.getFocusOwner();\n+\t\tif (focusOwner == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tJComponent providerComponent = provider.getComponent();\n+\t\treturn SwingUtilities.isDescendingFrom(focusOwner, providerComponent);\n+\t}\n+\n \tprivate static ComponentProvider getComponentProviderForContext(ActionContext context) {\n \t\tComponentProvider provider = context.getComponentProvider();\n \t\tif (provider != null) {",
    "output": "Fix Escape action prompting when using a non-modal dialog in a window with a single component provider"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/model/AbstractQueryTableModel.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/model/AbstractQueryTableModel.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/model/AbstractQueryTableModel.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/model/AbstractQueryTableModel.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -302,6 +302,7 @@ public boolean isShowHidden() {\n \t@Override\n \tprotected void doLoad(Accumulator<T> accumulator, TaskMonitor monitor)\n \t\t\tthrows CancelledException {\n+\t\tTrace trace = this.trace;\n \t\tif (trace == null || query == null || trace.getObjectManager().getRootSchema() == null) {\n \t\t\treturn;\n \t\t}",
    "output": "Fix rare race condition causing NPE."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiHandler.java b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiHandler.java\n--- a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiHandler.java\n+++ b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiHandler.java\n@@ -65,7 +65,7 @@\n import ghidra.util.exception.DuplicateFileException;\n \n public class TraceRmiHandler extends AbstractTraceRmiConnection {\n-\tpublic static final String VERSION = \"11.2\";\n+\tpublic static final String VERSION = \"11.3\";\n \n \tprotected static class VersionMismatchError extends TraceRmiError {\n \t\tpublic VersionMismatchError(String remote) {",
    "output": "Upgrade debug agent versions to 11.3"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiPlugin.java b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiPlugin.java\n--- a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiPlugin.java\n+++ b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiPlugin.java\n@@ -108,9 +108,11 @@ record ConnAndTarget(TraceRmiConnection conn, Target target) {}\n \t\t\t}\n \t\t}\n \n-\t\tfor (ConnAndTarget cat : targets) {\n-\t\t\ttargetService.publishTarget(cat.target);\n-\t\t\tlisteners.invoke().targetPublished(cat.conn, cat.target);\n+\t\tif (targetService != null) {\n+\t\t\tfor (ConnAndTarget cat : targets) {\n+\t\t\t\ttargetService.publishTarget(cat.target);\n+\t\t\t\tlisteners.invoke().targetPublished(cat.conn, cat.target);\n+\t\t\t}\n \t\t}\n \t}\n ",
    "output": "Fix NPEs when closing the Debugger tool."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeaderRenderer.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeaderRenderer.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeaderRenderer.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeaderRenderer.java\n@@ -105,10 +105,17 @@ public void paint(Graphics g) {\n \n \t\tupdateClipping();\n \n+\t\t// Note: we should not have to set the colors here.  That is usually done by the renderer\n+\t\t// when getTableCellRendererComponent() is called.  Some Lafs, like the FlatLaf will change\n+\t\t// colors when painting, after the renderer component has been configured.  To support that,\n+\t\t// we must update the colors here as well.  \n+\t\trendererComponent.setBackground(getBackground());\n+\t\trendererComponent.setForeground(getForeground());\n+\n \t\trendererComponent.paint(g);\n \n \t\t// paint our items after the delegate call so that we paint on top\n-\t\tsuper.paint(g);\n+\t\tpaintChildren(g);\n \t}\n \n \tprivate void updateClipping() {",
    "output": "Fix FlatLaf table header painting on hover"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/GFileSystemBase.java b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/GFileSystemBase.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/GFileSystemBase.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/GFileSystemBase.java\n@@ -16,8 +16,7 @@\n package ghidra.formats.gfilesystem;\n \n import java.io.*;\n-import java.util.Comparator;\n-import java.util.List;\n+import java.util.*;\n \n import ghidra.app.util.bin.ByteProvider;\n import ghidra.framework.Application;\n@@ -173,6 +172,7 @@ public GFile lookup(String path, Comparator<String> nameComp) throws IOException\n \t\tif (path == null || path.equals(\"/\")) {\n \t\t\treturn root;\n \t\t}\n+\t\tnameComp = Objects.requireNonNullElseGet(nameComp, this::getFilenameComparator);\n \n \t\tGFile current = root;\n \t\tString[] parts = path.split(\"/\");",
    "output": "Fix fs.lookup when namecomparator is null"
  },
  {
    "input": "diff --git a/Ghidra/Features/Jython/src/main/java/ghidra/jython/JythonUtils.java b/Ghidra/Features/Jython/src/main/java/ghidra/jython/JythonUtils.java\n--- a/Ghidra/Features/Jython/src/main/java/ghidra/jython/JythonUtils.java\n+++ b/Ghidra/Features/Jython/src/main/java/ghidra/jython/JythonUtils.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -27,7 +27,7 @@\n  */\n public class JythonUtils {\n \n-\tpublic static final String JYTHON_NAME = \"jython-2.7.3\";\n+\tpublic static final String JYTHON_NAME = \"jython-2.7.4\";\n \tpublic static final String JYTHON_CACHEDIR = \"jython_cachedir\";\n \tpublic static final String JYTHON_SRC = \"jython-src\";\n ",
    "output": "Upgrade Jython to 2.7.4"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/calltree/CallTreePlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/calltree/CallTreePlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/calltree/CallTreePlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/calltree/CallTreePlugin.java\n@@ -20,6 +20,7 @@\n import javax.swing.Icon;\n \n import docking.ActionContext;\n+import docking.ComponentProvider;\n import docking.action.DockingAction;\n import docking.action.MenuData;\n import ghidra.app.CorePluginPackage;\n@@ -205,6 +206,11 @@ private Function getFunction(ActionContext context) {\n \t\t\t}\n \t\t}\n \n+\t\tComponentProvider provider = context.getComponentProvider();\n+\t\tif (!(provider instanceof CallTreeProvider)) {\n+\t\t\treturn null; // only use the current location when in our provider\n+\t\t}\n+\n \t\treturn getFunction(currentLocation);\n \t}\n ",
    "output": "Fix Call Tree Plugin action appearing in odd places"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Gui/src/main/java/generic/theme/laf/FlatLookAndFeelManager.java b/Ghidra/Framework/Gui/src/main/java/generic/theme/laf/FlatLookAndFeelManager.java\n--- a/Ghidra/Framework/Gui/src/main/java/generic/theme/laf/FlatLookAndFeelManager.java\n+++ b/Ghidra/Framework/Gui/src/main/java/generic/theme/laf/FlatLookAndFeelManager.java\n@@ -43,9 +43,5 @@ protected void fixupLookAndFeelIssues() {\n \t\t// if \"Tree.showDefaultIcons\" is false.  We want the tree to display folder icons.\n \t\t//\n \t\tUIManager.put(\"Tree.showDefaultIcons\", Boolean.TRUE);\n-\n-\t\t// This fixes a bug in FlatScrollPaneUI at line 189 (version 3.2.1).  This can be removed\n-\t\t// in a future update if that code is fixed.\n-\t\tUIManager.put(\"ScrollPane.smoothScrolling\", Boolean.FALSE);\n \t}\n }",
    "output": "Upgrade flatlaf jar to 3.5.4"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java\n@@ -1142,7 +1142,7 @@ public void setSelection(ProgramSelection sel, EventTrigger trigger) {\n \t\t\t\t\tBigInteger index2 = loc2.getIndex();\n \t\t\t\t\tint fieldNum2 = layout.getEndRowFieldNum(loc2.getFieldNum());\n \t\t\t\t\tif (fieldNum2 >= layout2.getNumFields()) {\n-\t\t\t\t\t\tindex2 = loc2.getIndex().add(BigInteger.valueOf(layout2.getIndexSize()));\n+\t\t\t\t\t\tindex2 = loc2.getIndex().add(BigInteger.ONE);\n \t\t\t\t\t\tfieldNum2 = 0;\n \t\t\t\t\t}\n \t\t\t\t\tfieldSel.addRange(new FieldLocation(loc1.getIndex(), fieldNum1, 0, 0),",
    "output": "Fix bug exposed by change in ."
  },
  {
    "input": "diff --git a/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/gui/BSimSearchPlugin.java b/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/gui/BSimSearchPlugin.java\n--- a/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/gui/BSimSearchPlugin.java\n+++ b/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/gui/BSimSearchPlugin.java\n@@ -106,6 +106,7 @@ protected void init() {\n \tprivate void createActions() {\n \t\tnew ActionBuilder(\"BSim Overview\", getName()).menuPath(\"BSim\", \"Perform Overview...\")\n \t\t\t\t.helpLocation(new HelpLocation(getName(), \"BSim_Overview_Dialog\"))\n+\t\t\t\t.enabledWhen(c -> currentProgram != null)\n \t\t\t\t.onAction(c -> showOverviewDialog())\n \t\t\t\t.buildAndInstall(tool);\n \n@@ -115,6 +116,7 @@ private void createActions() {\n \t\t\t\t.toolBarIcon(ICON)\n \t\t\t\t.toolBarGroup(\"View\", \"Bsim\")\n \t\t\t\t.helpLocation(new HelpLocation(getName(), \"BSim_Search_Dialog\"))\n+\t\t\t\t.enabledWhen(c -> currentProgram != null)\n \t\t\t\t.onAction(c -> showSearchDialog(getSelectedFunctions()))\n \t\t\t\t.buildAndInstall(tool);\n ",
    "output": "Fix BSim action enablement for when no program is open"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugDirectory.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugDirectory.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugDirectory.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugDirectory.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -92,8 +92,9 @@ public class DebugDirectory implements StructConverter, ByteArrayConverter {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (sizeOfData > 0) {\n-\t\t\t\tif (!validator.checkPointer(pointerToRawData)) {\n-\t\t\t\t\tMsg.error(this, \"Invalid pointerToRawData \" + pointerToRawData);\n+\t\t\t\tif (!validator.checkPointer(pointerToRawData + sizeOfData - 1)) {\n+\t\t\t\t\tMsg.error(this, \"Invalid debug pointerToRawData + sizeOfData: 0x%x\"\n+\t\t\t\t\t\t\t.formatted(pointerToRawData + sizeOfData - 1));\n \t\t\t\t\tsizeOfData = 0;\n \t\t\t\t\treader.setPointerIndex(oldIndex);\n \t\t\t\t\treturn;",
    "output": "Improve bounds check in DebugDirectory.java"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearCmd.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearCmd.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearCmd.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/clear/ClearCmd.java\n@@ -77,10 +77,10 @@ protected ClearCmd(AddressSetView view, ClearOptions options, boolean sendIndivi\n \t\tthis.options = options;\n \t\tthis.sendIndividualEvents = sendIndividualEvents;\n \n-\t\tif (options == null) {\n-\t\t\toptions = new ClearOptions(false);\n-\t\t\toptions.setShouldClear(INSTRUCTIONS, true);\n-\t\t\toptions.setShouldClear(DATA, true);\n+\t\tif (this.options == null) {\n+\t\t\tthis.options = new ClearOptions(false);\n+\t\t\tthis.options.setShouldClear(INSTRUCTIONS, true);\n+\t\t\tthis.options.setShouldClear(DATA, true);\n \t\t}\n \t}\n ",
    "output": "Fix tests related to clear with options change"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/ClangLayoutController.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/ClangLayoutController.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/ClangLayoutController.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/ClangLayoutController.java\n@@ -206,8 +206,7 @@ private Color getTokenColor(ClangToken token) {\n \t\tif (token instanceof ClangFuncNameToken clangFunctionToken) {\n \t\t\tProgram program = decompilerPanel.getProgram();\n \t\t\tFunction function = DecompilerUtils.getFunction(program, clangFunctionToken);\n-\n-\t\t\tif (function instanceof UndefinedFunction) {\n+\t\t\tif (function == null || function instanceof UndefinedFunction) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tSymbol symbol = function.getSymbol();",
    "output": "Upgrade the color for resolved external functions"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/FileDataTypeManager.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/FileDataTypeManager.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/FileDataTypeManager.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/FileDataTypeManager.java\n@@ -110,7 +110,7 @@ public static FileDataTypeManager createFileArchive(File packedDbfile) throws IO\n \t * @param languageId valid language ID (see appropriate *.ldefs file for defined IDs)\n \t * @param compilerSpecId valid compiler spec ID which corresponds to the language ID.\n \t * @return data-type manager backed by the specified packedDbFile\n-\t * @returns DuplicateFileException if {@code packedDbFile} already exists\n+\t * @throws DuplicateFileException if {@code packedDbFile} already exists\n \t * @throws LanguageNotFoundException if specified {@code languageId} not defined. \n \t * @throws CompilerSpecNotFoundException if specified {@code compilerSpecId} is not defined \n \t * for the specified language. \n@@ -338,9 +338,8 @@ private void updateRootCategoryName(ResourceFile newFile, Category root) {\n \t\ttry {\n \t\t\troot.setName(newName);\n \t\t}\n-\t\tcatch (DuplicateNameException e) {\n-\t\t}\n-\t\tcatch (InvalidNameException e) {\n+\t\tcatch (InvalidNameException | DuplicateNameException e) {\n+\t\t\t// do nothing\n \t\t}\n \t}\n ",
    "output": "Fix javadoc error"
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb2/pdbreader/SymbolRecords.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb2/pdbreader/SymbolRecords.java\n--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb2/pdbreader/SymbolRecords.java\n+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb2/pdbreader/SymbolRecords.java\n@@ -135,6 +135,9 @@ private void determineCvSigValues() throws CancelledException, IOException, PdbE\n \t\tif (debugInfo == null) {\n \t\t\treturn;\n \t\t}\n+\t\tif (debugInfo.getModuleInformationList().size() == 0) {\n+\t\t\treturn;\n+\t\t}\n \t\t// We are assuming that first in the list is the one to look at for cases 1 and 2.\n \t\t//  If something else like lowest stream number, then need to change the logic.\n \t\tModuleInformation moduleInfo = debugInfo.getModuleInformationList().get(0);",
    "output": "Fix potential IndexOutOfBoundsException in PDB parsing"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/BinaryLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/BinaryLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/BinaryLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/BinaryLoader.java\n@@ -135,7 +135,7 @@ else if (optName.equals(OPTION_NAME_FILE_OFFSET)) {\n \t\t\t\t\t\tfileOffset = -1;\n \t\t\t\t\t}\n \t\t\t\t\tif (fileOffset < 0 || fileOffset >= origFileLength) {\n-\t\t\t\t\t\treturn \"File Offset must be greater than 0 and less than file length \" +\n+\t\t\t\t\t\treturn \"File Offset must be greater than or equal to 0 and less than file length \" +\n \t\t\t\t\t\t\torigFileLength + \" (0x\" + Long.toHexString(origFileLength) + \")\";\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -147,7 +147,7 @@ else if (optName.equals(OPTION_NAME_LEN)) {\n \t\t\t\t\t\tlength = -1;\n \t\t\t\t\t}\n \t\t\t\t\tif (length < 0 || length > origFileLength) {\n-\t\t\t\t\t\treturn \"Length must be greater than 0 and less than or equal to file length \" +\n+\t\t\t\t\t\treturn \"Length must be greater than or equal to 0 and less than or equal to file length \" +\n \t\t\t\t\t\t\torigFileLength + \" (0x\" + Long.toHexString(origFileLength) + \")\";\n \t\t\t\t\t}\n ",
    "output": "Make error messages match logic The logic in two places checks against `< 0` whose opposite is `>= 0` but the error text said \"... must be greater than 0\" I changed it to \"greater than or equal to 0\" to match the style of the second error but personally I prefer the more succinct \"... must be at least\""
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n@@ -549,14 +549,19 @@ static LoadSpec getLoadSpec(ByteProvider provider, Program program) {\n \t\tLoaderMap loaderMap = LoaderService.getSupportedLoadSpecs(provider,\n \t\t\tloader -> loader.getName().equalsIgnoreCase(program.getExecutableFormat()));\n \n+\t\tif (loaderMap.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n \t\tLoader loader = loaderMap.firstKey();\n \t\tif (loader == null) {\n \t\t\treturn null;\n \t\t}\n+\n+\t\tLanguageCompilerSpecPair programLcs = program.getLanguageCompilerSpecPair();\n \t\treturn loaderMap.get(loader)\n \t\t\t\t.stream()\n-\t\t\t\t.filter(\n-\t\t\t\t\te -> e.getLanguageCompilerSpec().equals(program.getLanguageCompilerSpecPair()))\n+\t\t\t\t.filter(e -> programLcs.equals(e.getLanguageCompilerSpec()))\n \t\t\t\t.findFirst()\n \t\t\t\t.orElse(null);\n \t}",
    "output": "Fix exception that could occur if LoadSpec wasn't found for some reason"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CycleGroup.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CycleGroup.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CycleGroup.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/CycleGroup.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -233,9 +233,10 @@ public ByteCycleGroup() {\n \n \tprivate static class FloatCycleGroup extends CycleGroup {\n \t\tpublic FloatCycleGroup() {\n-\t\t\tsuper(\"Cycle: float,double\");\n+\t\t\tsuper(\"Cycle: float,double,longdouble\");\n \t\t\taddDataType(new FloatDataType());\n \t\t\taddDataType(new DoubleDataType());\n+\t\t\taddDataType(new LongDoubleDataType());\n \n \t\t\tdefaultKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_F, 0);\n \t\t}",
    "output": "Add longdouble to FloatCycleGroup"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/SymbolSearcher.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/SymbolSearcher.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/SymbolSearcher.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/SymbolSearcher.java\n@@ -184,7 +184,9 @@ private void parseDynamic(Program program, List<ProgramLocation> locations) {\n \t\t\treturn;\n \t\t}\n \t\tSymbol s = program.getSymbolTable().getPrimarySymbol(address);\n-\t\taddSymbolIfMatches(s, locations);\n+\t\tif (s.isDynamic()) { // non-dynamic symbols have already been searched (ex, FUN_12345678)\n+\t\t\taddSymbolIfMatches(s, locations);\n+\t\t}\n \t}\n \n \tprivate void searchDefinedSymbols(Program program, List<ProgramLocation> locations) {",
    "output": "Fix Go To for functions with default names so that a table of choices is not shown"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeBank.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeBank.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeBank.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeBank.java\n@@ -210,7 +210,7 @@ public Iterator<VarnodeAST> locRange() {\n \t}\n \t\n \tpublic Iterator<VarnodeAST> locRange(AddressSpace spaceid) {\n-\t\tVarnodeAST searchvn1 = new VarnodeAST(spaceid.getAddress(0),0,0);\n+\t\tVarnodeAST searchvn1 = new VarnodeAST(spaceid.getMinAddress(),0,0);\n \t\tsearchvn1.setInput(true);\n \t\tVarnodeAST searchvn2 = new VarnodeAST(spaceid.getMaxAddress(), Integer.MAX_VALUE, 0);\n \t\treturn locTree.subSet(searchvn1, searchvn2).iterator();",
    "output": "Fix VarnodeBank.locRange(AddressSpace) not returning negative addresses"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java b/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java\n@@ -1385,15 +1385,20 @@ private synchronized void setNextFocusPlaceholder(ComponentPlaceholder placehold\n \t}\n \n \tprivate synchronized ComponentPlaceholder maybeGetPlaceholderToFocus() {\n+\n \t\tif (nextFocusedPlaceholder != null) {\n \t\t\tComponentPlaceholder temp = nextFocusedPlaceholder;\n \t\t\tsetNextFocusPlaceholder(null);\n \t\t\treturn temp;\n \t\t}\n \n \t\tKeyboardFocusManager kfm = KeyboardFocusManager.getCurrentKeyboardFocusManager();\n+\t\tComponent permanentFocusOwner = kfm.getPermanentFocusOwner();\n \t\tComponent focusOwner = kfm.getFocusOwner();\n-\t\tif (focusOwner == null) {\n+\n+\t\t// A null focus owner and a null permanent focus owner imply that Java did not know who  \n+\t\t// should get focus.  Make sure one of our widgets gets focus.\n+\t\tif (focusOwner == null && permanentFocusOwner == null) {\n \t\t\treturn findNextFocusedComponent();\n \t\t}\n \t\treturn null;\n@@ -1463,6 +1468,7 @@ private void setFocusedComponent(ComponentPlaceholder placeholder) {\n \t}\n \n \tprivate ComponentPlaceholder findNextFocusedComponent() {\n+\n \t\tIterator<ComponentPlaceholder> iterator = lastFocusedPlaceholders.iterator();\n \t\twhile (iterator.hasNext()) {\n \t\t\tComponentPlaceholder placeholder = iterator.next();\n@@ -1471,7 +1477,6 @@ private ComponentPlaceholder findNextFocusedComponent() {\n \t\t\t}\n \t\t\titerator.remove();\n \t\t}\n-\n \t\treturn getActivePlaceholder(defaultProvider);\n \t}\n ",
    "output": "Fix focus issue that caused new dialogs to sometimes have focus taken away"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java b/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java\n@@ -1100,6 +1100,11 @@ private class ShowProviderAction extends DockingAction {\n \t\t@Override\n \t\tpublic void actionPerformed(ActionContext context) {\n \n+\t\t\tif (isShowing()) {\n+\t\t\t\tsetVisible(false);\n+\t\t\t\treturn;\n+\t\t\t}\n+\n \t\t\tDockingWindowManager myDwm = DockingWindowManager.getInstance(getComponent());\n \t\t\tif (myDwm == null) {\n \t\t\t\t// this can happen when the tool loses focus",
    "output": "Upgrade the action to show a provider to be a toggle action, hiding the provider if already visible"
  },
  {
    "input": "diff --git a/Ghidra/Features/MicrosoftDemangler/src/main/java/ghidra/app/util/demangler/microsoft/MicrosoftDemangler.java b/Ghidra/Features/MicrosoftDemangler/src/main/java/ghidra/app/util/demangler/microsoft/MicrosoftDemangler.java\n--- a/Ghidra/Features/MicrosoftDemangler/src/main/java/ghidra/app/util/demangler/microsoft/MicrosoftDemangler.java\n+++ b/Ghidra/Features/MicrosoftDemangler/src/main/java/ghidra/app/util/demangler/microsoft/MicrosoftDemangler.java\n@@ -112,7 +112,7 @@ public DemangledDataType demangleType(MangledContext context) throws DemangledEx\n \t\t\tif (mdType == null) {\n \t\t\t\treturn null;\n \t\t\t}\n-\t\t\tString originalDemangled = item.toString();\n+\t\t\tString originalDemangled = mdType.toString();\n \t\t\tdemangler.getOutputOptions().setUseEncodedAnonymousNamespace(true);\n \t\t\tdataType = MicrosoftDemanglerUtil.convertToDemangledDataType(mdType, mangled,\n \t\t\t\toriginalDemangled);",
    "output": "Fix bug introduced into MicrosoftDemangler by"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/options/editor/FontPropertyEditor.java b/Ghidra/Framework/Docking/src/main/java/docking/options/editor/FontPropertyEditor.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/options/editor/FontPropertyEditor.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/options/editor/FontPropertyEditor.java\n@@ -158,7 +158,6 @@ private Component buildSizePanel() {\n \t\t\tsizeCombo =\n \t\t\t\tnew GComboBox<>(IntStream.rangeClosed(1, 72).boxed().toArray(Integer[]::new));\n \t\t\tsizeCombo.setMaximumRowCount(9);\n-\t\t\tsizeCombo.setMaximumRowCount(9);\n \t\t\tsizeCombo.addActionListener(actionListener);\n \t\t\tpanel.add(sizeCombo);\n ",
    "output": "Remove redundant duplicated line of code this line was there twice. 2nd will have no effect. probably cut and paste error? ``` sizeCombo.setMaximumRowCount(9); ```"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIWindowsClassRecoverer.java b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIWindowsClassRecoverer.java\n--- a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIWindowsClassRecoverer.java\n+++ b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIWindowsClassRecoverer.java\n@@ -2454,7 +2454,11 @@ public Integer getSingleVirtualParentOffset(RecoveredClass recoveredClass)\n \n \t\tMap<RecoveredClass, Integer> parentOffsetMap = getBaseClassOffsetMap(recoveredClass);\n \n-\t\treturn parentOffsetMap.get(virtualParentClasses.get(0));\n+\t\tif (parentOffsetMap != null) {\n+\t\t\treturn parentOffsetMap.get(virtualParentClasses.get(0));\n+\t\t}\n+\n+\t\treturn null;\n \n \t}\n ",
    "output": "Add null check to parentOffsetMap"
  },
  {
    "input": "diff --git a/GhidraBuild/MarkdownSupport/src/main/java/ghidra/markdown/MarkdownToHtml.java b/GhidraBuild/MarkdownSupport/src/main/java/ghidra/markdown/MarkdownToHtml.java\n--- a/GhidraBuild/MarkdownSupport/src/main/java/ghidra/markdown/MarkdownToHtml.java\n+++ b/GhidraBuild/MarkdownSupport/src/main/java/ghidra/markdown/MarkdownToHtml.java\n@@ -20,6 +20,7 @@\n import java.util.Map;\n \n import org.commonmark.Extension;\n+import org.commonmark.ext.footnotes.FootnotesExtension;\n import org.commonmark.ext.heading.anchor.HeadingAnchorExtension;\n import org.commonmark.node.Link;\n import org.commonmark.node.Node;\n@@ -49,8 +50,9 @@ public static void main(String[] args) throws Exception {\n \t\t\tthrow new Exception(\"First argument doesn't not end with .md\");\n \t\t}\n \n-\t\t// Setup the CommonMark Library with the needed \"anchor extension\" library\n-\t\tList<Extension> extensions = List.of(HeadingAnchorExtension.create());\n+\t\t// Setup the CommonMark Library with the needed extension libraries\n+\t\tList<Extension> extensions =\n+\t\t\tList.of(HeadingAnchorExtension.create(), FootnotesExtension.create());\n \t\tParser parser = Parser.builder().extensions(extensions).build();\n \t\tHtmlRenderer renderer = HtmlRenderer.builder()\n \t\t\t\t.extensions(extensions)",
    "output": "Add support for footnotes"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n@@ -63,7 +63,7 @@ public class ImporterUtilities {\n \t * TODO: will be refactored to use file_extension_icon.xml file info.\n \t */\n \tpublic static final GhidraFileFilter LOADABLE_FILES_FILTER = ExtensionFileFilter.forExtensions(\n-\t\t\"Loadable files\", \"exe\", \"dll\", \"obj\", \"drv\", \"bin\", \"hex\", \"o\", \"a\", \"so\", \"class\", \"lib\");\n+\t\t\"Loadable files\", \"exe\", \"dll\", \"obj\", \"drv\", \"bin\", \"hex\", \"o\", \"a\", \"so\", \"class\", \"lib\", \"dylib\");\n \n \t/**\n \t * File extension filter for well known 'container' files for GhidraFileChoosers.",
    "output": "Add macOS macho-o dynamic library file extension .dylib to file dialog filter The `LOADABLE_FILES_FILTER` `ExtensionFileFilter` contains well-known file extensions of loadable code files such as `.exe`, `.dll`, `.o`, etc but was missing `.dylib` used for dynamic libraries in Mach-O format on macOS"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -635,6 +635,13 @@ private void open() {\n \n \t\tOpenVersionedFileDialog<Program> openDialog =\n \t\t\tnew OpenVersionedFileDialog<>(tool, \"Open Program\", Program.class);\n+\n+\t\tDomainFile startFile = null;\n+\t\tProgram p = getCurrentProgram();\n+\t\tif (p != null) {\n+\t\t\tstartFile = p.getDomainFile();\n+\t\t}\n+\t\topenDialog.selectDomainFile(startFile);\n \t\topenDialog.setHelpLocation(new HelpLocation(HelpTopics.PROGRAM, \"Open_File_Dialog\"));\n \n \t\topenDialog.addOkActionListener(e -> {",
    "output": "Upgrade the Open Program dialog to select the current program"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Help/src/main/java/help/validator/LinkDatabase.java b/Ghidra/Framework/Help/src/main/java/help/validator/LinkDatabase.java\n--- a/Ghidra/Framework/Help/src/main/java/help/validator/LinkDatabase.java\n+++ b/Ghidra/Framework/Help/src/main/java/help/validator/LinkDatabase.java\n@@ -178,6 +178,11 @@ void addDuplicateAnchors(DuplicateAnchorCollection collection) {\n \t}\n \n \tpublic String getIDForLink(String target) {\n+\n+\t\tif (target.startsWith(JavaHelpValidator.EXTERNAL_PREFIX)) {\n+\t\t\treturn null; // the validator handles this later\n+\t\t}\n+\n \t\tPath path = Paths.get(target);\n \t\tPath file = Paths.get(target.split(\"#\")[0]);\n ",
    "output": "Fix for help building on Windows"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/ghidra_scripts/VSCodeProjectScript.java b/Ghidra/Features/Base/ghidra_scripts/VSCodeProjectScript.java\n--- a/Ghidra/Features/Base/ghidra_scripts/VSCodeProjectScript.java\n+++ b/Ghidra/Features/Base/ghidra_scripts/VSCodeProjectScript.java\n@@ -114,6 +114,8 @@ private void writeSettings(File installDir, File projectDir,\n \t\tjson.addProperty(\"java.import.gradle.enabled\", false);\n \t\tjson.addProperty(\"java.import.gradle.wrapper.enabled\", false);\n \t\tjson.addProperty(\"java.import.gradle.version\", gradleVersion);\n+\t\tjson.addProperty(\"java.format.settings.url\",\n+\t\t\tnew File(installDir, \"support/eclipse/GhidraEclipseFormatter.xml\").getAbsolutePath());\n \n \t\tJsonArray sourcePathArray = new JsonArray();\n \t\tjson.add(\"java.project.sourcePaths\", sourcePathArray);",
    "output": "Upgrade VSCodeProjectScript.java Pre-populate VSCodeProject settings with Ghidra formatter preferences."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/editor/EnumEditorProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/editor/EnumEditorProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/editor/EnumEditorProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/editor/EnumEditorProvider.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -272,6 +272,7 @@ private String getProviderSubTitle(DataType dataType) {\n \n \tprivate void createActions() {\n \t\thexDisplayAction = new ToggleActionBuilder(\"Toggle Hex Mode\", plugin.getName())\n+\t\t\t\t.helpLocation(new HelpLocation(HELP_TOPIC, \"Toggle_Hex_Mode\"))\n \t\t\t\t.menuPath(\"Show Enum Values in Hex\")\n \t\t\t\t.description(\"Toggles Enum value column to show values in hex or decimal\")\n \t\t\t\t.keyBinding(\"Shift-H\")",
    "output": "Add a help entry for an action missing help"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/ReferenceUtils.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/ReferenceUtils.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/ReferenceUtils.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/ReferenceUtils.java\n@@ -1097,6 +1097,9 @@ private static boolean matchesEnumField(Data data, DataType dt, FieldMatcher mat\n \t\tEnum enumm = (Enum) dt;\n \t\tList<String> names = getEnumNames(data, enumm);\n \t\tfor (String name : names) {\n+\t\t\tif (!enumm.contains(name)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tlong value = enumm.getValue(name);\n \t\t\tif (matcher.matches(name, (int) value)) {\n \t\t\t\treturn true;",
    "output": "Fix bug seen when searching for uses of an enum field"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/omf51/Omf51ModuleHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/omf51/Omf51ModuleHeader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/omf51/Omf51ModuleHeader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/omf51/Omf51ModuleHeader.java\n@@ -57,8 +57,8 @@ public DataType toDataType() throws DuplicateNameException, IOException {\n \t\tstruct.add(BYTE, \"type\", null);\n \t\tstruct.add(WORD, \"length\", null);\n \t\tstruct.add(moduleName.toDataType(), \"name\", null);\n-\t\tstruct.add(BYTE, \"padding\", null);\n \t\tstruct.add(BYTE, \"TRN ID\", null);\n+\t\tstruct.add(BYTE, \"padding\", null);\n \t\tstruct.add(BYTE, \"checksum\", null);\n \n \t\tstruct.setCategoryPath(new CategoryPath(OmfUtils.CATEGORY_PATH));",
    "output": "Upgrade Omf51ModuleHeader.java TRN ID and padding bytes were reversed"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/NextHighlightedTokenAction.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/NextHighlightedTokenAction.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/NextHighlightedTokenAction.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/NextHighlightedTokenAction.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -33,7 +33,7 @@\n public class NextHighlightedTokenAction extends AbstractDecompilerAction {\n \n \tpublic NextHighlightedTokenAction() {\n-\t\tsuper(\"Next Highlihted Token\");\n+\t\tsuper(\"Next Highlighted Token\");\n \n \t\tsetPopupMenuData(new MenuData(new String[] { \"Next Highlight\" }, \"Decompile\"));\n \t\tsetKeyBindingData(new KeyBindingData(\"Ctrl period\"));",
    "output": "Fix bad action name"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/ghidra_scripts/VSCodeProjectScript.java b/Ghidra/Features/Base/ghidra_scripts/VSCodeProjectScript.java\n--- a/Ghidra/Features/Base/ghidra_scripts/VSCodeProjectScript.java\n+++ b/Ghidra/Features/Base/ghidra_scripts/VSCodeProjectScript.java\n@@ -237,7 +237,7 @@ protected void run() throws Exception {\n \tprivate void writeSampleModule(File installDir, File projectDir) throws IOException {\n \t\t// Copy Skeleton and rename module\n \t\tString skeleton = \"Skeleton\";\n-\t\tFile skeletonDir = new File(installDir, \"Extensions/Ghidra/skeleton\");\n+\t\tFile skeletonDir = new File(installDir, \"Extensions/Ghidra/Skeleton\");\n \t\tFileUtils.copyDirectory(skeletonDir, projectDir);\n \n \t\t// Rename package",
    "output": "Fix a typo in VSCodeProjectScript.java that resulted in the \"Extensions/Ghidra/Skeleton\" directory not being found."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/LoadLibrariesOptionsDialog.java b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/LoadLibrariesOptionsDialog.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/LoadLibrariesOptionsDialog.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/LoadLibrariesOptionsDialog.java\n@@ -80,11 +80,16 @@ protected void okCallback() {\n \t\t\t\t\n \t\t\t\t// Display results\n \t\t\t\tString importMessages = messageLog.toString();\n-\t\t\t\tif (!Loader.loggingDisabled && !importMessages.isEmpty()) {\n-\t\t\t\t\tMsg.info(ImporterUtilities.class, TITLE + \":\\n\" + importMessages);\n+\t\t\t\tif (!importMessages.isEmpty()) {\n+\t\t\t\t\tif (!Loader.loggingDisabled) {\n+\t\t\t\t\t\tMsg.info(ImporterUtilities.class, TITLE + \":\\n\" + importMessages);\n+\t\t\t\t\t}\n+\t\t\t\t\tMultiLineMessageDialog.showModalMessageDialog(null, TITLE, \"Results\",\n+\t\t\t\t\t\timportMessages, MultiLineMessageDialog.INFORMATION_MESSAGE);\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tMsg.showInfo(this, null, TITLE, \"The program has no libraries.\");\n \t\t\t\t}\n-\t\t\t\tMultiLineMessageDialog.showModalMessageDialog(null, TITLE, \"Results\",\n-\t\t\t\t\timportMessages, MultiLineMessageDialog.INFORMATION_MESSAGE);\n \n \t\t\t\tloadResults.release(consumer);\n \t\t\t}",
    "output": "Improve Load Libraries results dialog for programs with no libraries"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Gui/src/main/java/generic/theme/laf/LookAndFeelManager.java b/Ghidra/Framework/Gui/src/main/java/generic/theme/laf/LookAndFeelManager.java\n--- a/Ghidra/Framework/Gui/src/main/java/generic/theme/laf/LookAndFeelManager.java\n+++ b/Ghidra/Framework/Gui/src/main/java/generic/theme/laf/LookAndFeelManager.java\n@@ -254,13 +254,22 @@ public void unRegisterFont(JComponent component, String fontId) {\n \n \tprivate void checkForAlreadyRegistered(Component component, String newFontId) {\n \t\tString existingFontId = componentToIdMap.get(component);\n-\t\tif (existingFontId != null) {\n-\t\t\tMsg.warn(this, \"\"\"\n-\t\t\t\t\tComponent has a Font ID registered more than once. \\\n-\t\t\t\t\tPreviously registered ID: '%s'.  Newly registered ID: '%s'.\n-\t\t\t\t\t\t\"\"\".formatted(existingFontId, newFontId),\n-\t\t\t\tReflectionUtilities.createJavaFilteredThrowable());\n+\t\tif (existingFontId == null) {\n+\t\t\treturn; // never registered before\n \t\t}\n+\n+\t\tif (component instanceof FontChangeListener) {\n+\t\t\t// Special Case: this allows clients to control how they listen to font changes.  We \n+\t\t\t// have guilty knowledge that some clients will use one listener to listen to multiple\n+\t\t\t// font ids, so don't print a warning for this case.\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tMsg.warn(this, \"\"\"\n+\t\t\t\tComponent has a Font ID registered more than once. \\\n+\t\t\t\tPreviously registered ID: '%s'.  Newly registered ID: '%s'.\n+\t\t\t\t\t\"\"\".formatted(existingFontId, newFontId),\n+\t\t\tReflectionUtilities.createJavaFilteredThrowable());\n \t}\n \n \tprivate Font toUiResource(Font font) {",
    "output": "Fix warning for recent font changes"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/strings/EncodedStringsDialog.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/strings/EncodedStringsDialog.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/strings/EncodedStringsDialog.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/strings/EncodedStringsDialog.java\n@@ -366,7 +366,7 @@ private void buildPreviewTableComponents() {\n \t\ttableModel = new EncodedStringsTableModel(program, selectedAddresses);\n \t\ttableModel.addTableModelListener(e -> {\n \t\t\tInteger rowNum = rowToSelect.getAndSet(null);\n-\t\t\tif (rowNum != null) {\n+\t\t\tif (rowNum != null && rowNum < tableModel.getRowCount()) {\n \t\t\t\ttable.selectRow(rowNum);\n \t\t\t\ttable.requestFocusInWindow();\n \t\t\t}\n@@ -848,7 +848,7 @@ private void selectedRowChange() {\n \t\tint rowCount = table.getRowCount();\n \t\tint selectedRowCount = table.getSelectedRowCount();\n \t\tsetCreateButtonInfo(rowCount, selectedRowCount);\n-\t\tif (selectedRowCount == 1) {\n+\t\tif (selectedRowCount == 1 && tableModel.getProgram() != null) {\n \t\t\tint[] selectedRows = table.getSelectedRows();\n \t\t\ttable.navigate(selectedRows[0], 0 /* location col */);\n \t\t}",
    "output": "Fix Encoded Strings dialog error when closing"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ExportDataDirectory.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ExportDataDirectory.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ExportDataDirectory.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/ExportDataDirectory.java\n@@ -216,7 +216,7 @@ public void markup(Program program, boolean isBinary, TaskMonitor monitor, Messa\n \t\t\t}\n \t\t\tPeUtils.createData(program, address, IBO32, log);\n \t\t\tData data = program.getListing().getDataAt(address);\n-\t\t\tif (data == null) {\n+\t\t\tif (data == null || !(data.getDataType() instanceof IBO32DataType)) {\n \t\t\t\tMsg.warn(this, \"Invalid or missing data at \" + address);\n \t\t\t\tbreak;\n \t\t\t}",
    "output": "Fix potential ClassCasatException in ExportDataDirectory.java"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java\n--- a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java\n+++ b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassHelper.java\n@@ -4527,7 +4527,7 @@ else if (vfunctionClass.getShortenedTemplateName() != null &&\n \t\t\t// apply the structure. It has to be one or the other and the correct length\n \t\t\t// because of the check at the beginning of the script that checked for either\n \t\t\t// array or structure of pointers and got size from them initially\n-\t\t\tapi.clearListing(vftableAddress);\n+\t\t\tapi.clearListing(vftableAddress, vftableAddress.add(vftableStruct.getLength() - 1));\n \t\t\tapi.createData(vftableAddress, vftableStruct);\n \n \t\t}",
    "output": "Fix code unit insertion issue"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/DataTypeLocationDescriptor.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/DataTypeLocationDescriptor.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/DataTypeLocationDescriptor.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/DataTypeLocationDescriptor.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -288,7 +288,7 @@ else if (label.endsWith(\"*\") && label.startsWith(paramName)) {\n \t\t\t}\n \n \t\t\tString variableName = paramParts[paramParts.length - 1];\n-\t\t\tint variableNameOffset = parameterDeclaration.indexOf(variableName);\n+\t\t\tint variableNameOffset = parameterDeclaration.lastIndexOf(variableName);\n \t\t\tif (label.length() > variableNameOffset) {\n \t\t\t\treturn label.substring(0, variableNameOffset - 1); // -1 for the space before the name\n \t\t\t}",
    "output": "Fix exception in creating highlights"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/GoToQuery.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/GoToQuery.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/GoToQuery.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/GoToQuery.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -510,7 +510,7 @@ private Namespace getScope(Program program, Namespace parent, String scopeName)\n \t\tint colonIndex = scopeName.lastIndexOf(\"::\");\n \t\tif (colonIndex >= 0) {\n \t\t\tString parentScopeName = scopeName.substring(0, colonIndex);\n-\t\t\tscopeName = scopeName.substring(colonIndex + 1);\n+\t\t\tscopeName = scopeName.substring(colonIndex + 2);\n \t\t\tparent = getScope(program, parent, parentScopeName);\n \t\t\tif (parent == null) {\n \t\t\t\treturn null;",
    "output": "Fix bug in goto processing to handle multiple level namespaces"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiTarget.java b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiTarget.java\n--- a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiTarget.java\n+++ b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/service/tracermi/TraceRmiTarget.java\n@@ -809,12 +809,14 @@ protected class Matches {\n \n \t\tpublic MatchedMethod getBest(String name, ActionName action,\n \t\t\t\tSupplier<List<? extends MethodMatcher>> preferredSupplier) {\n-\t\t\treturn map.computeIfAbsent(name, n -> chooseBest(action, preferredSupplier.get()));\n+\t\t\treturn getBest(name, action, preferredSupplier.get());\n \t\t}\n \n \t\tpublic MatchedMethod getBest(String name, ActionName action,\n \t\t\t\tList<? extends MethodMatcher> preferred) {\n-\t\t\treturn map.computeIfAbsent(name, n -> chooseBest(action, preferred));\n+\t\t\tsynchronized (map) {\n+\t\t\t\treturn map.computeIfAbsent(name, n -> chooseBest(action, preferred));\n+\t\t\t}\n \t\t}\n \n \t\tprivate MatchedMethod chooseBest(ActionName name, List<? extends MethodMatcher> preferred) {",
    "output": "Fix concurrency issue in TraceRmiTarget."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/equate/ConvertToSignedHexAction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/equate/ConvertToSignedHexAction.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/equate/ConvertToSignedHexAction.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/equate/ConvertToSignedHexAction.java\n@@ -4,9 +4,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -28,7 +28,9 @@ public ConvertToSignedHexAction(EquatePlugin plugin) {\n \n \t@Override\n \tprotected String getMenuName(Program program, Scalar scalar, boolean isData) {\n-\t\treturn getStandardLengthString(\"Signed Hex:\") + convertToString(program, scalar, isData);\n+\t\treturn isData\n+\t\t\t\t? null\n+\t\t\t\t: getStandardLengthString(\"Signed Hex:\") + convertToString(program, scalar, false);\n \t}\n \n \t@Override",
    "output": "Fix 'null' in convert menu -> signed hex on int data items"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/gui/tracermi/launcher/ScriptAttributesParser.java b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/gui/tracermi/launcher/ScriptAttributesParser.java\n--- a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/gui/tracermi/launcher/ScriptAttributesParser.java\n+++ b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/gui/tracermi/launcher/ScriptAttributesParser.java\n@@ -383,7 +383,13 @@ public static void processArguments(List<String> commandLine, Map<String, String\n \t\t\tString key = ent.getKey();\n \t\t\tif (key.startsWith(PREFIX_ENV)) {\n \t\t\t\tString varName = key.substring(PREFIX_ENV.length());\n-\t\t\t\tenv.put(varName, Objects.toString(ent.getValue().get(args).val()));\n+\t\t\t\tValStr<?> val = ent.getValue().get(args);\n+\t\t\t\tif (val == null || val.val() == null) {\n+\t\t\t\t\tenv.put(varName, \"\");\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tenv.put(varName, Objects.toString(val.val()));\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}",
    "output": "Fix null in dialog issue."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/FindReferencesToStructureFieldAction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/FindReferencesToStructureFieldAction.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/FindReferencesToStructureFieldAction.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/FindReferencesToStructureFieldAction.java\n@@ -70,7 +70,7 @@ private String getFieldName() {\n \t@Override\n \tpublic boolean isEnabledForContext(ActionContext context) {\n \t\tsetEnabled(false);\n-\t\tif (!hasIncompleteFieldEntry()) {\n+\t\tif (hasIncompleteFieldEntry()) {\n \t\t\treturn false;\n \t\t}\n \t\tif (model.getSelectedComponentRows().length != 1) {",
    "output": "Fix action enablement"
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbAddressManager.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbAddressManager.java\n--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbAddressManager.java\n+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbAddressManager.java\n@@ -358,6 +358,9 @@ public long getLength() {\n \tprivate void determineMemoryBlocks() throws CancelledException {\n \t\tAbstractPdb pdb = applicator.getPdb();\n \t\tPdbDebugInfo debugInfo = pdb.getDebugInfo();\n+\t\tif(debugInfo == null) {\n+\t\t\treturn;\n+\t\t}\n \t\tsegmentMapList = debugInfo.getSegmentMapList();\n \t\tif (debugInfo instanceof PdbNewDebugInfo) {\n \t\t\tDebugData debugData = ((PdbNewDebugInfo) debugInfo).getDebugData();",
    "output": "Fix restore debugInfo null check Restore the fix implemented by d86b60e6b2468423f853c591d1df9cd37b53c147"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/xml/SymbolTableXmlMgr.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/xml/SymbolTableXmlMgr.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/xml/SymbolTableXmlMgr.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/xml/SymbolTableXmlMgr.java\n@@ -197,7 +197,7 @@ else if (passNumber == 2) {\n \t\t\tString addrStr = element.getAttribute(\"ADDRESS\");\n \t\t\tString namespace = element.getAttribute(\"NAMESPACE\");\n \t\t\tif (namespace != null && namespace.endsWith(\"::\")) {\n-\t\t\t\tnamespace = namespace.substring(namespace.length() - 2);\n+\t\t\t\tnamespace = namespace.substring(0, namespace.length() - 2);\n \t\t\t}\n \t\t\tString primary = element.getAttribute(\"PRIMARY\");\n \t\t\tString sourceTypeString = element.getAttribute(\"SOURCE_TYPE\");\n@@ -233,13 +233,8 @@ else if (localNamespace != null &&\n \t\t\t\tscope = localNamespace;\n \t\t\t}\n \t\t\telse if (namespace != null && namespace.length() != 0) {\n-\t\t\t\tif (program.getGlobalNamespace().equals(localNamespace)) {\n-\t\t\t\t\tscope = NamespaceUtils.createNamespaceHierarchy(namespace,\n-\t\t\t\t\t\tprogram.getGlobalNamespace(), program, sourceType);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tname = namespace + name;\n-\t\t\t\t}\n+\t\t\t\tscope = NamespaceUtils.createNamespaceHierarchy(namespace,\n+\t\t\t\t\tprogram.getGlobalNamespace(), program, sourceType);\n \t\t\t}\n \n \t\t\tSymbol s = symbolTable.getPrimarySymbol(addr);",
    "output": "Fix wrong namespaces when using XML imports"
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbDataTypeParser.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbDataTypeParser.java\n--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbDataTypeParser.java\n+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbDataTypeParser.java\n@@ -184,6 +184,17 @@ public WrappedDataType findDataType(String datatype) throws CancelledException {\n \n \t\tString dataTypeName = datatype;\n \n+\t\t// Handle potential malformed datatypes where some datatype is implied\n+\t\t// *\n+\t\t// **\n+\t\t// [16]\n+\t\tif (dataTypeName.startsWith(\"*\") || dataTypeName.startsWith(\"[\")) {\n+\t\t\t// prepend undefined since intent is some datatype\n+\t\t\tMsg.warn(this, \"dataTypeName \\\"\" + dataTypeName + \n+\t\t\t\t\"\\\" references a pointer or array without a declared datatype; assuming undefined\");\n+\t\t\tdataTypeName = \"undefined\" + dataTypeName;\n+\t\t}\n+\n \t\t// Example type representations:\n \t\t// char *[2][3]     pointer(array(array(char,3),2))\n \t\t// char *[2][3] *   pointer(array(array(pointer(char),3),2))",
    "output": "Fix parsing of recoverable malformed datatypes MSVC sometimes generates pdbs where there is an implied datatype such as pointers `*` or arrays `[16]`. While the actual datatype is unknown, Ghidra has undefined to cover this use case. This avoids an error on PDB import which would have a cryptic message: \"Symbol list must contain at least one symbol name!\" without any info on what caused the issue."
  },
  {
    "input": "diff --git a/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/Repository.java b/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/Repository.java\n--- a/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/Repository.java\n+++ b/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/Repository.java\n@@ -424,7 +424,7 @@ boolean removeUser(String username) throws IOException {\n \t\tsynchronized (fileSystem) {\n \t\t\tif (userMap.remove(username) != null) {\n \t\t\t\twriteUserList(userMap, anonymousAccessAllowed);\n-\t\t\t\tlog.info(\"User access d from repository '\" + name + \"': \" + username);\n+\t\t\t\tlog.info(\"User access removed from repository '\" + name + \"': \" + username);\n \t\t\t\treturn true;\n \t\t\t}\n \t\t\treturn false;",
    "output": "Fix bugs in logging statement"
  },
  {
    "input": "diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/datastruct/PrivatelyQueuedListener.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/datastruct/PrivatelyQueuedListener.java\n--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/datastruct/PrivatelyQueuedListener.java\n+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/util/datastruct/PrivatelyQueuedListener.java\n@@ -32,16 +32,16 @@ public class PrivatelyQueuedListener<P> {\n \tprivate ListenerErrorHandler errorHandler =\n \t\tDataStructureErrorHandlerFactory.createListenerErrorHandler();\n \n-\tprotected class ListenerHandler implements InvocationHandler {\n-\t\tprivate static final Method OBJECT_HASHCODE;\n-\t\tstatic {\n-\t\t\ttry {\n-\t\t\t\tOBJECT_HASHCODE = Object.class.getMethod(\"hashCode\");\n-\t\t\t}\n-\t\t\tcatch (NoSuchMethodException | SecurityException e) {\n-\t\t\t\tthrow new AssertionError(e);\n-\t\t\t}\n-\t\t}\n+protected class ListenerHandler implements InvocationHandler {\n+    private static final Method OBJECT_HASHCODE = initObjectHashCode();\n+\n+    private static Method initObjectHashCode() {\n+        try {\n+            return Object.class.getMethod(\"hashCode\");\n+        } catch (NoSuchMethodException | SecurityException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\t\n \t\tprotected final Class<P> iface;\n \n \t\tpublic ListenerHandler(Class<P> iface) {",
    "output": "Fix initialization of OBJECT_HASHCODE in PrivatelyQueuedListener"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/ContextCache.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/ContextCache.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/ContextCache.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/ContextCache.java\n@@ -26,9 +26,6 @@ public class ContextCache {\n \tprivate int context_size = 0;\n \tprivate Register contextBaseRegister = null;\n \n-\tprivate BigInteger lastContextValue;\n-\tprivate int[] lastContextWords;\n-\n \tpublic ContextCache() {\n \t}\n \n@@ -57,10 +54,7 @@ public void getContext(ProcessorContextView ctx, int[] buf) {\n \t\t}\n \t}\n \n-\tprivate synchronized int[] getWords(BigInteger value) {\n-\t\tif (value.equals(lastContextValue)) {\n-\t\t\treturn lastContextWords;\n-\t\t}\n+\tprivate int[] getWords(BigInteger value) {\n \n \t\tint[] words = new int[context_size];\n \t\tbyte[] bytes = value.toByteArray();\n@@ -73,8 +67,6 @@ private synchronized int[] getWords(BigInteger value) {\n \t\t\t}\n \t\t\twords[i] = word;\n \t\t}\n-\t\tlastContextValue = value;\n-\t\tlastContextWords = words;\n \t\treturn words;\n \t}\n ",
    "output": "Remove (useless?) cache of lastContext from ContextCache"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n@@ -842,7 +842,8 @@ public List<Address> processChainedFixups(List<String> libraryPaths) throws Exce\n \t\t\tSection threadStartsSection =\n \t\t\t\tmachoHeader.getSection(SegmentNames.SEG_TEXT, SectionNames.THREAD_STARTS);\n \n-\t\t\tif (chainStartsSection != null) {\n+\t\t\tif (chainStartsSection != null && chainStartsSection.getAddress() != 0 &&\n+\t\t\t\tchainStartsSection.getSize() != 0) {\n \t\t\t\treader.setPointerIndex(chainStartsSection.getOffset());\n \t\t\t\tDyldChainedStartsOffsets chainedStartsOffsets =\n \t\t\t\t\tnew DyldChainedStartsOffsets(reader);\n@@ -852,7 +853,8 @@ public List<Address> processChainedFixups(List<String> libraryPaths) throws Exce\n \t\t\t\t\t\timagebase.getOffset(), symbolTable, log, monitor));\n \t\t\t\t}\n \t\t\t}\n-\t\t\telse if (threadStartsSection != null) {\n+\t\t\telse if (threadStartsSection != null && threadStartsSection.getAddress() != 0 &&\n+\t\t\t\tthreadStartsSection.getSize() != 0) {\n \t\t\t\tAddress threadSectionStart = space.getAddress(threadStartsSection.getAddress());\n \t\t\t\tAddress threadSectionEnd =\n \t\t\t\t\tthreadSectionStart.add(threadStartsSection.getSize() - 1);",
    "output": "Fix an issue with importing Mach-O binaries that have an empty \"__chain_starts\" section"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n@@ -401,7 +401,8 @@ public void updateUI() {\n \t}\n \n \tprivate void initializeCursorBlinking() {\n-\t\tboolean blinkingCursors = ThemeManager.getInstance().isBlinkingCursors();\n+\t\tThemeManager themeManager = ThemeManager.getInstance();\n+\t\tboolean blinkingCursors = themeManager != null ? themeManager.isBlinkingCursors() : true;\n \t\tsetBlinkCursor(blinkingCursors);\n \t}\n ",
    "output": "Fix accessibility test after cursor blinking change"
  },
  {
    "input": "diff --git a/Ghidra/Features/ProgramDiff/src/main/java/ghidra/app/plugin/core/diff/SaveApplySettingsAction.java b/Ghidra/Features/ProgramDiff/src/main/java/ghidra/app/plugin/core/diff/SaveApplySettingsAction.java\n--- a/Ghidra/Features/ProgramDiff/src/main/java/ghidra/app/plugin/core/diff/SaveApplySettingsAction.java\n+++ b/Ghidra/Features/ProgramDiff/src/main/java/ghidra/app/plugin/core/diff/SaveApplySettingsAction.java\n@@ -15,8 +15,6 @@\n  */\n package ghidra.app.plugin.core.diff;\n \n-import javax.swing.JComponent;\n-\n import docking.ActionContext;\n import docking.action.DockingAction;\n import docking.action.ToolBarData;\n@@ -53,9 +51,7 @@ class SaveApplySettingsAction extends DockingAction {\n \n \t@Override\n \tpublic boolean isEnabledForContext(ActionContext context) {\n-\t\tObject contextObject = context.getContextObject();\n-\t\tJComponent applySettingsComponent = settingsProvider.getComponent();\n-\t\treturn contextObject == applySettingsComponent;\n+\t\treturn true;\n \t}\n \n \t@Override",
    "output": "Fix save option on diff apply settings"
  },
  {
    "input": "diff --git a/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/MDMang.java b/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/MDMang.java\n--- a/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/MDMang.java\n+++ b/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/MDMang.java\n@@ -165,6 +165,7 @@ public MDDataType demangleType(boolean errorOnRemainingChars) throws MDException\n \t\tif (mangled == null) {\n \t\t\tthrow new MDException(\"MDMang: Mangled string is null.\");\n \t\t}\n+\t\tinitState();\n \t\tpushContext();\n \t\tif (peek() != '.') {\n \t\t\tthrow new MDException(\"MDMang: Mangled string is not that of a type.\");",
    "output": "Fix for MDMang demangleType"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryLookupTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryLookupTable.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryLookupTable.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryLookupTable.java\n@@ -212,15 +212,17 @@ synchronized static LibrarySymbolTable getSymbolTable(String dllName, int size)\n \t * \n \t * @param dllName The DLL name (including extension)\n \t * @param size The architecture size of the DLL (e.g., 32 or 64).\n-\t * @param log The message log\n+\t * @param log The message log (could be null)\n \t * @return LibrarySymbolTable associated with dllName\n \t */\n \tsynchronized static LibrarySymbolTable getSymbolTable(String dllName, int size,\n \t\t\tMessageLog log) {\n \t\tString cacheKey = LibrarySymbolTable.getCacheKey(dllName, size);\n \t\tLibrarySymbolTable symTab = cacheMap.get(cacheKey);\n \t\tif (symTab != null) {\n-\t\t\tlog.appendMsg(\"Applying cached symbols from \" + dllName);\n+\t\t\tif (log != null) {\n+\t\t\t\tlog.appendMsg(\"Applying cached symbols from \" + dllName);\n+\t\t\t}\n \t\t\treturn symTab;\n \t\t}\n ",
    "output": "Add null log check in LibraryLookupTable.java"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n@@ -65,7 +65,7 @@ private String getGdtUniversalId(ResourceFile gdtFile) {\n \t\tFileDataTypeManager dtm = null;\n \t\ttry {\n \t\t\tdtm = FileDataTypeManager.openFileArchive(gdtFile, false);\n-\t\t\tassertEquals(ArchiveWarning.NONE, dtm.getWarning());\n+\t\t\tassertEquals(dtm.getWarningMessage(true), ArchiveWarning.NONE, dtm.getWarning());\n \t\t\treturn dtm.getUniversalID().toString();\n \t\t}\n \t\tcatch (IOException e) {",
    "output": "Upgrade gdt archives to reflect x86 v4 revision"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java\n@@ -28,8 +28,8 @@\n import ghidra.app.util.bin.BinaryReader;\n import ghidra.app.util.bin.ByteProvider;\n import ghidra.app.util.bin.format.elf.info.ElfInfoItem.ItemWithAddress;\n-import ghidra.app.util.bin.format.golang.GoBuildInfo;\n import ghidra.app.util.bin.format.golang.GoBuildId;\n+import ghidra.app.util.bin.format.golang.GoBuildInfo;\n import ghidra.app.util.bin.format.golang.rtti.GoRttiMapper;\n import ghidra.app.util.bin.format.mz.DOSHeader;\n import ghidra.app.util.bin.format.pe.*;\n@@ -433,7 +433,7 @@ private void processDelayImports(OptionalHeader optionalHeader, Program program,\n \t\t\treturn;\n \t\t}\n \n-\t\tlog.appendMsg(\"Delay imports detected...\");\n+\t\tlog.appendMsg(\"Delay imports detected\");\n \n \t\tAddressSpace space = program.getAddressFactory().getDefaultAddressSpace();\n \t\tListing listing = program.getListing();",
    "output": "Fix print in PeLoader"
  },
  {
    "input": "diff --git a/Ghidra/Features/GraphFunctionCalls/src/main/java/functioncalls/graph/view/FcgComponent.java b/Ghidra/Features/GraphFunctionCalls/src/main/java/functioncalls/graph/view/FcgComponent.java\n--- a/Ghidra/Features/GraphFunctionCalls/src/main/java/functioncalls/graph/view/FcgComponent.java\n+++ b/Ghidra/Features/GraphFunctionCalls/src/main/java/functioncalls/graph/view/FcgComponent.java\n@@ -32,9 +32,6 @@\n  */\n public class FcgComponent extends GraphComponent<FcgVertex, FcgEdge, FunctionCallGraph> {\n \n-\t// our parent stores a reference to this graph, but we do it here to maintain its type\n-\tprivate FunctionCallGraph fcGraph;\n-\n \tprivate FcgVertexPaintTransformer vertexPaintTransformer =\n \t\tnew FcgVertexPaintTransformer(FcgVertex.DEFAULT_VERTEX_SHAPE_COLOR);\n \n@@ -55,7 +52,7 @@ public class FcgComponent extends GraphComponent<FcgVertex, FcgEdge, FunctionCal\n \n \t@Override\n \tprotected FcgVertex getInitialVertex() {\n-\t\treturn fcGraph.getSource();\n+\t\treturn graph.getSource();\n \t}\n \n \t@Override\n@@ -91,13 +88,6 @@ protected void decorateSatelliteViewer(SatelliteGraphViewer<FcgVertex, FcgEdge>\n \t\tedgeRenderer.setDrawColorTransformer(satelliteEdgePaintTransformer);\n \t}\n \n-\t@Override\n-\tpublic void dispose() {\n-\n-\t\tfcGraph = null;\n-\t\tsuper.dispose();\n-\t}\n-\n \t@Override // open access for testing\n \tpublic VisualGraphViewUpdater<FcgVertex, FcgEdge> getViewUpdater() {\n \t\treturn super.getViewUpdater();",
    "output": "Fix issue loading FCG when starting fully-zoomed in"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemIndexHelper.java b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemIndexHelper.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemIndexHelper.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemIndexHelper.java\n@@ -72,6 +72,7 @@ static class FileData<METADATATYPE> {\n \tpublic FileSystemIndexHelper(GFileSystem fs, FSRLRoot fsFSRL) {\n \t\tGFile rootGFile = GFileImpl.fromFSRL(fs, null, fsFSRL.withPath(\"/\"), true, -1);\n \t\trootDir = new FileData<>(rootGFile, null, -1);\n+\t\tfileToEntryMap.put(rootDir.file, rootDir);\n \t\tdirectoryToListing.put(rootDir.file, new HashMap<>());\n \t}\n ",
    "output": "Fix unique file number generation for duplicate files The size of the map was used as the unique id for file that didn't have an explicit file number. change accidentally disturbed this and was creating filenames that didn't match previous logic."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java\n@@ -26,6 +26,7 @@\n import ghidra.app.util.bin.format.mz.*;\n import ghidra.app.util.importer.MessageLog;\n import ghidra.program.database.mem.FileBytes;\n+import ghidra.program.database.module.TreeManager;\n import ghidra.program.model.address.*;\n import ghidra.program.model.data.DataType;\n import ghidra.program.model.data.DataUtilities;\n@@ -314,6 +315,10 @@ private void adjustSegmentStarts(Program program, TaskMonitor monitor) throws Ex\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\n+\t\t// Recreate the Program Tree since it may now be out of sync\n+\t\tprogram.getListing().removeTree(TreeManager.DEFAULT_TREE_NAME);\n+\t\tprogram.getListing().createRootModule(TreeManager.DEFAULT_TREE_NAME);\n \t}\n \n \tprivate void processRelocations(Program program, SegmentedAddressSpace space, MzExecutable mz,",
    "output": "Fix MzLoader Program Tree"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/RegisterLocationTrackingSpec.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/RegisterLocationTrackingSpec.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/RegisterLocationTrackingSpec.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/RegisterLocationTrackingSpec.java\n@@ -22,8 +22,7 @@\n import ghidra.program.model.lang.Register;\n import ghidra.program.model.lang.RegisterValue;\n import ghidra.program.util.ProgramLocation;\n-import ghidra.trace.model.Trace;\n-import ghidra.trace.model.TraceAddressSnapRange;\n+import ghidra.trace.model.*;\n import ghidra.trace.model.guest.TracePlatform;\n import ghidra.trace.model.memory.TraceMemorySpace;\n import ghidra.trace.model.memory.TraceMemoryState;\n@@ -65,7 +64,8 @@ default Address computeTraceAddress(ServiceProvider provider, DebuggerCoordinate\n \t\tif (reg == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tif (!thread.getLifespan().contains(snap)) {\n+\t\tLifespan lifespan = thread.getLifespan();\n+\t\tif (lifespan == null || !lifespan.contains(snap)) {\n \t\t\treturn null;\n \t\t}\n \t\tTraceMemorySpace regs = reg.getAddressSpace().isRegisterSpace()",
    "output": "Fix NPE/timing issue seen in ThreadsPanel"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/breakpoint/DebuggerBreakpointsPlugin.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/breakpoint/DebuggerBreakpointsPlugin.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/breakpoint/DebuggerBreakpointsPlugin.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/breakpoint/DebuggerBreakpointsPlugin.java\n@@ -20,6 +20,7 @@\n import ghidra.app.plugin.core.debug.DebuggerPluginPackage;\n import ghidra.app.plugin.core.debug.event.*;\n import ghidra.app.services.DebuggerLogicalBreakpointService;\n+import ghidra.app.services.DebuggerTraceManagerService;\n import ghidra.framework.plugintool.*;\n import ghidra.framework.plugintool.util.PluginStatus;\n \n@@ -31,6 +32,7 @@\n \tstatus = PluginStatus.RELEASED,\n \tservicesRequired = {\n \t\tDebuggerLogicalBreakpointService.class,\n+\t\tDebuggerTraceManagerService.class,\n \t},\n \teventsConsumed = {\n \t\tTraceOpenedPluginEvent.class,",
    "output": "Fix DebuggerBreakpointsPlugin dependency"
  },
  {
    "input": "diff --git a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/squashfs/SquashUtils.java b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/squashfs/SquashUtils.java\n--- a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/squashfs/SquashUtils.java\n+++ b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/squashfs/SquashUtils.java\n@@ -275,7 +275,7 @@ else if (inode.isSymLink()) {\n \n \t\t\t// Store symlink as file. Lookup handled when getting ByteProvider\n \t\t\tfsih.storeFileWithParent(entry.getFileName(), parentDir, symLinkInode.getNumber(),\n-\t\t\t\tfalse, 0, new SquashedFile(symLinkInode, null));\n+\t\t\t\tfalse, symLinkInode.getPath().length(), new SquashedFile(symLinkInode, null));\n \n \t\t}\n \t\telse {",
    "output": "Fix problem with symbolic links in SquashFS"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n@@ -60,7 +60,7 @@ public class ImporterUtilities {\n \t * TODO: will be refactored to use file_extension_icon.xml file info.\n \t */\n \tpublic static final GhidraFileFilter LOADABLE_FILES_FILTER = ExtensionFileFilter.forExtensions(\n-\t\t\"Loadable files\", \"exe\", \"dll\", \"obj\", \"drv\", \"bin\", \"o\", \"a\", \"so\", \"class\", \"lib\");\n+\t\t\"Loadable files\", \"exe\", \"dll\", \"obj\", \"drv\", \"bin\", \"hex\", \"o\", \"a\", \"so\", \"class\", \"lib\");\n \n \t/**\n \t * File extension filter for well known 'container' files for GhidraFileChoosers.",
    "output": "Add \"hex\" into \"Loadable files\" filter to highlight support for loading hex filex."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/menu/HorizontalRuleAction.java b/Ghidra/Framework/Docking/src/main/java/docking/menu/HorizontalRuleAction.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/menu/HorizontalRuleAction.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/menu/HorizontalRuleAction.java\n@@ -27,7 +27,7 @@\n import docking.action.DockingAction;\n import docking.action.MenuData;\n import docking.widgets.label.GDHtmlLabel;\n-import generic.theme.GThemeDefaults.Colors.Palette;\n+import generic.theme.GThemeDefaults.Colors;\n import ghidra.util.HTMLUtilities;\n \n /**\n@@ -57,7 +57,7 @@ public HorizontalRuleAction(String owner, String topName, String bottomName) {\n \t\tString bottomHtml = HTMLUtilities.escapeHTML(bottomName);\n \t\tmenuData.setMenuItemNamePlain(String.format(\"\"\"\n \t\t\t\t<html><CENTER><FONT SIZE=2 COLOR=\"%s\">%s<BR>%s</FONT></CENTER>\n-\t\t\t\t\"\"\", Palette.SILVER, topHtml, bottomHtml));\n+\t\t\t\t\"\"\", Colors.FOREGROUND_DISABLED, topHtml, bottomHtml));\n \t\tsetMenuBarData(menuData);\n \n \t\t// the description is meant to be used for the tooltip and is larger",
    "output": "Fix color of the horizontal line and text that separates programs"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/attribs/DWARFAttribute.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/attribs/DWARFAttribute.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/attribs/DWARFAttribute.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/attribs/DWARFAttribute.java\n@@ -141,7 +141,7 @@ public enum DWARFAttribute {\n \tDW_AT_call_all_tail_calls(0x7c, flag),\n \tDW_AT_call_return_pc(0x7d, address),\n \tDW_AT_call_value(0x7e, exprloc),\n-\tDW_AT_call_origin(0x7f, exprloc),\n+\tDW_AT_call_origin(0x7f, reference),\n \tDW_AT_call_parameter(0x80, reference),\n \tDW_AT_call_pc(0x81, address),\n \tDW_AT_call_tail_call(0x82, flag),",
    "output": "Fix DW_AT_call_origin expected attribute class Was causing warning messages \"Mismatched DWARF Attribute and Form: DW_AT_call_origin->DW_FORM_ref4\". Caused by bad info in the dwarf5 std docs, was fixed in dwarf6 std docs."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n@@ -50,6 +50,7 @@ public class DataTypeArchiveIDTest extends AbstractGenericTest {\n \t\t\tMap.entry(\"typeinfo/golang/golang_1.19_anybit_any.gdt\", \"3533812166493410774\"),\n \t\t\tMap.entry(\"typeinfo/golang/golang_1.20_anybit_any.gdt\", \"3533817003441909616\"),\n \t\t\tMap.entry(\"typeinfo/golang/golang_1.21_anybit_any.gdt\", \"3574190573109087960\"),\n+\t\t\tMap.entry(\"typeinfo/golang/golang_1.22_anybit_any.gdt\", \"3596108668808850319\"),\n \t\t\tMap.entry(\"typeinfo/rust/rust-common.gdt\", \"3557867258392862055\"));\n \t//@formatter:on\n ",
    "output": "Add golang 1.22"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/attribs/DWARFForm.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/attribs/DWARFForm.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/attribs/DWARFForm.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf/attribs/DWARFForm.java\n@@ -74,13 +74,7 @@ public DWARFAttributeValue readValue(DWARFFormContext context) throws IOExceptio\n \t},\n \tDW_FORM_data2(0x5, 2, constant),\n \tDW_FORM_data4(0x6, 4, constant),\n-\tDW_FORM_data8(0x7, 8, constant) {\n-\t\t@Override\n-\t\tpublic DWARFAttributeValue readValue(DWARFFormContext context) throws IOException {\n-\t\t\treturn new DWARFNumericAttribute(64, context.reader().readNextLong(), true, true,\n-\t\t\t\tcontext.def());\n-\t\t}\n-\t},\n+\tDW_FORM_data8(0x7, 8, constant),\n \tDW_FORM_string(0x8, DWARFForm.DYNAMIC_SIZE, string) {\n \t\t@Override\n \t\tpublic long getSize(DWARFFormContext context) throws IOException {",
    "output": "Remove duplicate dwarform data8 serialization code"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerResources.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerResources.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerResources.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerResources.java\n@@ -1516,21 +1516,6 @@ static ActionBuilder builder(Plugin owner) {\n \t\t}\n \t}\n \n-\tinterface SynchronizeTargetAction {\n-\t\tString NAME = \"Synchronize Target Activation\";\n-\t\tString DESCRIPTION = \"Synchronize trace activation with debugger focus/select\";\n-\t\tIcon ICON = ICON_SYNC;\n-\t\tString HELP_ANCHOR = \"sync_target\";\n-\n-\t\tstatic ToggleActionBuilder builder(Plugin owner) {\n-\t\t\tString ownerName = owner.getName();\n-\t\t\treturn new ToggleActionBuilder(NAME, ownerName).description(DESCRIPTION)\n-\t\t\t\t\t.menuPath(NAME)\n-\t\t\t\t\t.menuIcon(ICON)\n-\t\t\t\t\t.helpLocation(new HelpLocation(ownerName, HELP_ANCHOR));\n-\t\t}\n-\t}\n-\n \tinterface SaveByDefaultAction {\n \t\tString NAME = \"Save Traces By Default\";\n \t\tString DESCRIPTION = \"Automatically save traces to the project\";",
    "output": "Remove SynchronizedTargetActivation interface"
  },
  {
    "input": "diff --git a/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/gui/search/dialog/CreateBsimServerInfoDialog.java b/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/gui/search/dialog/CreateBsimServerInfoDialog.java\n--- a/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/gui/search/dialog/CreateBsimServerInfoDialog.java\n+++ b/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/gui/search/dialog/CreateBsimServerInfoDialog.java\n@@ -101,7 +101,7 @@ public boolean acceptServer(BSimServerInfo serverInfo) {\n \t\t\terrorMessage = e.getMessage();\n \t\t}\n \t\tint answer = OptionDialog.showYesNoDialog(null, \"Connection Test Failed!\",\n-\t\t\t\"Can't connect to server: \" + errorMessage + \"\\nDo you want create anyway?\");\n+\t\t\t\"Can't connect to server: \" + errorMessage + \"\\nDo you want to proceed with creation anyway?\");\n \t\treturn answer == OptionDialog.YES_OPTION;\n \t}\n ",
    "output": "Change error message to be more correct"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/rtti/GoSlice.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/rtti/GoSlice.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/rtti/GoSlice.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/golang/rtti/GoSlice.java\n@@ -25,6 +25,7 @@\n import ghidra.app.util.bin.format.golang.structmapping.*;\n import ghidra.program.model.address.*;\n import ghidra.program.model.data.*;\n+import ghidra.program.model.listing.Instruction;\n import ghidra.program.model.mem.Memory;\n import ghidra.util.Msg;\n import ghidra.util.exception.CancelledException;\n@@ -127,6 +128,12 @@ public boolean isValid(int elementSize) {\n \t\ttry {\n \t\t\tMemory memory = programContext.getProgram().getMemory();\n \t\t\tAddress arrayAddr = getArrayAddress();\n+\t\t\tInstruction arrayInstr =\n+\t\t\t\tprogramContext.getProgram().getListing().getInstructionAt(arrayAddr);\n+\t\t\tif (arrayInstr != null) {\n+\t\t\t\t// if slice array is pointing at an instruction (commonly in switch tables)\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t\treturn memory.contains(arrayAddr) &&\n \t\t\t\tmemory.contains(arrayAddr.addNoWrap(len * elementSize));\n \t\t}",
    "output": "Fix golang's slice detection that was triggering on switch tables"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tab/GTabPanel.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tab/GTabPanel.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tab/GTabPanel.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tab/GTabPanel.java\n@@ -74,7 +74,6 @@ public GTabPanel(String tabTypeName) {\n \t\tthis.tabTypeName = tabTypeName;\n \t\tsetLayout(new HorizontalLayout(0));\n \t\tsetFocusable(true);\n-\t\tsetBorder(new GTabPanelBorder());\n \t\tgetAccessibleContext().setAccessibleDescription(\n \t\t\t\"Use left and right arrows to highlight other tabs and press enter to select \" +\n \t\t\t\t\"the highlighted tab\");\n@@ -491,11 +490,13 @@ private void rebuildTabs() {\n \t\tallTabs.clear();\n \t\tremoveAll();\n \t\tcloseTabList();\n+\t\tsetBorder(null);\n \t\tif (!shouldShowTabs()) {\n \t\t\trevalidate();\n \t\t\trepaint();\n \t\t\treturn;\n \t\t}\n+\t\tsetBorder(new GTabPanelBorder());\n \n \t\tGTab<T> selectedTab = null;\n \t\tint availableWidth = getPanelWidth();",
    "output": "Fix GTabPanel to not show borders when no tabs are present"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/XRefFieldFactory.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/XRefFieldFactory.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/XRefFieldFactory.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/XRefFieldFactory.java\n@@ -545,7 +545,7 @@ private List<FieldElement> toFieldElements(List<XrefFieldElement> list, boolean\n \t\t\tint lastRow = list.size() - 1;\n \t\t\tAttributedString as =\n \t\t\t\tnew AttributedString(MORE_XREFS_STRING, XrefColors.DEFAULT, getMetrics());\n-\t\t\tfieldElements.add(new TextFieldElement(as, lastRow, 0));\n+\t\t\tfieldElements.add(new TextFieldElement(as, lastRow + 1, 0));\n \t\t}\n \t\treturn fieldElements;\n \t}",
    "output": "Fix junit test"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/protorules/PrimitiveExtractor.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/protorules/PrimitiveExtractor.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/protorules/PrimitiveExtractor.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/protorules/PrimitiveExtractor.java\n@@ -148,7 +148,7 @@ private boolean commonRefinement(ArrayList<Primitive> first, ArrayList<Primitive\n \t * @param offset is the starting offset of the union within the parent\n \t * @return true if a common refinement was found and appended\n \t */\n-\tprivate boolean handleUnion(UnionDataType dt, int max, int offset) {\n+\tprivate boolean handleUnion(Union dt, int max, int offset) {\n \t\tif (unionInvalid) {\n \t\t\treturn false;\n \t\t}\n@@ -232,7 +232,7 @@ private boolean extract(DataType dt, int max, int offset) {\n \t\t\t\treturn true;\n \t\t\t}\n \t\t\tcase PcodeDataTypeManager.TYPE_UNION:\n-\t\t\t\treturn handleUnion((UnionDataType) dt, max, offset);\n+\t\t\t\treturn handleUnion((Union) dt, max, offset);\n \t\t\tcase PcodeDataTypeManager.TYPE_STRUCT:\n \t\t\t\tbreak;\n \t\t\tdefault:",
    "output": "Change UnionDataTypes to Unions"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java\n@@ -247,6 +247,9 @@ public void dispose() {\n \tvoid navigateTo(Navigatable navigatable, Program program, int x, int y, int viewHeight,\n \t\t\tAddressIndexMap addrMap) {\n \t\tMarkerSetCacheEntry entry = markerSetCache.get(program);\n+\t\tif (entry == null) {\n+\t\t\treturn; // this can happen when no program is open\n+\t\t}\n \n \t\tProgramLocation loc = entry.getProgramLocation(y, viewHeight, addrMap, x);\n \t\tgetGoToService();",
    "output": "Fix exception when double-clicking in the marker margin when no program is open"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/EolCommentFieldFactory.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/EolCommentFieldFactory.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/EolCommentFieldFactory.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/EolCommentFieldFactory.java\n@@ -292,6 +292,9 @@ public ListingField getField(ProxyObj<?> proxy, int varWidth) {\n \t\t\telementList.addAll(elements);\n \t\t}\n \n+\t\tif (elementList.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n \t\treturn ListingTextField.createMultilineTextField(this, proxy, elementList, x, width,\n \t\t\tmaxDisplayLines, hlProvider);\n \t}",
    "output": "Fix mistake to change in EOL comment field for"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java b/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java\n@@ -441,12 +441,15 @@ void actionRemoved(DockingActionIf action) {\n \t}\n \n \t@Override\n-\t// we aren't focusable, so pass focus to a valid child component\n \tpublic void requestFocus() {\n \t\tif (lastFocusedComponent != null && lastFocusedComponent.isShowing()) {\n \t\t\tlastFocusedComponent.requestFocus();\n \t\t\treturn;\n \t\t}\n+\n+\t\tif (placeholder == null) {\n+\t\t\treturn;\t// this implies we have been disposed\n+\t\t}\n \t\tplaceholder.getProvider().requestFocus();\n \t}\n ",
    "output": "Fix unit tests"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java b/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java\n@@ -383,7 +383,7 @@ public Class<?> getContextType() {\n \t * @return true if this provider is showing.\n \t */\n \tpublic boolean isVisible() {\n-\t\treturn dockingTool.isVisible(this);\n+\t\treturn dockingTool != null && dockingTool.isVisible(this);\n \t}\n \n \t/**",
    "output": "Fix tests broken from"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIWindowsClassRecoverer.java b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIWindowsClassRecoverer.java\n--- a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIWindowsClassRecoverer.java\n+++ b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIWindowsClassRecoverer.java\n@@ -2495,7 +2495,7 @@ private Structure createClassStructureUsingRTTI(RecoveredClass recoveredClass,\n \t * @param recoveredClass the given class\n \t * @return the offset in the given class structure of the classes single virtual parent or NONE \n \t * if cannot retrieve an offset value or if there is not a single virtual parent for the given\n-\t * class.\n+\t * class. Return null if cannot retrieve the offset for the single virtual parent. \n \t * @throws CancelledException if cancelled\n \t * @throws AddressOutOfBoundsException if trying to access an address that does not exist in program\n \t * @throws MemoryAccessException  if trying to access memory that can't be accessed\n@@ -2517,7 +2517,7 @@ public Integer getSingleVirtualParentOffset(RecoveredClass recoveredClass)\n \tprivate Map<RecoveredClass, Integer> getBaseClassOffsetMap(RecoveredClass recoveredClass)\n \t\t\tthrows CancelledException, MemoryAccessException, AddressOutOfBoundsException {\n \n-\t\tMap<RecoveredClass, Integer> baseClassOffsetMap = new HashMap<RecoveredClass, Integer>();\n+\t\tMap<RecoveredClass, Integer> baseClassOffsetMap = new HashMap<>();\n \n \t\tData baseClassArrayData = getBaseClassArray(recoveredClass);\n ",
    "output": "Fix review notes"
  },
  {
    "input": "diff --git a/Ghidra/Test/DebuggerIntegrationTest/src/test.slow/java/agent/gdb/rmi/GdbCommandsTest.java b/Ghidra/Test/DebuggerIntegrationTest/src/test.slow/java/agent/gdb/rmi/GdbCommandsTest.java\n--- a/Ghidra/Test/DebuggerIntegrationTest/src/test.slow/java/agent/gdb/rmi/GdbCommandsTest.java\n+++ b/Ghidra/Test/DebuggerIntegrationTest/src/test.slow/java/agent/gdb/rmi/GdbCommandsTest.java\n@@ -243,7 +243,7 @@ public void testLcsp() throws Exception {\n \t\t\t\tquit\n \t\t\t\t\"\"\".formatted(PREAMBLE));\n \t\tassertEquals(\"\"\"\n-\t\t\t\tSelected Ghidra language: DATA:LE:64:default\n+\t\t\t\tSelected Ghidra language: x86:LE:32:default\n \t\t\t\tSelected Ghidra compiler: pointer64\"\"\",\n \t\t\textractOutSection(out, \"---Import---\"));\n \t\tassertEquals(\"\"\"",
    "output": "Fix tests Fix GdbCommandsTest.testLcsp Don't take user's transaction in ghidralldb.commands.put_state"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java\n@@ -70,6 +70,11 @@ public enum Platform {\n \t */\n \tFREEBSD_X86_64(OperatingSystem.FREE_BSD, Architecture.X86_64, \"freebsd_x86_64\", \".so\", \"\"),\n \n+\t/**\n+\t * Identifies a FreeBSD ARM 64-bit OS.\n+\t */\n+\tFREEBSD_ARM_64(OperatingSystem.FREE_BSD, Architecture.ARM_64, \"freebsd_arm_64\", \".so\", \"\"),\n+\n \t/**\n \t * Identifies an unsupported OS.\n \t */",
    "output": "Add support for FreeBSD ARM 64bit (no debugger support)"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/help/screenshot/AbstractScreenShotGenerator.java b/Ghidra/Features/Base/src/main/java/help/screenshot/AbstractScreenShotGenerator.java\n--- a/Ghidra/Features/Base/src/main/java/help/screenshot/AbstractScreenShotGenerator.java\n+++ b/Ghidra/Features/Base/src/main/java/help/screenshot/AbstractScreenShotGenerator.java\n@@ -111,7 +111,7 @@ public AbstractScreenShotGenerator() {\n \t\tsetInstanceField(\"allowTestTools\", ToolUtils.class, Boolean.FALSE);\n \t\tsetDockIcon();\n \n-\t\tThemeManager.getInstance().setTheme(new FlatLightTheme());\n+\t\trunSwing(() -> ThemeManager.getInstance().setTheme(new FlatLightTheme()));\n \t}\n \n \tprotected TestEnv newTestEnv() throws Exception {",
    "output": "Fix screenshot stack trace"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Gui/src/main/java/ghidra/framework/options/Options.java b/Ghidra/Framework/Gui/src/main/java/ghidra/framework/options/Options.java\n--- a/Ghidra/Framework/Gui/src/main/java/ghidra/framework/options/Options.java\n+++ b/Ghidra/Framework/Gui/src/main/java/ghidra/framework/options/Options.java\n@@ -194,7 +194,7 @@ public void registerOption(String optionName, OptionType type, Object defaultVal\n \t * @deprecated Use instead\n \t * {@link #registerOption(String, OptionType, Object, HelpLocation, String, Supplier)}\n \t */\n-\t@Deprecated(since = \"11.1\", forRemoval = true)\n+\t@Deprecated(since = \"11.0.2\", forRemoval = true)\n \tdefault public void registerOption(String optionName, OptionType type, Object defaultValue,\n \t\t\tHelpLocation help, String description, PropertyEditor editor) {\n \t\tString caller = ReflectionUtilities.getClassNameOlderThan(Options.class);\n@@ -248,7 +248,7 @@ public void registerThemeFontBinding(String optionName, String fontId, HelpLocat\n \t * @param editor the editor\n \t * @deprecated Use instead {@link #registerOptionsEditor(Supplier)}\n \t */\n-\t@Deprecated(since = \"11.1\", forRemoval = true)\n+\t@Deprecated(since = \"11.0.2\", forRemoval = true)\n \tdefault public void registerOptionsEditor(OptionsEditor editor) {\n \t\tString caller = ReflectionUtilities.getClassNameOlderThan(Options.class);\n \t\tString message = \"\"\"",
    "output": "Fix deprecated version number"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/CoffLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/CoffLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/CoffLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/CoffLoader.java\n@@ -701,7 +701,13 @@ private void processRelocations(CoffFileHeader header, Program program,\n \t\t\t\t\t\t\t\t++failureCount;\n \t\t\t\t\t\t\t\tfailedAddr = address;\n \t\t\t\t\t\t\t\thandleRelocationError(program, address, relocationType,\n-\t\t\t\t\t\t\t\t\t\"Unsupported COFF relocation type\", null);\n+\t\t\t\t\t\t\t\t\t\"unsupported type\", null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse if (status == Status.FAILURE) {\n+\t\t\t\t\t\t\t\t++failureCount;\n+\t\t\t\t\t\t\t\tfailedAddr = address;\n+\t\t\t\t\t\t\t\thandleRelocationError(program, address, relocationType,\n+\t\t\t\t\t\t\t\t\t\"unknown reason\", null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}",
    "output": "Fix COFF relocation error handler"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/coff/CoffMachineType.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/coff/CoffMachineType.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/coff/CoffMachineType.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/coff/CoffMachineType.java\n@@ -203,6 +203,11 @@ public class CoffMachineType {\n \t * Hitachi SH5\n \t */\n \tpublic final static short IMAGE_FILE_MACHINE_SH5 = 0x01a8;\n+\t\n+\t/**\n+\t * Texas Instruments TMS320C3x/4x\n+\t */\n+\tpublic final static short IMAGE_FILE_MACHINE_TI_TMS320C3x4x = 0x0093;\n \n \t/**\n \t * Texas Instruments TMS470",
    "output": "Add missing COFF machine ID"
  },
  {
    "input": "diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/program/model/address/CachedAddressSetView.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/program/model/address/CachedAddressSetView.java\n--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/program/model/address/CachedAddressSetView.java\n+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/program/model/address/CachedAddressSetView.java\n@@ -100,6 +100,10 @@ protected void ensureKnown(Address min, Address max) {\n \t\tif (minAddress == null) {\n \t\t\treturn;\n \t\t}\n+\t\tif (minAddress.compareTo(max) > 0 ||\n+\t\t\tmaxAddress.compareTo(min) < 0) {\n+\t\t\treturn;\n+\t\t}\n \t\tmin = cmax(min, minAddress);\n \t\tmax = cmin(max, maxAddress);\n \t\tif (known.contains(min, max)) {",
    "output": "Fix inverted range"
  },
  {
    "input": "diff --git a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/util/ImpliedMatchUtils.java b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/util/ImpliedMatchUtils.java\n--- a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/util/ImpliedMatchUtils.java\n+++ b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/util/ImpliedMatchUtils.java\n@@ -241,7 +241,13 @@ private static VTImpliedMatchInfo findImpliedMatch(AddressCorrelation correlator\n \t\t\tif (sourceFunction.getProgram()\n \t\t\t\t\t.getFunctionManager()\n \t\t\t\t\t.getFunctionAt(srcRefToAddress) == null) {\n-\t\t\t\treturn null; // function may not have been created here.\n+\t\t\t\treturn null; // source function may not have been created here.\n+\t\t\t}\n+\n+\t\t\tif (destinationFunction.getProgram()\n+\t\t\t\t\t.getFunctionManager()\n+\t\t\t\t\t.getFunctionAt(destRefToAddress) == null) {\n+\t\t\t\treturn null; // destination function may not have been created here.\n \t\t\t}\n \t\t}\n ",
    "output": "Add missing check for destination function existence when creating an implied match."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/gui/tracermi/launcher/LaunchAction.java b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/gui/tracermi/launcher/LaunchAction.java\n--- a/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/gui/tracermi/launcher/LaunchAction.java\n+++ b/Ghidra/Debug/Debugger-rmi-trace/src/main/java/ghidra/app/plugin/core/debug/gui/tracermi/launcher/LaunchAction.java\n@@ -228,7 +228,7 @@ public String getDescription() {\n \t\t}\n \t\tConfigLast last = findMostRecentConfig();\n \t\tTraceRmiLaunchOffer offer = findOffer(last);\n-\t\tif (last == null) {\n+\t\tif (offer == null) {\n \t\t\treturn \"Configure and launch \" + program.getName();\n \t\t}\n \t\treturn \"Re-launch \" + program.getName() + \" using \" + offer.getTitle();",
    "output": "Fix for type"
  },
  {
    "input": "diff --git a/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/ingest/BSimLaunchable.java b/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/ingest/BSimLaunchable.java\n--- a/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/ingest/BSimLaunchable.java\n+++ b/Ghidra/Features/BSim/src/main/java/ghidra/features/bsim/query/ingest/BSimLaunchable.java\n@@ -157,7 +157,7 @@ private static String defineCommand(String command) {\n \tprivate static final Set<String> LIST_FUNCTIONS_OPTIONS = \n \t\t\tSet.of(MD5_OPTION, NAME_OPTION, ARCH_OPTION, COMPILER_OPTION, PRINT_SELF_SIGNIFICANCE_OPTION, CALL_GRAPH_OPTION, PRINT_JUST_EXE_OPTION, MAX_FUNC_OPTION);\n \tprivate static final Set<String> GET_EXECUTABLES_OPTIONS = \n-\t\t\tSet.of(MD5_OPTION, NAME_OPTION, ARCH_OPTION, COMPILER_OPTION, SORT_COL_OPTION, INCLUDE_LIBS_OPTION);\n+\t\t\tSet.of(MD5_OPTION, NAME_OPTION, ARCH_OPTION, COMPILER_OPTION, SORT_COL_OPTION, LIMIT_OPTION, INCLUDE_LIBS_OPTION);\n \tprivate static final Set<String> GET_EXECUTABLES_COUNT_OPTIONS = \n \t\t\tSet.of(MD5_OPTION, NAME_OPTION, ARCH_OPTION, COMPILER_OPTION, INCLUDE_LIBS_OPTION);\n \t//@formatter:on",
    "output": "Fix BSIM listexes command line options handling. Although support for the '--limit' option is implemented, it's not possible to use it due to its absence from the set of valid options (GET_EXECUTABLES_OPTIONS). This commit fix it by adding LIMIT_OPTION to GET_EXECUTABLES_OPTIONS set."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n@@ -338,11 +338,12 @@ public void buildSrcZip(File outputFile, TaskMonitor monitor)\n \t\t\t\twroteToZip |= writeZipRecursively(zip, srcDir.getAbsolutePath(), srcDir);\n \t\t\t}\n \t\t}\n-\t\tif (wroteToZip) {\n-\t\t\tSystem.out\n-\t\t\t\t\t.println(\"Can't create source zip!  Has source been downloaded and installed?\");\n+\t\tif (!wroteToZip) {\n+\t\t\tSystem.out.println(\"Can't create source zip!  Has source been downloaded and installed?\");\n \t\t\t// zip.close reports error if nothing has been written to it\n \t\t\tzip.close();\n+\t\t} else {\n+\t\t\tzip.close(); // close it anyway to prevent a memory leak\n \t\t}\n \t}\n ",
    "output": "Fix false error in GhidraJarBuilder.java Changed from \"only giving an error if we WERE able to write to the sources jar\" to \"only giving an error if we were NOT able to write to the sources jar\"."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/thread/DebuggerThreadsProviderTest.java b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/thread/DebuggerThreadsProviderTest.java\n--- a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/thread/DebuggerThreadsProviderTest.java\n+++ b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/thread/DebuggerThreadsProviderTest.java\n@@ -395,6 +395,7 @@ public void testChangeThreadUpdatesProvider() throws Exception {\n \t\ttry (Transaction tx = tb.startTransaction()) {\n \t\t\tthread1.getObject().removeTree(Lifespan.nowOn(16));\n \t\t}\n+\t\twaitForDomainObject(tb.trace);\n \t\twaitForTasks();\n \n \t\twaitForPass(() -> {",
    "output": "Fix timing issue in testChangeThreadUpdatesProvider"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/model/DebuggerModelProviderTest.java b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/model/DebuggerModelProviderTest.java\n--- a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/model/DebuggerModelProviderTest.java\n+++ b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/model/DebuggerModelProviderTest.java\n@@ -1057,6 +1057,7 @@ public void testSetValueAffectsTree() throws Throwable {\n \t\ttry (Transaction tx = tb.startTransaction()) {\n \t\t\tthreads.setAttribute(Lifespan.nowOn(0), \"Current\", thread0);\n \t\t}\n+\t\twaitForDomainObject(tb.trace);\n \t\twaitForTasks();\n \n \t\tassertEquals(11, node.getChildren().size());",
    "output": "Fix timing issue in testSetValueAffectsTree"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/launch/AbstractDebuggerProgramLaunchOffer.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/launch/AbstractDebuggerProgramLaunchOffer.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/launch/AbstractDebuggerProgramLaunchOffer.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/launch/AbstractDebuggerProgramLaunchOffer.java\n@@ -15,8 +15,9 @@\n  */\n package ghidra.app.plugin.core.debug.service.model.launch;\n \n-import static ghidra.async.AsyncUtils.loop;\n+import static ghidra.async.AsyncUtils.*;\n \n+import java.io.File;\n import java.io.IOException;\n import java.util.*;\n import java.util.Map.Entry;\n@@ -285,8 +286,10 @@ private void saveLauncherArgs(Map<String, ?> args,\n \t\tfor (Entry<String, ParameterDescription<?>> entry : params.entrySet()) {\n \t\t\tmap.put(entry.getKey(), entry.getValue().defaultValue);\n \t\t}\n+\t\tString almostExecutablePath = program.getExecutablePath();\n+\t\tFile f = new File(almostExecutablePath);\n \t\tmap.put(TargetCmdLineLauncher.CMDLINE_ARGS_NAME,\n-\t\t\tTargetCmdLineLauncher.quoteImagePathIfSpaces(program.getExecutablePath()));\n+\t\t\tTargetCmdLineLauncher.quoteImagePathIfSpaces(f.getAbsolutePath()));\n \t\treturn map;\n \t}\n ",
    "output": "Fix for path"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java\n@@ -2431,6 +2431,11 @@ protected void addDataTypeToDelete(long id) {\n \t * @param replacementDataType datatype which is the replacement\n \t */\n \tprotected void addDataTypeToReplace(DataType oldDataType, DataType replacementDataType) {\n+\t\tObjects.requireNonNull(oldDataType);\n+\t\tObjects.requireNonNull(replacementDataType);\n+\t\tif (oldDataType == replacementDataType) {\n+\t\t\tthrow new AssertionError(\"Invalid datatype replacement pair\");\n+\t\t}\n \t\ttypesToReplace.add(new Pair<>(oldDataType, replacementDataType));\n \t}\n ",
    "output": "Add assertion check for datatype replacement"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/misc/FontAdjustPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/misc/FontAdjustPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/misc/FontAdjustPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/misc/FontAdjustPlugin.java\n@@ -18,8 +18,8 @@\n import docking.ActionContext;\n import docking.ComponentProvider;\n import docking.action.builder.ActionBuilder;\n+import ghidra.app.CorePluginPackage;\n import ghidra.app.plugin.PluginCategoryNames;\n-import ghidra.framework.main.UtilityPluginPackage;\n import ghidra.framework.plugintool.*;\n import ghidra.framework.plugintool.util.PluginStatus;\n \n@@ -28,11 +28,11 @@\n  */\n @PluginInfo( //@formatter:off\n \tstatus = PluginStatus.RELEASED,\n-\tpackageName = UtilityPluginPackage.NAME,\n+\tpackageName = CorePluginPackage.NAME,\n \tcategory = PluginCategoryNames.FRAMEWORK,\n \tshortDescription = \"Provides generic actions for increasing/decreasing fonts.\",\n \tdescription = \"This plugin provides actions for increasing fonts used by component providers. \"+\n-\t\"ComponentProviders can either override the \\\"changeFontSize()\\\" method or register a\" +\n+\t\"ComponentProviders can either override the \\\"adjustFontSize()\\\" method or register a\" +\n \t\"theme font id that can be automatically adjusted.\"\n ) //@formatter:on\n ",
    "output": "Fix FontAdjustPlugin not being added to the tool"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoaderOptionsFactory.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoaderOptionsFactory.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoaderOptionsFactory.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoaderOptionsFactory.java\n@@ -35,7 +35,7 @@ public class ElfLoaderOptionsFactory {\n \tstatic final boolean PERFORM_RELOCATIONS_DEFAULT = true;\n \n \tpublic static final String APPLY_UNDEFINED_SYMBOL_DATA_NAME = \"Apply Undefined Symbol Data\";\n-\tstatic final boolean APPLY_UNDEFINED_SYMBOL_DATA_DEFAULT = false;\n+\tstatic final boolean APPLY_UNDEFINED_SYMBOL_DATA_DEFAULT = true;\n \n \t// NOTE: Using too large of an image base can cause problems for relocation processing\n \t// for some language scenarios which utilize 32-bit relocations.  This may be due to",
    "output": "Change ELF create undefined data option to be enabled by default."
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/OverridePrototypeAction.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/OverridePrototypeAction.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/OverridePrototypeAction.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/OverridePrototypeAction.java\n@@ -76,7 +76,7 @@ static PcodeOp getCallOp(Program program, ClangToken tokenAtCursor) {\n \t}\n \n \tstatic Symbol getSymbol(Function func, ClangToken tokenAtCursor) {\n-\t\tif (tokenAtCursor == null) {\n+\t\tif (tokenAtCursor == null || (func instanceof UndefinedFunction)) {\n \t\t\treturn null;\n \t\t}\n ",
    "output": "Fix prototype override context check for UndefinedFunction case."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java b/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java\n@@ -1465,7 +1465,10 @@ else if (out.getSize() > 8) {\n \t\tif (ptype == PcodeOp.BRANCH || ptype == PcodeOp.RETURN || ptype == PcodeOp.BRANCHIND) {\n \t\t\t// if says this is branch, but has a fallthru, then really isn't a fallthru\n \t\t\t//   assume the future flow will have flowed the correct info.\n-\t\t\tnextAddr = fallthru;\n+\t\t\t// only assign for branch if it isn't a degenerate fallthru to itself\n+\t\t\tif (!minInstrAddress.equals(fallthru)) {\n+\t\t\t\tnextAddr = fallthru;\n+\t\t\t}\n \t\t}\n \n \t\treturn nextAddr;",
    "output": "Fix lockup on instruction fallthru override to self"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/AbstractNumberInputDialog.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/AbstractNumberInputDialog.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/AbstractNumberInputDialog.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/AbstractNumberInputDialog.java\n@@ -102,7 +102,11 @@ private static String nonNull(String s) {\n \t */\n \tprotected JPanel buildMainPanel(String prompt, boolean showAsHex) {\n \t\tJPanel panel = createPanel(prompt);\n-\t\tnumberInputField.addActionListener(e -> okCallback());\n+\t\tnumberInputField.addActionListener(e -> {\n+\t\t\tif (okButton.isEnabled()) {\n+\t\t\t\tokCallback();\n+\t\t\t}\n+\t\t});\n \n \t\tif (showAsHex) {\n \t\t\tnumberInputField.setHexMode();\n@@ -258,7 +262,7 @@ IntegerTextField getNumberInputField() {\n \n //==================================================================================================\n // Private Methods\n-//==================================================================================================\t\n+//==================================================================================================\n \n \t/**\n \t * Create the main panel.",
    "output": "Fix exception in dialog when pressing Enter with no text in the field"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java\n@@ -702,15 +702,16 @@ private void parseDynamicTable() throws IOException {\n \t\t\t}\n \n \t\t\tElfProgramHeader loadHeader = getProgramLoadHeaderContaining(vaddr);\n-\t\t\tif (loadHeader != null) {\n-\t\t\t\tlong dynamicTableOffset = loadHeader.getOffset() +\n-\t\t\t\t\t(dynamicHeaders[0].getVirtualAddress() - loadHeader.getVirtualAddress());\n-\t\t\t\tdynamicTable = new ElfDynamicTable(reader, this, dynamicTableOffset,\n-\t\t\t\t\tdynamicHeaders[0].getVirtualAddress());\n-\t\t\t\treturn;\n+\t\t\tif (loadHeader == null) {\n+\t\t\t\tloadHeader = dynamicHeaders[0];\n \t\t\t}\n+\t\t\tlong dynamicTableOffset = loadHeader.getOffset() +\n+\t\t\t\t(dynamicHeaders[0].getVirtualAddress() - loadHeader.getVirtualAddress());\n+\t\t\tdynamicTable = new ElfDynamicTable(reader, this, dynamicTableOffset,\n+\t\t\t\tdynamicHeaders[0].getVirtualAddress());\n+\t\t\treturn;\n \t\t}\n-\t\telse if (dynamicHeaders.length > 1) {\n+\t\tif (dynamicHeaders.length > 1) {\n \t\t\terrorConsumer.accept(\"Multiple ELF Dynamic table program headers found\");\n \t\t}\n ",
    "output": "Fix logic error in ElfHeader::parseDynamicTable when the PT_DYNAMIC header exists and the dynamic table is not also in a PT_LOAD segment"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/model/DebuggerModelProviderTest.java b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/model/DebuggerModelProviderTest.java\n--- a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/model/DebuggerModelProviderTest.java\n+++ b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/model/DebuggerModelProviderTest.java\n@@ -411,7 +411,9 @@ public void testDoubleClickObjectInObjectsTree() throws Throwable {\n \t\tGTree tree = modelProvider.objectsTreePanel.tree;\n \t\tGTreeNode node = waitForPass(() -> {\n \t\t\tGTreeNode n = Unique.assertOne(tree.getSelectedNodes());\n-\t\t\tassertEquals(\"Processes@0\", n.getName());\n+\t\t\tassertEquals(\n+\t\t\t\t\"Processes@%d\".formatted(System.identityHashCode(processes.getCanonicalParent(0))),\n+\t\t\t\tn.getName());\n \t\t\treturn n;\n \t\t});\n \t\tclickTreeNode(tree, node, MouseEvent.BUTTON1);\n@@ -822,7 +824,7 @@ public void testTreeTracksDisplayChange() throws Throwable {\n \t\t}\n \t\twaitForTasks();\n \n-\t\twaitForPass(() -> assertEquals(\"<html>Renamed Thread\", node.getDisplayText()));\n+\t\twaitForPass(() -> assertEquals(\"<html>Renamed&nbsp;Thread\", node.getDisplayText()));\n \t}\n \n \t@Test",
    "output": "Fix model provider tests."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProvider.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProvider.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProvider.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProvider.java\n@@ -1206,6 +1206,9 @@ protected void doAutoDisassemble(Address start) {\n \t\tAddressSet set = new AddressSet(space.getMinAddress(), space.getMaxAddress());\n \n \t\tReqs reqs = Reqs.fromView(tool, view);\n+\t\tif (reqs == null) {\n+\t\t\treturn;\n+\t\t}\n \t\tCurrentPlatformTraceDisassembleCommand dis =\n \t\t\tnew CurrentPlatformTraceDisassembleCommand(tool, set, reqs, start);\n \t\tdis.run(tool, view);",
    "output": "Fix NPE in auto-disassembly."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/disassemble/TraceDisassembleCommand.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/disassemble/TraceDisassembleCommand.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/disassemble/TraceDisassembleCommand.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/disassemble/TraceDisassembleCommand.java\n@@ -79,6 +79,9 @@ protected AddressSetView writeBlock(TraceProgramView view, InstructionBlock bloc\n \tpublic boolean applyToTyped(TraceProgramView view, TaskMonitor monitor) {\n \t\tDisassembler disassembler = getDisassembler(view, monitor);\n \t\tMemBuffer buffer = getBuffer(view);\n+\t\tif (buffer == null) {\n+\t\t\treturn true; // Memory space does not exist. Just go silently.\n+\t\t}\n \t\tint limit = computeLimit();\n \t\t// TODO: limit is actually instruction count, not byte count :'(\n \t\tInstructionBlock block = disassembler.pseudoDisassembleBlock(buffer, initialContext, limit);",
    "output": "Fix NPE in TraceDisassembleCommand."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/util/extensions/Extensions.java b/Ghidra/Framework/Generic/src/main/java/ghidra/util/extensions/Extensions.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/util/extensions/Extensions.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/util/extensions/Extensions.java\n@@ -155,10 +155,9 @@ String getAsString() {\n \t\t\treturn \"<no extensions installed>\";\n \t\t}\n \n-\t\tif (!buffy.isEmpty()) {\n-\t\t\t// remove trailing newline to keep logging consistent\n-\t\t\tbuffy.deleteCharAt(buffy.length() - 1);\n-\t\t}\n+\t\t// Remove trailing newline to keep logging consistent\n+\t\tbuffy.deleteCharAt(buffy.length() - 1);\n+\n \t\treturn buffy.toString();\n \t}\n ",
    "output": "Remove extra check Extensions.java Drive-by while reading the code."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functionwindow/FunctionWindowPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functionwindow/FunctionWindowPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functionwindow/FunctionWindowPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functionwindow/FunctionWindowPlugin.java\n@@ -55,7 +55,7 @@ public class FunctionWindowPlugin extends ProgramPlugin {\n \tprivate DockingAction compareFunctionsAction;\n \tprivate FunctionWindowProvider provider;\n \tprivate SwingUpdateManager swingMgr;\n-\tprivate DomainObjectListener domainObjectListener = createDomainObjectListener();\n+\tprivate DomainObjectListener domainObjectListener;\n \n \tpublic FunctionWindowPlugin(PluginTool tool) {\n \t\tsuper(tool);\n@@ -67,6 +67,7 @@ public FunctionWindowPlugin(PluginTool tool) {\n \tpublic void init() {\n \t\tsuper.init();\n \t\tprovider = new FunctionWindowProvider(this);\n+\t\tdomainObjectListener = createDomainObjectListener();\n \t\tcreateActions();\n \n \t\t/**",
    "output": "Add fix to stop tool init problem"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n@@ -1693,7 +1693,7 @@ public boolean isEnabledForContext(ActionContext context) {\n \t\t};\n \t\t//@formatter:off\n \t\texpandAction.setPopupMenuData(new MenuData(\n-\t\t\t\tnew String[] { \"Exapnd\" },\n+\t\t\t\tnew String[] { \"Expand\" },\n \t\t\t\tIcons.EXPAND_ALL_ICON,\n \t\t\t\tactionMenuGroup, NO_MNEMONIC,\n \t\t\t\tInteger.toString(subGroupIndex++)",
    "output": "Fix typo in GTree"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/threaded/TableData.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/threaded/TableData.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/threaded/TableData.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/threaded/TableData.java\n@@ -139,7 +139,7 @@ public ROW_OBJECT get(int modelRow) {\n \t * @return the index\n \t */\n \tpublic int indexOf(ROW_OBJECT t) {\n-\t\tif (!sortContext.isUnsorted()) {\n+\t\tif (isSorted()) {\n \t\t\tComparator<ROW_OBJECT> comparator = sortContext.getComparator();\n \t\t\treturn Collections.binarySearch(data, t, comparator);\n \t\t}\n@@ -159,7 +159,7 @@ public boolean remove(ROW_OBJECT t) {\n \t\t\tsource.remove(t);\n \t\t}\n \n-\t\tif (sortContext.isUnsorted()) {\n+\t\tif (!isSorted()) {\n \t\t\treturn data.remove(t); // no sort; cannot binary search\n \t\t}\n ",
    "output": "Fix timing exception related to selecting table items before the table has been sorted"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/util/classfinder/ClassSearcher.java b/Ghidra/Framework/Generic/src/main/java/ghidra/util/classfinder/ClassSearcher.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/util/classfinder/ClassSearcher.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/util/classfinder/ClassSearcher.java\n@@ -409,7 +409,7 @@ private static void loadExtensionPointSuffixes() {\n \t\t\tbuffy.append(suffix);\n \t\t\tbetween = \"|\";\n \t\t}\n-\t\tbuffy.append(')');\n+\t\tbuffy.append(\")$\");\n \t\textensionPointSuffixPattern = Pattern.compile(buffy.toString());\n \t\tlog.trace(\"Using extension point pattern: {}\", extensionPointSuffixPattern);\n \t}",
    "output": "Fix bug in ClassSearcher regex"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GDynamicColumnTableModel.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GDynamicColumnTableModel.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GDynamicColumnTableModel.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GDynamicColumnTableModel.java\n@@ -207,6 +207,13 @@ protected Comparator<ROW_TYPE> createSortComparator(int columnIndex) {\n \t */\n \t@SuppressWarnings(\"unchecked\") // the column provides the values itself; safe cast\n \tprotected Comparator<Object> createSortComparatorForColumn(int columnIndex) {\n+\t\tif (columnIndex < 0 || columnIndex >= tableColumns.size()) {\n+\t\t\t// We have seen this sporadically.  Assume for now there is some sort of timing issue.\n+\t\t\t// Although, it is possible for any client to call this on a table without columns.\n+\t\t\tMsg.debug(this, \"Invalid sort comparator request on %s at index %d (column count %d)\"\n+\t\t\t\t\t.formatted(getName(), columnIndex, tableColumns.size()));\n+\t\t\treturn null;\n+\t\t}\n \t\tDynamicTableColumn<ROW_TYPE, ?, ?> column = getColumn(columnIndex);\n \t\tComparator<Object> comparator =\n \t\t\t(Comparator<Object>) column.getComparator(this, columnIndex);",
    "output": "Fix a table exception seen when using Version Tracking"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n@@ -661,7 +661,9 @@ public void openPrograms(List<DomainFile> filesToOpen) {\n \t}\n \n \tprivate void openProgramLocations(List<ProgramLocator> locators) {\n-\n+\t\tif (locators.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n \t\tSet<ProgramLocator> toOpen = new LinkedHashSet<>(locators); \t// preserve order\n \n \t\t// ensure already opened programs are visible in the tool",
    "output": "Add guard for empty ProgramLocator list when opening programs."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n@@ -1111,8 +1111,11 @@ private List<FileSystemSearchPath> getSystemLibrarySearchPaths(List<Option> opti\n \t\tif (isLoadSystemLibraries(options) || shouldSearchAllPaths(options)) {\n \t\t\tList<Path> searchPaths = new ArrayList<>();\n \t\t\tfor (String str : LibrarySearchPathManager.getLibraryPathsList()) {\n+\t\t\t\tif (str.isBlank()) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \t\t\t\ttry {\n-\t\t\t\t\tPath path = Path.of(str).normalize();\n+\t\t\t\t\tPath path = Path.of(str.trim()).normalize();\n \t\t\t\t\tif (path.isAbsolute() && Files.exists(path)) {\n \t\t\t\t\t\tsearchPaths.add(path);\n \t\t\t\t\t}",
    "output": "Make AbstractLibrarySupportLoader.getSystemLibrarySearchPathsmore robust"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/PluginsConfiguration.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/PluginsConfiguration.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/PluginsConfiguration.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/PluginsConfiguration.java\n@@ -268,8 +268,12 @@ public List<PluginPackage> getPluginPackages() {\n \t}\n \n \tpublic List<PluginDescription> getPluginDescriptions(PluginPackage pluginPackage) {\n-\t\tList<PluginDescription> list = descriptionsByPackage.get(pluginPackage);\n \t\tList<PluginDescription> stableList = new ArrayList<>();\n+\t\tList<PluginDescription> list = descriptionsByPackage.get(pluginPackage);\n+\t\tif (list == null) {\n+\t\t\t// This should not happen.  This implies an environment where no plugins are found,\n+\t\t\treturn stableList;\n+\t\t}\n \t\tfor (PluginDescription pluginDescription : list) {\n \t\t\tif (pluginDescription.getStatus() == PluginStatus.UNSTABLE ||\n \t\t\t\tpluginDescription.getStatus() == PluginStatus.HIDDEN) {",
    "output": "Fix a bug for apps with no plugins found"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeader.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeader.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeader.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeader.java\n@@ -217,6 +217,9 @@ public String getToolTipText(MouseEvent e) {\n \t\t}\n \n \t\tTableCellRenderer headerRenderer = column.getHeaderRenderer();\n+\t\tif (headerRenderer == null) {\n+\t\t\treturn null;\n+\t\t}\n \t\tComponent component = headerRenderer.getTableCellRendererComponent(getTable(),\n \t\t\tcolumn.getHeaderValue(), false, false, 0, 0);\n \t\tint prefWidth = component.getPreferredSize().width;",
    "output": "Fix stack trace relating to table header tooltips"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/BundleHostTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/BundleHostTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/BundleHostTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/BundleHostTest.java\n@@ -36,7 +36,7 @@ public class BundleHostTest extends AbstractGhidraHeadlessIntegrationTest {\n \tprivate static final String TEMP_NAME_PREFIX = \"sourcebundle\";\n \n \t// the version of Guava Ghidra is currently using.\n-\tprivate static final int GUAVA_MAJOR_VERSION = 31;\n+\tprivate static final int GUAVA_MAJOR_VERSION = 32;\n \n \tprivate BundleHost bundleHost;\n \tprivate CapturingBundleHostListener capturingBundleHostListener;",
    "output": "Upgrade Guava to 32.1.3"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/GolangSymbolAnalyzer.java\n@@ -101,7 +101,7 @@ public boolean added(Program program, AddressSetView set, TaskMonitor monitor, M\n \t\t}\n \t\tlastTxId = txId;\n \n-\t\tif (isAlreadyImported(program)) {\n+\t\tif (isAlreadyAnalyzed(program)) {\n \t\t\tMsg.info(this, \"Golang analysis already performed, skipping.\");\n \t\t\treturn false;\n \t\t}\n@@ -796,12 +796,12 @@ private static class GolangAnalyzerOptions {\n \t}\n \n \t/**\n-\t * Returns true if DWARF has already been imported into the specified program.\n+\t * Returns true if Golang analysis has already been performed for the specified program.\n \t * \n \t * @param program {@link Program} to check\n-\t * @return true if DWARF has already been imported, false if not yet\n+\t * @return true if analysis has already been performed, false if not yet\n \t */\n-\tpublic static boolean isAlreadyImported(Program program) {\n+\tpublic static boolean isAlreadyAnalyzed(Program program) {\n \t\tOptions options = program.getOptions(Program.PROGRAM_INFO);\n \t\treturn options.getBoolean(ANALYZED_FLAG_OPTION_NAME, false);\n \t}",
    "output": "Fix golang analyzer javadoc / method name silly copy/paste left-over"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/app/services/TraceRmiService.java b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/app/services/TraceRmiService.java\n--- a/Ghidra/Debug/Debugger-api/src/main/java/ghidra/app/services/TraceRmiService.java\n+++ b/Ghidra/Debug/Debugger-api/src/main/java/ghidra/app/services/TraceRmiService.java\n@@ -34,7 +34,7 @@\n  */\n @ServiceInfo(\n \tdescription = \"A service for accepting and creating Trace RMI connections\",\n-\tdefaultProviderName = \"ghidra.app.plugin.core.debug.service.rmi.trace.TraceRmiPlugin\")\n+\tdefaultProviderName = \"ghidra.app.plugin.core.debug.service.tracermi.TraceRmiPlugin\")\n public interface TraceRmiService {\n \t/**\n \t * Get the address (and port) of the Trace RMI TCP server",
    "output": "Fix service defaultProvider class name."
  },
  {
    "input": "diff --git a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayWrapper.java b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayWrapper.java\n--- a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayWrapper.java\n+++ b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayWrapper.java\n@@ -55,7 +55,7 @@ public void setGraphDisplayListener(GraphDisplayListener listener) {\n \n \t@Override\n \tpublic void setFocusedVertex(AttributedVertex vertex, EventTrigger eventTrigger) {\n-\t\tSwing.runNow(() -> delegate.setFocusedVertex(vertex));\n+\t\tSwing.runNow(() -> delegate.setFocusedVertex(vertex, eventTrigger));\n \t}\n \n \t@Override",
    "output": "Fix program graph from bouncing location events"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleStatusTableModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleStatusTableModel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleStatusTableModel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleStatusTableModel.java\n@@ -337,7 +337,7 @@ public void bundlesAdded(Collection<GhidraBundle> bundles) {\n \t\t\t\tfor (GhidraBundle bundle : bundles) {\n \t\t\t\t\taddNewStatusNoFire(bundle);\n \t\t\t\t}\n-\t\t\t\tfireTableRowsInserted(index, bundles.size() - 1);\n+\t\t\t\tfireTableRowsInserted(index, index + bundles.size() - 1);\n \t\t\t});\n \t\t}\n ",
    "output": "Fix an IllegalOutOfBoundsException that occurred in the Bundle Manager when using JDK 21"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GFileChooserOptionsDialog.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GFileChooserOptionsDialog.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GFileChooserOptionsDialog.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GFileChooserOptionsDialog.java\n@@ -37,8 +37,6 @@ class GFileChooserOptionsDialog extends ReusableDialogComponentProvider {\n \n \t\taddOKButton();\n \t\taddCancelButton();\n-\n-\t\tsetPreferredSize(300, 100);\n \t}\n \n \t@Override",
    "output": "Fix bad preferred size"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/bookmark/CreateBookmarkDialog.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/bookmark/CreateBookmarkDialog.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/bookmark/CreateBookmarkDialog.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/bookmark/CreateBookmarkDialog.java\n@@ -114,6 +114,7 @@ private Component buildCentralPanel() {\n \n \t\tcategoryComboBox = new GhidraComboBox<>(getModel());\n \t\tcategoryComboBox.setEditable(true);\n+\t\tcategoryComboBox.setEnterKeyForwarding(true);\n \t\tdescriptionTextField = new JTextField(20);\n \n \t\tpanel.add(new JLabel(\"Address: \", SwingConstants.RIGHT));",
    "output": "Upgrade the Note Bookmark dialog to allow users to press Enter to close the dialog when the Category field is focused"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/StorageTableCellEditor.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/StorageTableCellEditor.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/StorageTableCellEditor.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/StorageTableCellEditor.java\n@@ -52,6 +52,8 @@ public boolean isCellEditable(EventObject e) {\n \t@Override\n \tpublic Component getTableCellEditorComponent(final JTable table, Object value,\n \t\t\tboolean isSelected, int row, int column) {\n+\n+\t\tstorage = null;\n \t\tString stringValue = value == null ? \"\" : value.toString();\n \t\tJTextField field = new JTextField(stringValue);\n \t\tfield.setBackground(getUneditableForegroundColor(isSelected));",
    "output": "Fix a Function Editor bag that caused incorrect custom storage setting when cancelling the storage editor dialog"
  },
  {
    "input": "diff --git a/Ghidra/Processors/Loongarch/src/main/java/ghidra/app/plugin/core/analysis/LoongsonAnalyzer.java b/Ghidra/Processors/Loongarch/src/main/java/ghidra/app/plugin/core/analysis/LoongsonAnalyzer.java\n--- a/Ghidra/Processors/Loongarch/src/main/java/ghidra/app/plugin/core/analysis/LoongsonAnalyzer.java\n+++ b/Ghidra/Processors/Loongarch/src/main/java/ghidra/app/plugin/core/analysis/LoongsonAnalyzer.java\n@@ -126,7 +126,7 @@ public boolean evaluateReturn(Varnode retVN, VarnodeContext context,\n \t\t\t};\n \n \t\teval.setTrustWritableMemory(trustWriteMemOption)\n-\t\t\t\t.setMinpeculativeOffset(minSpeculativeRefAddress)\n+\t\t\t\t.setMinSpeculativeOffset(minSpeculativeRefAddress)\n \t\t\t\t.setMaxSpeculativeOffset(maxSpeculativeRefAddress)\n \t\t\t\t.setMinStoreLoadOffset(minStoreLoadRefAddress)\n \t\t\t\t.setCreateComplexDataFromPointers(createComplexDataFromPointers);",
    "output": "Fix compilation error"
  },
  {
    "input": "diff --git a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java\n--- a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java\n+++ b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java\n@@ -1224,10 +1224,14 @@ private Map<Long, Map<Integer, Object>> mapFunctionScalarAndAddressOperands(\n \t\t\tif (map.keySet().isEmpty()) {\n \t\t\t\tcontinue;\n \t\t\t}\n-\n+\t\t\t\n \t\t\t// get offset from top of function to use in function to operandMap map\n-\t\t\tLong offset =\n-\t\t\t\tinst.getAddress().subtract(function.getEntryPoint().getOffset()).getOffset();\n+\t\t\t// can be positive or negative offset (positive means instruction address is after \n+\t\t\t// the entry address, negative means instruction address is before entry address)\n+\t\t\tLong entryOffset = function.getEntryPoint().getOffset();\n+\t\t\tLong instOffset = inst.getAddress().getOffset();\n+\t\t\tLong offset = instOffset - entryOffset;\n+\n \t\t\toffsetToOperandsMap.put(offset, map);\n \t\t}\n ",
    "output": "Upgrade to not use address.subtract to determine inst offset, which could in some cases cause an overflow error."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n@@ -1196,10 +1196,10 @@ else if (command instanceof PreboundDynamicLibraryCommand pbdlCommand) {\n \t\t\t}\n \n \t\t\tif (libraryPath != null) {\n-\t\t\t\tlibraryPaths.add(libraryPath);\n \t\t\t\tint index = libraryPath.lastIndexOf(\"/\");\n \t\t\t\tString libraryName = index != -1 ? libraryPath.substring(index + 1) : libraryPath;\n \t\t\t\tif (!libraryName.equals(program.getName())) {\n+\t\t\t\t\tlibraryPaths.add(libraryPath);\n \t\t\t\t\taddLibrary(libraryPath);\n \t\t\t\t\tprops.setString(\n \t\t\t\t\t\tExternalSymbolResolver.getRequiredLibraryProperty(libraryIndex++),",
    "output": "Fix a Mach-O load exception that could happen if a binary referred to itself as a dependent library"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/datatype/microsoft/MSDataTypeUtils.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/datatype/microsoft/MSDataTypeUtils.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/datatype/microsoft/MSDataTypeUtils.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/datatype/microsoft/MSDataTypeUtils.java\n@@ -173,7 +173,7 @@ public static DataType getMatchingDataType(Program program, DataType comparisonD\n \t\t\t\t// Can't get data type archive so just do nothing.\n \t\t\t}\n \t\t}\n-\t\treturn (matchingDt != null) ? matchingDt : comparisonDt;\n+\t\treturn (matchingDt != null) ? matchingDt.clone(programDTM) : comparisonDt;\n \t}\n \n \tprivate static DataType findMatchingDataType(DataType comparisonDt,",
    "output": "Add use of clone to MSDataTypeUtils when pulling datatype from archive"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/OldLanguage.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/OldLanguage.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/OldLanguage.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/OldLanguage.java\n@@ -251,7 +251,9 @@ void parseOldLanguage(Element root, boolean descriptionOnly)\n \t\t\t\tlangDescription = parseDescription(element, version);\n \t\t\t}\n \t\t\telse if (\"compiler\".equals(elementName)) {\n-\t\t\t\tassociatedCompilerSpecs.add(parseCompilerSpecDescription(element));\n+\t\t\t\tif (!descriptionOnly) {\n+\t\t\t\t\tassociatedCompilerSpecs.add(parseCompilerSpecDescription(element));\n+\t\t\t\t}\n \t\t\t}\n \t\t\telse if (\"spaces\".equals(elementName)) {\n \t\t\t\tif (spacesFound) {",
    "output": "Add missing x86 old language v2-v3 translators and corrected old language file parse bug"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java b/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java\n@@ -573,9 +573,12 @@ public Varnode getValue(Varnode varnode, boolean signed, ContextEvaluator evalua\n \t\t\t\t\tvalue = (value << 8 * (8 - size)) >> 8 * (8 - size);\n \t\t\t\t}\n \n-\t\t\t\t//  constants pulled from memory are suspec\n+\t\t\t\t// constants pulled from memory are suspect\n \t\t\t\t// unless memory is readonly, or given access from evaluator (trustWriteAccess)\n-\t\t\t\tint spaceId = (isReadOnly || evaluator.allowAccess(this, addr)) ? 0 : SUSPECT_OFFSET_SPACEID;\n+\t\t\t\tint spaceId = SUSPECT_OFFSET_SPACEID;\n+\t\t\t\tif (isReadOnly || (evaluator != null && evaluator.allowAccess(this, addr))) {\n+\t\t\t\t\tspaceId = 0;\n+\t\t\t\t}\n \t\t\t\treturn createVarnode(value, spaceId, size);\n \n \t\t\t}",
    "output": "Fix refactored code that was not checking for an evaluator before using it"
  },
  {
    "input": "diff --git a/Ghidra/Features/ProgramDiff/src/main/java/ghidra/app/plugin/core/diff/DiffActionManager.java b/Ghidra/Features/ProgramDiff/src/main/java/ghidra/app/plugin/core/diff/DiffActionManager.java\n--- a/Ghidra/Features/ProgramDiff/src/main/java/ghidra/app/plugin/core/diff/DiffActionManager.java\n+++ b/Ghidra/Features/ProgramDiff/src/main/java/ghidra/app/plugin/core/diff/DiffActionManager.java\n@@ -439,7 +439,7 @@ public void actionPerformed(ActionContext context) {\n \t\t}\n \n \t\tprivate void closeDiff() {\n-\t\t\tint choice = OptionDialog.showYesNoCancelDialog(null, \"Close Diff Session\",\n+\t\t\tint choice = OptionDialog.showYesNoDialog(null, \"Close Diff Session\",\n \t\t\t\t\"Close the current diff session?\");\n \t\t\tif (choice == OptionDialog.YES_OPTION) {\n \t\t\t\tplugin.closeProgram2();",
    "output": "Fix incorrect dialog usage"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/DockableToolBarManager.java b/Ghidra/Framework/Docking/src/main/java/docking/DockableToolBarManager.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/DockableToolBarManager.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/DockableToolBarManager.java\n@@ -207,6 +207,11 @@ public void actionPerformed(ActionContext context) {\n \t\t@Override\n \t\tpublic boolean isEnabledForContext(ActionContext context) {\n \t\t\tComponentProvider provider = context.getComponentProvider();\n+\t\t\tif (provider == null) {\n+\t\t\t\t// Some context providers do not specify the provider when creating a contexts\n+\t\t\t\tDockingWindowManager dwm = DockingWindowManager.getActiveInstance();\n+\t\t\t\tprovider = dwm.getActiveComponentProvider();\n+\t\t\t}\n \t\t\treturn provider == dockableComponent.getComponentProvider();\n \t\t}\n \t}",
    "output": "Fix the component provider close button being disabled in some providers"
  },
  {
    "input": "diff --git a/Ghidra/Features/GnuDemangler/src/main/java/ghidra/app/util/demangler/gnu/GnuDemanglerParser.java b/Ghidra/Features/GnuDemangler/src/main/java/ghidra/app/util/demangler/gnu/GnuDemanglerParser.java\n--- a/Ghidra/Features/GnuDemangler/src/main/java/ghidra/app/util/demangler/gnu/GnuDemanglerParser.java\n+++ b/Ghidra/Features/GnuDemangler/src/main/java/ghidra/app/util/demangler/gnu/GnuDemanglerParser.java\n@@ -367,7 +367,7 @@ private DemangledObjectBuilder getSpecializedBuilder(String demangled) {\n \t\t// Note: this really is a 'special handler' check that used to be handled above.  However,\n \t\t//       some demangled operator strings begin with this text.  If we do this check above,\n \t\t//       then we will not correctly handle those operators.\n-\t\tif (mangledSource.startsWith(\"_ZZ\")) {\n+\t\tif (mangledSource.startsWith(\"_ZZ\") || mangledSource.startsWith(\"__ZZ\")) {\n \t\t\treturn new ItemInNamespaceHandler(demangled);\n \t\t}\n ",
    "output": "Fix follow-on issue discovered when testing a Swift binary"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/mgr/BackgroundCommandTask.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/mgr/BackgroundCommandTask.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/mgr/BackgroundCommandTask.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/mgr/BackgroundCommandTask.java\n@@ -87,6 +87,7 @@ public void run(TaskMonitor monitor) {\n \t\t\t\ttaskMgr.clearTasks(obj);\n \t\t\t\ttaskMgr.taskFailed(obj, cmd, monitor);\n \t\t\t}\n+\t\t\tTaskUtilities.removeTrackedTask(this);\n \t\t\treturn;\n \t\t}\n \t\tfinally {",
    "output": "Fix edge case that prevented the tracked task from not getting removed"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/DefaultMemoryRecorder.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/DefaultMemoryRecorder.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/DefaultMemoryRecorder.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/DefaultMemoryRecorder.java\n@@ -111,7 +111,12 @@ public void removeProcessRegion(TargetMemoryRegion region) {\n \t\t\t\t\tMsg.warn(this, \"Could not find region \" + path + \" in trace to remove\");\n \t\t\t\t\treturn;\n \t\t\t\t}\n-\t\t\t\ttraceRegion.setDestructionSnap(snap - 1);\n+\t\t\t\tif (traceRegion.getCreationSnap() >= snap) {\n+\t\t\t\t\ttraceRegion.delete();\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\ttraceRegion.setDestructionSnap(snap - 1);\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcatch (DuplicateNameException | TraceOverlappedRegionException e) {\n \t\t\t\t// Region is shrinking in time",
    "output": "Fix memory region deletion in DTR"
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/DefaultPdbApplicator.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/DefaultPdbApplicator.java\n--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/DefaultPdbApplicator.java\n+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/DefaultPdbApplicator.java\n@@ -555,6 +555,7 @@ void pdbLogAndErrorMessage(Object originator, String message, Exception exc) {\n \t * Returns the TaskMonitor\n \t * @return the monitor\n \t */\n+\t@Override\n \tpublic TaskMonitor getMonitor() {\n \t\treturn pdb.getMonitor();\n \t}\n@@ -951,7 +952,7 @@ void scheduleDeferredFunctionWork(DeferrableFunctionSymbolApplier applier) {\n \t\t// Not using normalized address is OK, as we should have already set the context and\n \t\t//  used the normalized address when creating the one-byte function\n \t\tdisassembleAddresses.add(applier.getAddress());\n-\t\tdeferredFunctionWorkAppliers.add(applier);\n+\t\t//deferredFunctionWorkAppliers.add(applier);\n \t}\n \n \t//==============================================================================================",
    "output": "Fix PDB memory issue in 10.4"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/html/HTMLDataTypeRepresentation.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/html/HTMLDataTypeRepresentation.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/html/HTMLDataTypeRepresentation.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/html/HTMLDataTypeRepresentation.java\n@@ -378,10 +378,13 @@ protected TextLine buildFooterText(DataType dataType) {\n \t\tif (length < 0) {\n \t\t\treturn new TextLine(\" <i>Unsized</i>\");\n \t\t}\n+\n \t\tif (dataType.isZeroLength()) {\n-\t\t\tlength = 0;\n+\t\t\treturn new TextLine(\"0\");\n \t\t}\n-\t\treturn new TextLine(Integer.toString(length));\n+\n+\t\treturn new TextLine(\n+\t\t\tInteger.toString(length) + \" (\" + NumericUtilities.toHexString(length) + \")\");\n \t}\n \n \tprivate static boolean canLinkDataType(DataType dt) {",
    "output": "Upgrade structure tooltips to show length in hex"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/FindDialog.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/FindDialog.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/FindDialog.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/FindDialog.java\n@@ -238,7 +238,6 @@ private void storeSearchText(String text) {\n \n \t\tMutableComboBoxModel<String> model = (MutableComboBoxModel<String>) comboBox.getModel();\n \t\tmodel.insertElementAt(text, 0);\n-\t\tmodel.setSelectedItem(text);\n \n \t\tint size = model.getSize();\n \t\tfor (int i = 1; i < size; i++) {\n@@ -249,5 +248,7 @@ private void storeSearchText(String text) {\n \t\t\t}\n \t\t}\n \n+\t\t// do this last since removing items may change the selected item\n+\t\tmodel.setSelectedItem(text);\n \t}\n }",
    "output": "Fix bug in the Find Dialog that caused incorrect text to be selected when pressing Enter for a previous match"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeComparePanel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeComparePanel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeComparePanel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeComparePanel.java\n@@ -116,9 +116,9 @@ void setDataTypes(DataType dataType1, DataType dataType2) {\n \t\tHTMLDataTypeRepresentation[] diffs = representation1.diff(representation2);\n \n \t\t// Display the data types.\n-\t\tString dt1Text = (dataType1 != null) ? diffs[0].getHTMLString() : \"\";\n-\t\tString dt2Text =\n-\t\t\t(dataType2 != null) ? diffs[1].getHTMLString() : (dataType1 != null) ? \"<Removed>\" : \"\";\n+\t\tString dt1Text = (dataType1 != null) ? diffs[0].getFullHTMLString() : \"\";\n+\t\tString dt2Text = (dataType2 != null) ? diffs[1].getFullHTMLString()\n+\t\t\t\t: (dataType1 != null) ? \"<Removed>\" : \"\";\n \t\tdtLabel1.setText(dt1Text);\n \t\tdtLabel2.setText(dt2Text);\n \t}",
    "output": "Fix the Data Type Sync dialog to use the full type text"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n@@ -1022,7 +1022,7 @@ private Queue<UnprocessedLibrary> createUnprocessedQueue(List<String> libraryNam\n \t * @param fsRef A {@link FileSystemRef}\n \t * @param fsPath A {@link Path} relative to the root of the file system, or null for the root\n \t */\n-\tprivate record FileSystemSearchPath(FileSystemRef fsRef, Path fsPath) {}\n+\tprotected record FileSystemSearchPath(FileSystemRef fsRef, Path fsPath) {}\n \n \t/**\n \t * Gets a {@link List} of priority-ordered custom {@link FileSystemSearchPath}s used to search ",
    "output": "Make AbstractLibrarySupportLoader.FileSystemSearchPath \"protected\""
  },
  {
    "input": "diff --git a/Ghidra/Processors/PowerPC/src/main/java/ghidra/app/plugin/core/analysis/PowerPCAddressAnalyzer.java b/Ghidra/Processors/PowerPC/src/main/java/ghidra/app/plugin/core/analysis/PowerPCAddressAnalyzer.java\n--- a/Ghidra/Processors/PowerPC/src/main/java/ghidra/app/plugin/core/analysis/PowerPCAddressAnalyzer.java\n+++ b/Ghidra/Processors/PowerPC/src/main/java/ghidra/app/plugin/core/analysis/PowerPCAddressAnalyzer.java\n@@ -256,11 +256,6 @@ public boolean evaluateReference(VarnodeContext context, Instruction instr,\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n-\t\t\t\t\t// markup the data flow for this instruction\n-\t\t\t\t\tif (refType.isData()) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\n \t\t\t\t\treturn super.evaluateReference(context, instr, pcodeop, address, size, dataType, refType);\n \t\t\t\t}\n ",
    "output": "Fix creation of undefined data type for PPC read/write references"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/spinner/IntegerSpinner.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/spinner/IntegerSpinner.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/spinner/IntegerSpinner.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/spinner/IntegerSpinner.java\n@@ -77,6 +77,7 @@ public void keyPressed(KeyEvent e) {\n \t\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (newVal != null) {\n+\t\t\t\t\te.consume();\n \t\t\t\t\tspinner.setValue(newVal);\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix integer spinner inc-value when up/down arrow key"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n@@ -108,10 +108,12 @@ public DataTypesProvider(DataTypeManagerPlugin plugin, String providerName,\n \t\tif (isTransient) {\n \t\t\tsetTransient();\n \t\t}\n+\t\telse {\n+\t\t\taddToToolbar();\n+\t\t}\n \n \t\tsetTitle(TITLE);\n \t\tsetIcon(new GIcon(\"icon.plugin.datatypes.provider\"));\n-\t\taddToToolbar();\n \n \t\tnavigationHistory.setAllowDuplicates(true);\n \n@@ -486,8 +488,8 @@ else if (type == EventType.EXITED) {\n \t\tpreviewScrollPane = new JScrollPane(previewPane);\n \n \t\tDockingWindowManager.getHelpService()\n-\t\t\t.registerHelp(previewScrollPane,\n-\t\t\t\tnew HelpLocation(\"DataTypeManagerPlugin\", \"Preview_Window\"));\n+\t\t\t\t.registerHelp(previewScrollPane,\n+\t\t\t\t\tnew HelpLocation(\"DataTypeManagerPlugin\", \"Preview_Window\"));\n \t}\n \n \tprivate DataType locateDataType(HyperlinkEvent event) {",
    "output": "Fix for stack trace being logged"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/util/MemoryBlockMap.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/util/MemoryBlockMap.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/util/MemoryBlockMap.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/util/MemoryBlockMap.java\n@@ -38,7 +38,7 @@ public void createMapping(int width) {\n \t\t\treturn;\n \t\t}\n \n-\t\tblocks = program.getMemory().getBlocks();\n+\t\tblocks = includeBlocks();\n \t\tpixels = new int[blocks.length];\n \t\tlong totalSize = 0;\n \t\tfor (MemoryBlock block : blocks) {\n@@ -50,6 +50,10 @@ public void createMapping(int width) {\n \t\t}\n \t}\n \n+\tprotected MemoryBlock[] includeBlocks() {\n+\t\treturn program.getMemory().getBlocks();\n+\t}\n+\n \t@Override\n \tpublic Address getAddress(int pixel) {\n \t\tif (pixels == null) {",
    "output": "Make the block set in MemorBlockMap overrideable"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-agent-lldb/src/test/java/agent/lldb/lldb/LLDBTest.java b/Ghidra/Debug/Debugger-agent-lldb/src/test/java/agent/lldb/lldb/LLDBTest.java\n--- a/Ghidra/Debug/Debugger-agent-lldb/src/test/java/agent/lldb/lldb/LLDBTest.java\n+++ b/Ghidra/Debug/Debugger-agent-lldb/src/test/java/agent/lldb/lldb/LLDBTest.java\n@@ -39,15 +39,17 @@ public class LLDBTest extends AbstractGhidraHeadlessIntegrationTest {\n \tpublic static void assumeLibLoadable() {\n \t\ttry {\n \t\t\tSystem.load(\"/usr/lib/liblldb.so\");\n+\t\t\treturn;\n \t\t}\n \t\tcatch (UnsatisfiedLinkError ex) {\n \t\t}\n \t\ttry {\n \t\t\tSystem.load(\"/usr/lib/liblldb.dylib\");\n+\t\t\treturn;\n \t\t}\n \t\tcatch (UnsatisfiedLinkError ex) {\n-\t\t\tassumeTrue(\"lldb not available\", false);\n \t\t}\n+\t\tassumeTrue(\"lldb not available\", false);\n \t}\n \n \tprivate SBDebugger sbd;",
    "output": "Fix lldb library loading logic. Accept either or."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/model/time/schedule/TestThread.java b/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/model/time/schedule/TestThread.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/model/time/schedule/TestThread.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/trace/model/time/schedule/TestThread.java\n@@ -181,4 +181,8 @@ public void clearInject(Address address) {\n \t@Override\n \tpublic void clearAllInjects() {\n \t}\n+\n+\t@Override\n+\tpublic void stepPatch(String sleigh) {\n+\t}\n }",
    "output": "Fix compilation error"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java\n@@ -1329,7 +1329,6 @@ private void saveTaskTimes() {\n \t\tString taskNames[] = getTimedTasks();\n \t\tfor (String element : taskNames) {\n \t\t\tlong taskTimeMSec = getTaskTime(timedTasks, element);\n-\t\t\tSystem.out.println(element + \": \" + taskTimeMSec);\n \t\t\ttimes.addTime(element, taskTimeMSec);\n \t\t}\n ",
    "output": "Remove debug print"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_Method.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_Method.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_Method.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objectiveC/ObjectiveC_Method.java\n@@ -1,6 +1,5 @@\n /* ###\n  * IP: GHIDRA\n- * REVIEWED: YES\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -52,7 +51,7 @@ public void applyTo(Namespace namespace) throws Exception {\n \t\tif (implementation == 0) {\n \t\t\treturn;\n \t\t}\n-\t\tif (getName() == null && getName().length() == 0) {\n+\t\tif (getName() == null || getName().length() == 0) {\n \t\t\treturn;\n \t\t}\n ",
    "output": "Fix bad logic in ObjectiveC_Method.java"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesPanel.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesPanel.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesPanel.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesPanel.java\n@@ -92,6 +92,9 @@ public String getColumnName() {\n \t\t@Override\n \t\tpublic String getValue(ValueRow rowObject, Settings settings, Trace data,\n \t\t\t\tServiceProvider serviceProvider) throws IllegalArgumentException {\n+\t\t\tif (data == null) {\n+\t\t\t\treturn \"\";\n+\t\t\t}\n \t\t\tValueAttribute<AddressRange> attr =\n \t\t\t\trowObject.getAttribute(TargetModule.RANGE_ATTRIBUTE_NAME, AddressRange.class);\n \t\t\tif (attr == null) {",
    "output": "Fix ModuleProvider tests"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/SleighUtils.java b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/SleighUtils.java\n--- a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/SleighUtils.java\n+++ b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/SleighUtils.java\n@@ -308,9 +308,12 @@ public static void matchDereference(Tree tree, Consumer<Tree> onSpace, Consumer<\n \t\t\t\t\t\tmatch(tree, SleighParser.OP_DEREFERENCE, onSize, onOffset);\n \t\t\t\t\t\treturn;\n \t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new AssertionError(\n-\t\t\t\t\t\t\t\"OP_DEREFERENCE with 2 children where child[0] is \" +\n-\t\t\t\t\t\t\t\tSleighParser.tokenNames[child0.getType()]);\n+\t\t\t\t\t\tmatchTree(tree, SleighParser.OP_DEREFERENCE, children -> {\n+\t\t\t\t\t\t\tthrow new AssertionError(\n+\t\t\t\t\t\t\t\t\"OP_DEREFERENCE with 2 children where child[0] is \" +\n+\t\t\t\t\t\t\t\t\tSleighParser.tokenNames[child0.getType()]);\n+\t\t\t\t\t\t});\n+\t\t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\tcase 1:\n \t\t\t\tmatch(tree, SleighParser.OP_DEREFERENCE, onOffset);",
    "output": "Fix error in tracking drop-down with certain watches."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java\n@@ -280,6 +280,9 @@ protected DataType resolveSelection(DataType dataType) {\n \t\t\tif (dataType == null) {\n \t\t\t\treturn null;\n \t\t\t}\n+\t\t\tif (currentTrace == null) {\n+\t\t\t\treturn dataType;\n+\t\t\t}\n \t\t\ttry (Transaction tx = currentTrace.openTransaction(\"Resolve DataType\")) {\n \t\t\t\treturn currentTrace.getDataTypeManager().resolve(dataType, null);\n \t\t\t}",
    "output": "Fix NPE when assigning watch types with no trace."
  },
  {
    "input": "diff --git a/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/MDMangGhidra.java b/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/MDMangGhidra.java\n--- a/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/MDMangGhidra.java\n+++ b/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/MDMangGhidra.java\n@@ -22,6 +22,7 @@\n import mdemangler.datatype.MDDataType;\n import mdemangler.datatype.MDVarArgsType;\n import mdemangler.datatype.complex.*;\n+import mdemangler.datatype.extended.MDArrayReferencedType;\n import mdemangler.datatype.modifier.*;\n import mdemangler.functiontype.*;\n import mdemangler.naming.*;\n@@ -817,6 +818,9 @@ else if (datatype instanceof MDArrayBasicType) {\n \t\telse if (datatype instanceof MDVarArgsType) {\n \t\t\tresultDataType.setVarArgs();\n \t\t}\n+\t\telse if (datatype instanceof MDArrayReferencedType arrRefType) {\n+\t\t\treturn processDataType(resultDataType, arrRefType.getReferencedType());\n+\t\t}\n \t\telse if (datatype instanceof MDStdNullPtrType) {\n \t\t\tresultDataType.setName(datatype.toString());\n \t\t}",
    "output": "Fix MicrosoftDemangler processing from ... failing test"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/textfield/HintTextField.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/textfield/HintTextField.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/textfield/HintTextField.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/textfield/HintTextField.java\n@@ -76,8 +76,9 @@ public HintTextField(String hint, boolean required, InputVerifier verifier) {\n \t\tthis.hint = hint;\n \t\tthis.required = required;\n \t\tthis.verifier = verifier;\n+\n \t\taddListeners();\n-\t\tsetAttributes();\n+\t\tsetFont(getFont().deriveFont(Font.PLAIN));\n \t\tvalidateField();\n \t}\n \n@@ -129,6 +130,7 @@ public void paintComponent(Graphics g) {\n \n \t\tGraphics2D g2 = (Graphics2D) g;\n \t\tg2.setColor(Messages.HINT);\n+\t\tg2.setFont(g2.getFont().deriveFont(Font.ITALIC));\n \t\tg2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n \n \t\tDimension size = getSize();\n@@ -176,14 +178,6 @@ public boolean isFieldValid() {\n \t\treturn true;\n \t}\n \n-\t/**\n-\t * Sets font/color attributes for the field.\n-\t */\n-\tprivate void setAttributes() {\n-\t\tsetFont(getFont().deriveFont(Font.PLAIN));\n-\t\tsetForeground(new GColor(\"color.fg.textfield.hint\"));\n-\t}\n-\n \t/**\n \t * Checks the validity of the field and sets the appropriate \n \t * field attributes.",
    "output": "Fix hint text field foreground color"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/DBTraceProgramView.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/DBTraceProgramView.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/DBTraceProgramView.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/program/DBTraceProgramView.java\n@@ -1227,7 +1227,7 @@ public Register getRegister(Varnode varnode) {\n \n \t@Override\n \tpublic Address getImageBase() {\n-\t\treturn language.getAddressFactory().getAddressSet().getMinAddress();\n+\t\treturn language.getDefaultSpace().getMinAddress();\n \t}\n \n \t@Override",
    "output": "Fix address hover outside of default address space."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/PcodeExecutor.java b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/PcodeExecutor.java\n--- a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/PcodeExecutor.java\n+++ b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/PcodeExecutor.java\n@@ -411,7 +411,9 @@ protected void branchToAddress(Address target) {\n \t * @param frame the frame to finish\n \t */\n \tprotected void branchToOffset(T offset, PcodeFrame frame) {\n-\t\tstate.setVar(pc, offset);\n+\t\tT truncOff = arithmetic.unaryOp(PcodeOp.COPY, pc.getMinimumByteSize(),\n+\t\t\t(int) arithmetic.sizeOf(offset), offset);\n+\t\tstate.setVar(pc, truncOff);\n \t\tframe.finishAsBranch();\n \t}\n ",
    "output": "Fix indirect branching operand size mismatch."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/threaded/TableUpdateJob.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/threaded/TableUpdateJob.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/threaded/TableUpdateJob.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/threaded/TableUpdateJob.java\n@@ -522,18 +522,26 @@ private void doSortData(List<T> data) {\n \n \t\tComparator<T> comparator = newSortContext.getComparator();\n \t\tComparator<T> monitoredComparator = new MonitoredComparator<>(comparator, monitor, size);\n+\n+\t\t// copy the data. If the sort is cancelled, the data could be corrupted\n+\t\tList<T> copy = new ArrayList<>(data);\n \t\ttry {\n \t\t\tCollections.sort(data, monitoredComparator);\n \t\t}\n \t\tcatch (SortCancelledException e) {\n-\t\t\t// do nothing, the old data will remain\n+\t\t\t// restore copy as data could be corrupted\n+\t\t\tdata.clear();\n+\t\t\tdata.addAll(copy);\n \t\t}\n \t\tcatch (Exception e) {\n \t\t\t// We added this to catch an issue if the sort comparators violate the contract of\n \t\t\t// Comparator.  TimSort will throw an exception in this case.  We have decided to not\n \t\t\t// throw the exception.  This will allow the currently loaded data to be used, albeit\n \t\t\t// unsorted.\n \t\t\tMsg.error(this, \"Unable to finish table sorting\", e);\n+\t\t\t// restore copy as data could be corrupted\n+\t\t\tdata.clear();\n+\t\t\tdata.addAll(copy);\n \t\t}\n \n \t\tmonitor.setMessage(\"Done sorting\");",
    "output": "Fix issue with cancelling table sort can cause table data corruption"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/Varnode.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/Varnode.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/Varnode.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/Varnode.java\n@@ -19,8 +19,7 @@\n import static ghidra.program.model.pcode.ElementId.*;\n \n import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n+import java.util.*;\n \n import ghidra.program.model.address.*;\n import ghidra.program.model.lang.Language;\n@@ -389,6 +388,8 @@ else if (attribId == ATTRIB_SIZE.id()) {\n \t\t\t\tVariableStorage storage = factory.getJoinStorage(pieces);\n \t\t\t\t// Update \"join\" address to the one just registered with the pieces\n \t\t\t\taddr = factory.getJoinAddress(storage);\n+\t\t\t\t// Update size to be the size of the pieces \n+\t\t\t\tsz = Arrays.stream(pieces).map(x -> x.getSize()).reduce(0, Integer::sum);\n \t\t\t}\n \t\t\tcatch (InvalidInputException e) {\n \t\t\t\tthrow new DecoderException(\"Invalid varnode pieces: \" + e.getMessage());",
    "output": "Fix sizes of varnodes in variable space"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/LocalFileChooserModel.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/LocalFileChooserModel.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/LocalFileChooserModel.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/LocalFileChooserModel.java\n@@ -260,6 +260,9 @@ private void asyncUpdateRootInfo(File[] localRoots, Callback callback) {\n \t\t\t\t\t}\n \n \t\t\t\t\tIcon rootIcon = FS_VIEW.getSystemIcon(root); // possibly a slow call\n+\t\t\t\t\tif (rootIcon == null) {\n+\t\t\t\t\t\trootIcon = PROBLEM_FILE_ICON;\n+\t\t\t\t\t}\n \t\t\t\t\ticonMap.put(root, rootIcon);\n \t\t\t\t\tcallback.call();\n \t\t\t\t}",
    "output": "Fix NPE LocalFileChooserModel"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/PreProcessorTest.java b/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/PreProcessorTest.java\n--- a/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/PreProcessorTest.java\n+++ b/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/PreProcessorTest.java\n@@ -127,6 +127,15 @@ public void testHeaderParsed() throws Exception {\n \t\t\t\t\"\\\" second line\\\"\\n\" + \n \t\t\t\t\"\\\" third line\\\"\\n\" + \n \t\t\t\t\"\\\" fourth line\\\")\") != -1);\n+\n+\t\tassertTrue(\"multi line #pragma failed \", results\n+\t\t\t.indexOf(\"#pragma  multiple lines pragma\") != -1);\n+\t\t\n+\t\tassertTrue(\"#pragma with comment failed \", results\n+\t\t\t.indexOf(\"#pragma  no comment here\") != -1);\n+\t\t\n+\t\tassertTrue(\"#pragma with EOL comment failed \", results\n+\t\t\t.indexOf(\"#pragma  with no EOL comment here\") != -1);\n \t}\n \n \t@Test",
    "output": "Fix C-parsing of #pragma lines with multiple lines and comments"
  },
  {
    "input": "diff --git a/Ghidra/Processors/ARM/src/main/java/ghidra/app/plugin/core/analysis/ArmAnalyzer.java b/Ghidra/Processors/ARM/src/main/java/ghidra/app/plugin/core/analysis/ArmAnalyzer.java\n--- a/Ghidra/Processors/ARM/src/main/java/ghidra/app/plugin/core/analysis/ArmAnalyzer.java\n+++ b/Ghidra/Processors/ARM/src/main/java/ghidra/app/plugin/core/analysis/ArmAnalyzer.java\n@@ -78,6 +78,7 @@ public boolean canAnalyze(Program program) {\n \tpublic AddressSet flowConstants(final Program program, Address flowStart,\n \t\t\tAddressSetView flowSet, final SymbolicPropogator symEval, final TaskMonitor monitor)\n \t\t\tthrows CancelledException {\n+\n \t\t// follow all flows building up context\n \t\t// use context to fill out addresses on certain instructions\n \t\tConstantPropagationContextEvaluator eval =\n@@ -229,11 +230,16 @@ public boolean evaluateDestination(VarnodeContext context,\n \t\t\t\t@Override\n \t\t\t\tpublic boolean evaluateReturn(Varnode retVN, VarnodeContext context, Instruction instruction) {\n \t\t\t\t\t// check if a return is actually returning, or is branching with a constant PC\n-\n+\t\t\t\t\t\n+\t\t\t\t\t// if flow already overridden, don't override again\n+\t\t\t\t\tif (instruction.getFlowOverride() != FlowOverride.NONE) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t\n \t\t\t\t\tif (retVN != null && context.isConstant(retVN)) {\n \t\t\t\t\t\tlong offset = retVN.getOffset();\n \t\t\t\t\t\tif (offset > 3 && offset != -1) {\n-\t\t\t\t\t\t\t// need to override the return to a branch\n+\t\t\t\t\t\t\t// need to override the return flow to a branch\n \t\t\t\t\t\t\tinstruction.setFlowOverride(FlowOverride.BRANCH);\n \t\t\t\t\t\t}\n \t\t\t\t\t}",
    "output": "Fix arm Branch/Return waffle if correct function boundaries not created and LR is detected as a constant"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldChainedPtr.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldChainedPtr.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldChainedPtr.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldChainedPtr.java\n@@ -174,6 +174,7 @@ public static boolean isRelative(DyldChainType ptrFormat) {\n \t\t\tcase DYLD_CHAINED_PTR_ARM64E_KERNEL:\n \t\t\tcase DYLD_CHAINED_PTR_ARM64E_USERLAND:\n \t\t\tcase DYLD_CHAINED_PTR_ARM64E_USERLAND24:\n+\t\t\tcase DYLD_CHAINED_PTR_64_KERNEL_CACHE:\n \t\t\tcase DYLD_CHAINED_PTR_X86_64_KERNEL_CACHE:\n \t\t\t\treturn true;\n \t\t\tdefault:",
    "output": "Fix a regression in the Mach-O Loader that was causing incorrect DYLD_CHAINED_PTR_64_KERNEL_CACHE fixups"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java\n@@ -846,6 +846,9 @@ private void doSetTrace(Trace trace) {\n \t\tremoveOldListeners();\n \t\tthis.currentTrace = trace;\n \t\taddNewListeners();\n+\t\tfor (WatchRow row : watchTableModel.getModelData()) {\n+\t\t\trow.updateType();\n+\t\t}\n \t}\n \n \tpublic void coordinatesActivated(DebuggerCoordinates coordinates) {",
    "output": "Fix restoration of Watch data type."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeOp.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeOp.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeOp.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeOp.java\n@@ -120,7 +120,7 @@ public class PcodeOp {\n \t// translation.\n \tpublic static final int MULTIEQUAL = 60;  // Output equal to one of inputs, depending on execution\n \tpublic static final int INDIRECT = 61;    // Output probably equals input, but may be indirectly affected\n-\tpublic static final int PIECE = 62;       // Output is constructed from multiple peices\n+\tpublic static final int PIECE = 62;       // Output is constructed from multiple pieces\n \tpublic static final int SUBPIECE = 63;    // Output is a subpiece of input0, input1=offset into input0\n \n \tpublic static final int CAST = 64;        // Cast from one type to another",
    "output": "Fix typo in comment in PcodeOp.java: 'peices' -> 'pieces'"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibrarySymbolTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibrarySymbolTable.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibrarySymbolTable.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibrarySymbolTable.java\n@@ -43,7 +43,7 @@\n class LibrarySymbolTable {\n \n \tprivate static final SimpleDateFormat TIMESTAMP_FORMAT =\n-\t\tnew SimpleDateFormat(\"EEE MMM dd hh:mm:ss zzz yyyy\");\n+\t\tnew SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n \n \tprivate static final int NONE = 0;\n \tprivate static final int LIBRARY = 1;",
    "output": "Fix a timestamp encoding bug that caused PE symbol .exports files to not get matched and applied in some circumstances"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableFilterPanel.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableFilterPanel.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableFilterPanel.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableFilterPanel.java\n@@ -146,6 +146,12 @@ public class GTableFilterPanel<ROW_OBJECT> extends JPanel {\n \tprivate SwingUpdateManager updateManager = new SwingUpdateManager(250, 1000, () -> {\n \t\tString text = filterField.getText();\n \t\tTableFilter<ROW_OBJECT> tableFilter = filterFactory.getTableFilter(text, transformer);\n+\n+\t\t// Having an edit active when the data changes can lead to incorrect row editing.  The table\n+\t\t// knows which row is being edited by number.   If the data for that row number changes as a\n+\t\t// result of a filter, the table does not know this and may update the wrong row data.\n+\t\ttable.editingCanceled(null);\n+\n \t\ttextFilterModel.setTableFilter(\n \t\t\tgetCombinedTableFilter(secondaryTableFilter, tableFilter, columnTableFilter));\n \t});",
    "output": "Fix stale table edit after filtering"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/AppInfo.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/AppInfo.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/AppInfo.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/AppInfo.java\n@@ -46,7 +46,7 @@ public static Project getActiveProject() {\n \n \tpublic static void exitGhidra() {\n \t\tassertFrontEndRunning();\n-\t\ttool.exit();\n+\t\ttool.close(); // closing the front end tool will exit the application\n \t}\n \n \tprivate static void assertFrontEndRunning() {",
    "output": "Fix issue where theme changes wern't save when exiting Ghidra via menu action"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n@@ -507,20 +507,22 @@ else if (linkSearchFolder != null &&\n \t\t\t\t\t// options turned off (if shouldSearchAllPaths() is overridden to return true).\n \t\t\t\t\t// In this case, we still want to process those libraries, but we \n \t\t\t\t\t// do not want to save them, so they can be released.\n+\t\t\t\t\tboolean loadedLocal = false;\n \t\t\t\t\tif (!localSearchPaths.isEmpty()) {\n \t\t\t\t\t\tLoaded<Program> loadedLibrary = loadLibraryFromSearchPaths(\n \t\t\t\t\t\t\tlibraryName, provider, localSearchPaths, libraryDestFolderPath,\n \t\t\t\t\t\t\tunprocessed, depth, desiredLoadSpec, options, log, consumer, monitor);\n \t\t\t\t\t\tif (loadedLibrary != null) {\n \t\t\t\t\t\t\tif (loadLocalLibraries) {\n \t\t\t\t\t\t\t\tloadedPrograms.add(loadedLibrary);\n+\t\t\t\t\t\t\t\tloadedLocal = true;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\tloadedLibrary.release(consumer);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tif (!systemSearchPaths.isEmpty()) {\n+\t\t\t\t\tif (!loadedLocal && !systemSearchPaths.isEmpty()) {\n \t\t\t\t\t\tLoaded<Program> loadedLibrary = loadLibraryFromSearchPaths(\n \t\t\t\t\t\t\tlibraryName, provider, systemSearchPaths, libraryDestFolderPath,\n \t\t\t\t\t\t\tunprocessed, depth, desiredLoadSpec, options, log, consumer, monitor);",
    "output": "Fix an IllegalStateException that could occur if both \"Load Local Libraries From Disk\" and \"Load System Libraries From Disk\" options are used during import, and the same library is found in both local and system directories"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n@@ -32,7 +32,6 @@\n import docking.event.mouse.GMouseListenerAdapter;\n import docking.menu.MultiActionDockingAction;\n import docking.widgets.OptionDialog;\n-import docking.widgets.PopupWindow;\n import docking.widgets.textpane.GHtmlTextPane;\n import docking.widgets.tree.*;\n import docking.widgets.tree.support.GTreeSelectionEvent.EventOrigin;\n@@ -476,15 +475,10 @@ private void buildPreviewPane() {\n \t\t\t\tsetDataTypeSelected(dt);\n \t\t\t}\n \t\t\telse if (type == EventType.ENTERED) {\n-\t\t\t\t//\n-\t\t\t\t// The user hovered over the link--show something useful, like the path\n-\t\t\t\t//\n-\t\t\t\tJToolTip toolTip = new JToolTip();\n-\t\t\t\tCategoryPath path = dt.getCategoryPath();\n-\t\t\t\ttoolTip.setTipText(path.toString());\n-\t\t\t\tPopupWindow popup = new PopupWindow(toolTip);\n-\t\t\t\tpopup.setCloseWindowDelay(10000);\n-\t\t\t\tpopup.showPopup((MouseEvent) event.getInputEvent());\n+\t\t\t\tpreviewPane.setToolTipText(dt.getCategoryPath().toString());\n+\t\t\t}\n+\t\t\telse if (type == EventType.EXITED) {\n+\t\t\t\tpreviewPane.setToolTipText(null);\n \t\t\t}\n \n \t\t});",
    "output": "Use built-in tooltip manager for DTM preview tooltips Should fix issues with ghost windows left over mentioned in . Seems to also fix issues with DTM preview tooltips in WSL linux where window focus switches and causes title bar flashing."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java\n@@ -294,13 +294,19 @@ private void calcHash(PcodeOp op, int slot, int method) {\n \t\t\t\t\tbuildOpUp(markop.get(opproc));\n \t\t\t\t}\n \t\t\t\tgatherUnmarkedVn();\n+\t\t\t\tfor (; vnproc < markvn.size(); ++vnproc) {\n+\t\t\t\t\tbuildVnUp(markvn.get(vnproc));\n+\t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase 6:\n \t\t\t\tgatherUnmarkedOp();\n \t\t\t\tfor (; opproc < markop.size(); ++opproc) {\n \t\t\t\t\tbuildOpDown(markop.get(opproc));\n \t\t\t\t}\n \t\t\t\tgatherUnmarkedVn();\n+\t\t\t\tfor (; vnproc < markvn.size(); ++vnproc) {\n+\t\t\t\t\tbuildVnDown(markvn.get(vnproc));\n+\t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tbreak;",
    "output": "Fix for calcHash methods 5 and 6"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n@@ -44,7 +44,8 @@ public class DataTypeArchiveIDTest extends AbstractGenericTest {\n \t\tGENERIC_CLIB_32_GDT_PATH, \"2644097909188870631\",\n \t\tGENERIC_CLIB_64_GDT_PATH, \"3193699959493190971\",\n \t\tMAC_OS_10_9_GDT_PATH, \"2650667045259492112\",\n-\t\t\"typeinfo/golang/golang_1.18_anybit_any.gdt\", \"3528902399865061936\");\n+\t\t\"typeinfo/golang/golang_1.18_anybit_any.gdt\", \"3528902399865061936\",\n+\t\t\"typeinfo/golang/golang_1.17_anybit_any.gdt\", \"3533627828569507753\");\n \n \tprivate Map<ResourceFile, String> getCurrentGdts() {\n \t\treturn Application.findFilesByExtensionInApplication(\".gdt\")",
    "output": "Fix archive id test for new golang 1.17 gdt"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n@@ -511,11 +511,14 @@ protected boolean processExports(MachHeader header) throws Exception {\n \t\tAddress baseAddr = space.getAddress(textSegment.getVMaddress());\n \t\tfor (ExportEntry export : exports) {\n \t\t\tString name = SymbolUtilities.replaceInvalidChars(export.getName(), true);\n-\t\t\tAddress exportAddr = baseAddr.add(export.getAddress());\n-\t\t\tprogram.getSymbolTable().addExternalEntryPoint(exportAddr);\n \t\t\ttry {\n+\t\t\t\tAddress exportAddr = baseAddr.add(export.getAddress());\n+\t\t\t\tprogram.getSymbolTable().addExternalEntryPoint(exportAddr);\n \t\t\t\tprogram.getSymbolTable().createLabel(exportAddr, name, SourceType.IMPORTED);\n \t\t\t}\n+\t\t\tcatch (AddressOutOfBoundsException e) {\n+\t\t\t\tlog.appendMsg(\"Failed to process export '\" + export + \"': \" + e.getMessage());\n+\t\t\t}\n \t\t\tcatch (Exception e) {\n \t\t\t\tlog.appendMsg(\"Unable to create symbol: \" + e.getMessage());\n \t\t\t}",
    "output": "Fix an AddressOutOfBoundsException that could sometimes occur when importing the exports section of dyld_shared_cache files"
  },
  {
    "input": "diff --git a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerFieldAccess.java b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerFieldAccess.java\n--- a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerFieldAccess.java\n+++ b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerFieldAccess.java\n@@ -51,7 +51,6 @@ public DataType getDataType() {\n \t\tDataType dt = field.getDataType();\n \t\tdt = getBaseType(dt);\n \t\tif (!(dt instanceof Composite)) {\n-\t\t\t// can the dt be a pointer?\n \t\t\tMsg.error(this, \"Have a field for a type that is not a Composite type\");\n \t\t\treturn dt;\n \t\t}\n@@ -65,6 +64,11 @@ public DataType getDataType() {\n \t\t\t}\n \t\t}\n \n+\t\tint n = composite.getNumComponents();\n+\t\tif (offset >= n) {\n+\t\t\t// how sure when this condition can happen, but we have seen this in the wild\n+\t\t\treturn null;\n+\t\t}\n \t\tDataTypeComponent component = composite.getComponent(offset);\n \t\tif (component == null) {\n \t\t\treturn null; // not sure what else to do",
    "output": "Fix IndexOutOfBoundsException"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldChainedPtr.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldChainedPtr.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldChainedPtr.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldChainedPtr.java\n@@ -174,6 +174,7 @@ public static boolean isRelative(DyldChainType ptrFormat) {\n \t\t\tcase DYLD_CHAINED_PTR_ARM64E_KERNEL:\n \t\t\tcase DYLD_CHAINED_PTR_ARM64E_USERLAND:\n \t\t\tcase DYLD_CHAINED_PTR_ARM64E_USERLAND24:\n+\t\t\tcase DYLD_CHAINED_PTR_X86_64_KERNEL_CACHE:\n \t\t\t\treturn true;\n \t\t\tdefault:\n \t\t\t\treturn false;",
    "output": "Fix DYLD_CHAINED_PTR_X86_64_KERNEL_CACHE fixups"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProvider.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProvider.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProvider.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProvider.java\n@@ -44,6 +44,7 @@\n import generic.theme.GThemeDefaults.Colors;\n import ghidra.app.context.ListingActionContext;\n import ghidra.app.nav.ListingPanelContainer;\n+import ghidra.app.plugin.core.clipboard.CodeBrowserClipboardProvider;\n import ghidra.app.plugin.core.codebrowser.CodeViewerProvider;\n import ghidra.app.plugin.core.codebrowser.MarkerServiceBackgroundColorModel;\n import ghidra.app.plugin.core.debug.DebuggerCoordinates;\n@@ -674,6 +675,19 @@ protected ListingActionContext newListingActionContext() {\n \t\treturn new DebuggerListingActionContext(this);\n \t}\n \n+\t@Override\n+\tprotected CodeBrowserClipboardProvider newClipboardProvider() {\n+\t\treturn new CodeBrowserClipboardProvider(tool, this) {\n+\t\t\t@Override\n+\t\t\tpublic boolean isValidContext(ActionContext context) {\n+\t\t\t\tif (!(context instanceof DebuggerListingActionContext)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\treturn context.getComponentProvider() == componentProvider;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n \tprotected void createActions() {\n \t\tif (isMainListing()) {\n \t\t\tactionAutoSyncCursorWithStaticListing =",
    "output": "Fix paste into Dynamic Listing"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-agent-lldb/src/main/java/agent/lldb/model/impl/LldbModelTargetThreadImpl.java b/Ghidra/Debug/Debugger-agent-lldb/src/main/java/agent/lldb/model/impl/LldbModelTargetThreadImpl.java\n--- a/Ghidra/Debug/Debugger-agent-lldb/src/main/java/agent/lldb/model/impl/LldbModelTargetThreadImpl.java\n+++ b/Ghidra/Debug/Debugger-agent-lldb/src/main/java/agent/lldb/model/impl/LldbModelTargetThreadImpl.java\n@@ -94,7 +94,7 @@ public LldbModelTargetThreadImpl(LldbModelTargetThreadContainer threads,\n \t\t\tACCESSIBLE_ATTRIBUTE_NAME, accessible = false, //\n \t\t\tDISPLAY_ATTRIBUTE_NAME, getDisplay(), //\n \t\t\tSTATE_ATTRIBUTE_NAME, TargetExecutionState.ALIVE, //\n-\t\t\tTID_ATTRIBUTE_NAME, thread.GetThreadID().intValue(), //\n+\t\t\tTID_ATTRIBUTE_NAME, thread.GetThreadID().longValue(), //\n \t\t\tSUPPORTED_STEP_KINDS_ATTRIBUTE_NAME, SUPPORTED_KINDS //\n \t\t), \"Initialized\");\n ",
    "output": "Fix wrong type for TID_ATTRIBUTE_NAME in LldbModelTargetThreadImpl.java"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java\n--- a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java\n+++ b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RTTIGccClassRecoverer.java\n@@ -204,6 +204,11 @@ public List<RecoveredClass> createRecoveredClasses() throws CancelledException,\n \t\t\tMsg.debug(this, \"Could not create special vtables\");\n \t\t\treturn null;\n \t\t}\n+\t\t\n+\t\tif(specialVtables.size() != specialTypeinfos.size()) {\n+\t\t\tMsg.debug(this, \"Not equal number of special vtables and special typeinfos\");\n+\t\t\treturn null;\n+\t\t}\n \n \t\tsetComponentOffset();\n \n@@ -3382,6 +3387,13 @@ private Address findSpecialVtableUsingSpecialTypeinfo(Address typeinfoAddress, L\n \t\t\tif (specialTypeinfoAddrSet.contains(refTo)) {\n \t\t\t\tcontinue;\n \t\t\t}\n+\n+\t\t\t// all special vtables have zeros just before the ref to typeinfo\n+\t\t\tAddress vtableAddress = refTo.subtract(defaultPointerSize);\n+\t\t\tif (!isPossibleNullPointer(vtableAddress)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\tpossibleRefsInVtable.add(refTo);\n \t\t}\n \t\tif (possibleRefsInVtable.size() != 1) {",
    "output": "Fix case where si vtable was not getting created bc too many refs. Added secondary check. Added check for same num special vtable and typeinfos."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java\n@@ -301,7 +301,7 @@ void showToolTipPopup(MouseEvent event, String tip) {\n \tList<String> getMarkerTooltipLines(Program program, int y, int x, Address minAddr,\n \t\t\tAddress maxAddr) {\n \t\tMarkerSetCacheEntry entry = markerSetCache.get(program);\n-\t\treturn entry.getTooltipLines(y, x, minAddr, maxAddr);\n+\t\treturn entry == null ? List.of() : entry.getTooltipLines(y, x, minAddr, maxAddr);\n \t}\n \n \tstatic String getMarkerToolTip(MarkerSetImpl marker, Address a, int x, int y) {",
    "output": "Fix NPE by returning empty list."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/proxy/VariableProxy.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/proxy/VariableProxy.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/proxy/VariableProxy.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/proxy/VariableProxy.java\n@@ -15,6 +15,8 @@\n  */\n package ghidra.app.util.viewer.proxy;\n \n+import java.util.Objects;\n+\n import ghidra.app.util.viewer.listingpanel.ListingModel;\n import ghidra.program.model.address.Address;\n import ghidra.program.model.data.Pointer;\n@@ -23,7 +25,7 @@\n import ghidra.program.model.symbol.Reference;\n \n /**\n- * Stores information about a variable in a program such that the variable can \n+ * Stores information about a variable in a program such that the variable can\n  * be retrieved when needed.\n  */\n public class VariableProxy extends ProxyObj<Variable> {\n@@ -130,6 +132,6 @@ public boolean contains(Address a) {\n \t\tif (v == null) {\n \t\t\treturn false;\n \t\t}\n-\t\treturn v.getMinAddress().equals(a);\n+\t\treturn Objects.equals(v.getMinAddress(), a);\n \t}\n }",
    "output": "Fix potential NPE"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/GoToAddressLabelDialog.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/GoToAddressLabelDialog.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/GoToAddressLabelDialog.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/navigation/GoToAddressLabelDialog.java\n@@ -24,8 +24,8 @@\n import javax.swing.event.HyperlinkEvent;\n import javax.swing.event.HyperlinkListener;\n \n-import docking.DialogComponentProvider;\n import docking.DockingWindowManager;\n+import docking.ReusableDialogComponentProvider;\n import docking.tool.ToolConstants;\n import docking.widgets.HyperlinkComponent;\n import docking.widgets.checkbox.GCheckBox;\n@@ -42,7 +42,8 @@\n import ghidra.util.HelpLocation;\n import ghidra.util.task.TaskMonitorComponent;\n \n-public class GoToAddressLabelDialog extends DialogComponentProvider implements GoToServiceListener {\n+public class GoToAddressLabelDialog extends ReusableDialogComponentProvider\n+\t\timplements GoToServiceListener {\n \n \t//////////////////////////////////////////////////////////////////////\n \t//                                                                  //",
    "output": "Fix goToDialog to handle theme switching"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/ghidra_scripts/SynchronizeGDTCategoryPaths.java b/Ghidra/Features/Base/ghidra_scripts/SynchronizeGDTCategoryPaths.java\n--- a/Ghidra/Features/Base/ghidra_scripts/SynchronizeGDTCategoryPaths.java\n+++ b/Ghidra/Features/Base/ghidra_scripts/SynchronizeGDTCategoryPaths.java\n@@ -56,6 +56,8 @@ protected void run() throws Exception {\n \t\t\t\t}\n \t\t\t\tfinally {\n \t\t\t\t\tsecondArchive.endTransaction(transactionID, true);\n+\t\t\t\t\tsecondArchive.save();\n+\t\t\t\t\tsecondArchive.close();\n \t\t\t\t}\n \t\t\t}\n \t\t}",
    "output": "Fix updated archive category path name case to agree with old archive category path names"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/datamgr/DataTypeArchiveIDTest.java\n@@ -44,8 +44,7 @@ public class DataTypeArchiveIDTest extends AbstractGenericTest {\n \t\tGENERIC_CLIB_32_GDT_PATH, \"2644097909188870631\",\n \t\tGENERIC_CLIB_64_GDT_PATH, \"3193699959493190971\",\n \t\tMAC_OS_10_9_GDT_PATH, \"2650667045259492112\",\n-\t\t\"typeinfo/golang/golang_1.18_32bit_any.gdt\", \"3516036612698499343\",\n-\t\t\"typeinfo/golang/golang_1.18_64bit_any.gdt\", \"3516036958082656531\");\n+\t\t\"typeinfo/golang/golang_1.18_anybit_any.gdt\", \"3528902399865061936\");\n \n \tprivate Map<ResourceFile, String> getCurrentGdts() {\n \t\treturn Application.findFilesByExtensionInApplication(\".gdt\")",
    "output": "Fix DataTypeArchiveIdTest for golang gdt"
  },
  {
    "input": "diff --git a/Ghidra/Processors/eBPF/src/main/java/ghidra/app/plugin/core/analysis/eBPFAnalyzer.java b/Ghidra/Processors/eBPF/src/main/java/ghidra/app/plugin/core/analysis/eBPFAnalyzer.java\n--- a/Ghidra/Processors/eBPF/src/main/java/ghidra/app/plugin/core/analysis/eBPFAnalyzer.java\n+++ b/Ghidra/Processors/eBPF/src/main/java/ghidra/app/plugin/core/analysis/eBPFAnalyzer.java\n@@ -61,7 +61,7 @@ public boolean canAnalyze(Program program) {\n     @Override\n     public AddressSet flowConstants(final Program program, Address flowStart, AddressSetView flowSet, final SymbolicPropogator symEval, final TaskMonitor monitor)\n     throws CancelledException {\n-        ContextEvaluator eval = new ConstantPropagationContextEvaluator(trustWriteMemOption);\n+        ContextEvaluator eval = new ConstantPropagationContextEvaluator(monitor, trustWriteMemOption);\n         AddressSet resultSet = symEval.flowConstants(flowStart, flowSet, eval, true, monitor);\n \n         BookmarkManager bmmanager = program.getBookmarkManager();",
    "output": "Fix compilation error"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/ghidra_scripts/CreateExampleGDTArchiveScript.java b/Ghidra/Features/Base/ghidra_scripts/CreateExampleGDTArchiveScript.java\n--- a/Ghidra/Features/Base/ghidra_scripts/CreateExampleGDTArchiveScript.java\n+++ b/Ghidra/Features/Base/ghidra_scripts/CreateExampleGDTArchiveScript.java\n@@ -188,7 +188,6 @@ public void parseGDT_WinVS22() throws Exception {\n \t\t\t\t\"accctrl.h\",\n \t\t\t\t\"aclapi.h\",\n \t\t\t\t\"aclui.h\",\n-\t\t\t\t\"advapi32.h\",\n \t\t\t\t\"adtgen.h\",\n \t\t\t\t\"authz.h\",\n \t\t\t\t\"azroles.h\",",
    "output": "Fix parsing of forward declared enums and certain typedefs declared and used within a function body"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/TypedEventDispatcher.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/TypedEventDispatcher.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/TypedEventDispatcher.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/TypedEventDispatcher.java\n@@ -168,8 +168,12 @@ protected void listenForUntyped(int type, Consumer<DomainObjectChangeRecord> han\n \tpublic void handleChangeRecord(DomainObjectChangeRecord rec) {\n \t\t//String typeName = DefaultTraceChangeType.getName(rec.getEventType());\n \t\t//CountsByType.compute(typeName, (k, v) -> v == null ? 1 : v + 1);\n-\t\tif (rec instanceof TraceChangeRecord) {\n-\t\t\thandleTraceChangeRecord((TraceChangeRecord<?, ?>) rec);\n+\t\tif (rec.getEventType() == DomainObject.DO_OBJECT_RESTORED && restoredHandler != null) {\n+\t\t\trestoredHandler.accept(rec);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (rec instanceof TraceChangeRecord<?, ?> cr) {\n+\t\t\thandleTraceChangeRecord(cr);\n \t\t\treturn;\n \t\t}\n \t\tConsumer<DomainObjectChangeRecord> handler;",
    "output": "Fix for DO_OBJECT_RESTORED post"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/disassemble/CurrentPlatformTraceDisassembleAction.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/disassemble/CurrentPlatformTraceDisassembleAction.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/disassemble/CurrentPlatformTraceDisassembleAction.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/disassemble/CurrentPlatformTraceDisassembleAction.java\n@@ -78,6 +78,15 @@ public boolean isAddToPopup(ActionContext context) {\n \t\treturn reqs != null;\n \t}\n \n+\t@Override\n+\tpublic boolean isEnabledForContext(ActionContext context) {\n+\t\tReqs reqs = getReqs(context);\n+\t\tif (reqs == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn super.isEnabledForContext(context);\n+\t}\n+\n \t@Override\n \tpublic void actionPerformed(ActionContext context) {\n \t\tReqs reqs = getReqs(context);",
    "output": "Fix D-key ambiguity in Debugger's static listing."
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/ShowConstantUse.java b/Ghidra/Features/Decompiler/ghidra_scripts/ShowConstantUse.java\n--- a/Ghidra/Features/Decompiler/ghidra_scripts/ShowConstantUse.java\n+++ b/Ghidra/Features/Decompiler/ghidra_scripts/ShowConstantUse.java\n@@ -868,8 +868,7 @@ private void followToParam(HashMap<Address, Long> constUse, ArrayList<PcodeOp> d\n \t\t\t\treturn;\n \t\t\tcase PcodeOp.MULTIEQUAL:\n \t\t\t\tfor (int i = 0; i < def.getNumInputs(); i++) {\n-\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n-\t\t\t\t\tArrayList<PcodeOp> splitUseList = (ArrayList<PcodeOp>) defUseList.clone();\n+\t\t\t\t\tArrayList<PcodeOp> splitUseList = new ArrayList<>(defUseList);\n \t\t\t\t\tfollowToParam(constUse, splitUseList, highFunction, def.getInput(i), funcList,\n \t\t\t\t\t\tdoneSet);\n \t\t\t\t}",
    "output": "Remove annotation & clone"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/DBTrace.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/DBTrace.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/DBTrace.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/DBTrace.java\n@@ -186,7 +186,7 @@ public DBTrace(DBHandle dbh, DBOpenMode openMode, TaskMonitor monitor, Object co\n \t\tsuper(dbh, openMode, monitor, \"Untitled\", DB_TIME_INTERVAL, DB_BUFFER_SIZE, consumer);\n \t\tthis.storeFactory = new DBCachedObjectStoreFactory(this);\n \n-\t\ttry {\n+\t\ttry (Transaction tx = this.openTransaction(\"Create\")) {\n \t\t\tinitOptions(openMode);\n \t\t\tinit();\n \t\t}",
    "output": "Add missing transaction to DBTrace constructor"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/AbstractBaseDBTraceDefinedUnitsView.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/AbstractBaseDBTraceDefinedUnitsView.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/AbstractBaseDBTraceDefinedUnitsView.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/AbstractBaseDBTraceDefinedUnitsView.java\n@@ -376,8 +376,11 @@ protected Lifespan truncateSoonestDefined(Lifespan span, AbstractDBTraceCodeUnit\n \t\tif (extending == null) {\n \t\t\ttoScan = span;\n \t\t}\n+\t\telse if (span.lmax() <= extending.getEndSnap()) {\n+\t\t\t// we're shrinking or staying the same, so not possible to collide with others\n+\t\t\treturn span;\n+\t\t}\n \t\telse {\n-\t\t\tassert span.lmax() > extending.getEndSnap();\n \t\t\ttoScan = span.withMin(extending.getEndSnap() + 1);\n \t\t}\n \t\tT truncateBy =",
    "output": "Fix IllegalArgumentException when emulating backwards."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/cparser/C/CParserUtils.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/cparser/C/CParserUtils.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/cparser/C/CParserUtils.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/cparser/C/CParserUtils.java\n@@ -531,9 +531,19 @@ public static CParseResults parseHeaderFiles(DataTypeManager[] openDTmanagers, S\n \t\tcpp.addIncludePaths(includePaths);\n \n \t\tPrintStream os = System.out;\n-\t\tString fName = dtMgr.getName().replace(\".gdt\",\"\")+\"_CParser.out\";\n+\t\t\n+\t\tString fName = dtMgr.getName();\n+\t\t\n+\t\t// make a path to tmpdir with name of data type manager\n+\t\tString path = System.getProperty(\"java.io.tmpdir\") + File.pathSeparator + fName;\n+\t\t// if file data type manager, use path to .gdt file\n+\t\tif (dtMgr instanceof FileDataTypeManager) {\n+\t\t\tpath = ((FileDataTypeManager) dtMgr).getPath();\n+\t\t}\n+\t\tpath = path + \"_CParser.out\";\n+\t\t\n \t\ttry {\n-\t\t\tos = new PrintStream(new FileOutputStream(fName));\n+\t\t\tos = new PrintStream(new FileOutputStream(path));\n \t\t} catch (FileNotFoundException e2) {\n \t\t\tMsg.error(CParserUtils.class, \"Unexpected Exception: \" + e2.getMessage(), e2);\n \t\t}",
    "output": "Fix for cparser .out file not in CWD"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ExternalSymbolResolverAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ExternalSymbolResolverAnalyzer.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ExternalSymbolResolverAnalyzer.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ExternalSymbolResolverAnalyzer.java\n@@ -44,7 +44,7 @@ public class ExternalSymbolResolverAnalyzer extends AbstractAnalyzer {\n \t\t\"Links unresolved external symbols to the first symbol found in the program's required libraries list (found in program properties).\";\n \n \t/**\n-\t * Creates a new {@link MachoFunctionStartsAnalyzer} \n+\t * Creates a new {@link ExternalSymbolResolverAnalyzer} \n \t */\n \tpublic ExternalSymbolResolverAnalyzer() {\n \t\tsuper(NAME, DESCRIPTION, AnalyzerType.BYTE_ANALYZER);\n@@ -57,6 +57,11 @@ public ExternalSymbolResolverAnalyzer() {\n \n \t@Override\n \tpublic boolean canAnalyze(Program program) {\n+\t\t// This analyzer needs to look around the project for imported libraries\n+\t\tif (program.getDomainFile().getParent() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n \t\tOptions options = program.getOptions(Program.PROGRAM_INFO);\n \t\tString format = options.getString(\"Executable Format\", null);\n \t\treturn ElfLoader.ELF_NAME.equals(format) || MachoLoader.MACH_O_NAME.equals(format);",
    "output": "Improve ExternalSymbolResolverAnalyzer.canAnalyzecheck"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/RecoverClassesFromRTTIScript.java b/Ghidra/Features/Decompiler/ghidra_scripts/RecoverClassesFromRTTIScript.java\n--- a/Ghidra/Features/Decompiler/ghidra_scripts/RecoverClassesFromRTTIScript.java\n+++ b/Ghidra/Features/Decompiler/ghidra_scripts/RecoverClassesFromRTTIScript.java\n@@ -355,7 +355,7 @@ public String validate() {\n \t\t\treturn (\"There is no open program\");\n \t\t}\n \n-\t\tif (!GhidraProgramUtilities.isAnalyzedFlagSet(currentProgram)) {\n+\t\tif (!GhidraProgramUtilities.isAnalyzed(currentProgram)) {\n \t\t\treturn (\"The program has not been analyzed. Please run auto-analysis and make sure \" +\n \t\t\t\t\"the RTTI analzer is one of the analyzers enabled.\");\n \t\t}",
    "output": "Fix compilation issue"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-agent-lldb/src/main/java/agent/lldb/model/impl/LldbModelTargetProcessLaunchWithOptionsConnectorImpl.java b/Ghidra/Debug/Debugger-agent-lldb/src/main/java/agent/lldb/model/impl/LldbModelTargetProcessLaunchWithOptionsConnectorImpl.java\n--- a/Ghidra/Debug/Debugger-agent-lldb/src/main/java/agent/lldb/model/impl/LldbModelTargetProcessLaunchWithOptionsConnectorImpl.java\n+++ b/Ghidra/Debug/Debugger-agent-lldb/src/main/java/agent/lldb/model/impl/LldbModelTargetProcessLaunchWithOptionsConnectorImpl.java\n@@ -122,7 +122,7 @@ protected Map<String, ParameterDescription<?>> computeParameters() {\n \t\tParameterDescription<Boolean> pF8 =\n \t\t\tParameterDescription.create(Boolean.class, \"ExitRace\", false,\n \t\t\t\tfalse, \"Suppress race on exit\",\n-\t\t\t\t\"set this flag so lldb & the handee dont race to set its exit status\");\n+\t\t\t\t\"set this flag so lldb & the handee don't race to set its exit status\");\n \t\tmap.put(\"ExitRace\", pF8);\n \t\tParameterDescription<Boolean> pF9 = ParameterDescription.create(Boolean.class, \"Detach\",\n \t\t\tfalse,",
    "output": "Fix warning \"error: unmappable character (0xE2) for encoding US-ASCII\" > Task :Debugger-agent-lldb:compileJava /tmp/ghidra/Ghidra/Debug/Debugger-agent-lldb/src/main/java/agent/lldb/model/impl/LldbModelTargetProcessLaunchWithOptionsConnectorImpl.java:125: error: unmappable character (0xE2) for encoding US-ASCII \"set this flag so lldb & the handee don???t race to set its exit status\"); ^ /tmp/ghidra/Ghidra/Debug/Debugger-agent-lldb/src/main/java/agent/lldb/model/impl/LldbModelTargetProcessLaunchWithOptionsConnectorImpl.java:125: error: unmappable character (0x80) for encoding US-ASCII \"set this flag so lldb & the handee don???t race to set its exit status\"); ^ /tmp/ghidra/Ghidra/Debug/Debugger-agent-lldb/src/main/java/agent/lldb/model/impl/LldbModelTargetProcessLaunchWithOptionsConnectorImpl.java:125: error: unmappable character (0x99) for encoding US-ASCII \"set this flag so lldb & the handee don???t race to set its exit status\");"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/PreProcessorTest.java b/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/PreProcessorTest.java\n--- a/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/PreProcessorTest.java\n+++ b/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/PreProcessorTest.java\n@@ -32,7 +32,10 @@ public class PreProcessorTest extends AbstractGenericTest {\n \tprivate static String resourceName = \"PreProcessorTest.h\";\n \tprivate static CategoryPath path =\n \t\tnew CategoryPath(new CategoryPath(\"/PreProcessorTest.h\"), \"defines\");\n-\n+\t\n+\tprivate static CategoryPath definedPath =\n+\t\t\tnew CategoryPath(new CategoryPath(\"/defined.h\"), \"defines\");\n+\t\n \t// must get rid of after all tests\n \tprivate static StandAloneDataTypeManager dtMgr;\n \tprivate static ByteArrayOutputStream baos = new ByteArrayOutputStream();\n@@ -399,6 +402,13 @@ public void testMultipleInclude() {\n \t\tassertEquals(\"No INCLUDE5 define\", \"INCLUDE5\", defval);\n \t}\n \t\n+\t@Test\n+\tpublic void testDefinedInclude() {\n+\t\tdefname = \"DID_INCLUDE_DEFINED_INCLUDED\";\n+\t\tvalue = 1;\n+\t\tcheckDefine(dtMgr, definedPath, value, defname);\n+\t}\n+\t\n \t@Test\n \tpublic void testVarags() {\n \t\tdefname = \"EPRINTF_VARARGS\";",
    "output": "Fix defined include file names and pre-processor constants with size specification of UL and LL"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java\n@@ -827,6 +827,10 @@ String getDisplayName(File file) {\n \t\t\treturn \"\";\n \t\t}\n \n+\t\tif (isDisposed()) {\n+\t\t\treturn \"\";\n+\t\t}\n+\n \t\tif (GhidraFileChooser.MY_COMPUTER.equals(getCurrentDirectory())) {\n \t\t\tString str = getModel().getDescription(file);\n \t\t\tif (str == null || str.length() == 0) {\n@@ -840,6 +844,10 @@ else if (GhidraFileChooser.RECENT.equals(getCurrentDirectory())) {\n \t\treturn getFilename(file) + \"  \";\n \t}\n \n+\tprivate boolean isDisposed() {\n+\t\treturn fileChooserModel == null;\n+\t}\n+\n \tprivate void setDirectoryList(File directory, List<File> files) {\n \t\t// if the visible listing is still the same directory as this incoming list of files\n \t\tif (currentDirectory().equals(directory)) {",
    "output": "Fix file chooser NPE"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/CodeBrowserOptionsTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/CodeBrowserOptionsTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/CodeBrowserOptionsTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/CodeBrowserOptionsTest.java\n@@ -197,6 +197,7 @@ public void testOptionsHeaders() throws Exception {\n \t\tassertEquals(\"Pre-comments Field\", groups[idx++]);\n \t\tassertEquals(\"Register Field\", groups[idx++]);\n \t\tassertEquals(\"Selection Colors\", groups[idx++]);\n+\t\tassertEquals(\"Templates\", groups[idx++]);\n \t\tassertEquals(\"XREFs Field\", groups[idx++]);\n \t}\n ",
    "output": "Fix simple trip wire test for added category of listing sub-options"
  },
  {
    "input": "diff --git a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerReference.java b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerReference.java\n--- a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerReference.java\n+++ b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerReference.java\n@@ -156,15 +156,20 @@ else if (dt instanceof TypeDef) {\n \tpublic static DataType getFieldDataType(ClangFieldToken field) {\n \t\tDataType fieldDt = field.getDataType();\n \t\tfieldDt = DecompilerReference.getBaseType(fieldDt);\n-\t\tif (fieldDt instanceof Structure) {\n-\t\t\tStructure parent = (Structure) fieldDt;\n-\t\t\tint offset = field.getOffset();\n-\t\t\tint n = parent.getLength();\n-\t\t\tif (offset >= 0 && offset < n) {\n-\t\t\t\tDataTypeComponent dtc = parent.getComponentContaining(field.getOffset());\n+\t\tif (!(fieldDt instanceof Structure)) {\n+\t\t\treturn fieldDt;\n+\t\t}\n+\n+\t\tStructure parent = (Structure) fieldDt;\n+\t\tint offset = field.getOffset();\n+\t\tint n = parent.getLength();\n+\t\tif (offset >= 0 && offset < n) {\n+\t\t\tDataTypeComponent dtc = parent.getComponentContaining(field.getOffset());\n+\t\t\tif (dtc != null) {\n \t\t\t\tfieldDt = dtc.getDataType();\n \t\t\t}\n \t\t}\n+\n \t\treturn fieldDt;\n \t}\n ",
    "output": "Fix exception in data type finder"
  },
  {
    "input": "diff --git a/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/IndexMap.java b/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/IndexMap.java\n--- a/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/IndexMap.java\n+++ b/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/IndexMap.java\n@@ -175,7 +175,7 @@ int getFirstActiveFactoryIndex(BigInteger index, FieldFactory[] factories) {\n \t * except for the last line of a block which may end part way in the line.\n \t */\n \tint getLastActiveFactoryIndex(BigInteger index, FieldFactory[] factories) {\n-\t\tfor (int i = factories.length - 1; i > 0; i--) {\n+\t\tfor (int i = factories.length - 1; i >= 0; i--) {\n \t\t\tif (factories[i].isActive(index)) {\n \t\t\t\treturn i;\n \t\t\t}",
    "output": "Fix bug introduced by"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDynamicType.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDynamicType.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDynamicType.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDynamicType.java\n@@ -114,7 +114,7 @@ public enum ElfDynamicValueType {\n \t//  public static ElfDynamicType DT_ENCODING = addDefaultDynamicType(32, \"DT_ENCODING\",\n \t//\t  \"Start of encoded range\", ElfDynamicValueType.VALUE);\n \tpublic static ElfDynamicType DT_PREINIT_ARRAY = addDefaultDynamicType(32, \"DT_PREINIT_ARRAY\",\n-\t\t\"Array with addresses of preinit fct\", ElfDynamicValueType.VALUE);\n+\t\t\"Array with addresses of preinit fct\", ElfDynamicValueType.ADDRESS);\n \tpublic static ElfDynamicType DT_PREINIT_ARRAYSZ = addDefaultDynamicType(33,\n \t\t\"DT_PREINIT_ARRAYSZ\", \"Size in bytes of DT_PREINIT_ARRAY\", ElfDynamicValueType.VALUE);\n ",
    "output": "Fix DT_PREINIT_ARRAY value type"
  },
  {
    "input": "diff --git a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerVariable.java b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerVariable.java\n--- a/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerVariable.java\n+++ b/Ghidra/Features/DecompilerDependent/src/main/java/ghidra/app/extension/datatype/finder/DecompilerVariable.java\n@@ -106,7 +106,7 @@ private DataType getInputDataType(PcodeOp op) {\n \t\t}\n \n \t\tVarnode[] inputs = op.getInputs();\n-\t\tif (inputs.length == 2) {\n+\t\tif (inputs.length == 2 && inputs[0].getHigh() != null) {\n \t\t\treturn inputs[0].getHigh().getDataType();\n \t\t}\n ",
    "output": "Fix crash in find field references"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/SaveAsProgramAction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/SaveAsProgramAction.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/SaveAsProgramAction.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/SaveAsProgramAction.java\n@@ -40,7 +40,7 @@ protected void programChanged(Program program) {\n \t\t}\n \t\telse {\n \t\t\tString progName = program.getDomainFile().getName();\n-\t\t\tgetMenuBarData().setMenuItemNamePlain(\"Save '%s' As...'\".formatted(progName));\n+\t\t\tgetMenuBarData().setMenuItemNamePlain(\"Save '%s' As...\".formatted(progName));\n \t\t\tgetMenuBarData().setMnemonic('a');\n \t\t\tsetDescription(\"<html>Save '%s' As\".formatted(HTMLUtilities.escapeHTML(progName)));\n \t\t}",
    "output": "Fix menu text"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/PcodeExecutor.java b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/PcodeExecutor.java\n--- a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/PcodeExecutor.java\n+++ b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/PcodeExecutor.java\n@@ -64,7 +64,7 @@ public PcodeExecutor(SleighLanguage language, PcodeArithmetic<T> arithmetic,\n \t\tthis.reason = reason;\n \n \t\tthis.pc = language.getProgramCounter();\n-\t\tthis.pcSize = pc.getNumBytes();\n+\t\tthis.pcSize = pc != null ? pc.getNumBytes() : language.getDefaultSpace().getPointerSize();\n \t}\n \n \t/**",
    "output": "Fix User default space pointer size if no PC."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/indexedscrollpane/IndexedScrollPane.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/indexedscrollpane/IndexedScrollPane.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/indexedscrollpane/IndexedScrollPane.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/indexedscrollpane/IndexedScrollPane.java\n@@ -212,24 +212,9 @@ protected void paintComponent(Graphics g) {\n \n \t\t@Override\n \t\tpublic boolean getScrollableTracksViewportWidth() {\n-\t\t\tint prefWidth = comp.getPreferredSize().width;\n-\t\t\tint scrollPaneWidth = getScrollPaneWidth();\n-\t\t\treturn scrollPaneWidth > prefWidth;\n-\t\t}\n-\n-\t\tprivate int getScrollPaneWidth() {\n-\t\t\tContainer myParent = getParent();\n-\t\t\tif (myParent == null) {\n-\t\t\t\treturn 0;\n-\t\t\t}\n-\t\t\tContainer grandParent = myParent.getParent();\n-\t\t\tif (grandParent == null) {\n-\t\t\t\treturn 0;\n-\t\t\t}\n-\t\t\treturn grandParent.getSize().width;\n+\t\t\treturn false;\n \t\t}\n \n-\t\t@Override\n \t\tpublic int getScrollableUnitIncrement(Rectangle visibleRect, int orientation,\n \t\t\t\tint direction) {\n ",
    "output": "Fix fieldpanel scrollbar bug"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java b/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java\n@@ -1196,7 +1196,7 @@ public final Instruction getFirstInstruction(Function function) {\n \t * @return the last instruction in the current program\n \t */\n \tpublic final Instruction getLastInstruction() {\n-\t\tAddress address = currentProgram.getMinAddress();\n+\t\tAddress address = currentProgram.getMaxAddress();\n \t\tInstructionIterator iterator = currentProgram.getListing().getInstructions(address, false);\n \t\tif (iterator.hasNext()) {\n \t\t\treturn iterator.next();",
    "output": "Fix a bug in FlatProgramAPI.getLastInstruction"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/ConsistencyChecker.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/ConsistencyChecker.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/ConsistencyChecker.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/ConsistencyChecker.java\n@@ -725,7 +725,7 @@ private boolean checkSectionTruncations(Constructor ct, ConstructTpl cttpl,\n \t}\n \n \tprivate boolean checkSubtable(SubtableSymbol sym) {\n-\t\tint tablesize = 0;\n+\t\tint tablesize = -1;\n \t\tint numconstruct = sym.getNumConstructors();\n \t\tConstructor ct;\n \t\tboolean testresult = true;\n@@ -757,10 +757,10 @@ private boolean checkSubtable(SubtableSymbol sym) {\n \t\t\t\t}\n \t\t\t\tseennonemptyexport = true;\n \t\t\t\tint exsize = recoverSize(exportres.getSize(), ct);\n-\t\t\t\tif (tablesize == 0) {\n+\t\t\t\tif (tablesize == -1) {\n \t\t\t\t\ttablesize = exsize;\n \t\t\t\t}\n-\t\t\t\tif ((exsize != 0) && (exsize != tablesize)) {\n+\t\t\t\tif (exsize != tablesize) {\n \t\t\t\t\tcompiler.reportError(ct.location, String.format(\n \t\t\t\t\t\t\"Table '%s' has inconsistent export size; Constructor at %s is first conflict\",\n \t\t\t\t\t\tsym.getName(), ct.location));",
    "output": "Add 0 size exports to consistency check for subtables"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/CParserTest.java b/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/CParserTest.java\n--- a/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/CParserTest.java\n+++ b/Ghidra/Features/Base/src/test/java/ghidra/app/util/cparser/CParserTest.java\n@@ -51,6 +51,21 @@ public void testSimple() throws Exception {\n \t\tDataType dt = parser.getDataTypeManager().getDataType(\"/int32_t\");\n \t\tassertTrue(dt != null);\n \t\tassertTrue(dt instanceof TypeDef);\n+\t\t\n+\t\tdt = parser.parse(\"struct mystruct {\" +\n+                     \"    int field1;\" +\n+                     \"    char field2;\" +\n+                     \" };\");\n+\t\t\n+\t\tassertTrue(dt != null);\n+\t\tassertTrue(dt instanceof Structure);\n+\t\tStructure sdt = (Structure) dt;\n+\t\tDataTypeComponent comp = sdt.getComponent(0);\n+\t\tassertEquals(\"field1\", comp.getFieldName());\n+\t\tassertEquals(comp.getDataType().getName(),\"int\");\n+\t\tcomp = sdt.getComponent(1);\n+\t\tassertEquals(\"field2\", comp.getFieldName());\n+\t\tassertEquals(comp.getDataType().getName(),\"char\");\n \t}\n \n \t/**",
    "output": "Fix CParser.parse(String) method with not data type archive. Fixed return data type of method when parsing a structure."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n@@ -523,8 +523,8 @@ else if (!searchPaths.isEmpty()) {\n \t\t\t\t\t\t\t\"Library \" + libraryName + \": Examining \" + candidateLibraryFile);\n \t\t\t\t\t\tif (processLibrary(library, libraryName, candidateLibraryFile, provider,\n \t\t\t\t\t\t\tdesiredLoadSpec, options, log, monitor)) {\n-\t\t\t\t\t\t\tloadedPrograms.add(\n-\t\t\t\t\t\t\t\tnew Loaded<Program>(library, libraryName, libraryDestFolderPath));\n+\t\t\t\t\t\t\tloadedPrograms.add(new Loaded<Program>(library, simpleLibraryName,\n+\t\t\t\t\t\t\t\tlibraryDestFolderPath));\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\tlibrary.release(consumer);",
    "output": "Fix Loaded Program name for libraries that use absolute paths in their library names (Mach-O)"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/OptionsEditorPanel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/OptionsEditorPanel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/OptionsEditorPanel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/OptionsEditorPanel.java\n@@ -271,7 +271,8 @@ private Component buildProjectFolderEditor(Option option) {\n \t\tbutton.addActionListener(e -> {\n \t\t\tDataTreeDialog dataTreeDialog =\n \t\t\t\tnew DataTreeDialog(this, \"Choose a project folder\", DataTreeDialog.CHOOSE_FOLDER);\n-\t\t\tdataTreeDialog.setSelectedFolder(project.getProjectData().getFolder(lastFolderPath));\n+\t\t\tString folderPath = lastFolderPath.isBlank() ? \"/\" : lastFolderPath;\n+\t\t\tdataTreeDialog.setSelectedFolder(project.getProjectData().getFolder(folderPath));\n \t\t\tdataTreeDialog.showComponent();\n \t\t\tDomainFolder folder = dataTreeDialog.getDomainFolder();\n \t\t\tif (folder != null) {",
    "output": "Fix exception with library folder selection"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/DyldChainedStartsInImage.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/DyldChainedStartsInImage.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/DyldChainedStartsInImage.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/DyldChainedStartsInImage.java\n@@ -46,6 +46,11 @@ public class DyldChainedStartsInImage implements StructConverter {\n \t\tArrayList<DyldChainedStartsInSegment> starts = new ArrayList<>();\n \t\tfor (int off : seg_info_offset) {\n \n+\t\t\t// off == 0 means there is no associated starts_in_segment entry\n+\t\t\tif (off == 0) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\treader.setPointerIndex(ptrIndex + off);\n \t\t\tstarts.add(new DyldChainedStartsInSegment(reader));\n \t\t}",
    "output": "Fix exception when parsing dyld_chained_fixups"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java\n@@ -32,7 +32,7 @@\n import ghidra.util.exception.*;\n \n public class FunctionEditorModel {\n-\tpublic static final String PARSING_MODE_STATUS_TEXT =\n+\tpublic static final String PARSING_MODE_STATUS_TEXT = HTMLUtilities.HTML +\n \t\tHTMLUtilities.escapeHTML(\"<TAB> or <RETURN> to commit edits, <ESC> to abort\");\n \tstatic final String NONE_CHOICE = \"-NONE-\";\n ",
    "output": "Fix html rendering bug"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/ghidra_scripts/YaraGhidraGUIScript.java b/Ghidra/Features/Base/ghidra_scripts/YaraGhidraGUIScript.java\n--- a/Ghidra/Features/Base/ghidra_scripts/YaraGhidraGUIScript.java\n+++ b/Ghidra/Features/Base/ghidra_scripts/YaraGhidraGUIScript.java\n@@ -172,7 +172,6 @@ private String generateYaraString(String ruleName) {\n \t\tyaraString.append(\"\\t\\t$STR\" + 1 + \" = { \" + fullStr + \" }\\n\");\n \t\tyaraString.append(\"\\n\\tcondition:\\n\");\n \t\tyaraString.append(\"\\t\\t$STR1\");\n-\t\tyaraString.append(\" or $STR\" + (1));\n \t\tyaraString.append(\"\\n}\\n\");\n \n \t\treturn yaraString.toString();",
    "output": "Remove redunant 'or $STR1' from condition"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LoadException.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LoadException.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LoadException.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LoadException.java\n@@ -37,4 +37,23 @@ public class LoadException extends IOException {\n \tpublic LoadException(String message) {\n \t\tsuper(message);\n \t}\n+\t\n+\t/**\n+\t * Create a new {@link LoadException} with the given message and cause\n+\t * \n+\t * @param message The exception message\n+\t * @param cause The exception cause\n+\t */\n+\tpublic LoadException(String message, Throwable cause) {\n+\t\tsuper(message, cause);\n+\t}\n+\t\n+\t/**\n+\t * Create a new {@link LoadException} with the given cause\n+\t * \n+\t * @param cause The exception cause\n+\t */\n+\tpublic LoadException(Throwable cause) {\n+\t\tsuper(cause);\n+\t}\n }",
    "output": "Add missing LoadException constructors"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/pty/windows/AnsiBufferedInputStream.java b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/pty/windows/AnsiBufferedInputStream.java\n--- a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/pty/windows/AnsiBufferedInputStream.java\n+++ b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/pty/windows/AnsiBufferedInputStream.java\n@@ -365,6 +365,9 @@ protected String readAndClearEscBuf() {\n \n \tprotected int parseNumericBuffer() {\n \t\tString numeric = readAndClearEscBuf();\n+\t\tif (numeric.isEmpty()) {\n+\t\t\treturn 0;\n+\t\t}\n \t\tint result = Integer.parseInt(numeric);\n \t\treturn result;\n \t}",
    "output": "Fix incorrect parsing of the Erase In Line ANSI code. All credits go to nsadeveloper789 for the patch."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfRecord.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfRecord.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfRecord.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfRecord.java\n@@ -247,6 +247,6 @@ public final static String getRecordName(int type) {\n \t@Override\n \tpublic String toString() {\n \t\treturn String.format(\"name: %s, type: 0x%x, offset: 0x%x, length: 0x%x\",\n-\t\t\tgetRecordName(recordType & 0xfe), recordType, recordOffset, recordLength);\n+\t\t\tgetRecordName(recordType & (byte)0xfe), recordType, recordOffset, recordLength);\n \t}\n }",
    "output": "Fix error from"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java\n@@ -47,6 +47,9 @@ public OmfCommentRecord(BinaryReader reader) throws IOException {\n \t\t\tcase COMMENT_CLASS_LIBMOD:\n \t\t\t\tvalue = readString(reader);\n \t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treader.setPointerIndex(reader.getPointerIndex() + getRecordLength() - 3);\n+\t\t\t\tbreak;\n \t\t}\n \t\treadCheckSumByte(reader);\n \t}",
    "output": "Fix problem introduced by"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/ReplaceDataTypeAction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/ReplaceDataTypeAction.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/ReplaceDataTypeAction.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/ReplaceDataTypeAction.java\n@@ -112,7 +112,7 @@ protected JComponent createEditorPanel(DataTypeSelectionEditor dtEditor) {\n \t\t\t\tupdatedPanel.setBorder(BorderFactory.createEmptyBorder(5, 10, 10, 0));\n \t\t\t\tupdatedPanel.setLayout(new VerticalLayout(5));\n \n-\t\t\t\tGLabel label = new GLabel(\"Choose the relacement data type: \");\n+\t\t\t\tGLabel label = new GLabel(\"Choose the replacement data type: \");\n \t\t\t\tlabel.setBorder(BorderFactory.createEmptyBorder(5, 0, 5, 0));\n \t\t\t\tupdatedPanel.add(label);\n \n@@ -146,7 +146,7 @@ protected JComponent createEditorPanel(DataTypeSelectionEditor dtEditor) {\n \t\t}\n \t\tcatch (DataTypeDependencyException e) {\n \t\t\tMsg.showError(this, null, \"Replace Failed\", \"Replace failed.  Existing type \" + newDt +\n-\t\t\t\t\"; replacment type \" + oldDt + \". \" + e.getMessage());\n+\t\t\t\t\"; replacement type \" + oldDt + \". \" + e.getMessage());\n \t\t}\n \t\tfinally {\n \t\t\tdtm.endTransaction(txId, true);",
    "output": "Fix typos in ReplaceDataTypeAction"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/crypto/PasswordDialog.java b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/crypto/PasswordDialog.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/crypto/PasswordDialog.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/crypto/PasswordDialog.java\n@@ -111,6 +111,13 @@ private void updateCapLockWarning() {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void close() {\n+\t\t// override default close behavior to prevent dispose() from being called before\n+\t\t// the password value is retrieved\n+\t\tcloseDialog();\n+\t}\n+\n \t@Override\n \tprotected void okCallback() {\n \t\tresultState = RESULT_STATE.OK;",
    "output": "Fix file system password input dialog NPE"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-Debugging/src/main/java/ghidra/dbg/target/schema/TargetObjectSchema.java b/Ghidra/Debug/Framework-Debugging/src/main/java/ghidra/dbg/target/schema/TargetObjectSchema.java\n--- a/Ghidra/Debug/Framework-Debugging/src/main/java/ghidra/dbg/target/schema/TargetObjectSchema.java\n+++ b/Ghidra/Debug/Framework-Debugging/src/main/java/ghidra/dbg/target/schema/TargetObjectSchema.java\n@@ -641,13 +641,13 @@ private static void searchFor(TargetObjectSchema sch, PathMatcher result,\n \t\t\tfor (Entry<String, AttributeSchema> ent : sch.getAttributeSchemas().entrySet()) {\n \t\t\t\tList<String> extended = PathUtils.extend(prefix, ent.getKey());\n \t\t\t\tTargetObjectSchema attrSchema = ctx.getSchema(ent.getValue().getSchema());\n-\t\t\t\tsearchFor(attrSchema, result, extended, parentIsCanonical, type, requireAggregate,\n+\t\t\t\tsearchFor(attrSchema, result, extended, isCanonical, type, requireAggregate,\n \t\t\t\t\trequireCanonical, visited);\n \t\t\t}\n \t\t\tList<String> daExtended = PathUtils.extend(prefix, \"\");\n \t\t\tTargetObjectSchema daSchema =\n \t\t\t\tctx.getSchema(sch.getDefaultAttributeSchema().getSchema());\n-\t\t\tsearchFor(daSchema, result, daExtended, parentIsCanonical, type, requireAggregate,\n+\t\t\tsearchFor(daSchema, result, daExtended, isCanonical, type, requireAggregate,\n \t\t\t\trequireCanonical, visited);\n \n \t\t\tvisited.remove(sch);",
    "output": "Fix tests: Issue in schema search."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-Debugging/src/test/java/ghidra/dbg/testutil/CallbackValidator.java b/Ghidra/Debug/Framework-Debugging/src/test/java/ghidra/dbg/testutil/CallbackValidator.java\n--- a/Ghidra/Debug/Framework-Debugging/src/test/java/ghidra/dbg/testutil/CallbackValidator.java\n+++ b/Ghidra/Debug/Framework-Debugging/src/test/java/ghidra/dbg/testutil/CallbackValidator.java\n@@ -73,7 +73,7 @@ public CreationRecord(TargetObject object) {\n \t\tAddressRange.class, TargetAttachKind.class, TargetAttachKindSet.class,\n \t\tTargetBreakpointKind.class, TargetBreakpointKindSet.class, TargetStepKind.class,\n \t\tTargetStepKindSet.class, TargetExecutionState.class, TargetEventType.class,\n-\t\tTargetParameterMap.class, TargetObjectList.class);\n+\t\tTargetParameterMap.class, TargetObjectList.class, Class.class);\n \n \tpublic CallbackValidator(DebuggerObjectModel model) {\n \t\tthis.model = model;",
    "output": "Fix DebugModel tests"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java\n@@ -308,6 +308,7 @@ private void buildPanels() {\n \t\tif (overviewComponent != null) {\n \t\t\tscroller.setScrollbarSideKickComponent(buildOverviewComponent());\n \t\t}\n+\t\trevalidate();\n \t\trepaint();\n \t}\n ",
    "output": "Fix Listing header repaint issue on Flat LaFs"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java\n@@ -1514,6 +1514,7 @@ public void dispose() {\n \t\tactionManager.dispose();\n \t\toptionsDialog.dispose();\n \t\tclose();\n+\t\tworker.dispose();\n \t\tfileChooserModel = null;\n \t}\n ",
    "output": "Upgrade chooser to dispose its worker"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java\n@@ -33,7 +33,7 @@\n \n public class FunctionEditorModel {\n \tpublic static final String PARSING_MODE_STATUS_TEXT =\n-\t\t\"<TAB> or <RETURN> to commit edits, <ESC> to abort\";\n+\t\tHTMLUtilities.escapeHTML(\"<TAB> or <RETURN> to commit edits, <ESC> to abort\");\n \tstatic final String NONE_CHOICE = \"-NONE-\";\n \n \tprivate String name;\n@@ -641,9 +641,9 @@ private void updateParameterAndReturnStorage() {\n \t\t\t\t\treturnInfo.getFormalDataType(), storage);\n \t\t\t\ttry {\n \t\t\t\t\tif (autoParamCount < oldAutoCount) {\n-\t\t\t\t\t\tif (oldParams.get(\n-\t\t\t\t\t\t\tautoParamCount).getStorage().getAutoParameterType() != storage\n-\t\t\t\t\t\t\t\t\t.getAutoParameterType()) {\n+\t\t\t\t\t\tif (oldParams.get(autoParamCount)\n+\t\t\t\t\t\t\t\t.getStorage()\n+\t\t\t\t\t\t\t\t.getAutoParameterType() != storage.getAutoParameterType()) {\n \t\t\t\t\t\t\tadjustSelectionForRowRemoved(i);\n \t\t\t\t\t\t}\n \t\t\t\t\t}",
    "output": "Fix incorrect html rendering"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProviderTest.java b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProviderTest.java\n--- a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProviderTest.java\n+++ b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProviderTest.java\n@@ -297,7 +297,7 @@ public void testUniqueWatch() {\n \t}\n \n \t@Test\n-\tpublic void testLiveCausesReads() throws Exception {\n+\tpublic void testLiveCausesReads() throws Throwable {\n \t\tcreateTestModel();\n \t\tmb.createTestProcessesAndThreads();\n \t\tbank = mb.testThread1.addRegisterBank();\n@@ -311,6 +311,7 @@ public void testLiveCausesReads() throws Exception {\n \n \t\trecorder = modelService.recordTarget(mb.testProcess1,\n \t\t\tcreateTargetTraceMapper(mb.testProcess1), ActionSource.AUTOMATIC);\n+\t\twaitRecorder(recorder);\n \t\tTrace trace = recorder.getTrace();\n \t\tTraceThread thread = waitForValue(() -> recorder.getTraceThread(mb.testThread1));\n ",
    "output": "Fix timing issue in WatchesProviderTest"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/SymbolTreeProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/SymbolTreeProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/SymbolTreeProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/SymbolTreeProvider.java\n@@ -196,7 +196,7 @@ public void treeCollapsed(TreeExpansionEvent event) {\n \n \tprotected void treeNodeCollapsed(TreePath path) {\n \t\tObject lastPathComponent = path.getLastPathComponent();\n-\t\tif (lastPathComponent instanceof SymbolCategoryNode) {\n+\t\tif (lastPathComponent instanceof SymbolCategoryNode && !tree.hasFilterText()) {\n \t\t\ttree.runTask(m -> ((SymbolCategoryNode) lastPathComponent).unloadChildren());\n \t\t}\n \t}",
    "output": "Fix symbol tree not able to close category node with filter on"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/stack/vars/VariableValueHoverService.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/stack/vars/VariableValueHoverService.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/stack/vars/VariableValueHoverService.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/stack/vars/VariableValueHoverService.java\n@@ -590,7 +590,7 @@ public CompletableFuture<VariableValueTable> fillVariable(Variable variable) {\n \tpublic CompletableFuture<VariableValueTable> fillVariableValueTable(VariableValueTable table,\n \t\t\tProgramLocation programLocation, DebuggerCoordinates current,\n \t\t\tFieldLocation fieldLocation, Field field, List<String> warnings) {\n-\t\tif (traceManager == null || mappingService == null) {\n+\t\tif (traceManager == null || mappingService == null || current.getPlatform() == null) {\n \t\t\treturn null;\n \t\t}\n \t\tVariableEvaluator eval;",
    "output": "Fix NPE in VariableValueHoverService"
  },
  {
    "input": "diff --git a/GhidraBuild/LaunchSupport/src/main/java/LaunchSupport.java b/GhidraBuild/LaunchSupport/src/main/java/LaunchSupport.java\n--- a/GhidraBuild/LaunchSupport/src/main/java/LaunchSupport.java\n+++ b/GhidraBuild/LaunchSupport/src/main/java/LaunchSupport.java\n@@ -291,7 +291,8 @@ private static int handleVmArgs(JavaConfig javaConfig) {\n \t\t\treturn EXIT_FAILURE;\n \t\t}\n \n-\t\tjavaConfig.getLaunchProperties().getVmArgList().forEach(arg -> System.out.println(arg));\n+\t\t// Force newline style to make cross-platform parsing consistent\n+\t\tjavaConfig.getLaunchProperties().getVmArgList().forEach(e -> System.out.print(e + \"\\r\\n\"));\n \t\treturn EXIT_SUCCESS;\n \t}\n }",
    "output": "Fix a few launch issues (, )"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTable.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTable.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTable.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTable.java\n@@ -30,6 +30,7 @@\n import javax.swing.event.*;\n import javax.swing.plaf.TableUI;\n import javax.swing.table.*;\n+import javax.swing.text.JTextComponent;\n \n import docking.*;\n import docking.action.*;\n@@ -933,14 +934,17 @@ public final TableCellRenderer getHeaderRendererOverride(int col) {\n \t * displayed. However, the editor component will not have a focus. This method has been\n \t * overridden to request focus on the editor component.\n \t *\n-\t * @see javax.swing.JTable#editCellAt(int, int)\n+\t * @see javax.swing.JTable#editCellAt(int, int, EventObject)\n \t */\n \t@Override\n-\tpublic boolean editCellAt(int row, int column) {\n-\t\tboolean editAtCell = super.editCellAt(row, column);\n+\tpublic boolean editCellAt(int row, int column, EventObject e) {\n+\t\tboolean editAtCell = super.editCellAt(row, column, e);\n \t\tif (editAtCell) {\n \t\t\tComponent editor = getEditorComponent();\n-\t\t\teditor.requestFocus();\n+\t\t\teditor.requestFocusInWindow();\n+\t\t\tif (editor instanceof JTextComponent textComponent) {\n+\t\t\t\ttextComponent.selectAll();\n+\t\t\t}\n \t\t}\n \t\treturn editAtCell;\n \t}",
    "output": "Fix issue in tables where focus was not given to the cell editor when users pressed F2 to edit"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfFileHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfFileHeader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfFileHeader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfFileHeader.java\n@@ -338,6 +338,7 @@ else if (commentClass == OmfCommentRecord.COMMENT_CLASS_LIBMOD) {\n \t\t\t\theader.externsymbols.add((OmfExternalSymbol)record);\n \t\t\t\tbreak;\n \t\t\tcase PUBDEF:\n+\t\t\tcase LPUBDEF:\n \t\t\t\theader.symbols.add((OmfSymbolRecord)record);\n \t\t\t\tbreak;\n \t\t\tcase LINNUM:",
    "output": "Add symbols from LPUBDEF to symbol list"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerResources.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerResources.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerResources.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerResources.java\n@@ -86,9 +86,9 @@ public interface DebuggerResources {\n \n \tIcon ICON_STEP_INTO = new GIcon(\"icon.debugger.step.into\");\n \tIcon ICON_STEP_OVER = new GIcon(\"icon.debugger.step.over\");\n-\tIcon ICON_SKIP_OVER = new GIcon(\"icon.debugger.step.back\");\n+\tIcon ICON_SKIP_OVER = new GIcon(\"icon.debugger.skip.over\");\n \tIcon ICON_STEP_FINISH = new GIcon(\"icon.debugger.step.finish\");\n-\tIcon ICON_STEP_BACK = new GIcon(\"icon.debugger.skip.over\");\n+\tIcon ICON_STEP_BACK = new GIcon(\"icon.debugger.step.back\");\n \tIcon ICON_STEP_LAST = new GIcon(\"icon.debugger.step.last\");\n \n \tIcon ICON_SNAP_FORWARD = new GIcon(\"icon.debugger.snap.forward\");",
    "output": "Fix swapped step icons"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractProgramLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractProgramLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractProgramLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractProgramLoader.java\n@@ -128,7 +128,6 @@ public final List<DomainObject> load(ByteProvider provider, String name, DomainF\n \t\tboolean success = false;\n \t\ttry {\n \t\t\tmonitor.checkCanceled();\n-\t\t\tList<LoadedProgram> programsToFixup = new ArrayList<>();\n \t\t\tfor (LoadedProgram loadedProgram : loadedPrograms) {\n \t\t\t\tmonitor.checkCanceled();\n \n@@ -157,15 +156,14 @@ public final List<DomainObject> load(ByteProvider provider, String name, DomainF\n \t\t\t\tif (createProgramFile(program, loadedProgram.destinationFolder(), domainFileName,\n \t\t\t\t\tmessageLog, monitor)) {\n \t\t\t\t\tresults.add(program);\n-\t\t\t\t\tprogramsToFixup.add(loadedProgram);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tprogram.release(consumer); // some kind of exception happened; see MessageLog\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t// Subclasses can perform custom post-load fix-ups\n-\t\t\tpostLoadProgramFixups(programsToFixup, options, messageLog, monitor);\n+\t\t\tpostLoadProgramFixups(loadedPrograms, options, messageLog, monitor);\n \n \t\t\tsuccess = true;\n \t\t}",
    "output": "Fix an issue that prevented PE ordinal symbols from getting their true name resolved during headless mode import"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/generic/text/TextLayoutGraphics.java b/Ghidra/Framework/Generic/src/main/java/generic/text/TextLayoutGraphics.java\n--- a/Ghidra/Framework/Generic/src/main/java/generic/text/TextLayoutGraphics.java\n+++ b/Ghidra/Framework/Generic/src/main/java/generic/text/TextLayoutGraphics.java\n@@ -497,8 +497,9 @@ public void setTransform(AffineTransform Tx) {\n \n \t@Override\n \tpublic AffineTransform getTransform() {\n-\t\t// stub\n-\t\treturn null;\n+\t\t// Some UIs (e.g. FlatLookAndFeel) expect a transform to be applied in some situations\n+\t\t// depending on high resolution monitor settings\n+\t\treturn new AffineTransform();\n \t}\n \n \t@Override\n\ndiff --git a/Ghidra/Framework/Gui/src/main/java/ghidra/util/HTMLUtilities.java b/Ghidra/Framework/Gui/src/main/java/ghidra/util/HTMLUtilities.java\n--- a/Ghidra/Framework/Gui/src/main/java/ghidra/util/HTMLUtilities.java\n+++ b/Ghidra/Framework/Gui/src/main/java/ghidra/util/HTMLUtilities.java\n@@ -773,6 +773,7 @@ public void paint(Graphics g) {\n \t\t\tnew Rectangle(-size.width, -size.height, size.width * 2, size.height * 10);\n \n \t\tTextLayoutGraphics g = new TextLayoutGraphics();\n+\n \t\tg.setClip(bounds);\n \t\tlabel.paint(g);\n \t\tg.flush();",
    "output": "Fix null pointer exception in Project Lock dialog"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FrontEndTool.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FrontEndTool.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FrontEndTool.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FrontEndTool.java\n@@ -212,6 +212,17 @@ private Element getToolFileXml() {\n \t\treturn null;\n \t}\n \n+\t@Override\n+\tprotected boolean doSaveTool() {\n+\t\t// This method is overridden to allow the FrontEndTool to perform custom saving.\n+\t\t// The super.doSaveTool is designed to save tools to the user's tool chest directory. The \n+\t\t// FrontEndTool saves its state directly in the user's settings directory and includes\n+\t\t// the entire project's state such as what tools were running and data states for each\n+\t\t// running tool.\n+\t\tsaveToolConfigurationToDisk();\n+\t\treturn true;\n+\t}\n+\n \tvoid saveToolConfigurationToDisk() {\n \t\tToolTemplate template = saveToolToToolTemplate();\n \t\tElement root = new Element(FRONT_END_TOOL_XML_NAME);\n@@ -346,7 +357,6 @@ else if (RESTORE_PREVIOUS_PROJECT_NAME.equals(optionName)) {\n \n \t@Override\n \tpublic void exit() {\n-\t\tsaveToolConfigurationToDisk();\n \t\tplugin.exitGhidra();\n \t}\n ",
    "output": "Fix issue with spontaneous appearing weird tool"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/Disassembler.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/Disassembler.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/Disassembler.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/disassemble/Disassembler.java\n@@ -1387,21 +1387,26 @@ public void markInstructionError(InstructionError conflict) {\n \t\t\treturn;\n \t\t}\n \n+\t\tboolean markAsError = true;\n+\n \t\tAddress flowFrom = conflict.getFlowFromAddress();\n \t\tString flowMsg = flowFrom != null ? (\" (flow from \" + flowFrom + \")\") : \"\";\n \t\tAddress markAddr = address;\n \t\tif (!isBookmarkAllowed(markAddr)) {\n \t\t\tif (flowFrom != null) {\n \t\t\t\tmarkAddr = flowFrom;\n+\t\t\t\tif (conflict.getInstructionErrorType() == InstructionErrorType.MEMORY &&\n+\t\t\t\t\taddress.getOffset() == 0) {\n+\t\t\t\t\tmarkAsError = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tbmMgr.setBookmark(markAddr, BookmarkType.ERROR, ERROR_BOOKMARK_CATEGORY,\n-\t\t\tconflict.getConflictMessage() + flowMsg);\n-\n+\t\tbmMgr.setBookmark(markAddr, markAsError ? BookmarkType.ERROR : BookmarkType.WARNING,\n+\t\t\tERROR_BOOKMARK_CATEGORY, conflict.getConflictMessage() + flowMsg);\n \t}\n \n \tprivate boolean isBookmarkAllowed(Address addr) {",
    "output": "Use warning bookmark for bad flows to address 00000000 instead of error bookmark"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n@@ -333,6 +333,10 @@ protected JTreeMouseListenerDelegate createMouseListenerDelegate() {\n \t * @return the saved state\n \t */\n \tpublic GTreeState getTreeState() {\n+\t\tGTreeNode root = getViewRoot();\n+\t\tif (root == null) {\n+\t\t\treturn null; // this can happen during initialization\n+\t\t}\n \t\treturn new GTreeState(this);\n \t}\n ",
    "output": "Add check for null root when getting TreeState"
  },
  {
    "input": "diff --git a/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/ServerAdmin.java b/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/ServerAdmin.java\n--- a/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/ServerAdmin.java\n+++ b/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/ServerAdmin.java\n@@ -456,6 +456,9 @@ private void validateRepositoryName(String[] args, int i, File rootDirFile) {\n \t\t\tMsg.error(CommandProcessor.class, \"Repository not found: \" + repName);\n \t\t\tSystem.exit(-1);\n \t\t}\n+\t\tif (repName.contains(\" \")) {\n+\t\t\targs[i] = \"\\\"\" + repName + \"\\\"\";\n+\t\t}\n \t}\n \n \t/**",
    "output": "Fix svrAdmin when repo name contains a space"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewPanel.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewPanel.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewPanel.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/memview/MemviewPanel.java\n@@ -30,7 +30,7 @@\n public class MemviewPanel extends JPanel implements MouseListener, MouseMotionListener {\n \tprivate static final long serialVersionUID = 1L;\n \n-\tprivate Color ARROW_COLOR = new GColor(\"color.debugger.memview.arrow\");\n+\tprivate Color ARROW_COLOR = new GColor(\"color.debugger.plugin.plugin.memview.arrow\");\n \n \tprivate MemviewProvider provider;\n \tprivate MemviewMap amap;\n@@ -60,7 +60,6 @@ public class MemviewPanel extends JPanel implements MouseListener, MouseMotionLi\n \tprivate Map<Long, Set<MemoryBox>> time2box = new HashMap<>();\n \n \tpublic MemviewPanel(MemviewProvider provider) {\n-\t\tsuper();\n \t\tthis.provider = provider;\n \t\tsetPreferredSize(new Dimension(barWidth, barHeight));\n \t\tsetSize(getPreferredSize());",
    "output": "Fix incorrect theme property"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/PluginTool.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/PluginTool.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/PluginTool.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/PluginTool.java\n@@ -160,7 +160,8 @@ public PluginTool(Project project, ProjectManager projectManager, ToolServices t\n \t\t\tString name, boolean isDockable, boolean hasStatus, boolean isModal) {\n \t\tthis.project = project;\n \t\tthis.projectManager = projectManager;\n-\t\tthis.toolServices = toolServices;\n+\t\tthis.toolServices = toolServices == null ? new ToolServicesAdapter() : toolServices;\n+\n \t\tpropertyChangeMgr = new PropertyChangeSupport(this);\n \t\toptionsMgr = new OptionsManager(this);\n \t\twinMgr = createDockingWindowManager(isDockable, hasStatus, isModal);\n@@ -1317,6 +1318,9 @@ protected void setProject(Project project) {\n \t\tif (project != null) {\n \t\t\ttoolServices = project.getToolServices();\n \t\t}\n+\t\telse {\n+\t\t\ttoolServices = new ToolServicesAdapter();\n+\t\t}\n \t}\n \n \tprotected void restorePluginsFromXml(Element elem) throws PluginException {",
    "output": "Fix an exception when trying to open 2 tools with the same project"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/mem/MemoryBlockDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/mem/MemoryBlockDB.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/mem/MemoryBlockDB.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/mem/MemoryBlockDB.java\n@@ -539,11 +539,14 @@ private int putBytes(long offset, byte[] b, int off, int len) throws MemoryAcces\n \t}\n \n \tprivate SubMemoryBlock getSubBlock(long offset) {\n-\t\tif (lastSubBlock != null && lastSubBlock.contains(offset)) {\n-\t\t\treturn lastSubBlock;\n-\t\t}\n-\t\tlastSubBlock = findBlock(0, subBlocks.size() - 1, offset);\n-\t\treturn lastSubBlock;\n+\t\t// avoid potential thread race condition\n+\t\tSubMemoryBlock last = lastSubBlock;\n+\t\tif (last != null && last.contains(offset)) {\n+\t\t\treturn last;\n+\t\t}\n+\t\tlast = findBlock(0, subBlocks.size() - 1, offset);\n+\t\tlastSubBlock = last;\n+\t\treturn last;\n \t}\n \n \tprivate SubMemoryBlock findBlock(int minIndex, int maxIndex, long offset) {",
    "output": "Improve thread safety for cached lastSubBlock"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/ghidra_scripts/CreateExampleGDTArchiveScript.java b/Ghidra/Features/Base/ghidra_scripts/CreateExampleGDTArchiveScript.java\n--- a/Ghidra/Features/Base/ghidra_scripts/CreateExampleGDTArchiveScript.java\n+++ b/Ghidra/Features/Base/ghidra_scripts/CreateExampleGDTArchiveScript.java\n@@ -203,7 +203,7 @@ public void parseGDT_WinVS22() throws Exception {\n \t\t\t\t\"certif.h\",\n \t\t\t\t\"certmod.h\",\n \t\t\t\t\"certpol.h\",\n-\t\t\t\t\"certpoleng.h   \",\n+\t\t\t\t\"certpoleng.h\",\n \t\t\t\t\"certsrv.h\",\n \t\t\t\t\"certview.h\",\n \t\t\t\t\"credssp.h\",\n@@ -422,12 +422,12 @@ public void parseGDT_WinVS22() throws Exception {\n \t\t\t\t\"#http.h\", // included by something else\n \t\t\t\t\n \t\t\t\t\"# IP Helper\",\n-\t\t\t\t\"#icmpapi.h\",  // Something wrong with IP_ADDR\n \t\t\t\t\"ifdef.h\",\n \t\t\t\t\"inaddr.h\",\n \t\t\t\t\"ip2string.h\",\n \t\t\t\t\"ipexport.h\",\n \t\t\t\t\"iphlpapi.h\",\n+\t\t\t\t\"icmpapi.h\",  // Must be included after iphlpapi.h\n \t\t\t\t\"iprtrmib.h\",\n \t\t\t\t\"iptypes.h\",\n \t\t\t\t\"netioapi.h\",",
    "output": "Fix icmpapi.h parsing error in example GDT script According to the Microsoft document, icmpapi.h must be included after iphlpapi.h. If you change the order of the inclusion of icmpapi.h, the C Parser will have no problem parsing icmpapi.h."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/strings/ViewStringsTableModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/strings/ViewStringsTableModel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/strings/ViewStringsTableModel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/strings/ViewStringsTableModel.java\n@@ -132,6 +132,7 @@ public void removeDataInstanceAt(Address addr) {\n \t\tProgramLocation progLoc = rowsIndexedByAddress.get(addr);\n \t\tif (progLoc != null) {\n \t\t\tremoveObject(progLoc);\n+\t\t\trowsIndexedByAddress.remove(addr);\n \t\t}\n \t}\n ",
    "output": "Fix spurious string is filtered out messages If a location that holds a string is cleared, navigating to that location in the listing caused a bogus \"String at <addr> is filtered out of table view\"."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/guest/DBTraceGuestPlatformMappedMemory.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/guest/DBTraceGuestPlatformMappedMemory.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/guest/DBTraceGuestPlatformMappedMemory.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/guest/DBTraceGuestPlatformMappedMemory.java\n@@ -381,7 +381,7 @@ protected int getBytes(ByteBuffer buffer, Address guestStart) {\n \t\t\tint savedLimit = buffer.limit();\n \t\t\ttry {\n \t\t\t\tbuffer.limit(buffer.position() + lenToRead);\n-\t\t\t\thostSpace.getBytes(snap, hostCur, buffer);\n+\t\t\t\thostSpace.getViewBytes(snap, hostCur, buffer);\n \t\t\t}\n \t\t\tfinally {\n \t\t\t\tbuffer.limit(savedLimit);",
    "output": "Fix guest-platform disassembly of scratch snapshots"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilePlugin.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilePlugin.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilePlugin.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilePlugin.java\n@@ -39,6 +39,7 @@\n /**\n  * Plugin for producing a high-level C interpretation of assembly functions.\n  */\n+//@formatter:off\n @PluginInfo(\n \tstatus = PluginStatus.RELEASED,\n \tpackageName = CorePluginPackage.NAME,\n@@ -49,12 +50,13 @@\n \t\tGoToService.class, NavigationHistoryService.class, ClipboardService.class,\n \t\tDataTypeManagerService.class /*, ProgramManager.class */\n \t},\n-\tservicesProvided = { DecompilerHighlightService.class },\n+\tservicesProvided = { DecompilerHighlightService.class, DecompilerMarginService.class },\n \teventsConsumed = {\n \t\tProgramActivatedPluginEvent.class, ProgramOpenedPluginEvent.class,\n \t\tProgramLocationPluginEvent.class, ProgramSelectionPluginEvent.class,\n \t\tProgramClosedPluginEvent.class\n \t})\n+//@formatter:on\n public class DecompilePlugin extends Plugin {\n \n \tprivate PrimaryDecompilerProvider connectedProvider;",
    "output": "Fix missing service registration"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoProgramBuilder.java\n@@ -427,8 +427,18 @@ protected void fixupProgramTree() throws Exception {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif (segmentFragment == null) {\n+\t\t\t\tlog.appendMsg(\"Could not find/fixup segment in Program Tree: \" + segmentName);\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tProgramModule segmentModule = rootModule.createModule(segmentName);\n-\t\t\tsegmentModule.reparent(noSectionsName, rootModule);\n+\t\t\ttry {\n+\t\t\t\tsegmentModule.reparent(noSectionsName, rootModule);\n+\t\t\t}\n+\t\t\tcatch (NotFoundException e) {\n+\t\t\t\tlog.appendException(e);\n+\t\t\t\tcontinue;\n+\t\t\t}\n \n \t\t\t// Add the sections, which will remove overlapped ranges from the segment fragment\n \t\t\tfor (Section section : segment.getSections()) {",
    "output": "Fix an issue that prevented some Mach-O binaries from being imported if there were unexpected issues while creating the Program Tree."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleUtilities.java b/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleUtilities.java\n--- a/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleUtilities.java\n+++ b/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleUtilities.java\n@@ -63,6 +63,11 @@ public static boolean isModuleDirectory(ResourceFile dir) {\n \t */\n \tpublic static boolean isModuleDirectory(Path path) {\n \t\tFile file = path.toFile();\n+\t\tif (\"bin\".equals(file.getName())) {\n+\t\t\t// Prevent eclipse project bin directory from being treated as module root\n+\t\t\t// since files frequently get copied from root into bin\n+\t\t\treturn false;\n+\t\t}\n \t\treturn new File(file, MANIFEST_FILE_NAME).exists();\n \t}\n ",
    "output": "Add safety check for eclipse bin directory treatment as module root. Moved DataType extension point to SoftwareModeling."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/CloseProgramAction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/CloseProgramAction.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/CloseProgramAction.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/CloseProgramAction.java\n@@ -32,7 +32,7 @@ public CloseProgramAction(ProgramManagerPlugin plugin, String group, int subGrou\n \t\tmenuData.setMenuGroup(group);\n \t\tmenuData.setMenuSubGroup(Integer.toString(subGroup));\n \t\tsetMenuBarData(menuData);\n-\t\tsetKeyBindingData(new KeyBindingData(\"ctrl o\"));\n+\t\tsetKeyBindingData(new KeyBindingData(\"ctrl w\"));\n \t}\n \n \t@Override",
    "output": "Fix refactoring error for keybinding"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/DecompilerSwitchAnalyzer.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/DecompilerSwitchAnalyzer.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/DecompilerSwitchAnalyzer.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/DecompilerSwitchAnalyzer.java\n@@ -15,10 +15,11 @@\n  */\n package ghidra.app.plugin.core.analysis;\n \n-import java.math.BigInteger;\n import java.util.*;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import java.math.BigInteger;\n+\n import generic.concurrent.*;\n import ghidra.app.cmd.function.CreateFunctionCmd;\n import ghidra.app.cmd.function.DecompilerSwitchAnalysisCmd;\n@@ -115,8 +116,11 @@ public boolean added(Program program, AddressSetView set, TaskMonitor monitor, M\n \t\t\t\treturn true;\n \t\t\t}\n \n+\t\t\tmonitor.checkCanceled();\n \t\t\trunDecompilerAnalysis(program, definedFunctions, monitor);\n+\t\t\tmonitor.checkCanceled();\n \t\t\trunDecompilerAnalysis(program, undefinedFunctions, monitor);\n+\t\t\tmonitor.checkCanceled();\n \t\t}\n \t\tcatch (CancelledException ce) {\n \t\t\tthrow ce;",
    "output": "Fix Decompiler switch analyzer cancelability"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/DBTrace.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/DBTrace.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/DBTrace.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/DBTrace.java\n@@ -580,8 +580,7 @@ public void setChanged(TraceChangeRecord<?, ?> event) {\n \t}\n \n \t@Override\n-\t// NOTE: addListener synchronizes on this and might generate callbacks immediately\n-\tpublic synchronized DBTraceProgramView getFixedProgramView(long snap) {\n+\tpublic DBTraceProgramView getFixedProgramView(long snap) {\n \t\t// NOTE: The new viewport will need to read from the time manager during init\n \t\tDBTraceProgramView view;\n \t\ttry (LockHold hold = lockRead()) {\n@@ -595,8 +594,7 @@ public synchronized DBTraceProgramView getFixedProgramView(long snap) {\n \t}\n \n \t@Override\n-\t// NOTE: Ditto getFixedProgramView\n-\tpublic synchronized DBTraceVariableSnapProgramView createProgramView(long snap) {\n+\tpublic DBTraceVariableSnapProgramView createProgramView(long snap) {\n \t\t// NOTE: The new viewport will need to read from the time manager during init\n \t\tDBTraceVariableSnapProgramView view;\n \t\ttry (LockHold hold = lockRead()) {\n@@ -613,7 +611,7 @@ public DBTraceVariableSnapProgramView getProgramView() {\n \t}\n \n \t@Override\n-\tpublic synchronized DBTraceTimeViewport createTimeViewport() {\n+\tpublic DBTraceTimeViewport createTimeViewport() {\n \t\ttry (LockHold hold = lockRead()) {\n \t\t\tDBTraceTimeViewport view = new DBTraceTimeViewport(this);\n \t\t\tviewports.add(view);",
    "output": "Remove unnecessary 'synchronized' in DBTrace"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/analysis/SharedReturnAnalysisCmd.java b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/analysis/SharedReturnAnalysisCmd.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/analysis/SharedReturnAnalysisCmd.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/analysis/SharedReturnAnalysisCmd.java\n@@ -282,7 +282,7 @@ private boolean hasFallThruTo(Program program, Address location) {\n \t\tAddress fallFrom = instr.getFallFrom();\n \t\tif (fallFrom != null) {\n \t\t\tInstruction fallInstr = program.getListing().getInstructionContaining(fallFrom);\n-\t\t\tif (fallInstr != null && fallInstr.getFallThrough().equals(location)) {\n+\t\t\tif (fallInstr != null && location.equals(fallInstr.getFallThrough())) {\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}",
    "output": "Fix bug fund in testing"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/DebuggerCoordinates.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/DebuggerCoordinates.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/DebuggerCoordinates.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/DebuggerCoordinates.java\n@@ -351,7 +351,7 @@ public DebuggerCoordinates thread(TraceThread newThread) {\n \t\t\tthrow new IllegalArgumentException(\"Cannot change trace\");\n \t\t}\n \t\tif (newThread == null) {\n-\t\t\tnewThread = resolveThread(recorder, getTime());\n+\t\t\tnewThread = resolveThread(trace, recorder, getTime());\n \t\t}\n \t\tTrace newTrace = trace != null ? trace : newThread.getTrace();\n \t\tTracePlatform newPlatform = platform != null ? platform : resolvePlatform(newTrace);\n@@ -407,6 +407,13 @@ public DebuggerCoordinates frame(int newFrame) {\n \t\t\tnewObject);\n \t}\n \n+\tpublic DebuggerCoordinates frame(Integer newFrame) {\n+\t\tif (newFrame == null) {\n+\t\t\treturn this;\n+\t\t}\n+\t\treturn frame(newFrame.intValue());\n+\t}\n+\n \tprivate DebuggerCoordinates replaceView(TraceProgramView newView) {\n \t\treturn new DebuggerCoordinates(trace, platform, recorder, thread, newView, time, frame,\n \t\t\tobject);",
    "output": "Fix NPEs when restoring the Debugger with open traces"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java\n--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java\n@@ -111,8 +111,8 @@ public void testAssemble_T_push_r7_lr() {\n \t}\n \n \t@Test\n-\tpublic void testAssemble_T_vmov_i32_d0_simdExpand_0x1_0x0_0xb1() {\n-\t\tassertOneCompatRestExact(\"vmov.i32 d0,simdExpand(0x1,0x0,0xb1)\", \"83:ff:31:00\", THUMB,\n-\t\t\t0x00010100, \"vmov.i32 d0,simdExpand(0x1,0x0,0xb1)\");\n+\tpublic void testAssemble_T_vmov_i32_d0_simdExpand_0x0_0x0_0xb1() {\n+\t\tassertOneCompatRestExact(\"vmov.i32 d0,simdExpand(0x0,0x0,0xb1)\", \"83:ff:11:00\", THUMB,\n+\t\t\t0x00010100, \"vmov.i32 d0,simdExpand(0x0,0x0,0xb1)\");\n \t}\n }",
    "output": "Fix for vmov instruction not assembling correctly."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java b/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java\n@@ -885,8 +885,8 @@ else if (val1.isAddress()) {\n \t\t\t\t\t\t\t\t\t// if not, we must rely on reference to function.\n \t\t\t\t\t\t\t\t\ttarget = resolveFunctionReference(val1.getAddress());\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse if (val1.getSpace() == AddressSpace.EXTERNAL_SPACE.getSpaceID()) {\n-\t\t\t\t\t\t\t\t\t// target = val1.getAddress();\n+\t\t\t\t\t\t\t\telse if (vContext.isExternalSpace(val1.getSpace())) {\n+\t\t\t\t\t\t\t\t\ttarget = val1.getAddress();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t// if the value didn't get changed, then the real value isn't in here, don't make a reference\n \t\t\t\t\t\t\t\tif (target != null) {",
    "output": "Fix for regression from change for external calls"
  },
  {
    "input": "diff --git a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/stringable/FunctionSignatureStringable.java b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/stringable/FunctionSignatureStringable.java\n--- a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/stringable/FunctionSignatureStringable.java\n+++ b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/api/stringable/FunctionSignatureStringable.java\n@@ -469,6 +469,11 @@ public boolean equals(Object obj) {\n \t\tif (!returnInfo.isEquivalent(other.returnInfo)) { // storage not checked\n \t\t\treturn false;\n \t\t}\n+\n+\t\tif (!callingConventionName.equals(other.callingConventionName)) {\n+\t\t\treturn false;\n+\t\t}\n+\n \t\tint paramCnt = parameterInfos.size();\n \t\tif (paramCnt != other.parameterInfos.size()) {\n \t\t\treturn false;",
    "output": "Fix VT calling convention apply markup issue"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java\n@@ -39,7 +39,8 @@ public OmfCommentRecord(BinaryReader reader) throws IOException {\n \t\tbyte[] bytes = reader.readNextByteArray(\n \t\t\tgetRecordLength() - 3 /* 3 = sizeof(commentType+commentClass+trailing_crcbyte*/);\n \n-\t\tif (commentClass == COMMENT_CLASS_TRANSLATOR || commentClass == COMMENT_CLASS_LIBMOD || commentClass == COMMENT_CLASS_DEFAULT_LIBRARY) {\n+\t\tif (commentClass == COMMENT_CLASS_TRANSLATOR || commentClass == COMMENT_CLASS_LIBMOD ||\n+\t\t\tcommentClass == COMMENT_CLASS_DEFAULT_LIBRARY) {\n \t\t\tvalue = new String(bytes, StandardCharsets.US_ASCII); // assuming ASCII\n \t\t}\n \t\treadCheckSumByte(reader);",
    "output": "Fix PR source formatting"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/omf/OmfCommentRecord.java\n@@ -21,8 +21,12 @@\n import ghidra.app.util.bin.BinaryReader;\n \n public class OmfCommentRecord extends OmfRecord {\n+\t// Language translator comment\n \tpublic static final byte COMMENT_CLASS_TRANSLATOR = 0;\n+\t// Record specifying name of object\n \tpublic static final byte COMMENT_CLASS_LIBMOD = (byte) 0xA3;\n+\t// Default library cmd\n+\tpublic static final byte COMMENT_CLASS_DEFAULT_LIBRARY = (byte) 0x9F;\n \n \tprivate byte commentType;\n \tprivate byte commentClass;\n@@ -35,7 +39,7 @@ public OmfCommentRecord(BinaryReader reader) throws IOException {\n \t\tbyte[] bytes = reader.readNextByteArray(\n \t\t\tgetRecordLength() - 3 /* 3 = sizeof(commentType+commentClass+trailing_crcbyte*/);\n \n-\t\tif (commentClass == COMMENT_CLASS_TRANSLATOR || commentClass == COMMENT_CLASS_LIBMOD) {\n+\t\tif (commentClass == COMMENT_CLASS_TRANSLATOR || commentClass == COMMENT_CLASS_LIBMOD || commentClass == COMMENT_CLASS_DEFAULT_LIBRARY) {\n \t\t\tvalue = new String(bytes, StandardCharsets.US_ASCII); // assuming ASCII\n \t\t}\n \t\treadCheckSumByte(reader);",
    "output": "Add DEFAULT_LIBRARY to the comment class Adds the class DEFAULT_LIBRARY and decodes the String"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/AVR8AssemblyTest.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/AVR8AssemblyTest.java\n--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/AVR8AssemblyTest.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/AVR8AssemblyTest.java\n@@ -61,7 +61,7 @@ public void testAssemble_call_0x256() {\n \t}\n \n \t@Test\n-\tpublic void testAssemble_com_Wlo() {\n-\t\tassertOneCompatRestExact(\"com Wlo\", \"80:95\", 0x006fba * 2);\n+\tpublic void testAssemble_com_R24() {\n+\t\tassertOneCompatRestExact(\"com R24\", \"80:95\", 0x006fba * 2);\n \t}\n }",
    "output": "Fix AVR8 Wlo test"
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/main/java/pdb/LoadPdbTask.java b/Ghidra/Features/PDB/src/main/java/pdb/LoadPdbTask.java\n--- a/Ghidra/Features/PDB/src/main/java/pdb/LoadPdbTask.java\n+++ b/Ghidra/Features/PDB/src/main/java/pdb/LoadPdbTask.java\n@@ -175,10 +175,10 @@ private void scheduleDemangler(AutoAnalysisManager manager, Options analysisProp\n \t\t\tAddressSetView addrs) {\n \t\tMicrosoftDemanglerAnalyzer demanglerAnalyzer = new MicrosoftDemanglerAnalyzer();\n \t\tString analyzerName = demanglerAnalyzer.getName();\n-\t\tString defaultValueAsString = analysisProperties.getValueAsString(analyzerName);\n+\t\tString valueAsString = analysisProperties.getValueAsString(analyzerName);\n \n \t\t// Do not demangle if the demangler analyzer is turned off\n-\t\tif (!Boolean.parseBoolean(defaultValueAsString)) {\n+\t\tif (!Boolean.parseBoolean(valueAsString)) {\n \t\t\treturn;\n \t\t}\n \t\tmanager.scheduleOneTimeAnalysis(demanglerAnalyzer, addrs);",
    "output": "Improve demangler analysis after LoadPdbTask."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractLibrarySupportLoader.java\n@@ -135,6 +135,9 @@ protected boolean loadProgramInto(ByteProvider provider, LoadSpec loadSpec,\n \t@Override\n \tprotected void postLoadProgramFixups(List<LoadedProgram> loadedPrograms, List<Option> options,\n \t\t\tMessageLog messageLog, TaskMonitor monitor) throws CancelledException, IOException {\n+\t\tif (loadedPrograms.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n \t\tif (isLinkExistingLibraries(options) || isLoadLocalLibraries(options) ||\n \t\t\tisLoadSystemLibraries(options)) {\n \t\t\tDomainFolder programFolder = loadedPrograms.get(0).destinationFolder();",
    "output": "Fix issue with empty program list"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/manager/impl/GdbInferiorImpl.java b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/manager/impl/GdbInferiorImpl.java\n--- a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/manager/impl/GdbInferiorImpl.java\n+++ b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/manager/impl/GdbInferiorImpl.java\n@@ -245,11 +245,11 @@ public CompletableFuture<Map<String, GdbModule>> listModules() {\n \t\t// \"nosections\" is an unlikely section name. Goal is to exclude section lines.\n \t\t// TODO: Would be nice to save this switch, or better, choose at start based on version\n \t\tCompletableFuture<String> future =\n-\t\t\tconsoleCapture(\"maintenance info sections ALLOBJ nosections\",\n+\t\t\tconsoleCapture(\"maintenance info sections ALLOBJ\",\n \t\t\t\tCompletesWithRunning.CANNOT);\n \t\treturn future.thenCompose(output -> {\n \t\t\tif (output.split(\"\\n\").length <= 1) {\n-\t\t\t\treturn consoleCapture(\"maintenance info sections -all-objects nosections\")\n+\t\t\t\treturn consoleCapture(\"maintenance info sections -all-objects\")\n \t\t\t\t\t\t.thenApply(out2 -> parseModuleNames(out2, true));\n \t\t\t}\n \t\t\treturn CompletableFuture.completedFuture(parseModuleNames(output, false));",
    "output": "Remove nosections from gdb manager's listModules"
  },
  {
    "input": "diff --git a/Ghidra/Features/Python/src/main/java/ghidra/python/PythonUtils.java b/Ghidra/Features/Python/src/main/java/ghidra/python/PythonUtils.java\n--- a/Ghidra/Features/Python/src/main/java/ghidra/python/PythonUtils.java\n+++ b/Ghidra/Features/Python/src/main/java/ghidra/python/PythonUtils.java\n@@ -27,7 +27,7 @@\n  */\n public class PythonUtils {\n \n-\tpublic static final String PYTHON_NAME = \"jython-2.7.2\";\n+\tpublic static final String PYTHON_NAME = \"jython-2.7.3\";\n \tpublic static final String PYTHON_CACHEDIR = \"jython_cachedir\";\n \tpublic static final String PYTHON_SRC = \"python-src\";\n ",
    "output": "Upgrade Jython to 2.7.3"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/pcode/DebuggerPcodeStepperProvider.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/pcode/DebuggerPcodeStepperProvider.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/pcode/DebuggerPcodeStepperProvider.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/pcode/DebuggerPcodeStepperProvider.java\n@@ -899,7 +899,7 @@ protected void adjustCodeColWidth(List<PcodeRow> rows) {\n \t}\n \n \tprotected void populatePcode(PcodeFrame frame) {\n-\t\tLanguage language = current.getTrace().getBaseLanguage();\n+\t\tLanguage language = current.getPlatform().getLanguage();\n \n \t\tPcodeRowHtmlFormatter formatter = new PcodeRowHtmlFormatter(language, frame);\n \t\tList<PcodeRow> toAdd = formatter.getRows();\n@@ -920,7 +920,7 @@ else if (frame.isFallThrough()) {\n \n \tprotected <T> void populateUnique(PcodeFrame frame, PcodeExecutorState<T> state,\n \t\t\tPcodeArithmetic<T> arithmetic) {\n-\t\tLanguage language = current.getTrace().getBaseLanguage();\n+\t\tLanguage language = current.getPlatform().getLanguage();\n \t\t// NOTE: They may overlap. I don't think I care.\n \t\tSet<Varnode> uniques = new TreeSet<>(UNIQUE_COMPARATOR);\n \t\tfor (PcodeOp op : frame.getCode()) {",
    "output": "Fix p-code stepper register names in guest platforms"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghpatexpress/TokenPattern.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghpatexpress/TokenPattern.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghpatexpress/TokenPattern.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghpatexpress/TokenPattern.java\n@@ -153,7 +153,7 @@ else if (tok1.toklist.size() == tok2.toklist.size()) {\n \t\t\telse if (tok2.getRightEllipsis()) {\n \t\t\t\tif (tok2.toklist.size() != minsize) {\n \t\t\t\t\tthrow new SleighError(String.format(\"Mismatched pattern sizes -- %d vs %d\",\n-\t\t\t\t\t\ttok1.toklist.size(), minsize), location);\n+\t\t\t\t\t\ttok2.toklist.size(), minsize), location);\n \t\t\t\t}\n \t\t\t\telse if (tok1.toklist.size() == tok2.toklist.size()) {\n \t\t\t\t\tthrow new SleighError(\"Pattern size cannot vary (missing ... ?)\", location);",
    "output": "Fix typo in sleigh error print"
  },
  {
    "input": "diff --git a/Ghidra/Features/MicrosoftDemangler/src/main/java/ghidra/app/plugin/core/analysis/MicrosoftDemanglerAnalyzer.java b/Ghidra/Features/MicrosoftDemangler/src/main/java/ghidra/app/plugin/core/analysis/MicrosoftDemanglerAnalyzer.java\n--- a/Ghidra/Features/MicrosoftDemangler/src/main/java/ghidra/app/plugin/core/analysis/MicrosoftDemanglerAnalyzer.java\n+++ b/Ghidra/Features/MicrosoftDemangler/src/main/java/ghidra/app/plugin/core/analysis/MicrosoftDemanglerAnalyzer.java\n@@ -67,6 +67,9 @@ public void registerOptions(Options options, Program program) {\n \tpublic void optionsChanged(Options options, Program program) {\n \t\tapplyFunctionSignature =\n \t\t\toptions.getBoolean(OPTION_NAME_APPLY_SIGNATURE, applyFunctionSignature);\n+\n+\t\tapplyCallingConvention =\n+\t\t\toptions.getBoolean(OPTION_NAME_APPLY_CALLING_CONVENTION, applyCallingConvention);\n \t}\n \n \t@Override",
    "output": "Fix MSFT Demangler Calling Conventions flag"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/register/ProgramRegisterContextDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/register/ProgramRegisterContextDB.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/register/ProgramRegisterContextDB.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/register/ProgramRegisterContextDB.java\n@@ -273,9 +273,6 @@ public void setRegisterValue(Address start, Address end, RegisterValue value)\n \t\tlock.acquire();\n \t\tboolean restore = false;\n \t\ttry {\n-\t\t\t// FIXME: We do not properly handle painting context across the full \n-\t\t\t// address space which should be avoided.  A non-zero image\n-\t\t\t// base offset can result in a improperly coalesced long key-range.\n \t\t\tcheckContextWrite(value.getRegister(), start, end);\n \t\t\trestore = !changing; // indicates that we just initiated a change\n \t\t\tchanging = true;",
    "output": "Remove obsolete comment"
  },
  {
    "input": "diff --git a/Ghidra/Features/GraphFunctionCalls/src/main/java/functioncalls/plugin/FcgProvider.java b/Ghidra/Features/GraphFunctionCalls/src/main/java/functioncalls/plugin/FcgProvider.java\n--- a/Ghidra/Features/GraphFunctionCalls/src/main/java/functioncalls/plugin/FcgProvider.java\n+++ b/Ghidra/Features/GraphFunctionCalls/src/main/java/functioncalls/plugin/FcgProvider.java\n@@ -172,6 +172,13 @@ private void saveCurrentGraphPerspective() {\n \t\tif (!graphData.hasResults()) {\n \t\t\treturn;\n \t\t}\n+\t\t\n+\t\t// The graph component won't contain valid perspective information if it's not 'initialized'\n+\t\t// (i.e. rendered or displayed to the user). It may happen if the graph has been kept minimized \n+\t\t// in the separate tab. Related method: `GraphComponent::viewerInitialized`\n+\t\tif (view.getGraphComponent().isUninitialized()) {\n+\t\t\treturn;\n+\t\t}\n \n \t\tGraphPerspectiveInfo<FcgVertex, FcgEdge> info = view.generateGraphPerspective();\n \t\tgraphData.setGraphPerspective(info);",
    "output": "Fix incorrect positioning of function call graph"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/LoadCommandFactory.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/LoadCommandFactory.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/LoadCommandFactory.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/LoadCommandFactory.java\n@@ -77,10 +77,10 @@ public static LoadCommand getLoadCommand(BinaryReader reader, MachHeader header,\n \t\t\tcase LC_LOAD_DYLIB:\n \t\t\tcase LC_ID_DYLIB:\n \t\t\tcase LC_LOAD_UPWARD_DYLIB:\n-\t\t\tcase LC_DYLD_ENVIRONMENT:\n \t\t\t\treturn new DynamicLibraryCommand(reader);\n \t\t\tcase LC_LOAD_DYLINKER:\n \t\t\tcase LC_ID_DYLINKER:\n+\t\t\tcase LC_DYLD_ENVIRONMENT:\n \t\t\t\treturn new DynamicLinkerCommand(reader);\n \t\t\tcase LC_PREBOUND_DYLIB:\n \t\t\t\treturn new PreboundDynamicLibraryCommand(reader);",
    "output": "Fix Mach-O LC_DYLD_ENVIRONMENT"
  },
  {
    "input": "diff --git a/Ghidra/Debug/TaintAnalysis/src/test/java/ghidra/pcode/emu/taint/trace/TaintTracePcodeEmulatorTest.java b/Ghidra/Debug/TaintAnalysis/src/test/java/ghidra/pcode/emu/taint/trace/TaintTracePcodeEmulatorTest.java\n--- a/Ghidra/Debug/TaintAnalysis/src/test/java/ghidra/pcode/emu/taint/trace/TaintTracePcodeEmulatorTest.java\n+++ b/Ghidra/Debug/TaintAnalysis/src/test/java/ghidra/pcode/emu/taint/trace/TaintTracePcodeEmulatorTest.java\n@@ -234,7 +234,7 @@ public void testZeroByXor() throws Throwable {\n \n \t\t\tTracePropertyMap<String> taintMap =\n \t\t\t\ttb.trace.getAddressPropertyManager().getPropertyMap(\"Taint\", String.class);\n-\t\t\tTracePropertyMapRegisterSpace<String> mapSpace =\n+\t\t\tTracePropertyMapSpace<String> mapSpace =\n \t\t\t\ttaintMap.getPropertyMapRegisterSpace(thread, 0, false);\n \n \t\t\tassertEquals(Set.of(),\n@@ -265,7 +265,7 @@ public void testZeroByXorVia32() throws Throwable {\n \n \t\t\tTracePropertyMap<String> taintMap =\n \t\t\t\ttb.trace.getAddressPropertyManager().getPropertyMap(\"Taint\", String.class);\n-\t\t\tTracePropertyMapRegisterSpace<String> mapSpace =\n+\t\t\tTracePropertyMapSpace<String> mapSpace =\n \t\t\t\ttaintMap.getPropertyMapRegisterSpace(thread, 0, false);\n \n \t\t\tassertEquals(Set.of(),",
    "output": "Fix compilation after merges"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighConstant.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighConstant.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighConstant.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighConstant.java\n@@ -115,7 +115,8 @@ public void decode(Decoder decoder) throws PcodeXMLException {\n \t\t\t\t\tif (addr != null) {\n \t\t\t\t\t\tData data = program.getListing().getDataAt(addr);\n \t\t\t\t\t\tDataType dt = data == null ? DataType.DEFAULT : data.getDataType();\n-\t\t\t\t\t\tsymbol = globalMap.newSymbol(symref, addr, dt, data.getLength());\n+\t\t\t\t\t\tint size = data == null ? 1 : data.getLength();\n+\t\t\t\t\t\tsymbol = globalMap.newSymbol(symref, addr, dt, size);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix for failing tests"
  },
  {
    "input": "diff --git a/GhidraBuild/LaunchSupport/src/main/java/ghidra/launch/WindowsJavaFinder.java b/GhidraBuild/LaunchSupport/src/main/java/ghidra/launch/WindowsJavaFinder.java\n--- a/GhidraBuild/LaunchSupport/src/main/java/ghidra/launch/WindowsJavaFinder.java\n+++ b/GhidraBuild/LaunchSupport/src/main/java/ghidra/launch/WindowsJavaFinder.java\n@@ -27,8 +27,11 @@ public class WindowsJavaFinder extends JavaFinder {\n \t@Override\n \tprotected List<File> getJavaRootInstallDirs() {\n \t\tList<File> javaRootInstallDirs = new ArrayList<>();\n+\t\tjavaRootInstallDirs.add(new File(\"C:\\\\Java\"));\n \t\tjavaRootInstallDirs.add(new File(\"C:\\\\Program Files\\\\Java\"));\n \t\tjavaRootInstallDirs.add(new File(\"C:\\\\Program Files\\\\Amazon Corretto\"));\n+\t\tjavaRootInstallDirs.add(new File(\"C:\\\\Program Files\\\\Eclipse Adoptium\"));\n+\t\tjavaRootInstallDirs.add(new File(\"C:\\\\Program Files\\\\Microsoft\"));\n \t\treturn javaRootInstallDirs;\n \t}\n ",
    "output": "Add some new default JDK Windows installation locations to LaunchSupport"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java\n@@ -63,7 +63,7 @@ public enum Platform {\n \t/**\n \t * Identifies a macOS ARM 64-bit OS.\n \t */\n-\tMAC_ARM_64(OperatingSystem.MAC_OS_X, Architecture.ARM_64, \"mac_arm_64\", \".so\", \"\"),\n+\tMAC_ARM_64(OperatingSystem.MAC_OS_X, Architecture.ARM_64, \"mac_arm_64\", \".dylib\", \"\"),\n \n \t/**\n \t * Identifies an unsupported OS.",
    "output": "Fix wrong library extension on mac_arm_64 platform"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pdb/PdbInfoDotNet.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pdb/PdbInfoDotNet.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pdb/PdbInfoDotNet.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pdb/PdbInfoDotNet.java\n@@ -121,8 +121,8 @@ public DataType toDataType() {\n \t\tstruct.add(new StringDataType(), magic.length, \"signature\", null);\n \t\tstruct.add(new GuidDataType(), \"guid\", null);\n \t\tstruct.add(new DWordDataType(), \"age\", null);\n-\t\tif (pdbName.length() > 0) {\n-\t\t\tstruct.add(new StringDataType(), pdbName.length(), \"pdbname\", null);\n+\t\tif (pdbPath.length() > 0) {\n+\t\t\tstruct.add(new StringDataType(), pdbPath.length(), \"pdbpath\", null);\n \t\t}\n \t\tstruct.setCategoryPath(new CategoryPath(\"/PDB\"));\n \t\treturn struct;",
    "output": "Fix pdbinfo structure display"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/model/impl/GdbModelTargetStackFrameRegisterContainer.java b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/model/impl/GdbModelTargetStackFrameRegisterContainer.java\n--- a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/model/impl/GdbModelTargetStackFrameRegisterContainer.java\n+++ b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/model/impl/GdbModelTargetStackFrameRegisterContainer.java\n@@ -88,13 +88,13 @@ protected CompletableFuture<Void> populateRegisterDescriptions() {\n \t\t\tif (!valid) {\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tif (regs.size() != registersByNumber.size()) {\n-\t\t\t\tallRegisters.clear();\n-\t\t\t\tregistersByNumber.clear();\n-\t\t\t}\n-\t\t\tallRegisters.addAll(regs);\n \t\t\tList<GdbModelTargetStackFrameRegister> registers;\n \t\t\tsynchronized (this) {\n+\t\t\t\tif (regs.size() != registersByNumber.size()) {\n+\t\t\t\t\tallRegisters.clear();\n+\t\t\t\t\tregistersByNumber.clear();\n+\t\t\t\t}\n+\t\t\t\tallRegisters.addAll(regs);\n \t\t\t\tregisters = regs.stream().map(this::getTargetRegister).collect(Collectors.toList());\n \t\t\t}\n \t\t\tsetElements(registers, Map.of(), \"Refreshed\");",
    "output": "Fix GDB tests"
  },
  {
    "input": "diff --git a/GPL/DMG/src/dmg/java/mobiledevices/dmg/ghidra/GRandomAccessFile.java b/GPL/DMG/src/dmg/java/mobiledevices/dmg/ghidra/GRandomAccessFile.java\n--- a/GPL/DMG/src/dmg/java/mobiledevices/dmg/ghidra/GRandomAccessFile.java\n+++ b/GPL/DMG/src/dmg/java/mobiledevices/dmg/ghidra/GRandomAccessFile.java\n@@ -17,7 +17,6 @@ public class GRandomAccessFile {\n \tprivate static final byte[] EMPTY = new byte[0];\n \tprivate static final int BUFFER_SIZE = 0x100000;\n \n-\tprivate File file;\n \tprivate RandomAccessFile randomAccessFile;\n \tprivate byte[] buffer = EMPTY;\n \tprivate long bufferOffset = 0;\n@@ -77,7 +76,6 @@ private void checkOpen() throws IOException {\n \t *            while opening or creating the file\n \t */\n \tpublic GRandomAccessFile(File file, String mode) throws IOException {\n-\t\tthis.file = file;\n \t\trandomAccessFile = new RandomAccessFile(file, mode);\n \t\tthis.open = true;\n \t}",
    "output": "Remove unused File field."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SleighParserContext.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SleighParserContext.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SleighParserContext.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SleighParserContext.java\n@@ -86,6 +86,7 @@ public SleighParserContext(Address aAddr, Address nAddr, Address rAddr, Address\n \t\tnextInstrAddr = nAddr;\n \t\trefAddr = rAddr;\n \t\tdestAddr = dAddr;\n+\t\thandleMap = new HashMap<>();\n \t}\n \n \t/**",
    "output": "Fix NPE due to unintialized handleMap"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/autocomplete/TextFieldAutocompleter.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/autocomplete/TextFieldAutocompleter.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/autocomplete/TextFieldAutocompleter.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/autocomplete/TextFieldAutocompleter.java\n@@ -759,6 +759,7 @@ public void flushUpdates() {\n \t * Update the completion list immediately\n \t */\n \tpublic void updateNow() {\n+\t\tpendingTextUpdate = true;\n \t\tupdateManager.updateNow();\n \t}\n ",
    "output": "Fix DebuggerDisassemblyTest, again"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/OperandType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/OperandType.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/OperandType.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/OperandType.java\n@@ -341,6 +341,16 @@ public static boolean isFloat(int operandType) {\n \tpublic static boolean isCoProcessor(int operandType) {\n \t\treturn (operandType & COP) != 0;\n \t}\n+\t\n+    /**\n+\t * check the DYNAMIC flag.\n+\t * @param operandType the bit field to examine.\n+\t *\n+\t * @return true if the DYNAMIC flag is set.\n+\t */\n+\tpublic static boolean isDynamic(int operandType) {\n+\t\treturn (operandType & DYNAMIC) != 0;\n+\t}\n \n \t/**\n \t * check if both a scalar and an address\n@@ -458,6 +468,10 @@ public static String toString(int operandType) {\n \t\t\tappend(buf, \"COP \");\n \t\t}\n \n+        if (isDynamic(operandType)) {\n+            append(buf, \"DYN \");\n+        }\n+\n \t\treturn buf.toString();\n \t}\n ",
    "output": "Add DYNAMIC flag to toString for OperandType"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/AbstractDecompilerFindReferencesActionTest.java b/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/AbstractDecompilerFindReferencesActionTest.java\n--- a/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/AbstractDecompilerFindReferencesActionTest.java\n+++ b/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/AbstractDecompilerFindReferencesActionTest.java\n@@ -40,7 +40,6 @@\n import ghidra.program.util.ProgramLocation;\n import ghidra.util.HelpLocation;\n import ghidra.util.task.TaskMonitor;\n-import mockit.Mock;\n \n public abstract class AbstractDecompilerFindReferencesActionTest extends AbstractDecompilerTest {\n \n@@ -189,23 +188,20 @@ public SpyDataTypeReferenceFinder() {\n \t\t}\n \n \t\t@Override\n-\t\t@Mock\n \t\tpublic void findReferences(Program p, DataType dataType,\n \t\t\t\tConsumer<DataTypeReference> callback, TaskMonitor monitor) {\n \n \t\t\tdataTypeReferencesCallCount.incrementAndGet();\n \t\t}\n \n \t\t@Override\n-\t\t@Mock\n \t\tpublic void findReferences(Program p, DataType dt, String fieldName,\n \t\t\t\tConsumer<DataTypeReference> callback, TaskMonitor monitor) {\n \n \t\t\tcompositeFieldReferencesCallCount.incrementAndGet();\n \t\t}\n \n \t\t@Override\n-\t\t@Mock\n \t\tpublic void findReferences(Program p, FieldMatcher fieldMatcher,\n \t\t\t\tConsumer<DataTypeReference> callback, TaskMonitor monitor) {\n ",
    "output": "Remove left-over annotations"
  },
  {
    "input": "diff --git a/Ghidra/Debug/ProposedUtils/src/test/java/ghidra/util/database/spatial/RStarTreeMapTest.java b/Ghidra/Debug/ProposedUtils/src/test/java/ghidra/util/database/spatial/RStarTreeMapTest.java\n--- a/Ghidra/Debug/ProposedUtils/src/test/java/ghidra/util/database/spatial/RStarTreeMapTest.java\n+++ b/Ghidra/Debug/ProposedUtils/src/test/java/ghidra/util/database/spatial/RStarTreeMapTest.java\n@@ -877,7 +877,6 @@ public void testIntegrityWith1000RandomRects100x100Max10x10Using2Threads() throw\n \t\t\ttry (UndoableTransaction tid = UndoableTransaction.start(obj, \"AddRandom\", true)) {\n \t\t\t\tint i = 0;\n \t\t\t\tfor (Entry<IntRect, String> ent : list) {\n-\t\t\t\t\tSystem.err.println(\"Adding (sub) \" + i++);\n \t\t\t\t\tobj.map.put(ent.getKey(), ent.getValue());\n \t\t\t\t\t// Note, underlying tree is not synchronized, but map is\n \t\t\t\t\ttry (LockHold hold = LockHold.lock(obj.getReadWriteLock().readLock())) {\n@@ -906,7 +905,6 @@ public void testIntegrityWith1000RandomRects100x100Max10x10Using2Threads() throw\n \tpublic void testIntegrityWith2000VerticallyStackedRects() throws Exception {\n \t\ttry (UndoableTransaction tid = UndoableTransaction.start(obj, \"AddVertical\", true)) {\n \t\t\tfor (int i = 0; i < 2000; i++) {\n-\t\t\t\tSystem.err.println(\"Adding \" + i);\n \t\t\t\tobj.map.put(rect(0, 10, i, i + 1), \"Ent\" + i);\n \t\t\t\t// Note, underlying tree is not synchronized, but map is\n \t\t\t\t/*try (LockHold hold = LockHold.lock(obj.getReadWriteLock().readLock())) {",
    "output": "Remove gratuitous use of System.error in R*-TreeMap test"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/ByteCopier.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/ByteCopier.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/ByteCopier.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/ByteCopier.java\n@@ -415,7 +415,7 @@ public boolean applyTo(DomainObject domainObject) {\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \n-\t\t\t\t// Ask the user before pasting a string into the program.  Since having a string in \n+\t\t\t\t// Ask the user before pasting a string into the program.  Since having a string in\n \t\t\t\t// the clipboard is so common, this is to prevent an accidental paste.\n \t\t\t\tif (!confirmPaste(validString)) {\n \t\t\t\t\treturn true; // the user cancelled; the command is successful\n@@ -447,7 +447,7 @@ private boolean pasteBytes(Program program, byte[] bytes) {\n \t\t\t\t\t}\n \t\t\t\t\taddress = address.next();\n \t\t\t\t}\n-\t\t\t\treturn foundError;\n+\t\t\t\treturn !foundError;\n \t\t\t}\n \n \t\t\tprivate boolean confirmPaste(String validString) {",
    "output": "Upgrade incorrect tool status message when pasting bytes"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/util/DefaultTraceChangeType.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/util/DefaultTraceChangeType.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/util/DefaultTraceChangeType.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/util/DefaultTraceChangeType.java\n@@ -22,7 +22,8 @@\n import ghidra.framework.model.DomainObjectChangeRecord;\n \n public class DefaultTraceChangeType<T, U> implements TraceChangeType<T, U> {\n-\tprivate static int nextType = 0x3ACE0000; // Stay far away from manually-assigned types\n+\tprivate static int nextType = 0x3ACE; // Stay far away from manually-assigned types\n+\t// But not too far, since it makes the bit set for events gigantic.\n \n \tprivate static final Map<Integer, String> TYPE_NAMES = new HashMap<>();\n \tprivate static final Set<Field> FIELD_BACKLOG = new HashSet<>();",
    "output": "Change starting number for TraceChangeTypes"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-agent-frida/src/test/java/agent/frida/model/AbstractModelForFridaX64RegistersTest.java b/Ghidra/Debug/Debugger-agent-frida/src/test/java/agent/frida/model/AbstractModelForFridaX64RegistersTest.java\n--- a/Ghidra/Debug/Debugger-agent-frida/src/test/java/agent/frida/model/AbstractModelForFridaX64RegistersTest.java\n+++ b/Ghidra/Debug/Debugger-agent-frida/src/test/java/agent/frida/model/AbstractModelForFridaX64RegistersTest.java\n@@ -176,4 +176,11 @@ public void testWriteRegisters() throws Throwable {\n \t\t\tread.keySet());\n \t}\n \n+\t@Override\n+\t@Ignore\n+\t@Test\n+\tpublic void testBanksAreContainersConventionIsAsExpected() throws Throwable {\n+\t\t// Disabled as of 220609\n+\t}\n+\n }",
    "output": "Fix for one more test"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerUtils.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerUtils.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerUtils.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerUtils.java\n@@ -486,9 +486,18 @@ private static void addTokens(List<ClangToken> tokenList, Field[] lines, int lin\n \t\tif (lineNumber >= lines.length) {\n \t\t\treturn;\n \t\t}\n+\n \t\tClangTextField textLine = (ClangTextField) lines[lineNumber];\n \t\tint startIndex = getStartIndex(textLine, start);\n \t\tint endIndex = getEndIndex(textLine, end);\n+\t\tif (startIndex >= endIndex) {\n+\t\t\t// There is a bug in how the start and end field location get created when a line\n+\t\t\t// wraps.  This is likely something we can fix if we can get an example that shows this\n+\t\t\t// state.  For now, we are adding this error checking to prevent an exception in the\n+\t\t\t// call below.\n+\t\t\treturn;\n+\t\t}\n+\n \t\ttokenList.addAll(textLine.getTokens().subList(startIndex, endIndex));\n \t}\n ",
    "output": "Fix to prevent exception when making a selection that contains a wrapped Decompiler line"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ArrayValuesFieldFactory.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ArrayValuesFieldFactory.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ArrayValuesFieldFactory.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/ArrayValuesFieldFactory.java\n@@ -99,7 +99,7 @@ public ListingField getField(ProxyObj<?> proxy, int varWidth) {\n \t\tFieldElement[] aStrings = new FieldElement[valuesThisLine];\n \t\tfor (int i = 0; i < valuesThisLine; i++) {\n \t\t\tData child = parent.getComponent(index++);\n-\t\t\tString value = getDisplayValue(child, i != valuesThisLine - 1);\n+\t\t\tString value = getDisplayValue(child, remaining > valuesThisLine || i != valuesThisLine - 1);\n \t\t\tAttributedString as = new AttributedString(value, color, getMetrics());\n \t\t\taStrings[i] = new TextFieldElement(as, i, 0);\n \t\t}",
    "output": "Add trailing comma to arrays display"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/generic/test/AbstractGTest.java b/Ghidra/Framework/Generic/src/main/java/generic/test/AbstractGTest.java\n--- a/Ghidra/Framework/Generic/src/main/java/generic/test/AbstractGTest.java\n+++ b/Ghidra/Framework/Generic/src/main/java/generic/test/AbstractGTest.java\n@@ -15,8 +15,6 @@\n  */\n package generic.test;\n \n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.core.StringContains.*;\n import static org.junit.Assert.*;\n \n import java.io.File;\n@@ -300,12 +298,11 @@ public static <T> void assertContainsExactly(Collection<T> expected, Collection<\n \t}\n \n \tpublic static <T> void assertContainsString(String expected, String actual) {\n-\t\tassertThat(actual, containsString(expected));\n+\t\tassertTrue(actual.contains(expected));\n \t}\n \n \tpublic static <T> void assertContainsStringIgnoringCase(String expected, String actual) {\n-\t\t// newer hamcrest versions have containsStringIgnoringCase()\n-\t\tassertThat(actual.toLowerCase(), containsString(expected.toLowerCase()));\n+\t\tassertTrue(expected.toLowerCase().contains(actual.toLowerCase()));\n \t}\n \n \tprivate static String printListFailureMessage(String message, List<?> expected,",
    "output": "Fix bad test dependency"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/data/OptionsDB.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/data/OptionsDB.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/data/OptionsDB.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/data/OptionsDB.java\n@@ -21,8 +21,7 @@\n \n import db.*;\n import ghidra.framework.options.*;\n-import ghidra.util.HelpLocation;\n-import ghidra.util.SystemUtilities;\n+import ghidra.util.*;\n import ghidra.util.exception.ClosedException;\n \n /**\n@@ -280,6 +279,10 @@ public Object getCurrentValue() {\n \t\t\t\t\tif (optionType == getOptionType()) {\n \t\t\t\t\t\tvalue = optionType.convertStringToObject(rec.getString(VALUE_COL));\n \t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tMsg.info(this, \"The type for '\" + this.getName() + \"' has changed!  Using default value.\");\n+\t\t\t\t\t\tvalue = getDefaultValue();\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tisCached = true;",
    "output": "Fix to use default value if options type has changed. Blows up by returning the wrong type otherwise."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/util/task/UnknownProgressWrappingTaskMonitor.java b/Ghidra/Framework/Generic/src/main/java/ghidra/util/task/UnknownProgressWrappingTaskMonitor.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/util/task/UnknownProgressWrappingTaskMonitor.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/util/task/UnknownProgressWrappingTaskMonitor.java\n@@ -61,9 +61,9 @@ private void maybeUpdateMaximum() {\n \t\tlong currentMaximum = delegate.getMaximum();\n \t\tlong progress = delegate.getProgress();\n \n-\t\tint _75_percent = (int) (currentMaximum * .75);\n+\t\tlong _75_percent = currentMaximum - (currentMaximum / 4);\n \t\tif (progress > _75_percent) {\n-\t\t\tdelegate.setMaximum(currentMaximum + (currentMaximum - _75_percent));\n+\t\t\tdelegate.setMaximum(Math.max(progress, currentMaximum + currentMaximum / 4));\n \t\t}\n \t}\n ",
    "output": "Fix progress in task monitor when value exceeds 32bit int range"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DyldCacheUtils.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DyldCacheUtils.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DyldCacheUtils.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DyldCacheUtils.java\n@@ -195,10 +195,7 @@ private List<File> getSplitDyldCacheFiles(ByteProvider baseProvider,\n \t\t\tif (file != null && shouldCombineSplitFiles) {\n \t\t\t\tString baseName = file.getName();\n \t\t\t\tFile[] splitFiles = file.getParentFile().listFiles(f -> {\n-\t\t\t\t\tif (!f.getName().startsWith(baseName)) {\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (f.getName().equals(baseName)) {\n+\t\t\t\t\tif (!f.getName().startsWith(baseName + \".\")) {\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n \t\t\t\t\tif (f.getName().toLowerCase().endsWith(\".map\")) {",
    "output": "Fix issue with discovering split dyld_shared_cache files"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java\n@@ -577,7 +577,7 @@ public String getWorkerName() {\n \t\tInteger originalPriority = activeTask.taskPriority;\n \t\tactiveTask.taskPriority = limitPriority;\n \t\ttry {\n-\t\t\tyield(limitPriority, monitor);\n+\t\t\tthis.yield(limitPriority, monitor);\n \t\t}\n \t\tfinally {\n \t\t\tactiveTask.taskPriority = originalPriority;\n@@ -652,7 +652,7 @@ public void startAnalysis(TaskMonitor monitor, boolean printTaskTimes) {\n \t\t\t//    Thinking was that if some analysis causes disassembly to occur,\n \t\t\t//    then that disassembly and it's analysis will keep other analysis out of trouble.\n \t\t\t//    However for single threaded, this might not be worthwhile in the long run.\n-\t\t\tyield(activeTask.taskPriority, monitor);\n+\t\t\tthis.yield(activeTask.taskPriority, monitor);\n \t\t}\n \t\telse if (analysisThread != null || !isEnabled) {\n \t\t\t// this could be a sub-thread of a task, don't yield, or flush domain objects",
    "output": "Fix yield keyword conflict when compiling with JDK 17 compliance."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/ErrLogDialog.java b/Ghidra/Framework/Docking/src/main/java/docking/ErrLogDialog.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/ErrLogDialog.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/ErrLogDialog.java\n@@ -18,8 +18,6 @@\n import java.awt.*;\n import java.awt.event.ComponentAdapter;\n import java.awt.event.ComponentEvent;\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n import java.util.*;\n import java.util.List;\n \n@@ -145,18 +143,6 @@ else if (env.containsKey(\"HOSTNAME\")) {\n \t\treturn \"Workstation: \" + name;\n \t}\n \n-\tprivate Object getHostname() {\n-\t\tString hostname = \"<unknown>\";\n-\t\ttry {\n-\t\t\tInetAddress addr = InetAddress.getLocalHost();\n-\t\t\thostname = addr.getCanonicalHostName();\n-\t\t}\n-\t\tcatch (UnknownHostException e) {\n-\t\t\t// ignore\n-\t\t}\n-\t\treturn hostname;\n-\t}\n-\n \tpublic static void setErrorReporter(ErrorReporter errorReporter) {\n \t\tErrLogDialog.errorReporter = errorReporter;\n \t}",
    "output": "Remove unused code"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/time/schedule/TraceSchedule.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/time/schedule/TraceSchedule.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/time/schedule/TraceSchedule.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/time/schedule/TraceSchedule.java\n@@ -531,6 +531,7 @@ public TraceSchedule patched(TraceThread thread, List<String> sleigh) {\n \t\tfor (String line : sleigh) {\n \t\t\tticks.advance(new PatchStep(thread.getKey(), line));\n \t\t}\n+\t\tticks.coalescePatches(thread.getTrace().getBaseLanguage());\n \t\treturn new TraceSchedule(snap, ticks, new Sequence());\n \t}\n }",
    "output": "Fix missing coalescePatches call"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/memory/DebuggerMemoryBytesProviderTest.java b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/memory/DebuggerMemoryBytesProviderTest.java\n--- a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/memory/DebuggerMemoryBytesProviderTest.java\n+++ b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/memory/DebuggerMemoryBytesProviderTest.java\n@@ -1079,7 +1079,7 @@ public void testStackPCChangedTracks() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testEditLiveBytesWritesTarget() throws Exception {\n+\tpublic void testEditLiveBytesWritesTarget() throws Throwable {\n \t\tcreateTestModel();\n \t\tmb.createTestProcessesAndThreads();\n \n@@ -1097,12 +1097,12 @@ public void testEditLiveBytesWritesTarget() throws Exception {\n \t\tperformAction(actionEdit);\n \t\ttriggerText(memBytesProvider.getByteViewerPanel().getCurrentComponent(), \"42\");\n \t\tperformAction(actionEdit);\n+\t\twaitForSwing();\n+\t\twaitRecorder(recorder);\n \n \t\tbyte[] data = new byte[4];\n-\t\twaitForPass(() -> {\n-\t\t\tmb.testProcess1.memory.getMemory(mb.addr(0x55550800), data);\n-\t\t\tassertArrayEquals(mb.arr(0x42, 0, 0, 0), data);\n-\t\t});\n+\t\tmb.testProcess1.memory.getMemory(mb.addr(0x55550800), data);\n+\t\tassertArrayEquals(mb.arr(0x42, 0, 0, 0), data);\n \t}\n \n \t@Test",
    "output": "Fix timing issue in bytes provider test"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/DebuggerTrackLocationTrait.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/DebuggerTrackLocationTrait.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/DebuggerTrackLocationTrait.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/action/DebuggerTrackLocationTrait.java\n@@ -191,8 +191,11 @@ protected boolean sameCoordinates(DebuggerCoordinates a, DebuggerCoordinates b)\n \t}\n \n \tpublic void setSpec(LocationTrackingSpec spec) {\n-\t\t// TODO: What if action == null?\n-\t\tif (action != null) {\n+\t\tif (action == null) {\n+\t\t\t// It might if the client doesn't need a new button, e.g., TraceDiff\n+\t\t\tdoSetSpec(spec);\n+\t\t}\n+\t\telse {\n \t\t\taction.setCurrentActionStateByUserData(spec);\n \t\t}\n \t}",
    "output": "Fix NPE when changing register-tracking setting in dynamic listing."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/interpreters/DebuggerInterpreterPluginTest.java b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/interpreters/DebuggerInterpreterPluginTest.java\n--- a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/interpreters/DebuggerInterpreterPluginTest.java\n+++ b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/interpreters/DebuggerInterpreterPluginTest.java\n@@ -89,8 +89,7 @@ public void testOutputDisplaysInConsole() throws Exception {\n \t\twaitForSwing();\n \n \t\t// I/O processing has a dedicated thread\n-\t\t// FIXME: The trailing space is a hack to fix scrolling....\n-\t\twaitForPass(() -> assertEquals(\"Hello, World!\\n \", interpreter.getOutputText()));\n+\t\twaitForPass(() -> assertEquals(\"Hello, World!\\n\", interpreter.getOutputText()));\n \t}\n \n \t@Test",
    "output": "Fix Interpreter test after ."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterPlugin.java\n@@ -40,6 +40,7 @@\n import ghidra.formats.gfilesystem.FileCache.FileCacheEntryBuilder;\n import ghidra.formats.gfilesystem.FileSystemService;\n import ghidra.framework.main.*;\n+import ghidra.framework.main.datatree.DomainFileNode;\n import ghidra.framework.main.datatree.DomainFolderNode;\n import ghidra.framework.model.*;\n import ghidra.framework.options.SaveState;\n@@ -305,6 +306,11 @@ private static DomainFolder getFolderFromContext(ActionContext context) {\n \t\t\tDomainFolderNode node = (DomainFolderNode) contextObj;\n \t\t\treturn node.getDomainFolder();\n \t\t}\n+\t\tif (contextObj instanceof DomainFileNode) {\n+\t\t\tDomainFileNode node = (DomainFileNode) contextObj;\n+\t\t\tDomainFile domainFile = node.getDomainFile();\n+\t\t\treturn domainFile != null ? domainFile.getParent() : null;\n+\t\t}\n \n \t\treturn AppInfo.getActiveProject().getProjectData().getRootFolder();\n \t}",
    "output": "Improve import dialog default folder logic If highlighting a file in the project tree, use its folder as the initial import destination."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java\n@@ -1011,9 +1011,14 @@ public DataType resolve(DataType dataType, DataTypeConflictHandler handler) {\n \t\t\treturn dataType;\n \t\t}\n \n+\t\tif (dataType.isDeleted()) {\n+\t\t\tthrow new IllegalArgumentException(\"can't resolve deleted datatype\");\n+\t\t}\n+\n \t\tif (dataType instanceof BitFieldDataType) {\n \t\t\treturn resolveBitFieldDataType((BitFieldDataType) dataType, handler);\n \t\t}\n+\n \t\tlock.acquire();\n \t\tDataTypeConflictHandler originalHandler = null;\n \t\tboolean isEquivalenceCacheOwner = activateEquivalenceCache();",
    "output": "Add deleted datatype check to resolve method"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/util/ManualViewerCommandWrappedOption.java b/Ghidra/Features/Base/src/main/java/ghidra/util/ManualViewerCommandWrappedOption.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/util/ManualViewerCommandWrappedOption.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/util/ManualViewerCommandWrappedOption.java\n@@ -118,7 +118,7 @@ public static ManualViewerCommandWrappedOption getDefaultBrowserLoaderOptions()\n \t\tManualViewerCommandWrappedOption option = new ManualViewerCommandWrappedOption();\n \n \t\tif (Platform.CURRENT_PLATFORM.getOperatingSystem() == OperatingSystem.WINDOWS) {\n-\t\t\toption.setCommandString(\"cmd.exe\");\n+\t\t\toption.setCommandString(System.getenv(\"ComSpec\"));\n \t\t\tString[] args = new String[] { \"/c\", \"start\" };\n \t\t\toption.setCommandArguments(args);\n \t\t\toption.setUrlReplacementString(DEFAULT_URL_REPLACEMENT_STRING);",
    "output": "Use ComSpec in Manual Viewer"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypeManagerPlugin.java\n@@ -60,8 +60,7 @@\n import ghidra.program.model.data.*;\n import ghidra.program.model.listing.DataTypeArchive;\n import ghidra.program.model.listing.Program;\n-import ghidra.util.HelpLocation;\n-import ghidra.util.Msg;\n+import ghidra.util.*;\n import ghidra.util.datastruct.LRUMap;\n import ghidra.util.task.TaskLauncher;\n \n@@ -612,9 +611,11 @@ public List<DataType> getSortedDataTypeList() {\n \n \t@Override\n \tpublic void setDataTypeSelected(DataType dataType) {\n-\t\tif (provider.isVisible()) {\n-\t\t\tprovider.setDataTypeSelected(dataType);\n-\t\t}\n+\t\tSwing.runIfSwingOrRunLater(() -> {\n+\t\t\tif (provider.isVisible()) {\n+\t\t\t\tprovider.setDataTypeSelected(dataType);\n+\t\t\t}\n+\t\t});\n \t}\n \n \t@Override",
    "output": "Fix Swing thread access issue; fixed improper test names"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeDataTypeManager.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeDataTypeManager.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeDataTypeManager.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeDataTypeManager.java\n@@ -439,7 +439,7 @@ private void buildStructure(StringBuilder resBuf, Structure type, int size) {\n \t\t\t}\n \t\t\tresBuf.append(\"<field\");\n \t\t\tString field_name = comp.getFieldName();\n-\t\t\tif (field_name == null) {\n+\t\t\tif (field_name == null || field_name.length() == 0) {\n \t\t\t\tfield_name = comp.getDefaultFieldName();\n \t\t\t}\n \t\t\tSpecXmlUtils.xmlEscapeAttribute(resBuf, \"name\", field_name);\n@@ -470,7 +470,7 @@ public void buildUnion(StringBuilder resBuf, Union unionType) {\n \t\t\t}\n \t\t\tresBuf.append(\"<field\");\n \t\t\tString field_name = comp.getFieldName();\n-\t\t\tif (field_name == null) {\n+\t\t\tif (field_name == null || field_name.length() == 0) {\n \t\t\t\tfield_name = comp.getDefaultFieldName();\n \t\t\t}\n \t\t\tSpecXmlUtils.xmlEscapeAttribute(resBuf, \"name\", field_name);",
    "output": "Fix for decompiler error caused by empty union field names"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java b/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/util/VarnodeContext.java\n@@ -340,7 +340,7 @@ public boolean isStackSymbolicSpace(Varnode varnode) {\n \n \t\treturn isStackSpaceName(regSpace.getName());\n \t}\n-\t\n+\n \t/**\n \t * Check if spaceName is associated with the stack\n \t * \n@@ -849,6 +849,16 @@ private void addSetVarnodeToLastSetLocations(Varnode node, Address address) {\n \t\t\tallLastSet.put(node, addressSet);\n \t\t}\n \t\taddressSet.add(address);\n+\t\t\n+\t\t// for registers with parent larger register, must store that they were\n+\t\t// last set at this address as well.\n+\t\tif (node.isRegister()) {\n+\t\t\tRegister parentRegister = trans.getRegister(node).getParentRegister();\n+\t\t\tif (parentRegister != null) {\n+\t\t\t\tnode = trans.getVarnode(parentRegister);\n+\t\t\t\taddSetVarnodeToLastSetLocations(node, address);\n+\t\t\t}\n+\t\t}\n \t}\n \n \t/**",
    "output": "Fix for tracking the address of the last change to a larger parent register when instructions are modifying the smaller parts of the register"
  },
  {
    "input": "diff --git a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java\n--- a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java\n+++ b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java\n@@ -18,9 +18,10 @@\n \n import static ghidra.formats.gfilesystem.fileinfo.FileAttributeType.*;\n \n+import java.util.*;\n+\n import java.io.Closeable;\n import java.io.IOException;\n-import java.util.*;\n \n import org.apache.commons.io.FilenameUtils;\n \n@@ -124,6 +125,9 @@ private String fixupItemPath(ISimpleInArchiveItem item) throws SevenZipException\n \t\t\t// use the name of the 7zip file itself, minus the extension\n \t\t\titemPath = FilenameUtils.getBaseName(fsrl.getContainer().getName());\n \t\t}\n+\t\tif (itemPath.isEmpty()) {\n+\t\t\titemPath = \"<blank>\";\n+\t\t}\n \t\treturn itemPath;\n \t}\n ",
    "output": "Fix zip file entry with empty name, github"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/TLSDataDirectory.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/TLSDataDirectory.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/TLSDataDirectory.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/TLSDataDirectory.java\n@@ -79,7 +79,7 @@ public void markup(Program program, boolean isBinary, TaskMonitor monitor, Messa\n \t\t\t\t\tAddress nextCallbackAddr = PointerDataType.getAddressValue(\n \t\t\t\t\t\tnew DumbMemBufferImpl(program.getMemory(), nextCallbackPtrAddr),\n \t\t\t\t\t\tpointerDataType.getLength(), space);\n-\t\t\t\t\tif (nextCallbackAddr.getOffset() == 0) {\n+\t\t\t\t\tif (nextCallbackAddr == null || nextCallbackAddr.getOffset() == 0) {\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tPeUtils.createData(program, nextCallbackPtrAddr, pointerDataType, log);",
    "output": "Fix NullPointerException which occurs when getAddressValue returns null There are some cases where getAddressValue returns null, which leads to a nullPointerException in TLSDataDirectory."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataUtilities.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataUtilities.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataUtilities.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataUtilities.java\n@@ -101,6 +101,13 @@ private static boolean isDefaultData(DataType dt) {\n \t\tif (Undefined.isUndefined(dt)) {\n \t\t\treturn true;\n \t\t}\n+\t\tif (dt instanceof TypeDef) {\n+\t\t\tTypeDef td = (TypeDef) dt;\n+\t\t\tif (!td.isAutoNamed()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tdt = td.getDataType();\n+\t\t}\n \t\tif (dt instanceof Pointer) {\n \t\t\tPointer p = (Pointer) dt;\n \t\t\tdt = p.getDataType();",
    "output": "Add new data clear mode CLEAR_ALL_DEFAULT_CONFLICT_DATA for DataUtilities"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java\n@@ -1236,10 +1236,13 @@ public void refilterLater() {\n \t * @param newNode the node that may cause the tree to refilter.\n \t */\n \tpublic void refilterLater(GTreeNode newNode) {\n-\t\tif (isFilteringEnabled && filter != null) {\n-\t\t\tif (filter.acceptsNode(newNode)) {\n-\t\t\t\tfilterUpdateManager.updateLater();\n-\t\t\t}\n+\t\tif (!isFilteringEnabled || filter == null) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// non-leaf nodes may have children that would require filtering\n+\t\tif (!newNode.isLeaf() || filter.acceptsNode(newNode)) {\n+\t\t\tfilterUpdateManager.updateLater();\n \t\t}\n \t}\n ",
    "output": "Fix issue where opening a program didn't apply an existing datatypes tree filter to the new program's datatypes."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractProgramLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractProgramLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractProgramLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/AbstractProgramLoader.java\n@@ -130,7 +130,12 @@ public final List<DomainObject> load(ByteProvider provider, String name, DomainF\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \n-\t\t\t\tif (createProgramFile(loadedProgram, folder, name, messageLog,\n+\t\t\t\t// If this is the main imported program, use the given name, otherwise, use the\n+\t\t\t\t// internal program name. The first program in the list is the main imported program\n+\t\t\t\tString domainFileName =\n+\t\t\t\t\tloadedProgram == programs.get(0) ? name : loadedProgram.getName();\n+\n+\t\t\t\tif (createProgramFile(loadedProgram, folder, domainFileName, messageLog,\n \t\t\t\t\tmonitor)) {\n \t\t\t\t\tresults.add(loadedProgram);\n \t\t\t\t\tprogramsToFixup.add(loadedProgram);",
    "output": "Fix issue dll import names caused by original 1876 fix"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/ReferenceUtils.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/ReferenceUtils.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/ReferenceUtils.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/ReferenceUtils.java\n@@ -862,8 +862,10 @@ private static Data getDataAt(ProgramLocation location) {\n \t\tProgram p = location.getProgram();\n \t\tListing l = p.getListing();\n \t\tData dataContaining = l.getDataContaining(location.getAddress());\n-\t\tData data = dataContaining.getComponent(location.getComponentPath());\n-\t\treturn data;\n+\t\tif (dataContaining != null) {\n+\t\t\treturn dataContaining.getComponent(location.getComponentPath());\n+\t\t}\n+\t\treturn null;\n \t}\n \n \t/*",
    "output": "Fix stack trace"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerLocationLabel.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerLocationLabel.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerLocationLabel.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/DebuggerLocationLabel.java\n@@ -49,6 +49,7 @@ public ForLocationLabelTraceListener() {\n \t\t\tlistenFor(TraceMemoryRegionChangeType.LIFESPAN_CHANGED, this::regionChanged);\n \t\t\tlistenFor(TraceMemoryRegionChangeType.DELETED, this::regionChanged);\n \n+\t\t\tlistenFor(TraceModuleChangeType.ADDED, this::moduleChanged);\n \t\t\tlistenFor(TraceModuleChangeType.CHANGED, this::moduleChanged);\n \t\t\tlistenFor(TraceModuleChangeType.LIFESPAN_CHANGED, this::moduleChanged);\n \t\t\tlistenFor(TraceModuleChangeType.DELETED, this::moduleChanged);",
    "output": "Fix dynamic loc label update on module added"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/TraceObjectManager.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/TraceObjectManager.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/TraceObjectManager.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/TraceObjectManager.java\n@@ -261,6 +261,9 @@ public void createThread(TargetObject added) {\n \t\t\tcatch (DuplicateNameException e) {\n \t\t\t\tthrow new AssertionError(e); // Should be shrinking\n \t\t\t}\n+\t\t\tcatch (IllegalArgumentException e) {\n+\t\t\t\tMsg.warn(this, \"Unable to set creation snap for \" + traceThread);\n+\t\t\t}\n \t\t}\n \t}\n ",
    "output": "Fix for IllegalArgumentException (invalid range)"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledAddressTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledAddressTable.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledAddressTable.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledAddressTable.java\n@@ -88,8 +88,17 @@ public boolean applyTo(Program program, Address address, DemanglerOptions option\n \t\t\treturn false;\n \t\t}\n \n+\t\tif (address.isExternalAddress()) {\n+\t\t\tMsg.warn(this,\n+\t\t\t\t\"Unable to fully apply external demangled Address Table: \" + s.getName(true));\n+\t\t\treturn true;\n+\t\t}\n+\n \t\tListing listing = program.getListing();\n \t\tif (MemoryBlock.isExternalBlockAddress(address, program)) {\n+\t\t\tMsg.warn(this,\n+\t\t\t\t\"Unable to fully apply external demangled Address Table at \" + address + \": \" +\n+\t\t\t\t\ts.getName(true));\n \t\t\tlisting.setComment(address, CodeUnit.EOL_COMMENT,\n \t\t\t\t\"WARNING: Unable to apply demangled Address Table\");\n \t\t\treturn true; // don't complain",
    "output": "Improve improper error reporting by DemangledAddressTable with external symbols"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterDialog.java b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterDialog.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterDialog.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterDialog.java\n@@ -15,13 +15,14 @@\n  */\n package ghidra.plugin.importer;\n \n+import java.util.*;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n import java.awt.*;\n import java.awt.event.KeyAdapter;\n import java.awt.event.KeyEvent;\n import java.io.IOException;\n-import java.util.*;\n-import java.util.List;\n-import java.util.stream.Collectors;\n \n import javax.swing.*;\n import javax.swing.event.DocumentEvent;\n@@ -529,17 +530,10 @@ private boolean isDuplicateFilename() {\n \n \tprivate boolean isFilenameTooLong() {\n \t\tint maxNameLen = tool.getProject().getProjectData().getMaxNameLength();\n-\t\tString fullPath = getName();\n-\t\tString currentPath = fullPath;\n-\t\twhile (!StringUtils.isBlank(currentPath)) {\n-\t\t\tString filename = FilenameUtils.getName(currentPath);\n-\t\t\tif (filename.isEmpty()) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tif (filename.length() >= maxNameLen) {\n+\t\tfor (String pathPart : getName().split(\"/\")) {\n+\t\t\tif (pathPart.length() >= maxNameLen) {\n \t\t\t\treturn true;\n \t\t\t}\n-\t\t\tcurrentPath = FilenameUtils.getFullPathNoEndSeparator(currentPath);\n \t\t}\n \t\treturn false;\n \t}",
    "output": "Fix infinite loop when importing file with leading tilde in name ."
  },
  {
    "input": "diff --git a/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/service/FidServiceLibraryIngest.java b/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/service/FidServiceLibraryIngest.java\n--- a/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/service/FidServiceLibraryIngest.java\n+++ b/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/service/FidServiceLibraryIngest.java\n@@ -54,12 +54,10 @@ class FidServiceLibraryIngest {\n \n \tprivate LibraryRecord library = null; // Database record of the library we are creating\n \tprivate CompilerSpec compilerSpec = null;\n-\tprivate Map<FunctionRecord, Set<ChildSymbol>> unresolvedSymbols =\n-\t\tnew HashMap<>();\n+\tprivate Map<FunctionRecord, Set<ChildSymbol>> unresolvedSymbols = new HashMap<>();\n \tprivate TreeSet<Long> globalUniqueFunction = new TreeSet<>();\n \tprivate FidPopulateResult result = null;\n-\tprivate TreeMap<String, FidPopulateResult.Count> childHistogram =\n-\t\tnew TreeMap<>(); // Counts of child references to function symbols\n+\tprivate TreeMap<String, FidPopulateResult.Count> childHistogram = new TreeMap<>(); // Counts of child references to function symbols\n \n \tprivate static class FunctionRow {\n \t\tpublic FunctionRecord functionRecord;\n@@ -604,7 +602,8 @@ private boolean checkLanguageCompilerSpec(Program program) {\n \t\t\treturn false;\n \t\t}\n \t\tif (compilerSpec != null) {\n-\t\t\tif (!compilerSpec.equals(program.getCompilerSpec())) {\n+\t\t\tif (!compilerSpec.getCompilerSpecID()\n+\t\t\t\t\t.equals(program.getCompilerSpec().getCompilerSpecID())) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\"Program \" + program.getName() + \" has different compiler spec (\" +\n \t\t\t\t\t\tprogram.getCompilerSpec().getCompilerSpecID() +",
    "output": "Fix for FID ingest bug."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/marker/MarkerManager.java\n@@ -305,7 +305,7 @@ static String getMarkerToolTip(MarkerSetImpl marker, Address a, int x, int y) {\n \n \tList<MarkerSetImpl> copyMarkerSets(Program program) {\n \t\tMarkerSetCacheEntry entry = markerSetCache.get(program);\n-\t\treturn entry == null ? List.of() : entry.copyList();\n+\t\treturn entry == null ? Collections.emptyList() : entry.copyList();\n \t}\n \n \t/**",
    "output": "Upgrade marker set use of empty list to fix an exception"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-Debugging/src/main/java/ghidra/dbg/agent/AgentWindow.java b/Ghidra/Debug/Framework-Debugging/src/main/java/ghidra/dbg/agent/AgentWindow.java\n--- a/Ghidra/Debug/Framework-Debugging/src/main/java/ghidra/dbg/agent/AgentWindow.java\n+++ b/Ghidra/Debug/Framework-Debugging/src/main/java/ghidra/dbg/agent/AgentWindow.java\n@@ -53,7 +53,7 @@ public AgentWindow(String title, SocketAddress localAddress) {\n \t\tsetMinimumSize(new Dimension(400, 300));\n \t\tsetVisible(true);\n \n-\t\tSystem.setProperty(\"log4j.configuration\", \"agent.log4j.xml\");\n+\t\tSystem.setProperty(\"log4j.configurationFile\", \"agent.log4j.xml\");\n \t\tLoggingInitialization.initializeLoggingSystem();\n \t\tLoggerContext ctx = (LoggerContext) LogManager.getContext(false);\n \t\tConfiguration config = ctx.getConfiguration();",
    "output": "Fix for config error"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/menu/MultiStateDockingAction.java b/Ghidra/Framework/Docking/src/main/java/docking/menu/MultiStateDockingAction.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/menu/MultiStateDockingAction.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/menu/MultiStateDockingAction.java\n@@ -360,7 +360,7 @@ private class ActionStateToggleAction extends ToggleDockingAction {\n \t\tprivate final ActionState<T> actionState;\n \n \t\tprivate ActionStateToggleAction(ActionState<T> actionState, boolean isSelected) {\n-\t\t\tsuper(actionState.getName(), \"multiStateAction\");\n+\t\t\tsuper(actionState.getName(), \"MultiStateAction\");\n \n \t\t\tthis.actionState = actionState;\n \n@@ -371,6 +371,11 @@ private ActionStateToggleAction(ActionState<T> actionState, boolean isSelected)\n \t\t\tif (helpLocation != null) {\n \t\t\t\tsetHelpLocation(helpLocation);\n \t\t\t}\n+\t\t\telse {\n+\t\t\t\tHelpLocation parentHelp =\n+\t\t\t\t\tHelp.getHelpService().getHelpLocation(MultiStateDockingAction.this);\n+\t\t\t\tsetHelpLocation(parentHelp);\n+\t\t\t}\n \t\t}\n \n \t\t@Override",
    "output": "Upgrade toggle action to match recent change"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProvider.java\n@@ -576,10 +576,14 @@ private void activatedRemove(DebuggerWatchActionContext context) {\n \t}\n \n \tprivate ProgramLocation getDynamicLocation(ProgramLocation someLoc) {\n+\t\tTraceProgramView view = current.getView();\n+\t\tif (view == null) {\n+\t\t\treturn null;\n+\t\t}\n \t\tif (someLoc.getProgram() instanceof TraceProgramView) {\n \t\t\treturn someLoc;\n \t\t}\n-\t\treturn mappingService.getDynamicLocationFromStatic(current.getView(), someLoc);\n+\t\treturn mappingService.getDynamicLocationFromStatic(view, someLoc);\n \t}\n \n \tprivate AddressSetView getDynamicAddresses(Program program, AddressSetView set) {",
    "output": "Fix NPE in Watches when there is no current trace."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java\n@@ -577,7 +577,7 @@ public String getWorkerName() {\n \t\tInteger originalPriority = activeTask.taskPriority;\n \t\tactiveTask.taskPriority = limitPriority;\n \t\ttry {\n-\t\t\tyield(limitPriority, monitor);\n+\t\t\tthis.yield(limitPriority, monitor);\n \t\t}\n \t\tfinally {\n \t\t\tactiveTask.taskPriority = originalPriority;\n@@ -652,7 +652,7 @@ public void startAnalysis(TaskMonitor monitor, boolean printTaskTimes) {\n \t\t\t//    Thinking was that if some analysis causes disassembly to occur,\n \t\t\t//    then that disassembly and it's analysis will keep other analysis out of trouble.\n \t\t\t//    However for single threaded, this might not be worthwhile in the long run.\n-\t\t\tyield(activeTask.taskPriority, monitor);\n+\t\t\tthis.yield(activeTask.taskPriority, monitor);\n \t\t}\n \t\telse if (analysisThread != null || !isEnabled) {\n \t\t\t// this could be a sub-thread of a task, don't yield, or flush domain objects",
    "output": "Fix yield keyword conflict when compiling with JDK 17 compliance."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingPanel.java\n@@ -833,6 +833,7 @@ public void setBackgroundColorModel(ListingBackgroundColorModel colorModel) {\n \t\t\tlayeredColorModel = null;\n \t\t}\n \t\telse {\n+\t\t\tcolorModel.modelDataChanged(this);\n \t\t\tlayeredColorModel = new LayeredColorModel(colorModel, propertyBasedColorModel);\n \t\t\tfieldPanel.setBackgroundColorModel(layeredColorModel);\n \t\t}\n@@ -1126,6 +1127,7 @@ public void selectionChanged(FieldSelection selection, EventTrigger trigger) {\n \t/**\n \t * Returns the currently selected text. The value will only be non-null for selections within a\n \t * single field.\n+\t * \n \t * @return the selected text or null\n \t */\n \tpublic String getTextSelection() {",
    "output": "Fix timing issue with setting program in listing background."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/MenuResourceDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/MenuResourceDataType.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/MenuResourceDataType.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/MenuResourceDataType.java\n@@ -155,7 +155,7 @@ private int addMenuItemTemplate(MemBuffer memBuffer, List<DataTypeComponent> com\n \t\t\tint tempOffset, short mtOption) {\n \n \t\t//If it is a popup there is only an option field, no ID field\n-\t\tif (mtOption == MF_POPUP) {\n+\t\tif ((mtOption & MF_POPUP) == MF_POPUP) {\n \t\t\ttempOffset =\n \t\t\t\taddComp(WordDataType.dataType, 2, \"mtOption\", memBuffer.getAddress(), comps,\n \t\t\t\t\ttempOffset);",
    "output": "Fix parsing of popup menu item names in PE menu resources"
  },
  {
    "input": "diff --git a/Ghidra/Features/MicrosoftDmang/src/test/java/mdemangler/MDMangBaseTest.java b/Ghidra/Features/MicrosoftDmang/src/test/java/mdemangler/MDMangBaseTest.java\n--- a/Ghidra/Features/MicrosoftDmang/src/test/java/mdemangler/MDMangBaseTest.java\n+++ b/Ghidra/Features/MicrosoftDmang/src/test/java/mdemangler/MDMangBaseTest.java\n@@ -16,6 +16,7 @@\n package mdemangler;\n \n import java.io.*;\n+import java.util.Date;\n \n import org.junit.*;\n import org.junit.experimental.categories.Category;\n@@ -104,6 +105,8 @@ public class MDMangBaseTest extends AbstractGenericTest {\n \n \tprotected boolean quiet = false;\n \n+\tprivate static long startTime = 0;\n+\n \tprotected boolean beQuiet() {\n \t\treturn quiet || BATCH_MODE;\n \t\t//return quiet;\n@@ -139,6 +142,11 @@ public void setUp() throws Exception {\n \t\t}\n \t}\n \n+\t@BeforeClass\n+\tpublic static void startUp() {\n+\t\tstartTime = (new Date()).getTime();\n+\t}\n+\n \t@AfterClass\n \tpublic static void tearDown() throws Throwable {\n \t\tif (testWriter == null) {\n@@ -147,6 +155,9 @@ public static void tearDown() throws Throwable {\n \t\ttestWriter.close();\n \t\tMsg.info(MDMangBaseTest.class,\n \t\t\t\"Short test demangled results: \" + testFile.getAbsolutePath());\n+\t\tlong endTime = (new Date()).getTime();\n+\t\tMsg.info(MDMangBaseTest.class,\n+\t\t\t\"MDMangBaseTest time: \" + (endTime - startTime) / 1000.0 + \" sec.\");\n \t}\n \n \t@Rule",
    "output": "Add timer to MDMangBaseTest"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/GFileImpl.java b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/GFileImpl.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/GFileImpl.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/GFileImpl.java\n@@ -76,6 +76,12 @@ public static GFileImpl fromPathString(GFileSystem fileSystem, String path, FSRL\n \tpublic static GFileImpl fromPathString(GFileSystem fileSystem, GFile parent, String path,\n \t\t\tFSRL fsrl, boolean isDirectory, long length) {\n \t\tString[] split = path.split(FSUtilities.SEPARATOR);\n+\t\tif (split.length >= 3 && split[0].isEmpty() && split[1].isEmpty() && !split[2].isEmpty()) {\n+\t\t\t// The path was in UNC format, either //unc or \\\\unc.\n+\t\t\t// Put a unc prefix \"//\" back into the element that has the unc name.  The leading empty\n+\t\t\t// elements will be skipped when building the parentage.\n+\t\t\tsplit[2] = \"//\" + split[2];\n+\t\t}\n \t\tfor (int i = 0; i < split.length - 1; ++i) {\n \t\t\tif (split[i].length() == 0) {\n \t\t\t\tcontinue;",
    "output": "Fix UNC pathname handling (github )"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/service/breakpoint/DebuggerLogicalBreakpointServiceTest.java b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/service/breakpoint/DebuggerLogicalBreakpointServiceTest.java\n--- a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/service/breakpoint/DebuggerLogicalBreakpointServiceTest.java\n+++ b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/service/breakpoint/DebuggerLogicalBreakpointServiceTest.java\n@@ -571,7 +571,9 @@ public void testRecordTraceThenAddBreakpointThenOpenTrace() throws Throwable {\n \t\ttraceManager.openTrace(trace);\n \t\twaitForSwing();\n \n-\t\tassertLogicalBreakpointForLoneAccessBreakpoint(trace);\n+\t\twaitForPass(() -> {\n+\t\t\tassertLogicalBreakpointForLoneAccessBreakpoint(trace);\n+\t\t});\n \t}\n \n \t@Test",
    "output": "Fix timing issue in LogicalBreakpoint test."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleManifestFile.java b/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleManifestFile.java\n--- a/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleManifestFile.java\n+++ b/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleManifestFile.java\n@@ -96,15 +96,8 @@ else if (trimmedLine.startsWith(DEPENDENCY_IDENTIFIER)) {\n \t\t}\n \t\telse if (trimmedLine.startsWith(EXCLUDE_FROM_GHIDRA_JAR)) {\n \t\t\tString[] tokens = trimmedLine.split(\":\");\n-\n-            if (tokens.length == 2) {\n-                if (tokens[1].toLowerCase().trim().compareTo(\"false\") == 0)\n-                    excludeFromGhidraJar = false;\n-                else\n-                    excludeFromGhidraJar = true;\n-            }\n-            else\n-                excludeFromGhidraJar = true; // Default to not be included in build\n+\t\t\tString value = tokens.length == 2 ? tokens[1].trim() : \"\";\n+\t\t\texcludeFromGhidraJar = Boolean.valueOf(value);\n \t\t}\n \t\telse if (trimmedLine.startsWith(MODULE_FILE_LICENSE)) {\n \t\t\tprocessModuleFileLicense(trimmedLine);",
    "output": "Upgrade case and default setting Updated case and default setting to be false"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleManifestFile.java b/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleManifestFile.java\n--- a/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleManifestFile.java\n+++ b/Ghidra/Framework/Utility/src/main/java/utility/module/ModuleManifestFile.java\n@@ -95,7 +95,16 @@ else if (trimmedLine.startsWith(DEPENDENCY_IDENTIFIER)) {\n \t\t\t// ignore for now\n \t\t}\n \t\telse if (trimmedLine.startsWith(EXCLUDE_FROM_GHIDRA_JAR)) {\n-\t\t\texcludeFromGhidraJar = true;\n+\t\t\tString[] tokens = trimmedLine.split(\":\");\n+\n+            if (tokens.length == 2) {\n+                if (tokens[1].toLowerCase().trim().compareTo(\"false\") == 0)\n+                    excludeFromGhidraJar = false;\n+                else\n+                    excludeFromGhidraJar = true;\n+            }\n+            else\n+                excludeFromGhidraJar = true; // Default to not be included in build\n \t\t}\n \t\telse if (trimmedLine.startsWith(MODULE_FILE_LICENSE)) {\n \t\t\tprocessModuleFileLicense(trimmedLine);",
    "output": "Upgrade ModuleManifestFile.java The value associated with \"EXCLUDE FROM GHIDRA JAR\" module configuration has no effect when building the JAR file, for example, \"EXCLUDE FROM GHIDRA JAR: false\" will have no effect and the module will still be excluded since the current code checks only if the line starts with \"EXCLUDE FROM GHIDRA JAR\" but does not examine the assigned value. I updated the code to enable the effect of the true/false values."
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbApplicator.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbApplicator.java\n--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbApplicator.java\n+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbApplicator.java\n@@ -739,7 +739,8 @@ private void processItemTypesSequentially() throws CancelledException, PdbExcept\n \t\tint num = ipi.getTypeIndexMaxExclusive() - ipi.getTypeIndexMin();\n \t\tmonitor.initialize(num);\n \t\tsetMonitorMessage(\"PDB: Processing \" + num + \" item type components...\");\n-\t\tfor (int indexNumber = ipi.getTypeIndexMin(); indexNumber < num; indexNumber++) {\n+\t\tfor (int indexNumber =\n+\t\t\tipi.getTypeIndexMin(); indexNumber < ipi.getTypeIndexMaxExclusive(); indexNumber++) {\n \t\t\tmonitor.checkCanceled();\n \t\t\tMsTypeApplier applier = getTypeApplier(RecordNumber.itemRecordNumber(indexNumber));\n \t\t\tapplier.apply();",
    "output": "Fix bug in PDB item iteration bounds."
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/ExtendedFlatProgramAPI.java b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/ExtendedFlatProgramAPI.java\n--- a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/ExtendedFlatProgramAPI.java\n+++ b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/ExtendedFlatProgramAPI.java\n@@ -1333,7 +1333,7 @@ public String getNewShortenedTemplateName(RecoveredClass recoveredClass, int com\n \t\t\tcommaIndex--;\n \t\t}\n \n-\t\tString shortenedName = className.substring(0, nextComma) + \" ...>\";\n+\t\tString shortenedName = className.substring(0, nextComma) + \"...>\";\n \t\treturn shortenedName;\n \t}\n ",
    "output": "Fix space typo in createShortenedTemplateNames causing symbol.setName stack trace."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/PcodeEmit.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/PcodeEmit.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/PcodeEmit.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/PcodeEmit.java\n@@ -88,8 +88,8 @@ public PcodeEmit(ParserWalker walk, InstructionContext ictx, int fallOffset,\n \t\tAddressSpace myspace = startAddress.getAddressSpace();\n \t\tif (myspace.isOverlaySpace()) {\n \t\t\toverlayspace = myspace;\n-\t\t\tstartAddress = ((OverlayAddressSpace) myspace).getOverlayedSpace().getAddress(\n-\t\t\t\tstartAddress.getOffset());\n+\t\t\tstartAddress = ((OverlayAddressSpace) myspace).getOverlayedSpace()\n+\t\t\t\t\t.getAddress(startAddress.getOffset());\n \t\t}\n \t\tthis.fallOffset = fallOffset;\n \t\tthis.uniqueFactory = uniqueFactory;\n@@ -742,7 +742,7 @@ void checkOverlays(int opcode, VarnodeData[] in, int isize, VarnodeData out) {\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (int i = 0; i < isize; ++i) {\n-\t\t\t\tVarnodeData v = in[0];\n+\t\t\t\tVarnodeData v = in[i];\n \t\t\t\tif (v.space.equals(overlayspace)) {\n \t\t\t\t\tv.space = ((OverlayAddressSpace) v.space).getOverlayedSpace();\n \t\t\t\t}",
    "output": "Fix checkOverlays typo"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java\n@@ -172,7 +172,7 @@ protected void doSetContexts(TraceAddressSnapRange tasr, Language language,\n \t\t\tif (ctxSpace == null) {\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tctxSpace.setValue(language, null, tasr.getLifespan(), tasr.getRange());\n+\t\t\tctxSpace.removeValue(language, contextReg, tasr.getLifespan(), tasr.getRange());\n \t\t\treturn;\n \t\t}\n \t\tDBTraceRegisterContextSpace ctxSpace = ctxMgr.get(space, true);",
    "output": "Fix for NPE"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Method.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Method.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Method.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Method.java\n@@ -38,10 +38,12 @@ public ObjectiveC2_Method(ObjectiveC2_State state, BinaryReader reader,\n \t\tif (isSmallList) {\n \t\t\tint nameOffset = (int)ObjectiveC1_Utilities.readNextIndex(reader, true);\n \t\t\tlong namePtr;\n-\t\t\tif (state.is32bit)\n+\t\t\tif (state.is32bit) {\n \t\t\t\tnamePtr = reader.readInt(_index + nameOffset);\n-\t\t\telse\n+\t\t\t}\n+\t\t\telse {\n \t\t\t\tnamePtr = reader.readLong(_index + nameOffset);\n+\t\t\t}\n \n \t\t\tname = reader.readAsciiString(namePtr);\n ",
    "output": "Fix formatting issues"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/merge/listing/FunctionMerger.java b/Ghidra/Features/Base/src/main/java/ghidra/app/merge/listing/FunctionMerger.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/merge/listing/FunctionMerger.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/merge/listing/FunctionMerger.java\n@@ -1867,7 +1867,7 @@ else if (function2.isExternal()) {\n \t\t\t}\n \t\t\treturn isEquivalent(thunkedFunction1, thunkedFunction2);\n \t\t}\n-\t\telse if (thunkedFunction1 != null) {\n+\t\telse if (thunkedFunction2 != null) {\n \t\t\treturn false;\n \t\t}\n ",
    "output": "Fix function merge to check if thunkedFunction is the 2nd one, instead of the first that has been checked already This can cause the program to act as if thunkedFunction2 is never null whenver thunkedFunction1 is, which is wrong."
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbKind.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbKind.java\n--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbKind.java\n+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbKind.java\n@@ -52,6 +52,7 @@ private static String toCamel(String name) {\n \t\t\t}\n \t\t\tif (makeUpper) {\n \t\t\t\tc = Character.toUpperCase(c);\n+\t\t\t\tmakeUpper = false;\n \t\t\t}\n \t\t\tbuf.append(c);\n \t\t}",
    "output": "Fix toCamel so that only _ are converted to uppercase letters makeUpper being set to perpetually true meant that the entire name was in uppercase letters. This commit fixes that."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/ActionContext.java b/Ghidra/Framework/Docking/src/main/java/docking/ActionContext.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/ActionContext.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/ActionContext.java\n@@ -228,8 +228,10 @@ public ActionContext setSourceObject(Object sourceObject) {\n \t * @return this context\n \t */\n \tpublic ActionContext setMouseEvent(MouseEvent e) {\n-\t\tthis.mouseEvent = e;\n-\t\tthis.eventClickModifiers = e.getModifiersEx();\n+\t\tif (e != null) {\n+\t\t\tthis.mouseEvent = e;\n+\t\t\tthis.eventClickModifiers = e.getModifiersEx();\n+\t\t}\n \t\treturn this;\n \t}\n ",
    "output": "Fix stack trace when invoking contextMenu without using mouse"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/breakpoint/LogicalBreakpointInternal.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/breakpoint/LogicalBreakpointInternal.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/breakpoint/LogicalBreakpointInternal.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/breakpoint/LogicalBreakpointInternal.java\n@@ -93,6 +93,9 @@ public ProgramBreakpoint(Program program, Address address, long length,\n \n \t\t@Override\n \t\tpublic String toString() {\n+\t\t\t// volatile reads\n+\t\t\tBookmark eBookmark = this.eBookmark;\n+\t\t\tBookmark dBookmark = this.dBookmark;\n \t\t\tif (eBookmark != null) {\n \t\t\t\treturn String.format(\"<enabled %s(%s) at %s in %s>\", eBookmark.getTypeString(),\n \t\t\t\t\teBookmark.getCategory(), eBookmark.getAddress(), program.getName());\n@@ -127,6 +130,9 @@ public boolean isEmpty() {\n \t\t}\n \n \t\tpublic void deleteFromProgram() {\n+\t\t\t// volatile reads\n+\t\t\tBookmark eBookmark = this.eBookmark;\n+\t\t\tBookmark dBookmark = this.dBookmark;\n \t\t\ttry (UndoableTransaction tid =\n \t\t\t\tUndoableTransaction.start(program, \"Clear breakpoint\", false)) {\n \t\t\t\tBookmarkManager bookmarkManager = program.getBookmarkManager();\n@@ -193,6 +199,7 @@ public boolean remove(Bookmark bookmark) {\n \t\t}\n \n \t\tpublic Bookmark getBookmark() {\n+\t\t\tBookmark eBookmark = this.eBookmark;\n \t\t\tif (eBookmark != null) {\n \t\t\t\treturn eBookmark;\n \t\t\t}",
    "output": "Fix a timing issue in ProgramBreakpoint.toString"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/projectdata/actions/VersionControlCheckOutAction.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/projectdata/actions/VersionControlCheckOutAction.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/projectdata/actions/VersionControlCheckOutAction.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/projectdata/actions/VersionControlCheckOutAction.java\n@@ -134,7 +134,7 @@ private boolean gatherVersionedFiles(TaskMonitor monitor, List<DomainFile> resul\n \t\t\tif (n == 0) {\n \t\t\t\tMsg.showError(this, tool.getToolFrame(), \"Checkout Failed\",\n \t\t\t\t\t\"The specified files do not contain any versioned files available for \" +\n-\t\t\t\t\t\t\"checkeout\");\n+\t\t\t\t\t\t\"checkout\");\n \t\t\t\treturn false;\n \t\t\t}\n \n@@ -193,7 +193,7 @@ public void setMessage(String message) {\n \t\t\t\t};\n \n \t\t\t\tList<DomainFile> failedCheckouts = new ArrayList<>();\n-\t\t\t\tint progress = 0;\n+\t\t\t\tint progress = 1;\n \t\t\t\tfor (DomainFile df : versionedFiles) {\n \n \t\t\t\t\tmonitor.checkCanceled();",
    "output": "Fix off-by one display error in which checkout progress displayed to user starts from 0 instead of 1 Since we are displaying the number of the file in relation to the number of files to be checked out, the progress number should start at 1, instead of 0, because otherwise it gives the impression one more file than there actually are are set to be checked out."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunctionDBUtil.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunctionDBUtil.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunctionDBUtil.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunctionDBUtil.java\n@@ -635,18 +635,6 @@ private static Data setGlobalDataType(HighSymbol global, DataType dt)\n \t\t\treturn null;\n \t\t}\n \t\tAddress addr = storage.getFirstVarnode().getAddress();\n-\t\tif (storage.size() != dt.getLength() && program.getMemory().isBigEndian()) {\n-\t\t\t// maintain address of lsb\n-\t\t\tlong delta = storage.size() - dt.getLength();\n-\t\t\ttry {\n-\t\t\t\taddr = addr.addNoWrap(delta);\n-\t\t\t}\n-\t\t\tcatch (AddressOverflowException e) {\n-\t\t\t\tthrow new InvalidInputException(\n-\t\t\t\t\t\"Unable to resize global storage for \" + dt.getName() + \" at \" + addr);\n-\t\t\t}\n-\t\t}\n-\n \t\tListing listing = program.getListing();\n \t\tData d = listing.getDataAt(addr);\n \t\tif (d != null && d.getDataType().isEquivalent(dt)) {",
    "output": "Remove Big Endian address size check Removes a check specific to big endian that incorrectly checks backwards from an address since the pointer is the start of data and not the end (regardless of endianess)."
  },
  {
    "input": "diff --git a/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/ByteViewerPanel.java b/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/ByteViewerPanel.java\n--- a/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/ByteViewerPanel.java\n+++ b/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/ByteViewerPanel.java\n@@ -289,7 +289,6 @@ void setByteBlocks(ByteBlockSet blockSet) {\n \t\t}\n \t\tif (blocks != null && blocks.length > 0) {\n \t\t\tcolumnHeader.setColumnName(indexPanel, blocks[0].getIndexName());\n-\t\t\tsetCursorLocation(blocks[0], BigInteger.ZERO, 0);\n \t\t}\n \t\tindexPanel.dataChanged(BigInteger.ZERO, indexMap.getNumIndexes());\n \t\tindexSetChanged();",
    "output": "Fix to prevent scrolling issue in DebuggerMemoryBytes."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/help/GHelpBroker.java b/Ghidra/Framework/Docking/src/main/java/docking/help/GHelpBroker.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/help/GHelpBroker.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/help/GHelpBroker.java\n@@ -496,15 +496,18 @@ private void doCalloutReference(final Rectangle area, int callCount) {\n \t\tRectangle relativeArea = SwingUtilities.convertRectangle(scrollPane, area, contentPane);\n \t\tShape star = new StarShape(relativeArea.getLocation());\n \n-\t\tlastAnimator =\n+\t\tAnimator animator =\n \t\t\tAnimationUtils.createPaintingAnimator(helpWindow, new LocationHintPainter(star));\n-\t\tlastAnimator.addTarget(new TimingTargetAdapter() {\n+\t\tif (animator == null) {\n+\t\t\treturn;\n+\t\t}\n \n+\t\tlastAnimator = animator;\n+\t\tlastAnimator.addTarget(new TimingTargetAdapter() {\n \t\t\t@Override\n \t\t\tpublic void end() {\n \t\t\t\tlastAnimator = null;\n \t\t\t}\n-\n \t\t});\n \t}\n ",
    "output": "Fix Help Viewer exception when animation is disabled"
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/ApplyFunctions.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/ApplyFunctions.java\n--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/ApplyFunctions.java\n+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/ApplyFunctions.java\n@@ -112,7 +112,7 @@ private static Function checkInsideThunkFunction(Program program, Address addres\n \t\t\treturn null;\n \t\t}\n \t\tAddressSet thunkBody = new AddressSet(thunkFunction.getBody());\n-\t\tboolean hasRangeMatch = true;\n+\t\tboolean hasRangeMatch = false;\n \t\tAddressRangeIterator ari = thunkBody.getAddressRanges(true);\n \t\twhile (ari.hasNext()) {\n \t\t\tif (monitor.isCancelled()) {",
    "output": "Fix typo causing \"hasRangeMatch\" to always be true It should be set to false initially until a match is found. Because of this error, checkInsideThunkFunction will always think there is a range match, which could cause disastrous results."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Graph/src/main/java/ghidra/service/graph/GraphDisplayOptionsBuilder.java b/Ghidra/Framework/Graph/src/main/java/ghidra/service/graph/GraphDisplayOptionsBuilder.java\n--- a/Ghidra/Framework/Graph/src/main/java/ghidra/service/graph/GraphDisplayOptionsBuilder.java\n+++ b/Ghidra/Framework/Graph/src/main/java/ghidra/service/graph/GraphDisplayOptionsBuilder.java\n@@ -177,7 +177,7 @@ public GraphDisplayOptionsBuilder arrowLength(int length) {\n \t * @return this GraphDisplayOptionsBuilder\n \t */\n \tpublic GraphDisplayOptionsBuilder maxNodeCount(int maxNodeCount) {\n-\t\tdisplayOptions.getMaxNodeCount();\n+\t\tdisplayOptions.setMaxNodeCount(maxNodeCount);\n \t\treturn this;\n \t}\n ",
    "output": "Fix mistake in GraphDisplayOptionsBuilder that prevented users from setting the max node count"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n@@ -663,9 +663,6 @@ public void writeGhidraExtensionsDir() throws IOException {\n \t\t}\n \n \t\tpublic void writeExtensionPointClassFile() throws IOException {\n-\t\t\tString s = \"abc\";\n-\t\t\ts.getBytes();\n-\n \t\t\tZipEntry entry = new ZipEntry(ROOT_GHIDRA + \"EXTENSION_POINT_CLASSES\");\n \n \t\t\ttry {",
    "output": "Remove unused stray String Considering this is not a test method, there is no reason why String s = \"abc\" should be here, considering it is not even used. This was likely added by mistake."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/objects/components/ObjectTreeCellRenderer.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/objects/components/ObjectTreeCellRenderer.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/objects/components/ObjectTreeCellRenderer.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/objects/components/ObjectTreeCellRenderer.java\n@@ -15,7 +15,9 @@\n  */\n package ghidra.app.plugin.core.debug.gui.objects.components;\n \n-import java.awt.*;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Font;\n import java.util.Map;\n \n import javax.swing.JTree;\n@@ -27,6 +29,7 @@\n import ghidra.dbg.target.TargetExecutionStateful;\n import ghidra.dbg.target.TargetExecutionStateful.TargetExecutionState;\n import ghidra.dbg.target.TargetObject;\n+import ghidra.util.SystemUtilities;\n \n // TODO: In the new scheme, I'm not sure this is applicable anymore.\n class ObjectTreeCellRenderer extends GTreeRenderer {\n@@ -101,7 +104,7 @@ public Component getTreeCellRendererComponent(JTree t, Object value, boolean sel\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcomponent.setFont(container.isSubscribed() ? defaultFont : unsubscribedFont);\n+\t\t\tcomponent.setFont(SystemUtilities.adjustForFontSizeOverride(container.isSubscribed() ? defaultFont : unsubscribedFont));\n \t\t}\n \t\treturn component;\n \t}",
    "output": "Fix for font resizing"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/tasks/GTreeStartEditingTask.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/tasks/GTreeStartEditingTask.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/tasks/GTreeStartEditingTask.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/tasks/GTreeStartEditingTask.java\n@@ -68,12 +68,6 @@ public long getPriority() {\n \n \tprivate void edit() {\n \n-\t\tif (tree.isFiltered()) {\n-\t\t\tMsg.showWarn(getClass(), tree, \"Cannot Edit Tree Node\",\n-\t\t\t\t\"Can't edit tree node \\\"\" + childName + \"\\\" while tree is filtered.\");\n-\t\t\treturn;\n-\t\t}\n-\n \t\tif (editNode == null) {\n \t\t\teditNode = parent.getChild(childName);\n \t\t\tif (editNode == null) {",
    "output": "Remove restriction that prevented renaming GTree nodes while the tree was filtered"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/prototype/analysis/AggressiveInstructionFinderAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/prototype/analysis/AggressiveInstructionFinderAnalyzer.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/prototype/analysis/AggressiveInstructionFinderAnalyzer.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/prototype/analysis/AggressiveInstructionFinderAnalyzer.java\n@@ -55,7 +55,7 @@ public class AggressiveInstructionFinderAnalyzer extends AbstractAnalyzer {\n \n \tprivate static final String OPTION_NAME_CREATE_BOOKMARKS = \"Create Analysis Bookmarks\";\n \tprivate static final String OPTION_DESCRIPTION_CREATE_BOOKMARKS =\n-\t\t\"If checked, an alaysis bookmark will be created at the start of each disassembly \" +\n+\t\t\"If checked, an analysis bookmark will be created at the start of each disassembly \" +\n \t\t\t\"location where a run of instructions are identified by this analyzer.\";\n \tprivate static final boolean OPTION_DEFAULT_CREATE_BOOKMARKS_ENABLED = true;\n \n@@ -382,7 +382,7 @@ public boolean process(PseudoInstruction instr) {\n \t\t\t\t\t\tset = set.subtract(cmd.getDisassembledAddressSet());\n \t\t\t\t\t\tif (createBookmarksEnabled) {\n \t\t\t\t\t\t\tBookmarkEditCmd bcmd = new BookmarkEditCmd(entry, BookmarkType.ANALYSIS,\n-\t\t\t\t\t\t\t\t\"Aggressive Intruction Finder\", \"Found code\");\n+\t\t\t\t\t\t\t\t\"Aggressive Instruction Finder\", \"Found code\");\n \t\t\t\t\t\t\tbcmd.applyTo(program);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;",
    "output": "Fix typos in Aggressive Instruction Finder strings These strings display to the user, so they should be fixed."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/DisplayableEol.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/DisplayableEol.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/DisplayableEol.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/DisplayableEol.java\n@@ -163,7 +163,7 @@ private String[] getReferencePreviews(Program program, Reference[] refs) {\n \t\t\treturn getPreviewForNoReferences();\n \t\t}\n \n-\t\tSet<String> set = new HashSet<>();\n+\t\tSet<String> set = new LinkedHashSet<>();\n \t\tfor (Reference reference : refs) {\n \n \t\t\tif (reachedMaximumResults(set.size())) {\n@@ -513,8 +513,8 @@ private boolean isGoodAddress(Program program, Address addr) {\n \t */\n \tprivate RefRepeatComment[] getRepeatableComments(Listing listing, Reference[] memRefs,\n \t\t\tboolean showAll) {\n-\t\tSet<RefRepeatComment> set = new HashSet<>();\n \n+\t\tSet<RefRepeatComment> set = new LinkedHashSet<>();\n \t\tfor (int i = 0; i < memRefs.length && totalCommentsFound < maxDisplayLines; ++i) {\n \t\t\tif (!showAll && !memRefs[i].isPrimary()) {\n \t\t\t\tcontinue;",
    "output": "Fix ordering of automatic comments in the Listing"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/DataTypesProvider.java\n@@ -340,6 +340,15 @@ public ActionContext getActionContext(MouseEvent event) {\n \t\t\tclickedNode = archiveGTree.getNodeForLocation(point.x, point.y);\n \t\t\tisToolbarAction = false;\n \t\t}\n+\t\telse {\n+\t\t\t// Called via a keybinding; use the selected node in the tree to represent the clicked\n+\t\t\t// node.  This allows users to use a keybinding to show the context menu and have all\n+\t\t\t// actions installed.\n+\t\t\tTreePath path = archiveGTree.getSelectionPath();\n+\t\t\tif (path != null) {\n+\t\t\t\tclickedNode = (GTreeNode) path.getLastPathComponent();\n+\t\t\t}\n+\t\t}\n \n \t\treturn new DataTypesActionContext(this, plugin.getProgram(), archiveGTree, clickedNode,\n \t\t\tisToolbarAction);",
    "output": "Upgrade the Data Types context menu to include all actions when showing the menu from the keyboard via Shift-F10."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/java/agent/dbgeng/manager/impl/DbgManagerImpl.java b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/java/agent/dbgeng/manager/impl/DbgManagerImpl.java\n--- a/Ghidra/Debug/Debugger-agent-dbgeng/src/main/java/agent/dbgeng/manager/impl/DbgManagerImpl.java\n+++ b/Ghidra/Debug/Debugger-agent-dbgeng/src/main/java/agent/dbgeng/manager/impl/DbgManagerImpl.java\n@@ -606,7 +606,7 @@ private void defaultHandlers() {\n \t\thandlerMap.putVoid(DbgBreakpointDeletedEvent.class, this::processBreakpointDeleted);\n \n \t\tstatusMap.put(DbgBreakpointEvent.class, DebugStatus.BREAK);\n-\t\tstatusMap.put(DbgExceptionEvent.class, DebugStatus.BREAK);\n+\t\tstatusMap.put(DbgExceptionEvent.class, DebugStatus.NO_CHANGE);\n \t\tstatusMap.put(DbgProcessCreatedEvent.class, DebugStatus.BREAK);\n \t\tstatusMap.put(DbgStateChangedEvent.class, DebugStatus.NO_CHANGE);\n \t\tstatusMap.put(DbgStoppedEvent.class, DebugStatus.BREAK);",
    "output": "Fix for exceptions"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/time/DebuggerTimeProviderTest.java b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/time/DebuggerTimeProviderTest.java\n--- a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/time/DebuggerTimeProviderTest.java\n+++ b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/time/DebuggerTimeProviderTest.java\n@@ -50,7 +50,7 @@ protected void addSnapshots() {\n \t\t\tfirst.setRealTime(c.getTimeInMillis());\n \t\t\tTraceSnapshot second = timeManager.getSnapshot(10, true);\n \t\t\tsecond.setDescription(\"Snap 10\");\n-\t\t\tsecond.setSchedule(TraceSchedule.parse(\"0:5,t1-5\"));\n+\t\t\tsecond.setSchedule(TraceSchedule.parse(\"0:5;t1-5\"));\n \t\t}\n \t}\n \n@@ -81,7 +81,7 @@ protected void assertProviderPopulated() {\n \t\tSnapshotRow secondRow = snapsDisplayed.get(1);\n \t\tassertEquals(10, secondRow.getSnap());\n \t\tassertEquals(\"Snap 10\", secondRow.getDescription());\n-\t\tassertEquals(\"0:5,t1-5\", secondRow.getSchedule());\n+\t\tassertEquals(\"0:5;t1-5\", secondRow.getSchedule());\n \t\t// Timestamp is left unchecked, since default is current time\n \t}\n ",
    "output": "Fix DebuggerTimeProviderTest since changing , to ; in schedules."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DataTypeArchiveGTree.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DataTypeArchiveGTree.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DataTypeArchiveGTree.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/DataTypeArchiveGTree.java\n@@ -115,7 +115,9 @@ private void reclaimClosedNodes(GTreeNode node, TaskMonitor monitor) {\n \n \t\tList<GTreeNode> children = node.getChildren();\n \t\tfor (GTreeNode child : children) {\n-\t\t\treclaimClosedNodes(child, monitor);\n+\t\t\tif (child instanceof CategoryNode) {\n+\t\t\t\treclaimClosedNodes(child, monitor);\n+\t\t\t}\n \t\t}\n \t}\n ",
    "output": "Improve performance of the datatype tree recycling task."
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassUtils.java b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassUtils.java\n--- a/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassUtils.java\n+++ b/Ghidra/Features/Decompiler/ghidra_scripts/classrecovery/RecoveredClassUtils.java\n@@ -3313,6 +3313,24 @@ public void addConstructorsToClassNamespace(RecoveredClass recoveredClass,\n \t\t\t// listing has void too, otherwise, leave it as is, probably a void\n \t\t\tString returnType = getReturnTypeFromDecompiler(constructorFunction);\n \n+\t\t\t// Set error bookmark, add error message, and  get the listing return type if the \n+\t\t\t// decompiler return type is null\n+\t\t\tif (returnType == null) {\n+\n+\t\t\t\tString error = \"Decompiler Error: The decompiler failed to decompile function at \" +\n+\t\t\t\t\tconstructorFunction.getEntryPoint().toString() +\n+\t\t\t\t\t\" possibly due to the addition of \" + className + \" class structure.\";\n+\n+\t\t\t\tMsg.debug(this, error);\n+\n+\t\t\t\tprogram.getBookmarkManager().setBookmark(constructorFunction.getEntryPoint(),\n+\t\t\t\t\tBookmarkType.ERROR, \"Decompiler Error\", error);\n+\n+\t\t\t\t// get the return type from the listing and in some cases it will\n+\t\t\t\t// indicate the correct type to help determine the below type to add\n+\t\t\t\treturnType = constructorFunction.getReturnType().getDisplayName();\n+\t\t\t}\n+\n \t\t\tif (returnType.equals(\"void\")) {\n \t\t\t\tDataType voidDataType = new VoidDataType();\n \t\t\t\tconstructorFunction.setReturnType(voidDataType, SourceType.ANALYSIS);",
    "output": "Add check for error decompiling function and put bad bookmarks if it happens."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledFunction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledFunction.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledFunction.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/demangler/DemangledFunction.java\n@@ -382,7 +382,12 @@ public boolean applyTo(Program program, Address address, DemanglerOptions option\n \t\t// Account for register context.  This class may trigger disassembly, so we need to make\n \t\t// sure that the context is correctly set before that happens.  Also, be sure to apply\n \t\t// the function to the correct address.\n-\t\taddress = PseudoDisassembler.setTargeContextForDisassembly(program, address);\n+\n+\t\t//TODO revisit this in terms of external block addresses. Also shoul this check\n+\t\t// be moved into the PsuedoDisassembler???\n+\t\tif (!address.isExternalAddress()) {\n+\t\t\taddress = PseudoDisassembler.setTargeContextForDisassembly(program, address);\n+\t\t}\n \n \t\tif (!passesPreconditions(program, address)) {\n \t\t\treturn true; // eventually will not return anything ",
    "output": "Add temp fix to protect against fiddling with external addresses"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/emulation/ProgramEmulationUtils.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/emulation/ProgramEmulationUtils.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/emulation/ProgramEmulationUtils.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/emulation/ProgramEmulationUtils.java\n@@ -152,10 +152,10 @@ public static void loadExecutable(TraceSnapshot snapshot, Program program) {\n \t\t\t\tString modName = getModuleName(program);\n \n \t\t\t\t// TODO: Do I populate modules, since the mapping will already be done?\n+\t\t\t\tString path = \"Modules[\" + modName + \"].Sections[\" + block.getName() + \"-\" +\n+\t\t\t\t\tblock.getStart() + \"]\";\n \t\t\t\ttrace.getMemoryManager()\n-\t\t\t\t\t\t.createRegion(\n-\t\t\t\t\t\t\t\"Modules[\" + modName + \"].Sections[\" + block.getName() + \"]\",\n-\t\t\t\t\t\t\tsnapshot.getKey(), range, getRegionFlags(block));\n+\t\t\t\t\t\t.createRegion(path, snapshot.getKey(), range, getRegionFlags(block));\n \t\t\t}\n \t\t\tDebuggerStaticMappingUtils.addMapping(\n \t\t\t\tnew DefaultTraceLocation(trace, null, Range.atLeast(snapshot.getKey()), min),",
    "output": "Fix issue launching emulator with duplicate block names"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/DebuggerConnectDialog.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/DebuggerConnectDialog.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/DebuggerConnectDialog.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/DebuggerConnectDialog.java\n@@ -171,25 +171,29 @@ public void setModelService(DebuggerModelService modelService) {\n \t\t}\n \t}\n \n+\t@Override\n \tpublic void dispose() {\n \t\tmodelService.removeFactoriesChangedListener(listener);\n \t\tclearFactories();\n+\t\tsuper.dispose();\n \t}\n \n \tprotected void populateComponents() {\n \t\tJPanel panel = new JPanel(new BorderLayout());\n-\n \t\tpanel.setBorder(new EmptyBorder(10, 10, 10, 10));\n \n \t\tBox topBox = Box.createVerticalBox();\n-\t\tpanel.add(topBox, BorderLayout.NORTH);\n-\n \t\tdropdown = new JComboBox<>(dropdownModel);\n \t\ttopBox.add(dropdown);\n \n+\t\t// Avoid Swing's automatic indentation\n+\t\tJPanel inner = new JPanel(new BorderLayout());\n \t\tdescription = new JLabel(HTML_BOLD_DESCRIPTION + \"</html>\");\n \t\tdescription.setBorder(new EmptyBorder(10, 0, 10, 0));\n-\t\ttopBox.add(description);\n+\t\tinner.add(description);\n+\t\ttopBox.add(inner);\n+\n+\t\tpanel.add(topBox, BorderLayout.NORTH);\n \n \t\tlayout = new PairLayout(5, 5);\n \t\tpairPanel = new JPanel(layout);",
    "output": "Fix alignment of 'Description' in Debugger Connect dialog."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/DataDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/DataDB.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/DataDB.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/code/DataDB.java\n@@ -150,6 +150,11 @@ private void computeLength() {\n \t\t\t}\n \t\t}\n \n+\t\t// no need to do all that follow on checking when length == 1\n+\t\tif (length == 1) {\n+\t\t\treturn;\n+\t\t}\n+\n \t\t// FIXME Trying to get Data to display for External.\n \t\tif (address.isExternalAddress()) { // FIXME\n \t\t\treturn; // FIXME",
    "output": "Add small improvement"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldCacheSlideInfo3.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldCacheSlideInfo3.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldCacheSlideInfo3.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldCacheSlideInfo3.java\n@@ -97,6 +97,11 @@ public void fixPageChains(Program program, DyldCacheHeader dyldCacheHeader,\n \n \t\tList<DyldCacheMappingAndSlideInfo> mappingInfos =\n \t\t\tdyldCacheHeader.getCacheMappingAndSlideInfos();\n+\t\t\n+\t\tif (mappingInfos.size() <= DATA_PAGE_MAP_ENTRY) {\n+\t\t\treturn;\n+\t\t}\n+\t\t\n \t\tDyldCacheMappingAndSlideInfo dyldCacheMappingInfo = mappingInfos.get(DATA_PAGE_MAP_ENTRY); // default\n \t\tfor (DyldCacheMappingAndSlideInfo cacheSlideInfo : mappingInfos) {\n \t\t\tif (cacheSlideInfo.getSlideInfoFileOffset() == getSlideInfoOffset()) {",
    "output": "Fix IndexOutOfBoundsException in some DYLDs"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoPrelinkProgramBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoPrelinkProgramBuilder.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoPrelinkProgramBuilder.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoPrelinkProgramBuilder.java\n@@ -550,7 +550,7 @@ private class PrelinkMachoInfo {\n \t\t */\n \t\tpublic PrelinkMachoInfo(ByteProvider provider, long offset, Address headerAddr,\n \t\t\t\tPrelinkMap prelink) throws Exception {\n-\t\t\tthis(provider, offset, headerAddr, (String) null);\n+\t\t\tthis(provider, offset, headerAddr, \"\");\n \n \t\t\tif (prelink != null) {\n \t\t\t\tString path = prelink.getPrelinkBundlePath();",
    "output": "Fix NullPointerException when loading older kernelcaches"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/AbstractDecompilerAction.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/AbstractDecompilerAction.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/AbstractDecompilerAction.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/AbstractDecompilerAction.java\n@@ -31,6 +31,7 @@\n import ghidra.program.model.symbol.Symbol;\n import ghidra.program.model.symbol.SymbolTable;\n import ghidra.program.util.ProgramLocation;\n+import ghidra.util.UndefinedFunction;\n import ghidra.util.data.DataTypeParser.AllowedDataTypes;\n \n /**\n@@ -216,7 +217,7 @@ protected Symbol getSymbol(DecompilerActionContext context) {\n \n \t\t// prefer the decompiler's function reference over the program location's address\n \t\tFunction function = getFunction(context);\n-\t\tif (function != null) {\n+\t\tif (function != null && !(function instanceof UndefinedFunction)) {\n \t\t\treturn function.getSymbol();\n \t\t}\n ",
    "output": "Fix stack trace when clicking a location mapped to an UndefinedFunction"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RetypeFieldAction.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RetypeFieldAction.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RetypeFieldAction.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RetypeFieldAction.java\n@@ -102,7 +102,7 @@ protected void decompilerActionPerformed(DecompilerActionContext context) {\n \t\t}\n \n \t\tDataType dataType = chooseDataType(tool, program, originalDataType);\n-\t\tif (dataType == null) {\n+\t\tif (dataType == null || dataType.isEquivalent(originalDataType)) {\n \t\t\treturn; // cancelled\n \t\t}\n ",
    "output": "Fix bug that caused field to get renamed when not choosing a new type"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf4/next/NamespacePath.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf4/next/NamespacePath.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf4/next/NamespacePath.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/dwarf4/next/NamespacePath.java\n@@ -59,12 +59,9 @@ public static NamespacePath create(NamespacePath parent, String name, SymbolType\n \t}\n \n \tprivate static final String FWDSLASH_MANGLE = \"-fwdslash-\";\n-\tprivate static final String COLON_MANGLE = \"-\";\n \n \tprivate static String preMangleName(String name) {\n-\t\treturn name == null ? null\n-\t\t\t\t: name.replaceAll(\":\", COLON_MANGLE).replaceAll(\" \", \"\").replaceAll(\"/\",\n-\t\t\t\t\tFWDSLASH_MANGLE);\n+\t\treturn name == null ? null : name.replaceAll(\" \", \"\").replaceAll(\"/\", FWDSLASH_MANGLE);\n \t}\n \n \tprivate final NamespacePath parent;",
    "output": "Remove DWARF COLON_MANGLE"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SpecExtensionPanel.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SpecExtensionPanel.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SpecExtensionPanel.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SpecExtensionPanel.java\n@@ -323,7 +323,7 @@ private void populateElementTable() {\n \t\t\t\tif (injectLibrary.isOverride(fixupName, InjectPayload.CALLOTHERFIXUP_TYPE)) {\n \t\t\t\t\tstatus = Status.EXTENSION_OVERRIDE;\n \t\t\t\t}\n-\t\t\t\tif (injectLibrary.getPayload(InjectPayload.CALLFIXUP_TYPE, fixupName)\n+\t\t\t\tif (injectLibrary.getPayload(InjectPayload.CALLOTHERFIXUP_TYPE, fixupName)\n \t\t\t\t\t\t.isErrorPlaceholder()) {\n \t\t\t\t\tstatus = Status.EXTENSION_ERROR;\n \t\t\t\t}",
    "output": "Fix NPE in SpecExtensionPanel"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SpecExtensionPanel.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SpecExtensionPanel.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SpecExtensionPanel.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/SpecExtensionPanel.java\n@@ -323,7 +323,7 @@ private void populateElementTable() {\n \t\t\t\tif (injectLibrary.isOverride(fixupName, InjectPayload.CALLOTHERFIXUP_TYPE)) {\n \t\t\t\t\tstatus = Status.EXTENSION_OVERRIDE;\n \t\t\t\t}\n-\t\t\t\tif (injectLibrary.getPayload(InjectPayload.CALLFIXUP_TYPE, fixupName)\n+\t\t\t\tif (injectLibrary.getPayload(InjectPayload.CALLOTHERFIXUP_TYPE, fixupName)\n \t\t\t\t\t\t.isErrorPlaceholder()) {\n \t\t\t\t\tstatus = Status.EXTENSION_ERROR;\n \t\t\t\t}",
    "output": "Fix NPE in SpecExtensionPanel"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StringRenderParser.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StringRenderParser.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StringRenderParser.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StringRenderParser.java\n@@ -68,7 +68,7 @@ private State(boolean isFinal) { // Implies this accepts any\n \t\tprivate State(boolean isFinal, String accepts) {\n \t\t\tthis(isFinal, accepts.chars()\n \t\t\t\t\t.mapToObj(i -> (char) i)\n-\t\t\t\t\t.collect(Collectors.toCollection(HashSet::new)));\n+\t\t\t\t\t.collect(Collectors.toSet()));\n \t\t}\n \n \t\tprivate State(boolean isFinal, Set<Character> accepts) {",
    "output": "Fix gradle compilation error"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RenameFunctionAction.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RenameFunctionAction.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RenameFunctionAction.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/RenameFunctionAction.java\n@@ -41,7 +41,7 @@ public RenameFunctionAction() {\n \t\tsetPopupMenuData(new MenuData(new String[] { \"Rename Function\" }, \"Decompile\"));\n \t}\n \n-\tprivate Function getFunction(DecompilerActionContext context) {\n+\tprotected Function getFunction(DecompilerActionContext context) {\n \t\tProgram program = context.getProgram();\n \t\tClangToken tokenAtCursor = context.getTokenAtCursor();\n ",
    "output": "Fix compilation error"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/ProjectAccessPanel.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/ProjectAccessPanel.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/ProjectAccessPanel.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/ProjectAccessPanel.java\n@@ -482,6 +482,7 @@ private void addUsers(List<String> users) {\n \t * Panel for displaying the list of users with repository access.\n \t */\n \tclass KnownUsersPanel extends JPanel {\n+\t\tprivate static final int DEFAULT_USERLIST_ROWS_TO_SHOW = 20;\n \n \t\tprivate JList<String> userList;\n \t\tprivate DefaultListModel<String> listModel;\n@@ -514,6 +515,8 @@ class KnownUsersPanel extends JPanel {\n \t\t\t// Set the minimum dimensions of the scroll pane so we can't collapse it.\n \t\t\tDimension d = userList.getPreferredSize();\n \t\t\td.width = 100;\n+\t\t\td.height =\n+\t\t\t\tMath.min(userList.getFixedCellHeight() * DEFAULT_USERLIST_ROWS_TO_SHOW, d.height);\n \t\t\tsp.setPreferredSize(d);\n \t\t\tsp.setMinimumSize(new Dimension(100, 200));\n ",
    "output": "Fix scroll bars in userlist of shared project"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Category.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Category.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Category.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/objc2/ObjectiveC2_Category.java\n@@ -45,6 +45,8 @@ public ObjectiveC2_Category(ObjectiveC2_State state, BinaryReader reader) throws\n \n \t\treadName(reader);\n \t\treadClass(reader);\n+\t\tif (cls.getISA() == null)\n+\t\t\treturn;\n \t\treadInstanceMethods(reader);\n \t\treadClassMethods(reader);\n \t\treadProtocols(reader);",
    "output": "Fix(objc2): don't attempt to process external categories"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/IsFunctionCustomStorageTableColumn.java b/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/IsFunctionCustomStorageTableColumn.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/IsFunctionCustomStorageTableColumn.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/IsFunctionCustomStorageTableColumn.java\n@@ -20,7 +20,7 @@\n import ghidra.program.model.listing.Function;\n import ghidra.program.model.listing.Program;\n \n-public class IfFunctionCustomStorageTableColumn\n+public class IsFunctionCustomStorageTableColumn\n \t\textends ProgramBasedDynamicTableColumnExtensionPoint<Function, Boolean> {\n \n \t@Override",
    "output": "Fix merge compilation error"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/blobs/CliAbstractSig.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/blobs/CliAbstractSig.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/blobs/CliAbstractSig.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/blobs/CliAbstractSig.java\n@@ -723,7 +723,7 @@ public String getRepresentation(CliStreamMetadata stream) {\n \t\t\t\tmodsRep += mod.toString() + \", \";\n \t\t\t}\n \t\t\tif (customMods.size() > 0) {\n-\t\t\t\tmodsRep.substring(0, modsRep.length() - 2); // Remove last comma+space\n+\t\t\t\tmodsRep = modsRep.substring(0, modsRep.length() - 2); // Remove last comma+space\n \t\t\t}\n \t\t\treturn String.format(\"SzArray %s %s\", modsRep, typeRep);\n \t\t}",
    "output": "Use return value from substringThe substringmethod returns the desired result instead of modifying the current string."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/plugin/importer/ImporterUtilities.java\n@@ -15,10 +15,11 @@\n  */\n package ghidra.plugin.importer;\n \n+import java.util.*;\n+\n import java.awt.Window;\n import java.io.Closeable;\n import java.io.IOException;\n-import java.util.*;\n \n import docking.widgets.OptionDialog;\n import ghidra.app.plugin.core.help.AboutDomainObjectUtils;\n@@ -104,7 +105,9 @@ public static void setProgramProperties(Program program, FSRL fsrl, TaskMonitor\n \t\t\tfsrl = fsService.getFullyQualifiedFSRL(fsrl, monitor);\n \n \t\t\tOptions propertyList = program.getOptions(Program.PROGRAM_INFO);\n-\t\t\tpropertyList.setString(ProgramMappingService.PROGRAM_SOURCE_FSRL, fsrl.toString());\n+\t\t\tif (!propertyList.contains(ProgramMappingService.PROGRAM_SOURCE_FSRL)) {\n+\t\t\t\tpropertyList.setString(ProgramMappingService.PROGRAM_SOURCE_FSRL, fsrl.toString());\n+\t\t\t}\n \t\t\tString md5 = program.getExecutableMD5();\n \t\t\tif ((md5 == null || md5.isEmpty()) && fsrl.getMD5() != null) {\n \t\t\t\tprogram.setExecutableMD5(fsrl.getMD5());",
    "output": "Fix overwrite of FSRL when importing gzf"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbolAux.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbolAux.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbolAux.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbolAux.java\n@@ -143,7 +143,7 @@ public DataType toDataType() throws DuplicateNameException, IOException {\n     \treturn structure;\n     }\n \n-    private static class AuxSym implements StructConverter {\n+\tpublic static class AuxSym implements StructConverter {\n         private int      tagIndex;\n         private short    miscLnSzLinenumber;\n         private short    miscLnSzSize;\n@@ -209,7 +209,7 @@ public DataType toDataType() throws DuplicateNameException, IOException {\n         }\n     }\n \n-    private static class AuxFile implements StructConverter {\n+\tpublic static class AuxFile implements StructConverter {\n         private String name;\n \n         private static AuxFile createAuxFile(FactoryBundledWithBinaryReader reader, int index) throws IOException {\n@@ -240,7 +240,7 @@ public DataType toDataType() throws DuplicateNameException, IOException {\n         }\n     }\n \n-    private static class AuxSection implements StructConverter {\n+\tpublic static class AuxSection implements StructConverter {\n         private int   length;\n         private short numberOfRelocations;\n         private short numberOfLinenumbers;",
    "output": "Fix Pe/Mz loaders when COFF aux debug symbols are present Pe/Mz loaders would error if run under eclipse (or the continuesinterceptor is turned off) when the aux symbols are present because the inner classes were marked as private."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Application.java b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Application.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Application.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Application.java\n@@ -480,7 +480,11 @@ private File getModuleOSFile(String exactFilename, String moduleName)\n \t\t\t\texactFilename);\n \t\t}\n \n-\t\tthrow new OSFileNotFoundException(exactFilename);\n+\t\tif (file == null) {\n+\t\t\tthrow new OSFileNotFoundException(exactFilename);\n+\t\t}\n+\t\t\n+\t\treturn file;\n \t}\n \n \tprivate File findModuleFile(String subdirPath, String exactFilename) {",
    "output": "Fix bug in Application.getModuleOSFile"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProviderTest.java b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProviderTest.java\n--- a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProviderTest.java\n+++ b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/watch/DebuggerWatchesProviderTest.java\n@@ -280,7 +280,7 @@ protected WatchRow prepareTestDeadEdit(String expression) {\n \n \t\tperformAction(watchesProvider.actionAdd);\n \t\tWatchRow row = Unique.assertOne(watchesProvider.watchTableModel.getModelData());\n-\t\trow.setExpression(\"r0\");\n+\t\trow.setExpression(expression);\n \n \t\ttraceManager.openTrace(tb.trace);\n \t\ttraceManager.activateThread(thread);",
    "output": "Fix a mistake in the watch provider tests."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/CoreGTreeNode.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/CoreGTreeNode.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/CoreGTreeNode.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/CoreGTreeNode.java\n@@ -348,6 +348,7 @@ protected void doFireNodeRemoved(GTreeNode removedNode, int index) {\n \t\tGTree tree = getTree();\n \t\tif (tree != null) {\n \t\t\ttree.getModel().fireNodeRemoved((GTreeNode) this, removedNode, index);\n+\t\t\ttree.refilterLater();\n \t\t}\n \t}\n ",
    "output": "Fix bug where removing node from gtree didn't cause the tree to re-filter"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/objects/actions/ImportExportAsAction.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/objects/actions/ImportExportAsAction.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/objects/actions/ImportExportAsAction.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/objects/actions/ImportExportAsAction.java\n@@ -76,11 +76,11 @@ public boolean accept(File file, GhidraFileChooserModel chooserModel) {\n \t\tchooser.setFileSelectionMode(fileMode);\n \n \t\tchooser.setCurrentDirectory(Application.getUserSettingsDirectory());\n-\t\tif (chooser.wasCancelled()) {\n-\t\t\treturn;\n-\t\t}\n \n \t\tFile f = chooser.getSelectedFile();\n+\t\tif (chooser.wasCancelled() || f == null) { // Redundant? Meh, it's cheap.\n+\t\t\treturn;\n+\t\t}\n \t\tdoAction(container, f);\n \t}\n ",
    "output": "Fix NPE in Objects Provider: Import/Export As actions."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/stack/DBTraceStack.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/stack/DBTraceStack.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/stack/DBTraceStack.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/stack/DBTraceStack.java\n@@ -126,6 +126,9 @@ protected void fresh(boolean created) throws IOException {\n \t\telse {\n \t\t\tthread = manager.threadManager.getThread(threadSnap.threadKey);\n \t\t\tframes.clear();\n+\t\t\tif (frameKeys == null) {\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t\tfor (long k : frameKeys) {\n \t\t\t\tframes.add(manager.getFrameByKey(k));\n \t\t\t}",
    "output": "Fix NPE in DBTraceStack"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/database/listing/DBTraceInstructionsView.java\n@@ -139,10 +139,8 @@ protected Instruction doAddInstructions(Range<Long> lifespan, Iterator<Instructi\n \t\t\t\t\t\tlastInstruction = replaceIfNotNull(lastInstruction,\n \t\t\t\t\t\t\tdoAddInstructions(lifespan, delayed.iterator(), true));\n \t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tlastInstruction =\n-\t\t\t\t\t\t\tdoCreateInstruction(lifespan, startAddress, prototype, protoInstr);\n-\t\t\t\t\t}\n+\t\t\t\t\tlastInstruction =\n+\t\t\t\t\t\tdoCreateInstruction(lifespan, startAddress, prototype, protoInstr);\n \t\t\t\t}\n \t\t\t\tif (errorAddress != null && conflictCodeUnit == null &&\n \t\t\t\t\terrorAddress.compareTo(startAddress) <= 0) {",
    "output": "Fix for delay slot"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Graph/src/test/java/ghidra/service/graph/GraphDisplayOptionsTest.java b/Ghidra/Framework/Graph/src/test/java/ghidra/service/graph/GraphDisplayOptionsTest.java\n--- a/Ghidra/Framework/Graph/src/test/java/ghidra/service/graph/GraphDisplayOptionsTest.java\n+++ b/Ghidra/Framework/Graph/src/test/java/ghidra/service/graph/GraphDisplayOptionsTest.java\n@@ -253,8 +253,9 @@ public void testRegisterOptions() {\n \n \t\tOptions miscellaneousOptions = graphDisplayOptions.getOptions(\"Miscellaneous\");\n \t\tleafOptionNames = miscellaneousOptions.getLeafOptionNames();\n-\t\tassertEquals(Arrays.asList(\"Use Icons\", \"Selected Vertex Color\", \"Default Layout Algorithm\",\n-\t\t\t\"Default Vertex Color\", \"Default Vertex Shape\", \"Selected Edge Color\", \"Label Position\",\n+\t\tassertEquals(Arrays.asList(\"Use Icons\", \"Max Graph Size\",\n+\t\t\t\"Selected Vertex Color\", \"Default Layout Algorithm\", \"Default Vertex Color\",\n+\t\t\t\"Default Vertex Shape\", \"Selected Edge Color\", \"Label Position\",\n \t\t\t\"Default Edge Color\", \"Font\", \"Favored Edge Type\"), leafOptionNames);\n \n \t}",
    "output": "Fix junit test failure"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/FileHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/FileHeader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/FileHeader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/FileHeader.java\n@@ -413,7 +413,7 @@ void processImageRuntimeFunctionEntries() throws IOException {\n \n \t\tlong oldIndex = reader.getPointerIndex();\n \n-\t\tint start = irfeHeader.getPointerToRawData();\n+\t\tint start = ntHeader.rvaToPointer(irfeHeader.getVirtualAddress());\n \t\treader.setPointerIndex(start);\n \n \t\tImageRuntimeFunctionEntries entries =",
    "output": "Fix loading of RUNTIME_FUNCTION structures from x64 PEs when using SectionLayout.MEMORY"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/menu/keys/MenuKeyHandler.java b/Ghidra/Framework/Docking/src/main/java/docking/menu/keys/MenuKeyHandler.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/menu/keys/MenuKeyHandler.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/menu/keys/MenuKeyHandler.java\n@@ -169,6 +169,9 @@ protected int moveForward(MenuSelectionManager manager, MenuElement[] path,\n \t\t}\n \n \t\tint itemCount = getItemCount(popup);\n+\t\tif (itemCount == 0) {\n+\t\t\treturn -1;\n+\t\t}\n \n \t\t// handle wrapping around to the top again\n \t\tint updatedOffset = offset >= itemCount ? offset % itemCount : offset;",
    "output": "Fix stack trace when using keyboard shortcuts in a combo box popup menu"
  },
  {
    "input": "diff --git a/Ghidra/Test/IntegrationTest/src/test/java/ghidra/graph/program/DataReferenceGraphTaskTest.java b/Ghidra/Test/IntegrationTest/src/test/java/ghidra/graph/program/DataReferenceGraphTaskTest.java\n--- a/Ghidra/Test/IntegrationTest/src/test/java/ghidra/graph/program/DataReferenceGraphTaskTest.java\n+++ b/Ghidra/Test/IntegrationTest/src/test/java/ghidra/graph/program/DataReferenceGraphTaskTest.java\n@@ -227,7 +227,7 @@ public void testCodeReference() throws GraphException {\n \t\tassertNotNull(v1);\n \t\tassertNotNull(v2);\n \t\tassertNotNull(e1);\n-\t\tassertEquals(\"Initial Instruction\", v1.getVertexType());\n+\t\tassertEquals(\"Instruction\", v1.getVertexType());\n \t}\n \n \t@Test",
    "output": "Fix DataReferenceGraphTaskTest failure"
  },
  {
    "input": "diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/exec/PairedPcodeArithmetic.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/exec/PairedPcodeArithmetic.java\n--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/exec/PairedPcodeArithmetic.java\n+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/exec/PairedPcodeArithmetic.java\n@@ -56,7 +56,7 @@ public Pair<L, R> binaryOp(BinaryOpBehavior op, int sizeout, int sizein1, Pair<L\n \t\t\tint sizein2, Pair<L, R> in2) {\n \t\treturn new ImmutablePair<>(\n \t\t\tleftArith.binaryOp(op, sizeout, sizein1, in1.getLeft(), sizein2, in2.getLeft()),\n-\t\t\trightArith.binaryOp(op, sizeout, sizein1, in2.getRight(), sizein2, in2.getRight()));\n+\t\t\trightArith.binaryOp(op, sizeout, sizein1, in1.getRight(), sizein2, in2.getRight()));\n \t}\n \n \t@Override",
    "output": "Fix a critical typo in PairedPcodeArithmetic."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceCachedWriteBytesPcodeExecutorState.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceCachedWriteBytesPcodeExecutorState.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceCachedWriteBytesPcodeExecutorState.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceCachedWriteBytesPcodeExecutorState.java\n@@ -131,7 +131,8 @@ public static long upper(Range<UnsignedLong> rng) {\n \t\tpublic byte[] read(long offset, int size) {\n \t\t\tif (source != null) {\n \t\t\t\t// TODO: Warn or bail when reading UNKNOWN bytes\n-\t\t\t\t// NOTE: Not going to worry about gaps here:\n+\t\t\t\t// NOTE: Read without regard to gaps\n+\t\t\t\t// NOTE: Cannot write those gaps, though!!!\n \t\t\t\tRangeSet<UnsignedLong> uninitialized =\n \t\t\t\t\tcache.getUninitialized(offset, offset + size);\n \t\t\t\tif (!uninitialized.isEmpty()) {\n@@ -141,7 +142,11 @@ public byte[] read(long offset, int size) {\n \t\t\t\t\tlong upper = upper(toRead);\n \t\t\t\t\tByteBuffer buf = ByteBuffer.allocate((int) (upper - lower + 1));\n \t\t\t\t\tsource.getBytes(snap, space.getAddress(lower), buf);\n-\t\t\t\t\tcache.putData(lower, buf.array());\n+\t\t\t\t\tfor (Range<UnsignedLong> rng : uninitialized.asRanges()) {\n+\t\t\t\t\t\tlong l = lower(rng);\n+\t\t\t\t\t\tlong u = upper(rng);\n+\t\t\t\t\t\tcache.putData(l, buf.array(), (int) (l - lower), (int) (u - l + 1));\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tbyte[] data = new byte[size];",
    "output": "Fix for cache reading issue."
  },
  {
    "input": "diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/exec/BytesPcodeArithmetic.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/exec/BytesPcodeArithmetic.java\n--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/exec/BytesPcodeArithmetic.java\n+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/pcode/exec/BytesPcodeArithmetic.java\n@@ -56,7 +56,7 @@ public byte[] unaryOp(UnaryOpBehavior op, int sizeout, int sizein1, byte[] in1)\n \t@Override\n \tpublic byte[] binaryOp(BinaryOpBehavior op, int sizeout, int sizein1, byte[] in1, int sizein2,\n \t\t\tbyte[] in2) {\n-\t\tif (sizein1 > 8 || sizeout > 8) {\n+\t\tif (sizein1 > 8 || sizein2 > 8 || sizeout > 8) {\n \t\t\tBigInteger in1Val = Utils.bytesToBigInteger(in1, sizein1, isBigEndian, false);\n \t\t\tBigInteger in2Val = Utils.bytesToBigInteger(in2, sizein2, isBigEndian, false);\n \t\t\tBigInteger outVal = op.evaluateBinary(sizeout, sizein1, in1Val, in2Val);",
    "output": "Fix after review suggestion."
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/pcode/exec/trace/TracePcodeEmulatorTest.java b/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/pcode/exec/trace/TracePcodeEmulatorTest.java\n--- a/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/pcode/exec/trace/TracePcodeEmulatorTest.java\n+++ b/Ghidra/Debug/Framework-TraceModeling/src/test/java/ghidra/pcode/exec/trace/TracePcodeEmulatorTest.java\n@@ -646,10 +646,10 @@ public void testMOVAPS() throws Throwable {\n \t\t\t\tList.of(\n \t\t\t\t\t\"RIP = 0x00400000;\",\n \t\t\t\t\t\"RSP = 0x00110000;\",\n-\t\t\t\t\t\"*:8 0x00600000:8 = 0x0123456789abcdef;\",\n-\t\t\t\t\t\"*:8 0x00600008:8 = 0xfedcba9876543210;\"),\n+\t\t\t\t\t\"*:8 0x00600008:8 = 0x0123456789abcdef;\", // LE\n+\t\t\t\t\t\"*:8 0x00600000:8 = 0xfedcba9876543210;\"),\n \t\t\t\tList.of(\n-\t\t\t\t\t\"MOVAPS XMM0, xmmword ptr [0x00600007]\"));\n+\t\t\t\t\t\"MOVAPS XMM0, xmmword ptr [0x00600000]\"));\n \n \t\t\tTracePcodeEmulator emu = new TracePcodeEmulator(tb.trace, 0);\n \t\t\tPcodeThread<byte[]> emuThread = emu.newThread(thread.getPath());",
    "output": "Fix the test assertions, now that it executes."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbolAux.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbolAux.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbolAux.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/debug/DebugCOFFSymbolAux.java\n@@ -143,7 +143,7 @@ public DataType toDataType() throws DuplicateNameException, IOException {\n     \treturn structure;\n     }\n \n-    private static class AuxSym implements StructConverter {\n+\tpublic static class AuxSym implements StructConverter {\n         private int      tagIndex;\n         private short    miscLnSzLinenumber;\n         private short    miscLnSzSize;\n@@ -209,7 +209,7 @@ public DataType toDataType() throws DuplicateNameException, IOException {\n         }\n     }\n \n-    private static class AuxFile implements StructConverter {\n+\tpublic static class AuxFile implements StructConverter {\n         private String name;\n \n         private static AuxFile createAuxFile(FactoryBundledWithBinaryReader reader, int index) throws IOException {\n@@ -240,7 +240,7 @@ public DataType toDataType() throws DuplicateNameException, IOException {\n         }\n     }\n \n-    private static class AuxSection implements StructConverter {\n+\tpublic static class AuxSection implements StructConverter {\n         private int   length;\n         private short numberOfRelocations;\n         private short numberOfLinenumbers;",
    "output": "Fix Pe/Mz loaders when COFF aux debug symbols are present Pe/Mz loaders would error if run under eclipse (or the continuesinterceptor is turned off) when the aux symbols are present because the inner classes were marked as private."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/EnumDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/EnumDataType.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/EnumDataType.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/EnumDataType.java\n@@ -115,7 +115,7 @@ public void add(String valueName, long value) {\n \t\tbitGroups = null;\n \t\tcheckValue(value);\n \t\tif (nameMap.containsKey(valueName)) {\n-\t\t\tthrow new IllegalArgumentException(name + \" already exists in this enum\");\n+\t\t\tthrow new IllegalArgumentException(valueName + \" already exists in this enum\");\n \t\t}\n \t\tnameMap.put(valueName, value);\n \t\tList<String> list = valueMap.get(value);",
    "output": "Fix bad exception message"
  },
  {
    "input": "diff --git a/Ghidra/Features/Python/src/test.slow/java/ghidra/python/PythonScriptTest.java b/Ghidra/Features/Python/src/test.slow/java/ghidra/python/PythonScriptTest.java\n--- a/Ghidra/Features/Python/src/test.slow/java/ghidra/python/PythonScriptTest.java\n+++ b/Ghidra/Features/Python/src/test.slow/java/ghidra/python/PythonScriptTest.java\n@@ -131,6 +131,8 @@ private String runPythonScript(ResourceFile scriptFile, GhidraState state) throw\n \t\tscript.set(state, TaskMonitor.DUMMY, writer);\n \t\tscript.run();\n \n+\t\twaitForSwing();\n+\n \t\tAtomicReference<String> ref = new AtomicReference<>();\n \t\trunSwing(() -> {\n \t\t\tString text = console.getText(0, console.getTextLength());",
    "output": "Fix Python test"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/options/VisualGraphOptions.java b/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/options/VisualGraphOptions.java\n--- a/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/options/VisualGraphOptions.java\n+++ b/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/options/VisualGraphOptions.java\n@@ -108,6 +108,9 @@ public void registerOptions(Options options, HelpLocation help) {\n \t\toptions.registerOption(USE_MOUSE_RELATIVE_ZOOM_KEY, useMouseRelativeZoom(), help,\n \t\t\tUSE_MOUSE_RELATIVE_ZOOM_DESCRIPTION);\n \n+\t\toptions.registerOption(USE_CONDENSED_LAYOUT_KEY, useCondensedLayout(), help,\n+\t\t\tUSE_CONDENSED_LAYOUT_DESCRIPTION);\n+\n \t\toptions.registerOption(VIEW_RESTORE_OPTIONS_KEY, ViewRestoreOption.START_FULLY_ZOOMED_OUT,\n \t\t\thelp, VIEW_RESTORE_OPTIONS_DESCRIPTION);\n ",
    "output": "Fix missing option registration"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/ProjectDataTreePanel.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/ProjectDataTreePanel.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/ProjectDataTreePanel.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/datatree/ProjectDataTreePanel.java\n@@ -47,6 +47,7 @@\n public class ProjectDataTreePanel extends JPanel {\n \n \tprivate static final String EXPANDED_PATHS_SEPARATOR = \":\";\n+\tprivate static final int MAX_PROJECT_SIZE_TO_SEARCH = 1000;\n \n \tprivate DataTree tree;\n \tprivate ProjectData projectData;\n@@ -488,13 +489,14 @@ public void checkOpen(MouseEvent e) {\n \t * @param s node name\n \t */\n \tpublic void findAndSelect(String s) {\n-\t\ttree.expandTree(root);\n-\t\tIterator<GTreeNode> it = root.iterator(true);\n-\t\twhile (it.hasNext()) {\n-\t\t\tGTreeNode node = it.next();\n-\t\t\tif (node.getName().equals(s)) {\n-\t\t\t\ttree.setSelectedNode(node);\n-\t\t\t\treturn;\n+\t\tif (projectData.getFileCount() < MAX_PROJECT_SIZE_TO_SEARCH) {\n+\t\t\ttree.expandTree(root);\n+\t\t\tfor (Iterator<GTreeNode> it = root.iterator(true); it.hasNext();) {\n+\t\t\t\tGTreeNode node = it.next();\n+\t\t\t\tif (node.getName().equals(s)) {\n+\t\t\t\t\ttree.setSelectedNode(node);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}",
    "output": "Fix hang when \"Set External Program\" on large shared project. Fixes ."
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/SetEquateAction.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/SetEquateAction.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/SetEquateAction.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/SetEquateAction.java\n@@ -15,6 +15,7 @@\n  */\n package ghidra.app.plugin.core.decompile.actions;\n \n+import docking.action.KeyBindingData;\n import docking.action.MenuData;\n import ghidra.app.plugin.core.decompile.DecompilePlugin;\n import ghidra.app.plugin.core.decompile.DecompilerActionContext;\n@@ -24,13 +25,15 @@\n import ghidra.program.model.pcode.EquateSymbol;\n import ghidra.program.model.scalar.Scalar;\n import ghidra.util.HelpLocation;\n+import java.awt.event.KeyEvent;\n \n public class SetEquateAction extends ConvertConstantAction {\n \n \tpublic SetEquateAction(DecompilePlugin plugin) {\n \t\tsuper(plugin, \"Set Equate\", EquateSymbol.FORMAT_DEFAULT);\n \t\tsetHelpLocation(new HelpLocation(HelpTopics.DECOMPILER, \"ActionSetEquate\"));\n \t\tsetPopupMenuData(new MenuData(new String[] { \"Set Equate...\" }, \"Decompile\"));\n+\t\tsetKeyBindingData(new KeyBindingData(KeyEvent.VK_E, 0));\n \t}\n \n \t@Override",
    "output": "Add missing keybinding for SetEquateAction"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/symbol/PinnedSymbolTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/symbol/PinnedSymbolTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/symbol/PinnedSymbolTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/program/database/symbol/PinnedSymbolTest.java\n@@ -251,15 +251,6 @@ private void checkProcessorSymbolsInPlace(int expectedSymbols) {\n \t\tassertNotNull(symbolTable.getPrimarySymbol(addr(0x28)));\n \t\tassertNotNull(symbolTable.getPrimarySymbol(addr(0x30)));\n \t\tassertNotNull(symbolTable.getPrimarySymbol(addr(0x38)));\n-\n-\t\tassertEquals(1, symbolTable.getLabelHistory(addr(0)).length);\n-\t\tassertEquals(1, symbolTable.getLabelHistory(addr(8)).length);\n-\t\tassertEquals(1, symbolTable.getLabelHistory(addr(0x10)).length);\n-\t\tassertEquals(1, symbolTable.getLabelHistory(addr(0x18)).length);\n-\t\tassertEquals(1, symbolTable.getLabelHistory(addr(0x20)).length);\n-\t\tassertEquals(1, symbolTable.getLabelHistory(addr(0x28)).length);\n-\t\tassertEquals(1, symbolTable.getLabelHistory(addr(0x30)).length);\n-\t\tassertEquals(1, symbolTable.getLabelHistory(addr(0x38)).length);\n \t}\n \n \t@Before",
    "output": "Fix junit tests related to pinned symbol change"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/pty/linux/LinuxPtyChild.java b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/pty/linux/LinuxPtyChild.java\n--- a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/pty/linux/LinuxPtyChild.java\n+++ b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/pty/linux/LinuxPtyChild.java\n@@ -66,7 +66,9 @@ public PtySession session(String[] args, Map<String, String> env) throws IOExcep\n \tprotected PtySession sessionUsingJavaLeader(String[] args, Map<String, String> env)\n \t\t\tthrows IOException {\n \t\tfinal List<String> argsList = new ArrayList<>();\n-\t\targsList.add(\"java\");\n+\t\tString javaCommand =\n+\t\t\tSystem.getProperty(\"java.home\") + File.separator + \"bin\" + File.separator + \"java\";\n+\t\targsList.add(javaCommand);\n \t\targsList.add(\"-cp\");\n \t\targsList.add(System.getProperty(\"java.class.path\"));\n \t\targsList.add(LinuxPtySessionLeader.class.getCanonicalName());",
    "output": "Fix for random java call"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/model/impl/GdbModelTargetProcessMemory.java b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/model/impl/GdbModelTargetProcessMemory.java\n--- a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/model/impl/GdbModelTargetProcessMemory.java\n+++ b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/model/impl/GdbModelTargetProcessMemory.java\n@@ -65,6 +65,14 @@ public GdbModelTargetProcessMemory(GdbModelTargetInferior inferior) {\n \tprotected void updateUsingMappings(Map<BigInteger, GdbMemoryMapping> byStart) {\n \t\tList<GdbModelTargetMemoryRegion> regions;\n \t\tsynchronized (this) {\n+\t\t\tif (byStart.isEmpty()) {\n+\t\t\t\tAddressSet addressSet = impl.getAddressFactory().getAddressSet();\n+\t\t\t\tBigInteger start = addressSet.getMinAddress().getOffsetAsBigInteger();\n+\t\t\t\tBigInteger end = addressSet.getMaxAddress().getOffsetAsBigInteger();\n+\t\t\t\tGdbMemoryMapping mem = new GdbMemoryMapping(start, end,\n+\t\t\t\t\tend.subtract(start), start.subtract(start), \"default\");\n+\t\t\t\tbyStart.put(start, mem);\n+\t\t\t}\n \t\t\tregions =\n \t\t\t\tbyStart.values().stream().map(this::getTargetRegion).collect(Collectors.toList());\n \t\t}",
    "output": "Fix for missing 'info proc mappings'"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/hover/FunctionSignatureDecompilerHover.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/hover/FunctionSignatureDecompilerHover.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/hover/FunctionSignatureDecompilerHover.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/hover/FunctionSignatureDecompilerHover.java\n@@ -84,6 +84,9 @@ public JComponent getHoverComponent(Program program, ProgramLocation programLoca\n \t\tif (token instanceof ClangFuncNameToken) {\n \n \t\t\tFunction function = DecompilerUtils.getFunction(program, (ClangFuncNameToken) token);\n+\t\t\tif (function == null) {\n+\t\t\t\treturn null; // no function in program; maybe bad address\n+\t\t\t}\n \t\t\tString content = ToolTipUtils.getToolTipText(function, false);\n \t\t\treturn createTooltipComponent(content);\n \t\t}",
    "output": "Fix exception in Decompiler when hovering over function not in memory"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FileActionManager.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FileActionManager.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FileActionManager.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FileActionManager.java\n@@ -384,7 +384,7 @@ private DomainObject[] lockDomainObjects(List<DomainFile> files) {\n \t\t\t\tbuf.append(\n \t\t\t\t\t\"You may exit Ghidra, but the above action(s) will be aborted and all\\n\");\n \t\t\t\tbuf.append(\"changes made by those actions (and all changes made since those\\n\");\n-\t\t\t\tbuf.append(\"actions started),will be lost!  You will still have the option of \\n\");\n+\t\t\t\tbuf.append(\"actions started) will be lost!  You will still have the option of \\n\");\n \t\t\t\tbuf.append(\"saving any changes made before those actions began.\\n \\n\");\n \t\t\t\tbuf.append(\"Do you want to abort the action(s) and exit Ghidra?\");\n ",
    "output": "Fix comma in exit Ghidra while actions are running prompt"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java\n@@ -396,7 +396,7 @@ private int calcContextVarLayout(int start, int sz, int numbits) {\n \t\t\t\treportError(qual.location,\n \t\t\t\t\tString.format(\n \t\t\t\t\t\t\"Size of bitfield %s=(%d,%d) larger than %d bits in context register '%s'\",\n-\t\t\t\t\t\tqual.name, min, (8 * 4), sym.getName()));\n+\t\t\t\t\t\tqual.name, min, max, (8 * 4), sym.getName()));\n \n \t\t\t}\n \t\t\tif (max > maxBits) {",
    "output": "Add missing parameter to format string"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/RecoverClassesFromRTTIScript.java b/Ghidra/Features/Decompiler/ghidra_scripts/RecoverClassesFromRTTIScript.java\n--- a/Ghidra/Features/Decompiler/ghidra_scripts/RecoverClassesFromRTTIScript.java\n+++ b/Ghidra/Features/Decompiler/ghidra_scripts/RecoverClassesFromRTTIScript.java\n@@ -114,7 +114,7 @@ public class RecoverClassesFromRTTIScript extends GhidraScript {\n \t// multiple parents = red vertex\n \t// edge between child and parent is orange if child inherits the parent virtually\n \t// edge between child and parent is lime green if child inherits the parent non-virtually\n-\tprivate static final boolean GRAPH_CLASS_HIERARCHIES = true;\n+\tprivate static final boolean GRAPH_CLASS_HIERARCHIES = false;\n \n \t// show shortened class template names in class structure field names\n \tprivate static final boolean USE_SHORT_TEMPLATE_NAMES_IN_STRUCTURE_FIELDS = true;",
    "output": "Fix RecoverClass test failures caused by leaving graph flag on."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/MacintoshTimeStampDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/MacintoshTimeStampDataType.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/MacintoshTimeStampDataType.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/MacintoshTimeStampDataType.java\n@@ -17,6 +17,7 @@\n \n import java.text.SimpleDateFormat;\n import java.util.Date;\n+import java.util.Locale;\n import java.util.TimeZone;\n \n import ghidra.docking.settings.Settings;\n@@ -35,7 +36,7 @@ public class MacintoshTimeStampDataType extends BuiltIn {\n \t\t\tMacintoshTimeStampDataType.class.getName());\n \t}\n \n-\tprivate final static SimpleDateFormat formatter = new SimpleDateFormat(\"dd-MMM-yyyy HH:mm:ss\");\n+\tprivate final static SimpleDateFormat formatter = new SimpleDateFormat(\"dd-MMM-yyyy HH:mm:ss\", Locale.US);\n \tprivate static Date macStartDate;\n \n \tstatic {",
    "output": "Fix locale issue in MacintoshTimeStampDataType"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraJarApplicationLayout.java b/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraJarApplicationLayout.java\n--- a/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraJarApplicationLayout.java\n+++ b/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraJarApplicationLayout.java\n@@ -15,11 +15,9 @@\n  */\n package ghidra;\n \n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n+import java.io.*;\n import java.net.URL;\n import java.net.URLDecoder;\n-import java.nio.charset.StandardCharsets;\n import java.util.*;\n \n import generic.jar.ResourceFile;\n@@ -93,6 +91,17 @@ protected List<ResourceFile> findExtensionInstallationDirectories() {\n \t * @return A {@link ResourceFile} from the given {@link URL}\n \t */\n \tprivate ResourceFile fromUrl(URL url) {\n-\t\treturn new ResourceFile(URLDecoder.decode(url.toExternalForm(), StandardCharsets.UTF_8));\n+\t\tString urlString = url.toExternalForm();\n+\t\ttry {\n+\t\t\t// Decode the URL to replace things like %20 with real spaces.\n+\t\t\t// Note: can't use URLDecoder.decode(String, Charset) because Utility must be \n+\t\t\t// Java 1.8 compatible.\n+\t\t\turlString = URLDecoder.decode(urlString, \"UTF-8\");\n+\t\t}\n+\t\tcatch (UnsupportedEncodingException e) {\n+\t\t\t// Shouldn't happen, but failed to find UTF-8 encoding.\n+\t\t\t// Proceed without decoding, and hope for the best.\n+\t\t}\n+\t\treturn new ResourceFile(urlString);\n \t}\n }",
    "output": "Make Framework Utility Java 1.8 compatible again"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n@@ -526,11 +526,15 @@ private void createActions() {\n \t\t\t\t.menuPath(ToolConstants.MENU_FILE, \"&Open...\")\n \t\t\t\t.menuGroup(OPEN_GROUP, Integer.toString(subMenuGroupOrder++))\n \t\t\t\t.keyBinding(\"ctrl O\")\n-\t\t\t\t.withContext(ProgramActionContext.class)\n-\t\t\t\t.inWindow(ActionBuilder.When.CONTEXT_MATCHES)\n \t\t\t\t.onAction(c -> open())\n \t\t\t\t.buildAndInstall(tool);\n \n+\t\t//\t\t.withContext(ProgramActionContext.class)\n+\t\t//\t\t.inWindow(ActionBuilder.When.CONTEXT_MATCHES)\n+\t\t// openAction doesn't really use a context, but we want it to be in windows that\n+\t\t// have providers that use programs. \n+\t\topenAction.addToWindowWhen(ProgramActionContext.class);\n+\n \t\tcloseAction = new ActionBuilder(\"Close File\", getName())\n \t\t\t\t.menuPath(ToolConstants.MENU_FILE, \"&Close\")\n \t\t\t\t.menuGroup(OPEN_GROUP, Integer.toString(subMenuGroupOrder++))",
    "output": "Fix 'Open Program' action enablement when no programs are open"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/BundleHostTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/BundleHostTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/BundleHostTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/BundleHostTest.java\n@@ -376,7 +376,7 @@ public void testImportFromExtraSystemPackagesWithBadVersionConstraint() throws E\n \t\t\t\"  [null] osgi.wiring.package; (&(osgi.wiring.package=com.google.common.io)\" +\n \t\t\t  \"(version>=\"+(GUAVA_MAJOR_VERSION+1)+\".0.0)\" +\n \t\t\t  \"(!(version>=\"+(GUAVA_MAJOR_VERSION+2)+\".0.0))), \" +\n-\t\t\t  \"from /tmp/ghidra.dev2tmp/sourcebundle000/AClass.java\\n\",\n+\t\t\t  \"from \"+generic.util.Path.toPathString(currentBundle.getFile())+\"/AClass.java\\n\",\n \t\t\t\"1 missing package import:com.google.common.io (version>=\"+(GUAVA_MAJOR_VERSION+1)+\".0.0)\" +\n \t\t\t  \", 1 source file with errors\"\n \t\t);",
    "output": "Fix bad test path"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/console/DebuggerConsoleProvider.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/console/DebuggerConsoleProvider.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/console/DebuggerConsoleProvider.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/console/DebuggerConsoleProvider.java\n@@ -253,7 +253,8 @@ protected void updateRowHeights() {\n \t\tprotected int computePreferredHeight(int r, int c) {\n \t\t\tTableCellRenderer renderer = getCellRenderer(r, c);\n \t\t\tif (renderer instanceof ConsoleActionsCellRenderer) {\n-\t\t\t\tActionList actions = (ActionList) getModel().getValueAt(r, c);\n+\t\t\t\tActionList actions =\n+\t\t\t\t\t(ActionList) getModel().getValueAt(r, convertColumnIndexToModel(c));\n \t\t\t\tif (!actions.isEmpty()) {\n \t\t\t\t\treturn ACTION_BUTTON_SIZE;\n \t\t\t\t}",
    "output": "Fix embarassing table column mistake"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/OSGiUtils.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/OSGiUtils.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/OSGiUtils.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/OSGiUtils.java\n@@ -21,6 +21,7 @@\n import java.nio.file.*;\n import java.util.*;\n import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n@@ -220,9 +221,12 @@ static private boolean hasEvenQuoteCount(String s) {\n \tstatic void collectPackagesFromJar(Path jarPath, Set<String> packages) {\n \t\ttry {\n \t\t\ttry (JarFile jarFile = new JarFile(jarPath.toFile())) {\n+\t\t\t\tManifest manifest = jarFile.getManifest();\n+\n \t\t\t\t// if this jar is an OSGi bundle, use its declared exports\n-\t\t\t\tString exportPackageString =\n-\t\t\t\t\tjarFile.getManifest().getMainAttributes().getValue(Constants.EXPORT_PACKAGE);\n+\t\t\t\tString exportPackageString = manifest != null\n+\t\t\t\t\t\t? manifest.getMainAttributes().getValue(Constants.EXPORT_PACKAGE)\n+\t\t\t\t\t\t: null;\n \t\t\t\tif (exportPackageString != null) {\n \t\t\t\t\tString saved = null;\n \t\t\t\t\t/*",
    "output": "Fix classpath parsing for jars with no manifest"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/PEx64UnwindInfoDataType.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/PEx64UnwindInfoDataType.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/PEx64UnwindInfoDataType.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/PEx64UnwindInfoDataType.java\n@@ -155,7 +155,7 @@ private boolean hasChainedUnwindInfo(int flags) {\n \t}\n \n \tprivate Structure defineUnwindCodeStructure() {\n-\t\tStructureDataType unwindCode = new StructureDataType(\"UnwindCode\", 0);\n+\t\tStructureDataType unwindCode = new StructureDataType(\"UnwindCode\", 0, dataMgr);\n \t\tunwindCode.setPackingEnabled(true);\n \t\ttry {\n \t\t\tunwindCode.add(BYTE, \"OffsetInProlog\", null);",
    "output": "Use correct DatatypeManager when producing structures for PEx64unwindInfoDataType"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesProvider.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesProvider.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesProvider.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/gui/modules/DebuggerModulesProvider.java\n@@ -816,6 +816,9 @@ private boolean isContextNonEmpty(ActionContext ignored) {\n \n \tprivate boolean isContextSectionsOfOneModule(ActionContext ignored) {\n \t\tSet<TraceSection> sel = getSelectedSections(myActionContext);\n+\t\tif (sel == null || sel.isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n \t\treturn sel.stream().map(TraceSection::getModule).distinct().count() == 1;\n \t}\n ",
    "output": "Fix NPE is ModulesProvider"
  },
  {
    "input": "diff --git a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/ios/img4/Img4FileSystem.java b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/ios/img4/Img4FileSystem.java\n--- a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/ios/img4/Img4FileSystem.java\n+++ b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/ios/img4/Img4FileSystem.java\n@@ -20,7 +20,7 @@\n \n import javax.swing.Icon;\n \n-import org.python.bouncycastle.asn1.*;\n+import org.bouncycastle.asn1.*;\n \n import ghidra.app.util.bin.ByteProvider;\n import ghidra.file.crypto.CryptoKey;",
    "output": "Upgrade Img4 file system to use real bouncycastle"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/platform/GdbM68kDebuggerMappingOpinion.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/platform/GdbM68kDebuggerMappingOpinion.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/platform/GdbM68kDebuggerMappingOpinion.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/platform/GdbM68kDebuggerMappingOpinion.java\n@@ -49,7 +49,7 @@ public Set<DebuggerMappingOffer> offersForEnv(TargetEnvironment env, TargetProce\n \t\t\treturn Set.of();\n \t\t}\n \t\tString arch = env.getArchitecture();\n-\t\tif (arch.startsWith(\"mips:32\")) {\n+\t\tif (arch.startsWith(\"m68k\")) {\n \t\t\treturn Set.of(new GdbM68kBELinux32DefOffer(process));\n \t\t}\n \t\treturn Set.of();",
    "output": "Fix for C&P error"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Framework-Debugging/src/test/java/ghidra/dbg/testutil/DebuggerConsole.java b/Ghidra/Debug/Framework-Debugging/src/test/java/ghidra/dbg/testutil/DebuggerConsole.java\n--- a/Ghidra/Debug/Framework-Debugging/src/test/java/ghidra/dbg/testutil/DebuggerConsole.java\n+++ b/Ghidra/Debug/Framework-Debugging/src/test/java/ghidra/dbg/testutil/DebuggerConsole.java\n@@ -56,6 +56,10 @@ public void run() {\n \t\ttry {\n \t\t\twhile (!closed) {\n \t\t\t\tString line = reader.readLine();\n+\t\t\t\tif (line == null) {\n+\t\t\t\t\t// NB. EOF happens immediately under Gradle\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n \t\t\t\tif (interpreter == null) {\n \t\t\t\t\tSystem.err.println(\"Have not found interpreter, yet\");\n \t\t\t\t\tcontinue;",
    "output": "Fix debugger model testing under gradle"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Utility/src/main/java/ghidra/util/SystemUtilities.java b/Ghidra/Framework/Utility/src/main/java/ghidra/util/SystemUtilities.java\n--- a/Ghidra/Framework/Utility/src/main/java/ghidra/util/SystemUtilities.java\n+++ b/Ghidra/Framework/Utility/src/main/java/ghidra/util/SystemUtilities.java\n@@ -83,13 +83,20 @@ private static boolean checkForDevelopmentMode() {\n \t\tClass<?> myClass = SystemUtilities.class;\n \t\tClassLoader loader = myClass.getClassLoader();\n \t\tif (loader == null) {\n-\t\t\t// Loaded with the bootstrap class loader...definitely dev mode.\n-\t\t\t// The Eclipse GhidraDevPlugin does this when it's running from dev mode.\n-\t\t\treturn true;\n+\t\t\t// Can happen when called from the Eclipse GhidraDev plugin \n+\t\t\treturn false;\n \t\t}\n \t\tString name = myClass.getName().replace('.', '/') + \".class\";\n-\t\tURL url = loader.getResource(name);\n-\t\treturn !\"jar\".equals(url.getProtocol());\n+\t\tString protocol = loader.getResource(name).getProtocol();\n+\t\tswitch(protocol) {\n+\t\t\tcase \"file\": // Source repository mode (class files)\n+\t\t\t\treturn true;\n+\t\t\tcase \"jar\": // Release mode (jar files)\n+\t\t\tcase \"bundleresource\": // Eclipse GhidraDev mode\n+\t\t\t\treturn false;\n+\t\t\tdefault: // Unexpected protocol...assume a development mode\n+\t\t\t\treturn true;\n+\t\t}\n \t}\n \n \t/**",
    "output": "Fix a bug that prevented GhidraDev projects from recognizing extensions installed in the user's home Extension directory"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java\n@@ -107,6 +107,9 @@ public Instruction patchProgram(AssemblyResolvedConstructor res, Address at)\n \t@Override\n \tpublic InstructionIterator patchProgram(byte[] insbytes, Address at)\n \t\t\tthrows MemoryAccessException {\n+\t\tif (insbytes.length == 0) {\n+\t\t\treturn listing.getInstructions(new AddressSet(), true);\n+\t\t}\n \t\tAddress end = at.add(insbytes.length - 1);\n \t\tlisting.clearCodeUnits(at, end, false);\n \t\tmemory.setBytes(at, insbytes);",
    "output": "Fix silly SleighAssembler bug"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-gadp/src/test/java/ghidra/dbg/gadp/GadpClientServerTest.java b/Ghidra/Debug/Debugger-gadp/src/test/java/ghidra/dbg/gadp/GadpClientServerTest.java\n--- a/Ghidra/Debug/Debugger-gadp/src/test/java/ghidra/dbg/gadp/GadpClientServerTest.java\n+++ b/Ghidra/Debug/Debugger-gadp/src/test/java/ghidra/dbg/gadp/GadpClientServerTest.java\n@@ -1066,13 +1066,6 @@ protected void populateAvailableAndSync(DebuggerObjectModel client, ServerRunner\n \t\t\tCompletableFuture<?> here = new CompletableFuture<>();\n \t\t\tCompletableFuture<?> init = new CompletableFuture<>();\n \n-\t\t\t@Override\n-\t\t\tpublic void created(TargetObject object) {\n-\t\t\t\tif (\"Available[1]\".equals(object.getJoinedPath(\".\"))) {\n-\t\t\t\t\there.complete(null);\n-\t\t\t\t}\n-\t\t\t}\n-\n \t\t\t@Override\n \t\t\tpublic void attributesChanged(TargetObject object, Collection<String> removed,\n \t\t\t\t\tMap<String, ?> added) {\n@@ -1082,6 +1075,16 @@ public void attributesChanged(TargetObject object, Collection<String> removed,\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void elementsChanged(TargetObject object, Collection<String> removed,\n+\t\t\t\t\tMap<String, ? extends TargetObject> added) {\n+\t\t\t\tfor (TargetObject obj : added.values()) {\n+\t\t\t\t\tif (\"Available[1]\".equals(obj.getJoinedPath(\".\"))) {\n+\t\t\t\t\t\there.complete(null);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \t\t};\n \t\tclient.addModelListener(syncL, true);\n ",
    "output": "Fix GadpClientServerTest again"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/TraceObjectManager.java b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/TraceObjectManager.java\n--- a/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/TraceObjectManager.java\n+++ b/Ghidra/Debug/Debugger/src/main/java/ghidra/app/plugin/core/debug/service/model/TraceObjectManager.java\n@@ -403,19 +403,15 @@ public void removeSection(TargetObject removed) {\n \n \tpublic void addBreakpointContainer(TargetObject added) {\n \t\tTargetObject obj = findThreadOrProcess(added);\n-\t\tif (obj != null) {\n-\t\t\tManagedBreakpointRecorder breakpointRecorder = recorder.breakpointRecorder;\n-\t\t\tif (obj instanceof TargetThread) {\n-\t\t\t\tManagedBreakpointRecorder rec =\n-\t\t\t\t\trecorder.getThreadRecorderForSuccessor(added).getBreakpointRecorder();\n-\t\t\t\trec.offerBreakpointContainer((TargetBreakpointSpecContainer) added);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tbreakpointRecorder.offerBreakpointContainer((TargetBreakpointSpecContainer) added);\n-\t\t}\n-\t\telse {\n-\t\t\tMsg.error(this, \"Error recording breakpoint container \" + added);\n+\t\t// NB. obj can be null\n+\t\tManagedBreakpointRecorder breakpointRecorder = recorder.breakpointRecorder;\n+\t\tif (obj instanceof TargetThread) {\n+\t\t\tManagedBreakpointRecorder rec =\n+\t\t\t\trecorder.getThreadRecorderForSuccessor(added).getBreakpointRecorder();\n+\t\t\trec.offerBreakpointContainer((TargetBreakpointSpecContainer) added);\n+\t\t\treturn;\n \t\t}\n+\t\tbreakpointRecorder.offerBreakpointContainer((TargetBreakpointSpecContainer) added);\n \t}\n \n \tpublic void removeBreakpointContainer(TargetObject removed) {",
    "output": "Fix issue preventing placement of breakpoints with GDB"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/manager/impl/cmd/GdbWriteRegistersCommand.java b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/manager/impl/cmd/GdbWriteRegistersCommand.java\n--- a/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/manager/impl/cmd/GdbWriteRegistersCommand.java\n+++ b/Ghidra/Debug/Debugger-agent-gdb/src/main/java/agent/gdb/manager/impl/cmd/GdbWriteRegistersCommand.java\n@@ -87,10 +87,13 @@ protected String encode(String threadPart, String framePart) {\n \t\t\tb.append(reg.getName());\n \n \t\t\tBigInteger value = ent.getValue();\n-\t\t\tif (value.compareTo(UINT128_MAX) <= 0) {\n+\t\t\t//if the register is 16 or fewer bytes, just use the name\n+\t\t\tif (reg.getSize() <= 16) {\n \t\t\t\tb.append('=');\n \t\t\t\tb.append(value.toString());\n \t\t\t}\n+\t\t\t//if the register is more than 16 bytes use gdb's struct syntax\n+\t\t\t//note: this only works for x64\n \t\t\telse {\n \t\t\t\tb.append(\".v\");\n \t\t\t\tb.append(reg.getSize());",
    "output": "Fix large register writes for x64"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/framework/plugintool/dialog/KeyBindingUtilsTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/framework/plugintool/dialog/KeyBindingUtilsTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/framework/plugintool/dialog/KeyBindingUtilsTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/framework/plugintool/dialog/KeyBindingUtilsTest.java\n@@ -502,7 +502,14 @@ private void setKeyBinding(DockingActionIf action, String keyText, int keyCode)\n \t\tassertEquals(keyText.toUpperCase(), keyField.getText());\n \n \t\trunSwing(() -> panel.apply());\n-\t\tassertEquals(KeyStroke.getKeyStroke(keyCode, 0), action.getKeyBinding());\n+\n+\t\tif (!Objects.equals(KeyStroke.getKeyStroke(keyCode, 0), action.getKeyBinding())) {\n+\n+\t\t\tMsg.debug(this, \"Action did not take keybinding: \" + action.getFullName());\n+\n+\t\t\tassertEquals(\"Key binding was not applied\", KeyStroke.getKeyStroke(keyCode, 0),\n+\t\t\t\taction.getKeyBinding());\n+\t\t}\n \t}\n \n \tprivate void selectRowForAction(DockingActionIf action) throws Exception {",
    "output": "Add test debug"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/FunctionTagTableColumn.java b/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/FunctionTagTableColumn.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/FunctionTagTableColumn.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/util/table/field/FunctionTagTableColumn.java\n@@ -27,7 +27,7 @@\n  * will be displayed as a set of comma-delimited strings, in sorted order.\n  */\n public class FunctionTagTableColumn\n-\t\textends AbstractProgramBasedDynamicTableColumn<Function, String> {\n+\t\textends ProgramBasedDynamicTableColumnExtensionPoint<Function, String> {\n \n \t@Override\n \tpublic String getColumnName() {",
    "output": "Fix Function Tag table column so that it may be used in various tables"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/emulate/Emulate.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/emulate/Emulate.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/emulate/Emulate.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/emulate/Emulate.java\n@@ -475,8 +475,9 @@ private void executeCurrentOp() throws LowlevelError {\n \t\telse if (behave instanceof BinaryOpBehavior) {\n \t\t\tBinaryOpBehavior binaryBehave = (BinaryOpBehavior) behave;\n \t\t\tVarnode in1var = op.getInput(0);\n+\t\t\tVarnode in2var = op.getInput(1);\n \t\t\tVarnode outvar = op.getOutput();\n-\t\t\tif (in1var.getSize() > 8 || outvar.getSize() > 8) {\n+\t\t\tif (in1var.getSize() > 8 || in2var.getSize() > 8 || outvar.getSize() > 8) {\n \t\t\t\tBigInteger in1 = memstate.getBigInteger(op.getInput(0), false);\n \t\t\t\tBigInteger in2 = memstate.getBigInteger(op.getInput(1), false);\n \t\t\t\tBigInteger out = binaryBehave.evaluateBinary(outvar.getSize(),",
    "output": "Fix emulation of binary ops with large 2nd input"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n@@ -275,6 +275,10 @@ private void createExtensionPointSuffixPattern() {\n \t\tsb.append(\".*(\");\n \t\tString between = \"\";\n \t\tfor (String suffix : suffixes) {\n+\t\t\tsuffix = suffix.trim();\n+\t\t\tif (suffix.isEmpty()) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tsb.append(between);\n \t\t\tsb.append(suffix);\n \t\t\tbetween = \"|\";",
    "output": "Fix issue with how GhidraJarBuilder finds extension points"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/ghidra_scripts/PropagateConstantReferences.java b/Ghidra/Features/Base/ghidra_scripts/PropagateConstantReferences.java\n--- a/Ghidra/Features/Base/ghidra_scripts/PropagateConstantReferences.java\n+++ b/Ghidra/Features/Base/ghidra_scripts/PropagateConstantReferences.java\n@@ -36,7 +36,7 @@ public class PropagateConstantReferences extends GhidraScript {\n \tpublic void run() throws Exception {\n \t\tlong numInstructions = currentProgram.getListing().getNumInstructions();\n \t\tmonitor.initialize((int) (numInstructions));\n-\t\tmonitor.setMessage(\"Constant Propogation Markup\");\n+\t\tmonitor.setMessage(\"Constant Propagation Markup\");\n \n \t\t// set up the address set to restrict processing\n \t\tAddressSet restrictedSet =\n\ndiff --git a/Ghidra/Features/Base/ghidra_scripts/PropagateX86ConstantReferences.java b/Ghidra/Features/Base/ghidra_scripts/PropagateX86ConstantReferences.java\n--- a/Ghidra/Features/Base/ghidra_scripts/PropagateX86ConstantReferences.java\n+++ b/Ghidra/Features/Base/ghidra_scripts/PropagateX86ConstantReferences.java\n@@ -57,7 +57,7 @@ public class PropagateX86ConstantReferences extends GhidraScript {\n \tpublic void run() throws Exception {\n \t\tlong numInstructions = currentProgram.getListing().getNumInstructions();\n \t\tmonitor.initialize((int) (numInstructions));\n-\t\tmonitor.setMessage(\"Constant Propogation Markup\");\n+\t\tmonitor.setMessage(\"Constant Propagation Markup\");\n \n \t\t// set up the address set to restrict processing\n \t\tAddressSet restrictedSet = new AddressSet(currentSelection);",
    "output": "Fix monitor messages for constant propagation"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbol.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbol.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbol.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbol.java\n@@ -111,7 +111,6 @@ public class ElfSymbol implements ByteArrayConverter {\n \t * @param reader to read symbol from\n \t * @param symbolIndex index of the symbol to read\n \t * @param symbolTable symbol table to associate the symbol to\n-\t * @param stringTable string table to read symbols from\n \t * @param header else header\n \t * @return newly created ElfSymbol\n \t * ",
    "output": "Fix JavaDoc warning"
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbApplicator.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbApplicator.java\n--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbApplicator.java\n+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/pdb/pdbapplicator/PdbApplicator.java\n@@ -15,9 +15,10 @@\n  */\n package ghidra.app.util.pdb.pdbapplicator;\n \n-import java.math.BigInteger;\n import java.util.*;\n \n+import java.math.BigInteger;\n+\n import ghidra.app.cmd.label.SetLabelPrimaryCmd;\n import ghidra.app.util.NamespaceUtils;\n import ghidra.app.util.SymbolPath;\n@@ -204,7 +205,7 @@ public void applyTo(Program programParam, DataTypeManager dataTypeManagerParam,\n \t\t\t\tthrow new PdbException(\"Invalid Restriction\");\n \t\t}\n \n-\t\tif (program == null) {\n+\t\tif (program != null) {\n \t\t\tOptions options = program.getOptions(Program.PROGRAM_INFO);\n \t\t\toptions.setBoolean(PdbParserConstants.PDB_LOADED, true);\n \t\t}",
    "output": "Fix setting \"PDB Loaded\" flag"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/popup/PopupRegulator.java b/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/popup/PopupRegulator.java\n--- a/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/popup/PopupRegulator.java\n+++ b/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/popup/PopupRegulator.java\n@@ -15,6 +15,7 @@\n  */\n package ghidra.graph.viewer.popup;\n \n+import java.awt.Component;\n import java.awt.Window;\n import java.awt.event.*;\n \n@@ -129,6 +130,13 @@ private void showPopupForMouseEvent(MouseEvent event) {\n \t\t\treturn;\n \t\t}\n \n+\t\tComponent c = event.getComponent();\n+\t\tif (!c.isShowing()) {\n+\t\t\t// This method is called from a a timer.  It is possible that the graph has been \n+\t\t\t// closed by the time this method is called.\n+\t\t\treturn;\n+\t\t}\n+\n \t\tToolTipInfo<?> toolTipInfo = popupSource.getToolTipInfo(event);\n \t\tJComponent toolTipComponent = toolTipInfo.getToolTipComponent();\n \t\tboolean isCustomJavaTooltip = !(toolTipComponent instanceof JToolTip);",
    "output": "Fix graph-related stack trace"
  },
  {
    "input": "diff --git a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java\n--- a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java\n+++ b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java\n@@ -15,9 +15,10 @@\n  */\n package ghidra.file.formats.sevenzip;\n \n-import java.io.*;\n import java.util.*;\n \n+import java.io.*;\n+\n import org.apache.commons.io.FilenameUtils;\n \n import ghidra.formats.gfilesystem.*;\n@@ -261,6 +262,9 @@ private static void extractOperationResultToException(ExtractOperationResult ope\n \t\t\tcase UNKNOWN_OPERATION_RESULT: {\n \t\t\t\tthrow new IOException(\"Unexpected: 7-Zip returned unknown operation result\");\n \t\t\t}\n+\t\t\tcase WRONG_PASSWORD: {\n+\t\t\t\tthrow new IOException(\"7-Zip wrong password\");\n+\t\t\t}\n \t\t\tcase OK:\n \t\t\tdefault: {\n \t\t\t\t// it's all ok!",
    "output": "Fix SevenZipFileSystem to error correctly w/encrypted file"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/BuildVersionCommand.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/BuildVersionCommand.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/BuildVersionCommand.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/commands/BuildVersionCommand.java\n@@ -80,8 +80,10 @@ public DataType toDataType() throws DuplicateNameException, IOException {\n \t\tstruct.add(DWORD, \"minos\", null);\n \t\tstruct.add(DWORD, \"sdk\", null);\n \t\tstruct.add(DWORD, \"ntools\", null);\n-\t\tstruct.add(new ArrayDataType(buildToolVersionDataType, ntools,\n-\t\t\tbuildToolVersionDataType.getLength()), \"build_tool_version[]\", null);\n+\t\tif (ntools > 0) {\n+\t\t\tstruct.add(new ArrayDataType(buildToolVersionDataType, ntools,\n+\t\t\t\tbuildToolVersionDataType.getLength()), \"build_tool_version[]\", null);\n+\t\t}\n \t\tstruct.setCategoryPath(new CategoryPath(MachConstants.DATA_TYPE_CATEGORY));\n \t\treturn struct;\n \t}",
    "output": "Fix an exception that occurred when importing Mach-O files that define zero LC_BUILD_VERSION tool entries"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/MachHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/MachHeader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/MachHeader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/MachHeader.java\n@@ -46,7 +46,7 @@ public class MachHeader implements StructConverter {\n \tprivate long _commandIndex;\n \tprivate FactoryBundledWithBinaryReader _reader;\n \tprivate long _machHeaderStartIndexInProvider;\n-\tprivate long _machHeaderStartIndex;\n+\tprivate long _machHeaderStartIndex = 0;\n \tprivate boolean _parsed = false;\n \n \t/**",
    "output": "Make variable initialization more explicit"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Utility/src/main/java/utility/application/ApplicationUtilities.java b/Ghidra/Framework/Utility/src/main/java/utility/application/ApplicationUtilities.java\n--- a/Ghidra/Framework/Utility/src/main/java/utility/application/ApplicationUtilities.java\n+++ b/Ghidra/Framework/Utility/src/main/java/utility/application/ApplicationUtilities.java\n@@ -60,8 +60,21 @@ private static ResourceFile findPrimaryApplicationRootDir() {\n \t\t\ttry {\n \t\t\t\tResourceFile pathFile = new ResourceFile(new File(pathEntry).getCanonicalPath());\n \t\t\t\twhile (pathFile != null && pathFile.exists()) {\n-\t\t\t\t\tif (new ResourceFile(pathFile, ApplicationProperties.PROPERTY_FILE).exists()) {\n-\t\t\t\t\t\treturn pathFile;\n+\t\t\t\t\tResourceFile applicationPropertiesFile =\n+\t\t\t\t\t\tnew ResourceFile(pathFile, ApplicationProperties.PROPERTY_FILE);\n+\t\t\t\t\tif (applicationPropertiesFile.exists()) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tApplicationProperties applicationProperties =\n+\t\t\t\t\t\t\t\tnew ApplicationProperties(applicationPropertiesFile);\n+\t\t\t\t\t\t\tif (!applicationProperties.getApplicationName().isEmpty()) {\n+\t\t\t\t\t\t\t\treturn pathFile;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcatch (IOException e2) {\n+\t\t\t\t\t\t\tMsg.error(ApplicationUtilities.class,\n+\t\t\t\t\t\t\t\t\"Failed to read: \" + applicationPropertiesFile, e2);\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tpathFile = pathFile.getParentFile();\n \t\t\t\t}",
    "output": "Add a validation step when searching for the application.properties file"
  },
  {
    "input": "diff --git a/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/utils/GhidraScriptUtils.java b/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/utils/GhidraScriptUtils.java\n--- a/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/utils/GhidraScriptUtils.java\n+++ b/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/utils/GhidraScriptUtils.java\n@@ -25,6 +25,7 @@\n \n import ghidra.GhidraApplicationLayout;\n import ghidra.framework.GModule;\n+import ghidradev.Activator;\n \n /**\n  * Utility methods for working with Ghidra scripts in Eclipse.\n@@ -87,6 +88,12 @@ public static IJavaProject createGhidraScriptProject(String projectName, File pr\n \n \t\t// Link in the user's personal ghidra_scripts directory\n \t\tif (linkUserScripts) {\n+\t\t\tif (!userScriptsDir.isDirectory()) {\n+\t\t\t\tif (!userScriptsDir.mkdirs()) {\n+\t\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID,\n+\t\t\t\t\t\tIStatus.ERROR, \"Failed to create \" + userScriptsDir, null));\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tIFolder link = javaProject.getProject().getFolder(\"Home scripts\");\n \t\t\tlink.createLink(new Path(userScriptsDir.getAbsolutePath()), IResource.NONE, monitor);\n \t\t\tclasspathEntries.add(JavaCore.newSourceEntry(link.getFullPath()));",
    "output": "Fix GhidraDev exception when ~/ghidra_scripts doesn't exist"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/field/SymbolAnnotatedStringHandler.java\n@@ -22,7 +22,6 @@\n import docking.widgets.fieldpanel.field.AttributedString;\n import ghidra.app.nav.Navigatable;\n import ghidra.app.services.GoToService;\n-import ghidra.app.services.QueryData;\n import ghidra.app.util.NamespaceUtils;\n import ghidra.framework.plugintool.ServiceProvider;\n import ghidra.program.model.address.Address;\n@@ -142,8 +141,8 @@ public boolean handleMouseClick(String[] annotationParts, Navigatable sourceNavi\n \n \t\t// try going to the symbol first\n \t\tif (!symbols.isEmpty()) {\n-\t\t\tQueryData data = new QueryData(symbols.get(0).getName(), true);\n-\t\t\treturn goToService.goToQuery(sourceNavigatable, null, data, null, null);\n+\t\t\tSymbol s = symbols.get(0);\n+\t\t\treturn goToService.goTo(s.getProgramLocation());\n \t\t}\n \n \t\t// try going to the address",
    "output": "Fix symbol annotation to use the program location of an existing symbol instead of performing a search on that symbol's name"
  },
  {
    "input": "diff --git a/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/utils/GhidraScriptUtils.java b/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/utils/GhidraScriptUtils.java\n--- a/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/utils/GhidraScriptUtils.java\n+++ b/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/utils/GhidraScriptUtils.java\n@@ -25,6 +25,7 @@\n \n import ghidra.GhidraApplicationLayout;\n import ghidra.framework.GModule;\n+import ghidradev.Activator;\n \n /**\n  * Utility methods for working with Ghidra scripts in Eclipse.\n@@ -87,6 +88,12 @@ public static IJavaProject createGhidraScriptProject(String projectName, File pr\n \n \t\t// Link in the user's personal ghidra_scripts directory\n \t\tif (linkUserScripts) {\n+\t\t\tif (!userScriptsDir.isDirectory()) {\n+\t\t\t\tif (!userScriptsDir.mkdirs()) {\n+\t\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID,\n+\t\t\t\t\t\tIStatus.ERROR, \"Failed to create \" + userScriptsDir, null));\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tIFolder link = javaProject.getProject().getFolder(\"Home scripts\");\n \t\t\tlink.createLink(new Path(userScriptsDir.getAbsolutePath()), IResource.NONE, monitor);\n \t\t\tclasspathEntries.add(JavaCore.newSourceEntry(link.getFullPath()));",
    "output": "Fix GhidraDev exception when ~/ghidra_scripts doesn't exist"
  },
  {
    "input": "diff --git a/Ghidra/Processors/x86/src/main/java/ghidra/app/util/bin/format/elf/relocation/X86_64_ElfRelocationHandler.java b/Ghidra/Processors/x86/src/main/java/ghidra/app/util/bin/format/elf/relocation/X86_64_ElfRelocationHandler.java\n--- a/Ghidra/Processors/x86/src/main/java/ghidra/app/util/bin/format/elf/relocation/X86_64_ElfRelocationHandler.java\n+++ b/Ghidra/Processors/x86/src/main/java/ghidra/app/util/bin/format/elf/relocation/X86_64_ElfRelocationHandler.java\n@@ -207,11 +207,8 @@ public void relocate(ElfRelocationContext elfRelocationContext, ElfRelocation re\n \t\t\t\tmemory.setLong(relocationAddress, value);\n \t\t\t\tbreak;\n \t\t\tcase X86_64_ElfRelocationConstants.R_X86_64_IRELATIVE:\n-\t\t\t\t// NOTE: We don't support this since the code actually uses a function to \n-\t\t\t\t// compute the relocation value (i.e., indirect)\n-\t\t\t\tappliedSymbol = false;\n-\t\t\t\tmarkAsError(program, relocationAddress, \"R_X86_64_IRELATIVE\", symbolName,\n-\t\t\t\t\t\"indirect computed relocation not supported\", elfRelocationContext.getLog());\n+\t\t\t\tvalue = addend + elfRelocationContext.getImageBaseWordAdjustmentOffset();\n+\t\t\t\tmemory.setLong(relocationAddress, value);\n \t\t\t\tbreak;\n \n //\t\t\tcase ElfRelocationConstants.R_X86_64_TLSGD:",
    "output": "Add support for ELF relocation R_X86_64_IRELATIVE"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MachoLoader.java\n@@ -98,7 +98,7 @@ public void load(ByteProvider provider, LoadSpec loadSpec, List<Option> options,\n \t\t\tthrow e;\n \t\t}\n \t\tcatch (Exception e) {\n-\t\t\tthrow new IOException(e.getMessage());\n+\t\t\tthrow new IOException(e);\n \t\t}\n \t}\n ",
    "output": "Improve MachoLoader exception reporting"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java\n@@ -29,8 +29,7 @@\n import ghidra.program.model.listing.*;\n import ghidra.program.model.mem.Memory;\n import ghidra.program.model.mem.MemoryAccessException;\n-import ghidra.program.model.symbol.Symbol;\n-import ghidra.program.model.symbol.SymbolIterator;\n+import ghidra.program.model.symbol.*;\n import ghidra.util.task.TaskMonitor;\n \n /**\n@@ -240,6 +239,13 @@ protected Map<String, Long> getProgramLabels() {\n \t\t\tfinal SymbolIterator it = program.getSymbolTable().getAllSymbols(false);\n \t\t\twhile (it.hasNext()) {\n \t\t\t\tSymbol sym = it.next();\n+\t\t\t\tif (sym.isExternal()) {\n+\t\t\t\t\tcontinue; // skip externals - will generally be referenced indirectly not directly\n+\t\t\t\t}\n+\t\t\t\tSymbolType symbolType = sym.getSymbolType();\n+\t\t\t\tif (symbolType != SymbolType.LABEL && symbolType != SymbolType.FUNCTION) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \t\t\t\tlabels.put(sym.getName(), sym.getAddress().getOffset());\n \t\t\t}\n \t\t}",
    "output": "Change assembler to ignore external symbol names"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java b/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/ComponentProvider.java\n@@ -204,13 +204,18 @@ public final long getInstanceID() {\n \t// Default implementation\n \tpublic void requestFocus() {\n \n+\t\tJComponent component = getComponent();\n+\t\tif (component == null) {\n+\t\t\treturn; // this shouldn't happen; this implies we have been disposed\n+\t\t}\n+\n \t\tKeyboardFocusManager kfm = KeyboardFocusManager.getCurrentKeyboardFocusManager();\n \t\tComponent focusOwner = kfm.getFocusOwner();\n-\t\tif (focusOwner != null && SwingUtilities.isDescendingFrom(focusOwner, getComponent())) {\n+\t\tif (focusOwner != null && SwingUtilities.isDescendingFrom(focusOwner, component)) {\n \t\t\treturn;\n \t\t}\n \n-\t\tgetComponent().requestFocus();\n+\t\tcomponent.requestFocus();\n \t}\n \n \t/**",
    "output": "Fix potential timing-based stack trace"
  },
  {
    "input": "diff --git a/Ghidra/Features/BytePatterns/src/main/java/ghidra/bitpatterns/gui/ClosedPatternTableDialog.java b/Ghidra/Features/BytePatterns/src/main/java/ghidra/bitpatterns/gui/ClosedPatternTableDialog.java\n--- a/Ghidra/Features/BytePatterns/src/main/java/ghidra/bitpatterns/gui/ClosedPatternTableDialog.java\n+++ b/Ghidra/Features/BytePatterns/src/main/java/ghidra/bitpatterns/gui/ClosedPatternTableDialog.java\n@@ -124,6 +124,7 @@ public boolean isEnabledForContext(ActionContext context) {\n \n \t@Override\n \tpublic void close() {\n+\t\tsuper.close();\n \t\ttablePanel.dispose();\n \t}\n }\n\ndiff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/ListSelectionTableDialog.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/ListSelectionTableDialog.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/ListSelectionTableDialog.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/ListSelectionTableDialog.java\n@@ -72,6 +72,7 @@ protected void okCallback() {\n \n \t@Override\n \tpublic void close() {\n+\t\tsuper.close();\n \t\tfilterPanel.dispose();\n \t}\n ",
    "output": "Fix bug in recent update that prevents dialogs from closing"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/GraphComponent.java b/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/GraphComponent.java\n--- a/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/GraphComponent.java\n+++ b/Ghidra/Framework/Graph/src/main/java/ghidra/graph/viewer/GraphComponent.java\n@@ -454,7 +454,7 @@ public boolean isShowing() {\n \t\tmainStalePanel.setOpaque(false);\n \n \t\tString tooltip = HTMLUtilities.toWrappedHTML(\"The block model of the function \" +\n-\t\t\t\"for this graph has changed.  Press the relyout button to refresh the layout.\" +\n+\t\t\t\"for this graph has changed.  Press the relayout button to refresh the layout.\" +\n \t\t\t\"\\n\\n\") + \"<b>Note: </b>You can edit the graph \" +\n \t\t\t\"options to have the graph update automatically.\";\n ",
    "output": "Fix 'relyout' typo on stale function graphs"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/tables/CliTableCustomAttribute.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/tables/CliTableCustomAttribute.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/tables/CliTableCustomAttribute.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/tables/CliTableCustomAttribute.java\n@@ -42,9 +42,6 @@ public class CliCustomAttributeRow extends CliAbstractTableRow {\n \t\tpublic int typeIndex;\n \t\tpublic int valueIndex;\n \n-\t\tprivate static final byte CLITABLECUSTOMATTRIBUTE_TYPE_METHODDEF = 0x02;\n-\t\tprivate static final byte CLITABLECUSTOMATTRIBUTE_TYPE_METHODREF = 0x03;\n-\n \t\tpublic CliCustomAttributeRow(int parentIndex, int typeIndex, int valueIndex) {\n \t\t\tsuper();\n \t\t\tthis.parentIndex = parentIndex;",
    "output": "Remove unused constants"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/tables/CliTableCustomAttribute.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/tables/CliTableCustomAttribute.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/tables/CliTableCustomAttribute.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/tables/CliTableCustomAttribute.java\n@@ -28,7 +28,6 @@\n import ghidra.program.model.address.Address;\n import ghidra.program.model.data.CategoryPath;\n import ghidra.program.model.data.StructureDataType;\n-import ghidra.program.model.listing.BookmarkType;\n import ghidra.program.model.listing.Program;\n import ghidra.program.model.util.CodeUnitInsertionException;\n import ghidra.util.exception.DuplicateNameException;\n@@ -114,17 +113,6 @@ public void markup(Program program, boolean isBinary, TaskMonitor monitor, Messa\n \t\t\t\tmetadataStream.getBlobStream().getBlob(customRow.valueIndex),\n \t\t\t\t(CliCustomAttributeRow) row, metadataStream);\n \t\t\tmetadataStream.getBlobStream().updateBlob(blob, addr, program);\n-\n-\t\t\tif (tableType != null) {\n-\t\t\t\tprogram.getBookmarkManager()\n-\t\t\t\t\t\t.setBookmark(addr, BookmarkType.INFO, \"CLI Blob\",\n-\t\t\t\t\t\t\t\"CustomAttrib (\" + tableType.name() + \")\");\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tprogram.getBookmarkManager()\n-\t\t\t\t\t\t.setBookmark(addr, BookmarkType.INFO, \"CLI Blob\",\n-\t\t\t\t\t\t\t\"CustomAttrib (undefined)\");\n-\t\t\t}\n \t\t}\n \t}\n }",
    "output": "Remove the bookmarks for consistency with branch"
  },
  {
    "input": "diff --git a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProviderTest.java b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProviderTest.java\n--- a/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProviderTest.java\n+++ b/Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/listing/DebuggerListingProviderTest.java\n@@ -664,8 +664,11 @@ public void testAutoReadMemoryReads() throws Exception {\n \t\tassertArrayEquals(zero, buf.array());\n \n \t\trunSwing(() -> goToDyn(addr(trace, 0x55551800)));\n-\t\twaitForPass(() -> assertEquals(addr(trace, 0x55551800),\n-\t\t\tlistingProvider.getLocation().getAddress()));\n+\t\twaitForPass(() -> {\n+\t\t\tProgramLocation location = listingProvider.getLocation();\n+\t\t\tassertNotNull(location);\n+\t\t\tassertEquals(addr(trace, 0x55551800), location.getAddress());\n+\t\t});\n \t\twaitForDomainObject(trace);\n \t\tbuf.clear();\n \t\tassertEquals(data.length,",
    "output": "Fix an NPE in tests."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge3Test.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge3Test.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge3Test.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge3Test.java\n@@ -17,7 +17,8 @@\n \n import static org.junit.Assert.*;\n \n-import org.junit.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n import ghidra.program.database.*;\n import ghidra.program.model.data.*;\n@@ -1246,12 +1247,10 @@ public void modifyPrivate(ProgramDB program) {\n \n \t}\n \n-\t@Test\n-\t@Ignore\n+//\tTODO   See GP-585 for design issue preventing this test from passing\n+//\t@Test\n \tpublic void testEditStructureWithReplacementAndRemoval() throws Exception {\n \n-\t\t// See GP-585 for design issue preventing this test from passing\n-\n \t\tmtf.initialize(\"notepad\", new OriginalProgramModifierListener() {\n \n \t\t\t@Override",
    "output": "Fix ignored test"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableWidget.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableWidget.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableWidget.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableWidget.java\n@@ -116,6 +116,10 @@ public void setSortColumn(int column) {\n \t\tmyModel.setTableSortState(TableSortState.createDefaultSortState(column));\n \t}\n \n+\tpublic void setSortColumn(int column, boolean ascending) {\n+\t\tmyModel.setTableSortState(TableSortState.createDefaultSortState(column, ascending));\n+\t}\n+\n \tprotected void processMouseClicked(MouseEvent e) {\n \t\tif (listener == null) {\n \t\t\treturn;\n@@ -160,6 +164,10 @@ public List<T> getSelectedRowObjects() {\n \t\treturn gFilterTable.getSelectedRowObjects();\n \t}\n \n+\tpublic int getSelectedRowCount() {\n+\t\treturn table.getSelectedRowCount();\n+\t}\n+\n \tpublic void addSelectionListener(ObjectSelectedListener<T> l) {\n \t\tgFilterTable.addSelectionListener(l);\n \t}",
    "output": "Add the ability to specify sort column and direction"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSectionHeaderType.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSectionHeaderType.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSectionHeaderType.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSectionHeaderType.java\n@@ -139,10 +139,6 @@ public static void addSectionHeaderType(ElfSectionHeaderType type,\n \tpublic final String description;\n \n \tpublic ElfSectionHeaderType(int value, String name, String description) {\n-\t\tif (value < 0) {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\"ElfProgramHeaderType value out of range: 0x\" + Long.toHexString(value));\n-\t\t}\n \t\tthis.value = value;\n \t\tthis.name = name;\n \t\tthis.description = description;",
    "output": "Remove ELF restriction on definition of 32-bit section header values"
  },
  {
    "input": "diff --git a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/base/widgets/table/DataTypeTableCellEditor.java b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/base/widgets/table/DataTypeTableCellEditor.java\n--- a/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/base/widgets/table/DataTypeTableCellEditor.java\n+++ b/Ghidra/Debug/ProposedUtils/src/main/java/ghidra/base/widgets/table/DataTypeTableCellEditor.java\n@@ -90,19 +90,6 @@ private DataTypeManagerService updateService() {\n \t\treturn service;\n \t}\n \n-\t/**\n-\t * Get the maximum allowed size for the given row and column\n-\t * \n-\t * Defaults to unlimited.\n-\t * \n-\t * @param row the row being edited\n-\t * @param column the column being edited\n-\t * @return the maximum size or -1 for unlimited\n-\t */\n-\tprotected int getMaxLength(int row, int column) {\n-\t\treturn -1;\n-\t}\n-\n \tprotected AllowedDataTypes getAllowed(int row, int column) {\n \t\treturn AllowedDataTypes.ALL;\n \t}\n@@ -134,8 +121,7 @@ public Component getTableCellEditorComponent(JTable newTable, Object value, bool\n \n \tprotected void init(int row, int column) {\n \t\tupdateService();\n-\t\teditor = new DataTypeSelectionEditor(service, getMaxLength(row, column),\n-\t\t\tgetAllowed(row, column));\n+\t\teditor = new DataTypeSelectionEditor(service, getAllowed(row, column));\n \t\teditor.setPreferredDataTypeManager(getPreferredDataTypeManager(row, column));\n \t\teditor.setTabCommitsEdit(true);\n \t\teditor.setConsumeEnterKeyPress(false);",
    "output": "Fix after merge"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/html/FunctionDataTypeHTMLRepresentation.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/html/FunctionDataTypeHTMLRepresentation.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/html/FunctionDataTypeHTMLRepresentation.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/html/FunctionDataTypeHTMLRepresentation.java\n@@ -104,8 +104,8 @@ private List<ValidatableLine> buildArguments(FunctionDefinition functionDefiniti\n \t\t\tString name = var.getName();\n \n \t\t\tDataType locatableType = getLocatableDataType(dataType);\n-\t\t\tlines.add(new VariableTextLine(HTMLUtilities.friendlyEncodeHTML(displayName), name,\n-\t\t\t\tlocatableType));\n+\t\t\tlines.add(new VariableTextLine(HTMLUtilities.friendlyEncodeHTML(displayName),\n+\t\t\t\tHTMLUtilities.friendlyEncodeHTML(name), locatableType));\n \t\t}\n \n \t\treturn lines;\n@@ -114,7 +114,7 @@ private List<ValidatableLine> buildArguments(FunctionDefinition functionDefiniti\n \tprivate static String buildHTMLText(TextLine returnType, TextLine functionName,\n \t\t\tList<ValidatableLine> arguments, TextLine varArgs, TextLine voidArgs) {\n \n-\t\tStringBuffer sb = new StringBuffer();\n+\t\tStringBuilder sb = new StringBuilder();\n \n \t\tString returnTypeText = returnType.getText();\n \t\treturnTypeText = wrapStringInColor(returnTypeText, returnType.getTextColor());",
    "output": "Fix HTML escaping of function definition parameter names."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableStorage.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableStorage.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableStorage.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableStorage.java\n@@ -239,7 +239,7 @@ private void checkVarnodes() throws InvalidInputException {\n \t\t\t}\n \t\t\tif (i < (varnodes.length - 1) && !isRegister) {\n \t\t\t\tthrow new InvalidInputException(\n-\t\t\t\t\t\"Compound storage must use registers accept for last varnode\");\n+\t\t\t\t\t\"Compound storage must use registers except for last varnode\");\n \t\t\t}\n \t\t\tsize += varnode.getSize();\n \t\t}",
    "output": "Fix error message: 'except' replaces 'accept'"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DyldCacheProgramBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DyldCacheProgramBuilder.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DyldCacheProgramBuilder.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/DyldCacheProgramBuilder.java\n@@ -241,8 +241,7 @@ private void fixPageChains() throws MemoryAccessException, CancelledException {\n \t\t// locate slide Info\n \t\tDyldCacheSlideInfoCommon slideInfo = dyldCacheHeader.getSlideInfo();\n \t\tif (slideInfo == null || !(slideInfo instanceof DyldCacheSlideInfo2)) {\n-\t\t\tlog.appendMsg(\n-\t\t\t\t\"Can't handle version \" + slideInfo.getVersion() + \" slide info, only version 2\");\n+\t\t\tlog.appendMsg(\"No compatible slide info version\");\n \t\t\treturn;\n \t\t}\n \t\tDyldCacheSlideInfo2 slideInfo2 = (DyldCacheSlideInfo2) slideInfo;\n@@ -448,7 +447,7 @@ public DyldCacheMachoInfo(ByteProvider provider, long offset, Address headerAddr\n \t\t\t\tString path) throws Exception {\n \t\t\tthis.headerAddr = headerAddr;\n \t\t\tthis.header = MachHeader.createMachHeader(MessageLogContinuesFactory.create(log),\n-\t\t\t\tprovider, offset);\n+\t\t\t\tprovider, offset, false);\n \t\t\tthis.header.parse();\n \t\t\tthis.path = path;\n \t\t\tthis.name = new File(path).getName();",
    "output": "Fix issues with dyld_shared_cache parsing First issue fixed was a simple null deref. The other issue is the dylib's load commands in the dyld_shared_cache should be absolute from zero not relative from the start of the dylib's mach header. When done incorrectly this causes a read past the end of file."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/actions/SharedStubKeyBindingAction.java b/Ghidra/Framework/Docking/src/main/java/docking/actions/SharedStubKeyBindingAction.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/actions/SharedStubKeyBindingAction.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/actions/SharedStubKeyBindingAction.java\n@@ -66,7 +66,7 @@ public class SharedStubKeyBindingAction extends DockingAction implements Options\n \tprivate WeakHashMap<DockingActionIf, KeyStroke> clientActions = new WeakHashMap<>();\n \n \tprivate ToolOptions keyBindingOptions;\n-\tprivate Bag<String> actionOwners = new HashBag<String>();\n+\tprivate Bag<String> actionOwners = new HashBag<>();\n \n \t/**\n \t * Creates a new dummy action by the given name and default keystroke value\n@@ -220,7 +220,7 @@ private KeyStroke getKeyStroke(KeyBindingData data) {\n \tpublic void optionsChanged(ToolOptions options, String optionName, Object oldValue,\n \t\t\tObject newValue) {\n \n-\t\tif (!optionName.startsWith(getName())) {\n+\t\tif (!optionName.equals(getFullName())) {\n \t\t\treturn; // not my binding\n \t\t}\n ",
    "output": "Fix odd error where using a script keybinding could change a component provider's key binding"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test/java/ghidra/framework/options/SaveStateTest.java b/Ghidra/Features/Base/src/test/java/ghidra/framework/options/SaveStateTest.java\n--- a/Ghidra/Features/Base/src/test/java/ghidra/framework/options/SaveStateTest.java\n+++ b/Ghidra/Features/Base/src/test/java/ghidra/framework/options/SaveStateTest.java\n@@ -126,7 +126,7 @@ public void testKeyStroke() throws Exception {\n \n \t@Test\n \tpublic void testFont() throws Exception {\n-\t\tFont font = new Font(\"Times New Roman\", Font.BOLD, 12);\n+\t\tFont font = Font.decode(\"Dialog-BOLD-12\");\n \t\tss.putFont(\"TEST\", font);\n \t\tFont f = ss.getFont(\"TEST\", null);\n \t\tassertEquals(font, f);\n@@ -455,7 +455,7 @@ public void testJsonKeyStrokRoundTrip() {\n \n \t@Test\n \tpublic void testJsonFontRoundTrip() {\n-\t\tFont font = new Font(\"Times New Roman\", Font.BOLD, 12);\n+\t\tFont font = Font.decode(\"Dialog-BOLD-12\");\n \t\tss.putFont(\"foo\", font);\n \t\tSaveState restored = jsonRoundTrip(ss);\n \t\tassertEquals(font, restored.getFont(\"foo\", null));",
    "output": "Fix junit tes"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/ObjectChooserDialog.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/ObjectChooserDialog.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/ObjectChooserDialog.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/ObjectChooserDialog.java\n@@ -93,5 +93,6 @@ public void setFilterText(String text) {\n \t@Override\n \tpublic void close() {\n \t\ttable.dispose();\n+\t\tsuper.close();\n \t}\n }",
    "output": "Fix bug recently introduced when updating the table dispose method"
  },
  {
    "input": "diff --git a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n--- a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n+++ b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n@@ -618,6 +618,9 @@ private SatelliteVisualizationViewer<AttributedVertex, AttributedEdge> createSat\n \t\tsatellite.getRenderContext().setVertexFillPaintFunction(Colors::getColor);\n \t\tsatellite.scaleToLayout();\n \t\tsatellite.getRenderContext().setVertexLabelFunction(n -> null);\n+\t\t// always get the current predicate from the main view and test with it,\n+\t\tsatellite.getRenderContext()\n+\t\t\t\t.setVertexIncludePredicate(v -> viewer.getRenderContext().getVertexIncludePredicate().test(v));\n \t\tsatellite.getComponent().setBorder(BorderFactory.createEtchedBorder());\n \t\tparentViewer.getComponent().addComponentListener(new ComponentAdapter() {\n \t\t\t@Override\n@@ -820,7 +823,7 @@ private void configureFilters() {\n \t\t\tviewer.getRenderContext()\n \t\t\t\t\t.setVertexIncludePredicate(\n \t\t\t\t\t\tv -> v.getAttributeMap().values().stream().noneMatch(selected::contains));\n-\t\t\tviewer.repaint();\n+\n \t\t});\n \n \t\tedgeFilters = AttributeFilters.builder()",
    "output": "Fix 'hidden vertices are not also hidden in satellite view'"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge8Test.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge8Test.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge8Test.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/merge/datatypes/DataTypeMerge8Test.java\n@@ -163,7 +163,7 @@ public void modifyPrivate(ProgramDB program) {\n \t\tString statusText = label.getText();\n \t\tString expectedText =\n \t\t\t\"Structure Merge: Not enough undefined bytes to fit /XYZ in structure \" +\n-\t\t\t\t\"/MISC/ABC at offset 0x4.\\nIt needs 3 more byte(s) to be able to fit.\";\n-\t\tassertTrue(statusText.contains(expectedText));\n+\t\t\t\t\"/MISC/ABC at offset 0x4. It needs 3 more byte(s) to be able to fit.\";\n+\t\tassertTrue(\"Wrong status text: \" + statusText, statusText.contains(expectedText));\n \t}\n }",
    "output": "Fix test failing due to Front End status panel change to turn newline characters to spaces"
  },
  {
    "input": "diff --git a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n--- a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n+++ b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n@@ -429,7 +429,7 @@ private void createPopupActions() {\n \t\t\t\t.popupMenuGroup(\"z\", \"5\")\n \t\t\t\t.keyBinding(\"escape\")\n \t\t\t\t.enabledWhen(c -> hasSelection())\n-\t\t\t\t.onAction(c -> clearSelection())\n+\t\t\t\t.onAction(c -> clearSelection(true))\n \t\t\t\t.buildAndInstallLocal(componentProvider);\n \n \t\tnew ActionBuilder(\"Create Subgraph\", ACTION_OWNER)\n@@ -451,9 +451,9 @@ private void createPopupActions() {\n \n \t}\n \n-\tprivate void clearSelection() {\n-\t\tviewer.getSelectedVertexState().clear();\n-\t\tviewer.getSelectedEdgeState().clear();\n+\tprivate void clearSelection(boolean fireEvents) {\n+\t\tviewer.getSelectedVertexState().clear(fireEvents);\n+\t\tviewer.getSelectedEdgeState().clear(fireEvents);\n \t}\n \n \tprivate boolean hasSelection() {\n@@ -763,6 +763,8 @@ else if (!Arrays.asList(nodeSelectedState.getSelectedObjects()).containsAll(sele\n \t * @param attributedGraph the {@link AttributedGraph} to visualize\n \t */\n \tprivate void doSetGraphData(AttributedGraph attributedGraph) {\n+\t\tclearSelection(false);\n+\t\tfocusedVertex = null;\n \t\tgraph = attributedGraph;\n \n \t\tlayoutTransitionManager.setEdgeComparator(new EdgeComparator(graph, \"EdgeType\",",
    "output": "Fix stack trace when re-using a graph display and the new graph excees the vertex limit"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/symboltree/SymbolTreeNavigationTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/symboltree/SymbolTreeNavigationTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/symboltree/SymbolTreeNavigationTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/symboltree/SymbolTreeNavigationTest.java\n@@ -110,10 +110,11 @@ public void testInsertNode_AfterNavigation_Label_InGlobal_InOrganizationNode() {\n \n \t\tAddress addr = addr(\"0x01004896\");\n \t\tString nameLowInOrgNodes = labelsPrefix + \"3700\";\n-\t\tcreateGlobalLabel(addr, nameLowInOrgNodes);\n+\t\tSymbol firstSymbol = createGlobalLabel(addr, nameLowInOrgNodes);\n \n \t\tutil.collapseTree();\n \t\tgoTo(addr);\n+\t\tassertSelectedNode(firstSymbol);\n \n \t\t// create a name next to the one above so it gets 'insert'ed into the same parent node\n \t\tnameLowInOrgNodes = labelsPrefix + \"37000\";",
    "output": "Fix test failing due to timing issue when tree was not yet expanded"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/LogPanel.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/LogPanel.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/LogPanel.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/LogPanel.java\n@@ -94,7 +94,7 @@ public void messageLogged(String message, boolean isError) {\n \t\t\tif (isError) {\n \t\t\t\tlabel.setForeground(Color.RED);\n \t\t\t}\n-\t\t\tlabel.setText(message);\n+\t\t\tlabel.setText(message.replace(\"\\n\", \" \"));\n \t\t\tlabel.setToolTipText(message);\n \t\t});\n \t}",
    "output": "Upgrade setText to replace newline with space"
  },
  {
    "input": "diff --git a/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/app/plugin/core/clipboard/CopyPasteTestSuite.java b/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/app/plugin/core/clipboard/CopyPasteTestSuite.java\n--- a/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/app/plugin/core/clipboard/CopyPasteTestSuite.java\n+++ b/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/app/plugin/core/clipboard/CopyPasteTestSuite.java\n@@ -19,13 +19,14 @@\n import org.junit.runners.Suite;\n import org.junit.runners.Suite.SuiteClasses;\n \n-import ghidra.app.plugin.core.byteviewer.ByteViewerClipboardProviderTest;\n-\n //@formatter:off\n @RunWith(Suite.class)\n @SuiteClasses({\n \tClipboardPluginTest.class,\n-\tByteViewerClipboardProviderTest.class,\n+\t\n+\t// Uncomment this to run in IDE.  This can also be uncommented if the integration test module\n+\t// is updated to have a dependency on every module's test classes as well as source code.\n+\t//ByteViewerClipboardProviderTest.class,\n \tCodeBrowserClipboardProviderTest.class,\n \tCopyPasteCommentsTest.class, \n \tCopyPasteFunctionInfoTest.class",
    "output": "Upgrade test suite to avoid compiler failure due to 'integration test' not having test compile dependency on the 'byte viewer' module"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProgramDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProgramDB.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProgramDB.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/ProgramDB.java\n@@ -2334,7 +2334,11 @@ protected void close() {\n \t\tintRangePropertyMap.clear();\n \t\taddrSetPropertyMap.clear();\n \t\tfor (ManagerDB manager : managers) {\n-\t\t\tmanager.dispose();\n+\t\t\t// have to check for null in case we are closing after a failed open. This happens during\n+\t\t\t// testing where we first try to open a program and if it fails, we upgrade and re-open.\n+\t\t\tif (manager != null) {\n+\t\t\t\tmanager.dispose();\n+\t\t\t}\n \t\t}\n \t}\n ",
    "output": "Fix bug introduced with recent change for which attemps to clean up internal resources when closing a program."
  },
  {
    "input": "diff --git a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n--- a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n+++ b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n@@ -451,7 +451,7 @@ private void createPopupActions() {\n \t\t\t\t.popupMenuPath(\"Expand Selected Vertices\")\n \t\t\t\t.popupMenuGroup(\"zz\", \"6\")\n \t\t\t\t.description(\"Expands all selected collapsed vertices into their previous form\")\n-\t\t\t\t.onAction(c -> graphCollapser.ungroupSelectedVertices())\n+\t\t\t\t.onAction(c -> ungroupSelectedVertices())\n \t\t\t\t.buildAndInstallLocal(componentProvider);\n \n \t\ttogglePopupsAction = new ToggleActionBuilder(\"Display Popup Windows\", ACTION_OWNER)\n@@ -476,6 +476,19 @@ private void groupSelectedVertices() {\n \t\t}\n \t}\n \n+\t/**\n+\t * Ungroup the selected vertices. If the focusedVertex is no longer\n+\t * in the graph, null it. This will happen if the focusedVertex was\n+\t * the GroupVertex\n+\t */\n+\tprivate void ungroupSelectedVertices() {\n+\t\tgraphCollapser.ungroupSelectedVertices();\n+\t\tif (!graph.containsVertex(focusedVertex)) {\n+\t\t\tfocusedVertex = null;\n+\t\t}\n+\t}\n+\n+\n \tprivate void clearSelection() {\n \t\tviewer.getSelectedVertexState().clear();\n \t\tviewer.getSelectedEdgeState().clear();",
    "output": "Fix case where expansion of GroupVertex sends focusedVertex arrow highlight to the origin"
  },
  {
    "input": "diff --git a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n--- a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n+++ b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n@@ -1119,7 +1119,7 @@ public void ancestorMoved(AncestorEvent ancestorEvent) {\n \t\t}\n \n \t\tgraphMouse = new JgtPluggableGraphMouse(this);\n-\t\tviewer.setGraphMouse(graphMouse);\n+\t\tvv.setGraphMouse(graphMouse);\n \n \t\treturn vv;\n \t}\n@@ -1144,7 +1144,7 @@ private void run(ItemEvent e) {\n \t\t\t// vertices\n \t\t\tif (e.getStateChange() == ItemEvent.SELECTED) {\n \t\t\t\tCollection<AttributedVertex> selectedVertices = getVertices(e.getItem());\n-\t\t\t\tnotifySelectionChanged(new HashSet<AttributedVertex>(selectedVertices));\n+\t\t\t\tnotifySelectionChanged(new HashSet<>(selectedVertices));\n \n \t\t\t\tif (selectedVertices.size() == 1) {\n \t\t\t\t\t// if only one vertex was selected, make it the focused vertex",
    "output": "Fix test failing to recent change"
  },
  {
    "input": "diff --git a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n--- a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n+++ b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplay.java\n@@ -198,9 +198,6 @@ public void componentResized(ComponentEvent e) {\n \t\tviewer.setInitialDimensionFunction(InitialDimensionFunction\n \t\t\t\t.builder(viewer.getRenderContext().getVertexBoundsFunction())\n \t\t\t\t.build());\n-\n-\t\tgraphMouse = new JgtPluggableGraphMouse(this);\n-\n \t\tcreateToolbarActions();\n \t\tcreatePopupActions();\n \t\tconnectSelectionStateListeners();\n@@ -647,7 +644,6 @@ public void setGraphDisplayListener(GraphDisplayListener listener) {\n \t\t\tthis.listener.graphClosed();\n \t\t}\n \t\tthis.listener = listener;\n-\t\tviewer.setGraphMouse(graphMouse);\n \t}\n \n \tprivate void deselectEdge(AttributedEdge edge) {\n@@ -1122,6 +1118,9 @@ public void ancestorMoved(AncestorEvent ancestorEvent) {\n \t\t\tvv.getComponent().removeMouseListener(mouseListener);\n \t\t}\n \n+\t\tgraphMouse = new JgtPluggableGraphMouse(this);\n+\t\tviewer.setGraphMouse(graphMouse);\n+\n \t\treturn vv;\n \t}\n ",
    "output": "Fix issue with graph mouse controls not working if no listener is set."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Graph/src/test.slow/java/ghidra/graph/viewer/AbstractVisualGraphTest.java b/Ghidra/Framework/Graph/src/test.slow/java/ghidra/graph/viewer/AbstractVisualGraphTest.java\n--- a/Ghidra/Framework/Graph/src/test.slow/java/ghidra/graph/viewer/AbstractVisualGraphTest.java\n+++ b/Ghidra/Framework/Graph/src/test.slow/java/ghidra/graph/viewer/AbstractVisualGraphTest.java\n@@ -77,7 +77,7 @@ protected void buildAndLayoutGraph() throws CancelledException {\n \n \t\tTestLayoutProvider layoutProvider = createLayoutProvider();\n \t\tgraph.setLayout(layoutProvider.getLayout(graph, TaskMonitor.DUMMY));\n-\t\tgraphComponent = createGraphComponent(layoutProvider);\n+\t\tgraphComponent = runSwing(() -> createGraphComponent(layoutProvider));\n \t}\n \n \tprotected TestLayoutProvider createLayoutProvider() {",
    "output": "Fix potential test painting bug"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTable.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTable.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTable.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTable.java\n@@ -491,6 +491,10 @@ private int calculatePreferredRowHeight() {\n \t\t\treturn userDefinedRowHeight; // prefer user-defined settings\n \t\t}\n \n+\t\tif (getColumnCount() == 0) {\n+\t\t\treturn userDefinedRowHeight; // no columns yet defined\n+\t\t}\n+\n \t\tTableCellRenderer defaultRenderer = getDefaultRenderer(String.class);\n \t\ttry {\n \t\t\tComponent component =",
    "output": "Fix exception in byte viewer during table construction"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/nodes/SymbolTreeRootNode.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/nodes/SymbolTreeRootNode.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/nodes/SymbolTreeRootNode.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/nodes/SymbolTreeRootNode.java\n@@ -130,7 +130,10 @@ private GTreeNode findVariableSymbolNode(SymbolNode key, boolean loadChildren,\n \t\tSymbol functionSymbol = searchSymbol.getParentSymbol();\n \t\tSymbolNode parentKey = SymbolNode.createNode(functionSymbol, program);\n \t\tGTreeNode functionNode = findFunctionSymbolNode(parentKey, loadChildren, monitor);\n-\t\treturn ((SymbolTreeNode) functionNode).findSymbolTreeNode(key, loadChildren, monitor);\n+\t\tif (functionNode != null) {\n+\t\t\treturn ((SymbolTreeNode) functionNode).findSymbolTreeNode(key, loadChildren, monitor);\n+\t\t}\n+\t\treturn null;\n \t}\n \n \tprivate GTreeNode findFunctionSymbolNode(SymbolNode key, boolean loadChildren,",
    "output": "Fix potential NPE"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/streams/CliStreamUserStrings.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/streams/CliStreamUserStrings.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/streams/CliStreamUserStrings.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/cli/streams/CliStreamUserStrings.java\n@@ -64,7 +64,8 @@ public CliStreamUserStrings(CliStreamHeader header, long fileOffset, int rva,\n \t */\n \tpublic String getUserString(int index) {\n \t\tbyte[] bytes = blobMap.get(index).getContents();\n-\t\treturn new String(bytes, 0, bytes.length - 1, StandardCharsets.UTF_16);\n+\t\t// Must explicitly specify UTF_16LE or the string gets mangled\n+\t\treturn new String(bytes, 0, bytes.length - 1, StandardCharsets.UTF_16LE);\n \t}\n \n \t@Override\n@@ -78,8 +79,7 @@ public DataType toDataType() throws DuplicateNameException, IOException {\n \t\t\tif (blob.getContentsSize() > 0) {\n \t\t\t\tif (blob.getContentsSize() - 1 > 0) {\n \t\t\t\t\tstruct.add(UTF16, blob.getContentsSize() - 1,\n-\t\t\t\t\t\t\"[\" + Integer.toHexString(index) + \"]\",\n-\t\t\t\t\t\tnull);\n+\t\t\t\t\t\t\"[\" + Integer.toHexString(index) + \"]\", null);\n \t\t\t\t}\n \t\t\t\tstruct.add(BYTE, \"Extra byte\", \"0x01 if string contains non-ASCII\");\n \t\t\t}",
    "output": "Fix #US table processing"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/util/GhidraJarBuilder.java\n@@ -754,7 +754,9 @@ public void addFile(String jarPath, File file, ApplicationModule module)\n \t\t\tlong modifiedTime = file.lastModified();\n \t\t\taddToModuleTree(jarPath, module);\n \t\t\tif (extensionPointSuffixPattern.matcher(jarPath).matches()) {\n-\t\t\t\tcheckExtensionPointClass(jarPath, new FileInputStream(file));\n+\t\t\t\ttry (FileInputStream inStream = new FileInputStream(file)) {\n+\t\t\t\t\tcheckExtensionPointClass(jarPath, inStream);\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif (prefix != null) {\n@@ -775,16 +777,16 @@ public void addFile(String jarPath, File file, ApplicationModule module)\n \t\t\t\treturn;\n \t\t\t}\n \n-\t\t\tInputStream in = new FileInputStream(file);\n+\t\t\ttry (InputStream in = new FileInputStream(file)) {\n \n-\t\t\tbyte[] bytes = new byte[4096];\n-\t\t\tint numRead;\n+\t\t\t\tbyte[] bytes = new byte[4096];\n+\t\t\t\tint numRead;\n \n-\t\t\twhile ((numRead = in.read(bytes)) != -1) {\n-\t\t\t\tmonitor.checkCanceled();\n-\t\t\t\tjarOut.write(bytes, 0, numRead);\n+\t\t\t\twhile ((numRead = in.read(bytes)) != -1) {\n+\t\t\t\t\tmonitor.checkCanceled();\n+\t\t\t\t\tjarOut.write(bytes, 0, numRead);\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tin.close();\n \n \t\t\tjarOut.closeEntry();\n ",
    "output": "Fix Ghidra jar builder \"too many files open\" resource leak"
  },
  {
    "input": "diff --git a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java\n--- a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java\n+++ b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/sevenzip/SevenZipFileSystem.java\n@@ -18,6 +18,8 @@\n import java.io.*;\n import java.util.*;\n \n+import org.apache.commons.io.FilenameUtils;\n+\n import ghidra.formats.gfilesystem.*;\n import ghidra.formats.gfilesystem.annotations.FileSystemInfo;\n import ghidra.util.Msg;\n@@ -70,7 +72,13 @@ public void mount(File containerFile, TaskMonitor monitor)\n \t\t\t\t\tthrow new CancelledException();\n \t\t\t\t}\n \n-\t\t\t\tfsIndexHelper.storeFile(item.getPath(), item.getItemIndex(), item.isFolder(),\n+\t\t\t\tString itemPath = item.getPath();\n+\t\t\t\tif (items.length == 1 && itemPath.isBlank()) {\n+\t\t\t\t\t// special case when there is a single unnamed file.\n+\t\t\t\t\t// use the name of the 7zip file itself, minus the extension\n+\t\t\t\t\titemPath = FilenameUtils.getBaseName(fsrl.getContainer().getName());\n+\t\t\t\t}\n+\t\t\t\tfsIndexHelper.storeFile(itemPath, item.getItemIndex(), item.isFolder(),\n \t\t\t\t\tgetSize(item), item);\n \t\t\t}\n \t\t\tpreCacheAll(monitor);",
    "output": "Upgrade 7zip library to 16.02-2.01"
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/plugin/core/analysis/PdbUniversalAnalyzer.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/plugin/core/analysis/PdbUniversalAnalyzer.java\n--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/plugin/core/analysis/PdbUniversalAnalyzer.java\n+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/plugin/core/analysis/PdbUniversalAnalyzer.java\n@@ -63,7 +63,7 @@ public class PdbUniversalAnalyzer extends AbstractAnalyzer {\n \t// TODO: decide which PDB Analyzer should be enabled by default for release\n \tstatic final boolean DEFAULT_ENABLEMENT = true;\n \tprivate static final String DESCRIPTION =\n-\t\t\"Platform-indepent PDB analyzer (No XML support).\\n\" +\n+\t\t\"Platform-independent PDB analyzer (No XML support).\\n\" +\n \t\t\t\"NOTE: still undergoing development, so options may change.\";\n \n \t//==============================================================================================",
    "output": "Fix typo in PdbUniversalAnalyzer.java \"Platform-indepent\" -> \"Platform-independent\""
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java\n@@ -655,9 +655,12 @@ private Map<SectionHeader, Address> processMemoryBlocks(PortableExecutable pe, P\n \t\t\t\t\t\t\t\tsections[i].getName() + \" section\");\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlong offset = sections[i].getPointerToRawData();\n-\t\t\t\t\t\tMemoryBlockUtils.createInitializedBlock(prog, false,\n-\t\t\t\t\t\t\tsections[i].getReadableName(), address, fileBytes, offset, dataSize, \"\",\n-\t\t\t\t\t\t\t\"\", r, w, x, log);\n+\t\t\t\t\t\tString sectionName = sections[i].getReadableName();\n+\t\t\t\t\t\tif (sectionName.isBlank()) {\n+\t\t\t\t\t\t\tsectionName = \"SECTION.\" + i;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tMemoryBlockUtils.createInitializedBlock(prog, false, sectionName, address,\n+\t\t\t\t\t\t\tfileBytes, offset, dataSize, \"\", \"\", r, w, x, log);\n \t\t\t\t\t\tsectionToAddress.put(sections[i], address);\n \t\t\t\t\t}\n \t\t\t\t\tif (rawDataSize == virtualSize) {",
    "output": "Fix for exception when loading PE's with at least 1 empty section name Incorporating the section index into the renamed empty section name"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java b/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java\n@@ -2236,7 +2236,11 @@ public void hierarchyChanged(HierarchyEvent e) {\n \n \t\t\t\tcomponent.removeHierarchyListener(this);\n \t\t\t\tDockingWindowManager dwm = getInstance(component);\n-\t\t\t\tComponentProvider provider = dwm.getComponentProvider(component);\n+\t\t\t\tComponentProvider provider = null;\n+\t\t\t\tif (dwm != null) {\n+\t\t\t\t\tprovider = dwm.getComponentProvider(component);\n+\t\t\t\t}\n+\n \t\t\t\tlistener.componentLoaded(dwm, provider);\n \t\t\t}\n \t\t});",
    "output": "Fix of recent change to window manager"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/headless/HeadlessAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/headless/HeadlessAnalyzer.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/headless/HeadlessAnalyzer.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/headless/HeadlessAnalyzer.java\n@@ -1193,7 +1193,8 @@ else if (options.commit && !domFile.isCheckedOutExclusive()) {\n \t\t\t// This can never happen because there is no user interaction in headless!\n \t\t}\n \t\tcatch (Exception exc) {\n-\t\t\tMsg.error(this, domFile.getPathname() + \" Error during analysis: \" + exc.getMessage());\n+\t\t\tMsg.error(this, domFile.getPathname() + \" Error during analysis: \" + exc.getMessage(),\n+\t\t\t\texc);\n \t\t}\n \t\tfinally {\n ",
    "output": "Add stack trace to exception to get more diagnostic output"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java\n@@ -79,14 +79,15 @@ public Function getFunction() {\n \t}\n \n \t/**\n-\t * Get the id with the associated function symbol, if it exists\n-\t * @return the id or 0 otherwise\n+\t * Get the id with the associated function symbol, if it exists.\n+\t * Otherwise return a dynamic id based on the entry point.\n+\t * @return the symbol id, or possibly a dynamic id\n \t */\n \tpublic long getID() {\n \t\tif (func instanceof FunctionDB) {\n \t\t\treturn func.getSymbol().getID();\n \t\t}\n-\t\treturn 0;\n+\t\treturn func.getProgram().getSymbolTable().getDynamicSymbolID(func.getEntryPoint());\n \t}\n \n \t/**",
    "output": "Fix \"Duplicate scope id\" error with undefined functions in decompiler"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/util/TaskUtilities.java b/Ghidra/Framework/Generic/src/main/java/ghidra/util/TaskUtilities.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/util/TaskUtilities.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/util/TaskUtilities.java\n@@ -15,16 +15,18 @@\n  */\n package ghidra.util;\n \n-import java.util.*;\n+import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n \n import ghidra.util.task.Task;\n import ghidra.util.task.TaskMonitor;\n \n public class TaskUtilities {\n \n \tprivate static Map<Task, TaskMonitor> runningTasks = new ConcurrentHashMap<>();\n-\tprivate static List<TrackedTaskListener> listeners = new ArrayList<>();\n+\tprivate static List<TrackedTaskListener> listeners = new CopyOnWriteArrayList<>();\n \n \t/**\n \t * Adds a listener that will be notified when tasks are tracked (when they are added and",
    "output": "Fix bug in tests that allowed for ConcurrentModificationException"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraApplicationLayout.java b/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraApplicationLayout.java\n--- a/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraApplicationLayout.java\n+++ b/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraApplicationLayout.java\n@@ -96,14 +96,21 @@ public GhidraApplicationLayout(File applicationInstallationDir)\n \t\t// Application properties\n \t\tapplicationProperties = new ApplicationProperties(applicationRootDirs);\n \n-\t\t// Modules\n-\t\tmodules = findGhidraModules();\n-\n \t\t// User directories\n \t\tuserTempDir = ApplicationUtilities.getDefaultUserTempDir(getApplicationProperties());\n \t\tuserCacheDir = ApplicationUtilities.getDefaultUserCacheDir(getApplicationProperties());\n \t\tuserSettingsDir = ApplicationUtilities.getDefaultUserSettingsDir(getApplicationProperties(),\n \t\t\tgetApplicationInstallationDir());\n+\t\t\n+\t\t// Extensions\n+\t\textensionInstallationDirs = findExtensionInstallationDirectories();\n+\t\textensionArchiveDir = findExtensionArchiveDirectory();\n+\n+\t\t// Patch directory\n+\t\tpatchDir = findPatchDirectory();\n+\t\t\n+\t\t// Modules\n+\t\tmodules = findGhidraModules();\n \t}\n \n \t/**",
    "output": "Fix NPE in GhidraApplicationLayout when the layout is used from the GhidraDev Eclipse plugin"
  },
  {
    "input": "diff --git a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/analyzers/FileFormatAnalyzer.java b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/analyzers/FileFormatAnalyzer.java\n--- a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/analyzers/FileFormatAnalyzer.java\n+++ b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/analyzers/FileFormatAnalyzer.java\n@@ -228,4 +228,9 @@ protected Function createFunction(Program program, Address entryPoint) {\n \tprotected Address find(Program program, Address start, byte[] values, TaskMonitor monitor) {\n \t\treturn program.getMemory().findBytes(start, values, null, true, monitor);\n \t}\n+\n+\t@Override\n+\tpublic boolean rememberEnablementChangeAsUserPreference() {\n+\t\treturn false;\n+\t}\n }",
    "output": "Add missing file change"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ProgramLocationComparator.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ProgramLocationComparator.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ProgramLocationComparator.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/ProgramLocationComparator.java\n@@ -30,8 +30,6 @@\n  * two locations are definitely of the same class.\n  */\n public class ProgramLocationComparator implements Comparator<ProgramLocation> {\n-\t/** The singleton instance */\n-\tpublic static final ProgramLocationComparator INSTANCE = new ProgramLocationComparator();\n \tprivate static final Class<?>[] PROGRAM_LOCATION_CLASSES = {\n \n \t\tDividerLocation.class, ProgramLocation.class, PlateFieldLocation.class,\n@@ -58,6 +56,10 @@ public class ProgramLocationComparator implements Comparator<ProgramLocation> {\n \t\tRegisterFieldLocation.class,\n \n \t};\n+\t// Note, because this calls the constructor, which in turn refers to PROGRAM_LOCATION_CLASSES\n+\t// This must be declared/initialized after PROGRAM_LOCATION_CLASSES\n+\t/** The singleton instance */\n+\tpublic static final ProgramLocationComparator INSTANCE = new ProgramLocationComparator();\n \n \tprivate Map<Class<?>, Integer> priorityMap;\n ",
    "output": "Fix test failures from merging ProgramLocationComparator."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FileActionManager.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FileActionManager.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FileActionManager.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/main/FileActionManager.java\n@@ -556,6 +556,13 @@ void saveProject() {\n \t\tif (project == null) {\n \t\t\treturn;\n \t\t}\n+\n+\t\tif (!project.saveSessionTools()) {\n+\t\t\t// if tools have conflicting options, user is presented with a dialog that can\n+\t\t\t// be cancelled. If they press the cancel button, abort the entire save project action.\n+\t\t\treturn;\n+\t\t}\n+\n \t\tdoSaveProject(project);\n \t\tMsg.info(this, \"Saved project: \" + project.getName());\n \t}\n@@ -684,8 +691,7 @@ private boolean checkReadOnlyFiles(DomainObject[] objs) {\n \t\tsb.append(\"The following files are Read-Only and cannot be\\n\" +\n \t\t\t\" saved 'As Is.' You must do a manual 'Save As' for these\\n\" + \" files: \\n \\n\");\n \n-\t\tfor (int i = 0; i < list.size(); i++) {\n-\t\t\tDomainObject obj = list.get(i);\n+\t\tfor (DomainObject obj : list) {\n \t\t\tsb.append(obj.getDomainFile().getPathname());\n \t\t\tsb.append(\"\\n\");\n \t\t}",
    "output": "Change 'save project' action to have the same 'save' behavior as closing the front end."
  },
  {
    "input": "diff --git a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/ios/png/CrushedPNGUtil.java b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/ios/png/CrushedPNGUtil.java\n--- a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/ios/png/CrushedPNGUtil.java\n+++ b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/ios/png/CrushedPNGUtil.java\n@@ -104,7 +104,7 @@ else if (Arrays.equals(idBytes, CrushedPNGConstants.IDAT_CHUNK)) {\n \t\t\ttry (ByteArrayOutputStream decompressedOutput = new ByteArrayOutputStream(expectedSize);\n \t\t\t\tInflaterOutputStream inflaterStream = new InflaterOutputStream(decompressedOutput)) {\n \n-\t\t\t\tinflaterStream.write(ZLIB_COMPRESSION_DEFAULT);\n+\t\t\t\tinflaterStream.write(ZLIB.ZLIB_COMPRESSION_DEFAULT);\n \t\t\t\tidatStream.writeTo(inflaterStream);\n \t\t\t\tinflaterStream.finish();\n \t\t\t\tresults = decompressedOutput.toByteArray();",
    "output": "Fix compile error - missing ZLIB class specifier."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/LoggingInitialization.java b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/LoggingInitialization.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/LoggingInitialization.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/LoggingInitialization.java\n@@ -29,6 +29,8 @@\n public class LoggingInitialization {\n \n \tprivate static final String LOG4J_CONFIGURATION_PROPERTY = \"log4j.configuration\";\n+\tprivate static final String LOG4J2_CONFIGURATION_PROPERTY = \"log4j.configurationFile\";\n+\n \tprivate static final String PRODUCTION_LOGGING_CONFIGURATION_FILE = \"generic.log4j.xml\";\n \tprivate static final String DEVELOPMENT_LOGGING_CONFIGURATION_FILE = \"generic.log4jdev.xml\";\n \n@@ -47,6 +49,9 @@ public synchronized static void initializeLoggingSystem() {\n \t\t\ttry {\n \t\t\t\tLoggerContext context = (LoggerContext) LogManager.getContext(false);\n \t\t\t\tcontext.setConfigLocation(resource.toURI());\n+\n+\t\t\t\t// make future, unresolved contexts (e.g. from OSGi bundles) use this configuration\n+\t\t\t\tSystem.setProperty(LOG4J2_CONFIGURATION_PROPERTY, resource.toURI().toString());\n \t\t\t}\n \t\t\tcatch (URISyntaxException e) {\n \t\t\t\tMsg.error(LoggingInitialization.class, \"Unable to convert URL to URI\", e);\n@@ -58,7 +63,6 @@ public synchronized static void initializeLoggingSystem() {\n \t\t\t(resource == null) ? \"<no config file found>\" : resource.toExternalForm();\n \t\tMsg.info(LoggingInitialization.class, \"Using log config file: \" + configFilename);\n \t\tMsg.info(LoggingInitialization.class, \"Using log file: \" + APPLICATION_LOG_FILE);\n-\n \t\tINITIALIZED = true;\n \t}\n ",
    "output": "Fix for - configure log4j in OSGi with system property"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/plugins/importer/batch/BatchImportDialog.java b/Ghidra/Features/Base/src/main/java/ghidra/plugins/importer/batch/BatchImportDialog.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/plugins/importer/batch/BatchImportDialog.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/plugins/importer/batch/BatchImportDialog.java\n@@ -231,10 +231,15 @@ public void mouseClicked(MouseEvent e) {\n \t\t});\n \n \t\tremoveSourceButton.addActionListener(e -> {\n-\t\t\tint index = sourceList.getSelectedIndex();\n-\t\t\tif (index >= 0 && index < batchInfo.getUserAddedSources().size()) {\n-\t\t\t\tUserAddedSourceInfo uasi = batchInfo.getUserAddedSources().get(index);\n-\t\t\t\tbatchInfo.remove(uasi.getFSRL());\n+\t\t\tList<FSRL> sourcesToRemove = new ArrayList<>();\n+\t\t\tfor (int index : sourceList.getSelectedIndices()) {\n+\t\t\t\tif (index >= 0 && index < batchInfo.getUserAddedSources().size()) {\n+\t\t\t\t\tUserAddedSourceInfo uasi = batchInfo.getUserAddedSources().get(index);\n+\t\t\t\t\tsourcesToRemove.add(uasi.getFSRL());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor (FSRL fsrl : sourcesToRemove) {\n+\t\t\t\tbatchInfo.remove(fsrl);\n \t\t\t}\n \t\t\trefreshData();\n \t\t});",
    "output": "Fix removing multiple source files in Batch Import dialog"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/AbstractCodeBrowserNavigationTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/AbstractCodeBrowserNavigationTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/AbstractCodeBrowserNavigationTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/AbstractCodeBrowserNavigationTest.java\n@@ -63,8 +63,8 @@ public void setUp() throws Exception {\n \t\tclearHistory = getAction(np, \"Clear History Buffer\");\n \t\tcb = env.getPlugin(CodeBrowserPlugin.class);\n \n-\t\tnextFunction = getAction(cb, \"Go to next function\");\n-\t\tprevFunction = getAction(cb, \"Go to previous function\");\n+\t\tnextFunction = getAction(cb, \"Go To Next Function\");\n+\t\tprevFunction = getAction(cb, \"Go To Previous Function\");\n \t}\n \n \t@After",
    "output": "Fix a test."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/script/ScriptAction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/script/ScriptAction.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/script/ScriptAction.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/script/ScriptAction.java\n@@ -121,7 +121,11 @@ ResourceFile getScript() {\n \t}\n \n \tvoid refresh() {\n-\t\tScriptInfo info = infoManager.getExistingScriptInfo(script);\n+\t\t/* this is called during script manager initial config\n+\t\t * before any other access to script info, so we expect to\n+\t\t * create a new ScriptInfo with the next call.\n+\t\t */\n+\t\tScriptInfo info = infoManager.getScriptInfo(script);\n \t\tKeyStroke stroke = info.getKeyBinding();\n \t\tif (!isUserDefinedKeyBinding) {\n \t\t\tsetKeyBindingData(new KeyBindingData(stroke));",
    "output": "Fix null scriptinfo when a key is assigned to a script"
  },
  {
    "input": "diff --git a/Ghidra/Features/Python/src/main/java/ghidra/python/PythonUtils.java b/Ghidra/Features/Python/src/main/java/ghidra/python/PythonUtils.java\n--- a/Ghidra/Features/Python/src/main/java/ghidra/python/PythonUtils.java\n+++ b/Ghidra/Features/Python/src/main/java/ghidra/python/PythonUtils.java\n@@ -27,7 +27,7 @@\n  */\n public class PythonUtils {\n \n-\tpublic static final String PYTHON_NAME = \"jython-2.7.1\";\n+\tpublic static final String PYTHON_NAME = \"jython-2.7.2\";\n \tpublic static final String PYTHON_CACHEDIR = \"jython_cachedir\";\n \tpublic static final String PYTHON_SRC = \"python-src\";\n ",
    "output": "Upgrade to Jython 2.7.2"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeLazyNode.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeLazyNode.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeLazyNode.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeLazyNode.java\n@@ -41,7 +41,7 @@ public abstract class GTreeLazyNode extends GTreeNode {\n \t */\n \tpublic void unloadChildren() {\n \t\tif (isLoaded()) {\n-\t\t\tdoSetChildrenAndFireEvent(null);\n+\t\t\tsetChildren(null);\n \t\t}\n \t}\n ",
    "output": "Fix small gtree call that needed to be in swing thread"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java\n@@ -627,10 +627,10 @@ public void goToFunction(Function function, boolean newWindow) {\n \t\t\tnavigatable = newProvider;\n \t\t}\n \n-\t\tSymbol symbol = function.getSymbol();\n-\t\tExternalManager externalManager = program.getExternalManager();\n-\t\tExternalLocation externalLocation = externalManager.getExternalLocation(symbol);\n-\t\tif (externalLocation != null) {\n+\t\tif (function.isExternal()) {\n+\t\t\tSymbol symbol = function.getSymbol();\n+\t\t\tExternalManager externalManager = program.getExternalManager();\n+\t\t\tExternalLocation externalLocation = externalManager.getExternalLocation(symbol);\n \t\t\tservice.goToExternalLocation(navigatable, externalLocation, true);\n \t\t}\n \t\telse {",
    "output": "Fix unsupported exception in decompiler provider"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/CompEditorModel.java\n@@ -126,6 +126,7 @@ public boolean apply() throws InvalidDataTypeException {\n \t\t\treturn true;\n \t\t}\n \t\tfinally {\n+\t\t\tprovider.updateTitle();\n //\t\t\tselection = saveSelection;\n \t\t\tsetSelection(saveSelection);\n \t\t\toriginalDTM.endTransaction(transactionID, true);",
    "output": "Add fix to update provider/tab title on structure name edit"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/constraint/ColumnTypeMapper.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/constraint/ColumnTypeMapper.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/constraint/ColumnTypeMapper.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/constraint/ColumnTypeMapper.java\n@@ -16,6 +16,7 @@\n package docking.widgets.table.constraint;\n \n import java.util.List;\n+import java.util.Objects;\n \n import docking.widgets.table.constraint.provider.NumberColumnConstraintProvider;\n import ghidra.util.classfinder.ExtensionPoint;\n@@ -60,7 +61,7 @@ protected ColumnTypeMapper(Class<T> sourceType, Class<M> destinationType) {\n \n \t@Override\n \tpublic int hashCode() {\n-\t\treturn sourceType.hashCode() + destinationType.hashCode();\n+\t\treturn Objects.hash(sourceType, destinationType);\n \t}\n \n \t@Override",
    "output": "Fix hashcode method in ColumnTypeMapper to handle null source types"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n@@ -551,8 +551,8 @@ private void createActions() {\n \t\t\t\t.enabled(false)\n \t\t\t\t.buildAndInstall(tool);\n \n-\t\tsaveAction = new ActionBuilder(\"Save File\", \"&Save\")\n-\t\t\t\t.menuPath(ToolConstants.MENU_FILE, \"Close &All\")\n+\t\tsaveAction = new ActionBuilder(\"Save File\", getName())\n+\t\t\t\t.menuPath(ToolConstants.MENU_FILE, \"Save File\")\n \t\t\t\t.description(\"Save Program\")\n \t\t\t\t.menuGroup(SAVE_GROUP, Integer.toString(subMenuGroupOrder++))\n \t\t\t\t.menuIcon(null)",
    "output": "Fix help links"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleStatusComponentProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleStatusComponentProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleStatusComponentProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleStatusComponentProvider.java\n@@ -153,10 +153,10 @@ private void createActions() {\n \t\t\t\t.onAction(c -> doRefresh())\n \t\t\t\t.buildAndInstallLocal(this);\n \n-\t\taddBundlesAction(\"ActivateBundles\", \"Enable selected bundle(s)\",\n+\t\taddBundlesAction(\"EnableBundles\", \"Enable selected bundle(s)\",\n \t\t\tResourceManager.loadImage(\"images/media-playback-start.png\"), this::doEnableBundles);\n \n-\t\taddBundlesAction(\"DeactivateBundles\", \"Disable selected bundle(s)\",\n+\t\taddBundlesAction(\"DisableBundles\", \"Disable selected bundle(s)\",\n \t\t\tResourceManager.loadImage(\"images/media-playback-stop.png\"), this::doDisableBundles);\n \n \t\taddBundlesAction(\"CleanBundles\", \"Clean selected bundle build cache(s)\",",
    "output": "Fix links to help from bundle manager actions"
  },
  {
    "input": "diff --git a/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/framework/analysis/AnalysisManagerTest.java b/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/framework/analysis/AnalysisManagerTest.java\n--- a/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/framework/analysis/AnalysisManagerTest.java\n+++ b/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/framework/analysis/AnalysisManagerTest.java\n@@ -78,6 +78,11 @@ public void setUp() throws Exception {\n \t\tprogramBuilder.createMemory(\"AAA\", \"0x100\", 0x1000);\n \t\tprogram = programBuilder.getProgram();\n \t\tanalyzers = new ArrayList<>();\n+\n+\t\t// make sure the user scripts subdirectory exists for createScriptFile\n+\t\tFile userScriptsDir = new File(GhidraScriptUtil.USER_SCRIPTS_DIR);\n+\t\tuserScriptsDir.mkdirs();\n+\t\t\n \t\tGhidraScriptUtil.initialize(new BundleHost(), null);\n \t}\n ",
    "output": "Make sure the user scripts dir exists before creating a script in it"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/LessFreneticGTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/LessFreneticGTable.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/LessFreneticGTable.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/LessFreneticGTable.java\n@@ -63,7 +63,11 @@ public void thaw() {\n \n \t@SuppressWarnings(\"unchecked\")\n \t@Override\n-\tprotected <T> SelectionManager createSelectionManager(TableModel model) {\n-\t\treturn new MySelectionManager<T>(this, (RowObjectTableModel<T>) model);\n+\tprotected <T> SelectionManager createSelectionManager() {\n+\t\tTableModel model = getModel();\n+\t\tif (model instanceof RowObjectTableModel) {\n+\t\t\treturn new MySelectionManager<T>(this, (RowObjectTableModel<T>) model);\n+\t\t}\n+\t\treturn null;\n \t}\n }",
    "output": "Fix after rebase"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleHost.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleHost.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleHost.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleHost.java\n@@ -589,8 +589,9 @@ static void collectPackagesFromDirectory(Path dirPath, Set<String> s) {\n \t\ttry {\n \t\t\tFiles.walk(dirPath).filter(p -> p.toString().endsWith(\".class\")).forEach(p -> {\n \t\t\t\tString n = dirPath.relativize(p).toString();\n-\t\t\t\tint lastSlash = n.lastIndexOf('/');\n-\t\t\t\ts.add(lastSlash > 0 ? n.substring(0, lastSlash).replace('/', '.') : \"\");\n+\t\t\t\tint lastSlash = n.lastIndexOf(File.separatorChar);\n+\t\t\t\ts.add(lastSlash > 0 ? n.substring(0, lastSlash).replace(File.separatorChar, '.')\n+\t\t\t\t\t\t: \"\");\n \t\t\t});\n \n \t\t}",
    "output": "Fix for non-unix paths"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleHost.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleHost.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleHost.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/BundleHost.java\n@@ -29,7 +29,6 @@\n import org.apache.felix.framework.FrameworkFactory;\n import org.apache.felix.framework.util.FelixConstants;\n import org.apache.felix.framework.util.manifestparser.ManifestParser;\n-import org.apache.felix.main.AutoProcessor;\n import org.osgi.framework.*;\n import org.osgi.framework.launch.Framework;\n import org.osgi.framework.wiring.*;\n@@ -334,7 +333,6 @@ public void startFramework() throws OSGiException, IOException {\n \t\t\tthrow new OSGiException(\"initializing felix OSGi framework\", e);\n \t\t}\n \t\tbc = felix.getBundleContext();\n-\t\tAutoProcessor.process(config, bc);\n \n \t\tServiceReference<LogReaderService> ref = bc.getServiceReference(LogReaderService.class);\n \t\tif (ref != null) {",
    "output": "Remove org.apache.felix.main dependency"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/AbstractGhidraScriptMgrPluginTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/AbstractGhidraScriptMgrPluginTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/AbstractGhidraScriptMgrPluginTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/script/AbstractGhidraScriptMgrPluginTest.java\n@@ -1039,7 +1039,7 @@ protected void waitForTaskEnd(TaskListenerFlag flag) {\n \t\twaitForSwing();\n \n \t\tint waitCount = 0;\n-\t\twhile (!flag.ended && waitCount < 301) {\n+\t\twhile (!flag.ended && waitCount < 401) {\n \t\t\ttry {\n \t\t\t\tThread.sleep(DEFAULT_WAIT_DELAY);\n \t\t\t}",
    "output": "Add more time to script tests"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/script/JavaScriptProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/script/JavaScriptProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/script/JavaScriptProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/script/JavaScriptProvider.java\n@@ -133,7 +133,7 @@ public GhidraScript getScriptInstance(ResourceFile sourceFile, PrintWriter write\n \t\ttry {\n \t\t\tBundle b = bundle_host.installExplodedPath(bi.binDir);\n \t\t\tbi.bundleLoc = b.getLocation();\n-\t\t\tSystem.err.printf(\"new bundle loc is %s\\n\", bi.bundleLoc);\n+\t\t\tMsg.out(String.format(\"new bundle loc is %s\\n\", bi.bundleLoc));\n \t\t\tb.start();\n \t\t\tif (!bundle_host.waitForBundleStart(bi.bundleLoc)) {\n \t\t\t\tMsg.error(this, \"starting bundle\");",
    "output": "Use Msg instead of stderr"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/util/exporter/CppExporter.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/util/exporter/CppExporter.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/util/exporter/CppExporter.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/util/exporter/CppExporter.java\n@@ -243,6 +243,9 @@ private void configureOptions(Program program) {\n \t\t\t\t\toptions.grabFromToolAndProgram(null, opt, program);\n \t\t\t\t}\n \t\t\t}\n+\t\t\telse {\n+\t\t\t\toptions.grabFromProgram(program);\t// Let headless pull program specific options\n+\t\t\t}\n \n \t\t\tif (isUseCppStyleComments) {\n \t\t\t\toptions.setCommentStyle(CommentStyleEnum.CPPStyle);",
    "output": "Fix for CppExporter running in headless"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/internal/GTreeModel.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/internal/GTreeModel.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/internal/GTreeModel.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/internal/GTreeModel.java\n@@ -158,7 +158,15 @@ public void fireNodeDataChanged(GTreeNode changedNode) {\n \t\tSystemUtilities.assertThisIsTheSwingThread(\n \t\t\t\"GTreeModel.fireNodeDataChanged() must be \" + \"called from the AWT thread\");\n \n-\t\tTreeModelEvent event = new TreeModelEvent(this, (TreePath) null);\n+\t\tGTreeNode viewNode = convertToViewNode(changedNode);\n+\t\tif (viewNode == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\t// Note - we are passing in the treepath of the node that changed.  The javadocs in \n+\t\t// TreemodelListener seems to imply that you need to pass in the treepath of the parent\n+\t\t// of the node that changed and then the indexes of the children that changed. But this \n+\t\t// works and is cheaper then computing the index of the node that changed.\n+\t\tTreeModelEvent event = new TreeModelEvent(this, viewNode.getTreePath());\n \n \t\tfor (TreeModelListener listener : listeners) {\n \t\t\tlistener.treeNodesChanged(event);",
    "output": "Fix issue with GTreeModel's fireNodeChangedmethod not actually telling the tree which node changed."
  },
  {
    "input": "diff --git a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayComponentProvider.java b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayComponentProvider.java\n--- a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayComponentProvider.java\n+++ b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayComponentProvider.java\n@@ -27,15 +27,22 @@\n public class DefaultGraphDisplayComponentProvider extends ComponentProviderAdapter {\n \n \tstatic final String WINDOW_GROUP = \"ProgramGraph\";\n+\tprivate static final String WINDOW_MENU_GROUP_NAME = \"Graph\";\n \tprivate DefaultGraphDisplay display;\n \n \tDefaultGraphDisplayComponentProvider(DefaultGraphDisplay display, PluginTool pluginTool) {\n-\t\tsuper(pluginTool, \"Graph: \" + display.getId(), \"DefaultGraphDisplay\");\n+\t\tsuper(pluginTool, \"Graph\", \"DefaultGraphDisplay\");\n \t\tthis.display = display;\n \t\tsetHelpLocation(new HelpLocation(\"GraphServices\", \"Default_Graph_Display\"));\n \t\tsetIcon(DefaultDisplayGraphIcons.PROGRAM_GRAPH_ICON);\n \t\tsetTransient();\n \t\tsetWindowGroup(WINDOW_GROUP);\n+\t\tsetSubTitle(Integer.toString(display.getId()));\n+\t}\n+\n+\t@Override\n+\tpublic String getWindowSubMenuName() {\n+\t\treturn WINDOW_MENU_GROUP_NAME;\n \t}\n \n \t@Override",
    "output": "Fix graph window placement issues."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/totd/TipOfTheDayPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/totd/TipOfTheDayPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/totd/TipOfTheDayPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/totd/TipOfTheDayPlugin.java\n@@ -18,6 +18,7 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.*;\n+import java.util.stream.Collectors;\n \n import docking.ActionContext;\n import docking.action.DockingAction;\n@@ -82,7 +83,8 @@ public void actionPerformed(ActionContext context) {\n \n \tprivate List<String> loadTips() throws IOException {\n \t\ttry (InputStream in = getClass().getResourceAsStream(\"tips.txt\")) {\n-\t\t\treturn in == null ? Collections.emptyList() : FileUtilities.getLines(in);\n+\t\t\tList<String> tips = in == null ? Collections.emptyList() : FileUtilities.getLines(in);\n+\t\t\treturn tips.stream().filter(s -> s.length() > 0).collect(Collectors.toList());\n \t\t}\n \t}\n ",
    "output": "Remove blank tips of the day."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/constraint/ColumnTypeMapper.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/constraint/ColumnTypeMapper.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/constraint/ColumnTypeMapper.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/constraint/ColumnTypeMapper.java\n@@ -58,6 +58,26 @@ protected ColumnTypeMapper(Class<T> sourceType, Class<M> destinationType) {\n \t\tthis.destinationType = destinationType;\n \t}\n \n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn sourceType.hashCode() + destinationType.hashCode();\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (obj == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (getClass() != obj.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tColumnTypeMapper<?, ?> other = (ColumnTypeMapper<?, ?>) obj;\n+\t\treturn destinationType == other.destinationType && sourceType == other.sourceType;\n+\t}\n+\n \t/**\n \t * Converts an object of type T1 to an object of type T2\n \t * @param value the object to convert.",
    "output": "Fix location filter behavior where it kept popping up dialog about external filter changed added equals method to ColumnTypeMapper to fix"
  },
  {
    "input": "diff --git a/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/plugin/prototype/MicrosoftCodeAnalyzerPlugin/RttiAnalyzer.java b/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/plugin/prototype/MicrosoftCodeAnalyzerPlugin/RttiAnalyzer.java\n--- a/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/plugin/prototype/MicrosoftCodeAnalyzerPlugin/RttiAnalyzer.java\n+++ b/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/plugin/prototype/MicrosoftCodeAnalyzerPlugin/RttiAnalyzer.java\n@@ -225,7 +225,7 @@ private static List<Address> getRefsToRtti0(Program program, List<MemoryBlock> d\n \n \t\tint rtti0PointerOffset = Rtti4Model.getRtti0PointerComponentOffset();\n \n-\t\tMemoryBytePatternSearcher searcher = new MemoryBytePatternSearcher(\"RTTI0 refernces\");\n+\t\tMemoryBytePatternSearcher searcher = new MemoryBytePatternSearcher(\"RTTI0 references\");\n \n \t\tfor (Address rtti0Address : rtti0Locations) {\n \t\t\tbyte[] bytes;",
    "output": "Fix misspelling of references"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/framework/main/datatree/JavaFileListHandler.java b/Ghidra/Features/Base/src/main/java/ghidra/framework/main/datatree/JavaFileListHandler.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/framework/main/datatree/JavaFileListHandler.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/framework/main/datatree/JavaFileListHandler.java\n@@ -29,6 +29,7 @@\n import ghidra.framework.model.DomainFolder;\n import ghidra.framework.plugintool.PluginTool;\n import ghidra.util.Msg;\n+import ghidra.util.Swing;\n import util.CollectionUtils;\n \n /**\n@@ -67,12 +68,14 @@ public void handle(PluginTool tool, DataTree dataTree, GTreeNode destinationNode\n \tprivate void doImport(FileImporterService importer, DomainFolder folder, Object files) {\n \n \t\tList<File> fileList = CollectionUtils.asList((List<?>) files, File.class);\n-\t\tif (fileList.size() == 1 && fileList.get(0).isFile()) {\n-\t\t\timporter.importFile(folder, fileList.get(0));\n-\t\t}\n-\t\telse {\n-\t\t\timporter.importFiles(folder, fileList);\n-\t\t}\n+\t\tSwing.runLater(() -> {\n+\t\t\tif (fileList.size() == 1 && fileList.get(0).isFile()) {\n+\t\t\t\timporter.importFile(folder, fileList.get(0));\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\timporter.importFiles(folder, fileList);\n+\t\t\t}\n+\t\t});\n \t}\n \n \tprivate DomainFolder getDomainFolder(GTreeNode destinationNode) {",
    "output": "Fix drag-drop so Windows file explorer doesn't get blocked. Moved creation of modal Import dialog to a runSwingLater so drag-and-drop can return immediately."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeNode.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeNode.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeNode.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTreeNode.java\n@@ -258,10 +258,6 @@ public void removeNode(GTreeNode node) {\n \t * @param childList this list of nodes to be set as children of this node\n \t */\n \tpublic void setChildren(List<GTreeNode> childList) {\n-\t\tSystem.out.println(\"Setting children for node: \" + getTreePath());\n-\t\tfor (GTreeNode child : childList) {\n-\t\t\tSystem.out.println(\"\\tchild name: \" + child.getName());\n-\t\t}\n \t\tSwing.runNow(() -> doSetChildrenAndFireEvent(childList));\n \t}\n ",
    "output": "Fix accidental checkin of debug code."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/symbol/SymbolUtilities.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/symbol/SymbolUtilities.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/symbol/SymbolUtilities.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/symbol/SymbolUtilities.java\n@@ -238,13 +238,6 @@ public static void validateName(String name, Address address, SymbolType symbolT\n \t\tif (containsInvalidChars(name)) {\n \t\t\tthrow new InvalidInputException(\"Symbol name contains invalid characters: \" + name);\n \t\t}\n-\t\tif (address.isMemoryAddress() && isReservedDynamicLabelName(name, addrFactory)) {\n-\t\t\tif (symbolType == SymbolType.FUNCTION && getDefaultFunctionName(address).equals(name)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tthrow new InvalidInputException(\n-\t\t\t\t\"Symbol name matches possible default symbol name: \" + name);\n-\t\t}\n \t}\n \n \t/**",
    "output": "Remove restriction for creating symbols that resemble dynamic symbol names."
  },
  {
    "input": "diff --git a/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/service/FidProgramSeeker.java b/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/service/FidProgramSeeker.java\n--- a/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/service/FidProgramSeeker.java\n+++ b/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/service/FidProgramSeeker.java\n@@ -48,7 +48,7 @@ public int compare(HashMatch o1, HashMatch o2) {\n \n \tpublic final int MAX_NUM_PARENTS_FOR_SCORE = 500; // Limit number of (useless) parent (caller) functions\n \n-\tprivate final int CACHE_SIZE = 120000; // Maximum number of FidQuadHash cached\n+\tprivate final int MAX_CACHE_SIZE = 2000000; // Maximum number of FidQuadHash cached\n \n \tprivate final float scoreThreshold; // Code unit score a function must achieve to be considered a match\n \tprivate final int mediumHashCodeUnitLengthLimit;\n@@ -72,7 +72,10 @@ public FidProgramSeeker(FidQueryService fidQueryService, Program program, FidHas\n \t\tthis.scoreThreshold = scoreThreshold;\n \t\tthis.mediumHashCodeUnitLengthLimit = mediumHashCodeUnitLengthLimit;\n \t\tFidHasherFactory factory = new FidHasherFactory(hasher);\n-\t\tthis.cacheFactory = new FIDFixedSizeMRUCachingFactory(factory, CACHE_SIZE);\n+\t\tint cacheSize = program.getFunctionManager().getFunctionCount();\n+\t\tcacheSize = (cacheSize < 100) ? 100 : cacheSize;\n+\t\tcacheSize = (cacheSize > MAX_CACHE_SIZE) ? MAX_CACHE_SIZE : cacheSize;\n+\t\tthis.cacheFactory = new FIDFixedSizeMRUCachingFactory(factory, cacheSize);\n \t}\n \n \tpublic static ArrayList<Function> getChildren(Function function, boolean followThunks) {",
    "output": "Make FID cache size match the number of functions"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ProgramBigListingModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ProgramBigListingModel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ProgramBigListingModel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ProgramBigListingModel.java\n@@ -614,6 +614,8 @@ void put(Address addr, Layout layout, boolean isGapAddress) {\n \n \t@Override\n \tpublic ListingModel copy() {\n-\t\treturn new ProgramBigListingModel(program, formatMgr);\n+\t\tProgramBigListingModel model = new ProgramBigListingModel(program, formatMgr);\n+\t\tmodel.openCloseMgr = openCloseMgr;\n+\t\treturn model;\n \t}\n }",
    "output": "Fix junit errors caused by last week's listingModel change."
  },
  {
    "input": "diff --git a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayProvider.java b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayProvider.java\n--- a/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayProvider.java\n+++ b/Ghidra/Features/GraphServices/src/main/java/ghidra/graph/visualization/DefaultGraphDisplayProvider.java\n@@ -51,7 +51,7 @@ public GraphDisplay getGraphDisplay(boolean reuseGraph,\n \t\t\tTaskMonitor monitor) {\n \n \t\tif (reuseGraph && !displays.isEmpty()) {\n-\t\t\treturn getExistingGraph();\n+\t\t\treturn getVisibleGraph();\n \t\t}\n \n \t\tDefaultGraphDisplay display =\n@@ -66,9 +66,16 @@ public void initialize(PluginTool tool, Options graphOptions) {\n \t\tthis.options = graphOptions;\n \t}\n \n-\tprivate GraphDisplay getExistingGraph() {\n-\t\tDefaultGraphDisplay display = displays.iterator().next();\n-\t\treturn display;\n+\t/**\n+\t * Get a {@code GraphDisplay} that is 'showing', assuming that is the one the user\n+\t * wishes to append to.\n+\t * Called only when displays is not empty. If there are no 'showing' displays,\n+\t * return one from the Set via its iterator\n+\t * @return a display that is showing\n+\t */\n+\tprivate GraphDisplay getVisibleGraph() {\n+\t\treturn displays.stream().filter(d -> d.getComponent().isShowing())\n+\t\t\t\t.findAny().orElse(displays.iterator().next());\n \t}\n \n \t@Override",
    "output": "Change reuse/append display to choose a display that is currently visible. This will be the one in the open tab."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Graph/src/main/java/ghidra/service/graph/AttributedGraph.java b/Ghidra/Framework/Graph/src/main/java/ghidra/service/graph/AttributedGraph.java\n--- a/Ghidra/Framework/Graph/src/main/java/ghidra/service/graph/AttributedGraph.java\n+++ b/Ghidra/Framework/Graph/src/main/java/ghidra/service/graph/AttributedGraph.java\n@@ -80,6 +80,7 @@ public AttributedVertex addVertex(String id, String name) {\n \t\tif (vertexMap.containsKey(id)) {\n \t\t\tAttributedVertex vertex = vertexMap.get(id);\n \t\t\tvertex.setName(name);\n+\t\t\treturn vertex;\n \t\t}\n \t\tAttributedVertex newVertex = new AttributedVertex(id, name);\n \t\taddVertex(newVertex);\n\ndiff --git a/Ghidra/Framework/Graph/src/test/java/ghidra/service/graph/AttributedGraphTest.java b/Ghidra/Framework/Graph/src/test/java/ghidra/service/graph/AttributedGraphTest.java\n--- a/Ghidra/Framework/Graph/src/test/java/ghidra/service/graph/AttributedGraphTest.java\n+++ b/Ghidra/Framework/Graph/src/test/java/ghidra/service/graph/AttributedGraphTest.java\n@@ -88,7 +88,7 @@ public void testAddDuplicateVertexWithDifferentName() {\n \n \t\tassertEquals(1, graph.getVertexCount());\n \t\tassertTrue(v1 == v2);\n-\t\tassertEquals(\"Bob\", v2.getName());\n+\t\tassertEquals(\"Joe\", v2.getName());\n \t}\n \n \t@Test",
    "output": "Fix junit tests"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java\n@@ -94,7 +94,7 @@ public DecompileCallback(Program prog, Language language, CompilerSpec compilerS\n \t\tcpool = null;\n \t\tnativeMessage = null;\n \t\tdebug = null;\n-\t\tutf8Charset = Charset.availableCharsets().get(\"UTF-8\");\n+\t\tutf8Charset = Charset.availableCharsets().get(CharsetInfo.UTF8);\n \t}\n \n \tprivate static SAXParser getSAXParser() throws PcodeXMLException {",
    "output": "Use string reference"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/NTHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/NTHeader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/NTHeader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pe/NTHeader.java\n@@ -154,15 +154,15 @@ public long rvaToPointer(long rva) {\n \t\tSectionHeader[] sections = fileHeader.getSectionHeaders();\n \t\tfor (SectionHeader section : sections) {\n \t\t\tlong sectionVA = section.getVirtualAddress() & Conv.INT_MASK;\n-\t\t\tlong rawSize = section.getSizeOfRawData() & Conv.INT_MASK;\n+\t\t\tlong vSize = section.getVirtualSize() & Conv.INT_MASK;\n \t\t\tlong rawPtr = section.getPointerToRawData() & Conv.INT_MASK;\n \n \t\t\tswitch (layout) {\n \t\t\t\tcase MEMORY:\n \t\t\t\t\treturn rva;\n \t\t\t\tcase FILE:\n \t\t\t\tdefault:\n-\t\t\t\t\tif (rva >= sectionVA && rva < sectionVA + rawSize) {\n+\t\t\t\t\tif (rva >= sectionVA && rva < sectionVA + vSize) {\n \t\t\t\t\t\treturn rva + rawPtr - sectionVA;\n \t\t\t\t\t}\n \t\t\t\t\tbreak;",
    "output": "Use the virtual size to determine section"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/util/task/WrappingTaskMonitor.java b/Ghidra/Framework/Generic/src/main/java/ghidra/util/task/WrappingTaskMonitor.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/util/task/WrappingTaskMonitor.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/util/task/WrappingTaskMonitor.java\n@@ -68,7 +68,7 @@ public synchronized void setDelegate(TaskMonitor newDelegate) {\n \t\t\tdelegate.removeCancelledListener(l);\n \t\t}\n \n-\t\tnewDelegate.setMaximum(delegate.getMaximum());\n+\t\tnewDelegate.initialize(delegate.getMaximum());\n \t\tnewDelegate.setProgress(delegate.getProgress());\n \t\tnewDelegate.setMessage(delegate.getMessage());\n \t\tnewDelegate.setIndeterminate(delegate.isIndeterminate());",
    "output": "Fix missing progressbar in TaskDialog."
  },
  {
    "input": "diff --git a/Ghidra/Processors/MIPS/src/main/java/ghidra/app/util/bin/format/elf/extend/MIPS_ElfExtension.java b/Ghidra/Processors/MIPS/src/main/java/ghidra/app/util/bin/format/elf/extend/MIPS_ElfExtension.java\n--- a/Ghidra/Processors/MIPS/src/main/java/ghidra/app/util/bin/format/elf/extend/MIPS_ElfExtension.java\n+++ b/Ghidra/Processors/MIPS/src/main/java/ghidra/app/util/bin/format/elf/extend/MIPS_ElfExtension.java\n@@ -580,9 +580,11 @@ private void processMipsOptions(ElfLoadHelper elfLoadHelper, Address mipsOptions\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tdefault:\n-\t\t\t\t\t\t// consume unprocessed option description bytes\n-\t\t\t\t\t\telfLoadHelper.createData(nextOptionAddr,\n-\t\t\t\t\t\t\tnew ArrayDataType(ByteDataType.dataType, optionDataSize, 1));\n+\t\t\t\t\t\tif (optionDataSize > 0) {\n+\t\t\t\t\t\t\t// consume unprocessed option description bytes\n+\t\t\t\t\t\t\telfLoadHelper.createData(nextOptionAddr,\n+\t\t\t\t\t\t\t\tnew ArrayDataType(ByteDataType.dataType, optionDataSize, 1));\n+\t\t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tlimit -= odkHeader.getLength() + optionDataSize;",
    "output": "Fix a bug when parsing the elf SHT_MIPS_OPTIONS section"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functioncompare/MultiFunctionComparisonPanel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functioncompare/MultiFunctionComparisonPanel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functioncompare/MultiFunctionComparisonPanel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functioncompare/MultiFunctionComparisonPanel.java\n@@ -89,12 +89,16 @@ public MultiFunctionComparisonPanel(MultiFunctionComparisonProvider provider,\n \t */\n \t@Override\n \tpublic void reload() {\n-\t\treloadSourceList();\n-\t\tFunction selectedSource = (Function) sourceFunctionsCBModel.getSelectedItem();\n-\t\treloadTargetList(selectedSource);\n-\t\tloadFunctions(selectedSource, (Function) targetFunctionsCBModel.getSelectedItem());\n-\n-\t\tupdateTabText();\n+\t\tSwingUtilities.invokeLater(new Runnable() {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\treloadSourceList();\n+\t\t\t\tFunction selectedSource = (Function) sourceFunctionsCBModel.getSelectedItem();\n+\t\t\t\treloadTargetList(selectedSource);\n+\t\t\t\tloadFunctions(selectedSource, (Function) targetFunctionsCBModel.getSelectedItem());\n+\t\t\t\tupdateTabText();\n+\t\t\t}\n+\t\t});\n \n \t\t// Fire a notification to update the UI state; without this the \n \t\t// actions would not be properly enabled/disabled",
    "output": "Make sure updates to comparisons are done on swing thread"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/Platform.java\n@@ -1,6 +1,5 @@\n /* ###\n  * IP: GHIDRA\n- * REVIEWED: NO\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.",
    "output": "Fix certify header comment in Platform.java"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/docking/widgets/table/SelectionManagerTest.java b/Ghidra/Features/Base/src/test.slow/java/docking/widgets/table/SelectionManagerTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/docking/widgets/table/SelectionManagerTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/docking/widgets/table/SelectionManagerTest.java\n@@ -471,7 +471,7 @@ private void setFilterText(final String text) throws Exception {\n \t\twaitForThreadedModel();\n \t}\n \n-\tprivate void waitForThrsadedModel() {\n+\tprivate void waitForThreadedModel() {\n \t\tint numWaits = 0;\n \t\tint sleepyTime = 10;\n \t\tint maxWaits = ((MAX_ROW_COUNT + 1) * MAX_THREAD_SLEEP_DELAY) / sleepyTime;",
    "output": "Fix dumb mistake"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n@@ -534,6 +534,7 @@ private void createActions() {\n \t\t\t\t.menuGroup(OPEN_GROUP, Integer.toString(subMenuGroupOrder++))\n \t\t\t\t.withContext(ProgramActionContext.class)\n \t\t\t\t.onAction(c -> closeProgram(c.getProgram(), false))\n+\t\t\t\t.keyBinding(\"ctrl W\")\n \t\t\t\t.buildAndInstall(tool);\n \n \t\tcloseOthersAction = new ActionBuilder(\"Close Others\", getName())",
    "output": "Add ctrl+w close file hotkey"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/framework/analysis/AnalysisManager.java b/Ghidra/Features/Base/src/main/java/ghidra/framework/analysis/AnalysisManager.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/framework/analysis/AnalysisManager.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/framework/analysis/AnalysisManager.java\n@@ -86,6 +86,7 @@ public void runAnalysis(AddressSet addressSet) {\n \t\t}\n \t\tList<AnalysisPhase> analysisPhases = recipe.getAnalysisPhases();\n \t\tboolean isFirstPhase = true;\n+\t\ttaskManager.setSuspended(true);\n \t\tfor (AnalysisPhase analysisPhase : analysisPhases) {\n \t\t\ttaskManager.scheduleTask(new StartPhaseTask(analysisPhase), 0, analysisPhase.getName());\n \t\t\tif (isFirstPhase) {\n@@ -94,6 +95,7 @@ public void runAnalysis(AddressSet addressSet) {\n \t\t\t\t\tanalysisPhase.getName());\n \t\t\t}\n \t\t}\n+\t\ttaskManager.setSuspended(false);\n \n \t}\n ",
    "output": "Fix junit timing issue"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/ProgramManagerPlugin.java\n@@ -559,7 +559,7 @@ private void createActions() {\n \t\t\t\t.toolBarGroup(ToolConstants.TOOLBAR_GROUP_ONE)\n \t\t\t\t.keyBinding(\"ctrl S\")\n \t\t\t\t.withContext(ProgramActionContext.class)\n-\t\t\t\t.enabledWhen(c -> c.getProgram().isChanged())\n+\t\t\t\t.enabledWhen(c -> c.getProgram() != null && c.getProgram().isChanged())\n \t\t\t\t.onAction(c -> programSaveMgr.saveProgram(c.getProgram()))\n \t\t\t\t.buildAndInstall(tool);\n ",
    "output": "Fix bug in save action enablement"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/DropDownTextField.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/DropDownTextField.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/DropDownTextField.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/DropDownTextField.java\n@@ -346,7 +346,7 @@ private void updateDisplayLocation(boolean hasMatches) {\n \t\t\tupdateWindowLocation();\n \t\t\tshowMatchingWindow();\n \n-\t\t\tpreviewLabel.setBackground(TOOLTIP_WINDOW_BGCOLOR);\n+\t\t\tgetPreviewPaneComponent().setBackground(TOOLTIP_WINDOW_BGCOLOR);\n \t\t\ttoolTipWindow.setVisible(hasPreview());\n \t\t}\n \t}",
    "output": "Change drop down selection widget to avoid NPE in multi selection widget"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java\n--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java\n@@ -85,7 +85,7 @@ public void testAssemble_T_bl_0x0002350c() {\n \n \t@Test\n \tpublic void testAssemble_T_iteq() {\n-\t\tassertOneCompatRestExact(\"itETT eq\", \"09:BF\", THUMB, 0x00400000, \"itett eq\");\n+\t\tassertOneCompatRestExact(\"itett eq\", \"09:BF\", THUMB, 0x00400000, \"itett eq\");\n \t}\n \n \t@Test",
    "output": "Fix ARMAssemblyTest failure case issue again."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/CoreGTreeNode.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/CoreGTreeNode.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/CoreGTreeNode.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/CoreGTreeNode.java\n@@ -169,7 +169,11 @@ protected synchronized void doSetChildren(List<GTreeNode> childList) {\n \n \t\tif (oldChildren != null) {\n \t\t\tfor (GTreeNode node : oldChildren) {\n-\t\t\t\tnode.dispose();\n+\t\t\t\t// only dispose old nodes that aren't included in the new child list - if any\n+\t\t\t\t// old nodes don't have a parent, then they were not include in the new list\n+\t\t\t\tif (node.getParent() == null) {\n+\t\t\t\t\tnode.dispose();\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}",
    "output": "Fix issue in GTree where calling setChildren with exiting children put the tree in a bad state"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeader.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeader.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeader.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableHeader.java\n@@ -196,7 +196,7 @@ public String getToolTipText(MouseEvent e) {\n \n \t\tint realIndex = gTable.convertColumnIndexToModel(columnIndex);\n \n-\t\tString columnFilterToolTip = getColumnFilterToolTip(model, columnIndex);\n+\t\tString columnFilterToolTip = getColumnFilterToolTip(model, realIndex);\n \t\tVariableColumnTableModel variableModel = VariableColumnTableModel.from(model);\n \t\tif (variableModel != null) {\n \t\t\tString description = variableModel.getColumnDescription(realIndex);",
    "output": "Fix bug where column filter tooltip was on the wrong column"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/LocationReferencesProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/LocationReferencesProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/LocationReferencesProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/navigation/locationreferences/LocationReferencesProvider.java\n@@ -398,12 +398,7 @@ public JComponent getComponent() {\n \n \t@Override\n \tpublic ActionContext getActionContext(MouseEvent event) {\n-\t\tif (event != null) {\n-\t\t\tif (referencesPanel.selectRow(event)) {\n-\t\t\t\treturn new ActionContext(this, referencesPanel.getTable());\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n+\t\treturn new ActionContext(this, referencesPanel.getTable());\n \t}\n \n //==================================================================================================",
    "output": "Fix Location References Provider's 'Make Selection' toolbar action"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java\n--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/ARMAssemblyTest.java\n@@ -85,7 +85,7 @@ public void testAssemble_T_bl_0x0002350c() {\n \n \t@Test\n \tpublic void testAssemble_T_iteq() {\n-\t\tassertOneCompatRestExact(\"itETT eq\", \"09:BF\", THUMB, 0x00400000, \"itETT eq\");\n+\t\tassertOneCompatRestExact(\"itETT eq\", \"09:BF\", THUMB, 0x00400000, \"itett eq\");\n \t}\n \n \t@Test",
    "output": "Fix ARMAssemblyTest failure"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableAutoLookup.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableAutoLookup.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableAutoLookup.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/table/GTableAutoLookup.java\n@@ -55,18 +55,26 @@ public String getValueString(int row, int col) {\n \t\treturn obj == null ? null : obj.toString();\n \t}\n \n+\tprivate boolean isSortableTableModel() {\n+\t\treturn table.getModel() instanceof SortedTableModel;\n+\t}\n+\n \t@Override\n \tpublic boolean isSorted(int column) {\n-\n-\t\tif (table.getModel() instanceof SortedTableModel) {\n-\t\t\tSortedTableModel sortedModel = (SortedTableModel) table.getModel();\n-\t\t\treturn column == sortedModel.getPrimarySortColumnIndex();\n+\t\tif (!isSortableTableModel()) {\n+\t\t\treturn false;\n \t\t}\n-\t\treturn false;\n+\n+\t\tSortedTableModel sortedModel = (SortedTableModel) table.getModel();\n+\t\treturn column == sortedModel.getPrimarySortColumnIndex();\n \t}\n \n \t@Override\n \tpublic boolean isSortedAscending() {\n+\t\tif (!isSortableTableModel()) {\n+\t\t\treturn false;\n+\t\t}\n+\n \t\tSortedTableModel model = (SortedTableModel) table.getModel();\n \t\tint primarySortColumnIndex = model.getPrimarySortColumnIndex();\n \t\tTableSortState columnSortState = model.getTableSortState();",
    "output": "Fix for unchecked type casts in table auto-lookup"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/util/NumericUtilities.java b/Ghidra/Framework/Generic/src/main/java/ghidra/util/NumericUtilities.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/util/NumericUtilities.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/util/NumericUtilities.java\n@@ -250,7 +250,7 @@ public final static long bigIntegerToUnsignedLong(BigInteger value) {\n \t * @return aligned value\n \t */\n \tpublic static long getUnsignedAlignedValue(long unsignedValue, long alignment) {\n-\t\tif (unsignedValue % alignment == 0) {\n+\t\tif (alignment == 0 || unsignedValue % alignment == 0) {\n \t\t\treturn unsignedValue;\n \t\t}\n \t\tboolean negative = unsignedValue < 0;",
    "output": "Fix potential divide-by-zero"
  },
  {
    "input": "diff --git a/Ghidra/Features/FunctionGraph/src/main/java/ghidra/app/plugin/core/functiongraph/FGProvider.java b/Ghidra/Features/FunctionGraph/src/main/java/ghidra/app/plugin/core/functiongraph/FGProvider.java\n--- a/Ghidra/Features/FunctionGraph/src/main/java/ghidra/app/plugin/core/functiongraph/FGProvider.java\n+++ b/Ghidra/Features/FunctionGraph/src/main/java/ghidra/app/plugin/core/functiongraph/FGProvider.java\n@@ -22,7 +22,6 @@\n import javax.swing.*;\n \n import docking.*;\n-import docking.action.DockingActionIf;\n import docking.widgets.fieldpanel.FieldPanel;\n import edu.uci.ics.jung.graph.Graph;\n import generic.stl.Pair;\n@@ -147,12 +146,6 @@ public void setClipboardService(ClipboardService service) {\n \t\t}\n \t}\n \n-\t@Override\n-\tprotected void addLocalAction(DockingActionIf action) {\n-\t\t// overridden just to open package access\n-\t\tsuper.addLocalAction(action);\n-\t}\n-\n \tFGController getController() {\n \t\treturn controller;\n \t}",
    "output": "Upgrade for compatibility with action builder branch"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java\n@@ -39,7 +39,7 @@\n  *\n  *\n  */\n-public class DecompileOptions { //\n+public class DecompileOptions {\n \tprivate final static String PREDICATE_OPTIONSTRING = \"Analysis.Simplify predication\";\n \tprivate final static String PREDICATE_OPTIONDESCRIPTION =\n \t\t\"If set, multiple conditionally executed instructions \" +\n@@ -625,6 +625,10 @@ public int getMaxWidth() {\n \t\treturn maxwidth;\n \t}\n \n+\tpublic void setMaxWidth(int maxwidth) {\n+\t\tthis.maxwidth = maxwidth;\n+\t}\n+\n \tpublic Color getKeywordColor() {\n \t\treturn keywordColor;\n \t}",
    "output": "Add a setter method to the Decompiler's options"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/EditDataTypeAction.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/EditDataTypeAction.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/EditDataTypeAction.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/EditDataTypeAction.java\n@@ -33,12 +33,10 @@ public class EditDataTypeAction extends AbstractDecompilerAction {\n \tprivate final PluginTool tool;\n \n \tpublic EditDataTypeAction(PluginTool tool, DecompilerController controller) {\n-\t\tsuper(\"EditDataType\");\n+\t\tsuper(\"Edit Data Type\");\n \t\tthis.tool = tool;\n \t\tthis.controller = controller;\n \t\tsetPopupMenuData(new MenuData(new String[] { \"Edit Data Type\" }, \"Decompile\"));\n-//\t\tsetKeyBindingData( new KeyBindingData( KeyEvent.VK_L, InputEvent.CTRL_DOWN_MASK ) );\n-\n \t}\n \n \t@Override",
    "output": "Fix action name to correctly sort in key binding options"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/dialog/PluginDetailsPanel.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/dialog/PluginDetailsPanel.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/dialog/PluginDetailsPanel.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/dialog/PluginDetailsPanel.java\n@@ -220,7 +220,7 @@ private String createStringForMenuPath(String[] path) {\n \t\t\treturn null;\n \t\t}\n \n-\t\tStringBuffer buffy = new StringBuffer();\n+\t\tStringBuilder buffy = new StringBuilder();\n \t\tfor (int i = 0; i < path.length; i++) {\n \t\t\tbuffy.append(path[i].replaceAll(\"\\\\&\", \"\"));  // strip off the mnemonic identifier '&'\n \t\t\tif (i != path.length - 1) {",
    "output": "Use StringBuilder to build the menu path string."
  },
  {
    "input": "diff --git a/Ghidra/Test/IntegrationTest/src/screen/java/help/screenshot/SymbolTablePluginScreenShots.java b/Ghidra/Test/IntegrationTest/src/screen/java/help/screenshot/SymbolTablePluginScreenShots.java\n--- a/Ghidra/Test/IntegrationTest/src/screen/java/help/screenshot/SymbolTablePluginScreenShots.java\n+++ b/Ghidra/Test/IntegrationTest/src/screen/java/help/screenshot/SymbolTablePluginScreenShots.java\n@@ -186,9 +186,6 @@ else if (\"Namespace\".equals(headerValue)) {\n \t\t\t\telse if (\"Location\".equals(headerValue)) {\n \t\t\t\t\tcolumn.setPreferredWidth(170);\n \t\t\t\t}\n-\t\t\t\telse if (\"Namespace\".equals(headerValue)) {\n-\t\t\t\t\tcolumn.setPreferredWidth(170);\n-\t\t\t\t}\n \t\t\t\telse if (\"Source\".equals(headerValue)) {\n \t\t\t\t\tcolumn.setPreferredWidth(170);\n \t\t\t\t}",
    "output": "Remove impossible to reach code."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java b/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java\n--- a/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java\n+++ b/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java\n@@ -221,15 +221,15 @@ private static Map<String, GModule> getOrderedModules(ApplicationLayout layout)\n \n \t\t\t// Now handle modules that are internal to the Ghidra installation.\n \t\t\t// We will primarily order them by \"type\" and secondarily by name.\n-\t\t\tMap<String, Integer> typePriorityMap = Map.of(\n-\t\t\t\t\"Framework\", 0,\n-\t\t\t\t\"Configurations\", 1,\n-\t\t\t\t\"Features\", 2,\n-\t\t\t\t\"Processors\", 3,\n-\t\t\t\t\"GPL\", 4,\n-\t\t\t\t\"Extensions\", 5,\n-\t\t\t\t\"Test\", 6\n-\t\t\t);\n+\t\t\tMap<String, Integer> typePriorityMap = new HashMap<>();\n+\t\t\ttypePriorityMap.put(\"Framework\", 0);\n+\t\t\ttypePriorityMap.put(\"Configurations\", 1);\n+\t\t\ttypePriorityMap.put(\"Features\", 2);\n+\t\t\ttypePriorityMap.put(\"Processors\", 3);\n+\t\t\ttypePriorityMap.put(\"GPL\", 4);\n+\t\t\ttypePriorityMap.put(\"Extensions\", 5);\n+\t\t\ttypePriorityMap.put(\"Test\", 6);\n+\n \t\t\tString type1 = module1.getModuleRoot().getParentFile().getName();\n \t\t\tString type2 = module2.getModuleRoot().getParentFile().getName();\n \t\t\tint priority1 = typePriorityMap.getOrDefault(type1, typePriorityMap.size());",
    "output": "Remove Map.ofusage from Utility, which needs to build with Java 1.8 compliance."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveRootNode.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveRootNode.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveRootNode.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/tree/ArchiveRootNode.java\n@@ -225,8 +225,8 @@ public void archiveOpened(Archive archive) {\n \t\t\t\tint index = Collections.binarySearch(allChildrenList, node);\n \t\t\t\tif (index < 0) {\n \t\t\t\t\tindex = -index - 1;\n+\t\t\t\t\taddNode(index, node);\n \t\t\t\t}\n-\t\t\t\taddNode(index, node);\n \t\t\t\t// kick tree to refilter if filter in place so that nodes will stay expaned see\n \t\t\t\t// SCR #7895\n //\t\t\t\ttree.setFilterText(tree.getFilterText());",
    "output": "Fix problem with data type archive node adding twice to tree Tree node for a data type archive could be added twice, causing display problems and NPE when closing because of double-closing."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/MultiTabPanel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/MultiTabPanel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/MultiTabPanel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/progmgr/MultiTabPanel.java\n@@ -310,6 +310,10 @@ public void mousePressed(MouseEvent e) {\n \t\t\t\t\thideListWindow();\n \t\t\t\t}\n \n+\t\t\t\tif (e.isPopupTrigger()) {\n+\t\t\t\t\treturn; // allow popup triggers to show actions without changing tabs\n+\t\t\t\t}\n+\n \t\t\t\t// Tracker SCR 3605 - hitting 'X' to close tab doesn't work if tab is not selected\n \t\t\t\tif (e.getSource() == iconLabel) {\n \t\t\t\t\tdoRemoveProgram(program);",
    "output": "Fix exception when right-clicking a program tab with a global popup action installed"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/InformationBlock.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/InformationBlock.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/InformationBlock.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/ne/InformationBlock.java\n@@ -102,10 +102,10 @@ public class InformationBlock {\n     /**\n      * Is application designed for OS/2?\n      */\n-    public final static byte FLAGS_APP_OS2                   = (byte) 0x04;\n-    public final static byte FLAGS_APP_LOAD_CODE             = (byte) 0x08;\n-    public final static byte FLAGS_APP_LINK_ERRS             = (byte) 0x10;\n-    public final static byte FLAGS_APP_NONCONFORMING_PROG    = (byte) 0x20;\n+    public final static byte FLAGS_APP_OS2                   = (byte) 0x08;\n+    public final static byte FLAGS_APP_LOAD_CODE             = (byte) 0x10;\n+    public final static byte FLAGS_APP_LINK_ERRS             = (byte) 0x20;\n+    public final static byte FLAGS_APP_NONCONFORMING_PROG    = (byte) 0x40;\n     public final static byte FLAGS_APP_LIBRARY_MODULE        = (byte) 0x80;\n \n \t/**",
    "output": "Upgrade flag mapping The bit mapping of the application flags in Ghidra is different from the one documented on https://www.fileformat.info/format/exe/corion-ne.htm. This patch updates it to match the document."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/address/AddressRangeChunker.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/address/AddressRangeChunker.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/address/AddressRangeChunker.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/address/AddressRangeChunker.java\n@@ -81,7 +81,11 @@ public AddressRange next() {\n \t\t\t\t}\n \n \t\t\t\tlong available = end.subtract(nextStartAddress) + 1; // +1 to be inclusive\n-\t\t\t\tint size = Math.min(chunkSize, (int) available);\n+\n+\t\t\t\tint size = chunkSize;\n+\t\t\t\tif (available >= 0 && available < chunkSize) {\n+\t\t\t\t\tsize = (int) available;\n+\t\t\t\t}\n \n \t\t\t\tAddress currentStart = nextStartAddress;\n \t\t\t\tAddress currentEnd = nextStartAddress.add(size - 1); // -1 since inclusive",
    "output": "Fix bug when clearing large contiguous range"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java\n@@ -612,7 +612,7 @@ private Map<SectionHeader, Address> processMemoryBlocks(PortableExecutable pe, P\n \t\t}\n \n \t\t// Header block\n-\t\tint virtualSize = getVirtualSize(pe, sections, space);\n+\t\tint virtualSize = (int) Math.min(getVirtualSize(pe, sections, space), fileBytes.getSize());\n \t\tlong addr = optionalHeader.getImageBase();\n \t\tAddress address = space.getAddress(addr);\n ",
    "output": "Fix exception in PeLoader that occurred when creating a memory block for the headers when the block size exceeded the file size."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/interpreter/InterpreterComponentProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/interpreter/InterpreterComponentProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/interpreter/InterpreterComponentProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/interpreter/InterpreterComponentProvider.java\n@@ -171,12 +171,15 @@ public void dispose() {\n \n \t@Override\n \tpublic void componentActivated() {\n-\t\t// Call the callbacks\n-\t\tfirstActivationCallbacks.forEach(l -> l.call());\n \n-\t\t// Since we only care about the first activation, clear the list\n-\t\t// of callbacks so future activations don't trigger anything.\n+\t\t// Since we only care about the first activation, clear the list of callbacks so future \n+\t\t// activations don't trigger anything.  First save them off to a local list so when we\n+\t\t// process them we aren't affected by concurrent modification due to reentrance.\n+\t\tList<Callback> callbacks = new ArrayList<>(firstActivationCallbacks);\n \t\tfirstActivationCallbacks.clear();\n+\n+\t\t// Call the callbacks\n+\t\tcallbacks.forEach(l -> l.call());\n \t}\n \n \t@Override",
    "output": "Fix ConcurrentModificationException in python interpreter plugin."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/mem/MemoryBlockDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/mem/MemoryBlockDB.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/mem/MemoryBlockDB.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/mem/MemoryBlockDB.java\n@@ -477,7 +477,7 @@ private int putBytes(long offset, byte[] b, int off, int len) throws MemoryAcces\n \t\tint totalCopied = 0;\n \t\ttry {\n \t\t\twhile (totalCopied < len) {\n-\t\t\t\tSubMemoryBlock subBlock = getSubBlock(offset);\n+\t\t\t\tSubMemoryBlock subBlock = getSubBlock(offset + totalCopied);\n \t\t\t\ttotalCopied += subBlock.putBytes(offset + totalCopied, b, off + totalCopied,\n \t\t\t\t\tlen - totalCopied);\n \t\t\t}",
    "output": "Fix infinite loop in MemoryBlockDB.putBytes."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java\n@@ -399,7 +399,7 @@ private void parseSectionBasedRelocationTable(ElfSectionHeader section,\n \t\t\t\t\tsection, section.getOffset(), section.getAddress(), section.getSize(),\n \t\t\t\t\tsection.getEntrySize(), addendTypeReloc, symbolTable, sectionToBeRelocated));\n \t\t\t} \n-\t\t\telse if (sectionHeaderType == ElfSectionHeaderConstants.SHT_ANDROID_RELA ||\n+\t\t\telse if (sectionHeaderType == ElfSectionHeaderConstants.SHT_ANDROID_REL ||\n \t\t\t\t\t   sectionHeaderType == ElfSectionHeaderConstants.SHT_ANDROID_RELA) {\n \n \t\t\t\tfor (ElfRelocationTable relocTable : relocationTableList) {",
    "output": "Fix a typo in the section header type check."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/LocalSymbolMap.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/LocalSymbolMap.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/LocalSymbolMap.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/LocalSymbolMap.java\n@@ -17,7 +17,8 @@\n \n import java.util.*;\n \n-import ghidra.program.model.address.*;\n+import ghidra.program.model.address.Address;\n+import ghidra.program.model.address.AddressIterator;\n import ghidra.program.model.data.DataType;\n import ghidra.program.model.data.Undefined;\n import ghidra.program.model.listing.*;\n@@ -102,12 +103,7 @@ public void grabFromFunction(boolean includeDefaultNames) {\n \t\tboolean lock = (dbFunction.getSignatureSource() != SourceType.DEFAULT);\n \n \t\tAddress pcaddr = dbFunction.getEntryPoint();\n-\t\ttry {\n-\t\t\tpcaddr = pcaddr.subtract(1);\n-\t\t}\n-\t\tcatch (AddressOutOfBoundsException e) {\n-\t\t\t// Should rarely happen\n-\t\t}\n+\t\tpcaddr = pcaddr.subtractWrap(1);\n \n \t\tList<MappedSymbol> paramList = new ArrayList<MappedSymbol>();\n \t\tfor (int i = 0; i < p.length; ++i) {",
    "output": "Fix for se_bmaski, parameter first use with subtractWrap"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/FindNoReturnFunctionsAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/FindNoReturnFunctionsAnalyzer.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/FindNoReturnFunctionsAnalyzer.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/FindNoReturnFunctionsAnalyzer.java\n@@ -364,7 +364,7 @@ private boolean detectNoReturn(Program cp, AddressSet noReturnSet, AddressSetVie\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t\tInstruction oinst = cp.getListing().getInstructionAt(fromAddress);\n-\t\t\t\t\tif (!checkNonReturningIndicators(oinst, noReturnSet, blockModel)) {\n+\t\t\t\t\tif ( oinst == null || !checkNonReturningIndicators(oinst, noReturnSet, blockModel)) {\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n ",
    "output": "Fix NPE in FindNoReturnFunctionsAnalyzer If there is a reference to a non-returning function from a location that doesn't have an instruction, will get NPE."
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbParser.java b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbParser.java\n--- a/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbParser.java\n+++ b/Ghidra/Features/PDB/src/main/java/ghidra/app/util/bin/format/pdb/PdbParser.java\n@@ -177,6 +177,9 @@ public void parse() throws IOException, PdbException {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\telse { // only for .pdb.xml files.\n+\t\t\tverifyPdbSignature();\n+\t\t}\n \t\tparsed = true;\n \t}\n \n@@ -550,18 +553,15 @@ private void processPdbContents(boolean skipValidation) throws PdbException, IOE\n \t\tcatch (SAXException e) {\n \t\t\tthrow new IOException(e.getMessage());\n \t\t}\n-\n-\t\tverifyPdbSignature(in);\n \t}\n \n \t/**\n \t * Check to see if GUID and age in XML file matches GUID/Signature and age of binary\n \t *\n-\t * @param in  InputStream for XML file\n \t * @throws IOException If an I/O error occurs\n \t * @throws PdbException If error parsing the PDB.XML data\n \t */\n-\tprivate void verifyPdbSignature(InputStream in) throws IOException, PdbException {\n+\tprivate void verifyPdbSignature() throws IOException, PdbException {\n \n \t\tXmlElement xmlelem;\n ",
    "output": "Fix PDB validation logic"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/debug/DbViewerProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/debug/DbViewerProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/debug/DbViewerProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/debug/DbViewerProvider.java\n@@ -41,7 +41,7 @@ public DbViewerProvider(Plugin plugin) {\n \t\tsetHelpLocation(new HelpLocation(plugin.getName(), \"DbViewer\"));\n \t}\n \n-\tvoid closeDatabase() {\n+\tpublic void closeDatabase() {\n \t\tif (comp != null) {\n \t\t\tcomp.closeDatabase();\n \t\t}\n@@ -53,7 +53,7 @@ void closeDatabase() {\n \t * @param databaseName the name of the database.\n \t * @param handle the DBHandle for the open database\n \t */\n-\tvoid openDatabase(String databaseName, DBHandle handle) {\n+\tpublic void openDatabase(String databaseName, DBHandle handle) {\n \t\tif (comp != null) {\n \t\t\tcomp.openDatabase(databaseName, handle);\n \t\t}",
    "output": "Fix compilation errors."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/nodes/ExportsCategoryNode.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/nodes/ExportsCategoryNode.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/nodes/ExportsCategoryNode.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symboltree/nodes/ExportsCategoryNode.java\n@@ -24,7 +24,6 @@\n import ghidra.program.model.address.AddressIterator;\n import ghidra.program.model.listing.Program;\n import ghidra.program.model.symbol.Symbol;\n-import ghidra.program.model.symbol.SymbolType;\n import ghidra.util.task.TaskMonitor;\n import resources.ResourceManager;\n \n@@ -69,11 +68,9 @@ public Icon getIcon(boolean expanded) {\n \n \t@Override\n \tprotected boolean supportsSymbol(Symbol symbol) {\n-\t\tSymbolType symbolType = symbol.getSymbolType();\n-\t\tif (symbolType == symbolCategory.getSymbolType()) {\n-\t\t\treturn true;\n+\t\tif (!symbol.isPrimary()) {\n+\t\t\treturn false;\n \t\t}\n-\n \t\treturn symbol.isExternalEntryPoint() || symbol.getParentSymbol().isExternalEntryPoint();\n \t}\n }",
    "output": "Fix symbol tree to prevent non-entry point symbols from appearing in the Exports node"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/hover/ScalarOperandListingHover.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/hover/ScalarOperandListingHover.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/hover/ScalarOperandListingHover.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/hover/ScalarOperandListingHover.java\n@@ -100,6 +100,9 @@ private Object getOperand(OperandFieldLocation loc, Instruction instruction) {\n \t\tInstructionPrototype prototype = instruction.getPrototype();\n \t\tList<Object> list =\n \t\t\tprototype.getOpRepresentationList(opIndex, instruction.getInstructionContext());\n+\t\tif (list == null) {\n+\t\t\treturn null;\n+\t\t}\n \t\treturn list.get(loc.getSubOperandIndex());\n \t}\n ",
    "output": "Fix NullPointerException in ScalarOperandListingHover"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symtable/ReferenceProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symtable/ReferenceProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symtable/ReferenceProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/symtable/ReferenceProvider.java\n@@ -28,6 +28,7 @@\n import ghidra.program.model.listing.Program;\n import ghidra.program.model.symbol.Symbol;\n import ghidra.util.HelpLocation;\n+import ghidra.util.Swing;\n import ghidra.util.table.GhidraTable;\n import resources.ResourceManager;\n \n@@ -141,7 +142,11 @@ public void componentHidden() {\n \t@Override\n \tpublic void componentShown() {\n \t\treferenceKeyModel.setProgram(plugin.getProgram());\n-\t\tplugin.openSymbolProvider();\n+\n+\t\t// Note: this is a bit of a hack--if we do this during a tool's restore process, then\n+\t\t//       there is a chance that the Symbol Provider has not yet been re-loaded.   This\n+\t\t//       is only needed due to the odd dependency of this provider upon the Symbol Provider.\n+\t\tSwing.runLater(plugin::openSymbolProvider);\n \t}\n \n \t@Override",
    "output": "Fix exception when restoring a tool that had the Symbol Provider and References Provider visible"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/debug/DbViewerComponent.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/debug/DbViewerComponent.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/debug/DbViewerComponent.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/debug/DbViewerComponent.java\n@@ -96,8 +96,8 @@ synchronized void closeDatabase() {\n \t\t\ttableStats.clear();\n \t\t\tdbh = null;\n \t\t\tdbListener = null;\n-\t\t\tinvalidate();\n-\t\t\tgetParent().repaint();\n+\n+\t\t\trevalidate();\n \t\t}\n \t}\n \n@@ -127,10 +127,10 @@ synchronized void dispose() {\n \n \t/**\n \t * Get the statistics for the specified table.\n-\t * @param table\n+\t * @param table the table\n \t * @return arrays containing statistics. Element 0 provides\n-\t * statsitics for primary table, element 1 provides combined\n-\t * statsitics for all index tables.  Remaining array elements \n+\t * statistics for primary table, element 1 provides combined\n+\t * statistics for all index tables.  Remaining array elements \n \t * should be ignored since they have been combined into element 1.\n \t */\n \tprivate TableStatistics[] getStats(Table table) {\n@@ -189,9 +189,7 @@ private void updateTable() {\n \t\t\tsouthPanel = createSouthPanel(t.table);\n \t\t\tadd(southPanel, BorderLayout.CENTER);\n \t\t}\n-\t\t//invalidate();\n-\t\tvalidate();\n-\t\t//repaint();\n+\t\trevalidate();\n \t}\n \n \tprivate JPanel createSouthPanel(Table table) {",
    "output": "Fix NPE in db viewer"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/disassembler/Hcs12DisassembleAction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/disassembler/Hcs12DisassembleAction.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/disassembler/Hcs12DisassembleAction.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/disassembler/Hcs12DisassembleAction.java\n@@ -24,6 +24,7 @@\n import ghidra.program.model.address.Address;\n import ghidra.program.model.lang.*;\n import ghidra.program.model.listing.Program;\n+import ghidra.util.HelpLocation;\n \n \n /**\n@@ -39,6 +40,11 @@ public Hcs12DisassembleAction(DisassemblerPlugin plugin, String groupName, boole\n \t\t\n \t\tthis.plugin = plugin;\n \t\tthis.disassembleXgate = disassembleXgate;\n+\n+\t\t// Need to override the default help location since this action doesn't have its own\n+\t\t// section in the help.\n+\t\tHelpLocation location = new HelpLocation(\"DisassemblerPlugin\", \"Disassemble\");\n+\t\tthis.setHelpLocation(location);\n \t\t\n \t\tsetPopupMenuData( new MenuData( \n \t\t\tnew String[]{\"Disassemble - \"+ (disassembleXgate ? \"XGate\" : \"HCS12\") }, ",
    "output": "Add help location to HCS12DisassembleAction"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableUtilities.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableUtilities.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableUtilities.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/VariableUtilities.java\n@@ -415,6 +415,8 @@ private static Varnode expandVarnode(Varnode varnode, int sizeIncrease,\n \t\t\t\t\t\t\" bytes: \" + curStorage.toString());\n \t\t\t\t}\n \t\t\t}\n+\t\t\t\n+\t\t\tvnAddr = newReg.getAddress();\n \t\t\tif (bigEndian) {\n \t\t\t\tvnAddr = vnAddr.add(newReg.getMinimumByteSize() - size);\n \t\t\t\treturn new Varnode(vnAddr, size);",
    "output": "Fix for return storage commit"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/CommitParamsAction.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/CommitParamsAction.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/CommitParamsAction.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/CommitParamsAction.java\n@@ -90,8 +90,9 @@ public void actionPerformed(ActionContext context) {\n \t\t\tif (hfunc.getFunction().getSignatureSource() == SourceType.USER_DEFINED) {\n \t\t\t\tsource = SourceType.USER_DEFINED;\n \t\t\t}\n-\t\t\tHighFunctionDBUtil.commitParamsToDatabase(hfunc, true, source);\n+\t\t\t\n \t\t\tHighFunctionDBUtil.commitReturnToDatabase(hfunc, source);\n+\t\t\tHighFunctionDBUtil.commitParamsToDatabase(hfunc, true, source);\n \t\t}\n \t\tcatch (DuplicateNameException e) {\n \t\t\tthrow new AssertException(\"Unexpected exception\", e);",
    "output": "Fix for return storage commit"
  },
  {
    "input": "diff --git a/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/remote/GhidraServer.java b/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/remote/GhidraServer.java\n--- a/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/remote/GhidraServer.java\n+++ b/Ghidra/Features/GhidraServer/src/main/java/ghidra/server/remote/GhidraServer.java\n@@ -479,7 +479,7 @@ private static File getServerCfgFile(String cfgFileName) {\n \n \t\tResourceFile serverRoot = new ResourceFile(Application.getInstallationDirectory(),\n \t\t\tSystemUtilities.isInDevelopmentMode() ? \"ghidra/Ghidra/RuntimeScripts/Common/server\"\n-\t\t\t\t\t: \"ghidra/server\");\n+\t\t\t\t\t: \"server\");\n \t\tif (serverRoot == null || serverRoot.getFile(false) == null) {\n \t\t\tSystem.err.println(\n \t\t\t\t\"Failed to resolve installation root directory!: \" + serverRoot.getAbsolutePath());",
    "output": "Fix error with ghidra server relative path"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/CodeBrowserOptionsTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/CodeBrowserOptionsTest.java\n--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/CodeBrowserOptionsTest.java\n+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/codebrowser/CodeBrowserOptionsTest.java\n@@ -184,6 +184,7 @@ public void testOptionsHeaders() throws Exception {\n \t\tassertEquals(\"Function Signature Field\", groups[idx++]);\n \t\tassertEquals(\"Labels Field\", groups[idx++]);\n \t\tassertEquals(\"Mnemonic Field\", groups[idx++]);\n+\t\tassertEquals(\"Mouse\", groups[idx++]);\n \t\tassertEquals(\"Operands Field\", groups[idx++]);\n \t\tassertEquals(\"Pcode Field\", groups[idx++]);\n \t\tassertEquals(\"Plate Comment\", groups[idx++]);",
    "output": "Fix test problems"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeBrowserPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeBrowserPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeBrowserPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/CodeBrowserPlugin.java\n@@ -939,12 +939,6 @@ public boolean isEnabledForContext(ActionContext context) {\n \t\t\t\"SelectUtils\"));\n \t\ttableFromSelectionAction.setHelpLocation(\n \t\t\tnew HelpLocation(\"CodeBrowserPlugin\", \"Selection_Table\"));\n-\n-\t\t// don't add the actions initially if the service isn't there\n-\t\tTableService tableService = tool.getService(TableService.class);\n-\t\tif (tableService != null) {\n-\t\t\ttool.addAction(tableFromSelectionAction);\n-\t\t}\n \t}\n \n \tprivate GhidraProgramTableModel<Address> createTableModel(CodeUnitIterator iterator,",
    "output": "Remove code causing duplicate table action to be added to tool"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/x86AssemblyTest.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/x86AssemblyTest.java\n--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/x86AssemblyTest.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/app/plugin/assembler/sleigh/x86AssemblyTest.java\n@@ -250,7 +250,7 @@ public void testAssembly_CALL_0x0041bb80() {\n \n \t@Test\n \tpublic void testAssembly_AND_mRBP_n0x8m_0xffff0000() {\n-\t\tassertOneCompatRestExact(\"AND qword ptr [RBP + -0x8],0xffff0000\",\n+\t\tassertOneCompatRestExact(\"AND qword ptr [RBP + -0x8],-0x10000\",\n \t\t\t\"48:81:65:f8:00:00:ff:ff\");\n \t}\n ",
    "output": "Fix x86 test."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/processors/ShowInstructionInfoPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/processors/ShowInstructionInfoPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/processors/ShowInstructionInfoPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/processors/ShowInstructionInfoPlugin.java\n@@ -218,8 +218,8 @@ URL getValidUrl(ProgramActionContext context, Language language) throws IOExcept\n \n \t\tString pageNumber = entry.getPageNumber();\n \t\tString fixedFilename = filename.replace(File.separatorChar, '/');\n-\t\treturn new URL(\"file\", \"\",\n-\t\t\tfixedFilename + (pageNumber == null ? \"\" : \"#page=\" + pageNumber));\n+\t\treturn new URL(\n+\t\t\t\"file://\" + fixedFilename + (pageNumber == null ? \"\" : \"#page=\" + pageNumber));\n \t}\n \n \tManualEntry locateManualEntry(ProgramActionContext context, Language language) {",
    "output": "Fix problem displaying processor manuals in Windows Firefox."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/ListingHighlightProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/ListingHighlightProvider.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/ListingHighlightProvider.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/codebrowser/ListingHighlightProvider.java\n@@ -215,12 +215,19 @@ private Pattern createRegisterPattern(Register register, String... highlightStri\n \n \t\tList<String> registerNames = gatherRegisterNames(new ArrayList<String>(), register);\n \n-\t\tStringBuilder buffy = new StringBuilder();\n \t\tfor (String s : highlightStrings) {\n \t\t\tif (s != null) {\n-\t\t\t\tbuffy.append(\"\\\\Q\").append(s).append(\"\\\\E|\");\n+\t\t\t\tregisterNames.add(s);\n \t\t\t}\n \t\t}\n+\n+\t\t// Prioritize exact register matches by ensuring that the longest register name gets\n+\t\t// matched first\n+\t\tCollections.sort(registerNames, (a, b) -> {\n+\t\t\treturn Integer.valueOf(b.length()).compareTo(Integer.valueOf(a.length()));\n+\t\t});\n+\n+\t\tStringBuilder buffy = new StringBuilder();\n \t\tfor (String name : registerNames) {\n \t\t\tbuffy.append(\"\\\\Q\").append(name).append(\"\\\\E|\");\n \t\t}",
    "output": "Fix register highlight issue."
  },
  {
    "input": "diff --git a/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/launchers/GhidraLaunchTabGroup.java b/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/launchers/GhidraLaunchTabGroup.java\n--- a/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/launchers/GhidraLaunchTabGroup.java\n+++ b/GhidraBuild/EclipsePlugins/GhidraDev/GhidraDevPlugin/src/main/java/ghidradev/ghidraprojectcreator/launchers/GhidraLaunchTabGroup.java\n@@ -48,6 +48,7 @@ public void createTabs(ILaunchConfigurationDialog dialog, String mode) {\n \t\ttabs.add(getJavaMainTab());\n \t\ttabs.add(getUserDefinedArgumentsTab());\n \t\ttabs.add(new JavaClasspathTab());\n+\t\ttabs.add(new EnvironmentTab());\n \t\ttabs.add(getCommonTab());\n \n \t\t// Set the tabs",
    "output": "Add \"Environments\" tab to Ghidra run configuration in GhidraDev."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/mem/MemBlockDBTest.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/mem/MemBlockDBTest.java\n--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/mem/MemBlockDBTest.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/database/mem/MemBlockDBTest.java\n@@ -359,6 +359,27 @@ public void testJoinNonConsecutiveFileBytes() throws Exception {\n \t\tassertEquals(10, sourceInfo.getLength());\n \t}\n \n+\t@Test\n+\tpublic void testJoinNonConsecutiveBlocks() throws Exception {\n+\t\tFileBytes fileBytes = createFileBytes();\n+\t\tMemoryBlock block1 = createFileBytesBlock(fileBytes, addr(0), 25, 10);\n+\t\tMemoryBlock block2 = createFileBytesBlock(fileBytes, addr(20), 70, 10);\n+\t\tMemoryBlock block3 = createFileBytesBlock(fileBytes, addr(10), 0, 10);\n+\n+\t\tMemoryBlock block = mem.join(block1, block3);\n+\t\tblock = mem.join(block1, block2);\n+\t\tassertEquals(1, mem.getBlocks().length);\n+\t\tassertEquals(30, block.getSize());\n+\t\tassertEquals(addr(0), block.getStart());\n+\t\tList<MemoryBlockSourceInfo> sourceInfos = block.getSourceInfos();\n+\t\tassertEquals(3, sourceInfos.size());\n+\n+\t\tfor (int i = 0; i < block.getSize(); i++) {\n+\t\t\tmem.getByte(addr(i));\n+\t\t}\n+\t}\n+\n+\n \t@Test\n \tpublic void testJoinFileBytesBlockAndBufferBlock() throws Exception {\n \t\tFileBytes fileBytes = createFileBytes();",
    "output": "Add junit test for previous memory block bug"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n@@ -15,7 +15,7 @@\n  */\n package docking.widgets.fieldpanel;\n \n-import static docking.widgets.EventTrigger.INTERNAL_ONLY;\n+import static docking.widgets.EventTrigger.*;\n \n import java.awt.*;\n import java.awt.event.*;\n@@ -1888,7 +1888,7 @@ private boolean doSetCursorPosition(BigInteger index, int fieldNum, int row, int\n \t\t\tcursorPosition.fieldNum = fieldNum;\n \t\t\tcursorPosition.row = row;\n \t\t\tcursorPosition.col = col;\n-\t\t\tlastX = currentField.getStartX();\n+\t\t\tlastX = currentField.getX(row, col);\n \t\t\tnotifyCursorChanged(trigger);\n \t\t\treturn true;\n \t\t}",
    "output": "Fix problem causing incorrect cursor position to be set"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/MemoryBlockUtils.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/MemoryBlockUtils.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/MemoryBlockUtils.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/MemoryBlockUtils.java\n@@ -230,6 +230,8 @@ public static MemoryBlock createInitializedBlock(Program program, boolean isOver\n \t\t\tcatch (MemoryConflictException e) {\n \t\t\t\tblock = program.getMemory().createInitializedBlock(name, start, fileBytes, offset,\n \t\t\t\t\tlength, true);\n+\t\t\t\tlog.appendMsg(\"Conflict attempting to create memory block: \" + name +\n+\t\t\t\t\t\" at address \" + start.toString() + \" Created block in new overlay instead\");\n \t\t\t}\n \t\t}\n \t\tcatch (LockException | DuplicateNameException | MemoryConflictException e) {",
    "output": "Add log message when importer moves block to overlay because of conflict"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java b/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java\n@@ -191,21 +191,21 @@ public ComponentPlaceholder getComponentWindowingPlaceholder() {\n \t * @return the provider\n \t */\n \tpublic ComponentProvider getComponentProvider() {\n-\t\tif (componentInfo == null) {\n+\t\tif (placeholder == null) {\n \t\t\treturn null;\n \t\t}\n-\t\treturn componentInfo.getProvider();\n+\t\treturn placeholder.getProvider();\n \t}\n \n \t/**\n \t * Returns the docking window manager that owns this component\n \t * @return the manager\n \t */\n \tpublic DockingWindowManager getDockingWindowManager() {\n-\t\tif (componentInfo == null) {\n+\t\tif (placeholder == null) {\n \t\t\treturn null;\n \t\t}\n-\t\treturn componentInfo.getNode().getDockingWindowManager();\n+\t\treturn placeholder.getNode().getDockingWindowManager();\n \t}\n \n \t@Override",
    "output": "Fix merge issues."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemService.java b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemService.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemService.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/formats/gfilesystem/FileSystemService.java\n@@ -15,7 +15,10 @@\n  */\n package ghidra.formats.gfilesystem;\n \n-import java.io.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n import java.util.List;\n \n import org.apache.commons.io.FilenameUtils;\n@@ -394,7 +397,8 @@ private String getMD5(FSRL fsrl, TaskMonitor monitor) throws CancelledException,\n \t * @return {@link FSRL} pointing to the same file, never null\n \t */\n \tpublic FSRL getLocalFSRL(File f) {\n-\t\treturn localFS.getFSRL().withPath(FilenameUtils.separatorsToUnix(f.getPath()));\n+\t\treturn localFS.getFSRL().withPath(\n+\t\t\tFSUtilities.appendPath(\"/\", FilenameUtils.separatorsToUnix(f.getPath())));\n \t}\n \n \t/**",
    "output": "Fix FSRL path generation on windows. FSRLs were being generated without a leading \"/\". When using batch import on a local directory, the mismatch between a correct FSRL and a FSRL with a missing \"/\" caused truncated folder names to be created."
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java\n@@ -246,6 +246,10 @@ public void setLocation(ProgramLocation location, ViewerPosition viewerPosition)\n \n \tprivate boolean goToFunctionSignature(Address address) {\n \n+\t\tif (!decompileData.hasDecompileResults()) {\n+\t\t\treturn false;\n+\t\t}\n+\n \t\tAddress entry = decompileData.getFunction().getEntryPoint();\n \t\tif (!entry.equals(address)) {\n \t\t\treturn false;",
    "output": "Fix exception seen when creating a function and then pressing undo"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java\n@@ -298,6 +298,12 @@ else if (subel.getName().equals(\"override\")) {\n \t\t\t\t// Do nothing with override at the moment\n \t\t\t\tparser.discardSubTree();\n \t\t\t}\n+\t\t\telse if (subel.getName().equals(\"scope\")) {\n+\t\t\t\t// This must be a subscope of the local scope\n+\t\t\t\t// Currently this can only hold static variables of the function\n+\t\t\t\t// which ghidra already knows about\n+\t\t\t\tparser.discardSubTree();\n+\t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new PcodeXMLException(\"Unknown tag in function: \" + subel.getName());\n \t\t\t}",
    "output": "Fix for \"Unknown function tag: scope\" error"
  },
  {
    "input": "diff --git a/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/server/remote/SSHKeyUtil.java b/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/server/remote/SSHKeyUtil.java\n--- a/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/server/remote/SSHKeyUtil.java\n+++ b/Ghidra/Test/IntegrationTest/src/test.slow/java/ghidra/server/remote/SSHKeyUtil.java\n@@ -22,15 +22,15 @@\n \n import ch.ethz.ssh2.packets.TypesWriter;\n \n-class SSHKeyUtil {\n+public class SSHKeyUtil {\n \n \t/**\n \t * Generate private/public SSH keys for test purposes using RSA algorithm.\n \t * @return kay pair array suitable for writing to SSH private and public \n \t * key files ([0] corresponds to private key, [1] corresponds to public key)\n \t * @throws NoSuchAlgorithmException\n \t */\n-\tstatic String[] generateSSHKeys() throws NoSuchAlgorithmException {\n+\tpublic static String[] generateSSHKeys() throws NoSuchAlgorithmException {\n \n \t\tKeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\");\n \t\tgenerator.initialize(2048);",
    "output": "Make sshkeyutil methods public"
  },
  {
    "input": "diff --git a/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/elf/relocation/AARCH64_ElfRelocationHandler.java b/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/elf/relocation/AARCH64_ElfRelocationHandler.java\n--- a/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/elf/relocation/AARCH64_ElfRelocationHandler.java\n+++ b/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/elf/relocation/AARCH64_ElfRelocationHandler.java\n@@ -142,7 +142,9 @@ public void relocate(ElfRelocationContext elfRelocationContext, ElfRelocation re\n \t\t\t\tbreak;\n \t\t\t}\n \n+\t\t\t// B:  ((S+A-P) >> 2) & 0x3ffffff.\n \t\t\t// BL: ((S+A-P) >> 2) & 0x3ffffff\n+\t\t\tcase AARCH64_ElfRelocationConstants.R_AARCH64_JUMP26:\n \t\t\tcase AARCH64_ElfRelocationConstants.R_AARCH64_CALL26: {\n \t\t\t\tint oldValue = memory.getInt(relocationAddress, isBigEndianInstructions);\n \t\t\t\tnewValue = (symbolValue + addend);",
    "output": "Add R_AARCH64_JUMP26 relocation handler"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functioncompare/MappedFunctionComparisonPanel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functioncompare/MappedFunctionComparisonPanel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functioncompare/MappedFunctionComparisonPanel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/functioncompare/MappedFunctionComparisonPanel.java\n@@ -79,6 +79,7 @@ private void establishLeftFunctions(int leftFunctionIndex) {\n \t\tFunction[] leftSortedFunctions = getSortedFunctions(leftFunctionSet);\n \t\tleftWrappedFunctions = getWrappedFunctions(leftSortedFunctions);\n \t\tleftIndex = (leftFunctionIndex < leftSortedFunctions.length) ? leftFunctionIndex : 0;\n+\t\tsetLeftFunction(leftSortedFunctions[leftIndex]);\n \t}\n \n \tprivate void adjustRightFunctions(int rightFunctionIndex) {",
    "output": "Fix function code compare bug"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/framework/ApplicationInformationDisplayFactory.java b/Ghidra/Framework/Docking/src/main/java/docking/framework/ApplicationInformationDisplayFactory.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/framework/ApplicationInformationDisplayFactory.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/framework/ApplicationInformationDisplayFactory.java\n@@ -101,7 +101,7 @@ public static HelpLocation createHelpLocation() {\n \t}\n \n \tprotected String doCreateSplashScreenTitle() {\n-\t\treturn Application.getName();\n+\t\treturn Application.getName() + \" \" + Application.getApplicationVersion();\n \t}\n \n \tprotected String doCreateAboutTitle() {",
    "output": "Upgrade generic application name to include version"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/interpreter/InterpreterPanel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/interpreter/InterpreterPanel.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/interpreter/InterpreterPanel.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/interpreter/InterpreterPanel.java\n@@ -679,14 +679,14 @@ public int read(byte[] b, int off, int len) throws IOException {\n \t\t\t}\n \n \t\t\tif (bytes != null) {\n-\t\t\t\tint length = Math.min(bytes.length, len);\n-\t\t\t\tSystem.arraycopy(bytes, 0, b, off, length);\n-\t\t\t\tif (length == bytes.length) {\n+\t\t\t\tint length = Math.min(bytes.length - position, len);\n+\t\t\t\tSystem.arraycopy(bytes, position, b, off, length);\n+\t\t\t\tif (position + length == bytes.length) {\n \t\t\t\t\tposition = 0;\n \t\t\t\t\tbytes = null;\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tposition = b.length;\n+\t\t\t\t\tposition += length;\n \t\t\t\t}\n \t\t\t\treturn length;\n \t\t\t}",
    "output": "Fix Python Interpreter OutOfMemoryError when reading in large strings longer than 8192 characters."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldCacheLocalSymbolsInfo.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldCacheLocalSymbolsInfo.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldCacheLocalSymbolsInfo.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/macho/dyld/DyldCacheLocalSymbolsInfo.java\n@@ -80,7 +80,7 @@ public DyldCacheLocalSymbolsInfo(BinaryReader reader, DyldArchitecture architect\n \t\tnlistList = new ArrayList<>(nlistCount);\n \t\tlocalSymbolsEntryList = new ArrayList<>(entriesCount);\n \n-\t\tis32bit = !(architecture.getCpuType() == CpuTypes.CPU_TYPE_ARM_64 &&\n+\t\tis32bit = !(architecture.getCpuType() == CpuTypes.CPU_TYPE_ARM_64 ||\n \t\t\tarchitecture.getCpuType() == CpuTypes.CPU_TYPE_X86_64);\n \t}\n ",
    "output": "Fix DYLD symbol address issue."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeAST.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeAST.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeAST.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeAST.java\n@@ -222,8 +222,12 @@ else if (vn.isFree())\n \t\t\treturn false;\n \t\tif (isInput() != vn.isInput())\n \t\t\treturn false;\n-\t\tif (def != null)\n-\t\t\treturn (def.getSeqnum().equals(vn.getDef().getSeqnum()));\n+\t\tif (def != null) {\n+\t\t\tPcodeOp vnDef = vn.getDef();\n+\t\t\tif (vnDef == null)\n+\t\t\t\treturn false;\n+\t\t\treturn (def.getSeqnum().equals(vnDef.getSeqnum()));\n+\t\t}\n \t\treturn true;\n \t}\n ",
    "output": "Add null check for def of other VarnodeAST in equals method"
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/test/java/ghidra/app/util/bin/format/pdb/PdbParserTest.java b/Ghidra/Features/PDB/src/test/java/ghidra/app/util/bin/format/pdb/PdbParserTest.java\n--- a/Ghidra/Features/PDB/src/test/java/ghidra/app/util/bin/format/pdb/PdbParserTest.java\n+++ b/Ghidra/Features/PDB/src/test/java/ghidra/app/util/bin/format/pdb/PdbParserTest.java\n@@ -540,7 +540,7 @@ public void testFindPdb9() throws Exception {\n \t\t\tFile pdb = PdbParserNEW.findPDB(testProgram, symbolsFolder.getAbsolutePath());\n \n \t\t\tassertNotNull(pdb);\n-\t\t\tassertEquals(pdb.getAbsolutePath(), pdb.getAbsolutePath());\n+\t\t\tassertEquals(pdbFile.getAbsolutePath(), pdb.getAbsolutePath());\n \t\t}\n \t\tcatch (PdbException pdbe) {\n \t\t\tfail(\"Unexpected PdbException!\");",
    "output": "Fix test which was has meaningless assertion It seems that small mistake slip due to copy-paste."
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/DecompilerClangTest.java b/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/DecompilerClangTest.java\n--- a/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/DecompilerClangTest.java\n+++ b/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/DecompilerClangTest.java\n@@ -18,6 +18,7 @@\n import static org.junit.Assert.*;\n \n import java.util.List;\n+import java.util.Set;\n \n import org.junit.Test;\n \n@@ -158,8 +159,7 @@ public void testDecompiler_CopyFromSymbolWithoutSelection() throws Exception {\n \n \tprivate void copy() {\n \n-\t\tString fullName = \"Copy (ClipboardPlugin)\";\n-\t\tList<DockingActionIf> actions = tool.getDockingActionsByFullActionName(fullName);\n+\t\tSet<DockingActionIf> actions = getActionsByOwnerAndName(tool, \"ClipboardPlugin\", \"Copy\");\n \t\tfor (DockingActionIf action : actions) {\n \t\t\tObject service = getInstanceField(\"clipboardService\", action);\n \t\t\tif (service.getClass().toString().contains(\"Decomp\")) {",
    "output": "Fix compilation error."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/protocol/ghidra/GhidraURL.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/protocol/ghidra/GhidraURL.java\n--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/protocol/ghidra/GhidraURL.java\n+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/protocol/ghidra/GhidraURL.java\n@@ -120,6 +120,9 @@ public static ProjectLocator getProjectStorageLocator(URL localProjectURL) {\n \t\tString path = localProjectURL.getPath();\n \t\tint index = path.lastIndexOf('/');\n \t\tString dirPath = path.substring(0, index);\n+\t\tif (dirPath.endsWith(\":\")) {\n+\t\t\tdirPath += \"/\";\n+\t\t}\n \t\tif (dirPath.indexOf(\":/\") == 2) {\n \t\t\tdirPath = dirPath.substring(1);\n \t\t\tdirPath = dirPath.replace('/', File.separatorChar);",
    "output": "Fix bad windows path when project lives in root windows directory."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeAST.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeAST.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeAST.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/VarnodeAST.java\n@@ -223,7 +223,7 @@ else if (vn.isFree())\n \t\tif (isInput() != vn.isInput())\n \t\t\treturn false;\n \t\tif (def != null)\n-\t\t\treturn (def.getSeqnum() == vn.getDef().getSeqnum());\n+\t\t\treturn (def.getSeqnum().equals(vn.getDef().getSeqnum()));\n \t\treturn true;\n \t}\n ",
    "output": "Fix equals method in VarnodeAST"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/FunctionParameterFieldLocation.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/FunctionParameterFieldLocation.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/FunctionParameterFieldLocation.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/FunctionParameterFieldLocation.java\n@@ -27,7 +27,7 @@ public class FunctionParameterFieldLocation extends FunctionSignatureFieldLocati\n \t/**\n \t * Construct a new FunctionParameterFieldLocation object.\n \t * \n-\t * @param the program of the location\n+\t * @param program the program of the location\n \t * @param locationAddr the address of the listing location (i.e., referent code unit)\n \t * @param functionAddr the function address\n \t * @param charOffset the position within the function signature string for this location.\n@@ -38,7 +38,10 @@ public FunctionParameterFieldLocation(Program program, Address locationAddr,\n \t\t\tAddress functionAddr, int charOffset, String signature, Parameter parameter) {\n \t\tsuper(program, locationAddr, functionAddr, charOffset, signature);\n \t\tthis.parameter = parameter;\n-\t\tthis.ordinal = parameter.getOrdinal();\n+\n+\t\t// note: the parameter can be null if it is deleted in the background while this\n+\t\t//       location is being created\n+\t\tthis.ordinal = parameter == null ? -1 : parameter.getOrdinal();\n \t}\n \n \t/**\n@@ -51,7 +54,7 @@ public FunctionParameterFieldLocation() {\n \t/**\n \t * Returns the parameter associated with this location.  This value can be null if the \n \t * parameters are deleted from the function associated with the address of the parameter.\n-\t * @return\n+\t * @return the parameter\n \t */\n \tpublic Parameter getParameter() {\n \t\treturn parameter;",
    "output": "Fix NPE possible when background thread is mutating the function"
  },
  {
    "input": "diff --git a/Ghidra/Processors/8051/ghidra_scripts/Update8051.java b/Ghidra/Processors/8051/ghidra_scripts/Update8051.java\n--- a/Ghidra/Processors/8051/ghidra_scripts/Update8051.java\n+++ b/Ghidra/Processors/8051/ghidra_scripts/Update8051.java\n@@ -49,7 +49,7 @@ public void run() throws Exception {\n \t\t\tprintln(\"No address spaces found for \" +SFR + \", \"+ BITS + \", \" + SFR_BITS + \".\");\n \t\t}\n \t\telse {\n-\t\t\tString str = (count > 1 ? \" symbol to update.\" : \" symbols to update.\"); \n+\t\t\tString str = (count > 1 ? \" symbols to update.\" : \" symbol to update.\"); \n \t\t\tprintln(\"Found \" + count + str);\n \t\t}\n     }",
    "output": "Upgrade Update8051.java flaw in logic"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/EmbeddedMediaAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/EmbeddedMediaAnalyzer.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/EmbeddedMediaAnalyzer.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/EmbeddedMediaAnalyzer.java\n@@ -126,8 +126,14 @@ private List<Address> scanForMedia(Program program, DataType dt, String mediaNam\n \t\t\t\t}\n \t\t\t\t// skip either the valid data that was found or skip one byte\n \t\t\t\t// then do the next search\n-\t\t\t\tstart = found.add(skipLen);\n-\t\t\t\tfound = memory.findBytes(start, end, mediaBytes, mask, true, monitor);\n+\t\t\t\ttry {\n+\t\t\t\t\tstart = found.add(skipLen);\n+\t\t\t\t\tfound = memory.findBytes(start, end, mediaBytes, mask, true, monitor);\n+\t\t\t\t}\n+\t\t\t\tcatch (AddressOutOfBoundsException e) {\n+\t\t\t\t\t// If media was at the very end of the address space, we will end up here\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n ",
    "output": "Fix AddressOutOfBoundsException in EmbeddedMediaAnalyer."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/util/table/PreviewDataTableCellRenderer.java b/Ghidra/Features/Base/src/main/java/ghidra/util/table/PreviewDataTableCellRenderer.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/util/table/PreviewDataTableCellRenderer.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/util/table/PreviewDataTableCellRenderer.java\n@@ -45,8 +45,12 @@ public Component getTableCellRendererComponent(GTableCellRenderingData data) {\n \t\tJTable table = data.getTable();\n \t\tboolean isSelected = data.isSelected();\n \n+\t\tif (value == null) {\n+\t\t\treturn renderer;\n+\t\t}\n+\n \t\t// this class is only meant to handle PreviewTableCellData objects\n-\t\tif (value != null && !(value instanceof PreviewTableCellData)) {\n+\t\tif (!(value instanceof PreviewTableCellData)) {\n \t\t\tMsg.error(this,\n \t\t\t\t\"Renderer is not being used on \" + PreviewTableCellData.class.getSimpleName());\n \t\t\treturn renderer;",
    "output": "Fix NPE in PreviewDataTableCellRenderer."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/GenericRunInfo.java b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/GenericRunInfo.java\n--- a/Ghidra/Framework/Generic/src/main/java/ghidra/framework/GenericRunInfo.java\n+++ b/Ghidra/Framework/Generic/src/main/java/ghidra/framework/GenericRunInfo.java\n@@ -165,14 +165,20 @@ public static List<File> getPreviousApplicationSettingsDirsByTime() {\n \n \t\tfor (File dir : getUserSettingsDirsByTime()) {\n \t\t\tString dirName = dir.getName();\n+\n+\t\t\t// Ignore the currently active user settings directory.\n+\t\t\t// By definition, it is not a previous one.\n+\t\t\tif (dirName.equals(Application.getUserSettingsDirectory().getName())) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\tif (dirName.startsWith(\".\")) {\n \t\t\t\tdirName = dirName.substring(1);\n \t\t\t}\n \t\t\ttry {\n-\t\t\t\tApplicationIdentifier identifier = new ApplicationIdentifier(dirName);\n-\t\t\t\tif (!identifier.equals(myIdentifier) &&\n-\t\t\t\t\tidentifier.getApplicationReleaseName().equalsIgnoreCase(\n-\t\t\t\t\t\tmyIdentifier.getApplicationReleaseName())) {\n+\t\t\t\t// The current release name has to match for it to be considered\n+\t\t\t\tif (new ApplicationIdentifier(dirName).getApplicationReleaseName().equals(\n+\t\t\t\t\tmyIdentifier.getApplicationReleaseName())) {\n \t\t\t\t\tapplicationSettiingsDirs.add(dir);\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix minor issue with finding old preference files in development mode."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/filechooser/GhidraFileChooser.java\n@@ -1282,6 +1282,7 @@ private void createNewFolder() {\n \t\tif (!created) {\n \t\t\tMsg.showError(this, rootPanel, \"Create Folder Failed\",\n \t\t\t\t\"Unable to create new folder in \" + currentDirectory());\n+\t\t\treturn;\n \t\t}\n \n \t\tGhidraFile folder =",
    "output": "Fix file chooser to not put bogus file in model after failure. If failed to create new folder due to filesystem permissions or whatever, don't put a bogus entry in the file list model."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/ObjectChooserDialog.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/ObjectChooserDialog.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/ObjectChooserDialog.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/dialogs/ObjectChooserDialog.java\n@@ -57,6 +57,10 @@ protected void dialogShown() {\n \t\ttable.focusFilter();\n \t}\n \n+\tpublic GTableWidget<T> getTable() {\n+\t\treturn table;\n+\t}\n+\n \tprivate JComponent buildWorkPanel() {\n \t\ttable = new GTableWidget<>(getTitle(), objectClass, methodsForColumns);\n \t\ttable.setData(choosableObjects);",
    "output": "Fix for compile error due to recent review tool fix"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StringDataInstance.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StringDataInstance.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StringDataInstance.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/StringDataInstance.java\n@@ -625,7 +625,7 @@ private static Endian getEndiannessFromBOM(byte[] bytes, int charSize) {\n \t */\n \tpublic String getStringRepresentation() {\n \n-\t\tif (isProbe() || isBadCharSize()) {\n+\t\tif (isProbe() || isBadCharSize() || !buf.isInitializedMemory()) {\n \t\t\treturn UNKNOWN;\n \t\t}\n ",
    "output": "Change string in uninitialized memory to render as \"??\""
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/HyperlinkComponent.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/HyperlinkComponent.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/HyperlinkComponent.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/HyperlinkComponent.java\n@@ -114,6 +114,7 @@ public void setText(final String text) {\n \t\t//              Also, if we call getPreferredSize(), then it will work.\n \t\t//\n \t\ttextPane.getPreferredSize();\n+\t\tgetPreferredSize();\n \t}\n \n \tpublic String getText() {",
    "output": "Fix hack with preferred size"
  },
  {
    "input": "diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java\n--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java\n+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java\n@@ -201,10 +201,10 @@ public Program getProgram() {\n \n \t@Override\n \tpublic ProgramLocation getLocation() {\n-\t\tif (currentLocation == null) {\n-\t\t\treturn plugin.getCurrentLocation(); // avoid returning null\n+\t\tif (currentLocation instanceof DecompilerLocation) {\n+\t\t\treturn currentLocation;\n \t\t}\n-\t\treturn currentLocation;\n+\t\treturn controller.getDecompilerPanel().getCurrentLocation();\n \t}\n \n \t@Override",
    "output": "Fix decompiler context to always return a DecompilerLocation or null"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingModelAdapter.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingModelAdapter.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingModelAdapter.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/viewer/listingpanel/ListingModelAdapter.java\n@@ -491,11 +491,12 @@ private void checkIndex(BigInteger index, AddressSet addressSet) {\n \t\tif (indexBefore == null) {\n \t\t\tindexBefore = BigInteger.ZERO;\n \t\t}\n-\t\tif (indexAfter.subtract(indexBefore)\n-\t\t\t.compareTo(addressToIndexMap.getMiniumUnviewableGapSize()) > 0) {\n+\t\tif (indexAfter.subtract(indexBefore).compareTo(\n+\t\t\taddressToIndexMap.getMiniumUnviewableGapSize()) > 0) {\n \t\t\tAddress start = addressToIndexMap.getAddress(indexBefore.add(BigInteger.ONE));\n \t\t\tAddress end = addressToIndexMap.getAddress(indexAfter.subtract(BigInteger.ONE));\n-\t\t\tif (start != null && end != null) {\n+\t\t\tif (start != null && end != null &&\n+\t\t\t\tstart.getAddressSpace().equals(end.getAddressSpace())) {\n \t\t\t\taddressSet.add(start, end);\n \t\t\t}\n \t\t}\n@@ -619,7 +620,7 @@ public FieldSelection getFieldSelection(ProgramSelection selection) {\n \n \t/**\n \t * Sets the addresses displayed by this model's listing.\n-\t * @param view the addresses. These must already be compatible with the program \n+\t * @param view the addresses. These must already be compatible with the program\n \t * associated with this model.\n \t */\n \tpublic void setAddressSet(AddressSetView view) {",
    "output": "Fix stack trace when deleting (large) memory section"
  },
  {
    "input": "diff --git a/GhidraDocs/GhidraClass/AdvancedDevelopment/contrib/gadc/ghidra_scripts/Lab5Script.java b/GhidraDocs/GhidraClass/AdvancedDevelopment/contrib/gadc/ghidra_scripts/Lab5Script.java\n--- a/GhidraDocs/GhidraClass/AdvancedDevelopment/contrib/gadc/ghidra_scripts/Lab5Script.java\n+++ b/GhidraDocs/GhidraClass/AdvancedDevelopment/contrib/gadc/ghidra_scripts/Lab5Script.java\n@@ -51,7 +51,7 @@ public void run() throws Exception {\n \t\t\tString comment =\n \t\t\t\t\"[\" + register.getName() + \"]=[\" + scalar.toString(16, false, false, \"\", \"\") + \"]\";\n \t\t\tsetEOLComment(instruction.getMinAddress(), comment);\n-\t\t\tinstruction = getNextInstruction();\n+\t\t\tinstruction = getInstructionAfter(instruction);\n \t\t}\n \t}\n }",
    "output": "Upgrade to commons-lang3-3.9 and corrected some eclipse project issues"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java\n@@ -118,8 +118,8 @@ public int hash(int reg) {\n \t\t\treg = SimpleCRC32.hashOneByte(reg, slot);\n \t\t\treg = SimpleCRC32.hashOneByte(reg, transtable[op.getOpcode()]);\n \t\t\tlong val = op.getSeqnum().getTarget().getOffset();\n-\t\t\tint sz = op.getSeqnum().getTarget().getPointerSize();\n-\t\t\tfor (int i = 0; i < sz; ++i) {\n+\t\t\tint sz = op.getSeqnum().getTarget().getSize();\n+\t\t\tfor (int i = 0; i < sz; i += 8) {\n \t\t\t\treg = SimpleCRC32.hashOneByte(reg, (int) val);\n \t\t\t\tval >>= 8;\n \t\t\t}",
    "output": "Fix for Github equates in 16-bit x86"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/DropDownTextField.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/DropDownTextField.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/DropDownTextField.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/DropDownTextField.java\n@@ -26,7 +26,7 @@\n \n import org.apache.commons.lang3.StringUtils;\n \n-import docking.widgets.label.GDLabel;\n+import docking.widgets.label.GDHtmlLabel;\n import generic.util.WindowUtilities;\n import ghidra.util.StringUtilities;\n import ghidra.util.SystemUtilities;\n@@ -156,7 +156,7 @@ protected ListSelectionModel createListSelectionModel() {\n \t}\n \n \tprotected void setPreviewPaneAttributes() {\n-\t\tpreviewLabel = new GDLabel();\n+\t\tpreviewLabel = new GDHtmlLabel();\n \t\tpreviewLabel.setOpaque(true);\n \t\tpreviewLabel.setBackground(TOOLTIP_WINDOW_BGCOLOR);\n \t\tpreviewLabel.setVerticalAlignment(SwingConstants.TOP);",
    "output": "Fix HTML for dropdown text field's preview window"
  },
  {
    "input": "diff --git a/Ghidra/Features/ProgramDiff/src/test.slow/java/ghidra/app/plugin/core/diff/DiffTestAdapter.java b/Ghidra/Features/ProgramDiff/src/test.slow/java/ghidra/app/plugin/core/diff/DiffTestAdapter.java\n--- a/Ghidra/Features/ProgramDiff/src/test.slow/java/ghidra/app/plugin/core/diff/DiffTestAdapter.java\n+++ b/Ghidra/Features/ProgramDiff/src/test.slow/java/ghidra/app/plugin/core/diff/DiffTestAdapter.java\n@@ -730,14 +730,14 @@ void invokeAndWait(DockingActionIf action) {\n \t\tperformAction(action);\n \t}\n \n-\tComponent getComponentOfType(Container container, Class<?> componentClass) {\n+\t<T extends Component> T getComponentOfType(Container container, Class<T> componentClass) {\n \t\tComponent[] comps = container.getComponents();\n \t\tfor (Component element : comps) {\n-\t\t\tif (element.getClass().isAssignableFrom(componentClass)) {\n-\t\t\t\treturn element;\n+\t\t\tif (componentClass.isInstance(element)) {\n+\t\t\t\treturn componentClass.cast(element);\n \t\t\t}\n \t\t\telse if (element instanceof Container) {\n-\t\t\t\tComponent subComp = getComponentOfType((Container) element, componentClass);\n+\t\t\t\tT subComp = getComponentOfType((Container) element, componentClass);\n \t\t\t\tif (subComp != null) {\n \t\t\t\t\treturn subComp;\n \t\t\t\t}",
    "output": "Fix a bad test Test was comparing classes backwards."
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n@@ -1431,11 +1431,13 @@ public void mouseWheelMoved(MouseWheelEvent e) {\n \n \t\t\t\tif (e.isShiftDown()) {\n \t\t\t\t\t// horizontal scroll (only move viewport)\n-                    if (viewport != null) {\n+\t\t\t\t\tif (viewport != null) {\n \t\t\t\t\t\tPoint pos = viewport.getViewPosition();\n-\t\t\t\t\t\tviewport.setViewPosition(new Point(Math.max(0, pos.x + scrollAmount), pos.y));\n+\t\t\t\t\t\tviewport.setViewPosition(\n+\t\t\t\t\t\t\tnew Point(Math.max(0, pos.x + scrollAmount), pos.y));\n \t\t\t\t\t}\n-\t\t\t\t} else {\n+\t\t\t\t}\n+\t\t\t\telse {\n \t\t\t\t\tscrollView(scrollAmount);\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix indentation issue"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/fieldpanel/FieldPanel.java\n@@ -1428,7 +1428,16 @@ public void mouseWheelMoved(MouseWheelEvent e) {\n \t\t\t}\n \t\t\telse {\n \t\t\t\thoverHandler.stopHover();\n-\t\t\t\tscrollView(scrollAmount);\n+\n+\t\t\t\tif (e.isShiftDown()) {\n+\t\t\t\t\t// horizontal scroll (only move viewport)\n+                    if (viewport != null) {\n+\t\t\t\t\t\tPoint pos = viewport.getViewPosition();\n+\t\t\t\t\t\tviewport.setViewPosition(new Point(Math.max(0, pos.x + scrollAmount), pos.y));\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tscrollView(scrollAmount);\n+\t\t\t\t}\n \t\t\t}\n \t\t\te.consume();\n \t\t}",
    "output": "Add Mac OS X horizontal scroll with mouse wheel (touch pad two fingers scrolling)"
  },
  {
    "input": "diff --git a/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsAddressAnalyzer.java b/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsAddressAnalyzer.java\n--- a/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsAddressAnalyzer.java\n+++ b/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsAddressAnalyzer.java\n@@ -707,9 +707,6 @@ public void optionsChanged(Options options, Program program) {\n \t\toptions.registerOption(OPTION_NAME_ASSUME_T9_ENTRY, OPTION_DEFAULT_ASSUME_T9_ENTRY, null,\n \t\t\tOPTION_DESCRIPTION_ASSUME_T9_ENTRY);\n \n-\t\toptions.registerOption(OPTION_NAME_ASSUME_T9_ENTRY, OPTION_DEFAULT_ASSUME_T9_ENTRY, null,\n-\t\t\tOPTION_DESCRIPTION_ASSUME_T9_ENTRY);\n-\n \t\toptions.registerOption(OPTION_NAME_RECOVER_GP, OPTION_DEFAULT_RECOVER_GP, null,\n \t\t\tOPTION_DESCRIPTION_RECOVER_GP);\n \n@@ -721,9 +718,6 @@ public void optionsChanged(Options options, Program program) {\n \t\tassumeT9EntryAddress =\n \t\t\toptions.getBoolean(OPTION_NAME_ASSUME_T9_ENTRY, OPTION_DEFAULT_ASSUME_T9_ENTRY);\n \n-\t\tassumeT9EntryAddress =\n-\t\t\toptions.getBoolean(OPTION_NAME_ASSUME_T9_ENTRY, OPTION_DEFAULT_ASSUME_T9_ENTRY);\n-\n \t\tdiscoverGlobalGPSetting =\n \t\t\toptions.getBoolean(OPTION_NAME_RECOVER_GP, OPTION_DEFAULT_RECOVER_GP);\n \t}",
    "output": "Remove duplicated options in MipsAddressAnalyzer"
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/DynamicHash.java\n@@ -118,8 +118,8 @@ public int hash(int reg) {\n \t\t\treg = SimpleCRC32.hashOneByte(reg, slot);\n \t\t\treg = SimpleCRC32.hashOneByte(reg, transtable[op.getOpcode()]);\n \t\t\tlong val = op.getSeqnum().getTarget().getOffset();\n-\t\t\tint sz = op.getSeqnum().getTarget().getPointerSize();\n-\t\t\tfor (int i = 0; i < sz; ++i) {\n+\t\t\tint sz = op.getSeqnum().getTarget().getSize();\n+\t\t\tfor (int i = 0; i < sz; i += 8) {\n \t\t\t\treg = SimpleCRC32.hashOneByte(reg, (int) val);\n \t\t\t\tval >>= 8;\n \t\t\t}",
    "output": "Fix for Github equates in 16-bit x86"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/VarnodeInfo.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/VarnodeInfo.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/VarnodeInfo.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/VarnodeInfo.java\n@@ -73,7 +73,7 @@ else if (address.isMemoryAddress()) {\n \t\t\ttype = VarnodeType.Memory;\n \t\t}\n \t\telse {\n-\t\t\tthrow new IllegalArgumentException(\"Illegal varode address type\");\n+\t\t\tthrow new IllegalArgumentException(\"Illegal varnode address type\");\n \t\t}\n \t}\n ",
    "output": "Fix varnode typo"
  },
  {
    "input": "diff --git a/Ghidra/Features/PDB/src/screen/java/help/screenshot/PdbScreenShots.java b/Ghidra/Features/PDB/src/screen/java/help/screenshot/PdbScreenShots.java\n--- a/Ghidra/Features/PDB/src/screen/java/help/screenshot/PdbScreenShots.java\n+++ b/Ghidra/Features/PDB/src/screen/java/help/screenshot/PdbScreenShots.java\n@@ -69,7 +69,7 @@ public void testSymbolServerURLDialog() throws Exception {\n \tpublic void testKnownSymbolServerURLsDialog() throws Exception {\n \n \t\tList<URLChoice> urlChoices = new ArrayList<URLChoice>();\n-\t\turlChoices.add(new URLChoice(\"Internet\", \"http://msdl.microsoft.com/download/symbols\"));\n+\t\turlChoices.add(new URLChoice(\"Internet\", \"https://msdl.microsoft.com/download/symbols\"));\n \t\turlChoices.add(new URLChoice(\"My Network\", \"https://my_symbol_server.my.org\"));\n \n \t\tfinal ObjectChooserDialog<URLChoice> urlDialog =",
    "output": "Use HTTPS for Microsoft symbol server URL To prevent man-in-the-middle attack, it's better to use HTTPS for symbol downloading whenever possible. WinDbg also uses https://msdl.microsoft.com/download/symbols by default."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeManagerDB.java\n@@ -1111,7 +1111,9 @@ private void replaceUsesInOtherDataTypes(DataType existingDt, DataType newDt) {\n \t\t}\n \t\telse {\n \t\t\tbuildSortedDataTypeList();\n-\t\t\tIterator<DataType> it = sortedDataTypes.iterator();\n+\t\t\t// make copy of sortedDataTypes list before iterating as dt.dataTypeReplaced may \n+\t\t\t// call back into this class and cause a modification to the sortedDataTypes list.\n+\t\t\tIterator<DataType> it = new ArrayList<>(sortedDataTypes).iterator();\n \t\t\twhile (it.hasNext()) {\n \t\t\t\tDataType dt = it.next();\n \t\t\t\tdt.dataTypeReplaced(existingDt, newDt);",
    "output": "Fix concurrent modification in DataTypeManagerDB"
  },
  {
    "input": "diff --git a/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java b/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java\n--- a/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java\n+++ b/Ghidra/Framework/Utility/src/main/java/ghidra/GhidraLauncher.java\n@@ -88,13 +88,7 @@ public static void main(String[] args) throws Exception {\n \tprivate static void addPatchPaths(List<String> pathList, Collection<ResourceFile> appRootDirs) {\n \n \t\tfor (ResourceFile rootDir : appRootDirs) {\n-\n-\t\t\tResourceFile dir = new ResourceFile(rootDir, \"bin\");\n-\t\t\tif (dir.exists()) {\n-\t\t\t\tpathList.add(dir.getAbsolutePath());\n-\t\t\t}\n-\n-\t\t\tResourceFile debugLibDir = new ResourceFile(rootDir, \"lib\");\n+\t\t\tResourceFile debugLibDir = new ResourceFile(rootDir, \"patch\");\n \t\t\tif (debugLibDir.exists()) {\n \t\t\t\tpathList.addAll(findJarsInDir(debugLibDir));\n \t\t\t}",
    "output": "Change patch directory and updated distribution.gradle to copy patch/README.txt"
  },
  {
    "input": "diff --git a/GhidraBuild/BuildFiles/JsonDoclet/src/main/java/JsonDoclet.java b/GhidraBuild/BuildFiles/JsonDoclet/src/main/java/JsonDoclet.java\n--- a/GhidraBuild/BuildFiles/JsonDoclet/src/main/java/JsonDoclet.java\n+++ b/GhidraBuild/BuildFiles/JsonDoclet/src/main/java/JsonDoclet.java\n@@ -39,8 +39,6 @@\n @SuppressWarnings(\"unchecked\")\n public class JsonDoclet implements Doclet {\n \n-\tprivate final Set<Modifier> ACCESS_LEVEL = Set.of(Modifier.PUBLIC);\n-\n \tprivate Reporter log;\n \tprivate File destDir;\n \n@@ -122,8 +120,7 @@ public boolean run(DocletEnvironment env) {\n \t\t//@formatter:off\n \t\tElementFilter.typesIn(docEnv.getIncludedElements())\n \t\t\t.stream()\n-\t\t\t.filter(el -> el.getModifiers().containsAll(ACCESS_LEVEL))\n-\t\t\t.filter(el -> el.getKind().equals(ElementKind.CLASS))\n+\t\t\t.filter(el -> el.getKind().equals(ElementKind.CLASS) || el.getKind().equals(ElementKind.INTERFACE))\n \t\t\t.forEach(el -> writeJsonToFile(classToJson(el), el.getQualifiedName()));\n \t\t//@formatter:on\n \n@@ -211,9 +208,6 @@ private void processFieldAndMethodAttributes(TypeElement classElement, JSONObjec\n \t\tJSONArray methodArray = new JSONArray();\n \n \t\tfor (Element el : classElement.getEnclosedElements()) {\n-\t\t\tif (!el.getModifiers().containsAll(ACCESS_LEVEL)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n \n \t\t\tJSONObject obj = new JSONObject();\n \t\t\tobj.put(\"name\", el.getSimpleName().toString());",
    "output": "Add in interfaces and package-level stuff to jsondocs."
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/exporter/IntelHexExporter.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/exporter/IntelHexExporter.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/exporter/IntelHexExporter.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/exporter/IntelHexExporter.java\n@@ -302,7 +302,7 @@ public RecordSizeComponent(int recordSize) {\n \t\t\tsetLayout(new BorderLayout());\n \t\t\t\n \t\t\tinput = new HintTextField(Integer.toString(recordSize), false, new BoundedIntegerVerifier());\n-\t\t\tdropCb = new JCheckBox(\"Drop Extra Bytes\");\n+\t\t\tdropCb = new JCheckBox(\"Align To Record Size\");\n \t\t\t\n \t\t\tinput.setText(Integer.toString(recordSize));\n \t\t\t",
    "output": "Change label on intel hex option to be intelligible"
  },
  {
    "input": "diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/misc/MyProgramChangesDisplayPlugin.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/misc/MyProgramChangesDisplayPlugin.java\n--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/misc/MyProgramChangesDisplayPlugin.java\n+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/misc/MyProgramChangesDisplayPlugin.java\n@@ -242,6 +242,10 @@ private void disposeMarkerSets(Program program) {\n \tpublic void dispose() {\n \n \t\tworker.dispose();\n+\t\tif (currentProgram != null) {\n+\t\t\tcurrentProgram.removeTransactionListener(transactionListener);\n+\t\t\tcurrentProgram.removeListener(this);\n+\t\t}\n \n \t\ttool.getProject().getProjectData().removeDomainFolderChangeListener(folderListener);\n ",
    "output": "Fix exception when MyProgramChangesDisplayPlugin is uninstalled."
  },
  {
    "input": "diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeDataTypeManager.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeDataTypeManager.java\n--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeDataTypeManager.java\n+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/PcodeDataTypeManager.java\n@@ -261,10 +261,7 @@ public StringBuilder buildTypeRef(DataType type, int size) {\n \t\tif (type instanceof Array) {\n \t\t\treturn buildType(type, size);\n \t\t}\n-\t\tif (type instanceof FunctionDefinition) {\n-\t\t\treturn buildType(type, size);\n-\t\t}\n-\t\tif (type.getLength() <= 0) {\n+\t\tif (!(type instanceof FunctionDefinition) && type.getLength() <= 0) {\n \t\t\treturn buildType(type, size);\n \t\t}\n \t\tStringBuilder resBuf = new StringBuilder();\n@@ -541,7 +538,7 @@ public StringBuilder buildType(DataType type, int size) {\n \t\t}\n \t\tresBuf.append(\"<type\");\n \t\tif ((type instanceof Pointer) || (type instanceof Array) ||\n-\t\t\t(type instanceof FunctionDefinition) || (type.getLength() <= 0)) {\n+\t\t\t(!(type instanceof FunctionDefinition) && type.getLength() <= 0)) {\n \t\t\tSpecXmlUtils.encodeStringAttribute(resBuf, \"name\", \"\");\n \t\t}\n \t\telse {",
    "output": "Fix for"
  }
]