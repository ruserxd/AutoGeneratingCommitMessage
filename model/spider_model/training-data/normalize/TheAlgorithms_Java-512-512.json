[
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/datastructures/queues/DequeTest.java b/src/test/java/com/thealgorithms/datastructures/queues/DequeTest.java\n--- a/src/test/java/com/thealgorithms/datastructures/queues/DequeTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/queues/DequeTest.java\n@@ -87,4 +87,38 @@ void testToString() {\n         deque.addFirst(5);\n         assertEquals(\"Head -> 5 <-> 10 <-> 20 <- Tail\", deque.toString());\n     }\n+\n+    @Test\n+    void testAlternatingAddRemove() {\n+        Deque<Integer> deque = new Deque<>();\n+        deque.addFirst(1);\n+        deque.addLast(2);\n+        deque.addFirst(0);\n+        assertEquals(0, deque.pollFirst());\n+        assertEquals(2, deque.pollLast());\n+        assertEquals(1, deque.pollFirst());\n+        org.junit.jupiter.api.Assertions.assertTrue(deque.isEmpty());\n+    }\n+\n+    @Test\n+    void testSizeAfterOperations() {\n+        Deque<Integer> deque = new Deque<>();\n+        assertEquals(0, deque.size());\n+        deque.addFirst(1);\n+        deque.addLast(2);\n+        deque.addFirst(3);\n+        assertEquals(3, deque.size());\n+        deque.pollFirst();\n+        deque.pollLast();\n+        assertEquals(1, deque.size());\n+    }\n+\n+    @Test\n+    void testNullValues() {\n+        Deque<String> deque = new Deque<>();\n+        deque.addFirst(null);\n+        assertNull(deque.peekFirst());\n+        assertNull(deque.pollFirst());\n+        org.junit.jupiter.api.Assertions.assertTrue(deque.isEmpty());\n+    }\n }",
    "output": "Improve `DequeTest` * testing: improving DequeTest * testing: redundant case * testing: fix to many static imports * testing: add more test cases"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/divideandconquer/CountingInversionsTest.java b/src/test/java/com/thealgorithms/divideandconquer/CountingInversionsTest.java\n--- a/src/test/java/com/thealgorithms/divideandconquer/CountingInversionsTest.java\n+++ b/src/test/java/com/thealgorithms/divideandconquer/CountingInversionsTest.java\n@@ -29,4 +29,35 @@ public void testAllInversions() {\n         int[] arr = {5, 4, 3, 2, 1};\n         assertEquals(10, CountingInversions.countInversions(arr));\n     }\n+\n+    @Test\n+    public void testEmptyArray() {\n+        int[] arr = {};\n+        assertEquals(0, CountingInversions.countInversions(arr));\n+    }\n+\n+    @Test\n+    public void testArrayWithDuplicates() {\n+        int[] arr = {1, 3, 2, 3, 1};\n+        // Inversions: (3,2), (3,1), (3,1), (2,1)\n+        assertEquals(4, CountingInversions.countInversions(arr));\n+    }\n+\n+    @Test\n+    public void testLargeArray() {\n+        int n = 1000;\n+        int[] arr = new int[n];\n+        for (int i = 0; i < n; i++) {\n+            arr[i] = n - i; // descending order -> max inversions = n*(n-1)/2\n+        }\n+        int expected = n * (n - 1) / 2;\n+        assertEquals(expected, CountingInversions.countInversions(arr));\n+    }\n+\n+    @Test\n+    public void testArrayWithAllSameElements() {\n+        int[] arr = {7, 7, 7, 7};\n+        // No inversions since all elements are equal\n+        assertEquals(0, CountingInversions.countInversions(arr));\n+    }\n }",
    "output": "Improve test coverage `CountingInversionsTest` testing: improving test coverage CountingInversionsTest"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/BinaryPowTest.java b/src/test/java/com/thealgorithms/maths/BinaryPowTest.java\n--- a/src/test/java/com/thealgorithms/maths/BinaryPowTest.java\n+++ b/src/test/java/com/thealgorithms/maths/BinaryPowTest.java\n@@ -13,4 +13,34 @@ void testBinPow() {\n         assertEquals(729, BinaryPow.binPow(9, 3));\n         assertEquals(262144, BinaryPow.binPow(8, 6));\n     }\n+\n+    @Test\n+    void testZeroExponent() {\n+        assertEquals(1, BinaryPow.binPow(2, 0));\n+        assertEquals(1, BinaryPow.binPow(100, 0));\n+        assertEquals(1, BinaryPow.binPow(-5, 0));\n+    }\n+\n+    @Test\n+    void testZeroBase() {\n+        assertEquals(0, BinaryPow.binPow(0, 5));\n+        assertEquals(1, BinaryPow.binPow(0, 0));\n+    }\n+\n+    @Test\n+    void testOneBase() {\n+        assertEquals(1, BinaryPow.binPow(1, 100));\n+        assertEquals(1, BinaryPow.binPow(1, 0));\n+    }\n+\n+    @Test\n+    void testNegativeBase() {\n+        assertEquals(-8, BinaryPow.binPow(-2, 3));\n+        assertEquals(16, BinaryPow.binPow(-2, 4));\n+    }\n+\n+    @Test\n+    void testLargeExponent() {\n+        assertEquals(1073741824, BinaryPow.binPow(2, 30));\n+    }\n }",
    "output": "Add unit tests for the `BinaryPow.binPow` testing: added unit tests for the BinaryPow.binPow"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/AbsoluteValueTest.java b/src/test/java/com/thealgorithms/maths/AbsoluteValueTest.java\n--- a/src/test/java/com/thealgorithms/maths/AbsoluteValueTest.java\n+++ b/src/test/java/com/thealgorithms/maths/AbsoluteValueTest.java\n@@ -12,4 +12,28 @@ public class AbsoluteValueTest {\n     void testGetAbsValue() {\n         Stream.generate(() -> ThreadLocalRandom.current().nextInt()).limit(1000).forEach(number -> assertEquals(Math.abs(number), AbsoluteValue.getAbsValue(number)));\n     }\n+\n+    @Test\n+    void testZero() {\n+        assertEquals(0, AbsoluteValue.getAbsValue(0));\n+    }\n+\n+    @Test\n+    void testPositiveNumbers() {\n+        assertEquals(5, AbsoluteValue.getAbsValue(5));\n+        assertEquals(123456, AbsoluteValue.getAbsValue(123456));\n+        assertEquals(Integer.MAX_VALUE, AbsoluteValue.getAbsValue(Integer.MAX_VALUE));\n+    }\n+\n+    @Test\n+    void testNegativeNumbers() {\n+        assertEquals(5, AbsoluteValue.getAbsValue(-5));\n+        assertEquals(123456, AbsoluteValue.getAbsValue(-123456));\n+        assertEquals(Integer.MAX_VALUE, AbsoluteValue.getAbsValue(-Integer.MAX_VALUE));\n+    }\n+\n+    @Test\n+    void testMinIntEdgeCase() {\n+        assertEquals(Integer.MIN_VALUE, AbsoluteValue.getAbsValue(Integer.MIN_VALUE));\n+    }\n }",
    "output": "Improve tests coverage `AbsoluteValueTest`\ntesting: improve tests coverage AbsoluteValueTest"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/sorts/TopologicalSortTest.java b/src/test/java/com/thealgorithms/sorts/TopologicalSortTest.java\n--- a/src/test/java/com/thealgorithms/sorts/TopologicalSortTest.java\n+++ b/src/test/java/com/thealgorithms/sorts/TopologicalSortTest.java\n@@ -3,6 +3,7 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertIterableEquals;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n import com.thealgorithms.sorts.TopologicalSort.Graph;\n import java.util.LinkedList;\n@@ -59,4 +60,18 @@ public void failureTest() {\n             + \"Back edge: 6 -> 2\";\n         assertEquals(exception.getMessage(), expected);\n     }\n+    @Test\n+    void testEmptyGraph() {\n+        Graph graph = new Graph();\n+        LinkedList<String> sorted = TopologicalSort.sort(graph);\n+        assertTrue(sorted.isEmpty());\n+    }\n+    @Test\n+    void testSingleNode() {\n+        Graph graph = new Graph();\n+        graph.addEdge(\"A\", \"\");\n+        LinkedList<String> sorted = TopologicalSort.sort(graph);\n+        assertEquals(1, sorted.size());\n+        assertEquals(\"A\", sorted.getFirst());\n+    }\n }",
    "output": "Add Unit Tests for Empty and Single-Node Graphs in TopologicalSort"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/AbsoluteMax.java b/src/main/java/com/thealgorithms/maths/AbsoluteMax.java\n--- a/src/main/java/com/thealgorithms/maths/AbsoluteMax.java\n+++ b/src/main/java/com/thealgorithms/maths/AbsoluteMax.java\n@@ -17,7 +17,7 @@ public static int getMaxValue(int... numbers) {\n         }\n         int absMax = numbers[0];\n         for (int i = 1; i < numbers.length; i++) {\n-            if (Math.abs(numbers[i]) > Math.abs(absMax)) {\n+            if (Math.abs(numbers[i]) > Math.abs(absMax) || (Math.abs(numbers[i]) == Math.abs(absMax) && numbers[i] > absMax)) {\n                 absMax = numbers[i];\n             }\n         }\n\ndiff --git a/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java b/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java\n--- a/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java\n+++ b/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java\n@@ -19,4 +19,12 @@ void testGetMaxValue() {\n     void testGetMaxValueWithNoArguments() {\n         assertThrows(IllegalArgumentException.class, AbsoluteMax::getMaxValue);\n     }\n+\n+    @Test\n+    void testGetMaxValueWithSameAbsoluteValues() {\n+        assertEquals(5, AbsoluteMax.getMaxValue(-5, 5));\n+        assertEquals(5, AbsoluteMax.getMaxValue(5, -5));\n+        assertEquals(12, AbsoluteMax.getMaxValue(-12, 9, 3, 12, 1));\n+        assertEquals(12, AbsoluteMax.getMaxValue(12, 9, 3, -12, 1));\n+    }\n }",
    "output": "Fix absolute max bug"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/strings/WordLadderTest.java b/src/test/java/com/thealgorithms/strings/WordLadderTest.java\n--- a/src/test/java/com/thealgorithms/strings/WordLadderTest.java\n+++ b/src/test/java/com/thealgorithms/strings/WordLadderTest.java\n@@ -41,6 +41,21 @@ public void testWordLadder2() {\n         assertEquals(WordLadder.ladderLength(\"hit\", \"cog\", wordList2), 0);\n     }\n \n+    /**\n+     * Test 3:\n+     * Input: beginWord = \"hit\", endWord = \"cog\", wordList =\n+     * []\n+     * Output: 0\n+     * Explanation: The wordList is empty (corner case),\n+     * therefore there is no valid transformation sequence.\n+     */\n+    @Test\n+    public void testWordLadder3() {\n+\n+        List<String> wordList3 = Arrays.asList();\n+        assertEquals(WordLadder.ladderLength(\"hit\", \"cog\", wordList3), 0);\n+    }\n+\n     @ParameterizedTest\n     @CsvSource({\"'a', 'c', 'b,c', 2\", \"'a', 'c', 'a', 0\", \"'a', 'a', 'a', 0\", \"'ab', 'cd', 'ad,bd,cd', 3\", \"'a', 'd', 'b,c,d', 2\", \"'a', 'd', 'b,c,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,d', 2\"})\n     void testLadderLength(String beginWord, String endWord, String wordListStr, int expectedLength) {",
    "output": "Add to WordLadderTest corner case where wordList is empty"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/dynamicprogramming/RodCutting.java b/src/main/java/com/thealgorithms/dynamicprogramming/RodCutting.java\n--- a/src/main/java/com/thealgorithms/dynamicprogramming/RodCutting.java\n+++ b/src/main/java/com/thealgorithms/dynamicprogramming/RodCutting.java\n@@ -22,6 +22,10 @@ public static int cutRod(int[] price, int n) {\n         if (price == null || price.length == 0) {\n             throw new IllegalArgumentException(\"Price array cannot be null or empty.\");\n         }\n+        if (n < 0) {\n+            throw new IllegalArgumentException(\"Rod length cannot be negative.\");\n+        }\n+\n         // Create an array to store the maximum obtainable values for each rod length.\n         int[] val = new int[n + 1];\n         val[0] = 0;\n\ndiff --git a/src/test/java/com/thealgorithms/dynamicprogramming/RodCuttingTest.java b/src/test/java/com/thealgorithms/dynamicprogramming/RodCuttingTest.java\n--- a/src/test/java/com/thealgorithms/dynamicprogramming/RodCuttingTest.java\n+++ b/src/test/java/com/thealgorithms/dynamicprogramming/RodCuttingTest.java\n@@ -93,4 +93,10 @@ void testCutRodEmptyPrices() {\n         int length = 5;\n         assertThrows(IllegalArgumentException.class, () -> RodCutting.cutRod(prices, length), \"An empty prices array should throw an IllegalArgumentException.\");\n     }\n+    @Test\n+    void testCutRodNegativeLength() {\n+        int[] prices = {1, 5, 8, 9, 10}; // Prices are irrelevant for negative length\n+        int length = -1;\n+        assertThrows(IllegalArgumentException.class, () -> RodCutting.cutRod(prices, length), \"A negative rod length should throw an IllegalArgumentException.\");\n+    }\n }",
    "output": "Add edge case to handle negative rod length in RodCutting algorithm"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/Volume.java b/src/main/java/com/thealgorithms/maths/Volume.java\n--- a/src/main/java/com/thealgorithms/maths/Volume.java\n+++ b/src/main/java/com/thealgorithms/maths/Volume.java\n@@ -90,4 +90,16 @@ public static double volumePrism(double baseArea, double height) {\n     public static double volumePyramid(double baseArea, double height) {\n         return (baseArea * height) / 3;\n     }\n+\n+    /**\n+     * Calculate the volume of a frustum of a cone.\n+     *\n+     * @param r1 radius of the top of the frustum\n+     * @param r2 radius of the bottom of the frustum\n+     * @param height height of the frustum\n+     * @return volume of the frustum\n+     */\n+    public static double volumeFrustumOfCone(double r1, double r2, double height) {\n+        return (Math.PI * height / 3) * (r1 * r1 + r2 * r2 + r1 * r2);\n+    }\n }\n\ndiff --git a/src/test/java/com/thealgorithms/maths/VolumeTest.java b/src/test/java/com/thealgorithms/maths/VolumeTest.java\n--- a/src/test/java/com/thealgorithms/maths/VolumeTest.java\n+++ b/src/test/java/com/thealgorithms/maths/VolumeTest.java\n@@ -32,5 +32,8 @@ public void volume() {\n \n         /* test pyramid */\n         assertTrue(Volume.volumePyramid(10, 3) == 10.0);\n+\n+        /* test frustum */\n+        assertTrue(Volume.volumeFrustumOfCone(3, 5, 7) == 359.188760060433);\n     }\n }",
    "output": "Add Volume \"Algorithm Frustum Of Cone\" Then Test It.\n* Add Function volumeFrustum To Calculate Frustum Of Cone Then Test It.\n* Add Function volumeFrustumOfCone To Calculate Frustum Of Cone Then Test It.\n* Update VolumeTest.java\n* Update Volume.java"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java\n@@ -19,8 +19,7 @@ This method returns the majority element(s) in the given array of integers.\n     public static List<Integer> majority(int[] nums) {\n         HashMap<Integer, Integer> numToCount = new HashMap<>();\n         for (final var num : nums) {\n-            final var curCount = numToCount.getOrDefault(num, 0);\n-            numToCount.put(num, curCount + 1);\n+            numToCount.merge(num, 1, Integer::sum);\n         }\n         List<Integer> majorityElements = new ArrayList<>();\n         for (final var entry : numToCount.entrySet()) {",
    "output": "Use `getOrDefault` in `MajorityElement`"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java\n@@ -18,17 +18,13 @@ This method returns the majority element(s) in the given array of integers.\n    */\n     public static List<Integer> majority(int[] nums) {\n         HashMap<Integer, Integer> numToCount = new HashMap<>();\n-        int n = nums.length;\n-        for (int i = 0; i < n; i++) {\n-            if (numToCount.containsKey(nums[i])) {\n-                numToCount.put(nums[i], numToCount.get(nums[i]) + 1);\n-            } else {\n-                numToCount.put(nums[i], 1);\n-            }\n+        for (final var num : nums) {\n+            final var curCount = numToCount.getOrDefault(num, 0);\n+            numToCount.put(num, curCount + 1);\n         }\n         List<Integer> majorityElements = new ArrayList<>();\n         for (final var entry : numToCount.entrySet()) {\n-            if (entry.getValue() >= n / 2) {\n+            if (entry.getValue() >= nums.length / 2) {\n                 majorityElements.add(entry.getKey());\n             }\n         }",
    "output": "Use `getOrDefault` in `MajorityElement`"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java b/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java\n--- a/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java\n+++ b/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java\n@@ -12,6 +12,7 @@ void testGetMaxValue() {\n         assertEquals(16, AbsoluteMax.getMaxValue(-2, 0, 16));\n         assertEquals(-22, AbsoluteMax.getMaxValue(-3, -10, -22));\n         assertEquals(-888, AbsoluteMax.getMaxValue(-888));\n+        assertEquals(-1, AbsoluteMax.getMaxValue(-1, -1, -1, -1, -1));\n     }\n \n     @Test",
    "output": "Add an edge case for AbsoluteMax * Added an edge case to test * Fixed linting on added test"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/NumberOfDigitsTest.java b/src/test/java/com/thealgorithms/maths/NumberOfDigitsTest.java\n--- a/src/test/java/com/thealgorithms/maths/NumberOfDigitsTest.java\n+++ b/src/test/java/com/thealgorithms/maths/NumberOfDigitsTest.java\n@@ -4,7 +4,6 @@\n \n import java.util.function.IntFunction;\n import java.util.stream.Stream;\n-import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;",
    "output": "Remove unused import."
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMapCuckooHashing.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMapCuckooHashing.java\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMapCuckooHashing.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMapCuckooHashing.java\n@@ -1,6 +1,5 @@\n package com.thealgorithms.datastructures.hashmap.hashing;\n \n-import java.lang.Math;\n import java.util.Objects;\n \n /**",
    "output": "Remove unused import from `HashMapCuckooHashing`\nstyle: remove unused import from `HashMapCuckooHashing`"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/greedyalgorithms/JobSequencing.java b/src/main/java/com/thealgorithms/greedyalgorithms/JobSequencing.java\n--- a/src/main/java/com/thealgorithms/greedyalgorithms/JobSequencing.java\n+++ b/src/main/java/com/thealgorithms/greedyalgorithms/JobSequencing.java\n@@ -2,7 +2,6 @@\n \n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collections;\n \n // Problem Link: https://en.wikipedia.org/wiki/Job-shop_scheduling\n ",
    "output": "Remove unused import from `JobSequencing`\nstyle: remove unused import from `JobSequencing`"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/PerfectSquareTest.java b/src/test/java/com/thealgorithms/maths/PerfectSquareTest.java\n--- a/src/test/java/com/thealgorithms/maths/PerfectSquareTest.java\n+++ b/src/test/java/com/thealgorithms/maths/PerfectSquareTest.java\n@@ -1,8 +1,6 @@\n package com.thealgorithms.maths;\n \n-import java.util.stream.Stream;\n import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.ValueSource;\n ",
    "output": "Remove unused imports from `PerfectSquareTest`\nstyle: remove unused imports from `PerfectSquareTest`"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/PowerOfTwoOrNotTest.java b/src/test/java/com/thealgorithms/maths/PowerOfTwoOrNotTest.java\n--- a/src/test/java/com/thealgorithms/maths/PowerOfTwoOrNotTest.java\n+++ b/src/test/java/com/thealgorithms/maths/PowerOfTwoOrNotTest.java\n@@ -3,7 +3,6 @@\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-import java.util.Map;\n import org.junit.jupiter.api.Test;\n \n public class PowerOfTwoOrNotTest {",
    "output": "Remove unused import from `PowerOfTwoOrNotTest`\nstyle: remove unused import from `PowerOfTwoOrNotTest.java`"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/others/BoyerMooreTest.java b/src/test/java/com/thealgorithms/others/BoyerMooreTest.java\n--- a/src/test/java/com/thealgorithms/others/BoyerMooreTest.java\n+++ b/src/test/java/com/thealgorithms/others/BoyerMooreTest.java\n@@ -1,9 +1,7 @@\n package com.thealgorithms.others;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n \n import java.util.stream.Stream;\n import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;",
    "output": "Remove unused imports from `BoyerMooreTest`"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/strings/ReverseWordsInStringTest.java b/src/test/java/com/thealgorithms/strings/ReverseWordsInStringTest.java\n--- a/src/test/java/com/thealgorithms/strings/ReverseWordsInStringTest.java\n+++ b/src/test/java/com/thealgorithms/strings/ReverseWordsInStringTest.java\n@@ -2,7 +2,6 @@\n \n import java.util.stream.Stream;\n import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;",
    "output": "Remove unused import"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/searches/PerfectBinarySearchTest.java b/src/test/java/com/thealgorithms/searches/PerfectBinarySearchTest.java\n--- a/src/test/java/com/thealgorithms/searches/PerfectBinarySearchTest.java\n+++ b/src/test/java/com/thealgorithms/searches/PerfectBinarySearchTest.java\n@@ -1,6 +1,7 @@\n+package com.thealgorithms.searches;\n+\n import static org.junit.jupiter.api.Assertions.*;\n \n-import com.thealgorithms.searches.PerfectBinarySearch;\n import org.junit.jupiter.api.Test;\n \n /**",
    "output": "Add package name"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/HarshadNumber.java b/src/main/java/com/thealgorithms/maths/HarshadNumber.java\n--- a/src/main/java/com/thealgorithms/maths/HarshadNumber.java\n+++ b/src/main/java/com/thealgorithms/maths/HarshadNumber.java\n@@ -15,7 +15,7 @@ public static boolean isHarshad(long n) {\n         if (n <= 0) return false;\n \n         long t = n;\n-        int sumOfDigits = 0;\n+        long sumOfDigits = 0;\n         while (t > 0) {\n             sumOfDigits += t % 10;\n             t /= 10;",
    "output": "Make `sumOfDigits` `long` in `HarshadNumber.isHarshad`\nfix: make `sumOfDigits` `long` in `HarshadNumber.isHarshad`"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/greedyalgorithms/FractionalKnapsack.java b/src/main/java/com/thealgorithms/greedyalgorithms/FractionalKnapsack.java\n--- a/src/main/java/com/thealgorithms/greedyalgorithms/FractionalKnapsack.java\n+++ b/src/main/java/com/thealgorithms/greedyalgorithms/FractionalKnapsack.java\n@@ -32,7 +32,7 @@ public static int fractionalKnapsack(int weight[], int value[], int capacity) {\n                 current -= weight[index];\n             } else {\n                 // If only a fraction of the item can fit, add a proportionate value.\n-                finalValue += ratio[i][1] * current;\n+                finalValue += (int) (ratio[i][1] * current);\n                 break; // Stop adding items to the knapsack since it's full.\n             }\n         }",
    "output": "Use explicit cast to `int` in `FractionalKnapsack`"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/sorts/SelectionSort.java b/src/main/java/com/thealgorithms/sorts/SelectionSort.java\n--- a/src/main/java/com/thealgorithms/sorts/SelectionSort.java\n+++ b/src/main/java/com/thealgorithms/sorts/SelectionSort.java\n@@ -1,5 +1,7 @@\n package com.thealgorithms.sorts;\n \n+import static com.thealgorithms.sorts.SortUtils.swap;\n+\n public class SelectionSort implements SortAlgorithm {\n \n     /**\n@@ -20,9 +22,7 @@ public <T extends Comparable<T>> T[] sort(T[] arr) {\n                 }\n             }\n             if (minIndex != i) {\n-                T temp = arr[i];\n-                arr[i] = arr[minIndex];\n-                arr[minIndex] = temp;\n+                swap(arr, i, minIndex);\n             }\n         }\n         return arr;",
    "output": "Use method `SortUtils.swap`\n* refactor: use method SortUtils.swap\n* fix: clang format\n* style: explicitly import `swap`"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/FindMinRecursion.java b/src/main/java/com/thealgorithms/maths/FindMinRecursion.java\n--- a/src/main/java/com/thealgorithms/maths/FindMinRecursion.java\n+++ b/src/main/java/com/thealgorithms/maths/FindMinRecursion.java\n@@ -21,7 +21,7 @@ public static void main(String[] args) {\n         }\n \n         assert min(array, 0, array.length - 1) == Arrays.stream(array).min().getAsInt();\n-        assert min(array, array.length) == Arrays.stream(array).min().getAsInt();\n+        assert min(array) == Arrays.stream(array).min().getAsInt();\n     }\n \n     /**\n@@ -42,7 +42,7 @@ public static int min(int[] array, int low, int high) {\n         int leftMin = min(array, low, mid); // get min in [low, mid]\n         int rightMin = min(array, mid + 1, high); // get min in [mid+1, high]\n \n-        return Math.min(leftMin, rightMin);\n+        return leftMin > rightMin ? rightMin : leftMin;\n     }\n \n     /**\n@@ -52,7 +52,7 @@ public static int min(int[] array, int low, int high) {\n      * @param len length of given array\n      * @return min value of {@code array}\n      */\n-    public static int min(int[] array, int len) {\n-        return len == 1 ? array[0] : Math.min(min(array, len - 1), array[len - 1]);\n+    public static int min(int[] array) {\n+        return array.length == 1 ? array[0] : min(array, 0, array.length);\n     }\n }",
    "output": "Remove array len + Math.min"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/FindMaxRecursion.java b/src/main/java/com/thealgorithms/maths/FindMaxRecursion.java\n--- a/src/main/java/com/thealgorithms/maths/FindMaxRecursion.java\n+++ b/src/main/java/com/thealgorithms/maths/FindMaxRecursion.java\n@@ -17,7 +17,7 @@ public static void main(String[] args) {\n             array[i] = rand.nextInt() % 100;\n         }\n \n-        assert max(array, array.length) == Arrays.stream(array).max().getAsInt();\n+        assert max(array) == Arrays.stream(array).max().getAsInt();\n         assert max(array, 0, array.length - 1) == Arrays.stream(array).max().getAsInt();\n     }\n \n@@ -39,17 +39,16 @@ public static int max(int[] array, int low, int high) {\n         int leftMax = max(array, low, mid); // get max in [low, mid]\n         int rightMax = max(array, mid + 1, high); // get max in [mid+1, high]\n \n-        return Math.max(leftMax, rightMax);\n+        return leftMax < rightMax ? rightMax : leftMax;\n     }\n \n     /**\n      * Get max of array using recursion algorithm\n      *\n      * @param array contains elements\n-     * @param len length of given array\n      * @return max value of {@code array}\n      */\n-    public static int max(int[] array, int len) {\n-        return len == 1 ? array[0] : Math.max(max(array, len - 1), array[len - 1]);\n+    public static int max(int[] array) {\n+        return array.length == 1 ? array[0] : max(array, 0, array.length);\n     }\n }",
    "output": "Remove array len + Math.max"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/FindMin.java b/src/main/java/com/thealgorithms/maths/FindMin.java\n--- a/src/main/java/com/thealgorithms/maths/FindMin.java\n+++ b/src/main/java/com/thealgorithms/maths/FindMin.java\n@@ -1,26 +1,7 @@\n package com.thealgorithms.maths;\n \n-import java.util.Arrays;\n-import java.util.Random;\n-\n-public class FindMin {\n-\n-    /**\n-     * Driver Code\n-     */\n-    public static void main(String[] args) {\n-        Random random = new Random();\n-\n-        /* random size */\n-        int size = random.nextInt(100) + 1;\n-        int[] array = new int[size];\n-\n-        /* init array with random numbers */\n-        for (int i = 0; i < size; i++) {\n-            array[i] = random.nextInt() % 100;\n-        }\n-\n-        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n+public final class FindMin {\n+    private FindMin() {\n     }\n \n     /**\n@@ -30,7 +11,7 @@ public static void main(String[] args) {\n      * @exception IllegalArgumentException input array is empty\n      * @return the mimum value stored in the input array\n      */\n-    public static int findMin(int[] array) {\n+    public static int findMin(final int[] array) {\n         if (array.length == 0) {\n             throw new IllegalArgumentException(\"array must be non-empty.\");\n         }",
    "output": "Make `FindMin` a proper utilty class"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/FindMax.java b/src/main/java/com/thealgorithms/maths/FindMax.java\n--- a/src/main/java/com/thealgorithms/maths/FindMax.java\n+++ b/src/main/java/com/thealgorithms/maths/FindMax.java\n@@ -1,26 +1,7 @@\n package com.thealgorithms.maths;\n \n-import java.util.Arrays;\n-import java.util.Random;\n-\n-public class FindMax {\n-\n-    /**\n-     * Driver Code\n-     */\n-    public static void main(String[] args) {\n-        Random random = new Random();\n-\n-        /* random size */\n-        int size = random.nextInt(100) + 1;\n-        int[] array = new int[size];\n-\n-        /* init array with random numbers */\n-        for (int i = 0; i < size; i++) {\n-            array[i] = random.nextInt() % 100;\n-        }\n-\n-        assert Arrays.stream(array).max().getAsInt() == findMax(array);\n+public final class FindMax {\n+    private FindMax() {\n     }\n \n     /**\n@@ -30,7 +11,7 @@ public static void main(String[] args) {\n      * @exception IllegalArgumentException input array is empty\n      * @return the maximum value stored in the input array\n      */\n-    public static int findMax(int[] array) {\n+    public static int findMax(final int[] array) {\n         if (array.length == 0) {\n             throw new IllegalArgumentException(\"array must be non-empty.\");\n         }",
    "output": "Make `FindMax` a proper utilty class"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/FindMin.java b/src/main/java/com/thealgorithms/maths/FindMin.java\n--- a/src/main/java/com/thealgorithms/maths/FindMin.java\n+++ b/src/main/java/com/thealgorithms/maths/FindMin.java\n@@ -34,10 +34,10 @@ public static int findMin(int[] array) {\n         if (array.length == 0) {\n             throw new IllegalArgumentException(\"array must be non-empty.\");\n         }\n-        int min = Integer.MAX_VALUE;\n-        for (final var value : array) {\n-            if (value < min) {\n-                min = value;\n+        int min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] < min) {\n+                min = array[i];\n             }\n         }\n         return min;",
    "output": "Make FindMin more efficient"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/bitmanipulation/ClearBit.java b/src/main/java/com/thealgorithms/bitmanipulation/ClearBit.java\n--- a/src/main/java/com/thealgorithms/bitmanipulation/ClearBit.java\n+++ b/src/main/java/com/thealgorithms/bitmanipulation/ClearBit.java\n@@ -0,0 +1,11 @@\n+package com.thealgorithms.bitmanipulation;\r\n+/**\r\n+ * Clears the bit located at clear from num\r\n+ */\r\n+\r\n+public class ClearBit {\r\n+    public static int clearBit(int num, int clear) {\r\n+        int mask = ~(1 << clear);\r\n+        return num & mask;\r\n+    }\r\n+}\r\n\ndiff --git a/src/test/java/com/thealgorithms/bitmanipulation/ClearBitTest.java b/src/test/java/com/thealgorithms/bitmanipulation/ClearBitTest.java\n--- a/src/test/java/com/thealgorithms/bitmanipulation/ClearBitTest.java\n+++ b/src/test/java/com/thealgorithms/bitmanipulation/ClearBitTest.java\n@@ -0,0 +1,13 @@\n+package com.thealgorithms.bitmanipulation;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.*;\r\n+\r\n+import org.junit.jupiter.api.Test;\r\n+\r\n+public class ClearBitTest {\r\n+    @Test\r\n+    public void clearBitTest() {\r\n+        assertEquals(5, ClearBit.clearBit(7, 1));\r\n+        assertEquals(5, ClearBit.clearBit(5, 1));\r\n+    }\r\n+}\r",
    "output": "Add Clear Bit"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/bitmanipulation/SetBit.java b/src/main/java/com/thealgorithms/bitmanipulation/SetBit.java\n--- a/src/main/java/com/thealgorithms/bitmanipulation/SetBit.java\n+++ b/src/main/java/com/thealgorithms/bitmanipulation/SetBit.java\n@@ -0,0 +1,10 @@\n+package com.thealgorithms.bitmanipulation;\n+/**\n+ * Sets a specific bit to 1\n+ */\n+\n+public class SetBit {\n+    public static int setBit(int num, int bit) {\n+        return num | (1 << bit);\n+    }\n+}\n\ndiff --git a/src/test/java/com/thealgorithms/bitmanipulation/SetBit.java b/src/test/java/com/thealgorithms/bitmanipulation/SetBit.java\n--- a/src/test/java/com/thealgorithms/bitmanipulation/SetBit.java\n+++ b/src/test/java/com/thealgorithms/bitmanipulation/SetBit.java\n@@ -0,0 +1,13 @@\n+package com.thealgorithms.bitmanipulation;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+class SetBitTest {\n+    @Test\n+    void testSetBit() {\n+        assertEquals(5, SetBit.setBit(4, 0));\n+        assertEquals(3, SetBit.setBit(3, 1));\n+    }\n+}",
    "output": "Add SetBit to bitmanipulation"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/bitmanipulation/IsEven.java b/src/main/java/com/thealgorithms/bitmanipulation/IsEven.java\n--- a/src/main/java/com/thealgorithms/bitmanipulation/IsEven.java\n+++ b/src/main/java/com/thealgorithms/bitmanipulation/IsEven.java\n@@ -0,0 +1,12 @@\n+package com.thealgorithms.bitmanipulation;\n+\n+/**\n+ * Converts any Octal Number to a Binary Number\n+ * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n+ */\n+\n+public class IsEven {\n+    public static boolean isEven(int number) {\n+        return (number & 1) == 0;\n+    }\n+}\n\\ No newline at end of file\n\ndiff --git a/src/test/java/com/thealgorithms/bitmanipulation/IsEvenTest.java b/src/test/java/com/thealgorithms/bitmanipulation/IsEvenTest.java\n--- a/src/test/java/com/thealgorithms/bitmanipulation/IsEvenTest.java\n+++ b/src/test/java/com/thealgorithms/bitmanipulation/IsEvenTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.bitmanipulation;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+class IsEvenTest {\n+    @Test\n+    void testIsEven() {\n+        assertEquals(true, IsEven.isEven(2));\n+        assertEquals(true, IsEven.isEven(-12));\n+        assertEquals(false, IsEven.isEven(21));\n+    }\n+}",
    "output": "Add IsEven Algorithm"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/Factorial.java b/src/main/java/com/thealgorithms/maths/Factorial.java\n--- a/src/main/java/com/thealgorithms/maths/Factorial.java\n+++ b/src/main/java/com/thealgorithms/maths/Factorial.java\n@@ -1,6 +1,9 @@\n package com.thealgorithms.maths;\n \n-public class Factorial {\n+public final class Factorial {\n+    private Factorial() {\n+    }\n+\n     /**\n      * Calculate factorial N using iteration\n      *",
    "output": "Make `Factorial` a proper utility class"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java b/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java\n--- a/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java\n+++ b/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java\n@@ -3,7 +3,7 @@\n import java.util.LinkedList;\n import java.util.Queue;\n \n-/**\n+/*\n  * This entire class is used to build a Binary Tree data structure. There is the\n  * Node Class and the Tree Class, both explained below.\n  */\n@@ -164,13 +164,11 @@ else if (temp.left != null && temp.right != null) {\n                 if (successor.right != null) {\n                     successor.right.parent = successor.parent;\n                     successor.parent.left = successor.right;\n-                    successor.right = temp.right;\n-                    successor.right.parent = successor;\n                 } else {\n                     successor.parent.left = null;\n-                    successor.right = temp.right;\n-                    successor.right.parent = successor;\n                 }\n+                successor.right = temp.right;\n+                successor.right.parent = successor;\n             }\n \n             if (temp == root) {\n@@ -304,7 +302,7 @@ public void postOrder(Node localRoot) {\n      */\n     public void bfs(Node localRoot) {\n         // Create a queue for the order of the nodes\n-        Queue<Node> queue = new LinkedList<Node>();\n+        Queue<Node> queue = new LinkedList<>();\n \n         // If the give root is null, then we don't add to the queue\n         // and won't do anything",
    "output": "Remove duplicated lines"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/ReverseNumber.java b/src/main/java/com/thealgorithms/maths/ReverseNumber.java\n--- a/src/main/java/com/thealgorithms/maths/ReverseNumber.java\n+++ b/src/main/java/com/thealgorithms/maths/ReverseNumber.java\n@@ -1,11 +1,9 @@\n package com.thealgorithms.maths;\n \n-import java.lang.IllegalArgumentException;\n-\n /**\n  * @brief utility class reversing numbers\n  */\n-final public class ReverseNumber {\n+public final class ReverseNumber {\n     private ReverseNumber() {\n     }\n ",
    "output": "Upgrade `ReverseNumber` - removes an unused import, - fixes the order of the of the _modifiers_ in the definition of the class `ReverseNumber`"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/Average.java b/src/main/java/com/thealgorithms/maths/Average.java\n--- a/src/main/java/com/thealgorithms/maths/Average.java\n+++ b/src/main/java/com/thealgorithms/maths/Average.java\n@@ -12,6 +12,9 @@ public class Average {\n      * @return mean of given numbers\n      */\n     public static double average(double[] numbers) {\n+        if (numbers == null || numbers.length == 0) {\n+            throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n+        }\n         double sum = 0;\n         for (double number : numbers) {\n             sum += number;\n@@ -27,6 +30,9 @@ public static double average(double[] numbers) {\n      * @return average value\n      */\n     public static int average(int[] numbers) {\n+        if (numbers == null || numbers.length == 0) {\n+            throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n+        }\n         long sum = 0;\n         for (int number : numbers) {\n             sum += number;",
    "output": "Add Null/Empty check for param in average method"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/ciphers/DES.java b/src/main/java/com/thealgorithms/ciphers/DES.java\n--- a/src/main/java/com/thealgorithms/ciphers/DES.java\n+++ b/src/main/java/com/thealgorithms/ciphers/DES.java\n@@ -1,7 +1,7 @@\n package com.thealgorithms.ciphers;\n \n /**\n- * This class is build to demonstrate the application of the DES-algorithm on a\n+ * This class is build to demonstrate the application of the DES-algorithm (https://en.wikipedia.org/wiki/Data_Encryption_Standard) on a\n  * plain English message. The supplied key must be in form of a 64 bit binary String.\n  */\n public class DES {\n@@ -341,4 +341,4 @@ public String decrypt(String message) {\n         return decryptedMessage.toString().replace(\"\\0\", \"\"); // Get rid of the null bytes used for padding\n     }\n \n-}\n\\ No newline at end of file\n+}",
    "output": "Add wiki link for DES"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/io/BufferedReaderTest.java b/src/test/java/com/thealgorithms/io/BufferedReaderTest.java\n--- a/src/test/java/com/thealgorithms/io/BufferedReaderTest.java\n+++ b/src/test/java/com/thealgorithms/io/BufferedReaderTest.java\n@@ -99,35 +99,4 @@ public void testBlockPractical() throws IOException {\n       throw new IOException(\"Something not right\");\n     }\n   }\n-\n-  @Test\n-  public void randomTest() throws IOException {\n-    Random random = new Random();\n-\n-    int len = random.nextInt(9999);\n-    int bound = 256;\n-\n-    ByteArrayOutputStream stream = new ByteArrayOutputStream(len);\n-    while (len-- > 0)\n-      stream.write(random.nextInt(bound));\n-\n-    byte[] bytes = stream.toByteArray();\n-    ByteArrayInputStream comparer = new ByteArrayInputStream(bytes);\n-\n-    int blockSize = random.nextInt(7) + 5;\n-    BufferedReader reader = new BufferedReader(\n-            new ByteArrayInputStream(bytes), blockSize);\n-\n-    for (int i = 0; i < 50; i++) {\n-      if ((i & 1) == 0) {\n-        assertEquals(comparer.read(), reader.read());\n-        continue;\n-      }\n-      byte[] block = new byte[blockSize];\n-      comparer.read(block);\n-      byte[] read = reader.readBlock();\n-\n-      assertArrayEquals(block, read);\n-    }\n-  }\n-}\n\\ No newline at end of file\n+}",
    "output": "Remove blinking test for BufferedReader"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/backtracking/PowerSum.java b/src/main/java/com/thealgorithms/backtracking/PowerSum.java\n--- a/src/main/java/com/thealgorithms/backtracking/PowerSum.java\n+++ b/src/main/java/com/thealgorithms/backtracking/PowerSum.java\n@@ -1,6 +1,5 @@\n package com.thealgorithms.backtracking;\n \n-import java.util.Scanner;\n \n /*\n  * Problem Statement :",
    "output": "Remove unnecessary import"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/conversions/RomanToIntegerTest.java b/src/test/java/com/thealgorithms/conversions/RomanToIntegerTest.java\n--- a/src/test/java/com/thealgorithms/conversions/RomanToIntegerTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/RomanToIntegerTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.conversions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class RomanToIntegerTest {\n+\n+    @Test\n+    public void testRomanToInteger() {\n+        assertEquals(1994, RomanToInteger.romanToInt(\"MCMXCIV\"));\n+        assertEquals(58, RomanToInteger.romanToInt(\"LVIII\"));\n+    }\n+}",
    "output": "Add test case for RomanToInteger"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/conversions/HexaDecimalToDecimalTest.java b/src/test/java/com/thealgorithms/conversions/HexaDecimalToDecimalTest.java\n--- a/src/test/java/com/thealgorithms/conversions/HexaDecimalToDecimalTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/HexaDecimalToDecimalTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.conversions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class HexaDecimalToDecimalTest {\n+\n+    @Test\n+    public void testhexaDecimalToDecimal(){\n+        assertEquals(161, HexaDecimalToDecimal.getHexaToDec(\"A1\"));\n+        assertEquals(428, HexaDecimalToDecimal.getHexaToDec(\"1ac\"));\n+    }\n+}",
    "output": "Add test case for hexadecimal to decimal"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/conversions/BinaryToHexadecimalTest.java b/src/test/java/com/thealgorithms/conversions/BinaryToHexadecimalTest.java\n--- a/src/test/java/com/thealgorithms/conversions/BinaryToHexadecimalTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/BinaryToHexadecimalTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.conversions;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class BinaryToHexadecimalTest {\n+\n+    @Test\n+    public void testBinaryToHexadecimal() {\n+        assertEquals(\"6A\", BinaryToHexadecimal.binToHex(1101010));\n+        assertEquals(\"C\", BinaryToHexadecimal.binToHex(1100));\n+    }\n+}",
    "output": "Add test case for BinaryToHexadecimal"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/conversions/BinaryToOctalTest.java b/src/test/java/com/thealgorithms/conversions/BinaryToOctalTest.java\n--- a/src/test/java/com/thealgorithms/conversions/BinaryToOctalTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/BinaryToOctalTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.conversions;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class BinaryToOctalTest {\n+\n+    @Test\n+    public void testBinaryToOctal() {\n+        assertEquals(\"226\", BinaryToOctal.convertBinaryToOctal(10010110));\n+        assertEquals(\"135\", BinaryToOctal.convertBinaryToOctal(1011101));\n+    }\n+}",
    "output": "Add test case for BinaryToOctal"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/conversions/DecimalToHexaDecimalTest.java b/src/test/java/com/thealgorithms/conversions/DecimalToHexaDecimalTest.java\n--- a/src/test/java/com/thealgorithms/conversions/DecimalToHexaDecimalTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/DecimalToHexaDecimalTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.conversions;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class DecimalToHexaDecimalTest {\n+\n+    @Test\n+    public void testDecimalToHexaDecimal() {\n+        assertEquals(\"000000be\", DecimalToHexaDecimal.decToHex(190));\n+        assertEquals(\"00000708\", DecimalToHexaDecimal.decToHex(1800));\n+    }\n+}",
    "output": "Add test case for DecimalToHexaDecimal"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/dynamicprogramming/CatalanNumberTest.java b/src/test/java/com/thealgorithms/dynamicprogramming/CatalanNumberTest.java\n--- a/src/test/java/com/thealgorithms/dynamicprogramming/CatalanNumberTest.java\n+++ b/src/test/java/com/thealgorithms/dynamicprogramming/CatalanNumberTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.dynamicprogramming;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class CatalanNumberTest {\n+\n+    @Test\n+    public void testCatalanNumber() {\n+        assertEquals(42, CatalanNumber.findNthCatalan(5));\n+        assertEquals(16796, CatalanNumber.findNthCatalan(10));\n+    }\n+}",
    "output": "Add test case for CatalanNumber"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/conversions/OctalToDecimalTest.java b/src/test/java/com/thealgorithms/conversions/OctalToDecimalTest.java\n--- a/src/test/java/com/thealgorithms/conversions/OctalToDecimalTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/OctalToDecimalTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.conversions;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class OctalToDecimalTest {\n+\n+    @Test\n+    public void testOctalToDecimal() {\n+        assertEquals(1465, OctalToDecimal.convertOctalToDecimal(\"2671\"));\n+        assertEquals(189, OctalToDecimal.convertOctalToDecimal(\"275\"));\n+    }\n+}",
    "output": "Add test case for OctalToDecimal"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/conversions/OctalToHexadecimalTest.java b/src/test/java/com/thealgorithms/conversions/OctalToHexadecimalTest.java\n--- a/src/test/java/com/thealgorithms/conversions/OctalToHexadecimalTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/OctalToHexadecimalTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.conversions;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class OctalToHexadecimalTest {\n+\n+    @Test\n+    public void testOctalToHexadecimal() {\n+        assertEquals(\"1EA\", OctalToHexadecimal.decimalToHex(OctalToHexadecimal.octToDec(\"752\")));\n+        assertEquals(\"15E\", OctalToHexadecimal.decimalToHex(OctalToHexadecimal.octToDec(\"536\")));\n+    }\n+}",
    "output": "Add test case for OctalToHexadecimal"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/conversions/HexToOctTest.java b/src/test/java/com/thealgorithms/conversions/HexToOctTest.java\n--- a/src/test/java/com/thealgorithms/conversions/HexToOctTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/HexToOctTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.conversions;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class HexToOctTest {\n+\n+    @Test\n+    public void testHexToOct() {\n+        assertEquals(110, HexToOct.decimal2octal(HexToOct.hex2decimal(\"48\")));\n+        assertEquals(255, HexToOct.decimal2octal(HexToOct.hex2decimal(\"AD\")));\n+    }\n+}",
    "output": "Add test case for HexToOct"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/conversions/IntegerToRomanTest.java b/src/test/java/com/thealgorithms/conversions/IntegerToRomanTest.java\n--- a/src/test/java/com/thealgorithms/conversions/IntegerToRomanTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/IntegerToRomanTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.conversions;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class IntegerToRomanTest {\n+\n+    @Test\n+    public void testIntegerToRoman() {\n+        assertEquals(\"MCMXCIV\", IntegerToRoman.integerToRoman(1994));\n+        assertEquals(\"LVIII\", IntegerToRoman.integerToRoman(58));\n+    }\n+}",
    "output": "Add test case for IntegerToRoman"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/strings/WordLadderTest.java b/src/test/java/com/thealgorithms/strings/WordLadderTest.java\n--- a/src/test/java/com/thealgorithms/strings/WordLadderTest.java\n+++ b/src/test/java/com/thealgorithms/strings/WordLadderTest.java\n@@ -0,0 +1,17 @@\n+package com.thealgorithms.strings;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+import java.util.*;\n+\n+public class WordLadderTest {\n+\n+    @Test\n+    public void testWordLadder() {\n+        String words1[] = { \"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\" };\n+        assertEquals(5, WordLadder.ladderLength(\"hit\", \"cog\", Arrays.asList(words1)));\n+        String words2[] = { \"hot\", \"dot\", \"dog\", \"lot\", \"log\" };\n+        assertEquals(0, WordLadder.ladderLength(\"hit\", \"cog\", Arrays.asList(words2)));\n+     }\n+}",
    "output": "Add tests for WordLadder"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/searches/HowManyTimesRotatedTest.java b/src/test/java/com/thealgorithms/searches/HowManyTimesRotatedTest.java\n--- a/src/test/java/com/thealgorithms/searches/HowManyTimesRotatedTest.java\n+++ b/src/test/java/com/thealgorithms/searches/HowManyTimesRotatedTest.java\n@@ -0,0 +1,17 @@\n+package com.thealgorithms.searches;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class HowManyTimesRotatedTest {\n+\n+    @Test\n+    public void testHowManyTimesRotated() {\n+        int[] arr1 = {5, 1,2,3,4};\n+        assertEquals(1, HowManyTimesRotated.rotated(arr1));\n+        int[] arr2 = {15,17,2,3,5};\n+        assertEquals(2, HowManyTimesRotated.rotated(arr2));\n+    }\n+}\n+",
    "output": "Add tests for HowManyTimesRotated"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/strings/CheckVowelsTest.java b/src/test/java/com/thealgorithms/strings/CheckVowelsTest.java\n--- a/src/test/java/com/thealgorithms/strings/CheckVowelsTest.java\n+++ b/src/test/java/com/thealgorithms/strings/CheckVowelsTest.java\n@@ -0,0 +1,16 @@\n+package com.thealgorithms.strings;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class CheckVowelsTest {\n+\n+    @Test\n+    public void isVowel() {\n+        assertTrue(CheckVowels.hasVowels(\"foo\"));\n+        assertTrue(CheckVowels.hasVowels(\"bar\"));\n+        assertFalse(CheckVowels.hasVowels(\"why\"));\n+        assertFalse(CheckVowels.hasVowels(\"myths\"));\n+    }\n+}",
    "output": "Add tests for vowels check"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/strings/RotationTest.java b/src/test/java/com/thealgorithms/strings/RotationTest.java\n--- a/src/test/java/com/thealgorithms/strings/RotationTest.java\n+++ b/src/test/java/com/thealgorithms/strings/RotationTest.java\n@@ -0,0 +1,15 @@\n+package com.thealgorithms.strings;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class RotationTest {\n+\n+    @Test\n+    public void testRotation() {\n+        assertEquals(\"eksge\", Rotation.rotation(\"geeks\", 2));\n+        assertEquals(\"anasban\", Rotation.rotation(\"bananas\", 3));\n+        assertEquals(\"abracadabra\", Rotation.rotation(\"abracadabra\", 0));\n+     }\n+}",
    "output": "Add test case for Rotation"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/strings/Anagrams.java b/src/main/java/com/thealgorithms/strings/Anagrams.java\n--- a/src/main/java/com/thealgorithms/strings/Anagrams.java\n+++ b/src/main/java/com/thealgorithms/strings/Anagrams.java\n@@ -121,13 +121,8 @@ boolean approach4(String s, String t) {\n             for (char c : t.toCharArray()) {\n                 kk.put(c, kk.getOrDefault(c, 0) + 1);\n             }\n-            // It checks for equal frequencies\n-            for (char c : nm.keySet()) {\n-                if (!nm.get(c).equals(kk.get(c))) {\n-                    return false;\n-                }\n-            }\n-            return true;\n+            // It checks for equal frequencies by comparing key-value pairs of two hashmaps\n+            return nm.equals(kk);\n         }\n     }\n }",
    "output": "Remove extra loop in Anagram.java"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/strings/ReverseStringTest.java b/src/test/java/com/thealgorithms/strings/ReverseStringTest.java\n--- a/src/test/java/com/thealgorithms/strings/ReverseStringTest.java\n+++ b/src/test/java/com/thealgorithms/strings/ReverseStringTest.java\n@@ -0,0 +1,31 @@\n+package com.thealgorithms.strings;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class ReverseStringTest {\n+\n+    @Test\n+    public void ReverseStringTest() {\n+        String input1 = \"Hello World\";\n+        String input2 = \"helloworld\";\n+        String input3 = \"123456789\";\n+        String input4 = \"\";\n+\n+        String expectedOutput1 = \"dlroW olleH\";\n+        String expectedOutput2 = \"dlrowolleh\";\n+        String expectedOutput3 = \"987654321\";\n+        String expectedOutput4 = \"\";\n+\n+        assertEquals(ReverseString.reverse(input1), expectedOutput1);\n+        assertEquals(ReverseString.reverse(input2), expectedOutput2);\n+        assertEquals(ReverseString.reverse(input3), expectedOutput3);\n+        assertEquals(ReverseString.reverse(input4), expectedOutput4);\n+\n+        assertEquals(ReverseString.reverse2(input1), expectedOutput1);\n+        assertEquals(ReverseString.reverse2(input2), expectedOutput2);\n+        assertEquals(ReverseString.reverse2(input3), expectedOutput3);\n+        assertEquals(ReverseString.reverse2(input4), expectedOutput4);\n+    }\n+}",
    "output": "Add ReverseStringTest"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/strings/LowerTest.java b/src/test/java/com/thealgorithms/strings/LowerTest.java\n--- a/src/test/java/com/thealgorithms/strings/LowerTest.java\n+++ b/src/test/java/com/thealgorithms/strings/LowerTest.java\n@@ -0,0 +1,18 @@\n+package com.thealgorithms.strings;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class LowerTest {\n+    @Test\n+    public void toLowerCase() {\n+        String input1 = \"hello world\";\n+        String input2 = \"HelLO WoRld\";\n+        String input3 = \"HELLO WORLD\";\n+        \n+        assertEquals(\"hello world\", Lower.toLowerCase(input1));\n+        assertEquals(\"hello world\", Lower.toLowerCase(input2));\n+        assertEquals(\"hello world\", Lower.toLowerCase(input3));\n+    }\n+}",
    "output": "Add test for Lower"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/searches/BinarySearch.java b/src/main/java/com/thealgorithms/searches/BinarySearch.java\n--- a/src/main/java/com/thealgorithms/searches/BinarySearch.java\n+++ b/src/main/java/com/thealgorithms/searches/BinarySearch.java\n@@ -31,7 +31,7 @@ class BinarySearch implements SearchAlgorithm {\n      */\n     @Override\n     public <T extends Comparable<T>> int find(T[] array, T key) {\n-        return search(array, key, 0, array.length);\n+        return search(array, key, 0, array.length - 1);\n     }\n \n     /**",
    "output": "Fix off-by-one error ()"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/heaps/GenericHeap.java b/src/main/java/com/thealgorithms/datastructures/heaps/GenericHeap.java\n--- a/src/main/java/com/thealgorithms/datastructures/heaps/GenericHeap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/heaps/GenericHeap.java\n@@ -1,3 +1,5 @@\n+package com.thealgorithms.datastructures.heaps;\n+\n import java.util.*;\n \n public class GenericHeap <T extends Comparable <T> >{",
    "output": "Fix missing package paths"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/heaps/MaxHeap.java b/src/main/java/com/thealgorithms/datastructures/heaps/MaxHeap.java\n--- a/src/main/java/com/thealgorithms/datastructures/heaps/MaxHeap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/heaps/MaxHeap.java\n@@ -43,6 +43,10 @@ public HeapElement getElement(int elementIndex) {\n \n     // Get the key of the element at a given index\n     private double getElementKey(int elementIndex) {\n+        if ((elementIndex <= 0) || (elementIndex > maxHeap.size())) {\n+            throw new IndexOutOfBoundsException(\"Index out of heap range\");\n+        }\n+        \n         return maxHeap.get(elementIndex - 1).getKey();\n     }\n \n\ndiff --git a/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java b/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java\n--- a/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java\n@@ -37,6 +37,10 @@ public HeapElement getElement(int elementIndex) {\n \n     // Get the key of the element at a given index\n     private double getElementKey(int elementIndex) {\n+        if ((elementIndex <= 0) || (elementIndex > minHeap.size())) {\n+            throw new IndexOutOfBoundsException(\"Index out of heap range\");\n+        }\n+        \n         return minHeap.get(elementIndex - 1).getKey();\n     }\n ",
    "output": "Add index validation to Min Heap and Max Heap"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/Intersection.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/Intersection.java\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/Intersection.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/Intersection.java\n@@ -0,0 +1,38 @@\n+package com.thealgorithms.datastructures.hashmap.hashing;\n+\n+/*\n+ * this is algo which implies common mathematical set theory concept\n+ * called intersection in which result is common values of both the sets\n+ * here metaphor of sets is HashMap\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class Intersection {\n+\n+    public static List<Integer> intersection(int[] arr1, int[] arr2) {\n+        if (arr1 == null || arr2 == null || arr1.length == 0 || arr2.length == 0) {\n+            return Collections.emptyList();\n+        }\n+        Map<Integer, Integer> cnt = new HashMap<>(16);\n+        for (int v : arr1) {\n+            cnt.put(v, cnt.getOrDefault(v, 0) + 1);\n+        }\n+        List<Integer> res = new ArrayList<>();\n+        for (int v : arr2) {\n+            if (cnt.containsKey(v) && cnt.get(v) > 0) {\n+                res.add(v);\n+                cnt.put(v, cnt.get(v) - 1);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private Intersection() {\n+\n+    }\n+}",
    "output": "Change filename for Intersection.java file"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java\n@@ -89,7 +89,9 @@ private Node findKey(Node n, int key) {\n         public void delete(int key) {\n             if (!isEmpty()) {\n                 if (first.getKey() == key) {\n-                    first = null;\n+                    Node next = first.next;\n+                    first.next = null; // help GC\n+                    first = next;\n                 } else {\n                     delete(first, key);\n                 }",
    "output": "Add a check of the existance of a next node\n*"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/AmicableNumberTest.java b/src/test/java/com/thealgorithms/maths/AmicableNumberTest.java\n--- a/src/test/java/com/thealgorithms/maths/AmicableNumberTest.java\n+++ b/src/test/java/com/thealgorithms/maths/AmicableNumberTest.java\n@@ -0,0 +1,15 @@\n+package com.thealgorithms.maths;\r\n+\r\n+import org.junit.jupiter.api.Test;\r\n+\r\n+import static org.assertj.core.api.Assertions.assertThat;\r\n+\r\n+public class AmicableNumberTest {\r\n+\r\n+    @Test\r\n+    void testAmicableNumber() {\r\n+        assertThat(AmicableNumber.isAmicableNumber(220, 284)).isTrue();\r\n+        assertThat(AmicableNumber.isAmicableNumber(1184, 1210)).isTrue();\r\n+        assertThat(AmicableNumber.isAmicableNumber(2620, 2924)).isTrue();\r\n+    }\r\n+}\r",
    "output": "Add tests for Amicable Numbers"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/AutomorphicNumberTest.java b/src/test/java/com/thealgorithms/maths/AutomorphicNumberTest.java\n--- a/src/test/java/com/thealgorithms/maths/AutomorphicNumberTest.java\n+++ b/src/test/java/com/thealgorithms/maths/AutomorphicNumberTest.java\n@@ -0,0 +1,16 @@\n+package com.thealgorithms.maths;\r\n+\r\n+import org.junit.jupiter.api.Test;\r\n+\r\n+import static org.assertj.core.api.Assertions.assertThat;\r\n+\r\n+public class AutomorphicNumberTest{\r\n+\r\n+    @Test\r\n+    void testAutomorphicNumber(){\r\n+        assertThat(AutomorphicNumber.isAutomorphic(625)).isTrue();\r\n+        assertThat(AutomorphicNumber.isAutomorphic(144)).isFalse();\r\n+        assertThat(AutomorphicNumber.isAutomorphic(9376)).isTrue();\r\n+        assertThat(AutomorphicNumber.isAutomorphic(169)).isFalse();\r\n+    }\r\n+}\r",
    "output": "Add testcase to Automorphic Number Algorithm"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/others/LinkListSortTest.java b/src/test/java/com/thealgorithms/others/LinkListSortTest.java\n--- a/src/test/java/com/thealgorithms/others/LinkListSortTest.java\n+++ b/src/test/java/com/thealgorithms/others/LinkListSortTest.java\n@@ -4,7 +4,7 @@\n import com.thealgorithms.sorts.LinkList_Sort;\n \n import static org.junit.jupiter.api.Assertions.*;\n-public class LinkList_Sort_test {\n+public class LinkListSortTest {\n     @Test\n \tvoid testForOneElement() \n \t{\n@@ -30,7 +30,7 @@ void testForThreeElements()\n \tvoid testForFourElements() \n \t{\n \t\tint a[]={86,32,87,13};\n-\t\tassertFalse(LinkList_Sort.isSorted(a,2));\n+\t\tassertTrue(LinkList_Sort.isSorted(a,1));\n \t}\n \n \t@Test\n@@ -59,6 +59,6 @@ void testForSevenElements()\n \tvoid testForEightElements() \n \t{\n \t\tint a[]={123,234,145,764,322,367,768,34};\n-\t\tassertFalse(LinkList_Sort.isSorted(a,2));\n+\t\tassertTrue(LinkList_Sort.isSorted(a,2));\n \t}\n }",
    "output": "Add Devcontainer Support"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java b/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java\n--- a/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java\n@@ -50,7 +50,7 @@ private void swap(int index1, int index2) {\n     // Toggle an element up to its right place as long as its key is lower than its parent's\n     private void toggleUp(int elementIndex) {\n         double key = minHeap.get(elementIndex - 1).getKey();\n-        while (getElementKey((int) Math.floor(elementIndex / 2.0)) > key) {\n+        while (getElementKey((int) Math.floor(elementIndex / 2.0) + 1) > key) {\n             swap(elementIndex, (int) Math.floor(elementIndex / 2.0));\n             elementIndex = (int) Math.floor(elementIndex / 2.0);\n         }",
    "output": "Fix off-by-one mistake in MinHeap.java"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/others/PasswordGenTest.java b/src/test/java/com/thealgorithms/others/PasswordGenTest.java\n--- a/src/test/java/com/thealgorithms/others/PasswordGenTest.java\n+++ b/src/test/java/com/thealgorithms/others/PasswordGenTest.java\n@@ -0,0 +1,37 @@\n+package com.thealgorithms.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\n+public class PasswordGenTest {\n+    @Test \n+    public void failGenerationWithSameMinMaxLengthTest() {\n+        int length = 10;\n+        assertThrows(IllegalArgumentException.class, ()-> {\n+            PasswordGen.generatePassword(length, length);\n+        });\n+    }\n+\n+    @Test\n+    public void generateOneCharacterPassword() {\n+        String tempPassword = PasswordGen.generatePassword(1, 2);\n+        assertTrue(tempPassword.length()==1);\n+    }\n+\n+    @Test\n+    public void failGenerationWithMinLengthSmallerThanMaxLengthTest() {\n+        int minLength = 10;\n+        int maxLength = 5;\n+        assertThrows(IllegalArgumentException.class, ()-> {\n+            PasswordGen.generatePassword(minLength, maxLength);\n+        });\n+    }\n+\n+    @Test\n+    public void generatePasswordNonEmptyTest() {\n+        String tempPassword = PasswordGen.generatePassword(8, 16);\n+        assertTrue(tempPassword.length()!=0);\n+    }\n+}",
    "output": "Add tests for PasswordGen"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/PerfectSquareTest.java b/src/test/java/com/thealgorithms/maths/PerfectSquareTest.java\n--- a/src/test/java/com/thealgorithms/maths/PerfectSquareTest.java\n+++ b/src/test/java/com/thealgorithms/maths/PerfectSquareTest.java\n@@ -0,0 +1,37 @@\n+package com.thealgorithms.maths;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\n+public class PerfectSquareTest{\n+\t\n+\t@Test\n+\tpublic void TestPerfectSquareifiscorrect(){\n+\t\t//Valid Partition\n+\t\tint number = 9;\n+\t\t\n+\t\tboolean result = PerfectSquare.isPerfectSquare(number);\n+\t\t\n+\t\tassertTrue(result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void TestPerfectSquareifisnotcorrect(){\n+\t\t//Invalid Partition 1\n+\t\tint number = 3;\n+\t\t\n+\t\tboolean result = PerfectSquare.isPerfectSquare(number);\n+\t\t\n+\t\tassertFalse(result);\n+\t}\n+\t@Test\n+\tpublic void TestPerfectSquareifisNegativeNumber(){\n+\t\t//Invalid Partition 2\n+\t\tint number = -10;\n+\n+\t\tboolean result = PerfectSquare.isPerfectSquare(number);\n+\n+\t\tassertFalse(result);\n+\t}\n+}",
    "output": "Add tests for isPerfectSquare"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/SumOfDigitsTest.java b/src/test/java/com/thealgorithms/maths/SumOfDigitsTest.java\n--- a/src/test/java/com/thealgorithms/maths/SumOfDigitsTest.java\n+++ b/src/test/java/com/thealgorithms/maths/SumOfDigitsTest.java\n@@ -0,0 +1,25 @@\n+package com.thealgorithms.maths;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+/**\n+ * @author SirFixalot16\n+ * @since 01/06/22\n+ */\n+public class SumOfDigitsTest {\n+    @Test\n+    void isSumOf2Digits() {\n+        SumOfDigits sum = new SumOfDigits();\n+        assertEquals(11, sum.sumOfDigits(56));\n+    }\n+    void isSumOf3Digits() {\n+        SumOfDigits sum = new SumOfDigits();\n+        assertEquals(12, sum.sumOfDigits(192));\n+    }\n+    void isSumOf4Digits() {\n+        SumOfDigits sum = new SumOfDigits();\n+        assertEquals(25, sum.sumOfDigits(8962));\n+    }\n+}",
    "output": "Add tests for sum of digits"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/FactorialTest.java b/src/test/java/com/thealgorithms/maths/FactorialTest.java\n--- a/src/test/java/com/thealgorithms/maths/FactorialTest.java\n+++ b/src/test/java/com/thealgorithms/maths/FactorialTest.java\n@@ -0,0 +1,16 @@\n+package com.thealgorithms.maths;\r\n+\r\n+import org.junit.jupiter.api.Test;\r\n+import static org.junit.jupiter.api.Assertions.*;\r\n+\r\n+\r\n+\r\n+public class FactorialTest {\r\n+\r\n+    @Test\r\n+    public void test() {\r\n+        Factorial fact = new Factorial();\r\n+        assertEquals(120,fact.factorial(5));\r\n+ }\r\n+\r\n+}\n\\ No newline at end of file",
    "output": "Add tests for factorial"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/AverageTest.java b/src/test/java/com/thealgorithms/maths/AverageTest.java\n--- a/src/test/java/com/thealgorithms/maths/AverageTest.java\n+++ b/src/test/java/com/thealgorithms/maths/AverageTest.java\n@@ -0,0 +1,14 @@\n+package com.thealgorithms.maths;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+\n+public class AverageTest {\n+    double [] numbers = {3, 6, 9, 12, 15, 18, 21};\n+    @Test\n+    public void testAverage() {\n+        \n+        Assertions.assertEquals(12, Average.average(numbers));\n+    }\n+}",
    "output": "Add a test for average"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/TestArmstrong.java b/src/test/java/com/thealgorithms/maths/TestArmstrong.java\n--- a/src/test/java/com/thealgorithms/maths/TestArmstrong.java\n+++ b/src/test/java/com/thealgorithms/maths/TestArmstrong.java\n@@ -0,0 +1,15 @@\n+package com.thealgorithms.maths;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestArmstrong {\n+\n+    @Test\n+    public void testArmstrong() {\n+        Armstrong armstrong = new Armstrong();\n+        assertThat(armstrong.isArmstrong(371)).isTrue();\n+        assertThat(armstrong.isArmstrong(200)).isFalse();\n+    }\n+}",
    "output": "Add test for Armstrong"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/FindMinTest.java b/src/test/java/com/thealgorithms/maths/FindMinTest.java\n--- a/src/test/java/com/thealgorithms/maths/FindMinTest.java\n+++ b/src/test/java/com/thealgorithms/maths/FindMinTest.java\n@@ -1,10 +1,14 @@\n package com.thealgorithms.maths;\n \n-\n import org.junit.jupiter.api.Test;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n public class FindMinTest {\n+  @Test\n+  public void testFindMinValue(){\n+    assertEquals(1, FindMin.findMin(new int[] {1,2,3,4,5,6,7,8,9,10}));\n+  }\n+\n   @Test\n   public void test1(){\n     assertEquals(1, FindMin.findMin(new int[] {1, 3, 5, 7, 9}));",
    "output": "Add more tests for findMin"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/FindMinTest.java b/src/test/java/com/thealgorithms/maths/FindMinTest.java\n--- a/src/test/java/com/thealgorithms/maths/FindMinTest.java\n+++ b/src/test/java/com/thealgorithms/maths/FindMinTest.java\n@@ -0,0 +1,17 @@\n+package com.thealgorithms.maths;\n+\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class FindMinTest {\n+  @Test\n+  public void test1(){\n+    assertEquals(1, FindMin.findMin(new int[] {1, 3, 5, 7, 9}));\n+  }\n+  \n+  @Test\n+  public void test2(){\n+    assertEquals(0, FindMin.findMin(new int[] {0, 192, 384, 576}));\n+  }\n+}",
    "output": "Add Tests for FindMin"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/PythagoreanTripleTest.java b/src/test/java/com/thealgorithms/maths/PythagoreanTripleTest.java\n--- a/src/test/java/com/thealgorithms/maths/PythagoreanTripleTest.java\n+++ b/src/test/java/com/thealgorithms/maths/PythagoreanTripleTest.java\n@@ -0,0 +1,20 @@\n+package com.thealgorithms.maths;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class PythagoreanTripleTest {\n+    @Test\n+    public void Testpythagoreantriple(){\n+        \n+        assertEquals(true, PythagoreanTriple.isPythagTriple(3,4,5));\n+        assertEquals(true, PythagoreanTriple.isPythagTriple(6,8,10));\n+        assertEquals(true, PythagoreanTriple.isPythagTriple(9,12,15));\n+        assertEquals(true, PythagoreanTriple.isPythagTriple(12,16,20));\n+        assertEquals(true, PythagoreanTriple.isPythagTriple(15,20,25));\n+        assertEquals(true, PythagoreanTriple.isPythagTriple(18,24,30));        \n+        assertEquals(false, PythagoreanTriple.isPythagTriple(5,20,30));\n+        assertEquals(false, PythagoreanTriple.isPythagTriple(6,8,100));\n+        assertEquals(false, PythagoreanTriple.isPythagTriple(-2,-2,2));   \n+    }\n+}",
    "output": "Add tests for PythagoreanTriple"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/maths/FindMaxTest.java b/src/test/java/com/thealgorithms/maths/FindMaxTest.java\n--- a/src/test/java/com/thealgorithms/maths/FindMaxTest.java\n+++ b/src/test/java/com/thealgorithms/maths/FindMaxTest.java\n@@ -0,0 +1,12 @@\n+package com.thealgorithms.maths;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class FindMaxTest {\n+    \n+    @Test\n+    public void testFindMaxValue(){\n+        assertEquals(10, FindMax.findMax(new int[] {1,2,3,4,5,6,7,8,9,10}));\n+    }\n+}",
    "output": "Add tests for findMax"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/sorts/TimSort.java b/src/main/java/com/thealgorithms/sorts/TimSort.java\n--- a/src/main/java/com/thealgorithms/sorts/TimSort.java\n+++ b/src/main/java/com/thealgorithms/sorts/TimSort.java\n@@ -71,10 +71,10 @@ public TimSort() {\n      * sorting.\n      */\n     public void insertion_sort(int[] array, int start_idx, int end_idx) {\n-        for (int i = 0; i < array.length; i++) {\n+        for (int i = start_idx; i <= end_idx; i++) {\n             int current_element = array[i];\n             int j = i - 1;\n-            while (j >= 0 && array[j] > current_element) {\n+            while (j >= start_idx && array[j] > current_element) {\n                 array[j + 1] = array[j];\n                 j--;\n             }",
    "output": "Fix Bug in Tim Sort"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java\n@@ -105,6 +105,8 @@ private void delete(Node n, int key) {\n                 } else {\n                     n.setNext(n.getNext().getNext());\n                 }\n+            } else {\n+                delete(n.getNext(), key);\n             }\n         }\n ",
    "output": "Add else clause for node"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/strings/Upper.java b/src/main/java/com/thealgorithms/strings/Upper.java\n--- a/src/main/java/com/thealgorithms/strings/Upper.java\n+++ b/src/main/java/com/thealgorithms/strings/Upper.java\n@@ -19,6 +19,9 @@ public static void main(String[] args) {\n      * @return the {@code String}, converted to uppercase.\n      */\n     public static String toUpperCase(String s) {\n+        if (s == null || \"\".equals(s)) {\n+            return s;\n+        }\n         char[] values = s.toCharArray();\n         for (int i = 0; i < values.length; ++i) {\n             if (Character.isLetter(values[i]) && Character.isLowerCase(values[i])) {",
    "output": "Fix Null Pointer Exception in strings/Upper"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/strings/UpperTest.java b/src/test/java/com/thealgorithms/strings/UpperTest.java\n--- a/src/test/java/com/thealgorithms/strings/UpperTest.java\n+++ b/src/test/java/com/thealgorithms/strings/UpperTest.java\n@@ -0,0 +1,17 @@\n+package com.thealgorithms.strings;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class UpperTest {\n+    @Test\n+    public void toUpperCase() {\n+        String input1 = \"hello world\";\n+        String input2 = \"hElLo WoRlD\";\n+        String input3 = \"HELLO WORLD\";\n+        assertEquals(\"HELLO WORLD\", Upper.toUpperCase(input1));\n+        assertEquals(\"HELLO WORLD\", Upper.toUpperCase(input2));\n+        assertEquals(\"HELLO WORLD\", Upper.toUpperCase(input3));\n+    }\n+}",
    "output": "Add test for Upper"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/strings/PalindromeTest.java b/src/test/java/com/thealgorithms/strings/PalindromeTest.java\n--- a/src/test/java/com/thealgorithms/strings/PalindromeTest.java\n+++ b/src/test/java/com/thealgorithms/strings/PalindromeTest.java\n@@ -0,0 +1,18 @@\n+package com.thealgorithms.strings;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+public class PalindromeTest {\n+    @Test\n+    public void palindrome() {\n+        String input1 = \"kayak\";\n+        String input2 = \"kayaks\";\n+        Assertions.assertTrue(Palindrome.isPalindrome(input1));\n+        Assertions.assertFalse(Palindrome.isPalindrome(input2));\n+        Assertions.assertTrue(Palindrome.isPalindromeRecursion(input1));\n+        Assertions.assertFalse(Palindrome.isPalindromeRecursion(input2));\n+        Assertions.assertTrue(Palindrome.isPalindrome1(input1));\n+        Assertions.assertFalse(Palindrome.isPalindrome1(input2));\n+    }\n+}",
    "output": "Add test for Palindrome"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/strings/CharacterSameTest.java b/src/test/java/com/thealgorithms/strings/CharacterSameTest.java\n--- a/src/test/java/com/thealgorithms/strings/CharacterSameTest.java\n+++ b/src/test/java/com/thealgorithms/strings/CharacterSameTest.java\n@@ -0,0 +1,28 @@\n+package com.thealgorithms.strings;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\n+public class CharacterSameTest {\n+    @Test\n+    public void isAllCharactersSame() {\n+        String input1 = \"aaa\";\n+        String input2 = \"abc\";\n+        String input3 = \"1  1  1  1\";\n+        String input4 = \"111\";\n+        String input5 = \"\";\n+        String input6 = \"           \";\n+        String input7 = \".       \";\n+\n+        assertTrue(CharactersSame.isAllCharactersSame(input1));\n+        assertFalse(CharactersSame.isAllCharactersSame(input2));\n+        assertFalse(CharactersSame.isAllCharactersSame(input3));\n+        assertTrue(CharactersSame.isAllCharactersSame(input4));\n+        assertTrue(CharactersSame.isAllCharactersSame(input5));\n+        assertTrue(CharactersSame.isAllCharactersSame(input6));\n+        assertFalse(CharactersSame.isAllCharactersSame(input7));\n+\n+    }\n+\n+}",
    "output": "Add tests for CharacterSame"
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/strings/PangramTest.java b/src/test/java/com/thealgorithms/strings/PangramTest.java\n--- a/src/test/java/com/thealgorithms/strings/PangramTest.java\n+++ b/src/test/java/com/thealgorithms/strings/PangramTest.java\n@@ -0,0 +1,24 @@\n+package com.thealgorithms.strings;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\n+public class PangramTest {\n+    @Test\n+    public void isPangram() {\n+        String fullAlphabet = \"abcdefghijklmnopqrstuvwxyz\";\n+        String notFullAlphabet = \"abcdefghiklmnopqrstuvwxyz\";\n+        String fullMixedCaseAlphabet = \"a BCDE fghIjkLMnop qrSTuv WXYz\";\n+        String sentence1 = \"The quick brown fox jumps over the lazy dog\";\n+        String sentence2 = \"The quick brown fox jumps over the lazy gentleman\";  // missing letter d\n+\n+        assertTrue(Pangram.isPangram(fullAlphabet));\n+        assertFalse(Pangram.isPangram(notFullAlphabet));\n+        assertTrue(Pangram.isPangram(fullMixedCaseAlphabet));\n+        assertTrue(Pangram.isPangram(sentence1));\n+        assertFalse(Pangram.isPangram(sentence2));\n+\n+    }\n+}",
    "output": "Add test for Pangram.java"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/FFT.java b/src/main/java/com/thealgorithms/maths/FFT.java\n--- a/src/main/java/com/thealgorithms/maths/FFT.java\n+++ b/src/main/java/com/thealgorithms/maths/FFT.java\n@@ -142,8 +142,10 @@ public double abs() {\n          */\n         public Complex divide(Complex z) {\n             Complex temp = new Complex();\n-            temp.real = (this.real * z.real + this.img * z.img) / (z.abs() * z.abs());\n-            temp.img = (this.img * z.real - this.real * z.img) / (z.abs() * z.abs());\n+            double d = z.abs() * z.abs();\n+            d = (double)Math.round(d * 1000000000d) / 1000000000d;\n+            temp.real = (this.real * z.real + this.img * z.img) / (d);\n+            temp.img = (this.img * z.real - this.real * z.img) / (d);\n             return temp;\n         }\n ",
    "output": "Fix rounding in FFT ()"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/trees/AVLSimple.java b/src/main/java/com/thealgorithms/datastructures/trees/AVLSimple.java\n--- a/src/main/java/com/thealgorithms/datastructures/trees/AVLSimple.java\n+++ b/src/main/java/com/thealgorithms/datastructures/trees/AVLSimple.java\n@@ -29,7 +29,7 @@\n \n \n \n-public class AVLTree {\n+public class AVLSimple {\n \tprivate class Node{\n \t\tint data;\n \t\tint height;\n@@ -82,7 +82,7 @@ public void display() {\n \t\tSystem.out.println(this.root.height);\n \t}\n \tprivate void display (Node node) {\n-\t\tStrings str=\"\";\n+\t\tString str=\"\";\n \t\tif(node.left!=null)\n \t\t\tstr+=node.left.data+\"=>\";\n \t\telse",
    "output": "Fix typos ()"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/strings/LongestPalindromicSubstring.java b/src/main/java/com/thealgorithms/strings/LongestPalindromicSubstring.java\n--- a/src/main/java/com/thealgorithms/strings/LongestPalindromicSubstring.java\n+++ b/src/main/java/com/thealgorithms/strings/LongestPalindromicSubstring.java\n@@ -3,8 +3,6 @@\n // Longest Palindromic Substring\n import java.util.Scanner;\n \n-;\n-\n class LongestPalindromicSubstring {\n \n     public static void main(String[] args) {",
    "output": "Upgrade LongestPalindromicSubstring - Remove ; Removing unnecessary semi-colon ';'"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/Volume.java b/src/main/java/com/thealgorithms/maths/Volume.java\n--- a/src/main/java/com/thealgorithms/maths/Volume.java\n+++ b/src/main/java/com/thealgorithms/maths/Volume.java\n@@ -23,6 +23,12 @@ public static void main(String[] args) {\n \n         /* test cone */\n         assert Double.compare(volumeCone(5, 7), 916.297857297023) == 0;\n+        \n+        /*test prism*/\n+        assert Double.compare(volumePrism(10, 2), 20.0) == 0;\n+        \n+        /*test pyramid*/\n+        assert Double.compare(volumePyramid(10, 3), 10.0) == 0;\n \n     }\n \n@@ -89,4 +95,26 @@ private static double volumeHemisphere(double radius) {\n     private static double volumeCone(double radius, double height) {\n         return Math.PI * radius * radius * height / 3;\n     }\n+    \n+    /**\n+     * Calculate the volume of a prism.\n+     *\n+     * @param area of the base.\n+     * @param height of prism.\n+     * @return volume of given prism.\n+     */\n+    private static double volumePrism(double basearea, double height) {\n+        return basearea * height;\n+    }\n+    \n+    /**\n+     * Calculate the volume of a pyramid.\n+     *\n+     * @param area of the base.\n+     * @param height of pyramid.\n+     * @return volume of given pyramid.\n+     */\n+    private static double volumePyramid(double basearea, double height) {\n+        return basearea * height / 3;\n+    }\n }",
    "output": "Add volume of prism and pyramid"
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/graphs/A_Star.java b/src/main/java/com/thealgorithms/datastructures/graphs/A_Star.java\n--- a/src/main/java/com/thealgorithms/datastructures/graphs/A_Star.java\n+++ b/src/main/java/com/thealgorithms/datastructures/graphs/A_Star.java\n@@ -16,7 +16,7 @@ private static class Graph {\n         public Graph(int size) {\n             this.graph = new ArrayList<>();\n             for (int i = 0; i < size; i++) {\n-                this.graph.set(i, new ArrayList<>());\n+                this.graph.add(new ArrayList<>());\n             }\n         }\n ",
    "output": "Fix a bug in A_Star.Graph in jdk17"
  },
  {
    "input": "diff --git a/Sorts/BubbleSort.java b/Sorts/BubbleSort.java\n--- a/Sorts/BubbleSort.java\n+++ b/Sorts/BubbleSort.java\n@@ -18,9 +18,9 @@ class BubbleSort implements SortAlgorithm {\n    */\n   @Override\n   public <T extends Comparable<T>> T[] sort(T[] array) {\n-    for (int i = 0, size = array.length; i < size - 1; ++i) {\n+    for (int i = 1, size = array.length; i < size; ++i) {\n       boolean swapped = false;\n-      for (int j = 0; j < size - 1 - i; ++j) {\n+      for (int j = 0; j < size - i; ++j) {\n         if (greater(array[j], array[j + 1])) {\n           swap(array, j, j + 1);\n           swapped = true;",
    "output": "Upgrade bubble sort"
  },
  {
    "input": "diff --git a/DataStructures/Stacks/DuplicateBrackets.java b/DataStructures/Stacks/DuplicateBrackets.java\n--- a/DataStructures/Stacks/DuplicateBrackets.java\n+++ b/DataStructures/Stacks/DuplicateBrackets.java\n@@ -0,0 +1,45 @@\n+//  1. You are given a string exp representing an expression.\n+// 2. Assume that the expression is balanced  i.e. the opening and closing brackets match with each other.\n+// 3. But, some of the pair of brackets maybe extra/needless. \n+// 4. You are required to print true if you detect extra brackets and false otherwise.\n+\n+// e.g.'\n+// ((a + b) + (c + d)) -> false\n+// (a + b) + ((c + d)) -> true\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+public class DuplicateBrackets {\n+\n+    public static boolean check(String str){\n+        Stack<Character> st = new Stack<>();\n+        \n+        for(int i=0;i<str.length();i++){\n+            char ch = str.charAt(i);\n+            if(ch==')'){\n+                if(st.peek()=='('){\n+                    return true;\n+                }else{\n+                    while(st.size()>0 && st.peek()!='('){\n+                        st.pop();\n+                    }\n+                    st.pop();\n+                }\n+                \n+            }else{\n+                st.push(ch);\n+            }\n+            // System.out.println(st);\n+        }\n+        return false;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Scanner sc = new Scanner(System.in);\n+        String str = sc.nextLine();\n+        System.out.println(check(str));\n+    }\n+\n+}",
    "output": "Add Duplicate Brackets"
  },
  {
    "input": "diff --git a/Maths/ReverseNumber.java b/Maths/ReverseNumber.java\n--- a/Maths/ReverseNumber.java\n+++ b/Maths/ReverseNumber.java\n@@ -0,0 +1,30 @@\n+package Maths;\n+\n+import java.util.Scanner;\n+import java.util.NoSuchElementException;\n+import java.lang.IllegalStateException;\n+\n+public class ReverseNumber {\n+    public static void main(String[] args) {  \n+        int number;\n+        int reverse = 0;\n+\n+        try (Scanner sc = new Scanner(System.in)) {\n+            System.out.println(\"Enter a number:\");\n+            number = sc.nextInt();\n+        } catch (NoSuchElementException | IllegalStateException e) {\n+            System.out.println(\"ERROR: Invalid input\");\n+            return;\n+        }\n+        \n+\n+        while(number != 0)   {  \n+            int remainder = number % 10;\n+\n+            reverse = reverse * 10 + remainder;  \n+            number = number/10;  \n+        }\n+\n+        System.out.println(\"The reverse of the given number is: \" + reverse);  \n+    }    \n+}",
    "output": "Add reverse number"
  },
  {
    "input": "diff --git a/Others/BoyerMoore.java b/Others/BoyerMoore.java\n--- a/Others/BoyerMoore.java\n+++ b/Others/BoyerMoore.java\n@@ -0,0 +1,40 @@\n+/* this Code is the illustration of Boyer moore's voting algorithm to\n+find the majority element is an array that appears more than n/2 times in an array\n+where \"n\" is the length of the array.\n+For more information on the algorithm refer https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n+ */\n+package Others;\n+import java.util.*;\n+\n+public class BoyerMoore {\n+    public static int findmajor(int [] a){\n+int count=0; int cand=-1;\n+for(int i=0;i<a.length;i++){\n+    if(count==0){\n+        cand=a[i];\n+        count=1;\n+    }\n+    else {\n+        if (a[i] == cand)\n+            count++;\n+        else\n+            count--;\n+    }\n+}for (int i = 0; i < a.length; i++) {\n+            if (a[i] == cand)\n+                count++;}\n+        if (count > (a.length / 2))\n+            return cand;\n+        return -1;\n+}\n+    public static void main(String args[]){\n+        Scanner input=new Scanner(System.in);\n+        int n=input.nextInt();\n+        int a[]=new int[n];\n+        for(int i=0;i<n;i++){\n+            a[i]=input.nextInt();\n+        }\n+       System.out.println(\"the majority element is \"+findmajor(a));\n+\n+    }\n+}\n\\ No newline at end of file",
    "output": "Add Boyer moore voting algo"
  },
  {
    "input": "diff --git a/Maths/ADTFraction.java b/Maths/ADTFraction.java\n--- a/Maths/ADTFraction.java\n+++ b/Maths/ADTFraction.java\n@@ -1,10 +1,6 @@\n-\n package Maths;\n \n-\n public class ADTFraction {\n-\n-   \n     public static void main(String[] args) {\n         // TODO code application logic here\n \n@@ -21,9 +17,6 @@ public static void main(String[] args) {\n \n     }\n \n-}\n-\n-class ADTFraction {\n     private int n; //numerator\n     private int d; //denomenator\n ",
    "output": "Fix build issue in ADTFraction.java"
  },
  {
    "input": "diff --git a/Maths/TrinomialTriangle.java b/Maths/TrinomialTriangle.java\n--- a/Maths/TrinomialTriangle.java\n+++ b/Maths/TrinomialTriangle.java\n@@ -0,0 +1,47 @@\n+package Maths;\n+\n+/**\n+ * The trinomial triangle is a variation of Pascals triangle. The difference\n+ * between the two is that an entry in the trinomial triangle is the sum of the\n+ * three (rather than the two in Pasacals triangle) entries above it\n+ * \n+ * Example Input: n = 4 \n+ * Output \n+ * 1 \n+ * 1 1 1 \n+ * 1 2 3 2 1 \n+ * 1 3 6 7 6 3 1\n+ */\n+public class TrinomialTriangle {\n+\n+    public static int TrinomialValue(int n, int k) {\n+        if (n == 0 && k == 0) {\n+            return 1;\n+        }\n+\n+        if (k < -n || k > n) {\n+            return 0;\n+        }\n+\n+        return TrinomialValue(n - 1, k - 1) + TrinomialValue(n - 1, k) + TrinomialValue(n - 1, k + 1);\n+    }\n+\n+    public static void printTrinomial(int n) {\n+        for (int i = 0; i < n; i++) {\n+            for (int j = -i; j <= 0; j++) {\n+                System.out.print(TrinomialValue(i, j) + \" \");\n+            }\n+\n+            for (int j = 1; j <= i; j++) {\n+                System.out.print(TrinomialValue(i, j) + \" \");\n+            }\n+\n+            System.out.println();\n+        }\n+    }\n+\n+    public static void main(String argc[]) {\n+        int n = 6;\n+        printTrinomial(n);\n+    }\n+}",
    "output": "Add Trinomial triangle"
  },
  {
    "input": "diff --git a/Maths/LeonardoNumber.java b/Maths/LeonardoNumber.java\n--- a/Maths/LeonardoNumber.java\n+++ b/Maths/LeonardoNumber.java\n@@ -0,0 +1,20 @@\n+package Maths;\n+\n+public class LeonardoNumber {\n+    public static int leonardoNumber(int n) {\n+        if (n < 0) {\n+            return 0;\n+        }\n+        if (n == 0 || n == 1) {\n+            return 1;\n+        }\n+        return (leonardoNumber(n - 1) + leonardoNumber(n - 2) + 1);\n+    }\n+\n+    public static void main(String args[]) {\n+        for (int i = 0; i < 20; i++) {\n+            System.out.print(leonardoNumber(i) + \" \");\n+        }\n+\n+    }\n+}",
    "output": "Add Leonardo Number"
  },
  {
    "input": "diff --git a/DataStructures/Trees/FenwickTree.java b/DataStructures/Trees/FenwickTree.java\n--- a/DataStructures/Trees/FenwickTree.java\n+++ b/DataStructures/Trees/FenwickTree.java\n@@ -0,0 +1,34 @@\n+package DataStructures.Trees;\n+\n+public class FenwickTree {\n+    private int n;\n+    private int fen_t[];\n+    \n+    /* Constructor which takes the size of the array as a parameter */\n+    public FenwickTree(int n) {\n+        this.n = n;\n+        this.fen_t = new int[n + 1];\n+    }\n+    \n+    /* A function which will add the element val at index i*/\n+    public void update(int i, int val) {\n+        // As index starts from 0, increment the index by 1\n+        i += 1;\n+        while (i <= n) {\n+            fen_t[i] += val;\n+            i += i & (-i);\n+        }\n+    }\n+    \n+    /* A function which will return the cumulative sum from index 1 to index i*/\n+    public int query(int i) {\n+        // As index starts from 0, increment the index by 1\n+        i += 1;\n+        int cumSum = 0;\n+        while (i > 0) {\n+            cumSum += fen_t[i];\n+            i -= i & (-i);\n+        }\n+        return cumSum;\n+    }\n+}\n\\ No newline at end of file",
    "output": "Add Fenwick Tree"
  },
  {
    "input": "diff --git a/Others/MiniMaxAlgorithm.java b/Others/MiniMaxAlgorithm.java\n--- a/Others/MiniMaxAlgorithm.java\n+++ b/Others/MiniMaxAlgorithm.java\n@@ -97,8 +97,8 @@ public static int[] getRandomScores(int size, int maxScore) {\n         int[] randomScores = new int[(int) Math.pow(2, size)];\r\n         Random rand = new Random();\r\n \r\n-        for (int a : randomScores) {\r\n-            a = rand.nextInt(maxScore) + 1;\r\n+        for (int i = 0; i < randomScores.length; i++) {\r\n+            randomScores[i] = rand.nextInt(maxScore) + 1;\r\n         }\r\n \r\n         return randomScores;\r",
    "output": "Fix random number generation in MiniMax Algorithm"
  },
  {
    "input": "diff --git a/Sorts/SimpleSort.java b/Sorts/SimpleSort.java\n--- a/Sorts/SimpleSort.java\n+++ b/Sorts/SimpleSort.java\n@@ -0,0 +1,46 @@\n+package Sorts;\n+\n+import static Sorts.SortUtils.*;\n+\n+public class SimpleSort implements SortAlgorithm {\n+\n+    @Override\n+    public <T extends Comparable<T>> T[] sort(T[] array) {\n+        final int LENGTH = array.length;\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            for (int j = i + 1; j < LENGTH; j++) {\n+                if (less(array[j], array[i])) {\n+                    T element = array[j];\n+                    array[j] = array[i];\n+                    array[i] = element;\n+                }\n+            }\n+        }\n+\n+        return array;\n+    }\n+\n+    public static void main(String[] args) {\n+        // ==== Int =======\n+        Integer[] a = { 3, 7, 45, 1, 33, 5, 2, 9 };\n+        System.out.print(\"unsorted: \");\n+        print(a);\n+        System.out.println();\n+\n+        new SimpleSort().sort(a);\n+        System.out.print(\"sorted: \");\n+        print(a);\n+        System.out.println();\n+\n+        // ==== String =======\n+        String[] b = { \"banana\", \"berry\", \"orange\", \"grape\", \"peach\", \"cherry\", \"apple\", \"pineapple\" };\n+        System.out.print(\"unsorted: \");\n+        print(b);\n+        System.out.println();\n+\n+        new SimpleSort().sort(b);\n+        System.out.print(\"sorted: \");\n+        print(b);\n+    }\n+}",
    "output": "Add Simple Sort"
  },
  {
    "input": "diff --git a/DynamicProgramming/Sum_Of_Subset.java b/DynamicProgramming/Sum_Of_Subset.java\n--- a/DynamicProgramming/Sum_Of_Subset.java\n+++ b/DynamicProgramming/Sum_Of_Subset.java\n@@ -0,0 +1,28 @@\n+public class Sum_Of_Subset {\n+        public static void main(String[] args){\n+    \n+        int[] arr = { 7, 3, 2, 5, 8 };\n+        int Key = 14;\n+ \n+        if (subsetSum(arr, arr.length - 1, Key)) {\n+            System.out.print(\"Yes, that sum exists\");\n+        }\n+        else {\n+            System.out.print(\"Nope, that number does not exist\");\n+        }\n+    }\n+    public static boolean subsetSum(int[] arr, int num, int Key)\n+    {\n+        if (Key == 0) {\n+            return true;\n+        }\n+        if (num < 0 || Key < 0) {\n+            return false;\n+        }\n+\n+        boolean include = subsetSum(arr, num - 1, Key - arr[num]);\n+        boolean exclude = subsetSum(arr, num - 1, Key);\n+\n+        return include || exclude;\n+    }\n+}",
    "output": "Add sum of subset problem using DP"
  },
  {
    "input": "diff --git a/Maths/GenericRoot.java b/Maths/GenericRoot.java\n--- a/Maths/GenericRoot.java\n+++ b/Maths/GenericRoot.java\n@@ -0,0 +1,26 @@\n+/*\n+ * Algorithm explanation: https://technotip.com/6774/c-program-to-find-generic-root-of-a-number/#:~:text=Generic%20Root%3A%20of%20a%20number,get%20a%20single%2Ddigit%20output.&text=For%20Example%3A%20If%20user%20input,%2B%204%20%2B%205%20%3D%2015.\n+ */\n+public class GenericRoot {\n+\tpublic static void main(String[] args) {\n+\t\tint number1 = 1234;\n+\t\tint number2 = 12345;\n+\t\tint result1 = genericRoot(number1);\n+\t\tint result2 = genericRoot(number2);\n+\t\tSystem.out.println(\"Generic root of \" + number1 + \" is: \" + result1);\n+\t\tSystem.out.println(\"Generic root of \" + number2 + \" is: \" + result2);\n+\t}\n+\n+\tprivate static int genericRoot(int n) {\n+\t\tint root = 0;\n+\t\twhile (n > 0 || root > 9) {\n+\t\t\tif (n == 0) {\n+\t\t\t\tn = root;\n+\t\t\t\troot = 0;\n+\t\t\t}\n+\t\t\troot += n % 10;\n+\t\t\tn /= 10;\n+\t\t}\n+\t\treturn root;\n+\t}\n+}",
    "output": "Add generic root of a number [Hacktoberfest]"
  },
  {
    "input": "diff --git a/Strings/LongestPalindromicSubstring.java b/Strings/LongestPalindromicSubstring.java\n--- a/Strings/LongestPalindromicSubstring.java\n+++ b/Strings/LongestPalindromicSubstring.java\n@@ -0,0 +1,44 @@\n+// Longest Palindromic Substring\n+import java.util.Scanner;;\n+\n+\n+class LongestPalindromicSubstring {\n+    public static void main(String[] args) {\n+        Solution s = new Solution();\n+        String str = \"\";\n+        Scanner sc = new Scanner(System.in);\n+        System.out.print(\"Enter the string: \");\n+        str = sc.nextLine();\n+        System.out.println(\"Longest substring is : \"+s.longestPalindrome(str));\n+    }\n+}\n+\n+class Solution {\n+    public String longestPalindrome(String s) {\n+        if (s == null || s.length() == 0) {\n+            return \"\";\n+        }\n+        int n = s.length();\n+        String maxStr = \"\";\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = i; j < n; ++j) {\n+                if (isValid(s, i, j) == true) {\n+                    if (j - i + 1 > maxStr.length()) { // update maxStr\n+                        maxStr = s.substring(i, j + 1);\n+                    }\n+                }\n+            }\n+        }\n+        return maxStr;\n+    }\n+\n+    private boolean isValid(String s, int lo, int hi) {\n+        int n = hi - lo + 1;\n+        for (int i = 0; i < n / 2; ++i) {\n+            if (s.charAt(lo + i) != s.charAt(hi - i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}",
    "output": "Add longest palindromic substring"
  },
  {
    "input": "diff --git a/DivideAndConquer/BinaryExponentiation.java b/DivideAndConquer/BinaryExponentiation.java\n--- a/DivideAndConquer/BinaryExponentiation.java\n+++ b/DivideAndConquer/BinaryExponentiation.java\n@@ -0,0 +1,16 @@\n+public class BinaryExponentiation {\n+\n+    public static void main(String args[]) {\n+        System.out.println(calculatePower(2, 30));\n+    }\n+\n+    // Function to calculate x^y\n+    // Time Complexity: O(logn)\n+    public static long calculatePower(long x, long y) {\n+        if (y == 0) return 1;\n+        long val = calculatePower(x, y / 2);\n+        val *= val;\n+        if (y % 2 == 1) val *= x;\n+        return val;\n+    }\n+}",
    "output": "Add Binary Exponentiation"
  },
  {
    "input": "diff --git a/Maths/Area.java b/Maths/Area.java\n--- a/Maths/Area.java\n+++ b/Maths/Area.java\n@@ -28,6 +28,9 @@ public static void main(String[] args) {\n \n     /* test circle */\n     assert Double.compare(surfaceAreaCircle(20), 1256.6370614359173) == 0;\n+    \n+    /* test cylinder */\n+    assert Double.compare(surfaceAreaCylinder(1,2), 18.84955592153876) == 0;\n   }\n \n   /**\n@@ -60,6 +63,16 @@ private static double surfaceAreaSphere(double radius) {\n   private static double surfaceAreaRectangle(double length, double width) {\n     return length * width;\n   }\n+  \n+  /**\n+   * Calculate surface of a cylinder\n+   *\n+   * @param radius radius of the floor\n+   * @param height height of the cylinder.\n+   */\n+  private static double surfaceAreaCylinder(double radius, double height) {\n+    return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n+  }\n \n   /**\n    * Calculate the area of a square",
    "output": "Add surfaceAreaCylinder (hacktoberfest)"
  },
  {
    "input": "diff --git a/Maths/PiNilakantha.java b/Maths/PiNilakantha.java\n--- a/Maths/PiNilakantha.java\n+++ b/Maths/PiNilakantha.java\n@@ -0,0 +1,46 @@\n+package Maths;\n+\n+public class PiNilakantha {\n+\n+    // Calculates Pi using Nilakantha's infinite series\n+    // Method 2 in the following link explains the algorithm\n+    //https://en.scratch-wiki.info/wiki/Calculating_Pi\n+\n+\n+    public static void main(String[] args) {\n+        assert calculatePi(0) == 3.0;\n+        assert calculatePi(10) > 3.0;\n+        assert calculatePi(100) < 4.0;\n+\n+        System.out.println(calculatePi(500));\n+    }\n+\n+\n+    /**\n+     *\n+     * @param iterations number of times the infinite series gets repeated\n+     *        Pi get more accurate the higher the value of iterations is\n+     *        Values from 0 up to 500 are allowed since double precision is not sufficient\n+     *        for more than about 500 repetitions of this algorithm\n+     * @return the pi value of the calculation with a precision of x iteration\n+     */\n+    public static double calculatePi(int iterations) {\n+        if (iterations < 0 || iterations > 500) {\n+            throw new IllegalArgumentException(\"Please input Integer Number between 0 and 500\");\n+        }\n+\n+        double pi = 3;\n+        int divCounter = 2;\n+\n+        for (int i = 0; i < iterations; i++) {\n+\n+            if (i % 2 == 0)\n+                pi = pi + 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2));\n+            else\n+                pi = pi - 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2));\n+\n+            divCounter += 2;\n+        }\n+        return pi;\n+    }\n+}",
    "output": "Add class that calculated Pi * added class PiNilakantha.java which calculates Pi using Nilakanthas infinite series * added link to explanation partially"
  },
  {
    "input": "diff --git a/DataStructures/Graphs/BellmanFord.java b/DataStructures/Graphs/BellmanFord.java\n--- a/DataStructures/Graphs/BellmanFord.java\n+++ b/DataStructures/Graphs/BellmanFord.java\n@@ -4,7 +4,7 @@\n \n class BellmanFord\n /*Implementation of Bellman ford to detect negative cycles. Graph accepts inputs in form of edges which have\n-start vertex, end vertes and weights. Vertices should be labelled with a number between 0 and total number of vertices-1,both inclusive*/\n+start vertex, end vertex and weights. Vertices should be labelled with a number between 0 and total number of vertices-1,both inclusive*/\n {\n   int vertex, edge;\n   private Edge edges[];",
    "output": "Fix typo vertes to vertex Fixes: #{$2189}"
  },
  {
    "input": "diff --git a/Sorts/SelectionSort.java b/Sorts/SelectionSort.java\n--- a/Sorts/SelectionSort.java\n+++ b/Sorts/SelectionSort.java\n@@ -32,7 +32,7 @@ public <T extends Comparable<T>> T[] sort(T[] arr) {\n       int min = i;\n \n       for (int j = i + 1; j < n; j++) {\n-        if (arr[min].compareTo(arr[j]) < 0) {\n+        if (arr[min].compareTo(arr[j]) > 0) {\n           min = j;\n         }\n       }",
    "output": "Fix the sort order"
  },
  {
    "input": "diff --git a/Sorts/ShellSort.java b/Sorts/ShellSort.java\n--- a/Sorts/ShellSort.java\n+++ b/Sorts/ShellSort.java\n@@ -5,9 +5,11 @@\n public class ShellSort implements SortAlgorithm {\n \n   /**\n-   * This method implements Generic Shell Sort.\n+   * Implements generic shell sort.\n    *\n-   * @param array the array to be sorted\n+   * @param array the array to be sorted.\n+   * @param <T> the type of elements in the array.\n+   * @return the sorted array.\n    */\n   @Override\n   public <T extends Comparable<T>> T[] sort(T[] array) {\n@@ -37,6 +39,10 @@ public static void main(String[] args) {\n     Integer[] toSort = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n \n     ShellSort sort = new ShellSort();\n-    print(sort.sort(toSort));\n+    sort.sort(toSort);\n+    for (int i = 0; i < toSort.length - 1; ++i) {\n+      assert toSort[i] <= toSort[i + 1];\n+    }\n+    print(toSort);\n   }\n }",
    "output": "Upgrade shell sort documentation"
  },
  {
    "input": "diff --git a/Maths/BinaryPow.java b/Maths/BinaryPow.java\n--- a/Maths/BinaryPow.java\n+++ b/Maths/BinaryPow.java\n@@ -0,0 +1,46 @@\n+package Maths;\n+\n+public class BinaryPow {\n+  /**\n+   * Calculate a^p using binary exponentiation\n+   * [Binary-Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html)\n+   *\n+   * @param a the base for exponentiation\n+   * @param p the exponent - must be greater than 0\n+   * @return a^p\n+   */\n+  public static int binPow(int a, int p) {\n+    int res = 1;\n+    while (p > 0) {\n+      if ((p & 1) == 1) {\n+        res = res * a;\n+      }\n+      a = a * a;\n+      p >>>= 1;\n+    }\n+    return res;\n+  }\n+\n+  /** \n+   * Function for testing binary exponentiation\n+   * @param a the base \n+   * @param p the exponent\n+   */\n+  public static void test(int a, int p) { \n+    int res = binPow(a, p);\n+    assert res == (int) Math.pow(a, p) : \"Incorrect Implementation\";\n+    System.out.println(a + \"^\" + p + \": \" + res);\n+  }\n+\n+  /** Main Function to call tests\n+   * \n+   * @param args System Line Arguments\n+   */\n+  public static void main(String[] args) {\n+    // prints 2^15: 32768\n+    test(2, 15); \n+\n+    // prints 3^9: 19683\n+    test(3,9);\n+  }\n+}",
    "output": "Add Binary Exponentiation * Added Binary Exponentiation * tests added in Binary Exponentation * Assertion Added"
  },
  {
    "input": "diff --git a/DynamicProgramming/MinimumSumPartition.java b/DynamicProgramming/MinimumSumPartition.java\n--- a/DynamicProgramming/MinimumSumPartition.java\n+++ b/DynamicProgramming/MinimumSumPartition.java\n@@ -81,13 +81,12 @@ public static int getMin(int[] arr, int sum) {\n         return min;\n     }\n \n-    public static void main(String args[]){\n-        Scanner in = new Scanner(System.in);\n-        int n = in.nextInt();\n-        int arr[] = new int[n];\n-        for(int i = 0 ; i<n; i++){\n-            arr[i] = in.nextInt();\n-        }\n-        System.out.println(subSet(arr));\n+    /**\n+     * Driver Code\n+     */\n+    public static void main(String[] args) {\n+        assert subSet(new int[]{1, 6, 11,5}) == 1;\n+        assert subSet(new int[]{36, 7, 46, 40}) == 23;\n+        assert subSet(new int[]{1, 2, 3, 9}) == 3;\n     }\n }",
    "output": "Upgrade DynamicProgramming/MinimumSumPartition.java"
  },
  {
    "input": "diff --git a/DynamicProgramming/MinimumSumPartition.java b/DynamicProgramming/MinimumSumPartition.java\n--- a/DynamicProgramming/MinimumSumPartition.java\n+++ b/DynamicProgramming/MinimumSumPartition.java\n@@ -32,16 +32,14 @@ public static int subSet(int[] arr) {\n         }\n \n         //fill dp array\n-        for(int i = 1; i <= n; i++){\n-            for(int j = 1; j <= sum; j++){\n-                if(arr[i-1] < j){\n-                    dp[i][j] = dp[i-1][j - arr[i-1]] || dp[i-1][j];\n-                }\n-                else if(arr[i-1] == j){\n+        for (int i = 1; i <= n; i++) {\n+            for (int j = 1; j <= sum; j++) {\n+                if (arr[i - 1] < j) {\n+                    dp[i][j] = dp[i - 1][j - arr[i - 1]] || dp[i - 1][j];\n+                } else if (arr[i - 1] == j) {\n                     dp[i][j] = true;\n-                }\n-                else{\n-                    dp[i][j] = dp[i-1][j];\n+                } else {\n+                    dp[i][j] = dp[i - 1][j];\n                 }\n             }\n         }",
    "output": "Upgrade DynamicProgramming/MinimumSumPartition.java"
  },
  {
    "input": "diff --git a/DynamicProgramming/MinimumSumPartition.java b/DynamicProgramming/MinimumSumPartition.java\n--- a/DynamicProgramming/MinimumSumPartition.java\n+++ b/DynamicProgramming/MinimumSumPartition.java\n@@ -47,7 +47,7 @@ else if(arr[i-1] == j){\n         }\n \n         // fill the index array\n-        int index[] = new int[sum];\n+        int[] index = new int[sum];\n         int p = 0;\n         for (int i = 0; i <= sum / 2; i++) {\n             if (dp[n][i]) {",
    "output": "Upgrade DynamicProgramming/MinimumSumPartition.java"
  },
  {
    "input": "diff --git a/DynamicProgramming/MinimumSumPartition.java b/DynamicProgramming/MinimumSumPartition.java\n--- a/DynamicProgramming/MinimumSumPartition.java\n+++ b/DynamicProgramming/MinimumSumPartition.java\n@@ -49,8 +49,8 @@ else if(arr[i-1] == j){\n         // fill the index array\n         int index[] = new int[sum];\n         int p = 0;\n-        for(int i = 0; i <= sum / 2; i++){\n-            if(dp[n][i]){\n+        for (int i = 0; i <= sum / 2; i++) {\n+            if (dp[n][i]) {\n                 index[p++] = i;\n             }\n         }",
    "output": "Upgrade DynamicProgramming/MinimumSumPartition.java"
  },
  {
    "input": "diff --git a/DynamicProgramming/MinimumSumPartition.java b/DynamicProgramming/MinimumSumPartition.java\n--- a/DynamicProgramming/MinimumSumPartition.java\n+++ b/DynamicProgramming/MinimumSumPartition.java\n@@ -27,7 +27,7 @@ public static int subSet(int[] arr) {\n         for (int i = 0; i <= n; i++) {\n             dp[i][0] = true;\n         }\n-        for(int j = 0; j < sum; j++){\n+        for (int j = 0; j <= sum; j++) {\n             dp[0][j] = false;\n         }\n ",
    "output": "Upgrade DynamicProgramming/MinimumSumPartition.java"
  },
  {
    "input": "diff --git a/DynamicProgramming/MinimumSumPartition.java b/DynamicProgramming/MinimumSumPartition.java\n--- a/DynamicProgramming/MinimumSumPartition.java\n+++ b/DynamicProgramming/MinimumSumPartition.java\n@@ -24,7 +24,7 @@ public static int subSet(int[] arr) {\n         int n = arr.length;\n         int sum = getSum(arr);\n         boolean[][] dp = new boolean[n + 1][sum + 1];\n-        for(int i = 0; i < n; i++){\n+        for (int i = 0; i <= n; i++) {\n             dp[i][0] = true;\n         }\n         for(int j = 0; j < sum; j++){",
    "output": "Upgrade DynamicProgramming/MinimumSumPartition.java"
  },
  {
    "input": "diff --git a/DynamicProgramming/MinimumSumPartition.java b/DynamicProgramming/MinimumSumPartition.java\n--- a/DynamicProgramming/MinimumSumPartition.java\n+++ b/DynamicProgramming/MinimumSumPartition.java\n@@ -58,13 +58,16 @@ else if(arr[i-1] == j){\n         return getMin(index, sum);\n     }\n \n-    public static int getSum(int arr[]){\n-        if(arr.length <= 0){\n-            return 0;\n-        }\n+    /**\n+     * Calculate sum of array elements\n+     *\n+     * @param arr the array\n+     * @return sum of given array\n+     */\n+    public static int getSum(int[] arr) {\n         int sum = 0;\n-        for(int i = 0; i < arr.length; i++){\n-            sum += arr[i];\n+        for (int temp : arr) {\n+            sum += temp;\n         }\n         return sum;\n     }",
    "output": "Upgrade DynamicProgramming/MinimumSumPartition.java"
  },
  {
    "input": "diff --git a/DynamicProgramming/MinimumSumPartition.java b/DynamicProgramming/MinimumSumPartition.java\n--- a/DynamicProgramming/MinimumSumPartition.java\n+++ b/DynamicProgramming/MinimumSumPartition.java\n@@ -23,7 +23,7 @@ public class MinimumSumPartition\n \tpublic static int subSet(int[] arr) {\n         int n = arr.length;\n         int sum = getSum(arr);\n-        boolean dp[][] = new boolean[n+1][sum+1];\n+        boolean[][] dp = new boolean[n + 1][sum + 1];\n         for(int i = 0; i < n; i++){\n             dp[i][0] = true;\n         }",
    "output": "Upgrade DynamicProgramming/MinimumSumPartition.java"
  },
  {
    "input": "diff --git a/DynamicProgramming/MinimumSumPartition.java b/DynamicProgramming/MinimumSumPartition.java\n--- a/DynamicProgramming/MinimumSumPartition.java\n+++ b/DynamicProgramming/MinimumSumPartition.java\n@@ -20,7 +20,7 @@\n import java.io.*;\n public class MinimumSumPartition\n {\n-\tpublic static int subSet(int arr[]){\n+\tpublic static int subSet(int[] arr) {\n         int n = arr.length;\n         int sum = getSum(arr);\n         boolean dp[][] = new boolean[n+1][sum+1];",
    "output": "Upgrade DynamicProgramming/MinimumSumPartition.java"
  },
  {
    "input": "diff --git a/DynamicProgramming/MinimumSumPartition.java b/DynamicProgramming/MinimumSumPartition.java\n--- a/DynamicProgramming/MinimumSumPartition.java\n+++ b/DynamicProgramming/MinimumSumPartition.java\n@@ -69,13 +69,13 @@ public static int getSum(int arr[]){\n         return sum;\n     }\n \n-    public static int getMin(int arr[], int sum){\n-        if(arr.length <= 0){\n+    public static int getMin(int[] arr, int sum) {\n+        if (arr.length == 0) {\n             return 0;\n         }\n         int min = Integer.MAX_VALUE;\n-        for(int i = 0; i < arr.length; i++){\n-            min = Math.min(min, (sum - 2*arr[i]));\n+        for (int temp : arr) {\n+            min = Math.min(min, sum - 2 * temp);\n         }\n         return min;\n     }",
    "output": "Upgrade DynamicProgramming/MinimumSumPartition.java"
  },
  {
    "input": "diff --git a/Conversions/AnyBaseToAnyBase.java b/Conversions/AnyBaseToAnyBase.java\n--- a/Conversions/AnyBaseToAnyBase.java\n+++ b/Conversions/AnyBaseToAnyBase.java\n@@ -115,7 +115,8 @@ public static String base2base(String n, int b1, int b2) {\n         // the remainder until the quotient is zero. The number in the\n         // new base is the remainders, with the last remainder\n         // being the left-most digit.\n-\n+        if (0 == decimalValue)\n+        \treturn \"0\";\n         // While the quotient is NOT zero:\n         while (decimalValue != 0) {\n             // If the remainder is a digit < 10, simply add it to",
    "output": "Upgrade AnyBaseToAnyBase.java fix n=\"0\" bug"
  },
  {
    "input": "diff --git a/Maths/Average.java b/Maths/Average.java\n--- a/Maths/Average.java\n+++ b/Maths/Average.java\n@@ -4,10 +4,13 @@\n  * Calculate average of a list  of numbers\n  */\n public class Average {\n+    private static final double SMALL_VALUE = 0.00001f;\n     public static void main(String[] args) {\n-        assert average(new double[]{3, 6, 9, 12, 15, 18, 21}) == 12;\n-        assert average(new double[]{5, 10, 15, 20, 25, 30, 35}) == 20;\n-        assert average(new double[]{1, 2, 3, 4, 5, 6, 7, 8}) == 4.5;\n+        assert Math.abs(average(new double[]{3, 6, 9, 12, 15, 18, 21}) - 12) < SMALL_VALUE;\n+        assert Math.abs(average(new double[]{5, 10, 15, 20, 25, 30, 35}) - 20) < SMALL_VALUE;\n+        assert Math.abs(average(new double[]{1, 2, 3, 4, 5, 6, 7, 8}) - 4.5) < SMALL_VALUE;\n+        int[] array = {2, 4, 10};\n+        assert average(array) == 5;\n     }\n \n     /**\n@@ -23,4 +26,19 @@ public static double average(double[] numbers) {\n         }\n         return sum / numbers.length;\n     }\n-}\n+    \n+    /**\n+     * find average value of int array\n+     *\n+     * @param array the array contains element and the sum does not \n+     * excess long value limit\n+     * @return average value\n+     */\n+    public static int average(int[] array) {\n+        long sum = 0;\n+        for (int i = 0 ; i < array.length; ++i) {\n+            sum += array[i];\n+        }\n+        return (int)(sum / array.length);\n+    }\n+}\n\\ No newline at end of file",
    "output": "Upgrade Average.java 1. add int type array 2. The equality of floating-point numbers should be judged by the absolute value of the difference less than a small number"
  },
  {
    "input": "diff --git a/Maths/AbsoluteMin.java b/Maths/AbsoluteMin.java\n--- a/Maths/AbsoluteMin.java\n+++ b/Maths/AbsoluteMin.java\n@@ -10,10 +10,10 @@\n  */\n public class AbsoluteMin {\n     public static void main(String[] args) {\n-    \tint[] testnums = new int[]{4, 0, 16};\n+    \tint[] testnums = {4, 0, 16};\n     \tassert absMin(testnums) == 0;\n     \t\n-        int[] numbers = new int[]{3, -10, -2};\n+        int[] numbers = {3, -10, -2};\n         System.out.println(\"absMin(\" + Arrays.toString(numbers) + \") = \" + absMin(numbers));\n     }\n ",
    "output": "Fix array initialization"
  },
  {
    "input": "diff --git a/Maths/AbsoluteMax.java b/Maths/AbsoluteMax.java\n--- a/Maths/AbsoluteMax.java\n+++ b/Maths/AbsoluteMax.java\n@@ -10,10 +10,10 @@\n  */\n public class AbsoluteMax {\n     public static void main(String[] args) {\n-    \tint[] testnums = new int[]{-2, 0, 16};\n+    \tint[] testnums = {-2, 0, 16};\n     \tassert absMax(testnums) == 16;\n     \t\n-        int[] numbers = new int[]{3, -10, -2};\n+        int[] numbers = {3, -10, -2};\n         System.out.println(\"absMax(\" + Arrays.toString(numbers) + \") = \" + absMax(numbers));\n     }\n ",
    "output": "Fix array initialization"
  },
  {
    "input": "diff --git a/Misc/HeapSort.java b/Misc/HeapSort.java\n--- a/Misc/HeapSort.java\n+++ b/Misc/HeapSort.java\n@@ -1,6 +1,6 @@\n package Misc;\n \n-public class heap_sort {\n+public class HeapSort {\n     public void sort(int[] arr) {\n         int n = arr.length;\n ",
    "output": "Upgrade and rename heap_sort.java to HeapSort.java"
  },
  {
    "input": "diff --git a/Conversions/RomanToInteger.java b/Conversions/RomanToInteger.java\n--- a/Conversions/RomanToInteger.java\n+++ b/Conversions/RomanToInteger.java\n@@ -29,6 +29,7 @@ public class RomanToInteger {\n      */\n     public static int romanToInt(String A) {\n \n+        A = A.toUpperCase();\n         char prev = ' ';\n \n         int sum = 0;",
    "output": "Upgrade RomanToInteger.java In case if lower case roman letters are supplied, we need to convert into single case(Upper case)"
  },
  {
    "input": "diff --git a/DataStructures/HashMap/Hashing/HashMap.java b/DataStructures/HashMap/Hashing/HashMap.java\n--- a/DataStructures/HashMap/Hashing/HashMap.java\n+++ b/DataStructures/HashMap/Hashing/HashMap.java\n@@ -1,6 +1,6 @@\n package DataStructures.HashMap.Hashing;\n \n-class HashMap {\n+public class HashMap {\n     private int hsize;\n     private LinkedList[] buckets;\n \n@@ -145,4 +145,4 @@ public void setNext(Node next) {\n     \t\tthis.next = next;\n     \t}\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Use public class HashMap"
  },
  {
    "input": "diff --git a/DataStructures/HashMap/Hashing/HashMapLinearProbing.java b/DataStructures/HashMap/Hashing/HashMapLinearProbing.java\n--- a/DataStructures/HashMap/Hashing/HashMapLinearProbing.java\n+++ b/DataStructures/HashMap/Hashing/HashMapLinearProbing.java\n@@ -4,7 +4,7 @@\n  * This class is an implementation of a hash table using linear probing\n  *\n  */\n-class HashMapLinearProbing {\n+public class HashMapLinearProbing {\n     private int hsize;\n     private Integer[] buckets;\n     private Integer AVAILABLE;\n@@ -160,4 +160,4 @@ public boolean isEmpty() {\n     \t}\n     \treturn response;\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Use public class HashMapLinearProbing"
  },
  {
    "input": "diff --git a/Maths/CountDigit.java b/Maths/CountDigit.java\n--- a/Maths/CountDigit.java\n+++ b/Maths/CountDigit.java\n@@ -1,20 +1,21 @@\n-import java.util.*;\n package Maths;\n+\n+import java.util.*;\n+\n // count the number of digits in a number\n-class CountDigit {\n-\tpublic static void main(String args[]) {\n-\t\tScanner sc = new Scanner(System.in);\n-\t\tSystem.out.print(\"Enter the number: \");\n-\t\tint number = sc.nextInt();\n-\t\tint digits = 0;\n-\t\tif(number == 0)\n-\t\t{\n-\t\t\tSystem.out.println(\"The number of digits present in the number: 1\");\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tdigits = (int)Math.floor(Math.log10(Math.abs(number)) + 1);\n-\t\t\tSystem.out.println(\"The number of digits present in the number: \" + digits);\n-\t\t}\n+public class CountDigit {\n+    public static void main(String args[]) {\n+\tScanner sc = new Scanner(System.in);\n+\tSystem.out.print(\"Enter the number: \");\n+\tint number = sc.nextInt();\n+\tint digits = 0;\n+\tif(number == 0){\n+\t    System.out.println(\"The number of digits present in the number: 1\");\n+\t}\n+\telse\n+\t{\n+\t    digits = (int)Math.floor(Math.log10(Math.abs(number)) + 1);\n+\t    System.out.println(\"The number of digits present in the number: \" + digits);\n \t}\n-}\n\\ No newline at end of file\n+    }\n+}",
    "output": "Use public class"
  },
  {
    "input": "diff --git a/Searches/PerfectBinarySearch.java b/Searches/PerfectBinarySearch.java\n--- a/Searches/PerfectBinarySearch.java\n+++ b/Searches/PerfectBinarySearch.java\n@@ -1,4 +1,6 @@\n- import java.util.*;\n+package Searches;\n+\n+import java.util.*;\n \n class PerfectBinarySearch{\n ",
    "output": "Upgrade PerfectBinarySearch.java Add package;"
  },
  {
    "input": "diff --git a/Searches/PerfectBinarySearch.java b/Searches/PerfectBinarySearch.java\n--- a/Searches/PerfectBinarySearch.java\n+++ b/Searches/PerfectBinarySearch.java\n@@ -0,0 +1,34 @@\n+ import java.util.*;\n+\n+class PerfectBinarySearch{\n+\n+    static int binarySearch(int[] arr, int target) \n+    {\n+        int low = 0 ;\n+        int high = arr.length - 1 ;\n+\n+        while(low <= high) {\n+            int mid =(low + high) / 2;\n+\n+            if(arr[mid] == target) {\n+                return mid;\n+            }\n+            else if(arr[mid] > target) {\n+                high = mid - 1;\n+            }\n+            else {\n+                low = mid + 1;\n+            }\n+\n+        }\n+        return -1;\n+    }\n+\n+    public static void main(String[] args)\n+    {\n+        PerfectBinarySearch BinarySearch = new PerfectBinarySearch();\n+        int[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n+        assert BinarySearch.binarySearch(array, -1) == -1;\n+        assert BinarySearch.binarySearch(array, 11) == -1;\n+    }\n+}",
    "output": "Upgrade and rename Perfect BinarySearch to PerfectBinarySearch.java"
  },
  {
    "input": "diff --git a/Maths/CountDigit.java b/Maths/CountDigit.java\n--- a/Maths/CountDigit.java\n+++ b/Maths/CountDigit.java\n@@ -1,5 +1,5 @@\n import java.util.*;\n-import java.lang.*;\n+package Maths;\n // count the number of digits in a number\n class CountDigit {\n \tpublic static void main(String args[]) {",
    "output": "Upgrade with Maths package"
  },
  {
    "input": "diff --git a/Maths/CountDigit.java b/Maths/CountDigit.java\n--- a/Maths/CountDigit.java\n+++ b/Maths/CountDigit.java\n@@ -1,8 +1,8 @@\n import java.util.*;\n import java.lang.*;\n // count the number of digits in a number\n-class CountDigit{\n-\tpublic static void main(String args[]){\n+class CountDigit {\n+\tpublic static void main(String args[]) {\n \t\tScanner sc = new Scanner(System.in);\n \t\tSystem.out.print(\"Enter the number: \");\n \t\tint number = sc.nextInt();",
    "output": "Upgrade with Maths package"
  },
  {
    "input": "diff --git a/Maths/CountDigit.java b/Maths/CountDigit.java\n--- a/Maths/CountDigit.java\n+++ b/Maths/CountDigit.java\n@@ -7,7 +7,14 @@ public static void main(String args[]){\n \t\tSystem.out.print(\"Enter the number: \");\n \t\tint number = sc.nextInt();\n \t\tint digits = 0;\n-\t\tdigits = (int)Math.floor(Math.log10(number) + 1);\n-\t\tSystem.out.println(\"The number of digits present in the number: \" + digits);\n+\t\tif(number == 0)\n+\t\t{\n+\t\t\tSystem.out.println(\"The number of digits present in the number: 1\");\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tdigits = (int)Math.floor(Math.log10(Math.abs(number)) + 1);\n+\t\t\tSystem.out.println(\"The number of digits present in the number: \" + digits);\n+\t\t}\n \t}\n }\n\\ No newline at end of file",
    "output": "Upgrade for zero and negative numbers"
  },
  {
    "input": "diff --git a/Maths/CountDigit.java b/Maths/CountDigit.java\n--- a/Maths/CountDigit.java\n+++ b/Maths/CountDigit.java\n@@ -0,0 +1,13 @@\n+import java.util.*;\n+import java.lang.*;\n+// count the number of digits in a number\n+class CountDigit{\n+\tpublic static void main(String args[]){\n+\t\tScanner sc = new Scanner(System.in);\n+\t\tSystem.out.print(\"Enter the number: \");\n+\t\tint number = sc.nextInt();\n+\t\tint digits = 0;\n+\t\tdigits = (int)Math.floor(Math.log10(number) + 1);\n+\t\tSystem.out.println(\"The number of digits present in the number: \" + digits);\n+\t}\n+}\n\\ No newline at end of file",
    "output": "Add Count Digit program"
  },
  {
    "input": "diff --git a/DataStructures/Lists/DoublyLinkedList.java b/DataStructures/Lists/DoublyLinkedList.java\n--- a/DataStructures/Lists/DoublyLinkedList.java\n+++ b/DataStructures/Lists/DoublyLinkedList.java\n@@ -166,6 +166,22 @@ else if (current == null)\n             current.previous = newLink; // 1 <--> newLink <--> 2(current) <--> 3\n         }\n     }\n+\n+    /**\n+     * Deletes the passed node from the current list\n+     *\n+     * @param z Element to be deleted\n+     */\n+    public void deleteNode(Link z) {\n+        if(z.next == null){\n+            deleteTail();\n+        } else if(z == head){\n+            deleteHead();\n+        } else{ //before <-- 1 <--> 2(z) <--> 3 -->\n+            z.previous.next = z.next // 1 --> 3\n+            z.next.previous = z.previous // 1 <--> 3\n+        }\n+    }\n     \n     public static void removeDuplicates(DoublyLinkedList l ) {\n     \tLink linkOne = l.head ;",
    "output": "Add deleteNode method"
  },
  {
    "input": "diff --git a/Sorts/SelectionSort.java b/Sorts/SelectionSort.java\n--- a/Sorts/SelectionSort.java\n+++ b/Sorts/SelectionSort.java\n@@ -10,10 +10,12 @@ public class SelectionSort implements SortAlgorithm {\n \n     /**\n      * This method swaps the two elements in the array\n+     * @param <T>\n      * @param arr, i, j The array for the swap and \n                         the indexes of the to-swap elements\n      */\n-    public void swap(T[] arr, int i, int j) {\n+    \n+    public <T> void swap(T[] arr, int i, int j) {\n        T temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;",
    "output": "Fix <T> parameter error in SelectionSort"
  },
  {
    "input": "diff --git a/Maths/ParseInteger.java b/Maths/ParseInteger.java\n--- a/Maths/ParseInteger.java\n+++ b/Maths/ParseInteger.java\n@@ -16,7 +16,7 @@ public static void main(String[] args) {\n      * @throws NumberFormatException if the {@code string} does not contain a parsable integer.\n      */\n     public static int parseInt(String s) {\n-        if (s == null) {\n+        if (s == null || s.length() == 0) {\n             throw new NumberFormatException(\"null\");\n         }\n         boolean isNegative = s.charAt(0) == '-';",
    "output": "Upgrade ParseInteger.java Fixed error for empty string"
  },
  {
    "input": "diff --git a/Sorts/SelectionSort.java b/Sorts/SelectionSort.java\n--- a/Sorts/SelectionSort.java\n+++ b/Sorts/SelectionSort.java\n@@ -8,6 +8,17 @@\n \n public class SelectionSort implements SortAlgorithm {\n \n+    /**\n+     * This method swaps the two elements in the array\n+     * @param arr, i, j The array for the swap and \n+                        the indexes of the to-swap elements\n+     */\n+    public void swap(T[] arr, int i, int j) {\n+       T temp = arr[i];\n+       arr[i] = arr[j];\n+       arr[j] = temp;\n+    }\n+    \n     /**\n      * This method implements the Generic Selection Sort\n      *\n@@ -22,14 +33,14 @@ public <T extends Comparable<T>> T[] sort(T[] arr) {\n             int min = i;\n \n             for (int j = i + 1; j < n; j++) {\n-                if (SortUtils.less(arr[j], arr[min])) {\n+                if (arr[min].compareTo(arr[j]) < 0) {\n                     min = j;\n                 }\n             }\n \n             // Swapping if index of min is changed\n             if (min != i) {\n-                SortUtils.swap(arr, i, min);\n+                swap(arr, i, min);\n             }\n         }\n ",
    "output": "Upgrade SelectionSort.java -Used compareTo -Used a local swap method"
  },
  {
    "input": "diff --git a/Maths/PrimeFactorization.java b/Maths/PrimeFactorization.java\n--- a/Maths/PrimeFactorization.java\n+++ b/Maths/PrimeFactorization.java\n@@ -3,7 +3,7 @@\n import java.lang.Math;\n import java.util.Scanner;\n \n-public class algorithm {\n+public class PrimeFactorization {\n     public static void main(String[] args){\n         System.out.println(\"## all prime factors ##\");\n         Scanner scanner = new Scanner(System.in);",
    "output": "Fix Error:(6, 8) java: class algorithm is public, should be declared in a file named algorithm.java. Inside file PrimeFactorization, the name of public class was wrong"
  },
  {
    "input": "diff --git a/Maths/Factorial.java b/Maths/Factorial.java\n--- a/Maths/Factorial.java\n+++ b/Maths/Factorial.java\n@@ -3,11 +3,11 @@\n \n public class Factorial {\n     public static void main(String[] args) { //main method\n-        int n = 1;\n-Scanner sc= new Scanner(System.in);\n-System.out.println(\"Enter Number\");\n-n=sc.nextInt();\n-        System.out.println(n + \"! = \" + factorial(n));\n+           int n = 1;\n+           Scanner sc= new Scanner(System.in);\n+           System.out.println(\"Enter Number\");\n+           n=sc.nextInt();\n+           System.out.println(n + \"! = \" + factorial(n));\n     }\n \n     //Factorial = n! = n1 * (n-1) * (n-2)*...1",
    "output": "Add indentation in the \"main\" function statement block"
  },
  {
    "input": "diff --git a/Maths/Factorial.java b/Maths/Factorial.java\n--- a/Maths/Factorial.java\n+++ b/Maths/Factorial.java\n@@ -2,7 +2,7 @@\n import java.util.*; //for importing scanner\n \n public class Factorial {\n-    public static void main(String[] args) {\n+    public static void main(String[] args) { //main method\n         int n = 1;\n Scanner sc= new Scanner(System.in);\n System.out.println(\"Enter Number\");",
    "output": "Add comment in front of main method"
  },
  {
    "input": "diff --git a/Maths/Factorial.java b/Maths/Factorial.java\n--- a/Maths/Factorial.java\n+++ b/Maths/Factorial.java\n@@ -1,9 +1,12 @@\n package Maths;\n+import java.util.*; //for importing scanner\n \n-//change around 'n' for different factorial results\n public class Factorial {\n     public static void main(String[] args) {\n-        int n = 5;\n+        int n = 1;\n+Scanner sc= new Scanner(System.in);\n+System.out.println(\"Enter Number\");\n+n=sc.nextInt();\n         System.out.println(n + \"! = \" + factorial(n));\n     }\n ",
    "output": "Add scanner in factorail program"
  },
  {
    "input": "diff --git a/DataStructures/Lists/DoublyLinkedList.java b/DataStructures/Lists/DoublyLinkedList.java\n--- a/DataStructures/Lists/DoublyLinkedList.java\n+++ b/DataStructures/Lists/DoublyLinkedList.java\n@@ -160,6 +160,19 @@ else if (current == null)\n             current.previous = newLink; // 1 <--> newLink <--> 2(current) <--> 3\n         }\n     }\n+    \n+    public static void removeDuplicates(DoublyLinkedList l ) {\n+    \tLink linkOne = l.head ;\n+    \twhile(linkOne.next != null) { // list is present  \n+    \t\tLink linkTwo = linkOne.next; // second link for comparison\n+    \t\twhile(linkTwo.next!= null) {\n+    \t\t\tif(linkOne.value == linkTwo.value) // if there are duplicates values then \n+    \t\t\t\tl.delete(linkTwo.value);  // delete the link\n+    \t\t\tlinkTwo = linkTwo.next ; // go to next link \n+    \t\t}\n+    \t\tlinkOne = linkOne.next; // go to link link to iterate the whole list again\n+    \t}\n+    }\n \n     /**\n      * Returns true if list is empty",
    "output": "Add removeDuplicates function"
  },
  {
    "input": "diff --git a/Sorts/MergeSort.java b/Sorts/MergeSort.java\n--- a/Sorts/MergeSort.java\n+++ b/Sorts/MergeSort.java\n@@ -20,7 +20,7 @@ class MergeSort implements SortAlgorithm {\n      * @return sorted array\n      */\n     @Override\n-    @SuppressWarnings(\"unchecked\")\n+    \n     public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n         doSort(unsorted, 0, unsorted.length - 1);\n         return unsorted;",
    "output": "Remove unnecessary SuppressWarning"
  },
  {
    "input": "diff --git a/Misc/heap_sort.java b/Misc/heap_sort.java\n--- a/Misc/heap_sort.java\n+++ b/Misc/heap_sort.java\n@@ -57,8 +57,7 @@ static void printArray(int[] arr) {\n     // Driver program\n     public static void main(String args[]) {\n         int arr[] = {12, 11, 13, 5, 6, 7};\n-        int n = arr.length;\n-\n+        \n         heap_sort ob = new heap_sort();\n         ob.sort(arr);\n ",
    "output": "Remove unused variable"
  },
  {
    "input": "diff --git a/DataStructures/Lists/CursorLinkedList.java b/DataStructures/Lists/CursorLinkedList.java\n--- a/DataStructures/Lists/CursorLinkedList.java\n+++ b/DataStructures/Lists/CursorLinkedList.java\n@@ -4,6 +4,7 @@\n \n public class CursorLinkedList<T> {\n \n+    \n     private static class Node<T> {\n \n         T element;\n@@ -13,20 +14,16 @@ private static class Node<T> {\n             this.element = element;\n             this.next = next;\n         }\n-\n-        boolean isEmpty() {\n-            return element == null;\n-        }\n     }\n \n-\n     private final int os;\n     private int head;\n     private final Node<T>[] cursorSpace;\n     private int count;\n     private final static int CURSOR_SPACE_SIZE = 100;\n \n \n+    \n     {\n         // init at loading time\n         cursorSpace = new Node[CURSOR_SPACE_SIZE];",
    "output": "Remove unused method"
  },
  {
    "input": "diff --git a/DataStructures/HashMap/Hashing/LinkedList.java b/DataStructures/HashMap/Hashing/LinkedList.java\n--- a/DataStructures/HashMap/Hashing/LinkedList.java\n+++ b/DataStructures/HashMap/Hashing/LinkedList.java\n@@ -12,7 +12,6 @@ public LinkedList() {\n \n \tpublic void insert(int data) {\n \n-\t\tNode temp = Head;\n \t\tNode newnode = new Node(data);\n \t\n \t\tsize++;",
    "output": "Remove unused variable"
  },
  {
    "input": "diff --git a/DataStructures/Buffers/CircularBuffer.java b/DataStructures/Buffers/CircularBuffer.java\n--- a/DataStructures/Buffers/CircularBuffer.java\n+++ b/DataStructures/Buffers/CircularBuffer.java\n@@ -26,12 +26,15 @@ private int getTrueIndex(int i) {\n         return i % _buffer_size;\n     }\n \n+    \n     public Character readOutChar() {\n         Character result = null;\n \n+        \n         //if we have data to read\n         if (_readable_data.get() > 0) {\n-            result = new Character(_buffer[getTrueIndex(_read_index)]);\n+            \n+            result = Character.valueOf(_buffer[getTrueIndex(_read_index)]);\n             _readable_data.decrementAndGet();\n             _read_index++;\n         }",
    "output": "Remove deprecated use of Character"
  },
  {
    "input": "diff --git a/DataStructures/Graphs/ConnectedComponent.java b/DataStructures/Graphs/ConnectedComponent.java\n--- a/DataStructures/Graphs/ConnectedComponent.java\n+++ b/DataStructures/Graphs/ConnectedComponent.java\n@@ -108,7 +108,7 @@ public ArrayList<Node> depthFirstSearch(Node n, ArrayList<Node> visited) {\n public class ConnectedComponent {\r\n \r\n     public static void main(String[] args) {\r\n-        Graph graphChars = new Graph();\r\n+        Graph<Character> graphChars = new Graph<>();\r\n \r\n         // Graph 1\r\n         graphChars.addEdge('a', 'b');\r\n@@ -123,7 +123,7 @@ public static void main(String[] args) {\n \r\n         graphChars.addEdge('w', 'w');\r\n \r\n-        Graph graphInts = new Graph();\r\n+        Graph<Integer> graphInts = new Graph<>();\r\n \r\n         // Graph 2\r\n         graphInts.addEdge(1, 2);\r",
    "output": "Add type parameter"
  },
  {
    "input": "diff --git a/Conversions/RomanToInteger.java b/Conversions/RomanToInteger.java\n--- a/Conversions/RomanToInteger.java\n+++ b/Conversions/RomanToInteger.java\n@@ -4,7 +4,13 @@\n \n public class RomanToInteger {\n \n-    private static Map<Character, Integer> map = new HashMap<Character, Integer>() {{\n+    private static Map<Character, Integer> map = new HashMap<Character, Integer>() {\n+        /**\n+        *\n+        */\n+        private static final long serialVersionUID = 87605733047260530L;\n+\n+        {\n         put('I', 1);\n         put('V', 5);\n         put('X', 10);",
    "output": "Upgrade RomanToInteger.java declaring serialVersionUID"
  },
  {
    "input": "diff --git a/DataStructures/Trees/RedBlackBST.java b/DataStructures/Trees/RedBlackBST.java\n--- a/DataStructures/Trees/RedBlackBST.java\n+++ b/DataStructures/Trees/RedBlackBST.java\n@@ -330,5 +330,6 @@ public void deleteDemo() {\n         printTree(root);\r\n         System.out.println(\"Pre order\");\r\n         printTreepre(root);\r\n+        scan.close();\r\n     }\r\n }\n\\ No newline at end of file",
    "output": "Upgrade RedBlackBST.java closing Scanner scan"
  },
  {
    "input": "diff --git a/DataStructures/HashMap/Hashing/Main.java b/DataStructures/HashMap/Hashing/Main.java\n--- a/DataStructures/HashMap/Hashing/Main.java\n+++ b/DataStructures/HashMap/Hashing/Main.java\n@@ -8,16 +8,15 @@ public static void main(String[] args) {\n \t\tint choice, key;\n \n \t\tHashMap h = new HashMap(7);\n+\t\tScanner In = new Scanner(System.in);\n \n \t\twhile (true) {\n \t\t\tSystem.out.println(\"Enter your Choice :\");\n \t\t\tSystem.out.println(\"1. Add Key\");\n \t\t\tSystem.out.println(\"2. Delete Key\");\n \t\t\tSystem.out.println(\"3. Print Table\");\n \t\t\tSystem.out.println(\"4. Exit\");\n-\n-\t\t\tScanner In = new Scanner(System.in);\n-\n+\t\t\t\n \t\t\tchoice = In.nextInt();\n \n \t\t\tswitch (choice) {\n@@ -39,10 +38,11 @@ public static void main(String[] args) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcase 4: {\n+\t\t\t\t\tIn.close();\n \t\t\t\t\treturn;\n \t\t\t\t}\t\n \t\t\t}\n-\t\t\tIn.close();\n+\t\t\t\n \t\t}\n \t}\n }\n\\ No newline at end of file",
    "output": "Upgrade Main.java fixing bug Program is causing a NoSuchElementException"
  },
  {
    "input": "diff --git a/DataStructures/Graphs/Cycles.java b/DataStructures/Graphs/Cycles.java\n--- a/DataStructures/Graphs/Cycles.java\n+++ b/DataStructures/Graphs/Cycles.java\n@@ -10,7 +10,7 @@ class Cycle {\n     private int[][] adjacencyMatrix;\n     private boolean[] visited;\n     ArrayList<ArrayList<Integer>> cycles = new ArrayList<ArrayList<Integer>>();\n-    private boolean[] finalCycles;\n+    \n \n     public Cycle() {\n         Scanner in = new Scanner(System.in);",
    "output": "Upgrade Cycles.java removing unused member variable finalCycles"
  },
  {
    "input": "diff --git a/DataStructures/Graphs/PrimMST.java b/DataStructures/Graphs/PrimMST.java\n--- a/DataStructures/Graphs/PrimMST.java\n+++ b/DataStructures/Graphs/PrimMST.java\n@@ -1,7 +1,5 @@\n package DataStructures.Graphs;\n \n-import java.lang.*;\n-\n /**\n  * A Java program for Prim's Minimum Spanning Tree (MST) algorithm.\n  * adjacency matrix representation of the graph",
    "output": "Upgrade PrimMST.java removing unused import java.lang.*"
  },
  {
    "input": "diff --git a/DataStructures/Graphs/Cycles.java b/DataStructures/Graphs/Cycles.java\n--- a/DataStructures/Graphs/Cycles.java\n+++ b/DataStructures/Graphs/Cycles.java\n@@ -34,6 +34,7 @@ public Cycle() {\n             end = in.nextInt();\n             adjacencyMatrix[start][end] = 1;\n         }\n+        in.close();\n \n     }\n ",
    "output": "Upgrade Cycles.java closing Scanner in"
  },
  {
    "input": "diff --git a/Conversions/DecimalToBinary.java b/Conversions/DecimalToBinary.java\n--- a/Conversions/DecimalToBinary.java\n+++ b/Conversions/DecimalToBinary.java\n@@ -35,6 +35,7 @@ public static void conventionalConversion() {\n             n /= 2;\n         } //converting decimal to binary\n         System.out.println(\"\\tBinary number: \" + b);\n+        input.close();\n     }\n \n     /**",
    "output": "Upgrade DecimalToBinary.java Close ressource leak Scanner input"
  },
  {
    "input": "diff --git a/Sorts/BubbleSort.java b/Sorts/BubbleSort.java\n--- a/Sorts/BubbleSort.java\n+++ b/Sorts/BubbleSort.java\n@@ -21,7 +21,10 @@ public <T extends Comparable<T>> T[] sort(T array[]) {\n         for (int i = 0, size = array.length; i < size - 1; ++i) {\n             boolean swapped = false;\n             for (int j = 0; j < size - 1 - i; ++j) {\n-                swapped = less(array[j], array[j + 1]) && swap(array, j, j + 1);\n+            \tif (less(array[j], array[j + 1])) {\n+            \t\tswap(array, j, j + 1);\n+            \t\tswapped = true;\n+                }\n             }\n             if (!swapped) {\n                 break;",
    "output": "Upgrade BubbleSort.java Output from print(integers) returns [78, 231, 54, 23, 12, 9, 6, 4, 1] Correct output should be: [231, 78, 54, 23, 12, 9, 6, 4, 1]"
  },
  {
    "input": "diff --git a/Maths/FindMin.java b/Maths/FindMin.java\n--- a/Maths/FindMin.java\n+++ b/Maths/FindMin.java\n@@ -5,7 +5,7 @@ public class FindMin {\n     //Driver\n     public static void main(String[] args) {\n         int[] array = {2, 4, 9, 7, 19, 94, 5};\n-        System.out.println(\"min = \" + findMax(array));\n+        System.out.println(\"min = \" + findMin(array));\n     }\n \n     /**\n@@ -14,7 +14,7 @@ public static void main(String[] args) {\n      * @param array the array contains element\n      * @return min value\n      */\n-    public static int findMax(int[] array) {\n+    public static int findMin(int[] array) {\n         int min = array[0];\n         for (int i = 1; i < array.length; ++i) {\n             if (array[i] < min) {",
    "output": "Upgrade FindMin and"
  },
  {
    "input": "diff --git a/Searches/JumpSearch.java b/Searches/JumpSearch.java\n--- a/Searches/JumpSearch.java\n+++ b/Searches/JumpSearch.java\n@@ -0,0 +1,39 @@\n+package Searches;\n+\n+public class JumpSearch implements SearchAlgorithm {\n+\n+    public static void main(String[] args) {\n+        JumpSearch jumpSearch = new JumpSearch();\n+        Integer[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n+        for (int i = 0; i < array.length; i++) {\n+            assert jumpSearch.find(array, i) == i;\n+        }\n+        assert jumpSearch.find(array, -1) == -1;\n+        assert jumpSearch.find(array, 11) == -1;\n+    }\n+\n+    /**\n+     * Jump Search algorithm implements\n+     *\n+     * @param array the array contains elements\n+     * @param key   to be searched\n+     * @return index of {@code key} if found, otherwise <tt>-1</tt>\n+     */\n+    @Override\n+    public <T extends Comparable<T>> int find(T[] array, T key) {\n+        int length = array.length; /* length of array */\n+        int blockSize = (int) Math.sqrt(length); /* block size to be jumped */\n+\n+        int limit = blockSize;\n+        while (key.compareTo(array[limit]) > 0 && limit < array.length - 1) {\n+            limit = Math.min(limit + blockSize, array.length - 1);\n+        }\n+\n+        for (int i = limit - blockSize; i <= limit; i++) {\n+            if (array[i] == key) { /* execute linear search */\n+                return i;\n+            }\n+        }\n+        return -1; /* not found */\n+    }\n+}",
    "output": "Add jump search algorithm"
  },
  {
    "input": "diff --git a/DataStructures/Stacks/BalancedBrackets.java b/DataStructures/Stacks/BalancedBrackets.java\n--- a/DataStructures/Stacks/BalancedBrackets.java\n+++ b/DataStructures/Stacks/BalancedBrackets.java\n@@ -62,7 +62,7 @@ public static boolean isBalanced(String brackets) {\n                 case ')':\n                 case ']':\n                 case '}':\n-                    if (!(!bracketsStack.isEmpty() && isPaired(bracketsStack.pop(), bracket))) {\n+                    if (bracketsStack.isEmpty() || !isPaired(bracketsStack.pop(), bracket)) {\n                         return false;\n                     }\n                     break;",
    "output": "Make code readable"
  },
  {
    "input": "diff --git a/Others/CountWords.java b/Others/CountWords.java\n--- a/Others/CountWords.java\n+++ b/Others/CountWords.java\n@@ -44,7 +44,5 @@ private static int secondaryWordCount(String s) {\n         }\n         s = sb.toString();\n         return s.trim().split(\"[\\\\s]+\").length;\n-\n     }\n-\n }",
    "output": "Upgrade CountWords.java Cleaning the code"
  },
  {
    "input": "diff --git a/Maths/PrimeCheck.java b/Maths/PrimeCheck.java\n--- a/Maths/PrimeCheck.java\n+++ b/Maths/PrimeCheck.java\n@@ -6,17 +6,17 @@ public class PrimeCheck {\n     public static void main(String[] args) {\n         Scanner scanner = new Scanner(System.in);\n \n-        System.out.println(\"Enter n:\");\n+        System.out.print(\"Enter a number: \");\n         int n = scanner.nextInt();\n         if (isPrime(n)) {\n-            System.out.println(n + \"is prime number\");\n+            System.out.println(n + \" is a prime number\");\n         } else {\n-            System.out.println(n + \"is not prime number\");\n+            System.out.println(n + \" is not a prime number\");\n         }\n     }\n \n     /***\n-     * Check a number is prime or not\n+     * Checks if a number is prime or not\n      * @param n the number\n      * @return {@code true} if {@code n} is prime\n      */",
    "output": "Improve grammar and whitespace for prompts"
  },
  {
    "input": "diff --git a/DataStructures/Queues/PriorityQueues.java b/DataStructures/Queues/PriorityQueues.java\n--- a/DataStructures/Queues/PriorityQueues.java\n+++ b/DataStructures/Queues/PriorityQueues.java\n@@ -42,18 +42,15 @@ public PriorityQueue(int size) {\n     public void insert(int value) {\n         if (isFull()) {\n             throw new RuntimeException(\"Queue is full\");\n-        }\n-        if (nItems == 0) {\n-            queueArray[0] = value;\n         } else {\n-            int j = nItems;\n-            while (j > 0 && queueArray[j - 1] > value) {\n-                queueArray[j] = queueArray[j - 1]; // Shifts every element up to make room for insertion\n+            int j = nItems - 1; // index of last element\n+            while (j >= 0 && queueArray[j] > value) {\n+                queueArray[j + 1] = queueArray[j]; // Shifts every element up to make room for insertion\n                 j--;\n             }\n-            queueArray[j] = value; // Once the correct position is found the value is inserted\n-        }\n-        nItems++;\n+            queueArray[j + 1] = value; // Once the correct position is found the value is inserted\n+            nItems++;\n+        } \n     }\n \n     /**",
    "output": "Make code less"
  },
  {
    "input": "diff --git a/Sorts/BubbleSort.java b/Sorts/BubbleSort.java\n--- a/Sorts/BubbleSort.java\n+++ b/Sorts/BubbleSort.java\n@@ -18,18 +18,15 @@ class BubbleSort implements SortAlgorithm {\n \n     @Override\n     public <T extends Comparable<T>> T[] sort(T array[]) {\n-        int last = array.length;\n-        //Sorting\n-        boolean swap;\n-        do {\n-            swap = false;\n-            for (int count = 0; count < last - 1; count++) {\n-                if (less(array[count], array[count + 1])) {\n-                    swap = swap(array, count, count + 1);\n-                }\n+        for (int i = 0, size = array.length; i < size - 1; ++i) {\n+            boolean swapped = false;\n+            for (int j = 0; j < size - 1 - i; ++j) {\n+                swapped = less(array[j], array[j + 1]) && swap(array, j, j + 1);\n             }\n-            last--;\n-        } while (swap);\n+            if (!swapped) {\n+                break;\n+            }\n+        }\n         return array;\n     }\n ",
    "output": "Make code more readable"
  },
  {
    "input": "diff --git a/DynamicProgramming/Knapsack.java b/DynamicProgramming/Knapsack.java\n--- a/DynamicProgramming/Knapsack.java\n+++ b/DynamicProgramming/Knapsack.java\n@@ -6,7 +6,9 @@\n \n public class Knapsack {\n \n-    private static int knapSack(int W, int wt[], int val[], int n) {\n+    private static int knapSack(int W, int wt[], int val[], int n) throws IllegalArgumentException {\n+        if(wt == null || val == null)\n+            throw new IllegalArgumentException();\n         int i, w;\n         int rv[][] = new int[n + 1][W + 1];    //rv means return value\n ",
    "output": "Upgrade Knapsack.java Added check if the arrays are null"
  },
  {
    "input": "diff --git a/DataStructures/Lists/SinglyLinkedList.java b/DataStructures/Lists/SinglyLinkedList.java\n--- a/DataStructures/Lists/SinglyLinkedList.java\n+++ b/DataStructures/Lists/SinglyLinkedList.java\n@@ -61,7 +61,9 @@ public void deleteHead() {\n             throw new RuntimeException(\"The list is empty!\");\n         }\n \n+        Node destroy = head;\n         head = head.next;\n+        destroy = null;  // clear to let GC do its work\n     }\n \n     /**",
    "output": "Fix memory leak"
  },
  {
    "input": "diff --git a/DataStructures/Stacks/StackArray.java b/DataStructures/Stacks/StackArray.java\n--- a/DataStructures/Stacks/StackArray.java\n+++ b/DataStructures/Stacks/StackArray.java\n@@ -109,14 +109,13 @@ public int peek() {\n     }\n \n     private void resize(int newSize) {\n-        // private int[] transferArray = new int[newSize]; we can't put modifiers here !\n         int[] transferArray = new int[newSize];\n \n-        // for(int i = 0; i < stackArray.length(); i++){ the length isn't a method .\n         for (int i = 0; i < stackArray.length; i++) {\n             transferArray[i] = stackArray[i];\n-            stackArray = transferArray;\n         }\n+        // This reference change might be nice in here\n+        stackArray = transferArray;\n         maxSize = newSize;\n     }\n ",
    "output": "Fix StackArray.java resize()"
  },
  {
    "input": "diff --git a/Maths/AbsoluteValue.java b/Maths/AbsoluteValue.java\n--- a/Maths/AbsoluteValue.java\n+++ b/Maths/AbsoluteValue.java\n@@ -0,0 +1,27 @@\n+package Maths;\n+\n+/**\n+ * @author PatOnTheBack\n+ */\n+\n+ public class AbsoluteValue {\n+\n+    public static void main(String[] args) {\n+\n+        int value = -34;\n+\n+        System.out.println(\"The absolute value of \" + value + \" is \" + abs_val(value));\n+\n+    }\n+\n+    public static int abs_val(int value) {\n+      // If value is less than zero, make value positive.\n+      if (value < 0) {\n+        return -value;\n+      }\n+\n+      return value;\n+\n+    }\n+\n+ }",
    "output": "Add Maths Folder & Absolute Value Program"
  },
  {
    "input": "diff --git a/Conversions/BinaryToOctal.java b/Conversions/BinaryToOctal.java\n--- a/Conversions/BinaryToOctal.java\n+++ b/Conversions/BinaryToOctal.java\n@@ -16,6 +16,7 @@ public class BinaryToOctal {\n      */\n     public static void main(String args[]) {\n         Scanner sc = new Scanner(System.in);\n+        System.out.println(\"Input the binary number: \");\n         int b = sc.nextInt();\n         System.out.println(\"Octal equivalent: \" + convertBinaryToOctal(b));\n         sc.close();\n@@ -26,18 +27,24 @@ public static void main(String args[]) {\n      * This method converts a binary number to\n      * an octal number.\n      *\n-     * @param b The binary number\n+     * @param binary The binary number\n      * @return The octal number\n      */\n-    public static int convertBinaryToOctal(int b) {\n-        int o = 0, r = 0, j = 1;\n-        while (b != 0) {\n-            r = b % 10;\n-            o = o + r * j;\n-            j = j * 2;\n-            b = b / 10;\n+    public static String convertBinaryToOctal(int binary) {\n+        String octal = \"\";\n+        int currBit = 0, j = 1;\n+        while (binary != 0) {\n+            int code3 = 0;\n+            for (int i = 0; i < 3; i++) {\n+                currBit = binary % 10;\n+                binary = binary / 10;\n+                code3 += currBit * j;\n+                j *= 2;\n+            }\n+            octal = code3 + octal;\n+            j = 1;\n         }\n-        return o;\n+        return octal;\n     }\n \n }",
    "output": "Fix binary to octal conversion"
  },
  {
    "input": "diff --git a/Conversions/BinaryToDecimal.java b/Conversions/BinaryToDecimal.java\n--- a/Conversions/BinaryToDecimal.java\n+++ b/Conversions/BinaryToDecimal.java\n@@ -15,14 +15,14 @@ class BinaryToDecimal {\n      */\n     public static void main(String args[]) {\n         Scanner sc = new Scanner(System.in);\n-        int bin_num, bin_copy, d, s = 0, power = 0;\n+        int binNum, binCopy, d, s = 0, power = 0;\n         System.out.print(\"Binary number: \");\n-        bin_num = sc.nextInt();\n-        bin_copy = bin_num;\n-        while (bin_copy != 0) {\n-            d = bin_copy % 10;\n+        binNum = sc.nextInt();\n+        binCopy = binNum;\n+        while (binCopy != 0) {\n+            d = binCopy % 10;\n             s += d * (int) Math.pow(2, power++);\n-            bin_copy /= 10;\n+            binCopy /= 10;\n         }\n         System.out.println(\"Decimal equivalent:\" + s);\n         sc.close();",
    "output": "Upgrade BinaryToDecimal.java Changed bin_num and bin_copy to binNum and binCopy respectively"
  },
  {
    "input": "diff --git a/Conversions/BinaryToDecimal.java b/Conversions/BinaryToDecimal.java\n--- a/Conversions/BinaryToDecimal.java\n+++ b/Conversions/BinaryToDecimal.java\n@@ -15,14 +15,14 @@ class BinaryToDecimal {\n      */\n     public static void main(String args[]) {\n         Scanner sc = new Scanner(System.in);\n-        int n, k, d, s = 0, c = 0;\n+        int bin_num, bin_copy, d, s = 0, power = 0;\n         System.out.print(\"Binary number: \");\n-        n = sc.nextInt();\n-        k = n;\n-        while (k != 0) {\n-            d = k % 10;\n-            s += d * (int) Math.pow(2, c++);\n-            k /= 10;\n+        bin_num = sc.nextInt();\n+        bin_copy = bin_num;\n+        while (bin_copy != 0) {\n+            d = bin_copy % 10;\n+            s += d * (int) Math.pow(2, power++);\n+            bin_copy /= 10;\n         }\n         System.out.println(\"Decimal equivalent:\" + s);\n         sc.close();",
    "output": "Upgrade BinaryToDecimal.java Updated some of the variable names for the ease of understanding the process"
  },
  {
    "input": "diff --git a/DataStructures/Lists/DoublyLinkedList.java b/DataStructures/Lists/DoublyLinkedList.java\n--- a/DataStructures/Lists/DoublyLinkedList.java\n+++ b/DataStructures/Lists/DoublyLinkedList.java\n@@ -116,8 +116,13 @@ public Link deleteTail() {\n     public void delete(int x) {\n         Link current = head;\n \n-        while (current.value != x) // Find the position to delete\n-            current = current.next;\n+        while (current.value != x) {// Find the position to delete\n+            if (current != tail) {\n+                current = current.next;\n+            } else {// If we reach the tail and the element is still not found\n+                throw new RuntimeException(\"The element to be deleted does not exist!\");\n+            }\n+        }\n \n         if (current == head)\n             deleteHead();",
    "output": "Fix for . Deleting an element that doesn't exist causes NPE"
  },
  {
    "input": "diff --git a/DataStructures/Lists/DoublyLinkedList.java b/DataStructures/Lists/DoublyLinkedList.java\n--- a/DataStructures/Lists/DoublyLinkedList.java\n+++ b/DataStructures/Lists/DoublyLinkedList.java\n@@ -116,8 +116,13 @@ public Link deleteTail() {\n     public void delete(int x) {\n         Link current = head;\n \n-        while (current.value != x) // Find the position to delete\n-            current = current.next;\n+        while (current.value != x) {// Find the position to delete\n+            if (current != tail) {\n+                current = current.next;\n+            } else {// If we reach the tail and the element is still not found\n+                throw new RuntimeException(\"The element to be deleted does not exist!\");\n+            }\n+        }\n \n         if (current == head)\n             deleteHead();",
    "output": "Fix for . Deleting an element that doesn't exist causes NPE"
  },
  {
    "input": "diff --git a/DataStructures/Lists/SinglyLinkedList.java b/DataStructures/Lists/SinglyLinkedList.java\n--- a/DataStructures/Lists/SinglyLinkedList.java\n+++ b/DataStructures/Lists/SinglyLinkedList.java\n@@ -66,13 +66,12 @@ public void deleteHead() {\n     }\n \n     /**\n-    * This method deletes an element at Nth position\n-    */\n+     * This method deletes an element at Nth position\n+     */\n     public void deleteNth(int position) {\n-         if (position < 0 || position > getSize()) {\n+        if (position < 0 || position >= getSize()) {\n             throw new RuntimeException(\"position less than zero or position more than the count of list\");\n-        }\n-        else if (position == 0)\n+        } else if (position == 0)\n             deleteHead();\n         else {\n             Node cur = head;",
    "output": "Fix for . position=size causes NPE"
  },
  {
    "input": "diff --git a/DataStructures/Matrix/Matrix.java b/DataStructures/Matrix/Matrix.java\n--- a/DataStructures/Matrix/Matrix.java\n+++ b/DataStructures/Matrix/Matrix.java\n@@ -211,7 +211,12 @@ public Matrix multiply(Matrix other) throws RuntimeException {\n \t* @return boolean\n     */\n     public boolean equals(Matrix other) {\n-        return this == other;\n+        for (int i = 0; i < this.data.length; i++)\n+            for (int j = 0; j < this.data[0].length; j++)\n+                if (this.data[i][j] != other.data[i][j])\n+                    return false;\n+\n+        return true;\n     }\n \n     /**",
    "output": "Make Matrix equality comparison deep. Solution to the issue"
  },
  {
    "input": "diff --git a/DataStructures/Queues/PriorityQueues.java b/DataStructures/Queues/PriorityQueues.java\n--- a/DataStructures/Queues/PriorityQueues.java\n+++ b/DataStructures/Queues/PriorityQueues.java\n@@ -37,6 +37,10 @@ public PriorityQueue(int size){\n \tpublic void insert(int value){\n \t\tif(nItems == 0){\n \t\t\tqueueArray[0] = value;\n+\t\t\tnItems++;\n+\t\t}\n+\t\telse if(isFull()){\t//does not insert value when the queue is full\n+\t\t\tSystem.out.println(\"Queue is full\");\n \t\t}\n \t\telse{\n \t\t\tint j = nItems;\n@@ -45,8 +49,8 @@ public void insert(int value){\n \t\t\t\tj--;\n \t\t\t}\n \t\t\tqueueArray[j] = value; //Once the correct position is found the value is inserted\n+\t\t\tnItems++;\n \t\t}\n-\t\tnItems++;\n \t}\n \n \t/**\n@@ -120,4 +124,4 @@ public static void main(String args[]){\n \n \t\t//As you can see, a Priority Queue can be used as a sorting algotithm\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Upgrade PriorityQueues.java Include condition to check if the queue is full when inserting values into the queue"
  },
  {
    "input": "diff --git a/DataStructures/CSVFile/src/CSVFile.java b/DataStructures/CSVFile/src/CSVFile.java\n--- a/DataStructures/CSVFile/src/CSVFile.java\n+++ b/DataStructures/CSVFile/src/CSVFile.java\n@@ -136,7 +136,7 @@ public CSVFile(char separator) {\n \t\ttable = new ArrayList<ArrayList<String>>();\n \t\ttrackList = new ArrayList<Integer>();\n \t\tpathCSVFile = \"\";\n-\t\tthis.seperator = seperator;\n+\t\tthis.seperator = separator;\n \t}\n \n \t",
    "output": "Upgrade CSVFile.java to - Fix wrong assignation"
  },
  {
    "input": "diff --git a/Others/EulersFunction.java b/Others/EulersFunction.java\n--- a/Others/EulersFunction.java\n+++ b/Others/EulersFunction.java\n@@ -0,0 +1,20 @@\n+//You can read more about Euler's totient function https://en.wikipedia.org/wiki/Euler%27s_totient_function\n+public class EulersFunction {\n+    //This method returns us number of x that (x < n) and gcd(x, n) == 1 in O(sqrt(n)) time complexity;\n+    public static int getEuler(int n) {\n+        int result = n;\n+        for (int i = 2; i * i <= n; i++) {\n+            if(n % i == 0) {\n+                while (n % i == 0) n /= i;\n+                result -= result / i;\n+            }\n+        }\n+        if (n > 1) result -= result / n;\n+        return result;\n+    }\n+    public static void main(String[] args) {\n+        for(int i = 1; i < 100; i++) {\n+            System.out.println(getEuler(i));\n+        }\n+    }\n+}",
    "output": "Add Euler's totient Function"
  },
  {
    "input": "diff --git a/Searches/BinarySearch.java b/Searches/BinarySearch.java\n--- a/Searches/BinarySearch.java\n+++ b/Searches/BinarySearch.java\n@@ -72,7 +72,7 @@ private <T extends Comparable<T>> int search(T array[], T key, int left, int rig\n     // Driver Program\n     public static void main(String[] args) {\n         // Just generate data\n-        Random random = ThreadLocalRandom.current();\n+        Random r = ThreadLocalRandom.current();\n         \n         int size = 100;\n         int maxElement = 100000;",
    "output": "Upgrade BinarySearch.java fix"
  },
  {
    "input": "diff --git a/Others/Palindrome.java b/Others/Palindrome.java\n--- a/Others/Palindrome.java\n+++ b/Others/Palindrome.java\n@@ -1,6 +1,6 @@\n class Palindrome {\n \t\n-\tprivate String reverseString(String x){ //*helper method\n+\tprivate String reverseString(String x){ //*helper method\t\n \t\tString output = \"\";\n \t\tfor(int i=x.length()-1; i>=0; i--){\n \t\t\toutput += x.charAt(i); //addition of chars create String\n@@ -10,7 +10,9 @@ private String reverseString(String x){ //*helper method\n \t\n \t\n \tpublic Boolean FirstWay(String x){ //*palindrome method, returns true if palindrome\n-\t\treturn (x.equalsIgnoreCase(reverseString(x)));\n+\t\tif(x == null || x.length() <= 1) \n+            \t\treturn true;\n+        \treturn (x.equalsIgnoreCase(reverseString(x)));\n \t}\n   \t\n   \tpublic boolean SecondWay(String x)",
    "output": "Upgrade Palindrome.java Test cases where String x is null or has a length of 0 or 1 for FirstWay method"
  },
  {
    "input": "diff --git a/DataStructures/Trees/BinaryTree.java b/DataStructures/Trees/BinaryTree.java\n--- a/DataStructures/Trees/BinaryTree.java\n+++ b/DataStructures/Trees/BinaryTree.java\n@@ -69,8 +69,12 @@ public Node find(int key) {\n \t\tNode current = root;\n \t\twhile (current != null) {\n \t\t\tif(key < current.data) {\n+\t\t\t\tif(current.left == null)\n+\t\t\t\t\treturn current;\t//The key isn't exist, returns the parent\n \t\t\t\tcurrent = current.left;\n \t\t\t} else if(key > current.data) {\n+\t\t\t\tif(current.right == null)\n+\t\t\t\t\treturn current;\t\n \t\t\t\tcurrent = current.right;\n \t\t\t} else {\t// If you find the value return it\n \t\t\t\treturn current;",
    "output": "Fix BinaryTree.java put method"
  },
  {
    "input": "diff --git a/Others/SJF.java b/Others/SJF.java\n--- a/Others/SJF.java\n+++ b/Others/SJF.java\n@@ -1,3 +1,15 @@\n+// Shortest job first.\n+\n+// Shortest job first (SJF) or shortest job next, is a scheduling policy \n+// that selects the waiting process with the smallest execution time to execute next\n+// Shortest Job first has the advantage of having minimum average waiting \n+// time among all scheduling algorithms.\n+// It is a Greedy Algorithm.\n+// It may cause starvation if shorter processes keep coming.\n+// This problem has been solved using the concept of aging.\n+\n+\n+\n import java.util.Scanner;\n import java.util.ArrayList;\n import java.util.Comparator;",
    "output": "Add description about algorithm"
  },
  {
    "input": "diff --git a/Others/Dijkstra.java b/Others/Dijkstra.java\n--- a/Others/Dijkstra.java\n+++ b/Others/Dijkstra.java\n@@ -57,7 +57,7 @@ public Edge(String v1, String v2, int dist) {\n    }\r\n  \r\n    /** One vertex of the graph, complete with mappings to neighbouring vertices */\r\n-  public static class Vertex implements Comparable<Vertex>{\r\n+  public static class Vertex implements Comparable<Vertex> {\r\n \tpublic final String name;\r\n \tpublic int dist = Integer.MAX_VALUE; // MAX_VALUE assumed to be infinity\r\n \tpublic Vertex previous = null;\r\n@@ -67,7 +67,7 @@ public Vertex(String name){\n \t\tthis.name = name;\r\n \t}\r\n  \r\n-\tprivate void printPath(){\r\n+\tprivate void printPath() {\r\n \t\tif (this == this.previous)\r\n \t\t{\r\n \t\t\tSystem.out.printf(\"%s\", this.name);\r\n@@ -83,14 +83,14 @@ else if (this.previous == null)\n \t\t}\r\n \t}\r\n  \r\n-\tpublic int compareTo(Vertex other){\r\n+\tpublic int compareTo(Vertex other) {\r\n \t\tif (dist == other.dist)\r\n \t\t\treturn name.compareTo(other.name);\r\n  \r\n \t\treturn Integer.compare(dist, other.dist);\r\n \t}\r\n  \r\n-\t@Override public String toString(){\r\n+\t@Override public String toString() {\r\n \t\treturn \"(\" + name + \", \" + dist + \")\";\r\n \t}\r\n }\r",
    "output": "Upgrade the format of brackets"
  },
  {
    "input": "diff --git a/Others/Dijkstra.java b/Others/Dijkstra.java\n--- a/Others/Dijkstra.java\n+++ b/Others/Dijkstra.java\n@@ -12,7 +12,6 @@\n  * Also most of the comments are from RosettaCode.\r\n  *\r\n  */\r\n-\r\n //import java.io.*;\r\n import java.util.*; \r\n public class Dijkstra {\r",
    "output": "Add a new Dijkstra's algorithm"
  },
  {
    "input": "diff --git a/Data Structures/Stacks/StackOfLinkedList.java b/Data Structures/Stacks/StackOfLinkedList.java\n--- a/Data Structures/Stacks/StackOfLinkedList.java\n+++ b/Data Structures/Stacks/StackOfLinkedList.java\n@@ -15,6 +15,7 @@ public static void main(String[] args) {\n         stack.push(2);\n         stack.push(3);\n         stack.push(4);\n+        stack.push(5);\n \n         stack.printStack();\n \n@@ -23,6 +24,8 @@ public static void main(String[] args) {\n         stack.pop();\n         stack.pop();\n \n+        System.out.println(\"Top element of stack currently is: \" + stack.peek());\n+\n     }\n \n }\n@@ -75,12 +78,20 @@ public void pop() {\n         System.out.println(\"Popped element is: \" + temp.data);\n     }\n \n+    public int peek() {\n+      if (getSize() == 0) {\n+        return -1;\n+      }\n+\n+      return head.data;\n+    }\n+\n     public void printStack() {\n \n         Node temp = head;\n         System.out.println(\"Stack is printed as below: \");\n         while (temp != null) {\n-            System.out.print(temp.data + \" \");\n+            System.out.println(temp.data + \" \");\n             temp = temp.next;\n         }\n         System.out.println();\n@@ -94,5 +105,5 @@ public boolean isEmpty() {\n     public int getSize() {\n         return size;\n     }\n-    \n+\n }",
    "output": "Add peek() method and stack is now printed vertically"
  },
  {
    "input": "diff --git a/Dynamic Programming/CoinChange.java b/Dynamic Programming/CoinChange.java\n--- a/Dynamic Programming/CoinChange.java\n+++ b/Dynamic Programming/CoinChange.java\n@@ -29,9 +29,7 @@ public static int change(int[] coins, int amount) {\n \n         for (int coin : coins) {\n             for (int i=coin; i<amount+1; i++) {\n-                if (i>=coin) {\n                     combinations[i] += combinations[i-coin];\n-                }\n             }\n             // Uncomment the below line to see the state of combinations for each coin\n             // printAmount(combinations);",
    "output": "Remove redundant if condition for loop above if condition is starting from coin and operation is increment in loop so value of i will be always >= coin hence if condition is redundant there"
  },
  {
    "input": "diff --git a/DataStructures/Lists/CircleLinkedList.java b/DataStructures/Lists/CircleLinkedList.java\n--- a/DataStructures/Lists/CircleLinkedList.java\n+++ b/DataStructures/Lists/CircleLinkedList.java\n@@ -34,7 +34,7 @@ public void append(E value){\n     }\n \n     public E remove(int pos){\n-        if(pos>size || pos< 0){\n+        if(pos>=size || pos< 0){\n             //catching errors\n             throw new IndexOutOfBoundsException(\"position cannot be greater than size or negative\");\n         }\n@@ -45,13 +45,15 @@ public E remove(int pos){\n             iterator = iterator.next;\n             before = before.next;\n         }\n-        E saved = iterator.value;\n-        // assigning the next referance to the the element following the element we want to remove... the last element will be assigned to the head.\n+        E removedValue = iterator.value;\n+        // assigning the next reference to the the element following the element we want to remove... the last element will be assigned to the head.\n         before.next = iterator.next;\n         // scrubbing\n         iterator.next = null;\n         iterator.value = null;\n+        size--;\n \n-        return saved;\n+        return removedValue;\n     }\n+\n }\n\\ No newline at end of file",
    "output": "Fix remove method"
  },
  {
    "input": "diff --git a/DataStructures/Lists/CircleLinkedList.java b/DataStructures/Lists/CircleLinkedList.java\n--- a/DataStructures/Lists/CircleLinkedList.java\n+++ b/DataStructures/Lists/CircleLinkedList.java\n@@ -7,15 +7,16 @@ private Node(E value, Node<E> next){\n             this.next = next;\n         }\n     }\n+\n     //For better O.O design this should be private allows for better black box design\n     private int size;\n     //this will point to dummy node;\n     private Node<E> head;\n+    private Node<E> tail;\n     //constructer for class.. here we will make a dummy node for circly linked list implementation with reduced error catching as our list will never be empty;\n     public CircleLinkedList(){\n-        //creation of the dummy node\n-        head = new Node<E>(null,head);\n-        size = 0;\n+        head = new Node<>(null, head);\n+        tail = head;\n     }\n     // getter for the size... needed because size is private.\n     public int getSize(){ return size;}\n@@ -25,9 +26,13 @@ public void append(E value){\n             // we do not want to add null elements to the list.\n             throw new NullPointerException(\"Cannot add null element to the list\");\n         }\n-        //head.next points to the last element;\n-        head.next = new Node<E>(value,head);\n-        size++;}\n+\n+        //add new node at the end of the list and update tail node to point to new node\n+        tail.next = new Node(value, head);\n+        tail = tail.next;\n+        size++;\n+    }\n+\n     public E remove(int pos){\n         if(pos>size || pos< 0){\n             //catching errors",
    "output": "Fix null value issue stated in"
  },
  {
    "input": "diff --git a/Searches/src/search/IterativeTernarySearch.java b/Searches/src/search/IterativeTernarySearch.java\n--- a/Searches/src/search/IterativeTernarySearch.java\n+++ b/Searches/src/search/IterativeTernarySearch.java\n@@ -62,7 +62,10 @@ public static void main(String[] args) {\n         Random r = new Random();\n         int size = 100;\n         int maxElement = 100000;\n-        Integer[] integers = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);\n+        Integer[] integers = Stream.generate(() -> r.nextInt(maxElement))\n+                .limit(size)\n+                .sorted()\n+                .toArray(Integer[]::new);\n \n \n         //the element that should be found",
    "output": "Change code style"
  },
  {
    "input": "diff --git a/Sorts/CombSort.java b/Sorts/CombSort.java\n--- a/Sorts/CombSort.java\n+++ b/Sorts/CombSort.java\n@@ -3,17 +3,15 @@\n class CombSort\n {\n     // To find gap between elements\n-    int getNextGap(int gap)\n+    static int getNextGap(int gap)\n     {\n         // Shrink gap by Shrink factor\n         gap = (gap*10)/13;\n-        if (gap < 1)\n-            return 1;\n-        return gap;\n+        gap = (gap < 1) ? 1: gap;\n     }\n  \n     // Function to sort arr[] using Comb Sort\n-    void sort(int arr[])\n+    static void sort(int arr[])\n     {\n         int n = arr.length;\n  \n@@ -24,7 +22,7 @@ void sort(int arr[])\n         boolean swapped = true;\n  \n         // Keep running while gap is more than 1 and last iteration caused a swap\n-        while (gap != 1 || swapped == true)\n+        while (gap != 1 || swapped)\n         {\n             // Find next gap\n             gap = getNextGap(gap);\n@@ -57,8 +55,8 @@ public static void main(String args[])\n         ob.sort(arr);\n  \n         System.out.println(\"sorted array\");\n-        for (int i=0; i<arr.length; ++i)\n+        for (int i=0; i<arr.length; ++i) {\n             System.out.print(arr[i] + \" \");\n- \n+        } \n     }\n }",
    "output": "Upgrade CombSort.java As requested done the changes"
  },
  {
    "input": "diff --git a/Others/countwords.java b/Others/countwords.java\n--- a/Others/countwords.java\n+++ b/Others/countwords.java\n@@ -19,7 +19,7 @@ public static void main(String[] args){\n         } \n \n         private static int wordCount(String s){\n-          if(s.isEmpty() || s == null) return -1;\n+          if(s.isEmpty() || s == null) return 0;\n           return s.trim().split(\"[\\\\s]+\").length;\n         }\n         ",
    "output": "Fix a logical error"
  },
  {
    "input": "diff --git a/Others/CountChar.java b/Others/CountChar.java\n--- a/Others/CountChar.java\n+++ b/Others/CountChar.java\n@@ -24,7 +24,7 @@ public static void main(String[] args) {\n      * @return int: Number of characters in the passed string\n      * */\n \n-    public static int CountCharacters(String str) {\n+    private static int CountCharacters(String str) {\n \n     \tint count = 0;\n ",
    "output": "Change access specifier to private"
  },
  {
    "input": "diff --git a/Compression/src/HEncoder.java b/Compression/src/HEncoder.java\n--- a/Compression/src/HEncoder.java\n+++ b/Compression/src/HEncoder.java\n@@ -4,8 +4,8 @@\n \r\n public class HEncoder {\r\n \r\n-\tpublic HashMap<Character, String> encoder = new HashMap<>();\r\n-\tpublic HashMap<String, Character> decoder = new HashMap<>();\r\n+\tpublic HashMap<Character, String> encoder = new HashMap<>(); // in order to encode\r\n+\tpublic HashMap<String, Character> decoder = new HashMap<>(); // in order to decode\r\n \r\n \tprivate static class Node {\r\n \r\n@@ -81,14 +81,17 @@ private void traverse(Node node, String osf) {\n \r\n \t}\r\n \r\n+\t// compression work done here\r\n \tpublic String compress(String str) {\r\n \t\tString rv = \"\";\r\n \t\tfor (int i = 0; i < str.length(); ++i) {\r\n \t\t\trv += encoder.get(str.charAt(i));\r\n \t\t}\r\n \t\treturn rv;\r\n \t}\r\n+\t\r\n \r\n+\t//in order to decompress\r\n \tpublic String decompress(String str) {\r\n \t\tString s = \"\";\r\n \t\tString code = \"\";\r",
    "output": "Add comments for some functions"
  },
  {
    "input": "diff --git a/Others/PowerOfTwoOrNot.java b/Others/PowerOfTwoOrNot.java\n--- a/Others/PowerOfTwoOrNot.java\n+++ b/Others/PowerOfTwoOrNot.java\n@@ -0,0 +1,33 @@\n+import java.util.Scanner;\n+\n+/**\n+*A utility to check if a given number is power of two or not.\n+*For example 8,16 etc.\n+*/\n+public class PowerOfTwoOrNot {\n+\t\n+\tpublic static void main (String[] args) {\n+\t\n+\t\tScanner sc = new Scanner(System.in);\n+\t\tSystem.out.println(\"Enter the number\");\n+\t\tint num = sc.nextInt();\n+\t\tboolean isPowerOfTwo = checkIfPowerOfTwoOrNot(num);\n+\t\tif (isPowerOfTwo) {\n+\t\t\tSystem.out.println(\"Number is a power of two\");\n+\t\t} else {\n+\t\t\tSystem.out.println(\"Number is not a power of two\");\n+\t\t}\n+\t}\n+\n+\n+/**\n+* Checks whether given number is power of two or not.\n+*\n+* @param number\n+* @return boolean\n+*/\n+public static boolean checkIfPowerOfTwoOrNot(int number) {\n+\t\treturn number != 0 && ((number & (number-1)) == 0);\n+\t}\n+\n+}",
    "output": "Add PowerOfTwoOrNot to Others"
  },
  {
    "input": "diff --git a/Data Structures/Matrix/Matrix.java b/Data Structures/Matrix/Matrix.java\n--- a/Data Structures/Matrix/Matrix.java\n+++ b/Data Structures/Matrix/Matrix.java\n@@ -221,4 +221,20 @@ public String toString() {\n \n         return str;\n     }\n+\t\n+\t/**\n+    * Returns transposed matrix of this matrix.\n+    *\n+    * @return transposed Matrix. \n+    */\n+\tpublic Matrix transpose() {\n+\t\t\n+\t\tint[][] newData = new int[this.data[0].length][this.data.length];\n+\n+\t\tfor (int i = 0; i < this.getColumns(); ++i)\n+\t\t\tfor(int j = 0; j < this.getRows(); ++j)\n+\t\t\t\tnewData[i][j] = this.data[j][i];\n+\n+\t\treturn new Matrix(newData);\n+\t}\t\t\n }",
    "output": "Upgrade Matrix.java, added Transpose of a Matrix"
  },
  {
    "input": "diff --git a/Others/FloydTriangle.java b/Others/FloydTriangle.java\n--- a/Others/FloydTriangle.java\n+++ b/Others/FloydTriangle.java\n@@ -6,7 +6,7 @@ public static void main(String[] args) {\n           Scanner sc = new Scanner(System.in);\n           System.out.println(\"Enter the number of rows which you want in your Floyd Triangle: \");\n           int r = sc.nextInt(), n = 0;\n-\n+          sc.close();\n           for(int i=0; i < r; i++) {\n               for(int j=0; j <= i; j++) {\n                   System.out.print(++n + \" \");",
    "output": "Add closing the scanner"
  },
  {
    "input": "diff --git a/Others/FibToN.java b/Others/FibToN.java\n--- a/Others/FibToN.java\n+++ b/Others/FibToN.java\n@@ -9,7 +9,7 @@ public static void main(String[] args) {\n \t\t// print fibonacci sequence less than N\n \t\tint first = 0, second = 1;\n \t\t//first fibo and second fibonacci are 0 and 1 respectively\n-\t\t\n+\t\tscn.close();\n \t\twhile(first <= N){\n \t\t\t//print first fibo 0 then add second fibo into it while updating second as well\n \t\t\t",
    "output": "Add closeing the scanner"
  },
  {
    "input": "diff --git a/Others/countwords.java b/Others/countwords.java\n--- a/Others/countwords.java\n+++ b/Others/countwords.java\n@@ -7,7 +7,7 @@\n  * @author Marcus\n  *\n  */\n-  class CountTheWords{\n+  public class countwords{\n \n \tpublic static void main(String[] args){\n \t  Scanner input = new Scanner(System.in);",
    "output": "Add public and change class_name"
  },
  {
    "input": "diff --git a/Data Structures/Matrix/Matrix.java b/Data Structures/Matrix/Matrix.java\n--- a/Data Structures/Matrix/Matrix.java\n+++ b/Data Structures/Matrix/Matrix.java\n@@ -37,6 +37,7 @@ public static void main(String[] args) {\n         System.out.println(\"2 * m2:\\n\" + m2.scale(2));\n         System.out.println(\"m2 + m3:\\n\" + m2.plus(m3));\n         System.out.println(\"m2 - m3:\\n\" + m2.minus(m3));\n+        System.out.println(\"m2 * m3: \\n\"+m2.multiply(m3));\n \t}\n \n \n@@ -157,6 +158,32 @@ public Matrix minus(Matrix other) throws RuntimeException {\n \n         return new Matrix(newData);\n     }\n+    \n+    /**\n+     * Multiplies this matrix with another matrix.\n+     *\n+     * @param other : Matrix to be multiplied with\n+     * @return product\n+     */\n+     public Matrix multiply(Matrix other) throws RuntimeException {\n+\n+     \tint[][] newData = new int[this.data.length][other.getColumns()];\n+\n+     \tif(this.getColumns() !=other.getRows())\n+ \t\t\tthrow new RuntimeException(\"The two matrices cannot be multiplied.\");\n+     \tint sum;\n+     \tfor (int i = 0; i < this.getRows(); ++i)\n+ \t\t\tfor(int j = 0; j < other.getColumns(); ++j){\n+ \t\t\t\tsum = 0;\n+ \t\t\t\tfor(int k=0;k<this.getColumns();++k){\n+ \t\t\t\t\tsum += this.data[i][k] * other.getElement(k, j);\n+ \t\t\t\t}\n+ \t\t\t\tnewData[i][j] = sum; \n+ \t\t\t}\n+ \t\t\t\t\n+\n+         return new Matrix(newData);\n+     }\n \n     /**\n     * Checks if the matrix passed is equal to this matrix",
    "output": "Upgrade Matrix.java, added Matrix Multiplication"
  },
  {
    "input": "diff --git a/Others/Armstrong.java b/Others/Armstrong.java\n--- a/Others/Armstrong.java\n+++ b/Others/Armstrong.java\n@@ -1,5 +1,3 @@\n-package Others;\n-\n import java.util.Scanner;\n \n /**",
    "output": "Remove package name"
  },
  {
    "input": "diff --git a/Others/PasswordGen.java b/Others/PasswordGen.java\n--- a/Others/PasswordGen.java\n+++ b/Others/PasswordGen.java\n@@ -5,13 +5,19 @@\n \n /*\n     Creates a random password from ASCII letters\n+    Given password length bounds\n     \n     author: AKS1996\n-\tdate: 2017-10-22\n+    date: 2017-10-25\n */\n \n class PasswordGen {\n     public static void main(String args[]){\n+\tString password = generatePassword(8,16);\n+\tSystem.out.print(\"Password: \" + password);\n+    }\n+\t\n+    static String generatePassword(int min_length, int max_length){\n         Random random = new Random();\n \n         String upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n@@ -27,16 +33,13 @@ public static void main(String args[]){\n \n         // Inbuilt method to randomly shuffle a elements of a list\n         Collections.shuffle(letters);\n-\n-        int min_length = 8;\n-        int max_length = 16;\n         String password = \"\";\n \n         // Note that size of the password is also random\n         for(int i = random.nextInt(max_length-min_length) + min_length; i>0; --i) {\n             password += letters.get(random.nextInt(letters.size()));\n         }\n \n-        System.out.print(\"Password: \" + password);\n+        return password;\n     }\n }",
    "output": "Upgrade PasswordGen.java separated main and generatePassword function"
  },
  {
    "input": "diff --git a/Others/FloydTriangle.java b/Others/FloydTriangle.java\n--- a/Others/FloydTriangle.java\n+++ b/Others/FloydTriangle.java\n@@ -1,7 +1,7 @@\n import java.util.Scanner;\n \n \n-class FloydTriangle {\n+public class FloydTriangle {\n     public static void main(String[] args) {\n           Scanner sc = new Scanner(System.in);\n           System.out.println(\"Enter the number of rows which you want in your Floyd Triangle: \");",
    "output": "Upgrade and rename ft.java to FloydTriangle.java"
  },
  {
    "input": "diff --git a/Others/Armstrong.java b/Others/Armstrong.java\n--- a/Others/Armstrong.java\n+++ b/Others/Armstrong.java\n@@ -0,0 +1,40 @@\n+package Others;\n+\n+import java.util.Scanner;\n+/**\n+ * To check if a given number is armstrong or not.\n+ * @author mani manasa mylavarapu\n+ *\n+ */\n+public class Armstrong {\n+\tpublic static void main(String[] args) {\n+\t\tScanner scan = new Scanner(System.in);\n+\t\tSystem.out.println(\"please enter the number\");\n+\t\tint n = scan.nextInt();\n+\t\tboolean isArmstrong = checkIfANumberIsAmstrongOrNot(n);\n+\t\tif(isArmstrong)\n+\t\t{\n+\t\t\tSystem.out.println(\"the number is armstrong\");\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tSystem.out.println(\"the number is not armstrong\");\n+\t\t}\n+\t}\n+\n+\tpublic static boolean checkIfANumberIsAmstrongOrNot(int number) {\n+\t\tint remainder, sum = 0,temp=0;\n+\t\ttemp=number;\n+\t\twhile (number > 0) {\n+\t\t\tremainder = number % 10;\n+\t\t\tsum = sum + (remainder * remainder * remainder);\n+\t\t\tnumber = number / 10;\n+\t\t}\n+\t\tif (sum == temp) {\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t}\n+}\n\\ No newline at end of file",
    "output": "Add Armstrong number algorithm"
  },
  {
    "input": "diff --git a/data_structures/Graphs/PrimMST.java b/data_structures/Graphs/PrimMST.java\n--- a/data_structures/Graphs/PrimMST.java\n+++ b/data_structures/Graphs/PrimMST.java\n@@ -5,7 +5,7 @@\n import java.lang.*;\n import java.io.*;\n  \n-class MST\n+class PrimMST\n {\n     // Number of vertices in the graph\n     private static final int V=5;\n@@ -113,4 +113,4 @@ public static void main (String[] args)\n         // Print the solution\n         t.primMST(graph);\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Upgrade and rename prim.java to PrimMST.java"
  },
  {
    "input": "diff --git a/Searches/TernarySearch.java b/Searches/TernarySearch.java\n--- a/Searches/TernarySearch.java\n+++ b/Searches/TernarySearch.java\n@@ -57,7 +57,7 @@ public static void main(String[] args) {\n         System.out.println(\"Enter number of elements in the array\");\n         int n = s.nextInt();\n         int arr[] = new int[n];\n-        System.out.println(\"Enter the elements of the array\");\n+        System.out.println(\"Enter the elements of the Sorted array\");\n         for (int i= 0; i < n; i++){\n             arr[i] = s.nextInt();\n         }\n@@ -68,7 +68,7 @@ public static void main(String[] args) {\n             System.out.println(\" The element is not present in the array.\");\n         }\n         else {\n-            System.out.println(\"The element is present at the position\" + ans);\n+            System.out.println(\"The element is present at the position \" + (ans+1));\n         }\n     }\n }\n\\ No newline at end of file",
    "output": "Add Ternary Search"
  },
  {
    "input": "diff --git a/data_structures/Stacks/Stacks.java b/data_structures/Stacks/Stacks.java\n--- a/data_structures/Stacks/Stacks.java\n+++ b/data_structures/Stacks/Stacks.java\n@@ -42,7 +42,7 @@ public void push(int value){\n \t\t\ttop++;\n \t\t\tstackArray[top] = value;\n \t\t}else{\n-\t\t\tSystem.out.println(\"The stack is full, can't insert value\");\n+\t\t\tresize(maxSize*2);\n \t\t}\n \t}\n \n@@ -54,7 +54,12 @@ public void push(int value){\n \tpublic int pop(){\n \t\tif(!isEmpty()){ //Checks for an empty stack\n \t\t\treturn stackArray[top--];\n-\t\t}else{\n+\t\t}\n+\n+\t\tif(top < maxSize/4){\n+\t\t\tresize(maxSize/2);\n+\t\t}\n+\t\telse{\n \t\t\tSystem.out.println(\"The stack is already empty\");\n \t\t\treturn -1;\n \t\t}\n@@ -74,6 +79,16 @@ public int peek(){\n \t\t}\n \t}\n \n+\tprivate void resize(int newSize){\n+\t\tprivate int[] transferArray = new int[newSize];\n+\n+\t\tfor(int i = 0; i < stackArray.length(); i++){\n+\t\t\ttransferArray[i] = stackArray[i];\n+\t\t\tstackArray = transferArray;\n+\t\t}\n+\t\tmaxSize = newSize;\n+\t}\n+\n \t/**\n \t * Returns true if the stack is empty\n \t *",
    "output": "Add Resize for Stacks"
  },
  {
    "input": "diff --git a/Misc/FibToN.java b/Misc/FibToN.java\n--- a/Misc/FibToN.java\n+++ b/Misc/FibToN.java\n@@ -3,18 +3,21 @@\n public class FibToN {\n \n \tpublic static void main(String[] args) {\n+\t\t//take input\n \t\tScanner scn = new Scanner(System.in);\n+\t\tint N = scn.nextInt();\n+\t\t// print fibonacci sequence less than N\n+\t\tint first = 0, second = 1;\n+\t\t//first fibo and second fibonacci are 0 and 1 respectively\n \t\t\n-\t\tint n = scn.nextInt();\n-\t\t\n-\t\tint fn = 0, sn = 1;\n-\t\t\n-\t\twhile(fn <= n){\n-\t\t\tSystem.out.println(fn);\n+\t\twhile(first <= N){\n+\t\t\t//print first fibo 0 then add second fibo into it while updating second as well\n+\t\t\t\n+\t\t\tSystem.out.println(first);\n \t\t\t\n-\t\t\tint next = fn + sn;\n-\t\t\tfn = sn;\n-\t\t\tsn = next;\n+\t\t\tint next = first+ second;\n+\t\t\tfirst = second;\n+\t\t\tsecond = next;\n \t\t}\n \t}\n ",
    "output": "Upgrade added comments and changed variable names for better understanding"
  },
  {
    "input": "diff --git a/Misc/root_precision.java b/Misc/root_precision.java\n--- a/Misc/root_precision.java\n+++ b/Misc/root_precision.java\n@@ -7,22 +7,27 @@\n public class Solution {\n \n     public static void main(String[] args) {\n+\t//take input    \n       Scanner scn = new Scanner(System.in);\n       \n-      int N = scn.nextInt();\n-      int P = scn.nextInt();\n+      int N = scn.nextInt(); //N is the input number\n+      int P = scn.nextInt(); //P is precision value for eg - P is 3 in 2.564 and 5 in 3.80870.\n       \n       System.out.println(squareRoot(N, P));\n    }\n    \n    public static double squareRoot(int N, int P) {\n-      double sqrt = 0;;\n-      \n-        // Write your code here\n-       double root = Math.pow(N, 0.5);\n-\t\tint pre = (int) Math.pow(10, P);\n-\t\troot = root * pre;\n-\t   sqrt =  (int)root;\n-      return (double)sqrt/pre;\n+        double rv = 0;  //rv means return value\n+\t   \n+        double root = Math.pow(N, 0.5);\n+\t\n+\t//calculate precision to power of 10 and then multiply it with root value.\n+\tint precision = (int) Math.pow(10, P);\n+\troot = root * precision;\n+\t /*typecast it into integer then divide by precision and again typecast into double \n+\t   so as to have decimal points upto P precision */ \n+\t   \n+\trv =  (int)root;\n+      return (double)rv/precision;\n    }\n }",
    "output": "Upgrade added comments and variable names are more simpler now"
  },
  {
    "input": "diff --git a/Misc/TowerOfHanoiUsingRecursion.java b/Misc/TowerOfHanoiUsingRecursion.java\n--- a/Misc/TowerOfHanoiUsingRecursion.java\n+++ b/Misc/TowerOfHanoiUsingRecursion.java\n@@ -1,15 +1,15 @@\n-package com.manmeet;\n-\n import java.util.Scanner;\n \n-public class TowerOfHanoi\n+class TowerOfHanoi\n {\n     public static void shift(int n, String startPole, String intermediatePole, String endPole)\n     {\n         if (n == 0) // if n becomes zero the program returns thus ending the loop.\n         {\n             return;\n         }\n+      \n+      \n         // Shift function is called in recursion for swapping the n-1 disc from the startPole to the intermediatePole\n         shift(n - 1, startPole, endPole, intermediatePole);\n         System.out.println(\"\\nMove \\\"\" + n + \"\\\" from \" + startPole + \" --> \" + endPole); // Result Printing",
    "output": "Remove unrequired Package"
  },
  {
    "input": "diff --git a/Dynamic Programming/Knapsack.java b/Dynamic Programming/Knapsack.java\n--- a/Dynamic Programming/Knapsack.java\n+++ b/Dynamic Programming/Knapsack.java\n@@ -0,0 +1,38 @@\n+// A Dynamic Programming based solution for 0-1 Knapsack problem\n+\n+public class Knapsack\n+{\n+    \n+\tprivate static int knapSack(int W, int wt[], int val[], int n)\n+\t{\n+\t\tint i, w;\n+\tint rv[][] = new int[n+1][W+1];    //rv means return value\n+\t\n+\t// Build table rv[][] in bottom up manner\n+\tfor (i = 0; i <= n; i++)\n+\t{\n+\t\tfor (w = 0; w <= W; w++)\n+\t\t{\n+\t\t\tif (i==0 || w==0)\n+\t\t\t\trv[i][w] = 0;\n+\t\t\telse if (wt[i-1] <= w)\n+\t\t\t\trv[i][w] = Math.max(val[i-1] + rv[i-1][w-wt[i-1]], rv[i-1][w]);\n+\t\t\telse\n+\t\t\t\trv[i][w] = rv[i-1][w];\n+\t\t}\n+\t}\n+\t\n+\treturn rv[n][W];\n+\t}\n+\n+\n+\t// Driver program to test above function\n+\tpublic static void main(String args[])\n+\t{\n+\t\tint val[] = new int[]{50, 100, 130};\n+\tint wt[] = new int[]{10, 20, 40};\n+\tint W = 50;\n+\tint n = val.length;\n+\tSystem.out.println(knapSack(W, wt, val, n));\n+\t}\n+}",
    "output": "Add 0-1 knapsack\nVery frequently asked DP problem"
  },
  {
    "input": "diff --git a/Misc/crc32.java b/Misc/crc32.java\n--- a/Misc/crc32.java\n+++ b/Misc/crc32.java\n@@ -20,7 +20,6 @@ public static int crc32(byte[] data) {\n             else\n                 crc32 = (crc32 << 1);\n         }\n-        crc32 = crc32 ^ 0;\n         crc32 = Integer.reverse(crc32);                   //result reflect\n         return crc32 ^ 0xFFFFFFFF;                        //final xor value\n     }",
    "output": "Fix a small mistake"
  },
  {
    "input": "diff --git a/Misc/ReverseStackUsingRecursion.java b/Misc/ReverseStackUsingRecursion.java\n--- a/Misc/ReverseStackUsingRecursion.java\n+++ b/Misc/ReverseStackUsingRecursion.java\n@@ -1,4 +1,4 @@\n-package stacks_and_queues;\n+/* Program to reverse a Stack using Recursion*/\n \n \n import java.util.Stack;\n@@ -38,7 +38,7 @@ public static void main(String[] args) {\n \n     //Function Used to reverse Stack Using Recursion\n     private static void reverseUsingRecursion(Stack<Integer> stack) {\n-        if(stack.isEmpty())\n+        if(stack.isEmpty()) // If stack is empty then return\n         {\n             return;\n         }\n@@ -60,7 +60,7 @@ private static void insertAtEnd(int temptop) {\n             int temp = stack.peek(); /* All the items are stored in call stack until we reach end*/\n             stack.pop();\n \n-            insertAtEnd(temptop);\n+            insertAtEnd(temptop); //Recursive call\n \n             stack.push(temp);\n         }",
    "output": "Add algorithm to reverse a stack using recursion"
  },
  {
    "input": "diff --git a/Misc/Abecedarian.java b/Misc/Abecedarian.java\n--- a/Misc/Abecedarian.java\n+++ b/Misc/Abecedarian.java\n@@ -10,12 +10,8 @@ public static boolean isAbecedarian(String s){\n \n             if(s.charAt(i)<=s.charAt(i + 1)){} //Need to check if each letter for the whole word is less than the one before it\n \n-            else{\n-                System.out.println(\"That is not abecedarian\");\n-                return false;\n+            else{return false;}\n             }\n-\n         }\n-        System.out.println(\"Wow, that number is abecedarian\");\n         return true;\n-    }\n+}",
    "output": "Upgrade Abecedarian.java Removed unnecessary println and compacted it"
  },
  {
    "input": "diff --git a/Dynamic Programming/Fibonacci.java b/Dynamic Programming/Fibonacci.java\n--- a/Dynamic Programming/Fibonacci.java\n+++ b/Dynamic Programming/Fibonacci.java\n@@ -0,0 +1,49 @@\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ *\n+ * @author Varun Upadhyay (https://github.com/varunu28)\n+ *\n+ */\n+\n+public class Fibonacci {\n+\n+    public static Map<Integer,Integer> map = new HashMap<Integer,Integer>();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+        int n = Integer.parseInt(br.readLine());\n+\n+        System.out.println(fib(n)); // Returns 8 for n = 6\n+    }\n+\n+    /**\n+     * This method finds the nth fibonacci number using memoization technique\n+     *\n+     * @param n The input n for which we have to determine the fibonacci number\n+     * Outputs the nth fibonacci number\n+     **/\n+\n+    public static int fib(int n) {\n+        if (map.containsKey(n)) {\n+            return map.get(n);\n+        }\n+\n+        int f;\n+\n+        if (n <= 2) {\n+            f = 1;\n+        }\n+        else {\n+            f = fib(n-1) + fib(n-2);\n+            map.put(n,f);\n+        }\n+\n+        return f;\n+    }\n+}\n+",
    "output": "Add Fibanacci using memoization"
  },
  {
    "input": "diff --git a/data_structures/Lists/SinglyLinkedList.java b/data_structures/Lists/SinglyLinkedList.java\n--- a/data_structures/Lists/SinglyLinkedList.java\n+++ b/data_structures/Lists/SinglyLinkedList.java\n@@ -34,6 +34,36 @@ public void insertHead(int x){\n \t\thead = newNode; \t\t\t//Now set the new link to be the head\n \t}\n \n+\n+\t/**\n+     * Inserts a new node at a specified position\n+     * @param head     head node of the linked list\n+     * @param data     data to be stored in a new node\n+     * @param position position at which a new node is to be inserted\n+     * @return  reference of the head of the linked list\n+     */\n+\n+    Node InsertNth(Node head, int data, int position) {\n+        \n+        Node newNode = new Node();\n+        newNode.data = data;\n+        \n+        if (position == 0) {\n+            newNode.next = head;\n+            return newNode;\n+        }\n+\n+        Node current = head;\n+\n+        while (--position > 0) {\n+            current = current.next;\n+        }\n+        \n+        newNode.next = current.next;\n+        current.next = newNode;\n+        return head;\n+    }\n+    \n \t/**\n \t * This method deletes an element at the head\n \t * ",
    "output": "Add function to insert a node at specified position in linked list"
  },
  {
    "input": "diff --git a/Misc/CountChar.java b/Misc/CountChar.java\n--- a/Misc/CountChar.java\n+++ b/Misc/CountChar.java\n@@ -17,9 +17,7 @@ public static void main(String[] args) {\n \n         System.out.println(\"There are \" + CountCharacters(str) + \" characters.\");\n     }\n-\n-\n-\n+\t\n     /**\n      * @param str: String to count the characters\n      *\n@@ -30,12 +28,15 @@ public static int CountCharacters(String str) {\n \n     \tint count = 0;\n \n-    \tif(str.isEmpty() || str == null)\n-    \t\treturn -1;\n+    \tif(str == \"\" || str == null) //Exceptions\n+\t\t{ \n+\t\t\treturn 0; \n+\t\t}\n \n-        for(int i = 0; i < str.length(); i++)\n-        \tif(!Character.isWhitespace(str.charAt(i)))\n+        for(int i = 0; i < str.length(); i++) {\n+        \tif(!Character.isWhitespace(str.charAt(i))) {\n         \t\tcount++;\n+\t\t\t}}\n \n         return count;\n      }",
    "output": "Upgrade syntax / whitespace"
  },
  {
    "input": "diff --git a/data_structures/Stacks.java b/data_structures/Stacks.java\n--- a/data_structures/Stacks.java\n+++ b/data_structures/Stacks.java\n@@ -38,8 +38,12 @@ public Stack(int size){\n \t * @param value The element added\n \t */\n \tpublic void push(int value){\n-\t\ttop++;\n-\t\tstackArray[top] = value;\n+\t\tif(!isFull()){ //Checks for a full stack\n+\t\t\ttop++;\n+\t\t\tstackArray[top] = value;\n+\t\t}else{\n+\t\t\tSystem.out.prinln(\"The stack is full, can't insert value\");\t\n+\t\t}\n \t}\n \n \t/**\n@@ -48,7 +52,12 @@ public void push(int value){\n \t * @return value popped off the Stack\n \t */\n \tpublic int pop(){\n-\t\treturn stackArray[top--];\n+\t\tif(!isEmpty()){ //Checks for an empty stack\n+\t\t\treturn stackArray[top--];\n+\t\t}else{\n+\t\t\tSystem.out.println(\"The stack is already empty\");\n+\t\t\treturn -1;\n+\t\t}\n \t}\n \n \t/**\n@@ -57,7 +66,12 @@ public int pop(){\n \t * @return element at the top of the stack\n \t */\n \tpublic int peek(){\n-\t\treturn stackArray[top];\n+\t\tif(!isEmpty()){ //Checks for an empty stack\n+\t\t\treturn stackArray[top];\n+\t\t}else{\n+\t\t\tSystem.out.println(\"The stack is empty, cant peek\");\n+\t\t\treturn -1;\n+\t\t}\n \t}\n \n \t/**",
    "output": "Add a few edge cases in the stack class Added an if statement to: >The push method to make sure the stack wasn't full. >The pop method to make sure the stack wasn't empty. > The peek method to make sure the stack wasn't empty"
  },
  {
    "input": "diff --git a/ReverseString.java b/ReverseString.java\n--- a/ReverseString.java\n+++ b/ReverseString.java\n@@ -16,19 +16,17 @@ class ReverseString\n \t * @param str String to be reversed\n \t * @return Reversed string\n \t */\n-\tstatic String reverseString(String str)\n-\t{\n-\t\tString reverse=\"\";\n-\t\tif(str.length()==1)\n-\t\t{\n-\t\t\treturn str;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treverse=reverse+str.charAt(str.length()-1)+reverseString(str.substring(0,str.length()-1));\n-\t\t\treturn reverse;\n-\t\t}\n-\t}\n+\tpublic static String reverse(String str){\n+          if(str.isEmpty() || str == null) return str;\n+          \n+          char arr[] = str.toCharArray();\n+          for(int i = 0, j = str.length() - 1; i < j; i++, j--){\n+            char temp = arr[i];\n+            arr[i] = arr[j];\n+            arr[j] = temp;\n+          }\n+          return new String(arr);\n+        }\n \t\n \t/**\n \t * Main Method\n@@ -45,4 +43,4 @@ public static void main(String args[]) throws IOException\n \t\tbr.close();\n \t}\n }\n-\t\t\n\\ No newline at end of file\n+\t\t",
    "output": "Upgrade ReverseString.java Using recursion for reversing a String serves us no benifit. It places extra load on the stack, and it is less efficient than doing so iteratively. I understand now that we can not use built in reverse function, but using recursion is still the worst way we could do the task of String reversal. Everytime we call the reverse method we are placing an extra frame on our stack. This uses space. We also create another string that we are appending our result to with the recursive solution, which is slow because under the hood, Java will create a new empty String and then append each character to the new String, one char at a time. If we do this for each character, then asymtotically we now have time complexity of O(n^2). Recursion in this case also does not make our solution \"simpler\" or \"more elegant\". We want to use recursion when it is advantageous to do so....like traversing trees"
  },
  {
    "input": "diff --git a/countwords.java b/countwords.java\n--- a/countwords.java\n+++ b/countwords.java\n@@ -7,6 +7,8 @@\n  * @author Marcus\n  *\n  */\n+  class CountTheWords{\n+\n \tpublic static void main(String[] args){\n \t  Scanner input = new Scanner(System.in);\n           System.out.println(\"Enter your text: \");",
    "output": "Upgrade countwords.java Class was added back"
  },
  {
    "input": "diff --git a/countwords.java b/countwords.java\n--- a/countwords.java\n+++ b/countwords.java\n@@ -4,30 +4,21 @@\n  * You enter a string into this program, and it will return how\n  * many words were in that particular string\n  * \n- * @author Unknown\n+ * @author Marcus\n  *\n  */\n-class CountTheWords\n-{\n-\t/**\n-\t * The main method\n-\t * \n-\t * @param args Command line arguments\n-\t */\n-    public static void main(String args[])\n-    {\n-        System.out.println(\"Enter the string\");\n-        Scanner sc = new Scanner(System.in);\n-        String s=sc.nextLine();\n-         int count = 1;\n-         for (int i = 0; i < s.length()-1; i++)\n-        {\n-            if((s.charAt(i) == ' ') && (s.charAt(i+1) != ' '))\n-            {\n-                 count++;\n-            }\n+\tpublic static void main(String[] args){\n+\t  Scanner input = new Scanner(System.in);\n+          System.out.println(\"Enter your text: \");\n+          String str = input.nextLine();\n+          \n+          System.out.println(\"Your text has \" + wordCount(str) + \" word(s)\"); \n+\t  input.close();\n+        } \n+\n+        public static int wordCount(String s){\n+          if(s.isEmpty() || s == null) return -1;\n+          return s.trim().split(\"[\\\\s]+\").length;\n         }\n-        System.out.println(\"Number of words in the string = \"+count);\n-        sc.close();\n-    }\n-}\n\\ No newline at end of file\n+        \n+  }",
    "output": "Upgrade countwords.java Easier to read"
  },
  {
    "input": "diff --git a/Conversions/BinaryToOctal.java b/Conversions/BinaryToOctal.java\n--- a/Conversions/BinaryToOctal.java\n+++ b/Conversions/BinaryToOctal.java\n@@ -29,7 +29,15 @@ public static void main(String args[]) {\n \t * @return The octal number\n \t */\n \tpublic static int convertBinaryToOctal(int b) {\n-\t\t\n+\t\tint o = 0, r=0, j =1 ;\n+\t\twhile(b!=0)\n+\t\t{\n+\t\t\tr = b % 10;\n+        \t\to = o + r * j;\n+       \t\t\tj = j * 2;\n+        \t\tb = b / 10;\n+\t\t}\n+\t\treturn o;\n \t}\n \n }",
    "output": "Upgrade BinaryToOctal.java added logic to convert binary to octal"
  },
  {
    "input": "diff --git a/Sorts/BubbleSort.java b/Sorts/BubbleSort.java\n--- a/Sorts/BubbleSort.java\n+++ b/Sorts/BubbleSort.java\n@@ -16,8 +16,12 @@ class BubbleSort\n \t */\n \tpublic static void main(String[] args) \n \t{\n-\t\tint array[]=new int[6];\n+\t\tint size = 6;\n+\t\tint array[]=new int[size];\n+\t\tboolean swap;\n+\t\tint last = size - 1;\n \t\tScanner input=new Scanner(System.in);\n+\t\t\n \n \t\t//Input\n \t\tSystem.out.println(\"Enter any 6 Numbers for Unsorted Array : \");\n@@ -27,18 +31,22 @@ public static void main(String[] args)\n \t\t}\n \n \t\t//Sorting\n-\t\tfor(int i=0; i<5; i++)\n-\t\t{\n-\t\t\tfor(int j=i+1; j<6; j++)\n-\t\t\t{\n-\t\t\t\tif(array[j]>array[i])\n-\t\t\t\t{\n-\t\t\t\t\tint temp=array[j];\n-\t\t\t\t\tarray[j]=array[i];\n-\t\t\t\t\tarray[i]=temp;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\tdo\n+     \t\t{\n+          \t\tswap = false;\n+          \t\tfor (int count = 0; count < last; count++)\n+          \t\t{\n+               \t\t\tif (array[count] > array[count + 1])\n+               \t\t\t{\n+                    \t\t\tint temp = array[count];\n+                    \t\t\tarray[count] = array[count + 1];\n+                    \t\t\tarray[count + 1] = temp;\n+                    \t\t\tswap = true;\n+               \t\t\t}\n+          \t\t}\n+\t\t\t\n+          \t\tlast--;\n+     \t\t} while (swap);\n \n \t\t//Output\n \t\tfor(int i=0; i<6; i++)",
    "output": "Upgrade to more efficient version if array size is scaled. Changed loop from \"for\" to \"do-while\". Added decrement at end of do loop to decrease size of array tested after each iteration"
  },
  {
    "input": "diff --git a/Bubble Sort.java b/Bubble Sort.java\n--- a/Bubble Sort.java\n+++ b/Bubble Sort.java\n@@ -15,15 +15,15 @@ public static void main(String[] args)\n \t\t}\n \n \t\t//Sorting\n-\t\tfor(int i=0; i<6; i++)\n+\t\tfor(int i=0; i<5; i++)\n \t\t{\n-\t\t\tfor(int j=0; j<5; j++)\n+\t\t\tfor(int j=i+1; j<6; j++)\n \t\t\t{\n-\t\t\t\tif(array[j]>array[j+1])\n+\t\t\t\tif(array[j]>array[i])\n \t\t\t\t{\n \t\t\t\t\tint temp=array[j];\n-\t\t\t\t\tarray[j]=array[j+1];\n-\t\t\t\t\tarray[j+1]=temp;\n+\t\t\t\t\tarray[j]=array[i];\n+\t\t\t\t\tarray[i]=temp;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -35,4 +35,4 @@ public static void main(String[] args)\n \t\t}\n \n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Change in for loop for sorting This would decrease the number of comparisons in the loop used for sorting"
  },
  {
    "input": "diff --git a/Decimal to octal.java b/Decimal to octal.java\n--- a/Decimal to octal.java\n+++ b/Decimal to octal.java\n@@ -0,0 +1,19 @@\n+#import java.util.*;\n+class Decimal_Octal\n+{\n+  public static void main()\n+  {\n+    Scanner sc=new Scanner(System.in);\n+    int n,k,d,s=0,c=0;\n+    n=sc.nextInt();\n+    k=n;\n+    while(k!=0)\n+    {\n+      d=k%8;\n+      s+=d*(int)Math.pow(10,c++);\n+      k/=8;\n+    }\n+    System.out.println(\"Decimal number:\"+n);\n+    System.out.println(\"Octal equivalent:\"+s);\n+  }\n+}",
    "output": "Add Decimal to Octal conversion"
  },
  {
    "input": "diff --git a/Binary to Decimal.java b/Binary to Decimal.java\n--- a/Binary to Decimal.java\n+++ b/Binary to Decimal.java\n@@ -0,0 +1,19 @@\n+#import java.util.*;\n+class Binary_Decimal\n+{\n+  public static void main(String args[])\n+  {\n+    Scanner sc=new Scanner(System.in);\n+    int n,k,d,s=0,c=0;\n+    n=sc.nextInt();\n+    k=n;\n+    while(k!=0)\n+    {\n+      d=k%10;\n+      s+=d*(int)Math.pow(2,c++);\n+      k/=10;\n+    }\n+    System.out.println(\"Binary number:\"+n);\n+    System.out.println(\"Decimal equivalent:\"+s);\n+  }\n+}",
    "output": "Add Binary to Decimal conversion"
  },
  {
    "input": "diff --git a/Decimal to Binary.java b/Decimal to Binary.java\n--- a/Decimal to Binary.java\n+++ b/Decimal to Binary.java\n@@ -0,0 +1,19 @@\n+#import java.util.*;\n+class Decimal_Binary\n+{\n+  public static void main(String args[])\n+  {\n+    Scanner sc=new Scanner(System.in);\n+    int n,k,s=0,c=0,d;\n+    n=sc.nextInt();\n+    k=n;\n+    while(k!=0)\n+    {\n+      d=k%2;\n+      s=s+d*(int)Math.pow(10,c++);\n+      k/=2;\n+    }//converting decimal to binary\n+    System.out.println(\"Decimal number:\"+n);\n+    System.out.println(\"Binary equivalent:\"+s);\n+  }\n+}",
    "output": "Add decimal to binary conversion"
  },
  {
    "input": "diff --git a/data_structures/heaps/MaxHeap.java b/data_structures/heaps/MaxHeap.java\n--- a/data_structures/heaps/MaxHeap.java\n+++ b/data_structures/heaps/MaxHeap.java\n@@ -84,6 +84,7 @@ public void insertElement(HeapElement element) {\n \n     @Override\n     public void deleteElement(int elementIndex) {\n+\t\tif (isempty(maxHeap)) throw new EmptyHeapException(\"Attempt to delete an element from an empty heap\");\n         if ((elementIndex > maxHeap.size()) && (elementIndex <= 0)) throw new IndexOutOfBoundsException(\"Index out of heap range\");\n         // The last element in heap replaces the one to be deleted\n         maxHeap.set(elementIndex - 1, getElement(maxHeap.size()));\n\ndiff --git a/data_structures/heaps/MinHeap.java b/data_structures/heaps/MinHeap.java\n--- a/data_structures/heaps/MinHeap.java\n+++ b/data_structures/heaps/MinHeap.java\n@@ -87,6 +87,7 @@ public void insertElement(HeapElement element) {\n \n     @Override\n     public void deleteElement(int elementIndex) {\n+\t\tif (isempty(maxHeap)) throw new EmptyHeapException(\"Attempt to delete an element from an empty heap\");\n         if ((elementIndex > minHeap.size()) && (elementIndex <= 0)) throw new IndexOutOfBoundsException(\"Index out of heap range\");\n         // The last element in heap replaces the one to be deleted\n         minHeap.set(elementIndex - 1, getElement(minHeap.size()));",
    "output": "Add exception throws in case of handling empty heap"
  },
  {
    "input": "diff --git a/FindingPrimes.java b/FindingPrimes.java\n--- a/FindingPrimes.java\n+++ b/FindingPrimes.java\n@@ -0,0 +1,30 @@\n+/*\n+ * The Sieve of Eratosthenes is an algorithm used to find prime numbers, up to a given value.\n+ * Illustration: https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif\n+*/\n+public class FindingPrimes{\n+\tpublic static void main(String args[]){\n+\t\tSOE(20); //Example: Finds all the primes up to 20\n+\t}\n+\n+\tpublic static void SOE(int n){\n+\t\tboolean sieve[] = new boolean[n];\n+\n+\t\tint check = (int)Math.round(Math.sqrt(n)); //No need to check for multiples past the square root of n\n+\n+\t\tsieve[0] = false;\n+\t\tsieve[1] = false;\n+\t\tfor(int i = 2; i < n; i++)\n+\t\t\tsieve[i] = true; //Set every index to true except index 0 and 1\n+\n+\t\tfor(int i = 2; i< check; i++){\n+\t\t\tif(sieve[i]==true)\t\t\t\t\t//If i is a prime\n+\t\t\t\tfor(int j = i+i; j < n; j+=i)   //Step through the array in increments of i(the multiples of the prime)\n+\t\t\t\t\tsieve[j] = false;\t\t\t//Set every multiple of i to false\n+\t\t}\n+\t\tfor(int i = 0; i< n; i++){\n+\t\t\tif(sieve[i]==true)\n+\t\t\t\tSystem.out.print(i+\" \"); //In this example it will print 2 3 5 7 11 13 17 19\n+\t\t}\n+\t}\n+}\n\\ No newline at end of file",
    "output": "Add Sieve of Eratosthenes algorithm for finding primes"
  }
]