[
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/time_complexity.java b/codes/java/chapter_computational_complexity/time_complexity.java\n--- a/codes/java/chapter_computational_complexity/time_complexity.java\n+++ b/codes/java/chapter_computational_complexity/time_complexity.java\n@@ -87,7 +87,7 @@ static int expRecur(int n) {\n     }\n \n     /* 对数阶（循环实现） */\n-    static int logarithmic(float n) {\n+    static int logarithmic(int n) {\n         int count = 0;\n         while (n > 1) {\n             n = n / 2;\n@@ -97,14 +97,14 @@ static int logarithmic(float n) {\n     }\n \n     /* 对数阶（递归实现） */\n-    static int logRecur(float n) {\n+    static int logRecur(int n) {\n         if (n <= 1)\n             return 0;\n         return logRecur(n / 2) + 1;\n     }\n \n     /* 线性对数阶 */\n-    static int linearLogRecur(float n) {\n+    static int linearLogRecur(int n) {\n         if (n <= 1)\n             return 1;\n         int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n@@ -153,12 +153,12 @@ public static void main(String[] args) {\n         count = expRecur(n);\n         System.out.println(\"指数阶（递归实现）的操作数量 = \" + count);\n \n-        count = logarithmic((float) n);\n+        count = logarithmic(n);\n         System.out.println(\"对数阶（循环实现）的操作数量 = \" + count);\n-        count = logRecur((float) n);\n+        count = logRecur(n);\n         System.out.println(\"对数阶（递归实现）的操作数量 = \" + count);\n \n-        count = linearLogRecur((float) n);\n+        count = linearLogRecur(n);\n         System.out.println(\"线性对数阶（递归实现）的操作数量 = \" + count);\n \n         count = factorialRecur(n);",
    "output": "Fix Use int instead of float for the example code of log time complexity"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/quick_sort.java b/codes/java/chapter_sorting/quick_sort.java\n--- a/codes/java/chapter_sorting/quick_sort.java\n+++ b/codes/java/chapter_sorting/quick_sort.java\n@@ -56,14 +56,12 @@ static void swap(int[] nums, int i, int j) {\n \n     /* 选取三个候选元素的中位数 */\n     static int medianThree(int[] nums, int left, int mid, int right) {\n-        // 此处使用异或运算来简化代码\n-        // 异或规则为 0 ^ 0 = 1 ^ 1 = 0, 0 ^ 1 = 1 ^ 0 = 1\n-        if ((nums[left] < nums[mid]) ^ (nums[left] < nums[right]))\n-            return left;\n-        else if ((nums[mid] < nums[left]) ^ (nums[mid] < nums[right]))\n-            return mid;\n-        else\n-            return right;\n+        int l = nums[left], m = nums[mid], r = nums[right];\n+        if ((l <= m && m <= r) || (r <= m && m <= l))\n+            return mid; // m 在 l 和 r 之间\n+        if ((m <= l && l <= r) || (r <= l && l <= m))\n+            return left; // l 在 m 和 r 之间\n+        return right;\n     }\n \n     /* 哨兵划分（三数取中值） */",
    "output": "Fix the median_three mehod for quick sort\n\n* Add the section of terminologies.\r\n\r\n* fix format\r\n\r\n* Fix median_three function for quick sort\r\n\r\n* Delete docs/chapter_appendix/terminologies.md\r\n\r\n* Update quick_sort.ts\r\n\r\n* Update quick_sort.rs\r\n\r\n* Update quick_sort.js"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/array_binary_tree.java b/codes/java/chapter_tree/array_binary_tree.java\n--- a/codes/java/chapter_tree/array_binary_tree.java\n+++ b/codes/java/chapter_tree/array_binary_tree.java\n@@ -63,15 +63,15 @@ private void dfs(Integer i, String order, List<Integer> res) {\n         if (val(i) == null)\n             return;\n         // 前序遍历\n-        if (order == \"pre\")\n+        if (\"pre\".equals(order))\n             res.add(val(i));\n         dfs(left(i), order, res);\n         // 中序遍历\n-        if (order == \"in\")\n+        if (\"in\".equals(order))\n             res.add(val(i));\n         dfs(right(i), order, res);\n         // 后序遍历\n-        if (order == \"post\")\n+        if (\"post\".equals(order))\n             res.add(val(i));\n     }\n ",
    "output": "Fix Use .equals() to compare two strings in Java"
  },
  {
    "input": "diff --git a/codes/java/chapter_dynamic_programming/min_path_sum.java b/codes/java/chapter_dynamic_programming/min_path_sum.java\n--- a/codes/java/chapter_dynamic_programming/min_path_sum.java\n+++ b/codes/java/chapter_dynamic_programming/min_path_sum.java\n@@ -20,8 +20,8 @@ static int minPathSumDFS(int[][] grid, int i, int j) {\n             return Integer.MAX_VALUE;\n         }\n         // 计算从左上角到 (i-1, j) 和 (i, j-1) 的最小路径代价\n-        int left = minPathSumDFS(grid, i - 1, j);\n-        int up = minPathSumDFS(grid, i, j - 1);\n+        int up = minPathSumDFS(grid, i - 1, j);\n+        int left = minPathSumDFS(grid, i, j - 1);\n         // 返回从左上角到 (i, j) 的最小路径代价\n         return Math.min(left, up) + grid[i][j];\n     }\n@@ -41,8 +41,8 @@ static int minPathSumDFSMem(int[][] grid, int[][] mem, int i, int j) {\n             return mem[i][j];\n         }\n         // 左边和上边单元格的最小路径代价\n-        int left = minPathSumDFSMem(grid, mem, i - 1, j);\n-        int up = minPathSumDFSMem(grid, mem, i, j - 1);\n+        int up = minPathSumDFSMem(grid, mem, i - 1, j);\n+        int left = minPathSumDFSMem(grid, mem, i, j - 1);\n         // 记录并返回左上角到 (i, j) 的最小路径代价\n         mem[i][j] = Math.min(left, up) + grid[i][j];\n         return mem[i][j];",
    "output": "Fix the code in min_path_sum"
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/time_complexity.java b/codes/java/chapter_computational_complexity/time_complexity.java\n--- a/codes/java/chapter_computational_complexity/time_complexity.java\n+++ b/codes/java/chapter_computational_complexity/time_complexity.java\n@@ -107,8 +107,7 @@ static int logRecur(float n) {\n     static int linearLogRecur(float n) {\n         if (n <= 1)\n             return 1;\n-        int count = linearLogRecur(n / 2) +\n-                linearLogRecur(n / 2);\n+        int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n         for (int i = 0; i < n; i++) {\n             count++;\n         }",
    "output": "Fix Polishing code format on linearLogRecur, convert String type to string"
  },
  {
    "input": "diff --git a/codes/java/chapter_divide_and_conquer/build_tree.java b/codes/java/chapter_divide_and_conquer/build_tree.java\n--- a/codes/java/chapter_divide_and_conquer/build_tree.java\n+++ b/codes/java/chapter_divide_and_conquer/build_tree.java\n@@ -11,30 +11,30 @@\n \n public class build_tree {\n     /* 构建二叉树：分治 */\n-    static TreeNode dfs(int[] preorder, int[] inorder, Map<Integer, Integer> hmap, int i, int l, int r) {\n+    static TreeNode dfs(int[] preorder, Map<Integer, Integer> inorderMap, int i, int l, int r) {\n         // 子树区间为空时终止\n         if (r - l < 0)\n             return null;\n         // 初始化根节点\n         TreeNode root = new TreeNode(preorder[i]);\n         // 查询 m ，从而划分左右子树\n-        int m = hmap.get(preorder[i]);\n+        int m = inorderMap.get(preorder[i]);\n         // 子问题：构建左子树\n-        root.left = dfs(preorder, inorder, hmap, i + 1, l, m - 1);\n+        root.left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n         // 子问题：构建右子树\n-        root.right = dfs(preorder, inorder, hmap, i + 1 + m - l, m + 1, r);\n+        root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n         // 返回根节点\n         return root;\n     }\n \n     /* 构建二叉树 */\n     static TreeNode buildTree(int[] preorder, int[] inorder) {\n         // 初始化哈希表，存储 inorder 元素到索引的映射\n-        Map<Integer, Integer> hmap = new HashMap<>();\n+        Map<Integer, Integer> inorderMap = new HashMap<>();\n         for (int i = 0; i < inorder.length; i++) {\n-            hmap.put(inorder[i], i);\n+            inorderMap.put(inorder[i], i);\n         }\n-        TreeNode root = dfs(preorder, inorder, hmap, 0, 0, inorder.length - 1);\n+        TreeNode root = dfs(preorder, inorderMap, 0, 0, inorder.length - 1);\n         return root;\n     }\n ",
    "output": "Fix build_tree, binary_search_tree.cs fix two figures"
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/iteration.java b/codes/java/chapter_computational_complexity/iteration.java\n--- a/codes/java/chapter_computational_complexity/iteration.java\n+++ b/codes/java/chapter_computational_complexity/iteration.java\n@@ -8,7 +8,7 @@\n \n public class iteration {\n     /* for 循环 */\n-    public static int forLoop(int n) {\n+    static int forLoop(int n) {\n         int res = 0;\n         // 循环求和 1, 2, ..., n-1, n\n         for (int i = 1; i <= n; i++) {\n@@ -18,7 +18,7 @@ public static int forLoop(int n) {\n     }\n \n     /* while 循环 */\n-    public static int whileLoop(int n) {\n+    static int whileLoop(int n) {\n         int res = 0;\n         int i = 1; // 初始化条件变量\n         // 循环求和 1, 2, ..., n-1, n\n@@ -30,7 +30,7 @@ public static int whileLoop(int n) {\n     }\n \n     /* while 循环（两次更新） */\n-    public static int whileLoopII(int n) {\n+    static int whileLoopII(int n) {\n         int res = 0;\n         int i = 1; // 初始化条件变量\n         // 循环求和 1, 4, ...\n@@ -44,7 +44,7 @@ public static int whileLoopII(int n) {\n     }\n \n     /* 双层 for 循环 */\n-    public static String nestedForLoop(int n) {\n+    static String nestedForLoop(int n) {\n         StringBuilder res = new StringBuilder();\n         // 循环 i = 1, 2, ..., n-1, n\n         for (int i = 1; i <= n; i++) {\n\ndiff --git a/codes/java/chapter_computational_complexity/recursion.java b/codes/java/chapter_computational_complexity/recursion.java\n--- a/codes/java/chapter_computational_complexity/recursion.java\n+++ b/codes/java/chapter_computational_complexity/recursion.java\n@@ -6,9 +6,11 @@\n \n package chapter_computational_complexity;\n \n+import java.util.Stack;\n+\n public class recursion {\n     /* 递归 */\n-    public static int recur(int n) {\n+    static int recur(int n) {\n         // 终止条件\n         if (n == 1)\n             return 1;\n@@ -18,8 +20,27 @@ public static int recur(int n) {\n         return n + res;\n     }\n \n+    /* 使用迭代模拟递归 */\n+    static int forLoopRecur(int n) {\n+        // 使用一个显式的栈来模拟系统调用栈\n+        Stack<Integer> stack = new Stack<>();\n+        int res = 0;\n+        // 递：递归调用\n+        for (int i = n; i > 0; i--) {\n+            // 通过“入栈操作”模拟“递”\n+            stack.push(i);\n+        }\n+        // 归：返回结果\n+        while (!stack.isEmpty()) {\n+            // 通过“出栈操作”模拟“归”\n+            res += stack.pop();\n+        }\n+        // res = 1+2+3+...+n\n+        return res;\n+    }\n+\n     /* 尾递归 */\n-    public static int tailRecur(int n, int res) {\n+    static int tailRecur(int n, int res) {\n         // 终止条件\n         if (n == 0)\n             return res;\n@@ -28,7 +49,7 @@ public static int tailRecur(int n, int res) {\n     }\n \n     /* 斐波那契数列：递归 */\n-    public static int fib(int n) {\n+    static int fib(int n) {\n         // 终止条件 f(1) = 0, f(2) = 1\n         if (n == 1 || n == 2)\n             return n - 1;\n@@ -46,6 +67,9 @@ public static void main(String[] args) {\n         res = recur(n);\n         System.out.println(\"\\n递归函数的求和结果 res = \" + res);\n \n+        res = forLoopRecur(n);\n+        System.out.println(\"\\n使用迭代模拟递归求和结果 res = \" + res);\n+\n         res = tailRecur(n, 0);\n         System.out.println(\"\\n尾递归函数的求和结果 res = \" + res);\n ",
    "output": "Add comparison between iteration and recursion.\nFix the figure of tail recursion.\nFix two links"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n--- a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n+++ b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n@@ -24,8 +24,6 @@ static void preOrder(TreeNode root) {\n         if (root.val == 7) {\n             // 记录解\n             res.add(new ArrayList<>(path));\n-            path.remove(path.size() - 1);\n-            return;\n         }\n         preOrder(root.left);\n         preOrder(root.right);",
    "output": "Fix preorder_traversal_iii_compact code"
  },
  {
    "input": "diff --git a/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java b/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java\n--- a/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java\n+++ b/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java\n@@ -10,7 +10,7 @@ public class climbing_stairs_constraint_dp {\n     /* 带约束爬楼梯：动态规划 */\n     static int climbingStairsConstraintDP(int n) {\n         if (n == 1 || n == 2) {\n-            return n;\n+            return 1;\n         }\n         // 初始化 dp 表，用于存储子问题的解\n         int[][] dp = new int[n + 1][3];",
    "output": "Fix climbing_stairs_constraint_dp code"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -6,36 +6,23 @@\n \n package chapter_tree;\n \n-import java.util.*;\n import utils.*;\n \n /* 二叉搜索树 */\n class BinarySearchTree {\n     private TreeNode root;\n \n-    public BinarySearchTree(int[] nums) {\n-        Arrays.sort(nums); // 排序数组\n-        root = buildTree(nums, 0, nums.length - 1); // 构建二叉搜索树\n+    /* 构造方法 */\n+    public BinarySearchTree() {\n+        // 初始化空树\n+        root = null;\n     }\n \n     /* 获取二叉树根节点 */\n     public TreeNode getRoot() {\n         return root;\n     }\n \n-    /* 构建二叉搜索树 */\n-    public TreeNode buildTree(int[] nums, int i, int j) {\n-        if (i > j)\n-            return null;\n-        // 将数组中间节点作为根节点\n-        int mid = (i + j) / 2;\n-        TreeNode root = new TreeNode(nums[mid]);\n-        // 递归建立左子树和右子树\n-        root.left = buildTree(nums, i, mid - 1);\n-        root.right = buildTree(nums, mid + 1, j);\n-        return root;\n-    }\n-\n     /* 查找节点 */\n     public TreeNode search(int num) {\n         TreeNode cur = root;\n@@ -57,9 +44,11 @@ else if (cur.val > num)\n \n     /* 插入节点 */\n     public void insert(int num) {\n-        // 若树为空，直接提前返回\n-        if (root == null)\n+        // 若树为空，则初始化根节点\n+        if (root == null) {\n+            root = new TreeNode(num);\n             return;\n+        }\n         TreeNode cur = root, pre = null;\n         // 循环查找，越过叶节点后跳出\n         while (cur != null) {\n@@ -137,8 +126,12 @@ public void remove(int num) {\n public class binary_search_tree {\n     public static void main(String[] args) {\n         /* 初始化二叉搜索树 */\n-        int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n-        BinarySearchTree bst = new BinarySearchTree(nums);\n+        BinarySearchTree bst = new BinarySearchTree();\n+        // 请注意，不同的插入顺序会生成不同的二叉树，该序列可以生成一个完美二叉树\n+        int[] nums = { 8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15 };\n+        for (int num : nums) {\n+            bst.insert(num);\n+        }\n         System.out.println(\"\\n初始化的二叉树为\\n\");\n         PrintUtil.printTree(bst.getRoot());\n ",
    "output": "Fix binary_search_tree code"
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/iteration.java b/codes/java/chapter_computational_complexity/iteration.java\n--- a/codes/java/chapter_computational_complexity/iteration.java\n+++ b/codes/java/chapter_computational_complexity/iteration.java\n@@ -0,0 +1,76 @@\n+/**\n+ * File: iteration.java\n+ * Created Time: 2023-08-24\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_computational_complexity;\n+\n+public class iteration {\n+    /* for 循环 */\n+    public static int forLoop(int n) {\n+        int res = 0;\n+        // 循环求和 1, 2, ..., n-1, n\n+        for (int i = 1; i <= n; i++) {\n+            res += i;\n+        }\n+        return res;\n+    }\n+\n+    /* while 循环 */\n+    public static int whileLoop(int n) {\n+        int res = 0;\n+        int i = 1; // 初始化条件变量\n+        // 循环求和 1, 2, ..., n-1, n\n+        while (i <= n) {\n+            res += i;\n+            i += 1; // 更新条件变量\n+        }\n+        return res;\n+    }\n+\n+    /* while 循环（两次更新） */\n+    public static int whileLoopII(int n) {\n+        int res = 0;\n+        int i = 1; // 初始化条件变量\n+        // 循环求和 1, 2, 4, 5...\n+        while (i <= n) {\n+            res += i;\n+            i += 1; // 更新条件变量\n+            res += i;\n+            i *= 2; // 更新条件变量\n+        }\n+        return res;\n+    }\n+\n+    /* 双层 for 循环 */\n+    public static String nestedForLoop(int n) {\n+        StringBuilder res = new StringBuilder();\n+        // 循环 i = 1, 2, ..., n-1, n\n+        for (int i = 1; i <= n; i++) {\n+            // 循环 j = 1, 2, ..., n-1, n\n+            for (int j = 1; j <= n; j++) {\n+                res.append(\"(\" + i + \", \" + j + \"), \");\n+            }\n+        }\n+        return res.toString();\n+    }\n+\n+    /* Driver Code */\n+    public static void main(String[] args) {\n+        int n = 5;\n+        int res;\n+\n+        res = forLoop(n);\n+        System.out.println(\"\\nfor 循环的求和结果 res = \" + res);\n+\n+        res = whileLoop(n);\n+        System.out.println(\"\\nwhile 循环的求和结果 res = \" + res);\n+\n+        res = whileLoopII(n);\n+        System.out.println(\"\\nwhile 循环（两次更新）求和结果 res = \" + res);\n+\n+        String resStr = nestedForLoop(n);\n+        System.out.println(\"\\n双层 for 循环的遍历结果 \" + resStr);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_computational_complexity/recursion.java b/codes/java/chapter_computational_complexity/recursion.java\n--- a/codes/java/chapter_computational_complexity/recursion.java\n+++ b/codes/java/chapter_computational_complexity/recursion.java\n@@ -0,0 +1,55 @@\n+/**\n+ * File: recursion.java\n+ * Created Time: 2023-08-24\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_computational_complexity;\n+\n+public class recursion {\n+    /* 递归 */\n+    public static int recur(int n) {\n+        // 终止条件\n+        if (n == 1)\n+            return 1;\n+        // 递：递归调用\n+        int res = recur(n - 1);\n+        // 归：返回结果\n+        return n + res;\n+    }\n+\n+    /* 尾递归 */\n+    public static int tailRecur(int n, int res) {\n+        // 终止条件\n+        if (n == 0)\n+            return res;\n+        // 尾递归调用\n+        return tailRecur(n - 1, res + n);\n+    }\n+\n+    /* 斐波那契数列：递归 */\n+    public static int fib(int n) {\n+        // 终止条件 f(1) = 0, f(2) = 1\n+        if (n == 1 || n == 2)\n+            return n - 1;\n+        // 递归调用 f(n) = f(n-1) + f(n-2)\n+        int res = fib(n - 1) + fib(n - 2);\n+        // 返回结果 f(n)\n+        return res;\n+    }\n+\n+    /* Driver Code */\n+    public static void main(String[] args) {\n+        int n = 5;\n+        int res;\n+\n+        res = recur(n);\n+        System.out.println(\"\\n递归函数的求和结果 res = \" + res);\n+\n+        res = tailRecur(n, 0);\n+        System.out.println(\"\\n尾递归函数的求和结果 res = \" + res);\n+\n+        res = fib(n);\n+        System.out.println(\"\\n斐波那契数列的第 \" + n + \" 项为 \" + res);\n+    }\n+}",
    "output": "Add the section of iteration and recursion"
  },
  {
    "input": "diff --git a/codes/java/chapter_greedy/coin_change_greedy.java b/codes/java/chapter_greedy/coin_change_greedy.java\n--- a/codes/java/chapter_greedy/coin_change_greedy.java\n+++ b/codes/java/chapter_greedy/coin_change_greedy.java\n@@ -17,7 +17,7 @@ static int coinChangeGreedy(int[] coins, int amt) {\n         // 循环进行贪心选择，直到无剩余金额\n         while (amt > 0) {\n             // 找到小于且最接近剩余金额的硬币\n-            while (coins[i] > amt) {\n+            while (i > 0 && coins[i] > amt) {\n                 i--;\n             }\n             // 选择 coins[i]\n\ndiff --git a/codes/java/chapter_heap/top_k.java b/codes/java/chapter_heap/top_k.java\n--- a/codes/java/chapter_heap/top_k.java\n+++ b/codes/java/chapter_heap/top_k.java\n@@ -15,14 +15,14 @@ static Queue<Integer> topKHeap(int[] nums, int k) {\n         Queue<Integer> heap = new PriorityQueue<Integer>();\n         // 将数组的前 k 个元素入堆\n         for (int i = 0; i < k; i++) {\n-            heap.add(nums[i]);\n+            heap.offer(nums[i]);\n         }\n         // 从第 k+1 个元素开始，保持堆的长度为 k\n         for (int i = k; i < nums.length; i++) {\n             // 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆\n             if (nums[i] > heap.peek()) {\n                 heap.poll();\n-                heap.add(nums[i]);\n+                heap.offer(nums[i]);\n             }\n         }\n         return heap;",
    "output": "Fix the content"
  },
  {
    "input": "diff --git a/codes/java/chapter_searching/binary_search_edge.java b/codes/java/chapter_searching/binary_search_edge.java\n--- a/codes/java/chapter_searching/binary_search_edge.java\n+++ b/codes/java/chapter_searching/binary_search_edge.java\n@@ -1,56 +1,49 @@\n /**\n  * File: binary_search_edge.java\n- * Created Time: 2023-05-21\n+ * Created Time: 2023-08-04\n  * Author: Krahets (krahets@163.com)\n  */\n \n package chapter_searching;\n \n public class binary_search_edge {\n-    /* 二分查找最左一个元素 */\n+    /* 二分查找最左一个 target */\n     static int binarySearchLeftEdge(int[] nums, int target) {\n-        int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]\n-        while (i <= j) {\n-            int m = i + (j - i) / 2; // 计算中点索引 m\n-            if (nums[m] < target)\n-                i = m + 1; // target 在区间 [m+1, j] 中\n-            else if (nums[m] > target)\n-                j = m - 1; // target 在区间 [i, m-1] 中\n-            else\n-                j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中\n+        // 等价于查找 target 的插入点\n+        int i = binary_search_insertion.binarySearchInsertion(nums, target);\n+        // 未找到 target ，返回 -1\n+        if (i == nums.length || nums[i] != target) {\n+            return -1;\n         }\n-        if (i == nums.length || nums[i] != target)\n-            return -1; // 未找到目标元素，返回 -1\n+        // 找到 target ，返回索引 i\n         return i;\n     }\n \n-    /* 二分查找最右一个元素 */\n+    /* 二分查找最右一个 target */\n     static int binarySearchRightEdge(int[] nums, int target) {\n-        int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]\n-        while (i <= j) {\n-            int m = i + (j - i) / 2; // 计算中点索引 m\n-            if (nums[m] < target)\n-                i = m + 1; // target 在区间 [m+1, j] 中\n-            else if (nums[m] > target)\n-                j = m - 1; // target 在区间 [i, m-1] 中\n-            else\n-                i = m + 1; // 首个大于 target 的元素在区间 [m+1, j] 中\n+        // 转化为查找最左一个 target + 1\n+        int i = binary_search_insertion.binarySearchInsertion(nums, target + 1);\n+        // j 指向最右一个 target ，i 指向首个大于 target 的元素\n+        int j = i - 1;\n+        // 未找到 target ，返回 -1\n+        if (j == -1 || nums[j] != target) {\n+            return -1;\n         }\n-        if (j < 0 || nums[j] != target)\n-            return -1; // 未找到目标元素，返回 -1\n+        // 找到 target ，返回索引 j\n         return j;\n     }\n \n     public static void main(String[] args) {\n-        int target = 6;\n+        // 包含重复元素的数组\n         int[] nums = { 1, 3, 6, 6, 6, 6, 6, 10, 12, 15 };\n+        System.out.println(\"\\n数组 nums = \" + java.util.Arrays.toString(nums));\n \n-        // 二分查找最左一个元素\n-        int indexLeft = binarySearchLeftEdge(nums, target);\n-        System.out.println(\"数组中最左一个元素 6 的索引 = \" + indexLeft);\n-\n-        // 二分查找最右一个元素\n-        int indexRight = binarySearchRightEdge(nums, target);\n-        System.out.println(\"数组中最右一个元素 6 的索引 = \" + indexRight);\n+        // 二分查找左边界和右边界\n+        for (int target : new int[] { 6, 7 }) {\n+            int index = binarySearchLeftEdge(nums, target);\n+            System.out.println(\"最左一个元素 \" + target + \" 的索引为 \" + index);\n+            index = binarySearchRightEdge(nums, target);\n+            System.out.println(\"最右一个元素 \" + target + \" 的索引为 \" + index);\n+        }\n     }\n }\n\ndiff --git a/codes/java/chapter_searching/binary_search_insertion.java b/codes/java/chapter_searching/binary_search_insertion.java\n--- a/codes/java/chapter_searching/binary_search_insertion.java\n+++ b/codes/java/chapter_searching/binary_search_insertion.java\n@@ -0,0 +1,63 @@\n+/**\n+ * File: binary_search_edge.java\n+ * Created Time: 2023-08-04\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_searching;\n+\n+class binary_search_insertion {\n+    /* 二分查找插入点（无重复元素） */\n+    static int binarySearchInsertionSimple(int[] nums, int target) {\n+        int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]\n+        while (i <= j) {\n+            int m = i + (j - i) / 2; // 计算中点索引 m\n+            if (nums[m] < target) {\n+                i = m + 1; // target 在区间 [m+1, j] 中\n+            } else if (nums[m] > target) {\n+                j = m - 1; // target 在区间 [i, m-1] 中\n+            } else {\n+                return m; // 找到 target ，返回插入点 m\n+            }\n+        }\n+        // 未找到 target ，返回插入点 i\n+        return i;\n+    }\n+\n+    /* 二分查找插入点（存在重复元素） */\n+    static int binarySearchInsertion(int[] nums, int target) {\n+        int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]\n+        while (i <= j) {\n+            int m = i + (j - i) / 2; // 计算中点索引 m\n+            if (nums[m] < target) {\n+                i = m + 1; // target 在区间 [m+1, j] 中\n+            } else if (nums[m] > target) {\n+                j = m - 1; // target 在区间 [i, m-1] 中\n+            } else {\n+                j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中\n+            }\n+        }\n+        // 返回插入点 i\n+        return i;\n+    }\n+\n+    public static void main(String[] args) {\n+        // 无重复元素的数组\n+        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 26, 31, 35 };\n+        System.out.println(\"\\n数组 nums = \" + java.util.Arrays.toString(nums));\n+        // 二分查找插入点\n+        for (int target : new int[] { 6, 9 }) {\n+            int index = binarySearchInsertionSimple(nums, target);\n+            System.out.println(\"元素 \" + target + \" 的插入点的索引为 \" + index);\n+        }\n+\n+        // 包含重复元素的数组\n+        nums = new int[] { 1, 3, 6, 6, 6, 6, 6, 10, 12, 15 };\n+        System.out.println(\"\\n数组 nums = \" + java.util.Arrays.toString(nums));\n+        // 二分查找插入点\n+        for (int target : new int[] { 2, 6, 20 }) {\n+            int index = binarySearchInsertion(nums, target);\n+            System.out.println(\"元素 \" + target + \" 的插入点的索引为 \" + index);\n+        }\n+    }\n+}",
    "output": "Add the section of binary search insertion.\n\nRefactor the section of binary search edge.\r\nFinetune the figures of binary search"
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/hash_map_chaining.java b/codes/java/chapter_hashing/hash_map_chaining.java\n--- a/codes/java/chapter_hashing/hash_map_chaining.java\n+++ b/codes/java/chapter_hashing/hash_map_chaining.java\n@@ -80,10 +80,12 @@ void remove(int key) {\n         List<Pair> bucket = buckets.get(index);\n         // 遍历桶，从中删除键值对\n         for (Pair pair : bucket) {\n-            if (pair.key == key)\n+            if (pair.key == key) {\n                 bucket.remove(pair);\n+                size--;\n+                break;\n+            }\n         }\n-        size--;\n     }\n \n     /* 扩容哈希表 */",
    "output": "Fix the code of hash map chaining"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n--- a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n+++ b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n@@ -24,6 +24,7 @@ static void preOrder(TreeNode root) {\n         if (root.val == 7) {\n             // 记录解\n             res.add(new ArrayList<>(path));\n+            path.remove(path.size() - 1);\n             return;\n         }\n         preOrder(root.left);\n@@ -42,7 +43,7 @@ public static void main(String[] args) {\n         res = new ArrayList<>();\n         preOrder(root);\n \n-        System.out.println(\"\\n输出所有根节点到节点 7 的路径，且路径中不包含值为 3 的节点\");\n+        System.out.println(\"\\n输出所有根节点到节点 7 的路径，路径中不包含值为 3 的节点，仅包含一个值为 7 的节点\");\n         for (List<TreeNode> path : res) {\n             List<Integer> vals = new ArrayList<>();\n             for (TreeNode node : path) {",
    "output": "Fix the code of preorder_traversal_iii_compact"
  },
  {
    "input": "diff --git a/codes/java/chapter_greedy/max_product_cutting.java b/codes/java/chapter_greedy/max_product_cutting.java\n--- a/codes/java/chapter_greedy/max_product_cutting.java\n+++ b/codes/java/chapter_greedy/max_product_cutting.java\n@@ -0,0 +1,40 @@\n+/**\n+ * File: max_product_cutting.java\n+ * Created Time: 2023-07-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_greedy;\n+\n+import java.lang.Math;\n+\n+public class max_product_cutting {\n+    /* 最大切分乘积：贪心 */\n+    public static int maxProductCutting(int n) {\n+        // 当 n <= 3 时，必须切分出一个 1\n+        if (n <= 3) {\n+            return 1 * (n - 1);\n+        }\n+        // 贪心地切分出 3 ，a 为 3 的个数，b 为余数\n+        int a = n / 3;\n+        int b = n % 3;\n+        if (b == 1) {\n+            // 当余数为 1 时，将一对 1 * 3 转化为 2 * 2\n+            return (int) Math.pow(3, a - 1) * 2 * 2;\n+        }\n+        if (b == 2) {\n+            // 当余数为 2 时，不做处理\n+            return (int) Math.pow(3, a) * 2;\n+        }\n+        // 当余数为 0 时，不做处理\n+        return (int) Math.pow(3, a);\n+    }\n+\n+    public static void main(String[] args) {\n+        int n = 58;\n+\n+        // 贪心算法\n+        int res = maxProductCutting(n);\n+        System.out.println(\"最大切分乘积为\" + res);\n+    }\n+}",
    "output": "Add the section of max product cutting problem"
  },
  {
    "input": "diff --git a/codes/java/chapter_greedy/max_capacity.java b/codes/java/chapter_greedy/max_capacity.java\n--- a/codes/java/chapter_greedy/max_capacity.java\n+++ b/codes/java/chapter_greedy/max_capacity.java\n@@ -0,0 +1,38 @@\n+/**\n+ * File: max_capacity.java\n+ * Created Time: 2023-07-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_greedy;\n+\n+public class max_capacity {\n+    /* 最大容量：贪心 */\n+    static int maxCapacity(int[] ht) {\n+        // 初始化 i, j 分列数组两端\n+        int i = 0, j = ht.length - 1;\n+        // 初始最大容量为 0\n+        int res = 0;\n+        // 循环贪心选择，直至两板相遇\n+        while (i < j) {\n+            // 更新最大容量\n+            int cap = Math.min(ht[i], ht[j]) * (j - i);\n+            res = Math.max(res, cap);\n+            // 向内移动短板\n+            if (ht[i] < ht[j]) {\n+                i++;\n+            } else {\n+                j--;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] ht = { 3, 8, 5, 2, 7, 7, 3, 4 };\n+\n+        // 贪心算法\n+        int res = maxCapacity(ht);\n+        System.out.println(\"最大容量为 \" + res);\n+    }\n+}",
    "output": "Add the section of max capacity problem"
  },
  {
    "input": "diff --git a/codes/java/chapter_greedy/coin_change_greedy.java b/codes/java/chapter_greedy/coin_change_greedy.java\n--- a/codes/java/chapter_greedy/coin_change_greedy.java\n+++ b/codes/java/chapter_greedy/coin_change_greedy.java\n@@ -0,0 +1,55 @@\n+/**\n+ * File: coin_change_greedy.java\n+ * Created Time: 2023-07-20\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_greedy;\n+\n+import java.util.Arrays;\n+\n+public class coin_change_greedy {\n+    /* 零钱兑换：贪心 */\n+    static int coinChangeGreedy(int[] coins, int amt) {\n+        // 假设 coins 列表有序\n+        int i = coins.length - 1;\n+        int count = 0;\n+        // 循环进行贪心选择，直到无剩余金额\n+        while (amt > 0) {\n+            // 找到小于且最接近剩余金额的硬币\n+            while (coins[i] > amt) {\n+                i--;\n+            }\n+            // 选择 coins[i]\n+            amt -= coins[i];\n+            count++;\n+        }\n+        // 若未找到可行方案，则返回 -1\n+        return amt == 0 ? count : -1;\n+    }\n+\n+    public static void main(String[] args) {\n+        // 贪心：能够保证找到全局最优解\n+        int[] coins = { 1, 5, 10, 20, 50, 100 };\n+        int amt = 186;\n+        int res = coinChangeGreedy(coins, amt);\n+        System.out.println(\"\\ncoins = \" + Arrays.toString(coins) + \", amt = \" + amt);\n+        System.out.println(\"凑到 \" + amt + \" 所需的最少硬币数量为 \" + res);\n+\n+        // 贪心：无法保证找到全局最优解\n+        coins = new int[] { 1, 20, 50 };\n+        amt = 60;\n+        res = coinChangeGreedy(coins, amt);\n+        System.out.println(\"\\ncoins = \" + Arrays.toString(coins) + \", amt = \" + amt);\n+        System.out.println(\"凑到 \" + amt + \" 所需的最少硬币数量为 \" + res);\n+        System.out.println(\"实际上需要的最少数量为 3 ，即 20 + 20 + 20\");\n+\n+        // 贪心：无法保证找到全局最优解\n+        coins = new int[] { 1, 49, 50 };\n+        amt = 98;\n+        res = coinChangeGreedy(coins, amt);\n+        System.out.println(\"\\ncoins = \" + Arrays.toString(coins) + \", amt = \" + amt);\n+        System.out.println(\"凑到 \" + amt + \" 所需的最少硬币数量为 \" + res);\n+        System.out.println(\"实际上需要的最少数量为 2 ，即 49 + 49\");\n+    }\n+}\n\ndiff --git a/codes/java/chapter_greedy/fractional_knapsack.java b/codes/java/chapter_greedy/fractional_knapsack.java\n--- a/codes/java/chapter_greedy/fractional_knapsack.java\n+++ b/codes/java/chapter_greedy/fractional_knapsack.java\n@@ -0,0 +1,59 @@\n+/**\n+ * File: fractional_knapsack.java\n+ * Created Time: 2023-07-20\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_greedy;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+/* 物品 */\n+class Item {\n+    int w; // 物品重量\n+    int v; // 物品价值\n+\n+    public Item(int w, int v) {\n+        this.w = w;\n+        this.v = v;\n+    }\n+}\n+\n+public class fractional_knapsack {\n+    /* 分数背包：贪心 */\n+    static double fractionalKnapsack(int[] wgt, int[] val, int cap) {\n+        // 创建物品列表，包含两个属性：重量、价值\n+        Item[] items = new Item[wgt.length];\n+        for (int i = 0; i < wgt.length; i++) {\n+            items[i] = new Item(wgt[i], val[i]);\n+        }\n+        // 按照单位价值 item.v / item.w 从高到低进行排序\n+        Arrays.sort(items, Comparator.comparingDouble(item -> -((double) item.v / item.w)));\n+        // 循环贪心选择\n+        double res = 0;\n+        for (Item item : items) {\n+            if (item.w <= cap) {\n+                // 若剩余容量充足，则将当前物品整个装进背包\n+                res += item.v;\n+                cap -= item.w;\n+            } else {\n+                // 若剩余容量不足，则将当前物品的一部分装进背包\n+                res += (double) item.v / item.w * cap;\n+                // 已无剩余容量，因此跳出循环\n+                break;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] wgt = { 10, 20, 30, 40, 50 };\n+        int[] val = { 50, 120, 150, 210, 240 };\n+        int cap = 50;\n+\n+        // 贪心算法\n+        double res = fractionalKnapsack(wgt, val, cap);\n+        System.out.println(\"不超过背包容量的最大物品价值为 \" + res);\n+    }\n+}",
    "output": "Add the chapter of greedy.\n\nAdd the section of fractional knapsack"
  },
  {
    "input": "diff --git a/codes/java/chapter_divide_and_conquer/binary_search_recur.java b/codes/java/chapter_divide_and_conquer/binary_search_recur.java\n--- a/codes/java/chapter_divide_and_conquer/binary_search_recur.java\n+++ b/codes/java/chapter_divide_and_conquer/binary_search_recur.java\n@@ -0,0 +1,45 @@\n+/**\n+ * File: binary_search_recur.java\n+ * Created Time: 2023-07-17\n+ * Author: krahets (krahets@163.com)\n+ */\n+\n+package chapter_divide_and_conquer;\n+\n+public class binary_search_recur {\n+    /* 二分查找：问题 f(i, j) */\n+    static int dfs(int[] nums, int target, int i, int j) {\n+        // 若区间为空，代表无目标元素，则返回 -1\n+        if (i > j) {\n+            return -1;\n+        }\n+        // 计算中点索引 m\n+        int m = (i + j) / 2;\n+        if (nums[m] < target) {\n+            // 递归子问题 f(m+1, j)\n+            return dfs(nums, target, m + 1, j);\n+        } else if (nums[m] > target) {\n+            // 递归子问题 f(i, m-1)\n+            return dfs(nums, target, i, m - 1);\n+        } else {\n+            // 找到目标元素，返回其索引\n+            return m;\n+        }\n+    }\n+\n+    /* 二分查找 */\n+    static int binarySearch(int[] nums, int target) {\n+        int n = nums.length;\n+        // 求解问题 f(0, n-1)\n+        return dfs(nums, target, 0, n - 1);\n+    }\n+\n+    public static void main(String[] args) {\n+        int target = 6;\n+        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 26, 31, 35 };\n+\n+        // 二分查找（双闭区间）\n+        int index = binarySearch(nums, target);\n+        System.out.println(\"目标元素 6 的索引 = \" + index);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_divide_and_conquer/build_tree.java b/codes/java/chapter_divide_and_conquer/build_tree.java\n--- a/codes/java/chapter_divide_and_conquer/build_tree.java\n+++ b/codes/java/chapter_divide_and_conquer/build_tree.java\n@@ -0,0 +1,51 @@\n+/**\n+ * File: build_tree.java\n+ * Created Time: 2023-07-17\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_divide_and_conquer;\n+\n+import utils.*;\n+import java.util.*;\n+\n+public class build_tree {\n+    /* 构建二叉树：分治 */\n+    static TreeNode dfs(int[] preorder, int[] inorder, Map<Integer, Integer> hmap, int i, int l, int r) {\n+        // 子树区间为空时终止\n+        if (r - l < 0)\n+            return null;\n+        // 初始化根节点\n+        TreeNode root = new TreeNode(preorder[i]);\n+        // 查询 m ，从而划分左右子树\n+        int m = hmap.get(preorder[i]);\n+        // 子问题：构建左子树\n+        root.left = dfs(preorder, inorder, hmap, i + 1, l, m - 1);\n+        // 子问题：构建右子树\n+        root.right = dfs(preorder, inorder, hmap, i + 1 + m - l, m + 1, r);\n+        // 返回根节点\n+        return root;\n+    }\n+\n+    /* 构建二叉树 */\n+    static TreeNode buildTree(int[] preorder, int[] inorder) {\n+        // 初始化哈希表，存储 inorder 元素到索引的映射\n+        Map<Integer, Integer> hmap = new HashMap<>();\n+        for (int i = 0; i < inorder.length; i++) {\n+            hmap.put(inorder[i], i);\n+        }\n+        TreeNode root = dfs(preorder, inorder, hmap, 0, 0, inorder.length - 1);\n+        return root;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] preorder = { 3, 9, 2, 1, 7 };\n+        int[] inorder = { 9, 3, 1, 2, 7 };\n+        System.out.println(\"前序遍历 = \" + Arrays.toString(preorder));\n+        System.out.println(\"中序遍历 = \" + Arrays.toString(inorder));\n+\n+        TreeNode root = buildTree(preorder, inorder);\n+        System.out.println(\"构建的二叉树为：\");\n+        PrintUtil.printTree(root);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_divide_and_conquer/hanota.java b/codes/java/chapter_divide_and_conquer/hanota.java\n--- a/codes/java/chapter_divide_and_conquer/hanota.java\n+++ b/codes/java/chapter_divide_and_conquer/hanota.java\n@@ -0,0 +1,59 @@\n+/**\n+ * File: hanota.java\n+ * Created Time: 2023-07-17\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_divide_and_conquer;\n+\n+import java.util.*;\n+\n+public class hanota {\n+    /* 移动一个圆盘 */\n+    static void move(List<Integer> src, List<Integer> tar) {\n+        // 从 src 顶部拿出一个圆盘\n+        Integer pan = src.remove(src.size() - 1);\n+        // 将圆盘放入 tar 顶部\n+        tar.add(pan);\n+    }\n+\n+    /* 求解汉诺塔：问题 f(i) */\n+    static void dfs(int i, List<Integer> src, List<Integer> buf, List<Integer> tar) {\n+        // 若 src 只剩下一个圆盘，则直接将其移到 tar\n+        if (i == 1) {\n+            move(src, tar);\n+            return;\n+        }\n+        // 子问题 f(i-1) ：将 src 顶部 i-1 个圆盘借助 tar 移到 buf\n+        dfs(i - 1, src, tar, buf);\n+        // 子问题 f(1) ：将 src 剩余一个圆盘移到 tar\n+        move(src, tar);\n+        // 子问题 f(i-1) ：将 buf 顶部 i-1 个圆盘借助 src 移到 tar\n+        dfs(i - 1, buf, src, tar);\n+    }\n+\n+    /* 求解汉诺塔 */\n+    static void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {\n+        int n = A.size();\n+        // 将 A 顶部 n 个圆盘借助 B 移到 C\n+        dfs(n, A, B, C);\n+    }\n+\n+    public static void main(String[] args) {\n+        // 列表尾部是柱子顶部\n+        List<Integer> A = new ArrayList<>(Arrays.asList(5, 4, 3, 2, 1));\n+        List<Integer> B = new ArrayList<>();\n+        List<Integer> C = new ArrayList<>();\n+        System.out.println(\"初始状态下：\");\n+        System.out.println(\"A = \" + A);\n+        System.out.println(\"B = \" + B);\n+        System.out.println(\"C = \" + C);\n+\n+        hanota(A, B, C);\n+\n+        System.out.println(\"圆盘移动完成后：\");\n+        System.out.println(\"A = \" + A);\n+        System.out.println(\"B = \" + B);\n+        System.out.println(\"C = \" + C);\n+    }\n+}",
    "output": "Add Java and C++ code for the chapter of\ndivide and conquer"
  },
  {
    "input": "diff --git a/codes/java/chapter_dynamic_programming/edit_distance.java b/codes/java/chapter_dynamic_programming/edit_distance.java\n--- a/codes/java/chapter_dynamic_programming/edit_distance.java\n+++ b/codes/java/chapter_dynamic_programming/edit_distance.java\n@@ -0,0 +1,139 @@\n+/**\n+ * File: edit_distance.java\n+ * Created Time: 2023-07-13\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_dynamic_programming;\n+\n+import java.util.Arrays;\n+\n+public class edit_distance {\n+    /* 编辑距离：暴力搜索 */\n+    static int editDistanceDFS(String s, String t, int i, int j) {\n+        // 若 s 和 t 都为空，则返回 0\n+        if (i == 0 && j == 0)\n+            return 0;\n+        // 若 s 为空，则返回 t 长度\n+        if (i == 0)\n+            return j;\n+        // 若 t 为空，则返回 s 长度\n+        if (j == 0)\n+            return i;\n+        // 若两字符相等，则直接跳过此两字符\n+        if (s.charAt(i - 1) == t.charAt(j - 1))\n+            return editDistanceDFS(s, t, i - 1, j - 1);\n+        // 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1\n+        int insert = editDistanceDFS(s, t, i, j - 1);\n+        int delete = editDistanceDFS(s, t, i - 1, j);\n+        int replace = editDistanceDFS(s, t, i - 1, j - 1);\n+        // 返回最少编辑步数\n+        return Math.min(Math.min(insert, delete), replace) + 1;\n+    }\n+\n+    /* 编辑距离：记忆化搜索 */\n+    static int editDistanceDFSMem(String s, String t, int[][] mem, int i, int j) {\n+        // 若 s 和 t 都为空，则返回 0\n+        if (i == 0 && j == 0)\n+            return 0;\n+        // 若 s 为空，则返回 t 长度\n+        if (i == 0)\n+            return j;\n+        // 若 t 为空，则返回 s 长度\n+        if (j == 0)\n+            return i;\n+        // 若已有记录，则直接返回之\n+        if (mem[i][j] != -1)\n+            return mem[i][j];\n+        // 若两字符相等，则直接跳过此两字符\n+        if (s.charAt(i - 1) == t.charAt(j - 1))\n+            return editDistanceDFSMem(s, t, mem, i - 1, j - 1);\n+        // 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1\n+        int insert = editDistanceDFSMem(s, t, mem, i, j - 1);\n+        int delete = editDistanceDFSMem(s, t, mem, i - 1, j);\n+        int replace = editDistanceDFSMem(s, t, mem, i - 1, j - 1);\n+        // 记录并返回最少编辑步数\n+        mem[i][j] = Math.min(Math.min(insert, delete), replace) + 1;\n+        return mem[i][j];\n+    }\n+\n+    /* 编辑距离：动态规划 */\n+    static int editDistanceDP(String s, String t) {\n+        int n = s.length(), m = t.length();\n+        int[][] dp = new int[n + 1][m + 1];\n+        // 状态转移：首行首列\n+        for (int i = 1; i <= n; i++) {\n+            dp[i][0] = i;\n+        }\n+        for (int j = 1; j <= m; j++) {\n+            dp[0][j] = j;\n+        }\n+        // 状态转移：其余行列\n+        for (int i = 1; i <= n; i++) {\n+            for (int j = 1; j <= m; j++) {\n+                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n+                    // 若两字符相等，则直接跳过此两字符\n+                    dp[i][j] = dp[i - 1][j - 1];\n+                } else {\n+                    // 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1\n+                    dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n+                }\n+            }\n+        }\n+        return dp[n][m];\n+    }\n+\n+    /* 编辑距离：状态压缩后的动态规划 */\n+    static int editDistanceDPComp(String s, String t) {\n+        int n = s.length(), m = t.length();\n+        int[] dp = new int[m + 1];\n+        // 状态转移：首行\n+        for (int j = 1; j <= m; j++) {\n+            dp[j] = j;\n+        }\n+        // 状态转移：其余行\n+        for (int i = 1; i <= n; i++) {\n+            // 状态转移：首列\n+            int leftup = dp[0]; // 暂存 dp[i-1, j-1]\n+            dp[0] = i;\n+            // 状态转移：其余列\n+            for (int j = 1; j <= m; j++) {\n+                int temp = dp[j];\n+                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n+                    // 若两字符相等，则直接跳过此两字符\n+                    dp[j] = leftup;\n+                } else {\n+                    // 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1\n+                    dp[j] = Math.min(Math.min(dp[j - 1], dp[j]), leftup) + 1;\n+                }\n+                leftup = temp; // 更新为下一轮的 dp[i-1, j-1]\n+            }\n+        }\n+        return dp[m];\n+    }\n+\n+    public static void main(String[] args) {\n+        String s = \"bag\";\n+        String t = \"pack\";\n+        int n = s.length(), m = t.length();\n+\n+        // 暴力搜索\n+        int res = editDistanceDFS(s, t, n, m);\n+        System.out.println(\"将 \" + s + \" 更改为 \" + t + \" 最少需要编辑 \" + res + \" 步\");\n+\n+        // 记忆化搜索\n+        int[][] mem = new int[n + 1][m + 1];\n+        for (int[] row : mem)\n+            Arrays.fill(row, -1);\n+        res = editDistanceDFSMem(s, t, mem, n, m);\n+        System.out.println(\"将 \" + s + \" 更改为 \" + t + \" 最少需要编辑 \" + res + \" 步\");\n+\n+        // 动态规划\n+        res = editDistanceDP(s, t);\n+        System.out.println(\"将 \" + s + \" 更改为 \" + t + \" 最少需要编辑 \" + res + \" 步\");\n+\n+        // 状态压缩后的动态规划\n+        res = editDistanceDPComp(s, t);\n+        System.out.println(\"将 \" + s + \" 更改为 \" + t + \" 最少需要编辑 \" + res + \" 步\");\n+    }\n+}",
    "output": "Add the section of edit distance problem"
  },
  {
    "input": "diff --git a/codes/java/chapter_dynamic_programming/coin_change.java b/codes/java/chapter_dynamic_programming/coin_change.java\n--- a/codes/java/chapter_dynamic_programming/coin_change.java\n+++ b/codes/java/chapter_dynamic_programming/coin_change.java\n@@ -0,0 +1,72 @@\n+/**\n+ * File: coin_change.java\n+ * Created Time: 2023-07-11\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_dynamic_programming;\n+\n+import java.util.Arrays;\n+\n+public class coin_change {\n+    /* 零钱兑换：动态规划 */\n+    static int coinChangeDP(int[] coins, int amt) {\n+        int n = coins.length;\n+        int MAX = amt + 1;\n+        // 初始化 dp 表\n+        int[][] dp = new int[n + 1][amt + 1];\n+        // 状态转移：首行首列\n+        for (int a = 1; a <= amt; a++) {\n+            dp[0][a] = MAX;\n+        }\n+        // 状态转移：其余行列\n+        for (int i = 1; i <= n; i++) {\n+            for (int a = 1; a <= amt; a++) {\n+                if (coins[i - 1] > a) {\n+                    // 若超过背包容量，则不选硬币 i\n+                    dp[i][a] = dp[i - 1][a];\n+                } else {\n+                    // 不选和选硬币 i 这两种方案的较小值\n+                    dp[i][a] = Math.min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n+                }\n+            }\n+        }\n+        return dp[n][amt] != MAX ? dp[n][amt] : -1;\n+    }\n+\n+    /* 零钱兑换：状态压缩后的动态规划 */\n+    static int coinChangeDPComp(int[] coins, int amt) {\n+        int n = coins.length;\n+        int MAX = amt + 1;\n+        // 初始化 dp 表\n+        int[] dp = new int[amt + 1];\n+        Arrays.fill(dp, MAX);\n+        dp[0] = 0;\n+        // 状态转移\n+        for (int i = 1; i <= n; i++) {\n+            for (int a = 1; a <= amt; a++) {\n+                if (coins[i - 1] > a) {\n+                    // 若超过背包容量，则不选硬币 i\n+                    dp[a] = dp[a];\n+                } else {\n+                    // 不选和选硬币 i 这两种方案的较小值\n+                    dp[a] = Math.min(dp[a], dp[a - coins[i - 1]] + 1);\n+                }\n+            }\n+        }\n+        return dp[amt] != MAX ? dp[amt] : -1;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] coins = { 1, 2, 5 };\n+        int amt = 4;\n+\n+        // 动态规划\n+        int res = coinChangeDP(coins, amt);\n+        System.out.println(\"凑到目标金额所需的最少硬币数量为 \" + res);\n+\n+        // 状态压缩后的动态规划\n+        res = coinChangeDPComp(coins, amt);\n+        System.out.println(\"凑到目标金额所需的最少硬币数量为 \" + res);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_dynamic_programming/coin_change_ii.java b/codes/java/chapter_dynamic_programming/coin_change_ii.java\n--- a/codes/java/chapter_dynamic_programming/coin_change_ii.java\n+++ b/codes/java/chapter_dynamic_programming/coin_change_ii.java\n@@ -0,0 +1,67 @@\n+/**\n+ * File: coin_change_ii.java\n+ * Created Time: 2023-07-11\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_dynamic_programming;\n+\n+public class coin_change_ii {\n+    /* 零钱兑换 II：动态规划 */\n+    static int coinChangeIIDP(int[] coins, int amt) {\n+        int n = coins.length;\n+        // 初始化 dp 表\n+        int[][] dp = new int[n + 1][amt + 1];\n+        // 初始化首列\n+        for (int i = 0; i <= n; i++) {\n+            dp[i][0] = 1;\n+        }\n+        // 状态转移\n+        for (int i = 1; i <= n; i++) {\n+            for (int a = 1; a <= amt; a++) {\n+                if (coins[i - 1] > a) {\n+                    // 若超过背包容量，则不选硬币 i\n+                    dp[i][a] = dp[i - 1][a];\n+                } else {\n+                    // 不选和选硬币 i 这两种方案之和\n+                    dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n+                }\n+            }\n+        }\n+        return dp[n][amt];\n+    }\n+\n+    /* 零钱兑换 II：状态压缩后的动态规划 */\n+    static int coinChangeIIDPComp(int[] coins, int amt) {\n+        int n = coins.length;\n+        // 初始化 dp 表\n+        int[] dp = new int[amt + 1];\n+        dp[0] = 1;\n+        // 状态转移\n+        for (int i = 1; i <= n; i++) {\n+            for (int a = 1; a <= amt; a++) {\n+                if (coins[i - 1] > a) {\n+                    // 若超过背包容量，则不选硬币 i\n+                    dp[a] = dp[a];\n+                } else {\n+                    // 不选和选硬币 i 这两种方案之和\n+                    dp[a] = dp[a] + dp[a - coins[i - 1]];\n+                }\n+            }\n+        }\n+        return dp[amt];\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] coins = { 1, 2, 5 };\n+        int amt = 5;\n+\n+        // 动态规划\n+        int res = coinChangeIIDP(coins, amt);\n+        System.out.println(\"凑出目标金额的硬币组合数量为 \" + res);\n+\n+        // 状态压缩后的动态规划\n+        res = coinChangeIIDPComp(coins, amt);\n+        System.out.println(\"凑出目标金额的硬币组合数量为 \" + res);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_dynamic_programming/unbounded_knapsack.java b/codes/java/chapter_dynamic_programming/unbounded_knapsack.java\n--- a/codes/java/chapter_dynamic_programming/unbounded_knapsack.java\n+++ b/codes/java/chapter_dynamic_programming/unbounded_knapsack.java\n@@ -0,0 +1,63 @@\n+/**\n+ * File: unbounded_knapsack.java\n+ * Created Time: 2023-07-11\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_dynamic_programming;\n+\n+public class unbounded_knapsack {\n+    /* 完全背包：动态规划 */\n+    static int unboundedKnapsackDP(int[] wgt, int[] val, int cap) {\n+        int n = wgt.length;\n+        // 初始化 dp 表\n+        int[][] dp = new int[n + 1][cap + 1];\n+        // 状态转移\n+        for (int i = 1; i <= n; i++) {\n+            for (int c = 1; c <= cap; c++) {\n+                if (wgt[i - 1] > c) {\n+                    // 若超过背包容量，则不选物品 i\n+                    dp[i][c] = dp[i - 1][c];\n+                } else {\n+                    // 不选和选物品 i 这两种方案的较大值\n+                    dp[i][c] = Math.max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);\n+                }\n+            }\n+        }\n+        return dp[n][cap];\n+    }\n+\n+    /* 完全背包：状态压缩后的动态规划 */\n+    static int unboundedKnapsackDPComp(int[] wgt, int[] val, int cap) {\n+        int n = wgt.length;\n+        // 初始化 dp 表\n+        int[] dp = new int[cap + 1];\n+        // 状态转移\n+        for (int i = 1; i <= n; i++) {\n+            for (int c = 1; c <= cap; c++) {\n+                if (wgt[i - 1] > c) {\n+                    // 若超过背包容量，则不选物品 i\n+                    dp[c] = dp[c];\n+                } else {\n+                    // 不选和选物品 i 这两种方案的较大值\n+                    dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n+                }\n+            }\n+        }\n+        return dp[cap];\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] wgt = { 1, 2, 3 };\n+        int[] val = { 5, 11, 15 };\n+        int cap = 4;\n+\n+        // 动态规划\n+        int res = unboundedKnapsackDP(wgt, val, cap);\n+        System.out.println(\"不超过背包容量的最大物品价值为 \" + res);\n+\n+        // 状态压缩后的动态规划\n+        res = unboundedKnapsackDPComp(wgt, val, cap);\n+        System.out.println(\"不超过背包容量的最大物品价值为 \" + res);\n+    }\n+}",
    "output": "Add the section of unbounded knapsack problem"
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/built_in_hash.java b/codes/java/chapter_hashing/built_in_hash.java\n--- a/codes/java/chapter_hashing/built_in_hash.java\n+++ b/codes/java/chapter_hashing/built_in_hash.java\n@@ -0,0 +1,38 @@\n+/**\n+ * File: built_in_hash.java\n+ * Created Time: 2023-06-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_hashing;\n+\n+import utils.*;\n+import java.util.*;\n+\n+public class built_in_hash {\n+    public static void main(String[] args) {\n+        int num = 3;\n+        int hashNum = Integer.hashCode(num);\n+        System.out.println(\"整数 \" + num + \" 的哈希值为 \" + hashNum);\n+\n+        boolean bol = true;\n+        int hashBol = Boolean.hashCode(bol);\n+        System.out.println(\"布尔量 \" + bol + \" 的哈希值为 \" + hashBol);\n+\n+        double dec = 3.14159;\n+        int hashDec = Double.hashCode(dec);\n+        System.out.println(\"小数 \" + dec + \" 的哈希值为 \" + hashDec);\n+\n+        String str = \"Hello 算法\";\n+        int hashStr = str.hashCode();\n+        System.out.println(\"字符串 \" + str + \" 的哈希值为 \" + hashStr);\n+\n+        Object[] arr = { 12836, \"小哈\" };\n+        int hashTup = Arrays.hashCode(arr);\n+        System.out.println(\"数组 \" + Arrays.toString(arr) + \" 的哈希值为 \" + hashTup);\n+\n+        ListNode obj = new ListNode(0);\n+        int hashObj = obj.hashCode();\n+        System.out.println(\"节点对象 \" + obj + \" 的哈希值为 \" + hashObj);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_hashing/simple_hash.java b/codes/java/chapter_hashing/simple_hash.java\n--- a/codes/java/chapter_hashing/simple_hash.java\n+++ b/codes/java/chapter_hashing/simple_hash.java\n@@ -0,0 +1,66 @@\n+/**\n+ * File: simple_hash.java\n+ * Created Time: 2023-06-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_hashing;\n+\n+public class simple_hash {\n+    /* 加法哈希 */\n+    static int addHash(String key) {\n+        long hash = 0;\n+        final int MODULUS = 1000000007;\n+        for (char c : key.toCharArray()) {\n+            hash = (hash + (int) c) % MODULUS;\n+        }\n+        return (int) hash;\n+    }\n+\n+    /* 乘法哈希 */\n+    static int mulHash(String key) {\n+        long hash = 0;\n+        final int MODULUS = 1000000007;\n+        for (char c : key.toCharArray()) {\n+            hash = (31 * hash + (int) c) % MODULUS;\n+        }\n+        return (int) hash;\n+    }\n+\n+    /* 异或哈希 */\n+    static int xorHash(String key) {\n+        int hash = 0;\n+        final int MODULUS = 1000000007;\n+        for (char c : key.toCharArray()) {\n+            System.out.println((int)c);\n+            hash ^= (int) c;\n+        }\n+        return hash & MODULUS;\n+    }\n+\n+    /* 旋转哈希 */\n+    static int rotHash(String key) {\n+        long hash = 0;\n+        final int MODULUS = 1000000007;\n+        for (char c : key.toCharArray()) {\n+            hash = ((hash << 4) ^ (hash >> 28) ^ (int) c) % MODULUS;\n+        }\n+        return (int) hash;\n+    }\n+\n+    public static void main(String[] args) {\n+        String key = \"Hello 算法\";\n+\n+        int hash = addHash(key);\n+        System.out.println(\"加法哈希值为 \" + hash);\n+\n+        hash = mulHash(key);\n+        System.out.println(\"乘法哈希值为 \" + hash);\n+\n+        hash = xorHash(key);\n+        System.out.println(\"异或哈希值为 \" + hash);\n+\n+        hash = rotHash(key);\n+        System.out.println(\"旋转哈希值为 \" + hash);\n+    }\n+}",
    "output": "Add Java and C++ code for the section hash algorithm"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/subset_sum_i.java b/codes/java/chapter_backtracking/subset_sum_i.java\n--- a/codes/java/chapter_backtracking/subset_sum_i.java\n+++ b/codes/java/chapter_backtracking/subset_sum_i.java\n@@ -0,0 +1,55 @@\n+/**\n+ * File: subset_sum_i.java\n+ * Created Time: 2023-06-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_backtracking;\n+\n+import java.util.*;\n+\n+public class subset_sum_i {\n+    /* 回溯算法：子集和 I */\n+    static void backtrack(List<Integer> state, int target, int[] choices, int start, List<List<Integer>> res) {\n+        // 子集和等于 target 时，记录解\n+        if (target == 0) {\n+            res.add(new ArrayList<>(state));\n+            return;\n+        }\n+        // 遍历所有选择\n+        // 剪枝二：从 start 开始遍历，避免生成重复子集\n+        for (int i = start; i < choices.length; i++) {\n+            // 剪枝一：若子集和超过 target ，则直接结束循环\n+            // 这是因为数组已排序，后边元素更大，子集和一定超过 target\n+            if (target - choices[i] < 0) {\n+                break;\n+            }\n+            // 尝试：做出选择，更新 target, start\n+            state.add(choices[i]);\n+            // 进行下一轮选择\n+            backtrack(state, target - choices[i], choices, i, res);\n+            // 回退：撤销选择，恢复到之前的状态\n+            state.remove(state.size() - 1);\n+        }\n+    }\n+\n+    /* 求解子集和 I */\n+    static List<List<Integer>> subsetSumI(int[] nums, int target) {\n+        List<Integer> state = new ArrayList<>(); // 状态（子集）\n+        Arrays.sort(nums); // 对 nums 进行排序\n+        int start = 0; // 遍历起始点\n+        List<List<Integer>> res = new ArrayList<>(); // 结果列表（子集列表）\n+        backtrack(state, target, nums, start, res);\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 3, 4, 5 };\n+        int target = 9;\n+\n+        List<List<Integer>> res = subsetSumI(nums, target);\n+\n+        System.out.println(\"输入数组 nums = \" + Arrays.toString(nums) + \", target = \" + target);\n+        System.out.println(\"所有和等于 \" + target + \" 的子集 res = \" + res);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_backtracking/subset_sum_i_naive.java b/codes/java/chapter_backtracking/subset_sum_i_naive.java\n--- a/codes/java/chapter_backtracking/subset_sum_i_naive.java\n+++ b/codes/java/chapter_backtracking/subset_sum_i_naive.java\n@@ -0,0 +1,53 @@\n+/**\n+ * File: subset_sum_i_naive.java\n+ * Created Time: 2023-06-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_backtracking;\n+\n+import java.util.*;\n+\n+public class subset_sum_i_naive {\n+    /* 回溯算法：子集和 I */\n+    static void backtrack(List<Integer> state, int target, int total, int[] choices, List<List<Integer>> res) {\n+        // 子集和等于 target 时，记录解\n+        if (total == target) {\n+            res.add(new ArrayList<>(state));\n+            return;\n+        }\n+        // 遍历所有选择\n+        for (int i = 0; i < choices.length; i++) {\n+            // 剪枝：若子集和超过 target ，则跳过该选择\n+            if (total + choices[i] > target) {\n+                continue;\n+            }\n+            // 尝试：做出选择，更新元素和 total\n+            state.add(choices[i]);\n+            // 进行下一轮选择\n+            backtrack(state, target, total + choices[i], choices, res);\n+            // 回退：撤销选择，恢复到之前的状态\n+            state.remove(state.size() - 1);\n+        }\n+    }\n+\n+    /* 求解子集和 I（包含重复子集） */\n+    static List<List<Integer>> subsetSumINaive(int[] nums, int target) {\n+        List<Integer> state = new ArrayList<>(); // 状态（子集）\n+        int total = 0; // 子集和\n+        List<List<Integer>> res = new ArrayList<>(); // 结果列表（子集列表）\n+        backtrack(state, target, total, nums, res);\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 3, 4, 5 };\n+        int target = 9;\n+\n+        List<List<Integer>> res = subsetSumINaive(nums, target);\n+\n+        System.out.println(\"输入数组 nums = \" + Arrays.toString(nums) + \", target = \" + target);\n+        System.out.println(\"所有和等于 \" + target + \" 的子集 res = \" + res);\n+        System.out.println(\"请注意，该方法输出的结果包含重复集合\");\n+    }\n+}\n\ndiff --git a/codes/java/chapter_backtracking/subset_sum_ii.java b/codes/java/chapter_backtracking/subset_sum_ii.java\n--- a/codes/java/chapter_backtracking/subset_sum_ii.java\n+++ b/codes/java/chapter_backtracking/subset_sum_ii.java\n@@ -0,0 +1,60 @@\n+/**\n+ * File: subset_sum_ii.java\n+ * Created Time: 2023-06-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_backtracking;\n+\n+import java.util.*;\n+\n+public class subset_sum_ii {\n+    /* 回溯算法：子集和 II */\n+    static void backtrack(List<Integer> state, int target, int[] choices, int start, List<List<Integer>> res) {\n+        // 子集和等于 target 时，记录解\n+        if (target == 0) {\n+            res.add(new ArrayList<>(state));\n+            return;\n+        }\n+        // 遍历所有选择\n+        // 剪枝二：从 start 开始遍历，避免生成重复子集\n+        // 剪枝三：从 start 开始遍历，避免重复选择同一元素\n+        for (int i = start; i < choices.length; i++) {\n+            // 剪枝一：若子集和超过 target ，则直接结束循环\n+            // 这是因为数组已排序，后边元素更大，子集和一定超过 target\n+            if (target - choices[i] < 0) {\n+                break;\n+            }\n+            // 剪枝四：如果该元素与左边元素相等，说明该搜索分支重复，直接跳过\n+            if (i > start && choices[i] == choices[i - 1]) {\n+                continue;\n+            }\n+            // 尝试：做出选择，更新 target, start\n+            state.add(choices[i]);\n+            // 进行下一轮选择\n+            backtrack(state, target - choices[i], choices, i + 1, res);\n+            // 回退：撤销选择，恢复到之前的状态\n+            state.remove(state.size() - 1);\n+        }\n+    }\n+\n+    /* 求解子集和 II */\n+    static List<List<Integer>> subsetSumII(int[] nums, int target) {\n+        List<Integer> state = new ArrayList<>(); // 状态（子集）\n+        Arrays.sort(nums); // 对 nums 进行排序\n+        int start = 0; // 遍历起始点\n+        List<List<Integer>> res = new ArrayList<>(); // 结果列表（子集列表）\n+        backtrack(state, target, nums, start, res);\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 4, 4, 5 };\n+        int target = 9;\n+\n+        List<List<Integer>> res = subsetSumII(nums, target);\n+\n+        System.out.println(\"输入数组 nums = \" + Arrays.toString(nums) + \", target = \" + target);\n+        System.out.println(\"所有和等于 \" + target + \" 的子集 res = \" + res);\n+    }\n+}",
    "output": "Add the section of subset sum problem"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -109,10 +109,15 @@ public void remove(int num) {\n             // 当子节点数量 = 0 / 1 时， child = null / 该子节点\n             TreeNode child = cur.left != null ? cur.left : cur.right;\n             // 删除节点 cur\n-            if (pre.left == cur)\n-                pre.left = child;\n-            else\n-                pre.right = child;\n+            if (cur != root) {\n+                if (pre.left == cur)\n+                    pre.left = child;\n+                else\n+                    pre.right = child;\n+            } else {\n+                // 若删除节点为根节点，则重新指定根节点\n+                root = child;\n+            }\n         }\n         // 子节点数量 = 2\n         else {",
    "output": "Fix remove() in binary search tree"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/selection_sort.java b/codes/java/chapter_sorting/selection_sort.java\n--- a/codes/java/chapter_sorting/selection_sort.java\n+++ b/codes/java/chapter_sorting/selection_sort.java\n@@ -0,0 +1,36 @@\n+/**\n+ * File: selection_sort.java\n+ * Created Time: 2023-05-23\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_sorting;\n+\n+import java.util.Arrays;\n+\n+public class selection_sort {\n+    /* 选择排序 */\n+    public static void selectionSort(int[] nums) {\n+        int n = nums.length;\n+        // 外循环：未排序区间为 [i, n-1]\n+        for (int i = 0; i < n - 1; i++) {\n+            // 内循环：找到未排序区间 [i, n-1] 中的最小元素\n+            int k = i;\n+            for (int j = i + 1; j < n; j++) {\n+                if (nums[j] < nums[k]) {\n+                    k = j; // 更新最小元素\n+                }\n+            }\n+            // 将该最小元素与未排序区间的首个元素交换\n+            int temp = nums[i];\n+            nums[i] = nums[k];\n+            nums[k] = temp;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 4, 1, 3, 1, 5, 2 };\n+        selectionSort(nums);\n+        System.out.println(\"选择排序完成后 nums = \" + Arrays.toString(nums));\n+    }\n+}",
    "output": "Add the section of selection sort"
  },
  {
    "input": "diff --git a/codes/java/chapter_searching/binary_search.java b/codes/java/chapter_searching/binary_search.java\n--- a/codes/java/chapter_searching/binary_search.java\n+++ b/codes/java/chapter_searching/binary_search.java\n@@ -45,7 +45,7 @@ else if (nums[m] > target) // 此情况说明 target 在区间 [i, m) 中\n \n     public static void main(String[] args) {\n         int target = 6;\n-        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 67, 70, 92 };\n+        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 26, 31, 35 };\n \n         /* 二分查找（双闭区间） */\n         int index = binarySearch(nums, target);",
    "output": "Fix the test case of binary search"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/bucket_sort.java b/codes/java/chapter_sorting/bucket_sort.java\n--- a/codes/java/chapter_sorting/bucket_sort.java\n+++ b/codes/java/chapter_sorting/bucket_sort.java\n@@ -20,7 +20,7 @@ static void bucketSort(float[] nums) {\n         // 1. 将数组元素分配到各个桶中\n         for (float num : nums) {\n             // 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]\n-            int i = (int) num * k;\n+            int i = (int) (num * k);\n             // 将 num 添加进桶 i\n             buckets.get(i).add(num);\n         }",
    "output": "Fix bucket_sort"
  },
  {
    "input": "diff --git a/codes/java/chapter_searching/two_sum.java b/codes/java/chapter_searching/two_sum.java\n--- a/codes/java/chapter_searching/two_sum.java\n+++ b/codes/java/chapter_searching/two_sum.java\n@@ -1,5 +1,5 @@\n /**\n- * File: leetcode_two_sum.java\n+ * File: two_sum.java\n  * Created Time: 2022-11-25\n  * Author: Krahets (krahets@163.com)\n  */\n@@ -8,7 +8,7 @@\n \n import java.util.*;\n \n-public class leetcode_two_sum {\n+public class two_sum {\n     /* 方法一：暴力枚举 */\n     static int[] twoSumBruteForce(int[] nums, int target) {\n         int size = nums.length;\n@@ -40,7 +40,7 @@ static int[] twoSumHashTable(int[] nums, int target) {\n     public static void main(String[] args) {\n         // ======= Test Case =======\n         int[] nums = { 2, 7, 11, 15 };\n-        int target = 9;\n+        int target = 13;\n \n         // ====== Driver Code ======\n         // 方法一",
    "output": "Add figures to replace_linear_by_hashing.md"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/preorder_find_nodes.java b/codes/java/chapter_backtracking/preorder_find_nodes.java\n--- a/codes/java/chapter_backtracking/preorder_find_nodes.java\n+++ b/codes/java/chapter_backtracking/preorder_find_nodes.java\n@@ -32,7 +32,7 @@ public static void main(String[] args) {\n         res = new ArrayList<>();\n         preOrder(root);\n \n-        System.out.println(\"\\n输出所有根节点到节点 7 的路径\");\n+        System.out.println(\"\\n输出所有值为 7 的节点\");\n         List<Integer> vals = new ArrayList<>();\n         for (TreeNode node : res) {\n             vals.add(node.val);",
    "output": "Add cpp code for the backtrack algorithm"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/preorder_find_nodes.java b/codes/java/chapter_backtracking/preorder_find_nodes.java\n--- a/codes/java/chapter_backtracking/preorder_find_nodes.java\n+++ b/codes/java/chapter_backtracking/preorder_find_nodes.java\n@@ -15,15 +15,12 @@ static void preOrder(TreeNode root) {\n         if (root == null) {\n             return;\n         }\n-        // 尝试\n         if (root.val == 7) {\n             // 记录解\n             res.add(root);\n         }\n         preOrder(root.left);\n         preOrder(root.right);\n-        // 回退\n-        return;\n     }\n \n     public static void main(String[] args) {",
    "output": "Fix the codes of backtracking"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -127,17 +127,6 @@ public void remove(int num) {\n             cur.val = tmp.val;\n         }\n     }\n-\n-    /* 获取中序遍历中的下一个节点（仅适用于 root 有左子节点的情况） */\n-    public TreeNode getInOrderNext(TreeNode root) {\n-        if (root == null)\n-            return root;\n-        // 循环访问左子节点，直到叶节点时为最小节点，跳出\n-        while (root.left != null) {\n-            root = root.left;\n-        }\n-        return root;\n-    }\n }\n \n public class binary_search_tree {",
    "output": "Remove unused functions"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/avl_tree.java b/codes/java/chapter_tree/avl_tree.java\n--- a/codes/java/chapter_tree/avl_tree.java\n+++ b/codes/java/chapter_tree/avl_tree.java\n@@ -92,9 +92,8 @@ private TreeNode rotate(TreeNode node) {\n     }\n \n     /* 插入节点 */\n-    public TreeNode insert(int val) {\n+    public void insert(int val) {\n         root = insertHelper(root, val);\n-        return root;\n     }\n \n     /* 递归插入节点（辅助方法） */\n@@ -116,9 +115,8 @@ else if (val > node.val)\n     }\n \n     /* 删除节点 */\n-    public TreeNode remove(int val) {\n+    public void remove(int val) {\n         root = removeHelper(root, val);\n-        return root;\n     }\n \n     /* 递归删除节点（辅助方法） */\n@@ -141,7 +139,10 @@ else if (val > node.val)\n                     node = child;\n             } else {\n                 // 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点\n-                TreeNode temp = getInOrderNext(node.right);\n+                TreeNode temp = node.right;\n+                while (temp.left != null) {\n+                    temp = temp.left;\n+                }\n                 node.right = removeHelper(node.right, temp.val);\n                 node.val = temp.val;\n             }\n@@ -153,17 +154,6 @@ else if (val > node.val)\n         return node;\n     }\n \n-    /* 获取中序遍历中的下一个节点（仅适用于 root 有左子节点的情况） */\n-    private TreeNode getInOrderNext(TreeNode node) {\n-        if (node == null)\n-            return node;\n-        // 循环访问左子节点，直到叶节点时为最小节点，跳出\n-        while (node.left != null) {\n-            node = node.left;\n-        }\n-        return node;\n-    }\n-\n     /* 查找节点 */\n     public TreeNode search(int val) {\n         TreeNode cur = root;\n\ndiff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -56,16 +56,16 @@ else if (cur.val > num)\n     }\n \n     /* 插入节点 */\n-    public TreeNode insert(int num) {\n+    public void insert(int num) {\n         // 若树为空，直接提前返回\n         if (root == null)\n-            return null;\n+            return;\n         TreeNode cur = root, pre = null;\n         // 循环查找，越过叶节点后跳出\n         while (cur != null) {\n             // 找到重复节点，直接返回\n             if (cur.val == num)\n-                return null;\n+                return;\n             pre = cur;\n             // 插入位置在 cur 的右子树中\n             if (cur.val < num)\n@@ -80,14 +80,13 @@ public TreeNode insert(int num) {\n             pre.right = node;\n         else\n             pre.left = node;\n-        return node;\n     }\n \n     /* 删除节点 */\n-    public TreeNode remove(int num) {\n+    public void remove(int num) {\n         // 若树为空，直接提前返回\n         if (root == null)\n-            return null;\n+            return;\n         TreeNode cur = root, pre = null;\n         // 循环查找，越过叶节点后跳出\n         while (cur != null) {\n@@ -104,7 +103,7 @@ public TreeNode remove(int num) {\n         }\n         // 若无待删除节点，则直接返回\n         if (cur == null)\n-            return null;\n+            return;\n         // 子节点数量 = 0 or 1\n         if (cur.left == null || cur.right == null) {\n             // 当子节点数量 = 0 / 1 时， child = null / 该子节点\n@@ -118,14 +117,15 @@ public TreeNode remove(int num) {\n         // 子节点数量 = 2\n         else {\n             // 获取中序遍历中 cur 的下一个节点\n-            TreeNode nex = getInOrderNext(cur.right);\n-            int tmp = nex.val;\n-            // 递归删除节点 nex\n-            remove(nex.val);\n-            // 将 nex 的值复制给 cur\n-            cur.val = tmp;\n+            TreeNode tmp = cur.right;\n+            while (tmp.left != null) {\n+                tmp = tmp.left;\n+            }\n+            // 递归删除节点 tmp\n+            remove(tmp.val);\n+            // 用 tmp 覆盖 cur\n+            cur.val = tmp.val;\n         }\n-        return cur;\n     }\n \n     /* 获取中序遍历中的下一个节点（仅适用于 root 有左子节点的情况） */\n@@ -153,7 +153,7 @@ public static void main(String[] args) {\n         System.out.println(\"\\n查找到的节点对象为 \" + node + \"，节点值 = \" + node.val);\n \n         /* 插入节点 */\n-        node = bst.insert(16);\n+        bst.insert(16);\n         System.out.println(\"\\n插入节点 16 后，二叉树为\\n\");\n         PrintUtil.printTree(bst.getRoot());\n ",
    "output": "Fix the return type of binary search tree and avl tree"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/radix_sort.java b/codes/java/chapter_sorting/radix_sort.java\n--- a/codes/java/chapter_sorting/radix_sort.java\n+++ b/codes/java/chapter_sorting/radix_sort.java\n@@ -16,51 +16,51 @@ static int digit(int num, int exp) {\n     }\n \n     /* 计数排序（根据 nums 第 k 位排序） */\n-    static void countingSort(int[] nums, int exp) {\n-        // 十进制的各位数字范围为 0~9 ，因此需要长度为 10 的桶\n-        int[] bucket = new int[10];\n+    static void countingSortDigit(int[] nums, int exp) {\n+        // 十进制的位范围为 0~9 ，因此需要长度为 10 的桶\n+        int[] counter = new int[10];\n         int n = nums.length;\n-        // 借助桶来统计 0~9 各数字的出现次数\n+        // 统计 0~9 各数字的出现次数\n         for (int i = 0; i < n; i++) {\n             int d = digit(nums[i], exp); // 获取 nums[i] 第 k 位，记为 d\n-            bucket[d]++;                 // 统计数字 d 的出现次数\n+            counter[d]++;                // 统计数字 d 的出现次数\n         }\n         // 求前缀和，将“出现个数”转换为“数组索引”\n         for (int i = 1; i < 10; i++) {\n-            bucket[i] += bucket[i - 1];\n+            counter[i] += counter[i - 1];\n         }\n-        // 倒序遍历，根据桶内统计结果，将各元素填入暂存数组 tmp\n-        int[] tmp = new int[n];\n+        // 倒序遍历，根据桶内统计结果，将各元素填入 res\n+        int[] res = new int[n];\n         for (int i = n - 1; i >= 0; i--) {\n             int d = digit(nums[i], exp);\n-            int j = bucket[d] - 1; // 获取 d 在数组中的索引 j\n-            tmp[j] = nums[i];      // 将当前元素填入索引 j\n-            bucket[d]--;           // 将 d 的数量减 1\n+            int j = counter[d] - 1; // 获取 d 在数组中的索引 j\n+            res[j] = nums[i];       // 将当前元素填入索引 j\n+            counter[d]--;           // 将 d 的数量减 1\n         }\n-        // 将 tmp 复制到 nums\n+        // 使用结果覆盖原数组 nums\n         for (int i = 0; i < n; i++)\n-            nums[i] = tmp[i];\n+            nums[i] = res[i];\n     }\n \n     /* 基数排序 */\n     static void radixSort(int[] nums) {\n         // 获取数组的最大元素，用于判断最大位数\n-        int ma = Integer.MIN_VALUE;\n+        int m = Integer.MIN_VALUE;\n         for (int num : nums)\n-            if (num > ma) ma = num;\n+            if (num > m) m = num;\n         // 按照从低位到高位的顺序遍历\n-        for (int exp = 1; ma >= exp; exp *= 10)\n-            // 对数组元素的第 k 位执行「计数排序」\n+        for (int exp = 1; exp <= m; exp *= 10)\n+            // 对数组元素的第 k 位执行计数排序\n             // k = 1 -> exp = 1\n             // k = 2 -> exp = 10\n-            // k = 3 -> exp = 100\n             // 即 exp = 10^(k-1)\n-            countingSort(nums, exp);\n+            countingSortDigit(nums, exp);\n     }\n \n     public static void main(String[] args) {\n-        /* 基数排序 */\n-        int[] nums = { 23, 12, 3, 4, 788, 192 };\n+        // 基数排序\n+        int[] nums = { 10546151, 35663510, 42865989, 34862445, 81883077, \n+                       88906420, 72429244, 30524779, 82060337, 63832996 };\n         radixSort(nums);\n         System.out.println(\"基数排序完成后 nums = \" + Arrays.toString(nums));\n     }",
    "output": "Add the section of radix sort"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/bucket_sort.java b/codes/java/chapter_sorting/bucket_sort.java\n--- a/codes/java/chapter_sorting/bucket_sort.java\n+++ b/codes/java/chapter_sorting/bucket_sort.java\n@@ -0,0 +1,47 @@\n+/**\n+ * File: bucket_sort.java\n+ * Created Time: 2023-03-17\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_sorting;\n+\n+import java.util.*;\n+\n+public class bucket_sort {\n+    /* 桶排序 */\n+    static void bucketSort(float[] nums) {\n+        // 初始化 k = n/3 个桶，预期向每个桶分配 3 个元素\n+        int k = nums.length / 2;\n+        List<List<Float>> buckets = new ArrayList<>();\n+        for (int i = 0; i < k; i++) {\n+            buckets.add(new ArrayList<>());\n+        }\n+        // 1. 将数组元素分配到各个桶中\n+        for (float num : nums) {\n+            // 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]\n+            int i = (int) num * k;\n+            // 将 num 添加进桶 i\n+            buckets.get(i).add(num);\n+        }\n+        // 2. 对各个桶执行排序\n+        for (List<Float> bucket : buckets) {\n+            // 使用内置排序函数，也可以替换成其它排序算法\n+            Collections.sort(bucket);\n+        }\n+        // 3. 遍历桶合并结果\n+        int i = 0;\n+        for (List<Float> bucket : buckets) {\n+            for (float num : bucket) {\n+                nums[i++] = num;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        // 设输入数据为浮点数，范围为 [0, 1)\n+        float[] nums = { 0.49f, 0.96f, 0.82f, 0.09f, 0.57f, 0.43f, 0.91f, 0.58f, 0.15f, 0.37f, 0.55f, 0.28f };\n+        bucketSort(nums);\n+        System.out.println(\"桶排序完成后 nums = \" + Arrays.toString(nums));\n+    }\n+}",
    "output": "Add the section of bucket sort"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/counting_sort.java b/codes/java/chapter_sorting/counting_sort.java\n--- a/codes/java/chapter_sorting/counting_sort.java\n+++ b/codes/java/chapter_sorting/counting_sort.java\n@@ -68,11 +68,11 @@ static void countingSort(int[] nums) {\n \n     public static void main(String[] args) {\n         int[] nums = { 1, 0, 1, 2, 0, 4, 0, 2, 2, 4 };\n-\n         countingSortNaive(nums);\n         System.out.println(\"计数排序（无法排序对象）完成后 nums = \" + Arrays.toString(nums));\n-\n-        countingSort(nums);\n-        System.out.println(\"计数排序完成后 nums = \" + Arrays.toString(nums));\n+        \n+        int[] nums1 = { 1, 0, 1, 2, 0, 4, 0, 2, 2, 4 };\n+        countingSort(nums1);\n+        System.out.println(\"计数排序完成后 nums1 = \" + Arrays.toString(nums1));\n     }\n }",
    "output": "Add Python and C++ code for the counting sort"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/counting_sort.java b/codes/java/chapter_sorting/counting_sort.java\n--- a/codes/java/chapter_sorting/counting_sort.java\n+++ b/codes/java/chapter_sorting/counting_sort.java\n@@ -0,0 +1,78 @@\n+/**\n+ * File: bubble_sort.java\n+ * Created Time: 2023-03-17\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_sorting;\n+\n+import java.util.*;\n+\n+public class counting_sort {\n+    /* 计数排序 */\n+    // 简单实现，无法用于排序对象\n+    static void countingSortNaive(int[] nums) {\n+        // 1. 统计数组最大元素 m\n+        int m = 0;\n+        for (int num : nums) {\n+            m = Math.max(m, num);\n+        }\n+        // 2. 统计各数字的出现次数\n+        // counter[num] 代表 num 的出现次数\n+        int[] counter = new int[m + 1];\n+        for (int num : nums) {\n+            counter[num]++;\n+        }\n+        // 3. 遍历 counter ，将各元素填入原数组 nums\n+        int i = 0;\n+        for (int num = 0; num < m + 1; num++) {\n+            for (int j = 0; j < counter[num]; j++, i++) {\n+                nums[i] = num;\n+            }\n+        }\n+    }\n+\n+    /* 计数排序 */\n+    // 完整实现，可排序对象，并且是稳定排序\n+    static void countingSort(int[] nums) {\n+        // 1. 统计数组最大元素 m\n+        int m = 0;\n+        for (int num : nums) {\n+            m = Math.max(m, num);\n+        }\n+        // 2. 统计各数字的出现次数\n+        // counter[num] 代表 num 的出现次数\n+        int[] counter = new int[m + 1];\n+        for (int num : nums) {\n+            counter[num]++;\n+        }\n+        // 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”\n+        // 即 counter[num]-1 是 num 在 res 中最后一次出现的索引\n+        for (int i = 0; i < m; i++) {\n+            counter[i + 1] += counter[i];\n+        }\n+        // 4. 倒序遍历 nums ，将各元素填入结果数组 res\n+        // 初始化数组 res 用于记录结果\n+        int n = nums.length;\n+        int[] res = new int[n];\n+        for (int i = n - 1; i >= 0; i--) {\n+            int num = nums[i];\n+            res[counter[num] - 1] = num; // 将 num 放置到对应索引处\n+            counter[num]--; // 令前缀和自减 1 ，得到下次放置 num 的索引\n+        }\n+        // 使用结果数组 res 覆盖原数组 nums\n+        for (int i = 0; i < n; i++) {\n+            nums[i] = res[i];\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 1, 0, 1, 2, 0, 4, 0, 2, 2, 4 };\n+\n+        countingSortNaive(nums);\n+        System.out.println(\"计数排序（无法排序对象）完成后 nums = \" + Arrays.toString(nums));\n+\n+        countingSort(nums);\n+        System.out.println(\"计数排序完成后 nums = \" + Arrays.toString(nums));\n+    }\n+}",
    "output": "Add the section of counting sort"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/radix_sort.java b/codes/java/chapter_sorting/radix_sort.java\n--- a/codes/java/chapter_sorting/radix_sort.java\n+++ b/codes/java/chapter_sorting/radix_sort.java\n@@ -16,7 +16,7 @@ static int digit(int num, int exp) {\n     }\n \n     /* 计数排序（根据 nums 第 k 位排序） */\n-    static void countSort(int[] nums, int exp) {\n+    static void countingSort(int[] nums, int exp) {\n         // 十进制的各位数字范围为 0~9 ，因此需要长度为 10 的桶\n         int[] bucket = new int[10];\n         int n = nums.length;\n@@ -55,7 +55,7 @@ static void radixSort(int[] nums) {\n             // k = 2 -> exp = 10\n             // k = 3 -> exp = 100\n             // 即 exp = 10^(k-1)\n-            countSort(nums, exp);\n+            countingSort(nums, exp);\n     }\n \n     public static void main(String[] args) {",
    "output": "Fix the deconstructor of linkedlist_queue.cpp"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/linkedlist_deque.java b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n@@ -22,15 +22,15 @@ class ListNode {\n /* 基于双向链表实现的双向队列 */\n class LinkedListDeque {\n     private ListNode front, rear; // 头结点 front ，尾结点 rear\n-    private int size = 0;         // 双向队列的长度\n+    private int queSize = 0;      // 双向队列的长度\n \n     public LinkedListDeque() {\n         front = rear = null;\n     }\n \n     /* 获取双向队列的长度 */\n     public int size() {\n-        return size;\n+        return queSize;\n     }\n \n     /* 判断双向队列是否为空 */\n@@ -57,7 +57,7 @@ else if (isFront) {\n             node.prev = rear;\n             rear = node;  // 更新尾结点\n         }\n-        size++; // 更新队列长度\n+        queSize++; // 更新队列长度\n     }\n \n     /* 队首入队 */\n@@ -97,7 +97,7 @@ private Integer poll(boolean isFront) {\n             }\n             rear = rPrev;    // 更新尾结点\n         }\n-        size--; // 更新队列长度\n+        queSize--; // 更新队列长度\n         return val;\n     }\n ",
    "output": "Add C++ code for the linkedlist deque and array deque"
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/linked_list.java b/codes/java/chapter_array_and_linkedlist/linked_list.java\n--- a/codes/java/chapter_array_and_linkedlist/linked_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/linked_list.java\n@@ -12,8 +12,8 @@ public class linked_list {\n     /* 在链表的结点 n0 之后插入结点 P */\n     static void insert(ListNode n0, ListNode P) {\n         ListNode n1 = n0.next;\n-        n0.next = P;\n         P.next = n1;\n+        n0.next = P;\n     }\n \n     /* 删除链表的结点 n0 之后的首个结点 */",
    "output": "Change the operations sequence of the likedlist's insert() method"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/array_deque.java b/codes/java/chapter_stack_and_queue/array_deque.java\n--- a/codes/java/chapter_stack_and_queue/array_deque.java\n+++ b/codes/java/chapter_stack_and_queue/array_deque.java\n@@ -116,7 +116,7 @@ public int[] toArray() {\n public class array_deque {\n     public static void main(String[] args) {\n         /* 初始化双向队列 */\n-        LinkedListDeque deque = new LinkedListDeque();\n+        ArrayDeque deque = new ArrayDeque(10);\n         deque.pushLast(3);\n         deque.pushLast(2);\n         deque.pushLast(5);",
    "output": "Fix array_deque.java\nUnify the book name.\nUpdate cover image"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/bubble_sort.java b/codes/java/chapter_sorting/bubble_sort.java\n--- a/codes/java/chapter_sorting/bubble_sort.java\n+++ b/codes/java/chapter_sorting/bubble_sort.java\n@@ -51,6 +51,6 @@ public static void main(String[] args) {\n \n         int[] nums1 = { 4, 1, 3, 1, 5, 2 };\n         bubbleSortWithFlag(nums1);\n-        System.out.println(\"冒泡排序完成后 nums1 = \" + Arrays.toString(nums));\n+        System.out.println(\"冒泡排序完成后 nums1 = \" + Arrays.toString(nums1));\n     }\n }",
    "output": "Add chapter_sorting by dart * add chapter_sorting by dart * fixed style of dart and bug mentioned before * alter min value of dart * Update radix_sort.dart --------- Co-authored-by: Yudong Jin <krahets@163.com>"
  },
  {
    "input": "diff --git a/codes/java/chapter_graph/graph_traversal.java b/codes/java/chapter_graph/graph_traversal.java\n--- a/codes/java/chapter_graph/graph_traversal.java\n+++ b/codes/java/chapter_graph/graph_traversal.java\n@@ -1,70 +0,0 @@\n-/**\n- * File: graph_adjacency_list.java\n- * Created Time: 2023-02-12\n- * Author: Krahets (krahets@163.com)\n- */\n-\n-package chapter_graph;\n-\n-import java.util.*;\n-\n-public class graph_traversal {\n-    /* 以顶点 vet 为起点，对图 graph 执行广度优先遍历 */\n-    // 采用 GraphAdjList 表示图，以方便获取指定结点的所有邻接结点\n-    static List<Vertex> graphBFS(GraphAdjList graph, Vertex startVet) {\n-        // 顶点遍历序列\n-        List<Vertex> res = new ArrayList<>();\n-        // 用于记录顶点是否已被访问\n-        Set<Vertex> visited = new HashSet<>() {{ add(startVet); }};\n-        // 队列用于实现 BFS\n-        Queue<Vertex> que = new LinkedList<>() {{ offer(startVet); }};\n-        // 循环直至访问完所有顶点\n-        while (!que.isEmpty()) {\n-            Vertex vet = que.poll(); // 队首顶点出队\n-            res.add(vet);            // 访问该顶点\n-            // 遍历该顶点的所有邻接顶点\n-            for (Vertex adjVet : graph.adjList.get(vet)) {\n-                if (!visited.contains(adjVet)) {\n-                    que.offer(adjVet);   // 只入队未访问的顶点\n-                    visited.add(adjVet); // 标记该顶点已被访问\n-                }\n-            }\n-        }\n-        // 返回顶点遍历序列\n-        return res;\n-    }\n-\n-    /* 输入值列表 vals ，返回顶点列表 vets */\n-    static Vertex[] valsToVets(int[] vals) {\n-        Vertex[] vets = new Vertex[vals.length];\n-        for (int i = 0; i < vals.length; i++) {\n-            vets[i] = new Vertex(vals[i]);\n-        }\n-        return vets;\n-    }\n-\n-    /* 输入顶点列表 vets ，返回值列表 vals */\n-    static List<Integer> vetsToVals(List<Vertex> vets) {\n-        List<Integer> vals = new ArrayList<>();\n-        for (Vertex vet : vets) {\n-            vals.add(vet.val);\n-        }\n-        return vals;\n-    }\n-\n-    public static void main(String[] args) {\n-        /* 初始化无向图 */\n-        Vertex[] v = valsToVets(new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 });\n-        Vertex[][] edges = { { v[0], v[1] }, { v[0], v[3] }, { v[1], v[2] }, { v[1], v[4] }, \n-                             { v[2], v[5] }, { v[3], v[4] }, { v[3], v[6] }, { v[4], v[5] },\n-                             { v[4], v[7] }, { v[5], v[8] }, { v[6], v[7] }, { v[7], v[8] }};\n-        GraphAdjList graph = new GraphAdjList(edges);\n-        System.out.println(\"\\n初始化后，图为\");\n-        graph.print();\n-\n-        /* 广度优先遍历 BFS */\n-        List<Vertex> res = graphBFS(graph, v[0]);\n-        System.out.println(\"\\n广度优先遍历（BFS）顶点序列为\");\n-        System.out.println(vetsToVals(res));\n-    }\n-}",
    "output": "Remove graph_traversal.java"
  },
  {
    "input": "diff --git a/codes/java/include/Vertex.java b/codes/java/include/Vertex.java\n--- a/codes/java/include/Vertex.java\n+++ b/codes/java/include/Vertex.java\n@@ -0,0 +1,35 @@\n+/**\n+ * File: TreeNode.java\n+ * Created Time: 2022-11-25\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package include;\n+\n+import java.util.*;\n+\n+/* 顶点类 */\n+public class Vertex {\n+    public int val;\n+    public Vertex(int val) {\n+        this.val = val;\n+    }\n+\n+    /* 输入值列表 vals ，返回顶点列表 vets */\n+    public static Vertex[] valsToVets(int[] vals) {\n+        Vertex[] vets = new Vertex[vals.length];\n+        for (int i = 0; i < vals.length; i++) {\n+            vets[i] = new Vertex(vals[i]);\n+        }\n+        return vets;\n+    }\n+\n+    /* 输入顶点列表 vets ，返回值列表 vals */\n+    public static List<Integer> vetsToVals(List<Vertex> vets) {\n+        List<Integer> vals = new ArrayList<>();\n+        for (Vertex vet : vets) {\n+            vals.add(vet.val);\n+        }\n+        return vals;\n+    }\n+}\n\\ No newline at end of file",
    "output": "Add missing Vertex.java"
  },
  {
    "input": "diff --git a/codes/java/chapter_graph/graph_adjacency_matrix.java b/codes/java/chapter_graph/graph_adjacency_matrix.java\n--- a/codes/java/chapter_graph/graph_adjacency_matrix.java\n+++ b/codes/java/chapter_graph/graph_adjacency_matrix.java\n@@ -100,7 +100,7 @@ public static void main(String[] args) {\n         /* 初始化无向图 */\n         // 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引\n         int[] vertices = { 1, 3, 2, 5, 4 };\n-        int[][] edges = { { 0, 1 }, { 0, 2 }, { 1, 2 }, { 2, 3 }, { 0, 3 }, { 2, 4 }, { 3, 4 } };\n+        int[][] edges = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 0, 3 }, { 2, 4 }, { 3, 4 } };\n         GraphAdjMat graph = new GraphAdjMat(vertices, edges);\n         System.out.println(\"\\n初始化后，图为\");\n         graph.print();",
    "output": "Fix the initial edges in graph_adjacency_matrix"
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/leetcode_two_sum.java b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n--- a/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n+++ b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n@@ -8,9 +8,10 @@\n \n import java.util.*;\n \n-/* 方法一：暴力枚举 */\n-class SolutionBruteForce {\n-    public int[] twoSum(int[] nums, int target) {\n+\n+public class leetcode_two_sum {\n+    /* 方法一：暴力枚举 */\n+    static int[] twoSumBruteForce(int[] nums, int target) {\n         int size = nums.length;\n         // 两层循环，时间复杂度 O(n^2)\n         for (int i = 0; i < size - 1; i++) {\n@@ -21,11 +22,9 @@ public int[] twoSum(int[] nums, int target) {\n         }\n         return new int[0];\n     }\n-}\n \n-/* 方法二：辅助哈希表 */\n-class SolutionHashMap {\n-    public int[] twoSum(int[] nums, int target) {\n+    /* 方法二：辅助哈希表 */\n+    static int[] twoSumHashTable(int[] nums, int target) {\n         int size = nums.length;\n         // 辅助哈希表，空间复杂度 O(n)\n         Map<Integer, Integer> dic = new HashMap<>();\n@@ -38,22 +37,18 @@ public int[] twoSum(int[] nums, int target) {\n         }\n         return new int[0];\n     }\n-}\n \n-public class leetcode_two_sum {\n     public static void main(String[] args) {\n         // ======= Test Case =======\n         int[] nums = { 2,7,11,15 };\n         int target = 9;\n         \n         // ====== Driver Code ======\n         // 方法一\n-        SolutionBruteForce slt1 = new SolutionBruteForce();\n-        int[] res = slt1.twoSum(nums, target);\n+        int[] res = twoSumBruteForce(nums, target);\n         System.out.println(\"方法一 res = \" + Arrays.toString(res));\n         // 方法二\n-        SolutionHashMap slt2 = new SolutionHashMap();\n-        res = slt2.twoSum(nums, target);\n+        res = twoSumHashTable(nums, target);\n         System.out.println(\"方法二 res = \" + Arrays.toString(res));\n     }\n }",
    "output": "Add build script for JS and TS codes"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/array_queue.java b/codes/java/chapter_stack_and_queue/array_queue.java\n--- a/codes/java/chapter_stack_and_queue/array_queue.java\n+++ b/codes/java/chapter_stack_and_queue/array_queue.java\n@@ -10,13 +10,13 @@\n \n /* 基于环形数组实现的队列 */\n class ArrayQueue {\n-    private int[] nums;     // 用于存储队列元素的数组\n-    private int front = 0;  // 头指针，指向队首\n-    private int rear = 0;   // 尾指针，指向队尾 + 1\n+    private int[] nums;  // 用于存储队列元素的数组\n+    private int front;   // 队首指针，指向队首元素\n+    private int queSize; // 队列长度\n \n     public ArrayQueue(int capacity) {\n-        // 初始化数组\n         nums = new int[capacity];\n+        front = queSize = 0;\n     }\n \n     /* 获取队列的容量 */\n@@ -26,33 +26,34 @@ public int capacity() {\n \n     /* 获取队列的长度 */\n     public int size() {\n-        int capacity = capacity();\n-        // 由于将数组看作为环形，可能 rear < front ，因此需要取余数\n-        return (capacity + rear - front) % capacity;\n+        return queSize;\n     }\n \n     /* 判断队列是否为空 */\n     public boolean isEmpty() {\n-        return rear - front == 0;\n+        return queSize == 0;\n     }\n \n     /* 入队 */\n     public void offer(int num) {\n-        if (size() == capacity()) {\n+        if (queSize == capacity()) {\n             System.out.println(\"队列已满\");\n             return;\n         }\n+        // 计算尾指针，指向队尾索引 + 1\n+        // 通过取余操作，实现 rear 越过数组尾部后回到头部\n+        int rear = (front + queSize) % capacity();\n         // 尾结点后添加 num\n         nums[rear] = num;\n-        // 尾指针向后移动一位，越过尾部后返回到数组头部\n-        rear = (rear + 1) % capacity();\n+        queSize++;\n     }\n \n     /* 出队 */\n     public int poll() {\n         int num = peek();\n-        // 队头指针向后移动一位，若越过尾部则返回到数组头部\n+        // 队首指针向后移动一位，若越过尾部则返回到数组头部\n         front = (front + 1) % capacity();\n+        queSize--;\n         return num;\n     }\n \n@@ -65,12 +66,10 @@ public int peek() {\n \n     /* 返回数组 */\n     public int[] toArray() {\n-        int size = size();\n-        int capacity = capacity();\n         // 仅转换有效长度范围内的列表元素\n-        int[] res = new int[size];\n-        for (int i = 0, j = front; i < size; i++, j++) {\n-            res[i] = nums[j % capacity];\n+        int[] res = new int[queSize];\n+        for (int i = 0, j = front; i < queSize; i++, j++) {\n+            res[i] = nums[j % capacity()];\n         }\n         return res;\n     }",
    "output": "Fix array queue"
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/my_list.java b/codes/java/chapter_array_and_linkedlist/my_list.java\n--- a/codes/java/chapter_array_and_linkedlist/my_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/my_list.java\n@@ -33,14 +33,14 @@ public int capacity() {\n     /* 访问元素 */\n     public int get(int index) {\n         // 索引如果越界则抛出异常，下同\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         return nums[index];\n     }\n \n     /* 更新元素 */\n     public void set(int index, int num) {\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         nums[index] = num;\n     }\n@@ -57,7 +57,7 @@ public void add(int num) {\n \n     /* 中间插入元素 */\n     public void insert(int index, int num) {\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         // 元素数量超出容量时，触发扩容机制\n         if (size == capacity())\n@@ -73,7 +73,7 @@ public void insert(int index, int num) {\n \n     /* 删除元素 */\n     public int remove(int index) {\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         int num = nums[index];\n         // 将索引 index 之后的元素都向前移动一位",
    "output": "Fix the index out of bound check in my_list"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/linkedlist_deque.java b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n@@ -0,0 +1,184 @@\n+/**\n+ * File: linkedlist_deque.java\n+ * Created Time: 2023-01-20\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_stack_and_queue;\n+\n+import java.util.*;\n+\n+/* 双向链表结点 */\n+class ListNode {\n+    int val;       // 结点值\n+    ListNode next; // 后继结点引用（指针）\n+    ListNode prev; // 前驱结点引用（指针）\n+\n+    ListNode(int val) {\n+        this.val = val;\n+        prev = next = null;\n+    }\n+}\n+\n+/* 基于双向链表实现的双向队列 */\n+class LinkedListDeque {\n+    private ListNode front, rear; // 头结点 front ，尾结点 rear\n+    private int size = 0;         // 双向队列的长度\n+\n+    public LinkedListDeque() {\n+        front = rear = null;\n+    }\n+\n+    /* 获取双向队列的长度 */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /* 判断双向队列是否为空 */\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /* 入队操作 */\n+    private void offer(int num, boolean isFront) {\n+        ListNode node = new ListNode(num);\n+        // 若链表为空，则令 front, rear 都指向 node\n+        if (size() == 0)\n+            front = rear = node;\n+        // 队首入队操作\n+        else if (isFront) {\n+            // 将 node 添加至链表头部\n+            front.prev = node;\n+            node.next = front;\n+            front = node; // 更新头结点\n+        // 队尾入队操作\n+        } else {\n+            // 将 node 添加至链表尾部\n+            rear.next = node;\n+            node.prev = rear;\n+            rear = node;  // 更新尾结点\n+        }\n+        size++; // 更新队列长度\n+    }\n+\n+    /* 队首入队 */\n+    public void offerFirst(int num) {\n+        offer(num, true);\n+    }\n+\n+    /* 队尾入队 */\n+    public void offerLast(int num) {\n+        offer(num, false);\n+    }\n+\n+    /* 出队操作 */\n+    private Integer poll(boolean isFront) {\n+        // 若队列为空，直接返回 null\n+        if (size() == 0)\n+            return null;\n+        int val;\n+        // 队首出队操作\n+        if (isFront) {\n+            val = front.val; // 暂存头结点值\n+            // 删除头结点\n+            ListNode fNext = front.next;\n+            if (fNext != null) {\n+                fNext.prev = null;\n+                front.next = null;\n+            }\n+            front = fNext;   // 更新头结点\n+        // 队尾出队操作\n+        } else {\n+            val = rear.val;  // 暂存尾结点值\n+            // 删除尾结点\n+            ListNode rPrev = rear.prev;\n+            if (rPrev != null) {\n+                rPrev.next = null;\n+                rear.prev = null;\n+            }\n+            rear = rPrev;    // 更新尾结点\n+        }\n+        size--; // 更新队列长度\n+        return val;\n+    }\n+\n+    /* 队首出队 */\n+    public Integer pollFirst() {\n+        return poll(true);\n+    }\n+\n+    /* 队尾出队 */\n+    public Integer pollLast() {\n+        return poll(false);\n+    }\n+\n+    /* 访问队首元素 */\n+    public Integer peekFirst() {\n+        return size() != 0 ? front.val : null;\n+    }\n+\n+    /* 访问队尾元素 */\n+    public Integer peekLast() {\n+        return size() != 0 ? rear.val : null;\n+    }\n+\n+    /* 打印双向队列 */\n+    public void print() {\n+        if (size() == 0) {\n+            System.out.println(\"[ ]\");\n+            return;\n+        }\n+        List<String> list = new ArrayList<>();\n+        ListNode head = front;\n+        while (head != null) {\n+            list.add(String.valueOf(head.val));\n+            head = head.next;\n+        }\n+        System.out.println(\"[\" + String.join(\" <-> \", list) + \"]\");\n+    }\n+}\n+\n+public class linkedlist_deque {\n+    public static void main(String[] args) {\n+        /* 初始化双向队列 */\n+        LinkedListDeque deque = new LinkedListDeque();\n+        System.out.println(\"初始化空队列\");\n+        deque.print();\n+\n+        int[] nums = { 1, 2, 3 }; // 测试数据\n+\n+        /* 队尾入队 */\n+        for (int num : nums) {\n+            deque.offerLast(num);\n+            System.out.printf(\"元素 %d 队尾入队后，队列为\\n\", num);\n+            deque.print();\n+        }\n+        /* 队尾出队 */\n+        while (!deque.isEmpty()) {\n+            int last = deque.pollLast();\n+            System.out.printf(\"队尾出队元素为 %d ，队列为\\n\", last);\n+            deque.print();\n+        }\n+\n+        /* 队首入队 */\n+        for (int num : nums) {\n+            deque.offerFirst(num);\n+            System.out.printf(\"元素 %d 队首入队后，队列为\\n\", num);\n+            deque.print();\n+        }\n+        /* 队首出队 */\n+        while (!deque.isEmpty()) {\n+            int first = deque.pollFirst();\n+            System.out.printf(\"队首出队元素为 %d ，队列为\\n\", first);\n+            deque.print();\n+        }\n+\n+        /* 获取队列的长度 */\n+        int size = deque.size();\n+        System.out.println(\"队列长度 size = \" + size);\n+\n+        /* 判断双向队列是否为空 */\n+        boolean isEmpty = deque.isEmpty();\n+        System.out.println(\"双向队列是否为空 = \" + isEmpty);\n+    }\n+}",
    "output": "Add linkedlist_deque.java"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_tree_bfs.java b/codes/java/chapter_tree/binary_tree_bfs.java\n--- a/codes/java/chapter_tree/binary_tree_bfs.java\n+++ b/codes/java/chapter_tree/binary_tree_bfs.java\n@@ -13,7 +13,7 @@ public class binary_tree_bfs {\n     /* 层序遍历 */\n     static List<Integer> hierOrder(TreeNode root) {\n         // 初始化队列，加入根结点\n-        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n         // 初始化一个列表，用于保存遍历序列\n         List<Integer> list = new ArrayList<>();\n         while (!queue.isEmpty()) {\n\ndiff --git a/codes/java/include/TreeNode.java b/codes/java/include/TreeNode.java\n--- a/codes/java/include/TreeNode.java\n+++ b/codes/java/include/TreeNode.java\n@@ -32,7 +32,7 @@ public static TreeNode listToTree(List<Integer> list) {\n             return null;\n         \n         TreeNode root = new TreeNode(list.get(0));\n-        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n         int i = 0;\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n@@ -58,7 +58,7 @@ public static TreeNode listToTree(List<Integer> list) {\n     public static List<Integer> treeToList(TreeNode root) {\n         List<Integer> list = new ArrayList<>();\n         if(root == null) return list;\n-        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n             if(node != null) {",
    "output": "Add zig codes for Section 'Heap' (heap.zig)"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_tree_bfs.java b/codes/java/chapter_tree/binary_tree_bfs.java\n--- a/codes/java/chapter_tree/binary_tree_bfs.java\n+++ b/codes/java/chapter_tree/binary_tree_bfs.java\n@@ -13,7 +13,7 @@ public class binary_tree_bfs {\n     /* 层序遍历 */\n     static List<Integer> hierOrder(TreeNode root) {\n         // 初始化队列，加入根结点\n-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n         // 初始化一个列表，用于保存遍历序列\n         List<Integer> list = new ArrayList<>();\n         while (!queue.isEmpty()) {\n\ndiff --git a/codes/java/include/TreeNode.java b/codes/java/include/TreeNode.java\n--- a/codes/java/include/TreeNode.java\n+++ b/codes/java/include/TreeNode.java\n@@ -32,7 +32,7 @@ public static TreeNode listToTree(List<Integer> list) {\n             return null;\n         \n         TreeNode root = new TreeNode(list.get(0));\n-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n         int i = 0;\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n@@ -58,7 +58,7 @@ public static TreeNode listToTree(List<Integer> list) {\n     public static List<Integer> treeToList(TreeNode root) {\n         List<Integer> list = new ArrayList<>();\n         if(root == null) return list;\n-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n             if(node != null) {",
    "output": "Fix bugs in java codes using JDK 1.8.0"
  },
  {
    "input": "diff --git a/codes/java/chapter_heap/heap.java b/codes/java/chapter_heap/heap.java\n--- a/codes/java/chapter_heap/heap.java\n+++ b/codes/java/chapter_heap/heap.java\n@@ -12,28 +12,26 @@\n \n public class heap {\n     public static void testPush(Queue<Integer> heap, int val) {\n-        // 元素入堆\n-        heap.add(val);\n-\n+        heap.add(val); // 元素入堆\n         System.out.format(\"\\n添加元素 %d 后\\n\", val);\n         PrintUtil.printHeap(heap);\n     }\n \n     public static void testPoll(Queue<Integer> heap) {\n-        // 元素出堆\n-        int val = heap.poll();\n-\n+        int val = heap.poll(); // 堆顶元素出堆\n         System.out.format(\"\\n出堆元素为 %d\\n\", val);\n         PrintUtil.printHeap(heap);\n     }\n \n     public static void main(String[] args) {\n         /* 初始化堆 */\n-        // 初始化最小堆\n+        // 初始化小顶堆\n         Queue<Integer> minHeap = new PriorityQueue<>();\n-        // 初始化最大堆（使用 lambda 表达式修改 Comparator）\n+        // 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）\n         Queue<Integer> maxHeap = new PriorityQueue<>((a, b) -> { return b - a; });\n \n+        System.out.println(\"\\n以下测试样例为大顶堆\");\n+\n         /* 元素入堆 */\n         testPush(maxHeap, 1);\n         testPush(maxHeap, 3);\n@@ -45,7 +43,7 @@ public static void main(String[] args) {\n         int peek = maxHeap.peek();\n         System.out.format(\"\\n堆顶元素为 %d\\n\", peek);\n \n-        /* 元素出堆 */\n+        /* 堆顶元素出堆 */\n         testPoll(maxHeap);\n         testPoll(maxHeap);\n \n@@ -56,5 +54,11 @@ public static void main(String[] args) {\n         /* 判断堆是否为空 */\n         boolean isEmpty = maxHeap.isEmpty();\n         System.out.format(\"\\n堆是否为空 %b\\n\", isEmpty);\n+\n+        /* 输入列表并建堆 */\n+        // 时间复杂度为 O(n) ，而非 O(nlogn)\n+        minHeap = new PriorityQueue<>(Arrays.asList(1, 3, 2, 5, 4));\n+        System.out.println(\"\\n输入 [1, 3, 2, 5, 4] ，建立小顶堆\");\n+        PrintUtil.printHeap(minHeap);\n     }\n }\n\ndiff --git a/codes/java/chapter_heap/my_heap.java b/codes/java/chapter_heap/my_heap.java\n--- a/codes/java/chapter_heap/my_heap.java\n+++ b/codes/java/chapter_heap/my_heap.java\n@@ -18,13 +18,13 @@ public MaxHeap() {\n         maxHeap = new ArrayList<>();\n     }\n \n-    /* 构造函数，堆化 nums 所有元素 */\n+    /* 构造函数，根据输入列表建堆 */\n     public MaxHeap(List<Integer> nums) {\n-        // 将元素拷贝至堆中\n+        // 所有元素入堆\n         maxHeap = new ArrayList<>(nums);\n         // 堆化除叶结点以外的其他所有结点\n         for (int i = parent(size() - 1); i >= 0; i--) {\n-            heapify(i);\n+            siftDown(i);\n         }\n     }\n \n@@ -40,7 +40,7 @@ private int right(int i) {\n \n     /* 获取父结点索引 */\n     private int parent(int i) {\n-        return (i - 1) / 2;\n+        return (i - 1) / 2; // 向下整除\n     }\n \n     /* 交换元素 */\n@@ -72,12 +72,20 @@ public void push(int val) {\n         // 添加结点\n         maxHeap.add(val);\n         // 从底至顶堆化\n-        int i = size() - 1;\n+        siftUp(size() - 1);\n+    }\n+\n+    /* 从结点 i 开始，从底至顶堆化 */\n+    private void siftUp(int i) {\n         while (true) {\n+            // 获取结点 i 的父结点\n             int p = parent(i);\n+            // 当“越过根结点”或“结点无需修复”时，结束堆化\n             if (p < 0 || maxHeap.get(i) <= maxHeap.get(p))\n                 break;\n+            // 交换两结点\n             swap(i, p);\n+            // 循环向上堆化\n             i = p;\n         }\n     }\n@@ -87,26 +95,28 @@ public int poll() {\n         // 判空处理\n         if (isEmpty())\n             throw new EmptyStackException();\n-        // 交换根结点与右下角（即最后一个）结点\n+        // 交换根结点与最右叶结点（即交换首元素与尾元素）\n         swap(0, size() - 1);\n         // 删除结点\n         int val = maxHeap.remove(size() - 1);\n         // 从顶至底堆化\n-        heapify(0);\n+        siftDown(0);\n         // 返回堆顶元素\n         return val;\n     }\n \n     /* 从结点 i 开始，从顶至底堆化 */\n-    private void heapify(int i) {\n+    private void siftDown(int i) {\n         while (true) {\n             // 判断结点 i, l, r 中值最大的结点，记为 ma ；\n             int l = left(i), r = right(i), ma = i;\n-            if (l < size() && maxHeap.get(l) > maxHeap.get(ma)) ma = l;\n-            if (r < size() && maxHeap.get(r) > maxHeap.get(ma)) ma = r;\n-            // 若结点 i 最大，则无需继续堆化，跳出\n+            if (l < size() && maxHeap.get(l) > maxHeap.get(ma))\n+                ma = l;\n+            if (r < size() && maxHeap.get(r) > maxHeap.get(ma))\n+                ma = r;\n+            // 若结点 i 最大或索引 l, r 越界，则无需继续堆化，跳出\n             if (ma == i) break;\n-            // 交换结点 i 与结点 max\n+            // 交换两结点\n             swap(i, ma);\n             // 循环向下堆化\n             i = ma;\n@@ -124,26 +134,24 @@ public void print() {\n \n public class my_heap {\n     public static void testPush(MaxHeap maxHeap, int val) {\n-        // 元素入堆\n-        maxHeap.push(val);\n-\n+        maxHeap.push(val);  // 元素入堆\n         System.out.format(\"\\n添加元素 %d 后\\n\", val);\n         maxHeap.print();\n     }\n \n     public static void testPoll(MaxHeap maxHeap) {\n-        // 元素出堆\n-        int val = maxHeap.poll();\n-\n+        int val = maxHeap.poll(); // 堆顶元素出堆\n         System.out.format(\"\\n出堆元素为 %d\\n\", val);\n         maxHeap.print();\n     }\n \n     public static void main(String[] args) {\n         /* 初始化堆 */\n-        // 初始化最大堆\n+        // 初始化大顶堆\n         MaxHeap maxHeap = new MaxHeap();\n \n+        System.out.println(\"\\n以下测试样例为大顶堆\");\n+\n         /* 元素入堆 */\n         testPush(maxHeap, 1);\n         testPush(maxHeap, 3);\n@@ -155,7 +163,7 @@ public static void main(String[] args) {\n         int peek = maxHeap.peek();\n         System.out.format(\"\\n堆顶元素为 %d\\n\", peek);\n \n-        /* 元素出堆 */\n+        /* 堆顶元素出堆 */\n         testPoll(maxHeap);\n         testPoll(maxHeap);\n \n@@ -166,5 +174,10 @@ public static void main(String[] args) {\n         /* 判断堆是否为空 */\n         boolean isEmpty = maxHeap.isEmpty();\n         System.out.format(\"\\n堆是否为空 %b\\n\", isEmpty);\n+\n+        /* 将输入列表堆化 */\n+        maxHeap = new MaxHeap(Arrays.asList(1, 3, 2, 5, 4));\n+        System.out.println(\"\\n输入 [1, 3, 2, 5, 4] ，建立大顶堆\");\n+        maxHeap.print();\n     }\n }",
    "output": "Add time complexity in stack, queue, deque. Update heap"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_tree_dfs.java b/codes/java/chapter_tree/binary_tree_dfs.java\n--- a/codes/java/chapter_tree/binary_tree_dfs.java\n+++ b/codes/java/chapter_tree/binary_tree_dfs.java\n@@ -43,7 +43,7 @@ static void postOrder(TreeNode root) {\n     public static void main(String[] args) {\n         /* 初始化二叉树 */\n         // 这里借助了一个从数组直接生成二叉树的函数\n-        TreeNode root = TreeNode.arrToTree(new Integer[] { 1, null, 3, 4, 5 });\n+        TreeNode root = TreeNode.arrToTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });\n         System.out.println(\"\\n初始化二叉树\\n\");\n         PrintUtil.printTree(root);\n ",
    "output": "Fix the test case of the binary tree dfs in Java"
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/array_hash_map.java b/codes/java/chapter_hashing/array_hash_map.java\n--- a/codes/java/chapter_hashing/array_hash_map.java\n+++ b/codes/java/chapter_hashing/array_hash_map.java\n@@ -0,0 +1,138 @@\n+/*\n+ * File: hash_map.java\n+ * Created Time: 2022-12-04\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_hashing;\n+import java.util.*;\n+\n+/* 键值对 int->String */\n+class Entry {\n+    public int key;\n+    public String val;\n+    public Entry(int key, String val) {\n+        this.key = key;\n+        this.val = val;\n+    }\n+}\n+\n+/* 基于数组简易实现的哈希表 */\n+class ArrayHashMap {\n+    private List<Entry> bucket;\n+    public ArrayHashMap() {\n+        // 初始化一个长度为 10 的桶（数组）\n+        bucket = new ArrayList<>(10);\n+        for (int i = 0; i < 10; i++) {\n+            bucket.add(null);\n+        }\n+    }\n+\n+    /* 哈希函数 */\n+    private int hashFunc(int key) {\n+        int index = key % 10000;\n+        return index;\n+    }\n+\n+    /* 查询操作 */\n+    public String get(int key) {\n+        int index = hashFunc(key);\n+        Entry pair = bucket.get(index);\n+        if (pair == null) return null;\n+        return pair.val;\n+    }\n+\n+    /* 添加操作 */\n+    public void put(int key, String val) {\n+        Entry pair = new Entry(key, val);\n+        int index = hashFunc(key);\n+        bucket.set(index, pair);\n+    }\n+\n+    /* 删除操作 */\n+    public void remove(int key) {\n+        int index = hashFunc(key);\n+        // 置为空字符，代表删除\n+        bucket.set(index, null);\n+    }\n+\n+    /* 获取所有键值对 */\n+    public List<Entry> entrySet() {\n+        List<Entry> entrySet = new ArrayList<>();\n+        for (Entry pair : bucket) {\n+            if (pair != null)\n+                entrySet.add(pair);\n+        }\n+        return entrySet;\n+    }\n+\n+    /* 获取所有键 */\n+    public List<Integer> keySet() {\n+        List<Integer> keySet = new ArrayList<>();\n+        for (Entry pair : bucket) {\n+            if (pair != null)\n+                keySet.add(pair.key);\n+        }\n+        return keySet;\n+    }\n+\n+    /* 获取所有值 */\n+    public List<String> valueSet() {\n+        List<String> valueSet = new ArrayList<>();\n+        for (Entry pair : bucket) {\n+            if (pair != null)\n+                valueSet.add(pair.val);\n+        }\n+        return valueSet;\n+    }\n+\n+    /* 打印哈希表 */\n+    public void print() {\n+        for (Entry kv: entrySet()) {\n+            System.out.println(kv.key + \" -> \" + kv.val);\n+        }\n+    }\n+}\n+\n+\n+public class array_hash_map {\n+    public static void main(String[] args) {\n+        /* 初始化哈希表 */\n+        ArrayHashMap map = new ArrayHashMap();\n+\n+        /* 添加操作 */\n+        // 在哈希表中添加键值对 (key, value)\n+        map.put(10001, \"小哈\");   \n+        map.put(10002, \"小啰\");   \n+        map.put(10003, \"小算\");   \n+        map.put(10004, \"小法\");\n+        map.put(10005, \"小哇\");\n+        System.out.println(\"\\n添加完成后，哈希表为\\nKey -> Value\");\n+        map.print();\n+\n+        /* 查询操作 */\n+        // 向哈希表输入键 key ，得到值 value\n+        String name = map.get(10002);\n+        System.out.println(\"\\n输入学号 10002 ，查询到姓名 \" + name);\n+\n+        /* 删除操作 */\n+        // 在哈希表中删除键值对 (key, value)\n+        map.remove(10005);\n+        System.out.println(\"\\n删除 10005 后，哈希表为\\nKey -> Value\");\n+        map.print();\n+\n+        /* 遍历哈希表 */\n+        System.out.println(\"\\n遍历键值对 Key->Value\");\n+        for (Entry kv: map.entrySet()) {\n+            System.out.println(kv.key + \" -> \" + kv.val);\n+        }\n+        System.out.println(\"\\n单独遍历键 Key\");\n+        for (int key: map.keySet()) {\n+            System.out.println(key);\n+        }\n+        System.out.println(\"\\n单独遍历值 Value\");\n+        for (String val: map.valueSet()) {\n+            System.out.println(val);\n+        }\n+    }\n+}\n\ndiff --git a/codes/java/chapter_hashing/hash_map.java b/codes/java/chapter_hashing/hash_map.java\n--- a/codes/java/chapter_hashing/hash_map.java\n+++ b/codes/java/chapter_hashing/hash_map.java\n@@ -0,0 +1,51 @@\n+/*\n+ * File: hash_map.java\n+ * Created Time: 2022-12-04\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_hashing;\n+import java.util.*;\n+import include.*;\n+\n+public class hash_map {\n+    public static void main(String[] args) {\n+        /* 初始化哈希表 */\n+        Map<Integer, String> map = new HashMap<>();\n+\n+        /* 添加操作 */\n+        // 在哈希表中添加键值对 (key, value)\n+        map.put(10001, \"小哈\");   \n+        map.put(10002, \"小啰\");   \n+        map.put(10003, \"小算\");   \n+        map.put(10004, \"小法\");\n+        map.put(10005, \"小哇\");\n+        System.out.println(\"\\n添加完成后，哈希表为\\nKey -> Value\");\n+        PrintUtil.printHashMap(map);\n+\n+        /* 查询操作 */\n+        // 向哈希表输入键 key ，得到值 value\n+        String name = map.get(10002);\n+        System.out.println(\"\\n输入学号 10002 ，查询到姓名 \" + name);\n+\n+        /* 删除操作 */\n+        // 在哈希表中删除键值对 (key, value)\n+        map.remove(10005);\n+        System.out.println(\"\\n删除 10005 后，哈希表为\\nKey -> Value\");\n+        PrintUtil.printHashMap(map);\n+\n+        /* 遍历哈希表 */\n+        System.out.println(\"\\n遍历键值对 Key->Value\");\n+        for (Map.Entry <Integer, String> kv: map.entrySet()) {\n+            System.out.println(kv.getKey() + \" -> \" + kv.getValue());\n+        }\n+        System.out.println(\"\\n单独遍历键 Key\");\n+        for (int key: map.keySet()) {\n+            System.out.println(key);\n+        }\n+        System.out.println(\"\\n单独遍历值 Value\");\n+        for (String val: map.values()) {\n+            System.out.println(val);\n+        }\n+    }\n+}\n\ndiff --git a/codes/java/include/PrintUtil.java b/codes/java/include/PrintUtil.java\n--- a/codes/java/include/PrintUtil.java\n+++ b/codes/java/include/PrintUtil.java\n@@ -91,4 +91,16 @@ public static void showTrunks(Trunk p) {\n         showTrunks(p.prev);\n         System.out.print(p.str);\n     }\n+\n+    /**\n+     * Print a hash map\n+     * @param <K>\n+     * @param <V>\n+     * @param map\n+     */\n+    public static <K, V> void printHashMap(Map<K, V> map) {\n+        for (Map.Entry <K, V> kv: map.entrySet()) {\n+            System.out.println(kv.getKey() + \" -> \" + kv.getValue());\n+        }\n+    }\n }",
    "output": "Add the chapter of hash map"
  },
  {
    "input": "diff --git a/codes/java/include/TreeNode.java b/codes/java/include/TreeNode.java\n--- a/codes/java/include/TreeNode.java\n+++ b/codes/java/include/TreeNode.java\n@@ -26,6 +26,9 @@ public TreeNode(int x) {\n      * @return\n      */\n     public static TreeNode arrToTree(Integer[] arr) {\n+        if (arr.length == 0)\n+            return null;\n+        \n         TreeNode root = new TreeNode(arr[0]);\n         Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n         int i = 1;",
    "output": "Fix the util of array to tree"
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/my_list.java b/codes/java/chapter_array_and_linkedlist/my_list.java\n--- a/codes/java/chapter_array_and_linkedlist/my_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/my_list.java\n@@ -56,13 +56,13 @@ public void add(int num) {\n     }\n \n     /* 中间插入元素 */\n-    public void add(int index, int num) {\n+    public void insert(int index, int num) {\n         if (index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         // 元素数量超出容量时，触发扩容机制\n         if (size == capacity())\n             extendCapacity();\n-        // 索引 i 以及之后的元素都向后移动一位\n+        // 将索引 index 以及之后的元素都向后移动一位\n         for (int j = size - 1; j >= index; j--) {\n             nums[j + 1] = nums[j];\n         }\n@@ -72,15 +72,18 @@ public void add(int index, int num) {\n     }\n \n     /* 删除元素 */\n-    public void remove(int index) {\n+    public int remove(int index) {\n         if (index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n-        // 索引 i 之后的元素都向前移动一位\n+        int num = nums[index];\n+        // 将索引 index 之后的元素都向前移动一位\n         for (int j = index; j < size - 1; j++) {\n             nums[j] = nums[j + 1];\n         }\n         // 更新元素数量\n         size--;\n+        // 返回被删除元素\n+        return num;\n     }\n \n     /* 列表扩容 */\n@@ -118,7 +121,7 @@ public static void main(String[] args) {\n                            \" ，容量 = \" + list.capacity() + \" ，长度 = \" + list.size());\n \n         /* 中间插入元素 */\n-        list.add(3, 6);\n+        list.insert(3, 6);\n         System.out.println(\"在索引 3 处插入数字 6 ，得到 list = \" + Arrays.toString(list.toArray()));\n \n         /* 删除元素 */\n\ndiff --git a/codes/java/chapter_stack_and_queue/array_queue.java b/codes/java/chapter_stack_and_queue/array_queue.java\n--- a/codes/java/chapter_stack_and_queue/array_queue.java\n+++ b/codes/java/chapter_stack_and_queue/array_queue.java\n@@ -50,11 +50,8 @@ public void offer(int num) {\n \n     /* 出队 */\n     public int poll() {\n-        // 删除头结点\n-        if (isEmpty())\n-            throw new EmptyStackException();\n-        int num = nums[front];\n-        // 队头指针向后移动，越过尾部后返回到数组头部\n+        int num = peek();\n+        // 队头指针向后移动一位，若越过尾部则返回到数组头部\n         front = (front + 1) % capacity();\n         return num;\n     }",
    "output": "Add python code of chapter queue to docs"
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/my_list.java b/codes/java/chapter_array_and_linkedlist/my_list.java\n--- a/codes/java/chapter_array_and_linkedlist/my_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/my_list.java\n@@ -10,14 +10,14 @@\n \n /* 列表类简易实现 */\n class MyList {\n-    int[] nums;               // 数组（存储列表元素）\n-    int initialCapacity = 10; // 列表初始容量\n-    int size = 0;             // 列表长度（即当前元素数量）\n-    int extendRatio = 2;      // 每次列表扩容的倍数\n+    private int[] nums;           // 数组（存储列表元素）\n+    private int capacity = 10;    // 列表容量\n+    private int size = 0;         // 列表长度（即当前元素数量）\n+    private int extendRatio = 2;  // 每次列表扩容的倍数\n \n     /* 构造函数 */\n     public MyList() {\n-        nums = new int[initialCapacity];\n+        nums = new int[capacity];\n     }\n \n     /* 获取列表长度（即当前元素数量）*/\n@@ -27,7 +27,7 @@ public int size() {\n \n     /* 获取列表容量 */\n     public int capacity() {\n-        return nums.length;\n+        return capacity;\n     }\n \n     /* 访问元素 */\n@@ -48,7 +48,7 @@ public void set(int index, int num) {\n     /* 尾部添加元素 */\n     public void add(int num) {\n         // 元素数量超出容量时，触发扩容机制\n-        if (size == nums.length)\n+        if (size == capacity())\n             extendCapacity();\n         nums[size] = num;\n         // 更新元素数量\n@@ -60,7 +60,7 @@ public void add(int index, int num) {\n         if (index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         // 元素数量超出容量时，触发扩容机制\n-        if (size == nums.length)\n+        if (size == capacity())\n             extendCapacity();\n         // 索引 i 以及之后的元素都向后移动一位\n         for (int j = size - 1; j >= index; j--) {\n@@ -86,7 +86,9 @@ public void remove(int index) {\n     /* 列表扩容 */\n     public void extendCapacity() {\n         // 新建一个长度为 size 的数组，并将原数组拷贝到新数组\n-        nums = Arrays.copyOf(nums, nums.length * extendRatio);\n+        nums = Arrays.copyOf(nums, capacity() * extendRatio);\n+        // 更新列表容量\n+        capacity = nums.length;\n     }\n \n     /* 将列表转换为数组 */",
    "output": "Add C++ codes for the chapter\narray and linked list"
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/leetcode_two_sum.java b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n--- a/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n+++ b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n@@ -8,9 +8,10 @@\n \n import java.util.*;\n \n-class solution_brute_force {\n+class SolutionBruteForce {\n     public int[] twoSum(int[] nums, int target) {\n         int size = nums.length;\n+        // 两层循环，时间复杂度 O(n^2)\n         for (int i = 0; i < size - 1; i++) {\n             for (int j = i + 1; j < size; j++) {\n                 if (nums[i] + nums[j] == target)\n@@ -21,10 +22,12 @@ public int[] twoSum(int[] nums, int target) {\n     }\n }\n \n-class solution_hash_map {\n+class SolutionHashMap {\n     public int[] twoSum(int[] nums, int target) {\n         int size = nums.length;\n+        // 辅助哈希表，空间复杂度 O(n)\n         Map<Integer, Integer> dic = new HashMap<>();\n+        // 单层循环，时间复杂度 O(n)\n         for (int i = 0; i < size; i++) {\n             if (dic.containsKey(target - nums[i])) {\n                 return new int[] { dic.get(target - nums[i]), i };\n@@ -43,11 +46,11 @@ public static void main(String[] args) {\n         \n         // ====== Driver Code ======\n         // 方法一\n-        solution_brute_force slt1 = new solution_brute_force();\n+        SolutionBruteForce slt1 = new SolutionBruteForce();\n         int[] res = slt1.twoSum(nums, target);\n         System.out.println(Arrays.toString(res));\n         // 方法二\n-        solution_hash_map slt2 = new solution_hash_map();\n+        SolutionHashMap slt2 = new SolutionHashMap();\n         res = slt2.twoSum(nums, target);\n         System.out.println(Arrays.toString(res));\n     }\n\ndiff --git a/codes/java/chapter_computational_complexity/space_complexity_types.java b/codes/java/chapter_computational_complexity/space_complexity_types.java\n--- a/codes/java/chapter_computational_complexity/space_complexity_types.java\n+++ b/codes/java/chapter_computational_complexity/space_complexity_types.java\n@@ -100,7 +100,7 @@ public static void main(String[] args) {\n         quadratic(n);\n         quadraticRecur(n);\n         // 指数阶\n-        TreeNode tree = buildTree(n);\n-        PrintUtil.printTree(tree);\n+        TreeNode root = buildTree(n);\n+        PrintUtil.printTree(root);\n     }\n }\n\ndiff --git a/codes/java/chapter_computational_complexity/time_complexity_types.java b/codes/java/chapter_computational_complexity/time_complexity_types.java\n--- a/codes/java/chapter_computational_complexity/time_complexity_types.java\n+++ b/codes/java/chapter_computational_complexity/time_complexity_types.java\n@@ -29,7 +29,6 @@ static int arrayTraversal(int[] nums) {\n         int count = 0;\n         // 循环次数与数组长度成正比\n         for (int num : nums) {\n-            // System.out.println(num);\n             count++;\n         }\n         return count;\n@@ -38,6 +37,7 @@ static int arrayTraversal(int[] nums) {\n     /* 平方阶 */\n     static int quadratic(int n) {\n         int count = 0;\n+        // 循环次数与数组长度成平方关系\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n                 count++;\n@@ -47,18 +47,22 @@ static int quadratic(int n) {\n     }\n \n     /* 平方阶（冒泡排序） */\n-    static void bubbleSort(int[] nums) {\n-        int n = nums.length;\n-        for (int i = 0; i < n - 1; i++) {\n-            for (int j = 0; j < n - 1 - i; j++) {\n+    static int bubbleSort(int[] nums) {\n+        int count = 0;  // 计数器\n+        // 外循环：待排序元素数量为 n-1, n-2, ..., 1\n+        for (int i = nums.length - 1; i > 0; i--) {\n+            // 内循环：冒泡操作\n+            for (int j = 0; j < i; j++) {\n                 if (nums[j] > nums[j + 1]) {\n-                    // 交换 nums[j] 和 nums[j + 1]\n+                    // 交换 nums[j] 与 nums[j + 1]\n                     int tmp = nums[j];\n                     nums[j] = nums[j + 1];\n                     nums[j + 1] = tmp;\n+                    count += 3;  // 元素交换包含 3 个单元操作\n                 }\n             }\n         }\n+        return count;\n     }\n \n     /* 指数阶（循环实现） */\n@@ -135,6 +139,11 @@ public static void main(String[] args) {\n \n         count = quadratic(n);\n         System.out.println(\"平方阶的计算操作数量 = \" + count);\n+        int[] nums = new int[n];\n+        for (int i = 0; i < n; i++)\n+            nums[i] = n - i;  // [n,n-1,...,2,1]\n+        count = bubbleSort(nums);\n+        System.out.println(\"平方阶（冒泡排序）的计算操作数量 = \" + count);\n \n         count = exponential(n);\n         System.out.println(\"指数阶（循环实现）的计算操作数量 = \" + count);",
    "output": "Add python codes and for the chapter of\ncomputational complexity.\nUpdate Java codes.\nUpdate Contributors"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/merge_sort.java b/codes/java/chapter_sorting/merge_sort.java\n--- a/codes/java/chapter_sorting/merge_sort.java\n+++ b/codes/java/chapter_sorting/merge_sort.java\n@@ -9,10 +9,14 @@ public class merge_sort {\n      * 右子数组区间 [mid + 1, right]\n      */\n     static void merge(int[] nums, int left, int mid, int right) {\n-        int[] tmp = Arrays.copyOfRange(nums, left, right + 1);     // 初始化辅助数组\n-        int leftStart = left - left, leftEnd = mid - left,         // 左子数组的起始索引和结束索引\n-            rightStart = mid + 1 - left, rightEnd = right - left;  // 右子数组的起始索引和结束索引\n-        int i = leftStart, j = rightStart;                // i,j 分别指向左子数组、右子数组的首元素\n+        // 初始化辅助数组\n+        int[] tmp = Arrays.copyOfRange(nums, left, right + 1);   \n+        // 左子数组的起始索引和结束索引  \n+        int leftStart = left - left, leftEnd = mid - left;\n+        // 右子数组的起始索引和结束索引       \n+        int rightStart = mid + 1 - left, rightEnd = right - left;\n+        // i, j 分别指向左子数组、右子数组的首元素\n+        int i = leftStart, j = rightStart;                \n         // 通过覆盖原数组 nums 来合并左子数组和右子数组\n         for (int k = left; k <= right; k++) {\n             // 若 “左子数组已全部合并完”，则选取右子数组元素，并且 j++",
    "output": "Add merge sort, and sorting algorithm"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/bubble_sort.java b/codes/java/chapter_sorting/bubble_sort.java\n--- a/codes/java/chapter_sorting/bubble_sort.java\n+++ b/codes/java/chapter_sorting/bubble_sort.java\n@@ -0,0 +1,50 @@\n+package chapter_sorting;\n+\n+import java.util.*;\n+\n+public class bubble_sort {\n+    /* 冒泡排序 */\n+    static void bubbleSort(int[] nums) {\n+        // 外循环：待排序元素数量为 n-1, n-2, ..., 1\n+        for (int i = nums.length - 1; i > 0; i--) {\n+            // 内循环：冒泡操作\n+            for (int j = 0; j < i; j++) {\n+                if (nums[j] > nums[j + 1]) {\n+                    // 交换 nums[j] 与 nums[j + 1]\n+                    int tmp = nums[j];\n+                    nums[j] = nums[j + 1];\n+                    nums[j + 1] = tmp;\n+                }\n+            }\n+        }\n+    }\n+\n+    /* 冒泡排序（标志优化）*/\n+    static void bubbleSortWithFlag(int[] nums) {\n+        // 外循环：待排序元素数量为 n-1, n-2, ..., 1\n+        for (int i = nums.length - 1; i > 0; i--) {\n+            boolean flag = false; // 初始化标志位\n+            // 内循环：冒泡操作\n+            for (int j = 0; j < i; j++) {\n+                if (nums[j] > nums[j + 1]) {\n+                    // 交换 nums[j] 与 nums[j + 1]\n+                    int tmp = nums[j];\n+                    nums[j] = nums[j + 1];\n+                    nums[j + 1] = tmp;\n+                    flag = true;  // 记录交换元素\n+                }\n+            }\n+            if (!flag) break;     // 此轮冒泡未交换任何元素，直接跳出\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 4, 1, 3, 1, 5, 2 };\n+        bubbleSort(nums);\n+        System.out.println(\"排序后数组 nums = \" + Arrays.toString(nums));\n+\n+        int[] nums1 = { 4, 1, 3, 1, 5, 2 };\n+        bubbleSortWithFlag(nums1);\n+        System.out.println(\"排序后数组 nums1 = \" + Arrays.toString(nums));\n+    }\n+}\n\ndiff --git a/codes/java/chapter_sorting/insertion_sort.java b/codes/java/chapter_sorting/insertion_sort.java\n--- a/codes/java/chapter_sorting/insertion_sort.java\n+++ b/codes/java/chapter_sorting/insertion_sort.java\n@@ -0,0 +1,25 @@\n+package chapter_sorting;\n+\n+import java.util.*;\n+\n+public class insertion_sort {\n+    /* 插入排序 */\n+    static void insertionSort(int[] nums) {\n+        // 外循环：base = nums[1], nums[2], ..., nums[n-1]\n+        for (int i = 1; i < nums.length; i++) {\n+            int base = nums[i], j = i - 1;\n+            // 内循环：将 base 插入到左边的正确位置\n+            while (j >= 0 && nums[j] > base) {\n+                nums[j + 1] = nums[j];  // 1. 将 nums[j] 向右移动一位\n+                j--;\n+            }\n+            nums[j + 1] = base;         // 2. 将 base 赋值到正确位置\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 4, 1, 3, 1, 5, 2 };\n+        insertionSort(nums);\n+        System.out.println(\"排序后数组 nums = \" + Arrays.toString(nums));\n+    }\n+}",
    "output": "Add bubble sort, insertion sort"
  },
  {
    "input": "diff --git a/codes/java/chapter_searching/binary_search.java b/codes/java/chapter_searching/binary_search.java\n--- a/codes/java/chapter_searching/binary_search.java\n+++ b/codes/java/chapter_searching/binary_search.java\n@@ -0,0 +1,52 @@\n+package chapter_searching;\n+\n+public class binary_search {\n+    /* 二分查找（双闭区间） */\n+    static int binarySearch(int[] nums, int target) {\n+        // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素\n+        int i = 0, j = nums.length - 1;\n+        // 循环，当搜索区间为空时跳出（当 i > j 时为空）\n+        while (i <= j) {\n+            int m = (i + j) / 2;       // 计算中点索引 m\n+            if (nums[m] < target)      // 此情况说明 target 在区间 [m+1, j] 中\n+                i = m + 1;\n+            else if (nums[m] > target) // 此情况说明 target 在区间 [i, m-1] 中\n+                j = m - 1;\n+            else                       // 找到目标元素，返回其索引\n+                return m;\n+        }\n+        // 未找到目标元素，返回 -1\n+        return -1;\n+    }\n+\n+    /* 二分查找（左闭右开） */\n+    static int binarySearch1(int[] nums, int target) {\n+        // 初始化左闭右开 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1\n+        int i = 0, j = nums.length;\n+        // 循环，当搜索区间为空时跳出（当 i = j 时为空）\n+        while (i < j) {\n+            int m = (i + j) / 2;       // 计算中点索引 m\n+            if (nums[m] < target)      // 此情况说明 target 在区间 [m+1, j) 中\n+                i = m + 1;\n+            else if (nums[m] > target) // 此情况说明 target 在区间 [i, m) 中\n+                j = m;\n+            else                       // 找到目标元素，返回其索引\n+                return m;\n+        }\n+        // 未找到目标元素，返回 -1\n+        return -1;\n+    }\n+    \n+    public static void main(String[] args) {\n+        int target = 6;\n+        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 67, 70, 92 };\n+        \n+        /* 二分查找（双闭区间） */\n+        int index = binarySearch(nums, target);\n+        System.out.println(\"目标元素 6 的索引 = \" + index);\n+\n+        /* 二分查找（左闭右开） */\n+        index = binarySearch1(nums, target);\n+        System.out.println(\"目标元素 6 的索引 = \" + index);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_searching/hashing_search.java b/codes/java/chapter_searching/hashing_search.java\n--- a/codes/java/chapter_searching/hashing_search.java\n+++ b/codes/java/chapter_searching/hashing_search.java\n@@ -0,0 +1,45 @@\n+package chapter_searching;\n+\n+import include.*;\n+import java.util.*;\n+\n+public class hashing_search {\n+    /* 哈希查找（数组） */\n+    static int hashingSearch(Map<Integer, Integer> map, int target) {\n+        // 哈希表的 key: 目标元素，value: 索引\n+        // 若哈希表中无此 key ，返回 -1\n+        return map.getOrDefault(target, -1);\n+    }\n+\n+    /* 哈希查找（链表） */\n+    static ListNode hashingSearch1(Map<Integer, ListNode> map, int target) {\n+        // 哈希表的 key: 目标结点值，value: 结点对象\n+        // 若哈希表中无此 key ，返回 -1\n+        return map.getOrDefault(target, null);\n+    }\n+\n+    public static void main(String[] args) {\n+        int target = 3;\n+\n+        /* 哈希查找（数组） */\n+        int[] nums = { 1, 5, 3, 2, 4, 7, 5, 9, 10, 8 };\n+        // 初始化哈希表\n+        Map<Integer, Integer> map = new HashMap<>();\n+        for (int i = 0; i < nums.length; i++) {\n+            map.put(nums[i], i);  // key: 元素，value: 索引\n+        }\n+        int index = hashingSearch(map, target);\n+        System.out.println(\"目标元素 3 的索引 = \" + index);\n+\n+        /* 哈希查找（链表） */\n+        ListNode head = ListNode.arrToLinkedList(nums);\n+        // 初始化哈希表\n+        Map<Integer, ListNode> map1 = new HashMap<>();\n+        while (head != null) {\n+            map1.put(head.val, head);  // key: 结点值，value: 结点\n+            head = head.next;\n+        }\n+        ListNode node = hashingSearch1(map1, target);\n+        System.out.println(\"目标结点值 3 的对应结点对象为 \" + node);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_searching/linear_search.java b/codes/java/chapter_searching/linear_search.java\n--- a/codes/java/chapter_searching/linear_search.java\n+++ b/codes/java/chapter_searching/linear_search.java\n@@ -0,0 +1,45 @@\n+package chapter_searching;\n+\n+import include.*;\n+\n+public class linear_search {\n+\n+    /* 线性查找（数组） */\n+    static int linearSearch(int[] nums, int target) {\n+        // 遍历数组\n+        for (int i = 0; i < nums.length; i++) {\n+            // 找到目标元素，返回其索引\n+            if (nums[i] == target)\n+                return i;\n+        }\n+        // 未找到目标元素，返回 -1\n+        return -1;\n+    }\n+\n+    /* 线性查找（链表） */\n+    static ListNode linearSearch(ListNode head, int target) {\n+        // 遍历链表\n+        while (head != null) {\n+            // 找到目标结点，返回之\n+            if (head.val == target)\n+                return head;\n+            head = head.next;\n+        }\n+        // 未找到目标结点，返回 null\n+        return null;\n+    }\n+\n+    public static void main(String[] args) {\n+        int target = 3;\n+\n+        /* 在数组中执行线性查找 */\n+        int[] nums = { 1, 5, 3, 2, 4, 7, 5, 9, 10, 8 };\n+        int index = linearSearch(nums, target);\n+        System.out.println(\"目标元素 3 的索引 = \" + index);\n+\n+        /* 在链表中执行线性查找 */\n+        ListNode head = ListNode.arrToLinkedList(nums);\n+        ListNode node = linearSearch(head, target);\n+        System.out.println(\"目标结点值 3 的对应结点对象为 \" + node);\n+    }\n+}",
    "output": "Add the chapter of searching"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -0,0 +1,146 @@\n+package chapter_tree;\n+\n+import java.util.*;\n+import include.*;\n+\n+class BinarySearchTree {\n+    private TreeNode root;\n+\n+    public BinarySearchTree(int[] nums) {\n+        Arrays.sort(nums); // 排序数组\n+        root = buildTree(nums, 0, nums.length - 1);  // 构建二叉搜索树\n+    }\n+\n+    /* 获取二叉树根结点 */\n+    public TreeNode getRoot() {\n+        return root;\n+    }\n+\n+    /* 构建二叉搜索树 */\n+    public TreeNode buildTree(int[] nums, int i, int j) {\n+        if (i > j) return null;\n+        // 将数组中间结点作为根结点\n+        int mid = (i + j) / 2;\n+        TreeNode root = new TreeNode(nums[mid]);\n+        // 递归建立左子树和右子树\n+        root.left = buildTree(nums, i, mid - 1);\n+        root.right = buildTree(nums, mid + 1, j);\n+        return root;\n+    }\n+\n+    /* 查找结点 */\n+    public TreeNode search(int num) {\n+        TreeNode cur = root;\n+        // 循环查找，越过叶结点后跳出\n+        while (cur != null) {\n+            // 目标结点在 root 的右子树中\n+            if (cur.val < num) cur = cur.right;\n+            // 目标结点在 root 的左子树中\n+            else if (cur.val > num) cur = cur.left;\n+            // 找到目标结点，跳出循环\n+            else break;\n+        }\n+        // 返回目标结点\n+        return cur;\n+    }\n+\n+    /* 插入结点 */\n+    public TreeNode insert(int num) {\n+        // 若树为空，直接提前返回\n+        if (root == null) return null;\n+        TreeNode cur = root, pre = null;\n+        // 循环查找，越过叶结点后跳出\n+        while (cur != null) {\n+            // 找到重复结点，直接返回\n+            if (cur.val == num) return null;\n+            pre = cur;\n+            // 插入位置在 root 的右子树中\n+            if (cur.val < num) cur = cur.right;\n+            // 插入位置在 root 的左子树中\n+            else cur = cur.left;\n+        }\n+        // 插入结点 val\n+        TreeNode node = new TreeNode(num);\n+        if (pre.val < num) pre.right = node;\n+        else pre.left = node;\n+        return node;\n+    }\n+\n+    /* 删除结点 */\n+    public TreeNode remove(int num) {\n+        // 若树为空，直接提前返回\n+        if (root == null) return null;\n+        TreeNode cur = root, pre = null;\n+        // 循环查找，越过叶结点后跳出\n+        while (cur != null) {\n+            // 找到待删除结点，跳出循环\n+            if (cur.val == num) break;\n+            pre = cur;\n+            // 待删除结点在 root 的右子树中\n+            if (cur.val < num) cur = cur.right;\n+            // 待删除结点在 root 的左子树中\n+            else cur = cur.left;\n+        }\n+        // 若无待删除结点，则直接返回\n+        if (cur == null) return null;\n+        // 子结点数量 = 0 or 1\n+        if (cur.left == null || cur.right == null) {\n+            // 当子结点数量 = 0 / 1 时， child = null / 该子结点\n+            TreeNode child = cur.left != null ? cur.left : cur.right;\n+            // 删除结点 cur\n+            if (pre.left == cur) pre.left = child;\n+            else pre.right = child;\n+        }\n+        // 子结点数量 = 2\n+        else {\n+            // 获取中序遍历中 cur 的下一个结点\n+            TreeNode nex = min(cur.right);\n+            int tmp = nex.val;\n+            // 递归删除结点 nex\n+            remove(nex.val);\n+            // 将 nex 的值复制给 cur\n+            cur.val = tmp;\n+        }\n+        return cur;\n+    }\n+\n+    /* 获取最小结点 */\n+    public TreeNode min(TreeNode root) {\n+        if (root == null) return root;\n+        // 循环访问左子结点，直到叶结点时为最小结点，跳出\n+        while (root.left != null) {\n+            root = root.left;\n+        }\n+        return root;\n+    }\n+}\n+\n+public class binary_search_tree {\n+    public static void main(String[] args) {\n+        /* 初始化二叉搜索树 */\n+        int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+        BinarySearchTree bst = new BinarySearchTree(nums);\n+        System.out.println(\"\\n初始化的二叉树为\\n\");\n+        PrintUtil.printTree(bst.getRoot());\n+\n+        /* 查找结点 */\n+        TreeNode node = bst.search(5);\n+        System.out.println(\"\\n查找到的结点对象为 \" + node + \"，结点值 = \" + node.val);\n+\n+        /* 插入结点 */\n+        node = bst.insert(16);\n+        System.out.println(\"\\n插入结点 16 后，二叉树为\\n\");\n+        PrintUtil.printTree(bst.getRoot());\n+\n+        /* 删除结点 */\n+        bst.remove(1);\n+        System.out.println(\"\\n删除结点 1 后，二叉树为\\n\");\n+        PrintUtil.printTree(bst.getRoot());\n+        bst.remove(2);\n+        System.out.println(\"\\n删除结点 2 后，二叉树为\\n\");\n+        PrintUtil.printTree(bst.getRoot());\n+        bst.remove(4);\n+        System.out.println(\"\\n删除结点 4 后，二叉树为\\n\");\n+        PrintUtil.printTree(bst.getRoot());\n+    }\n+}",
    "output": "Add section of binary search tree.\nMake all table align center"
  }
]