[
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelay.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelay.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelay.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelay.java\n@@ -111,7 +111,9 @@ final class OnNext implements Runnable {\n \n             @Override\n             public void run() {\n-                downstream.onNext(t);\n+                if (!w.isDisposed()) {\n+                    downstream.onNext(t);\n+                }\n             }\n         }\n \n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDelay.java b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDelay.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDelay.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDelay.java\n@@ -111,7 +111,9 @@ final class OnNext implements Runnable {\n \n             @Override\n             public void run() {\n-                downstream.onNext(t);\n+                if (!w.isDisposed()) {\n+                    downstream.onNext(t);\n+                }\n             }\n         }\n \n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelayTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelayTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelayTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelayTest.java\n@@ -20,6 +20,7 @@\n import java.util.*;\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.*;\n+import java.util.concurrent.locks.LockSupport;\n \n import org.junit.*;\n import org.mockito.InOrder;\n@@ -28,6 +29,7 @@\n import io.reactivex.rxjava3.core.*;\n import io.reactivex.rxjava3.exceptions.TestException;\n import io.reactivex.rxjava3.functions.*;\n+import io.reactivex.rxjava3.internal.disposables.SequentialDisposable;\n import io.reactivex.rxjava3.internal.functions.Functions;\n import io.reactivex.rxjava3.processors.PublishProcessor;\n import io.reactivex.rxjava3.schedulers.*;\n@@ -1030,4 +1032,38 @@ public Publisher<Object> apply(Integer t) throws Exception {\n         .to(TestHelper.<Integer>testConsumer())\n         .assertFailureAndMessage(NullPointerException.class, \"The itemDelay returned a null Publisher\");\n     }\n+\n+    @Test\n+    public void cancelShouldPreventRandomSubsequentEmissions() {\n+        for (int attempt = 1; attempt < 100; attempt ++) {\n+\n+            SequentialDisposable disposable = new SequentialDisposable();\n+            ConcurrentLinkedQueue<Integer> sink = new ConcurrentLinkedQueue<>();\n+\n+            disposable.replace(\n+                Flowable.range(1, 10)\n+                .delay(1, TimeUnit.MICROSECONDS, Schedulers.computation(), true)\n+                .doOnNext(v -> {\n+                    if (v == 1) {\n+                        Schedulers.computation().scheduleDirect(disposable::dispose);\n+                    }\n+                    sink.offer(v);\n+                })\n+            .subscribe());\n+\n+            LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(1));\n+\n+            Integer last = null;\n+\n+            while (!sink.isEmpty()) {\n+                Integer current = sink.poll();\n+\n+                if (last != null && last + 1 != current) {\n+                    fail(\"Emission hole: \" + last + \" -> \" + current);\n+                }\n+\n+                last = current;\n+            }\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDelayTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDelayTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDelayTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDelayTest.java\n@@ -20,6 +20,7 @@\n import java.util.*;\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.LockSupport;\n \n import org.junit.*;\n import org.mockito.InOrder;\n@@ -29,6 +30,7 @@\n import io.reactivex.rxjava3.core.Observer;\n import io.reactivex.rxjava3.exceptions.TestException;\n import io.reactivex.rxjava3.functions.*;\n+import io.reactivex.rxjava3.internal.disposables.SequentialDisposable;\n import io.reactivex.rxjava3.internal.functions.Functions;\n import io.reactivex.rxjava3.observers.*;\n import io.reactivex.rxjava3.schedulers.*;\n@@ -978,4 +980,37 @@ public Observable<Object> apply(Integer t) throws Exception {\n         .to(TestHelper.<Integer>testConsumer())\n         .assertFailureAndMessage(NullPointerException.class, \"The itemDelay returned a null ObservableSource\");\n     }\n-}\n+\n+    @Test\n+    public void cancelShouldPreventRandomSubsequentEmissions() {\n+        for (int attempt = 1; attempt < 100; attempt ++) {\n+\n+            SequentialDisposable disposable = new SequentialDisposable();\n+            ConcurrentLinkedQueue<Integer> sink = new ConcurrentLinkedQueue<>();\n+\n+            disposable.replace(\n+                Observable.range(1, 10)\n+                .delay(1, TimeUnit.MICROSECONDS, Schedulers.computation(), true)\n+                .doOnNext(v -> {\n+                    if (v == 1) {\n+                        Schedulers.computation().scheduleDirect(disposable::dispose);\n+                    }\n+                    sink.offer(v);\n+                })\n+            .subscribe());\n+\n+            LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(1));\n+\n+            Integer last = null;\n+\n+            while (!sink.isEmpty()) {\n+                Integer current = sink.poll();\n+\n+                if (last != null && last + 1 != current) {\n+                    fail(\"Emission hole: \" + last + \" -> \" + current);\n+                }\n+\n+                last = current;\n+            }\n+        }\n+    }}",
    "output": "Fix delay-cancellation race producing random subsequent emissions"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java\n@@ -138,9 +138,12 @@ public void onSubscribe(Subscription s) {\n         @Override\n         public void onNext(T t) {\n             if (!queue.offer(t)) {\n+                // Error must be set first before calling cancel to avoid race\n+                // with hasNext(), which checks for cancel first before checking\n+                // for error.\n+                error = new QueueOverflowException();\n                 SubscriptionHelper.cancel(this);\n-\n-                onError(new QueueOverflowException());\n+                onComplete();\n             } else {\n                 signalConsumer();\n             }",
    "output": "Upgrade BlockingFlowableIterable.onNext() to set error before cancel To avoid race with hasNext(), which checks for cancel first before checking for error. For example, in the following case, hasNext() may return false to the caller, making the caller assume the iterable finished successfully. 1. onNext() called cancel 2. hasNext() found the iterable is cancelled 3. hasNext() found that error is null thus returned false to the caller, without throwing the error 4. onNext() set error"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchMap.java b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchMap.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchMap.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchMap.java\n@@ -349,9 +349,10 @@ public void onSubscribe(Disposable d) {\n \n         @Override\n         public void onNext(R t) {\n-            if (index == parent.unique) {\n+            SimpleQueue<R> q = queue;\n+            if (index == parent.unique && q != null) {\n                 if (t != null) {\n-                    queue.offer(t);\n+                    q.offer(t);\n                 }\n                 parent.drain();\n             }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchTest.java\n@@ -1377,4 +1377,19 @@ Flowable<Integer> createFlowable(AtomicInteger inner) {\n             inner.incrementAndGet();\n         });\n     }\n+\n+    @Test\n+    public void innerOnSubscribeOuterCancelRace() {\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+\n+        Flowable.just(1)\n+        .hide()\n+        .switchMap(v -> Flowable.just(1)\n+                .doOnSubscribe(d -> ts.cancel())\n+                .scan(1, (a, b) -> a)\n+        )\n+        .subscribe(ts);\n+\n+        ts.assertEmpty();\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchTest.java\n@@ -1438,4 +1438,19 @@ Observable<Integer> createObservable(AtomicInteger inner) {\n             inner.incrementAndGet();\n         });\n     }\n+\n+    @Test\n+    public void innerOnSubscribeOuterCancelRace() {\n+        TestObserver<Integer> to = new TestObserver<Integer>();\n+\n+        Observable.just(1)\n+        .hide()\n+        .switchMap(v -> Observable.just(1)\n+                .doOnSubscribe(d -> to.dispose())\n+                .scan(1, (a, b) -> a)\n+        )\n+        .subscribe(to);\n+\n+        to.assertEmpty();\n+    }\n }",
    "output": "Fix ObservableSwitchMap NPE due to cancel race"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Flowable.java b/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n@@ -20394,7 +20394,7 @@ public final TestSubscriber<T> test(long initialRequest, boolean cancel) { // No\n     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n     @SchedulerSupport(SchedulerSupport.NONE)\n     @NonNull\n-    public final <@NonNull R, @NonNull A> Single<R> collect(@NonNull Collector<? super T, A, R> collector) {\n+    public final <@NonNull R, @Nullable A> Single<R> collect(@NonNull Collector<? super T, A, R> collector) {\n         Objects.requireNonNull(collector, \"collector is null\");\n         return RxJavaPlugins.onAssembly(new FlowableCollectWithCollectorSingle<>(this, collector));\n     }",
    "output": "Remove `@NonNull` annotation from `Collector` container type parameter.\n\n`collect` delegates to `FlowableCollectWithCollectorSingle`, which does\r\nis not annotated to require a non-nullable type for its corresponding\r\ntype parameter and whose implementation works fine with a null\r\ncontainer.\r\n\r\nThis PR lets Kotlin code pass a `Collector<T, A, R>`, where `A` is\r\ndeclared as `<A: Any?>`"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Flowable.java b/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n@@ -12755,7 +12755,46 @@ public final Flowable<T> onBackpressureDrop(@NonNull Consumer<? super T> onDrop)\n     @SchedulerSupport(SchedulerSupport.NONE)\n     @NonNull\n     public final Flowable<T> onBackpressureLatest() {\n-        return RxJavaPlugins.onAssembly(new FlowableOnBackpressureLatest<>(this));\n+        return RxJavaPlugins.onAssembly(new FlowableOnBackpressureLatest<>(this, null));\n+    }\n+\n+    /**\n+     * Drops all but the latest item emitted by the current {@code Flowable} if the downstream is not ready to receive\n+     * new items (indicated by a lack of {@link Subscription#request(long)} calls from it) and emits this latest\n+     * item when the downstream becomes ready.\n+     * <p>\n+     * <img width=\"640\" height=\"245\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.latest.v3.png\" alt=\"\">\n+     * <p>\n+     * Its behavior is logically equivalent to {@code blockingLatest()} with the exception that\n+     * the downstream is not blocking while requesting more values.\n+     * <p>\n+     * Note that if the current {@code Flowable} does support backpressure, this operator ignores that capability\n+     * and doesn't propagate any backpressure requests from downstream.\n+     * <p>\n+     * Note that due to the nature of how backpressure requests are propagated through subscribeOn/observeOn,\n+     * requesting more than 1 from downstream doesn't guarantee a continuous delivery of {@code onNext} events.\n+     * <dl>\n+     *  <dt><b>Backpressure:</b></dt>\n+     *  <dd>The operator honors backpressure from downstream and consumes the current {@code Flowable} in an unbounded\n+     *  manner (i.e., not applying backpressure to it).</dd>\n+     *  <dt><b>Scheduler:</b></dt>\n+     *  <dd>{@code onBackpressureLatest} does not operate by default on a particular {@link Scheduler}.</dd>\n+     * </dl>\n+     *\n+     * @param onDropped\n+     *        called with the current entry when it has been replaced by a new one\n+     * @throws NullPointerException if {@code onDropped} is {@code null}\n+     * @return the new {@code Flowable} instance\n+     * @since 3.1.7\n+     */\n+    @CheckReturnValue\n+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n+    @SchedulerSupport(SchedulerSupport.NONE)\n+    @NonNull\n+    @Experimental\n+     public final Flowable<T> onBackpressureLatest(@NonNull Consumer<? super T> onDropped) {\n+        Objects.requireNonNull(onDropped, \"onDropped is null\");\n+        return RxJavaPlugins.onAssembly(new FlowableOnBackpressureLatest<>(this, onDropped));\n     }\n \n     /**\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureLatest.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureLatest.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureLatest.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureLatest.java\n@@ -14,30 +14,48 @@\n package io.reactivex.rxjava3.internal.operators.flowable;\n \n import io.reactivex.rxjava3.core.Flowable;\n+import io.reactivex.rxjava3.exceptions.Exceptions;\n+import io.reactivex.rxjava3.functions.Consumer;\n import org.reactivestreams.Subscriber;\n \n public final class FlowableOnBackpressureLatest<T> extends AbstractFlowableWithUpstream<T, T> {\n \n-    public FlowableOnBackpressureLatest(Flowable<T> source) {\n+    final Consumer<? super T> onDropped;\n+\n+    public FlowableOnBackpressureLatest(Flowable<T> source, Consumer<? super T> onDropped) {\n         super(source);\n+        this.onDropped = onDropped;\n     }\n \n     @Override\n     protected void subscribeActual(Subscriber<? super T> s) {\n-        source.subscribe(new BackpressureLatestSubscriber<>(s));\n+        source.subscribe(new BackpressureLatestSubscriber<>(s, onDropped));\n     }\n \n     static final class BackpressureLatestSubscriber<T> extends AbstractBackpressureThrottlingSubscriber<T, T> {\n \n         private static final long serialVersionUID = 163080509307634843L;\n \n-        BackpressureLatestSubscriber(Subscriber<? super T> downstream) {\n+        final Consumer<? super T> onDropped;\n+\n+        BackpressureLatestSubscriber(Subscriber<? super T> downstream,\n+                                     Consumer<? super T> onDropped) {\n             super(downstream);\n+            this.onDropped = onDropped;\n         }\n \n         @Override\n         public void onNext(T t) {\n-            current.lazySet(t);\n+            T oldValue = current.getAndSet(t);\n+            if (onDropped != null && oldValue != null) {\n+                try {\n+                    onDropped.accept(oldValue);\n+                } catch (Throwable ex) {\n+                    Exceptions.throwIfFatal(ex);\n+                    upstream.cancel();\n+                    downstream.onError(ex);\n+                }\n+            }\n             drain();\n         }\n     }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureLatestTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureLatestTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureLatestTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureLatestTest.java\n@@ -17,6 +17,7 @@\n import java.util.concurrent.TimeUnit;\n \n import org.junit.*;\n+import org.mockito.InOrder;\n import org.reactivestreams.Publisher;\n \n import io.reactivex.rxjava3.core.*;\n@@ -27,6 +28,8 @@\n import io.reactivex.rxjava3.subscribers.TestSubscriber;\n import io.reactivex.rxjava3.testsupport.*;\n \n+import static org.mockito.Mockito.inOrder;\n+\n public class FlowableOnBackpressureLatestTest extends RxJavaTest {\n     @Test\n     public void simple() {\n@@ -62,6 +65,68 @@ public void simpleBackpressure() {\n         ts.assertNotComplete();\n     }\n \n+    @Test\n+    public void simpleBackpressureWithOnDroppedCallback() {\n+        PublishProcessor<Integer> source = PublishProcessor.create();\n+        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L);\n+\n+        Observer<Object> dropCallbackObserver = TestHelper.mockObserver();\n+\n+        source.onBackpressureLatest(dropCallbackObserver::onNext)\n+                .subscribe(ts);\n+\n+        ts.assertNoValues();\n+\n+        source.onNext(1);\n+        source.onNext(2);\n+        source.onNext(3);\n+\n+        ts.request(1);\n+\n+        ts.assertValues(3);\n+\n+        source.onNext(4);\n+        source.onNext(5);\n+\n+        ts.request(2);\n+\n+        ts.assertValues(3,5);\n+\n+        InOrder dropCallbackOrder = inOrder(dropCallbackObserver);\n+        dropCallbackOrder.verify(dropCallbackObserver).onNext(1);\n+        dropCallbackOrder.verify(dropCallbackObserver).onNext(2);\n+        dropCallbackOrder.verify(dropCallbackObserver).onNext(4);\n+        dropCallbackOrder.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void simpleBackpressureWithOnDroppedCallbackEx() {\n+        PublishProcessor<Integer> source = PublishProcessor.create();\n+        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L);\n+\n+        source.onBackpressureLatest(e -> {\n+                    if (e == 3) {\n+                        throw new TestException(\"forced\");\n+                    }\n+                })\n+                .subscribe(ts);\n+\n+        ts.assertNoValues();\n+\n+        source.onNext(1);\n+        source.onNext(2);\n+\n+        ts.request(1);\n+\n+        ts.assertValues(2);\n+\n+        source.onNext(3);\n+        source.onNext(4);\n+\n+        ts.assertError(TestException.class);\n+        ts.assertValues(2);\n+    }\n+\n     @Test\n     public void synchronousDrop() {\n         PublishProcessor<Integer> source = PublishProcessor.create();\n@@ -105,7 +170,7 @@ public void synchronousDrop() {\n     }\n \n     @Test\n-    public void asynchronousDrop() throws InterruptedException {\n+    public void asynchronousDrop() {\n         TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(1L) {\n             final Random rnd = new Random();\n             @Override",
    "output": "Add onDropped callback for onBackpressureLatest - #7458"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleTimeout.java b/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleTimeout.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleTimeout.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleTimeout.java\n@@ -113,11 +113,7 @@ public void onError(Throwable e) {\n \n         @Override\n         public void run() {\n-            Disposable d = get();\n-            if (d != DisposableHelper.DISPOSED && compareAndSet(d, DisposableHelper.DISPOSED)) {\n-                if (d != null) {\n-                    d.dispose();\n-                }\n+            if (DisposableHelper.dispose(this)) {\n                 SingleSource<? extends T> other = this.other;\n                 if (other == null) {\n                     downstream.onError(new TimeoutException(timeoutMessage(timeout, unit)));\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/single/SingleTimeoutTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/single/SingleTimeoutTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/single/SingleTimeoutTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/single/SingleTimeoutTest.java\n@@ -28,7 +28,7 @@\n import io.reactivex.rxjava3.functions.Action;\n import io.reactivex.rxjava3.observers.TestObserver;\n import io.reactivex.rxjava3.plugins.RxJavaPlugins;\n-import io.reactivex.rxjava3.schedulers.TestScheduler;\n+import io.reactivex.rxjava3.schedulers.*;\n import io.reactivex.rxjava3.subjects.*;\n import io.reactivex.rxjava3.testsupport.TestHelper;\n \n@@ -255,4 +255,24 @@ protected void subscribeActual(@NonNull SingleObserver<? super @NonNull Integer>\n \n         assertTrue(d.isDisposed());\n     }\n+\n+    @Test\n+    public void timeoutWithZero() throws InterruptedException {\n+        int n = 10_000;\n+        Scheduler sch = Schedulers.single();\n+        for (int i = 0; i < n; i++) {\n+            final int y = i;\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            Disposable d = Single.never()\n+                    .timeout(0, TimeUnit.NANOSECONDS, sch)\n+                    .subscribe(v -> {}, e -> {\n+                        //System.out.println(\"timeout \" + y);\n+                        latch.countDown();\n+                    });\n+            if (!latch.await(2, TimeUnit.SECONDS)) {\n+                System.out.println(d + \" \" + sch);\n+                throw new IllegalStateException(\"Timeout did not work at y = \" + y);\n+            }\n+        }\n+    }\n }",
    "output": "Fix Single.timeout race condition"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleFirstTimed.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleFirstTimed.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleFirstTimed.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleFirstTimed.java\n@@ -105,9 +105,10 @@ public void onNext(T t) {\n                     downstream.onNext(t);\n                     BackpressureHelper.produced(this, 1);\n                 } else {\n+                    upstream.cancel();\n                     done = true;\n-                    cancel();\n                     downstream.onError(MissingBackpressureException.createDefault());\n+                    worker.dispose();\n                     return;\n                 }\n \n@@ -122,10 +123,10 @@ public void onNext(T t) {\n                     onDropped.accept(t);\n                 } catch (Throwable ex) {\n                     Exceptions.throwIfFatal(ex);\n-                    downstream.onError(ex);\n-                    worker.dispose();\n                     upstream.cancel();\n                     done = true;\n+                    downstream.onError(ex);\n+                    worker.dispose();\n                 }\n             }\n         }\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableThrottleFirstTimed.java b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableThrottleFirstTimed.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableThrottleFirstTimed.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableThrottleFirstTimed.java\n@@ -32,7 +32,7 @@ public final class ObservableThrottleFirstTimed<T> extends AbstractObservableWit\n \n     public ObservableThrottleFirstTimed(\n             ObservableSource<T> source,\n-            long timeout, \n+            long timeout,\n             TimeUnit unit,\n             Scheduler scheduler,\n             Consumer<? super T> onDropped) {\n@@ -102,9 +102,9 @@ public void onNext(T t) {\n                     onDropped.accept(t);\n                 } catch (Throwable ex) {\n                     Exceptions.throwIfFatal(ex);\n+                    upstream.dispose();\n                     downstream.onError(ex);\n                     worker.dispose();\n-                    upstream.dispose();\n                 }\n             }\n         }",
    "output": "Fix cancellation order in ThrottleFirst\n\n* Fix cancellation order in ThrottleFirst\r\n\r\n* Bump vanniktech maven publish\r\n\r\n* Undo bump, seems to be gradle issue"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleLatest.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleLatest.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleLatest.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleLatest.java\n@@ -306,8 +306,7 @@ void drain() {\n         }\n \n         void tryDropAndSignalMBE(T valueToDrop) {\n-            Throwable errorToSignal = new MissingBackpressureException(\n-                    \"Could not emit value due to lack of requests\");\n+            Throwable errorToSignal = MissingBackpressureException.createDefault();\n             if (onDropped != null) {\n                 try {\n                     onDropped.accept(valueToDrop);",
    "output": "Upgrade Flowable.throttleLatest MissingBackpressureException message"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBufferExactBoundary.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBufferExactBoundary.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBufferExactBoundary.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBufferExactBoundary.java\n@@ -45,7 +45,7 @@ protected void subscribeActual(Subscriber<? super U> s) {\n     }\n \n     static final class BufferExactBoundarySubscriber<T, U extends Collection<? super T>, B>\n-    extends QueueDrainSubscriber<T, U, U> implements FlowableSubscriber<T>, Subscription, Disposable {\n+    extends QueueDrainSubscriber<T, U, U> implements Subscription, Disposable {\n \n         final Supplier<U> bufferSupplier;\n         final Publisher<B> boundary;\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.java\n@@ -244,8 +244,7 @@ public final boolean isEmpty() {\n         }\n     }\n \n-    static final class ObserveOnSubscriber<T> extends BaseObserveOnSubscriber<T>\n-    implements FlowableSubscriber<T> {\n+    static final class ObserveOnSubscriber<T> extends BaseObserveOnSubscriber<T> {\n \n         private static final long serialVersionUID = -4547113800637756442L;\n \n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableToList.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableToList.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableToList.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableToList.java\n@@ -46,7 +46,7 @@ protected void subscribeActual(Subscriber<? super U> s) {\n \n     static final class ToListSubscriber<T, U extends Collection<? super T>>\n     extends DeferredScalarSubscription<U>\n-    implements FlowableSubscriber<T>, Subscription {\n+    implements FlowableSubscriber<T> {\n \n         private static final long serialVersionUID = -8134157938864266736L;\n         Subscription upstream;\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBufferExactBoundary.java b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBufferExactBoundary.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBufferExactBoundary.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBufferExactBoundary.java\n@@ -43,7 +43,7 @@ protected void subscribeActual(Observer<? super U> t) {\n     }\n \n     static final class BufferExactBoundaryObserver<T, U extends Collection<? super T>, B>\n-    extends QueueDrainObserver<T, U, U> implements Observer<T>, Disposable {\n+    extends QueueDrainObserver<T, U, U> implements Disposable {\n \n         final Supplier<U> bufferSupplier;\n         final ObservableSource<B> boundary;\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/schedulers/NewThreadWorker.java b/src/main/java/io/reactivex/rxjava3/internal/schedulers/NewThreadWorker.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/schedulers/NewThreadWorker.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/schedulers/NewThreadWorker.java\n@@ -26,7 +26,7 @@\n  * worker but doesn't perform task-tracking operations.\n  *\n  */\n-public class NewThreadWorker extends Scheduler.Worker implements Disposable {\n+public class NewThreadWorker extends Scheduler.Worker {\n     private final ScheduledExecutorService executor;\n \n     volatile boolean disposed;\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/schedulers/TrampolineScheduler.java b/src/main/java/io/reactivex/rxjava3/internal/schedulers/TrampolineScheduler.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/schedulers/TrampolineScheduler.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/schedulers/TrampolineScheduler.java\n@@ -62,7 +62,7 @@ public Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit uni\n         return EmptyDisposable.INSTANCE;\n     }\n \n-    static final class TrampolineWorker extends Scheduler.Worker implements Disposable {\n+    static final class TrampolineWorker extends Scheduler.Worker {\n         final PriorityBlockingQueue<TimedRunnable> queue = new PriorityBlockingQueue<>();\n \n         private final AtomicInteger wip = new AtomicInteger();\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/validators/ParamValidationCheckerTest.java b/src/test/java/io/reactivex/rxjava3/validators/ParamValidationCheckerTest.java\n--- a/src/test/java/io/reactivex/rxjava3/validators/ParamValidationCheckerTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/validators/ParamValidationCheckerTest.java\n@@ -560,6 +560,7 @@ public void checkParallelFlowable() {\n         for (Class<?> interfaces : AllFunctionals.class.getInterfaces()) {\n             defaultValues.put(interfaces, af);\n         }\n+        defaultValues.put(Subscriber.class, af);\n         defaultValues.put(TimeUnit.class, TimeUnit.SECONDS);\n         defaultValues.put(Scheduler.class, Schedulers.single());\n         defaultValues.put(BackpressureStrategy.class, BackpressureStrategy.MISSING);\n@@ -926,7 +927,7 @@ static final class AllFunctionals\n     Function3, Function4, Function5, Function6, Function7, Function8, Function9,\n     FlowableOnSubscribe, ObservableOnSubscribe, SingleOnSubscribe, MaybeOnSubscribe, CompletableOnSubscribe,\n     FlowableTransformer, ObservableTransformer, SingleTransformer, MaybeTransformer, CompletableTransformer,\n-    Subscriber, FlowableSubscriber, Observer, SingleObserver, MaybeObserver, CompletableObserver,\n+    FlowableSubscriber, Observer, SingleObserver, MaybeObserver, CompletableObserver,\n     FlowableOperator, ObservableOperator, SingleOperator, MaybeOperator, CompletableOperator,\n     Comparator, ParallelTransformer\n     {",
    "output": "Remove redundant interface declarations\n\n* Remove redundant interface declarations\r\n\r\n* Fix paramvalidator"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Maybe.java b/src/main/java/io/reactivex/rxjava3/core/Maybe.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Maybe.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Maybe.java\n@@ -110,7 +110,7 @@\n  * @since 2.0\n  * @see io.reactivex.rxjava3.observers.DisposableMaybeObserver\n  */\n-public abstract class Maybe<T> implements MaybeSource<T> {\n+public abstract class Maybe<@NonNull T> implements MaybeSource<T> {\n \n     /**\n      * Runs multiple {@link MaybeSource}s provided by an {@link Iterable} sequence and",
    "output": "Add missing `@NonNull` annotation to `Maybe` type argument"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Observable.java b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Observable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n@@ -5520,7 +5520,6 @@ public final T blockingFirst(@NonNull T defaultItem) {\n      * @see #blockingForEach(Consumer, int)\n      */\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    @NonNull\n     public final void blockingForEach(@NonNull Consumer<? super T> onNext) {\n         blockingForEach(onNext, bufferSize());\n     }\n@@ -5560,7 +5559,6 @@ public final void blockingForEach(@NonNull Consumer<? super T> onNext) {\n      * @see #subscribe(Consumer)\n      */\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    @NonNull\n     public final void blockingForEach(@NonNull Consumer<? super T> onNext, int capacityHint) {\n         Objects.requireNonNull(onNext, \"onNext is null\");\n         Iterator<T> it = blockingIterable(capacityHint).iterator();\n@@ -12036,7 +12034,6 @@ public final Observable<T> retryWhen(\n      * @throws NullPointerException if {@code observer} is {@code null}\n      */\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    @NonNull\n     public final void safeSubscribe(@NonNull Observer<? super T> observer) {\n         Objects.requireNonNull(observer, \"observer is null\");\n         if (observer instanceof SafeObserver) {",
    "output": "Remove @NonNull annotations for functions with void return type\n\nCo-authored-by: Pavel Korolev <pavel.korolev@onde.app>"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/observers/BaseTestConsumer.java b/src/main/java/io/reactivex/rxjava3/observers/BaseTestConsumer.java\n--- a/src/main/java/io/reactivex/rxjava3/observers/BaseTestConsumer.java\n+++ b/src/main/java/io/reactivex/rxjava3/observers/BaseTestConsumer.java\n@@ -307,11 +307,11 @@ private U assertError(@NonNull Predicate<Throwable> errorPredicate, boolean exac\n     public final U assertValue(@NonNull T value) {\n         int s = values.size();\n         if (s != 1) {\n-            throw fail(\"expected: \" + valueAndClass(value) + \" but was: \" + values);\n+            throw fail(\"\\nexpected: \" + valueAndClass(value) + \"\\ngot: \" + values);\n         }\n         T v = values.get(0);\n         if (!Objects.equals(value, v)) {\n-            throw fail(\"expected: \" + valueAndClass(value) + \" but was: \" + valueAndClass(v));\n+            throw fail(\"\\nexpected: \" + valueAndClass(value) + \"\\ngot: \" + valueAndClass(v));\n         }\n         return (U)this;\n     }\n@@ -359,7 +359,7 @@ public final U assertValueAt(int index, @NonNull T value) {\n \n         T v = values.get(index);\n         if (!Objects.equals(value, v)) {\n-            throw fail(\"expected: \" + valueAndClass(value) + \" but was: \" + valueAndClass(v) + \" at position \" + index);\n+            throw fail(\"Values at position \" + index + \" differ;\\nexpected: \" + valueAndClass(value) + \"\\ngot: \" + valueAndClass(v));\n         }\n         return (U)this;\n     }\n@@ -425,7 +425,7 @@ public static String valueAndClass(@Nullable Object o) {\n     public final U assertValueCount(int count) {\n         int s = values.size();\n         if (s != count) {\n-            throw fail(\"Value counts differ; expected: \" + count + \" but was: \" + s);\n+            throw fail(\"Value counts differ;\\nexpected: \" + count + \"\\ngot: \" + s);\n         }\n         return (U)this;\n     }\n@@ -450,14 +450,14 @@ public final U assertNoValues() {\n     public final U assertValues(@NonNull T... values) {\n         int s = this.values.size();\n         if (s != values.length) {\n-            throw fail(\"Value count differs; expected: \" + values.length + \" \" + Arrays.toString(values)\n-            + \" but was: \" + s + \" \" + this.values);\n+            throw fail(\"Value count differs;\\nexpected: \" + values.length + \" \" + Arrays.toString(values)\n+            + \"\\ngot: \" + s + \" \" + this.values);\n         }\n         for (int i = 0; i < s; i++) {\n             T v = this.values.get(i);\n             T u = values[i];\n             if (!Objects.equals(u, v)) {\n-                throw fail(\"Values at position \" + i + \" differ; expected: \" + valueAndClass(u) + \" but was: \" + valueAndClass(v));\n+                throw fail(\"Values at position \" + i + \" differ;\\nexpected: \" + valueAndClass(u) + \"\\ngot: \" + valueAndClass(v));\n             }\n         }\n         return (U)this;\n@@ -504,7 +504,7 @@ public final U assertValueSequence(@NonNull Iterable<? extends T> sequence) {\n             T v = actualIterator.next();\n \n             if (!Objects.equals(u, v)) {\n-                throw fail(\"Values at position \" + i + \" differ; expected: \" + valueAndClass(u) + \" but was: \" + valueAndClass(v));\n+                throw fail(\"Values at position \" + i + \" differ;\\nexpected: \" + valueAndClass(u) + \"\\ngot: \" + valueAndClass(v));\n             }\n             i++;\n         }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/observers/TestObserverTest.java b/src/test/java/io/reactivex/rxjava3/observers/TestObserverTest.java\n--- a/src/test/java/io/reactivex/rxjava3/observers/TestObserverTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/observers/TestObserverTest.java\n@@ -999,7 +999,7 @@ public void assertValueAtIndexMatch() {\n \n     @Test\n     public void assertValueAtIndexNoMatch() {\n-        assertThrowsWithMessage(\"expected: b (class: String) but was: c (class: String) at position 2 (latch = 0, values = 3, errors = 0, completions = 1)\", AssertionError.class, () -> {\n+        assertThrowsWithMessage(\"Values at position 2 differ;\\nexpected: b (class: String)\\ngot: c (class: String) (latch = 0, values = 3, errors = 0, completions = 1)\", AssertionError.class, () -> {\n             TestObserver<String> to = new TestObserver<>();\n \n             Observable.just(\"a\", \"b\", \"c\").subscribe(to);\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/testsupport/BaseTestConsumerEx.java b/src/test/java/io/reactivex/rxjava3/testsupport/BaseTestConsumerEx.java\n--- a/src/test/java/io/reactivex/rxjava3/testsupport/BaseTestConsumerEx.java\n+++ b/src/test/java/io/reactivex/rxjava3/testsupport/BaseTestConsumerEx.java\n@@ -160,7 +160,7 @@ public final U assertErrorMessage(String message) {\n             Throwable e = errors.get(0);\n             String errorMessage = e.getMessage();\n             if (!Objects.equals(message, errorMessage)) {\n-                throw fail(\"Error message differs; exptected: \" + message + \" but was: \" + errorMessage);\n+                throw fail(\"Error message differs;\\nexpected: \" + message + \"\\ngot: \" + errorMessage);\n             }\n         } else {\n             throw fail(\"Multiple errors\");\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/testsupport/TestObserverEx.java b/src/test/java/io/reactivex/rxjava3/testsupport/TestObserverEx.java\n--- a/src/test/java/io/reactivex/rxjava3/testsupport/TestObserverEx.java\n+++ b/src/test/java/io/reactivex/rxjava3/testsupport/TestObserverEx.java\n@@ -254,8 +254,8 @@ public final TestObserverEx<T> assertFusionMode(int mode) {\n         int m = establishedFusionMode;\n         if (m != mode) {\n             if (qd != null) {\n-                throw new AssertionError(\"Fusion mode different. Expected: \" + fusionModeToString(mode)\n-                + \", actual: \" + fusionModeToString(m));\n+                throw new AssertionError(\"Fusion mode different.\\nexpected: \" + fusionModeToString(mode)\n+                + \"\\ngot: \" + fusionModeToString(m));\n             } else {\n                 throw fail(\"Upstream is not fuseable\");\n             }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/testsupport/TestObserverExTest.java b/src/test/java/io/reactivex/rxjava3/testsupport/TestObserverExTest.java\n--- a/src/test/java/io/reactivex/rxjava3/testsupport/TestObserverExTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/testsupport/TestObserverExTest.java\n@@ -1274,7 +1274,7 @@ public void assertValueAtIndexMatch() {\n \n     @Test\n     public void assertValueAtIndexNoMatch() {\n-        assertThrows(\"expected: b (class: String) but was: c (class: String) (latch = 0, values = 3, errors = 0, completions = 1)\", AssertionError.class, () -> {\n+        assertThrows(\"\\nexpected: b (class: String)\\ngot: c (class: String) (latch = 0, values = 3, errors = 0, completions = 1)\", AssertionError.class, () -> {\n             TestObserverEx<String> to = new TestObserverEx<>();\n \n             Observable.just(\"a\", \"b\", \"c\").subscribe(to);",
    "output": "Upgrade assert messages format to be compliant with GradleRunner and JUnitRunner"
  },
  {
    "input": "diff --git a/src/main/module/module-info.java b/src/main/module/module-info.java\n--- a/src/main/module/module-info.java\n+++ b/src/main/module/module-info.java\n@@ -16,15 +16,17 @@\n     exports io.reactivex.rxjava3.core;\n     exports io.reactivex.rxjava3.disposables;\n     exports io.reactivex.rxjava3.exceptions;\n+    exports io.reactivex.rxjava3.flowables;\n     exports io.reactivex.rxjava3.functions;\n     exports io.reactivex.rxjava3.observables;\n     exports io.reactivex.rxjava3.observers;\n+    exports io.reactivex.rxjava3.operators;\n     exports io.reactivex.rxjava3.parallel;\n     exports io.reactivex.rxjava3.plugins;\n     exports io.reactivex.rxjava3.processors;\n     exports io.reactivex.rxjava3.schedulers;\n     exports io.reactivex.rxjava3.subjects;\n     exports io.reactivex.rxjava3.subscribers;\n \n-    requires org.reactivestreams;\n+    requires transitive org.reactivestreams;\n }\n\\ No newline at end of file",
    "output": "Add missing exports packages, fix param overrides"
  },
  {
    "input": "diff --git a/src/main/module/module-info.java b/src/main/module/module-info.java\n--- a/src/main/module/module-info.java\n+++ b/src/main/module/module-info.java\n@@ -0,0 +1,30 @@\n+/*\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+module io.reactivex.rxjava3 {\n+    exports io.reactivex.rxjava3.annotations;\n+    exports io.reactivex.rxjava3.core;\n+    exports io.reactivex.rxjava3.disposables;\n+    exports io.reactivex.rxjava3.exceptions;\n+    exports io.reactivex.rxjava3.functions;\n+    exports io.reactivex.rxjava3.observables;\n+    exports io.reactivex.rxjava3.observers;\n+    exports io.reactivex.rxjava3.parallel;\n+    exports io.reactivex.rxjava3.plugins;\n+    exports io.reactivex.rxjava3.processors;\n+    exports io.reactivex.rxjava3.schedulers;\n+    exports io.reactivex.rxjava3.subjects;\n+    exports io.reactivex.rxjava3.subscribers;\n+\n+    requires org.reactivestreams;\n+}\n\\ No newline at end of file",
    "output": "Add full Java module descriptor"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Single.java b/src/main/java/io/reactivex/rxjava3/core/Single.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Single.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Single.java\n@@ -4735,7 +4735,7 @@ public final Disposable subscribe() {\n     @CheckReturnValue\n     @NonNull\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    public final Disposable subscribe(@NonNull BiConsumer<? super T, ? super Throwable> onCallback) {\n+    public final Disposable subscribe(@NonNull BiConsumer<@Nullable ? super T, @Nullable ? super Throwable> onCallback) {\n         Objects.requireNonNull(onCallback, \"onCallback is null\");\n \n         BiConsumerSingleObserver<T> observer = new BiConsumerSingleObserver<>(onCallback);",
    "output": "Fix missing nullability on Single.subscribe(BiConsumer)"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/schedulers/ExecutorScheduler.java b/src/main/java/io/reactivex/rxjava3/internal/schedulers/ExecutorScheduler.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/schedulers/ExecutorScheduler.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/schedulers/ExecutorScheduler.java\n@@ -38,7 +38,9 @@ public final class ExecutorScheduler extends Scheduler {\n     @NonNull\n     final Executor executor;\n \n-    static final Scheduler HELPER = Schedulers.single();\n+    static final class SingleHolder {\n+        static final Scheduler HELPER = Schedulers.single();\n+    }\n \n     public ExecutorScheduler(@NonNull Executor executor, boolean interruptibleWorker, boolean fair) {\n         this.executor = executor;\n@@ -97,7 +99,7 @@ public Disposable scheduleDirect(@NonNull Runnable run, final long delay, final\n \n         final DelayedRunnable dr = new DelayedRunnable(decoratedRun);\n \n-        Disposable delayed = HELPER.scheduleDirect(new DelayedDispose(dr), delay, unit);\n+        Disposable delayed = SingleHolder.HELPER.scheduleDirect(new DelayedDispose(dr), delay, unit);\n \n         dr.timed.replace(delayed);\n \n@@ -215,7 +217,7 @@ public Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit\n                     return EmptyDisposable.INSTANCE;\n                 }\n             } else {\n-                final Disposable d = HELPER.scheduleDirect(sr, delay, unit);\n+                final Disposable d = SingleHolder.HELPER.scheduleDirect(sr, delay, unit);\n                 sr.setFuture(new DisposeOnCancel(d));\n             }\n \n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/schedulers/ExecutorSchedulerInternalTest.java b/src/test/java/io/reactivex/rxjava3/internal/schedulers/ExecutorSchedulerInternalTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/schedulers/ExecutorSchedulerInternalTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/schedulers/ExecutorSchedulerInternalTest.java\n@@ -0,0 +1,27 @@\n+/*\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.rxjava3.internal.schedulers;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+import org.junit.Test;\n+\n+public class ExecutorSchedulerInternalTest {\n+\n+    @Test\n+    public void helperHolder() {\n+        assertNotNull(new ExecutorScheduler.SingleHolder());\n+    }\n+\n+}",
    "output": "Fix ExecutorScheduler initializing Schedulers prematurely\n\n* Fix ExecutorScheduler initializing Schedulers prematurely\r\n\r\n* Add coverage of the holder class"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Observable.java b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Observable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n@@ -10371,7 +10371,7 @@ public final <R> Observable<R> lift(@NonNull ObservableOperator<? extends R, ? s\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n     @NonNull\n-    public final <R> Observable<R> map(@NonNull Function<? super T, ? extends R> mapper) {\n+    public final <@NonNull R> Observable<R> map(@NonNull Function<? super T, ? extends R> mapper) {\n         Objects.requireNonNull(mapper, \"mapper is null\");\n         return RxJavaPlugins.onAssembly(new ObservableMap<>(this, mapper));\n     }",
    "output": "Fix missing NonNull on Observable.map\n\n* Fix missing NonNull on Observable.map\r\n\r\nI noticed this while testing the upcoming Kotlin 1.5.30-M1 (which has improved support for type-use nullability annotations) https://youtrack.jetbrains.com/issue/KT-47833. This makes `at least match Single, but `Maybe.map` is also missing this. I suspect there are others too.\r\n\r\n* Update src/main/java/io/reactivex/rxjava3/core/Observable.java"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/rxjava3/testsupport/TestHelper.java b/src/test/java/io/reactivex/rxjava3/testsupport/TestHelper.java\n--- a/src/test/java/io/reactivex/rxjava3/testsupport/TestHelper.java\n+++ b/src/test/java/io/reactivex/rxjava3/testsupport/TestHelper.java\n@@ -3503,18 +3503,26 @@ public static File findSource(String baseClassName, String parentPackage) throws\n         parentPackage = parentPackage.replace(\".\", \"/\");\n //        System.out.println(path);\n \n-        int i = path.toLowerCase().indexOf(\"/rxjava\");\n-        if (i < 0) {\n-            System.out.println(\"Can't find the base RxJava directory\");\n-            return null;\n-        }\n-\n-        // find end of any potential postfix to /RxJava\n-        int j = path.indexOf(\"/\", i + 6);\n+        // Locate the src/main/java directory\n+        String p = null;\n+        while (true) {\n+            int idx = path.lastIndexOf(\"/\");\n+            if (idx < 0) {\n+                break;\n+            }\n+            path = path.substring(0, idx);\n+            String check = path + \"/src/main/java\";\n \n-        String basePackage = path.substring(0, j + 1) + \"src/main/java\";\n+            if (new File(check).exists()) {\n+                p = check + \"/\" + parentPackage + \"/\" + baseClassName + \".java\";\n+                break;\n+            }\n+        }\n \n-        String p = basePackage + \"/\" + parentPackage + \"/\" + baseClassName + \".java\";\n+        if (p == null) {\n+            System.err.println(\"Unable to locate the RxJava sources\");\n+            return null;\n+        }\n \n         File f = new File(p);\n ",
    "output": "Fix source locator code to support GitHub Actions folder layout"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java\n@@ -13,7 +13,7 @@\n package io.reactivex.rxjava3.internal.operators.flowable;\n \n import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.*;\n \n import org.reactivestreams.*;\n \n@@ -308,7 +308,7 @@ void drain() {\n                                     continue;\n                                 } else {\n                                     active = true;\n-                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n+                                    inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                                 }\n \n                             } else {\n@@ -325,20 +325,22 @@ void drain() {\n         }\n     }\n \n-    static final class WeakScalarSubscription<T> implements Subscription {\n+    static final class SimpleScalarSubscription<T>\n+    extends AtomicBoolean\n+    implements Subscription {\n+        private static final long serialVersionUID = -7606889335172043256L;\n+\n         final Subscriber<? super T> downstream;\n         final T value;\n-        boolean once;\n \n-        WeakScalarSubscription(T value, Subscriber<? super T> downstream) {\n+        SimpleScalarSubscription(T value, Subscriber<? super T> downstream) {\n             this.value = value;\n             this.downstream = downstream;\n         }\n \n         @Override\n         public void request(long n) {\n-            if (n > 0 && !once) {\n-                once = true;\n+            if (n > 0L && compareAndSet(false, true)) {\n                 Subscriber<? super T> a = downstream;\n                 a.onNext(value);\n                 a.onComplete();\n@@ -507,7 +509,7 @@ void drain() {\n                                     continue;\n                                 } else {\n                                     active = true;\n-                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n+                                    inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                                 }\n                             } else {\n                                 active = true;\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java\n@@ -345,7 +345,7 @@ public void run() {\n                                 continue;\n                             } else {\n                                 active = true;\n-                                inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n+                                inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                             }\n \n                         } else {\n@@ -528,7 +528,7 @@ public void run() {\n                                 continue;\n                             } else {\n                                 active = true;\n-                                inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n+                                inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                             }\n                         } else {\n                             active = true;\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapSchedulerTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapSchedulerTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapSchedulerTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapSchedulerTest.java\n@@ -66,6 +66,56 @@ public Publisher<? extends Object> apply(String v)\n         .assertResult(\"RxSingleScheduler\");\n     }\n \n+    @Test\n+    public void innerScalarRequestRace() {\n+        Flowable<Integer> just = Flowable.just(1);\n+        int n = 1000;\n+        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {\n+            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();\n+\n+            TestSubscriber<Integer> ts = source\n+                    .concatMap(v -> v, n + 1, ImmediateThinScheduler.INSTANCE)\n+                    .test(1L);\n+\n+            TestHelper.race(() -> {\n+                for (int j = 0; j < n; j++) {\n+                    source.onNext(just);\n+                }\n+            }, () -> {\n+                for (int j = 0; j < n; j++) {\n+                    ts.request(1);\n+                }\n+            });\n+\n+            ts.assertValueCount(n);\n+        }\n+    }\n+\n+    @Test\n+    public void innerScalarRequestRaceDelayError() {\n+        Flowable<Integer> just = Flowable.just(1);\n+        int n = 1000;\n+        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {\n+            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();\n+\n+            TestSubscriber<Integer> ts = source\n+                    .concatMapDelayError(v -> v, true, n + 1, ImmediateThinScheduler.INSTANCE)\n+                    .test(1L);\n+\n+            TestHelper.race(() -> {\n+                for (int j = 0; j < n; j++) {\n+                    source.onNext(just);\n+                }\n+            }, () -> {\n+                for (int j = 0; j < n; j++) {\n+                    ts.request(1);\n+                }\n+            });\n+\n+            ts.assertValueCount(n);\n+        }\n+    }\n+\n     @Test\n     public void boundaryFusionDelayError() {\n         Flowable.range(1, 10000)\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapTest.java\n@@ -24,18 +24,18 @@\n import io.reactivex.rxjava3.core.*;\n import io.reactivex.rxjava3.exceptions.*;\n import io.reactivex.rxjava3.functions.*;\n-import io.reactivex.rxjava3.internal.operators.flowable.FlowableConcatMap.WeakScalarSubscription;\n-import io.reactivex.rxjava3.processors.UnicastProcessor;\n+import io.reactivex.rxjava3.internal.operators.flowable.FlowableConcatMap.SimpleScalarSubscription;\n+import io.reactivex.rxjava3.processors.*;\n import io.reactivex.rxjava3.schedulers.Schedulers;\n import io.reactivex.rxjava3.subscribers.TestSubscriber;\n import io.reactivex.rxjava3.testsupport.TestHelper;\n \n public class FlowableConcatMapTest extends RxJavaTest {\n \n     @Test\n-    public void weakSubscriptionRequest() {\n+    public void simpleSubscriptionRequest() {\n         TestSubscriber<Integer> ts = new TestSubscriber<>(0);\n-        WeakScalarSubscription<Integer> ws = new WeakScalarSubscription<>(1, ts);\n+        SimpleScalarSubscription<Integer> ws = new SimpleScalarSubscription<>(1, ts);\n         ts.onSubscribe(ws);\n \n         ws.request(0);\n@@ -79,6 +79,56 @@ public Publisher<? extends Object> apply(String v)\n         .assertResult(\"RxSingleScheduler\");\n     }\n \n+    @Test\n+    public void innerScalarRequestRace() {\n+        Flowable<Integer> just = Flowable.just(1);\n+        int n = 1000;\n+        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {\n+            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();\n+\n+            TestSubscriber<Integer> ts = source\n+                    .concatMap(v -> v, n + 1)\n+                    .test(1L);\n+\n+            TestHelper.race(() -> {\n+                for (int j = 0; j < n; j++) {\n+                    source.onNext(just);\n+                }\n+            }, () -> {\n+                for (int j = 0; j < n; j++) {\n+                    ts.request(1);\n+                }\n+            });\n+\n+            ts.assertValueCount(n);\n+        }\n+    }\n+\n+    @Test\n+    public void innerScalarRequestRaceDelayError() {\n+        Flowable<Integer> just = Flowable.just(1);\n+        int n = 1000;\n+        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {\n+            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();\n+\n+            TestSubscriber<Integer> ts = source\n+                    .concatMapDelayError(v -> v, true, n + 1)\n+                    .test(1L);\n+\n+            TestHelper.race(() -> {\n+                for (int j = 0; j < n; j++) {\n+                    source.onNext(just);\n+                }\n+            }, () -> {\n+                for (int j = 0; j < n; j++) {\n+                    ts.request(1);\n+                }\n+            });\n+\n+            ts.assertValueCount(n);\n+        }\n+    }\n+\n     @Test\n     public void boundaryFusionDelayError() {\n         Flowable.range(1, 10000)",
    "output": "Fix Flowable.concatMap backpressure w/ scalars"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureError.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureError.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureError.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureError.java\n@@ -65,6 +65,7 @@ public void onNext(T t) {\n                 downstream.onNext(t);\n                 BackpressureHelper.produced(this, 1);\n             } else {\n+                upstream.cancel();\n                 onError(new MissingBackpressureException(\"could not emit value due to lack of requests\"));\n             }\n         }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureErrorTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureErrorTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureErrorTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureErrorTest.java\n@@ -13,11 +13,16 @@\n \n package io.reactivex.rxjava3.internal.operators.flowable;\n \n+import static org.junit.Assert.*;\n+\n import org.junit.Test;\n import org.reactivestreams.Publisher;\n \n import io.reactivex.rxjava3.core.*;\n+import io.reactivex.rxjava3.exceptions.MissingBackpressureException;\n import io.reactivex.rxjava3.functions.Function;\n+import io.reactivex.rxjava3.subjects.PublishSubject;\n+import io.reactivex.rxjava3.subscribers.TestSubscriber;\n import io.reactivex.rxjava3.testsupport.TestHelper;\n \n public class FlowableOnBackpressureErrorTest extends RxJavaTest {\n@@ -51,4 +56,20 @@ public Object apply(Flowable<Integer> f) throws Exception {\n             }\n         }, false, 1, 1, 1);\n     }\n+\n+    @Test\n+    public void overflowCancels() {\n+        PublishSubject<Integer> ps = PublishSubject.create();\n+\n+        TestSubscriber<Integer> ts = ps.toFlowable(BackpressureStrategy.ERROR)\n+        .test(0L);\n+\n+        assertTrue(ps.hasObservers());\n+\n+        ps.onNext(1);\n+\n+        assertFalse(ps.hasObservers());\n+\n+        ts.assertFailure(MissingBackpressureException.class);\n+    }\n }",
    "output": "Fix toFlowable(ERROR) not cancelling on MBE"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Flowable.java b/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n@@ -19802,7 +19802,7 @@ public final TestSubscriber<T> test(long initialRequest, boolean cancel) { // No\n     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n     @SchedulerSupport(SchedulerSupport.NONE)\n     @NonNull\n-    public final <@NonNull R, A> Single<R> collect(@NonNull Collector<T, A, R> collector) {\n+    public final <@NonNull R, A> Single<R> collect(@NonNull Collector<? super T, A, R> collector) {\n         Objects.requireNonNull(collector, \"collector is null\");\n         return RxJavaPlugins.onAssembly(new FlowableCollectWithCollectorSingle<>(this, collector));\n     }\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/core/Observable.java b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Observable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n@@ -16642,7 +16642,7 @@ public final TestObserver<T> test(boolean dispose) { // NoPMD\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n     @NonNull\n-    public final <@NonNull R, A> Single<R> collect(@NonNull Collector<T, A, R> collector) {\n+    public final <@NonNull R, A> Single<R> collect(@NonNull Collector<? super T, A, R> collector) {\n         Objects.requireNonNull(collector, \"collector is null\");\n         return RxJavaPlugins.onAssembly(new ObservableCollectWithCollectorSingle<>(this, collector));\n     }\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableCollectWithCollector.java b/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableCollectWithCollector.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableCollectWithCollector.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableCollectWithCollector.java\n@@ -36,17 +36,17 @@ public final class FlowableCollectWithCollector<T, A, R> extends Flowable<R> {\n \n     final Flowable<T> source;\n \n-    final Collector<T, A, R> collector;\n+    final Collector<? super T, A, R> collector;\n \n-    public FlowableCollectWithCollector(Flowable<T> source, Collector<T, A, R> collector) {\n+    public FlowableCollectWithCollector(Flowable<T> source, Collector<? super T, A, R> collector) {\n         this.source = source;\n         this.collector = collector;\n     }\n \n     @Override\n     protected void subscribeActual(@NonNull Subscriber<? super R> s) {\n         A container;\n-        BiConsumer<A, T> accumulator;\n+        BiConsumer<A, ? super T> accumulator;\n         Function<A, R> finisher;\n \n         try {\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableCollectWithCollectorSingle.java b/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableCollectWithCollectorSingle.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableCollectWithCollectorSingle.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableCollectWithCollectorSingle.java\n@@ -39,9 +39,9 @@ public final class FlowableCollectWithCollectorSingle<T, A, R> extends Single<R>\n \n     final Flowable<T> source;\n \n-    final Collector<T, A, R> collector;\n+    final Collector<? super T, A, R> collector;\n \n-    public FlowableCollectWithCollectorSingle(Flowable<T> source, Collector<T, A, R> collector) {\n+    public FlowableCollectWithCollectorSingle(Flowable<T> source, Collector<? super T, A, R> collector) {\n         this.source = source;\n         this.collector = collector;\n     }\n@@ -54,7 +54,7 @@ public Flowable<R> fuseToFlowable() {\n     @Override\n     protected void subscribeActual(@NonNull SingleObserver<? super R> observer) {\n         A container;\n-        BiConsumer<A, T> accumulator;\n+        BiConsumer<A, ? super T> accumulator;\n         Function<A, R> finisher;\n \n         try {\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableCollectWithCollector.java b/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableCollectWithCollector.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableCollectWithCollector.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableCollectWithCollector.java\n@@ -36,17 +36,17 @@ public final class ObservableCollectWithCollector<T, A, R> extends Observable<R>\n \n     final Observable<T> source;\n \n-    final Collector<T, A, R> collector;\n+    final Collector<? super T, A, R> collector;\n \n-    public ObservableCollectWithCollector(Observable<T> source, Collector<T, A, R> collector) {\n+    public ObservableCollectWithCollector(Observable<T> source, Collector<? super T, A, R> collector) {\n         this.source = source;\n         this.collector = collector;\n     }\n \n     @Override\n     protected void subscribeActual(@NonNull Observer<? super R> observer) {\n         A container;\n-        BiConsumer<A, T> accumulator;\n+        BiConsumer<A, ? super T> accumulator;\n         Function<A, R> finisher;\n \n         try {\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableCollectWithCollectorSingle.java b/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableCollectWithCollectorSingle.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableCollectWithCollectorSingle.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableCollectWithCollectorSingle.java\n@@ -36,9 +36,9 @@ public final class ObservableCollectWithCollectorSingle<T, A, R> extends Single<\n \n     final Observable<T> source;\n \n-    final Collector<T, A, R> collector;\n+    final Collector<? super T, A, R> collector;\n \n-    public ObservableCollectWithCollectorSingle(Observable<T> source, Collector<T, A, R> collector) {\n+    public ObservableCollectWithCollectorSingle(Observable<T> source, Collector<? super T, A, R> collector) {\n         this.source = source;\n         this.collector = collector;\n     }\n@@ -51,7 +51,7 @@ public Observable<R> fuseToObservable() {\n     @Override\n     protected void subscribeActual(@NonNull SingleObserver<? super R> observer) {\n         A container;\n-        BiConsumer<A, T> accumulator;\n+        BiConsumer<A, ? super T> accumulator;\n         Function<A, R> finisher;\n \n         try {",
    "output": "Make the parameter of {Flowable,Observable}.collect(Collector) contravariant on T"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMap.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMap.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMap.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMap.java\n@@ -115,7 +115,12 @@ public void onNext(T t) {\n         @Override\n         public boolean tryOnNext(T t) {\n             if (done) {\n-                return false;\n+                return true;\n+            }\n+\n+            if (sourceMode != NONE) {\n+                downstream.tryOnNext(null);\n+                return true;\n             }\n \n             U v;\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/jdk8/FlowableMapOptionalTest.java b/src/test/java/io/reactivex/rxjava3/internal/jdk8/FlowableMapOptionalTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/jdk8/FlowableMapOptionalTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/jdk8/FlowableMapOptionalTest.java\n@@ -24,9 +24,10 @@\n import io.reactivex.rxjava3.exceptions.TestException;\n import io.reactivex.rxjava3.functions.Function;\n import io.reactivex.rxjava3.internal.fuseable.QueueFuseable;\n+import io.reactivex.rxjava3.internal.schedulers.ImmediateThinScheduler;\n import io.reactivex.rxjava3.internal.subscriptions.BooleanSubscription;\n import io.reactivex.rxjava3.processors.*;\n-import io.reactivex.rxjava3.testsupport.TestHelper;\n+import io.reactivex.rxjava3.testsupport.*;\n \n public class FlowableMapOptionalTest extends RxJavaTest {\n \n@@ -467,4 +468,20 @@ public void boundaryFusedMixedConditional() {\n         .assertFusionMode(QueueFuseable.NONE)\n         .assertResult(2, 4, 6, 8, 10);\n     }\n+\n+    @Test\n+    public void conditionalFusionNoNPE() {\n+        TestSubscriberEx<Object> ts = new TestSubscriberEx<>()\n+        .setInitialFusionMode(QueueFuseable.ANY);\n+\n+        Flowable.empty()\n+        .observeOn(ImmediateThinScheduler.INSTANCE)\n+        .filter(v -> true)\n+        .mapOptional(Optional::of)\n+        .filter(v -> true)\n+        .subscribe(ts)\n+        ;\n+\n+        ts.assertResult();\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMapTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMapTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMapTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMapTest.java\n@@ -28,6 +28,7 @@\n import io.reactivex.rxjava3.functions.*;\n import io.reactivex.rxjava3.internal.functions.Functions;\n import io.reactivex.rxjava3.internal.fuseable.*;\n+import io.reactivex.rxjava3.internal.schedulers.ImmediateThinScheduler;\n import io.reactivex.rxjava3.internal.subscriptions.BooleanSubscription;\n import io.reactivex.rxjava3.plugins.RxJavaPlugins;\n import io.reactivex.rxjava3.processors.*;\n@@ -617,4 +618,19 @@ public Object apply(Flowable<Object> f) throws Exception {\n         }, false, 1, 1, 1);\n     }\n \n+    @Test\n+    public void conditionalFusionNoNPE() {\n+        TestSubscriberEx<Object> ts = new TestSubscriberEx<>()\n+        .setInitialFusionMode(QueueFuseable.ANY);\n+\n+        Flowable.empty()\n+        .observeOn(ImmediateThinScheduler.INSTANCE)\n+        .filter(v -> true)\n+        .map(v -> v)\n+        .filter(v -> true)\n+        .subscribe(ts)\n+        ;\n+\n+        ts.assertResult();\n+    }\n }",
    "output": "Fix map() conditional chain causing NPE"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n@@ -2667,19 +2667,17 @@ public void issue6974Part2Case2Loop() {\n \n     static void issue6974RunPart2NoEvict(int groupByBufferSize, int flatMapMaxConcurrency, int groups,\n             boolean notifyOnExplicitEviction) {\n-        TestSubscriber<Integer> ts = Flowable\n+    \t\n+        Flowable\n         .range(1, 500_000)\n         .map(i -> i % groups)\n         .groupBy(i -> i)\n         .flatMap(gf -> gf\n                 .take(10, TimeUnit.MILLISECONDS)\n                 , flatMapMaxConcurrency)\n-        .test();\n-\n-        ts\n+        .subscribeWith(new TestSubscriberEx<>())\n         .awaitDone(5, TimeUnit.SECONDS)\n-        .assertNoErrors()\n-        .assertComplete();\n+        .assertTerminated(); // MBE is possible if the async group closing is slow\n     }\n \n     @Test",
    "output": "Fix for issue #7001"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n@@ -2719,10 +2719,9 @@ public void issue6974Part2Case1ObserveOn() {\n                      // .take(10)\n                      .take(10, TimeUnit.MILLISECONDS)\n             , flatMapMaxConcurrency)\n-        .test()\n+        .subscribeWith(new TestSubscriberEx<>())\n         .awaitDone(5, TimeUnit.SECONDS)\n-        .assertNoErrors()\n-        .assertComplete();\n+        .assertTerminated(); // MBE is possible if the async group closing is slow\n     }\n \n     @Test\n@@ -2746,10 +2745,9 @@ public void issue6974Part2Case1ObserveOnHide() {\n                      // .take(10)\n                      .take(10, TimeUnit.MILLISECONDS)\n             , flatMapMaxConcurrency)\n-        .test()\n+        .subscribeWith(new TestSubscriberEx<>())\n         .awaitDone(5, TimeUnit.SECONDS)\n-        .assertNoErrors()\n-        .assertComplete();\n+        .assertTerminated(); // MBE is possible if the async group closing is slow\n     }\n \n     @Test\n@@ -2834,10 +2832,9 @@ public void issue6974Part2Case1ObserveOnConditional() {\n                      // .take(10)\n                      .take(10, TimeUnit.MILLISECONDS)\n             , flatMapMaxConcurrency)\n-        .test()\n+        .subscribeWith(new TestSubscriberEx<>())\n         .awaitDone(5, TimeUnit.SECONDS)\n-        .assertNoErrors()\n-        .assertComplete();\n+        .assertTerminated(); // MBE is possible if the async group closing is slow\n     }\n \n     @Test\n@@ -2862,10 +2859,9 @@ public void issue6974Part2Case1ObserveOnConditionalHide() {\n                      // .take(10)\n                      .take(10, TimeUnit.MILLISECONDS)\n             , flatMapMaxConcurrency)\n-        .test()\n+        .subscribeWith(new TestSubscriberEx<>())\n         .awaitDone(5, TimeUnit.SECONDS)\n-        .assertNoErrors()\n-        .assertComplete();\n+        .assertTerminated(); // MBE is possible if the async group closing is slow\n     }\n \n     /*",
    "output": "Fix recent groupBy tests sometimes failing with MBE"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n@@ -214,9 +214,7 @@ public void onError(Throwable t) {\n                 g.onError(t);\n             }\n             groups.clear();\n-            if (evictedGroups != null) {\n-                evictedGroups.clear();\n-            }\n+            completeEvictions();\n             downstream.onError(t);\n         }\n \n@@ -226,10 +224,10 @@ public void onComplete() {\n                 for (GroupedUnicast<K, V> g : groups.values()) {\n                     g.onComplete();\n                 }\n+\n                 groups.clear();\n-                if (evictedGroups != null) {\n-                    evictedGroups.clear();\n-                }\n+                completeEvictions();\n+\n                 done = true;\n                 downstream.onComplete();\n             }\n@@ -594,6 +592,11 @@ void cleanupQueue(long emitted, boolean polled) {\n             while (queue.poll() != null) {\n                 emitted++;\n             }\n+\n+            replenishParent(emitted, polled);\n+        }\n+\n+        void replenishParent(long emitted, boolean polled) {\n             if (polled) {\n                 emitted++;\n             }\n@@ -618,6 +621,9 @@ boolean checkTerminated(boolean d, boolean empty, Subscriber<? super T> a,\n                             a.onError(e);\n                         } else {\n                             a.onComplete();\n+                            // completion doesn't mean the parent has completed\n+                            // because of evicted groups\n+                            replenishParent(emitted, polled);\n                         }\n                         return true;\n                     }\n@@ -632,6 +638,10 @@ boolean checkTerminated(boolean d, boolean empty, Subscriber<? super T> a,\n                     if (empty) {\n                         cancelled.lazySet(true);\n                         a.onComplete();\n+\n+                        // completion doesn't mean the parent has completed\n+                        // because of evicted groups\n+                        replenishParent(emitted, polled);\n                         return true;\n                     }\n                 }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n@@ -18,11 +18,12 @@\n import static org.mockito.Mockito.*;\n \n import java.io.IOException;\n+import java.time.Duration;\n import java.util.*;\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.*;\n \n-import org.junit.*;\n+import org.junit.Test;\n import org.mockito.Mockito;\n import org.reactivestreams.*;\n \n@@ -2876,4 +2877,82 @@ public void issue6974Part2Case1ObserveOnHideLoop() {\n         }\n     }\n     */\n+\n+    static <T> Function<Consumer<Object>, ConcurrentMap<T, Object>> ttlCapGuava(Duration ttl) {\n+        return itemEvictConsumer ->\n+            CacheBuilder\n+            .newBuilder()\n+            .expireAfterWrite(ttl)\n+            .removalListener(n -> {\n+                if (n.getCause() != com.google.common.cache.RemovalCause.EXPLICIT) {\n+                    try {\n+                        itemEvictConsumer.accept(n.getValue());\n+                    } catch (Throwable throwable) {\n+                        throw new RuntimeException(throwable);\n+                    }\n+                }\n+            }).<T, Object>build().asMap();\n+    }\n+\n+    @Test\n+    public void issue6982Case1() {\n+        final int groups = 20;\n+\n+        int groupByBufferSize = 2;\n+        int flatMapMaxConcurrency = 200 * groups;\n+\n+        // ~50% of executions - Not completed (latch = 1, values = 500000, errors = 0, completions = 0, timeout!,\n+        // disposed!)\n+\n+        Flowable\n+        .range(1, 500_000)\n+        .map(i -> i % groups)\n+        .groupBy(i -> i, i -> i, false, groupByBufferSize, ttlCapGuava(Duration.ofMillis(10)))\n+        .flatMap(gf -> gf.observeOn(Schedulers.computation()), flatMapMaxConcurrency)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertNoErrors()\n+        .assertComplete();\n+    }\n+\n+    /*\n+     * Disabled: Takes very long. Run it locally only.\n+    @Test\n+    public void issue6982Case1Loop() {\n+        for (int i = 0; i < 200; i++) {\n+            System.out.println(\"issue6982Case1Loop \"  + i);\n+            issue6982Case1();\n+        }\n+    }\n+     */\n+\n+    @Test\n+    public void issue6982Case2() {\n+        final int groups = 20;\n+\n+        int groupByBufferSize = groups * 30;\n+        int flatMapMaxConcurrency = groups * 500;\n+        // Always : Not completed (latch = 1, values = 14100, errors = 0, completions = 0, timeout!, disposed!)\n+\n+        Flowable\n+        .range(1, 500_000)\n+        .map(i -> i % groups)\n+        .groupBy(i -> i, i -> i, false, groupByBufferSize, ttlCapGuava(Duration.ofMillis(10)))\n+        .flatMap(gf -> gf.observeOn(Schedulers.computation()), flatMapMaxConcurrency)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertNoErrors()\n+        .assertComplete();\n+    }\n+\n+    /*\n+     * Disabled: Takes very long. Run it locally only.\n+    @Test\n+    public void issue6982Case2Loop() {\n+        for (int i = 0; i < 200; i++) {\n+            System.out.println(\"issue6982Case2Loop \"  + i);\n+            issue6982Case2();\n+        }\n+    }\n+     */\n }",
    "output": "Fix Flowable.groupBy eviction-completion-replenishment problems"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/rxjava3/subjects/ReplaySubjectTest.java b/src/test/java/io/reactivex/rxjava3/subjects/ReplaySubjectTest.java\n--- a/src/test/java/io/reactivex/rxjava3/subjects/ReplaySubjectTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/subjects/ReplaySubjectTest.java\n@@ -797,6 +797,7 @@ public void getValuesUnbounded() {\n \n     }\n \n+    @Test\n     public void createInvalidCapacity() {\n         try {\n             ReplaySubject.create(-99);",
    "output": "Add missing `@Test` annotation"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n@@ -270,9 +270,10 @@ private void completeEvictions() {\n \n         public void cancel(K key) {\n             Object mapKey = key != null ? key : NULL_KEY;\n-            groups.remove(mapKey);\n-            if (groupCount.decrementAndGet() == 0) {\n-                upstream.cancel();\n+            if (groups.remove(mapKey) != null) {\n+                if (groupCount.decrementAndGet() == 0) {\n+                    upstream.cancel();\n+                }\n             }\n         }\n \n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n@@ -2558,4 +2558,50 @@ public void subscribeAbandonRace() throws Throwable {\n             ts.assertValueCount(1);\n         }\n     }\n+\n+    @Test\n+    public void issue6974() {\n+\n+        FlowableTransformer<Integer, Integer> operation =\n+                source -> source.publish(shared ->\n+                    shared\n+                    .firstElement()\n+                    .flatMapPublisher(firstElement ->\n+                        Flowable.just(firstElement).concatWith(shared)\n+                    )\n+                );\n+\n+        issue6974Run(20, 500_000, 20 - 1, 20 * 2, operation, false);\n+\n+        issue6974Run(20, 500_000, 20, 20 * 2, operation, false);\n+    }\n+\n+    static void issue6974Run(int groups, int iterations, int sizeCap, int flatMapConcurrency,\n+            FlowableTransformer<Integer, Integer> operation, boolean notifyOnExplicitRevoke) {\n+        TestSubscriber<Integer> test = Flowable\n+                .range(1, groups)\n+                .repeat(iterations / groups)\n+                .groupBy(i -> i, i -> i, false, 128, sizeCap(sizeCap, notifyOnExplicitRevoke))\n+                .flatMap(gf -> gf.compose(operation), flatMapConcurrency)\n+                .test();\n+        test.awaitDone(5, TimeUnit.SECONDS);\n+        test.assertValueCount(iterations);\n+    }\n+\n+    static <T> Function<Consumer<Object>, Map<T, Object>> sizeCap(int maxCapacity, boolean notifyOnExplicit) {\n+        return itemEvictConsumer ->\n+        CacheBuilder\n+        .newBuilder()\n+        .maximumSize(maxCapacity)\n+        .removalListener(notification -> {\n+            if (notification.getCause() != RemovalCause.EXPLICIT || notifyOnExplicit) {\n+                try {\n+                    itemEvictConsumer.accept(notification.getValue());\n+                } catch (Throwable throwable) {\n+                    throw new RuntimeException(throwable);\n+                }\n+            }\n+        })\n+        .<T, Object>build().asMap();\n+    }\n }",
    "output": "Fix Flowable.groupBy eviction logic double decrement and hang"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMap.java b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMap.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMap.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMap.java\n@@ -318,6 +318,7 @@ void drainLoop() {\n                 if (checkTerminate()) {\n                     return;\n                 }\n+                int innerCompleted = 0;\n                 SimplePlainQueue<U> svq = queue;\n \n                 if (svq != null) {\n@@ -333,9 +334,18 @@ void drainLoop() {\n                         }\n \n                         child.onNext(o);\n+                        innerCompleted++;\n                     }\n                 }\n \n+                if (innerCompleted != 0) {\n+                    if (maxConcurrency != Integer.MAX_VALUE) {\n+                        subscribeMore(innerCompleted);\n+                        innerCompleted = 0;\n+                    }\n+                    continue;\n+                }\n+\n                 boolean d = done;\n                 svq = queue;\n                 InnerObserver<?, ?>[] inner = observers.get();\n@@ -353,7 +363,6 @@ void drainLoop() {\n                     return;\n                 }\n \n-                int innerCompleted = 0;\n                 if (n != 0) {\n                     int j = Math.min(n - 1, lastIndex);\n \n@@ -415,27 +424,33 @@ void drainLoop() {\n \n                 if (innerCompleted != 0) {\n                     if (maxConcurrency != Integer.MAX_VALUE) {\n-                        while (innerCompleted-- != 0) {\n-                            ObservableSource<? extends U> p;\n-                            synchronized (this) {\n-                                p = sources.poll();\n-                                if (p == null) {\n-                                    wip--;\n-                                    continue;\n-                                }\n-                            }\n-                            subscribeInner(p);\n-                        }\n+                        subscribeMore(innerCompleted);\n+                        innerCompleted = 0;\n                     }\n                     continue;\n                 }\n+\n                 missed = addAndGet(-missed);\n                 if (missed == 0) {\n                     break;\n                 }\n             }\n         }\n \n+        void subscribeMore(int innerCompleted) {\n+            while (innerCompleted-- != 0) {\n+                ObservableSource<? extends U> p;\n+                synchronized (this) {\n+                    p = sources.poll();\n+                    if (p == null) {\n+                        wip--;\n+                        continue;\n+                    }\n+                }\n+                subscribeInner(p);\n+            }\n+        }\n+\n         boolean checkTerminate() {\n             if (disposed) {\n                 return true;\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapTest.java\n@@ -1478,4 +1478,28 @@ public void innerCompletesAfterOnNextInDrainThenCancels() {\n         .requestMore(1)\n         .assertValuesOnly(1);\n     }\n+\n+    @Test(timeout = 5000)\n+    public void mixedScalarAsync() {\n+        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {\n+            Flowable\n+            .range(0, 20)\n+            .flatMap(\n+                    integer -> {\n+                        if (integer % 5 != 0) {\n+                            return Flowable\n+                                    .just(integer);\n+                        }\n+\n+                        return Flowable\n+                                .just(-integer)\n+                                .observeOn(Schedulers.computation());\n+                    },\n+                    false,\n+                    1\n+            )\n+            .ignoreElements()\n+            .blockingAwait();\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapTest.java\n@@ -1240,4 +1240,28 @@ public void fusedInnerCrash2() {\n \n         to.assertFailure(TestException.class, 1, 2);\n     }\n+\n+    @Test(timeout = 5000)\n+    public void mixedScalarAsync() {\n+        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {\n+            Observable\n+            .range(0, 20)\n+            .flatMap(\n+                    integer -> {\n+                        if (integer % 5 != 0) {\n+                            return Observable\n+                                    .just(integer);\n+                        }\n+\n+                        return Observable\n+                                .just(-integer)\n+                                .observeOn(Schedulers.computation());\n+                    },\n+                    false,\n+                    1\n+            )\n+            .ignoreElements()\n+            .blockingAwait();\n+        }\n+    }\n }",
    "output": "Fix Observable.flatMap with maxConcurrency hangs\n\n* Fix Observable.flatMap with maxConcurrency hangs\r\n\r\n* Verify Flowable"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Completable.java b/src/main/java/io/reactivex/rxjava3/core/Completable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Completable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Completable.java\n@@ -18,7 +18,6 @@\n import org.reactivestreams.*;\n \n import io.reactivex.rxjava3.annotations.*;\n-import io.reactivex.rxjava3.core.Observable;\n import io.reactivex.rxjava3.disposables.Disposable;\n import io.reactivex.rxjava3.exceptions.*;\n import io.reactivex.rxjava3.functions.*;\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/core/Maybe.java b/src/main/java/io/reactivex/rxjava3/core/Maybe.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Maybe.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Maybe.java\n@@ -20,7 +20,6 @@\n import org.reactivestreams.*;\n \n import io.reactivex.rxjava3.annotations.*;\n-import io.reactivex.rxjava3.core.Observable;\n import io.reactivex.rxjava3.disposables.Disposable;\n import io.reactivex.rxjava3.exceptions.*;\n import io.reactivex.rxjava3.functions.*;",
    "output": "Remove unused imports"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Flowable.java b/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Flowable.java\n@@ -2921,11 +2921,12 @@ public static Flowable<Long> interval(long period, @NonNull TimeUnit unit, @NonN\n      * @throws IllegalArgumentException\n      *             if {@code count} is less than zero, or if {@code start} + {@code count} &minus; 1 exceeds\n      *             {@link Long#MAX_VALUE}\n+     * @see #range(int, int)\n      */\n     @CheckReturnValue\n+    @NonNull\n     @BackpressureSupport(BackpressureKind.ERROR)\n     @SchedulerSupport(SchedulerSupport.COMPUTATION)\n-    @NonNull\n     public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, @NonNull TimeUnit unit) {\n         return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());\n     }\n@@ -4386,6 +4387,8 @@ public static <T> Flowable<T> never() {\n      *             if {@code count} is less than zero, or if {@code start} + {@code count} &minus; 1 exceeds\n      *             {@link Integer#MAX_VALUE}\n      * @see <a href=\"http://reactivex.io/documentation/operators/range.html\">ReactiveX operators documentation: Range</a>\n+     * @see #rangeLong(long, long)\n+     * @see #intervalRange(long, long, long, long, TimeUnit)\n      */\n     @CheckReturnValue\n     @BackpressureSupport(BackpressureKind.FULL)\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/core/Observable.java b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Observable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n@@ -2537,10 +2537,11 @@ public static Observable<Long> interval(long period, @NonNull TimeUnit unit, @No\n      * @throws IllegalArgumentException\n      *             if {@code count} is negative, or if {@code start} + {@code count} &minus; 1 exceeds\n      *             {@link Long#MAX_VALUE}\n+     * @see #range(int, int)\n      */\n     @CheckReturnValue\n-    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n     @NonNull\n+    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n     public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, @NonNull TimeUnit unit) {\n         return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());\n     }\n@@ -3895,6 +3896,8 @@ public static <T> Observable<T> never() {\n      *             if {@code count} is negative, or if {@code start} + {@code count} &minus; 1 exceeds\n      *             {@link Integer#MAX_VALUE}\n      * @see <a href=\"http://reactivex.io/documentation/operators/range.html\">ReactiveX operators documentation: Range</a>\n+     * @see #rangeLong(long, long)\n+     * @see #intervalRange(long, long, long, long, TimeUnit)\n      */\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n@@ -3933,6 +3936,7 @@ public static Observable<Integer> range(int start, int count) {\n      *             if {@code count} is negative, or if {@code start} + {@code count} &minus; 1 exceeds\n      *             {@link Long#MAX_VALUE}\n      * @see <a href=\"http://reactivex.io/documentation/operators/range.html\">ReactiveX operators documentation: Range</a>\n+     * @see #intervalRange(long, long, long, long, TimeUnit)\n      */\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)",
    "output": "Add see annotation for range operators"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchMap.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchMap.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchMap.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchMap.java\n@@ -198,7 +198,6 @@ void drain() {\n             for (;;) {\n \n                 if (cancelled) {\n-                    active.lazySet(null);\n                     return;\n                 }\n \n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchTest.java\n@@ -19,7 +19,7 @@\n \n import java.util.*;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.*;\n \n import org.junit.*;\n import org.mockito.InOrder;\n@@ -1337,4 +1337,44 @@ public void innerCompletedBackpressureBoundaryDelayError() {\n \n         ts.assertValuesOnly(1);\n     }\n+\n+    @Test\n+    public void cancellationShouldTriggerInnerCancellationRace() throws Throwable {\n+        AtomicInteger outer = new AtomicInteger();\n+        AtomicInteger inner = new AtomicInteger();\n+\n+        int n = 10_000;\n+        for (int i = 0; i < n; i++) {\n+            Flowable.<Integer>create(it -> {\n+                it.onNext(0);\n+            }, BackpressureStrategy.MISSING)\n+            .switchMap(v -> createFlowable(inner))\n+            .observeOn(Schedulers.computation())\n+            .doFinally(() -> {\n+                outer.incrementAndGet();\n+            })\n+            .take(1)\n+            .blockingSubscribe(v -> { }, Throwable::printStackTrace);\n+        }\n+\n+        Thread.sleep(100);\n+        assertEquals(inner.get(), outer.get());\n+        assertEquals(n, inner.get());\n+    }\n+\n+    Flowable<Integer> createFlowable(AtomicInteger inner) {\n+        return Flowable.<Integer>unsafeCreate(s -> {\n+            SerializedSubscriber<Integer> it = new SerializedSubscriber<>(s);\n+            it.onSubscribe(new BooleanSubscription());\n+            Schedulers.io().scheduleDirect(() -> {\n+                it.onNext(1);\n+            }, 0, TimeUnit.MILLISECONDS);\n+            Schedulers.io().scheduleDirect(() -> {\n+                it.onNext(2);\n+            }, 0, TimeUnit.MILLISECONDS);\n+        })\n+        .doFinally(() -> {\n+            inner.incrementAndGet();\n+        });\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchTest.java\n@@ -34,7 +34,7 @@\n import io.reactivex.rxjava3.internal.functions.Functions;\n import io.reactivex.rxjava3.internal.schedulers.ImmediateThinScheduler;\n import io.reactivex.rxjava3.internal.util.ExceptionHelper;\n-import io.reactivex.rxjava3.observers.TestObserver;\n+import io.reactivex.rxjava3.observers.*;\n import io.reactivex.rxjava3.plugins.RxJavaPlugins;\n import io.reactivex.rxjava3.schedulers.*;\n import io.reactivex.rxjava3.subjects.PublishSubject;\n@@ -1398,4 +1398,44 @@ public void innerIgnoresCancelAndErrors() throws Throwable {\n             TestHelper.assertUndeliverable(errors, 0, TestException.class);\n         });\n     }\n+\n+    @Test\n+    public void cancellationShouldTriggerInnerCancellationRace() throws Throwable {\n+        AtomicInteger outer = new AtomicInteger();\n+        AtomicInteger inner = new AtomicInteger();\n+\n+        int n = 10_000;\n+        for (int i = 0; i < n; i++) {\n+            Observable.<Integer>create(it -> {\n+                it.onNext(0);\n+            })\n+            .switchMap(v -> createObservable(inner))\n+            .observeOn(Schedulers.computation())\n+            .doFinally(() -> {\n+                outer.incrementAndGet();\n+            })\n+            .take(1)\n+            .blockingSubscribe(v -> { }, Throwable::printStackTrace);\n+        }\n+\n+        Thread.sleep(100);\n+        assertEquals(inner.get(), outer.get());\n+        assertEquals(n, inner.get());\n+    }\n+\n+    Observable<Integer> createObservable(AtomicInteger inner) {\n+        return Observable.<Integer>unsafeCreate(s -> {\n+            SerializedObserver<Integer> it = new SerializedObserver<>(s);\n+            it.onSubscribe(Disposable.empty());\n+            Schedulers.io().scheduleDirect(() -> {\n+                it.onNext(1);\n+            }, 0, TimeUnit.MILLISECONDS);\n+            Schedulers.io().scheduleDirect(() -> {\n+                it.onNext(2);\n+            }, 0, TimeUnit.MILLISECONDS);\n+        })\n+        .doFinally(() -> {\n+            inner.incrementAndGet();\n+        });\n+    }\n }",
    "output": "Fix switchMap not canceling properly during onNext-cancel races"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n@@ -401,6 +401,7 @@ public void request(long n) {\n         public void cancel() {\n             if (cancelled.compareAndSet(false, true)) {\n                 cancelParent();\n+                drain();\n             }\n         }\n \n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n@@ -2444,4 +2444,38 @@ public void accept(Integer v) throws Throwable {\n         .assertNoErrors()\n         .assertComplete();\n     }\n+\n+    @Test\n+    public void cancelledGroupResumesRequesting() {\n+        final List<TestSubscriber<Integer>> tss = new ArrayList<>();\n+        final AtomicInteger counter = new AtomicInteger();\n+        final AtomicBoolean done = new AtomicBoolean();\n+        Flowable.range(1, 1000)\n+                .doOnNext(new Consumer<Integer>() {\n+                    @Override\n+                    public void accept(Integer v) throws Exception {\n+                        counter.getAndIncrement();\n+                    }\n+                })\n+                .groupBy(Functions.justFunction(1))\n+                .subscribe(new Consumer<GroupedFlowable<Integer, Integer>>() {\n+                    @Override\n+                    public void accept(GroupedFlowable<Integer, Integer> v) throws Exception {\n+                        TestSubscriber<Integer> ts = TestSubscriber.create(0L);\n+                        tss.add(ts);\n+                        v.subscribe(ts);\n+                    }\n+                }, Functions.emptyConsumer(), new Action() {\n+                    @Override\n+                    public void run() throws Exception {\n+                        done.set(true);\n+                    }\n+                });\n+\n+        while (!done.get()) {\n+            tss.remove(0).cancel();\n+        }\n+\n+        assertEquals(1000, counter.get());\n+    }\n }",
    "output": "Fix groupBy not requesting more if a group is cancelled w/ items"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Completable.java b/src/main/java/io/reactivex/rxjava3/core/Completable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Completable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Completable.java\n@@ -29,7 +29,7 @@\n import io.reactivex.rxjava3.internal.operators.completable.*;\n import io.reactivex.rxjava3.internal.operators.maybe.*;\n import io.reactivex.rxjava3.internal.operators.mixed.*;\n-import io.reactivex.rxjava3.internal.operators.single.SingleDelayWithCompletable;\n+import io.reactivex.rxjava3.internal.operators.single.*;\n import io.reactivex.rxjava3.observers.TestObserver;\n import io.reactivex.rxjava3.plugins.RxJavaPlugins;\n import io.reactivex.rxjava3.schedulers.Schedulers;\n@@ -414,6 +414,29 @@ public static Completable create(@NonNull CompletableOnSubscribe source) {\n         return RxJavaPlugins.onAssembly(new CompletableCreate(source));\n     }\n \n+    /**\n+     * Compares two {@link CompletableSource}s and emits {@code true} via a {@link Single} if both complete.\n+     * <p>\n+     * <img width=\"640\" height=\"187\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.sequenceEqual.png\" alt=\"\">\n+     * <dl>\n+     * <dt><b>Scheduler:</b></dt>\n+     * <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.</dd>\n+     * </dl>\n+     * @param source1 the first {@code CompletableSource} instance\n+     * @param source2 the second {@code CompletableSource} instance\n+     * @return the new {@code Single} instance\n+     * @throws NullPointerException if {@code source1} or {@code source2} is {@code null}\n+     * @since 3.0.0\n+     */\n+    @CheckReturnValue\n+    @NonNull\n+    @SchedulerSupport(SchedulerSupport.NONE)\n+    public static Single<Boolean> sequenceEqual(@NonNull CompletableSource source1, @NonNull CompletableSource source2) { // NOPMD\n+        Objects.requireNonNull(source1, \"source1 is null\");\n+        Objects.requireNonNull(source2, \"source2 is null\");\n+        return mergeArrayDelayError(source1, source2).andThen(Single.just(true));\n+    }\n+\n     /**\n      * Constructs a {@code Completable} instance by wrapping the given source callback\n      * <strong>without any safeguards; you should manage the lifecycle and response\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/completable/CompletableSequenceEqualTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/completable/CompletableSequenceEqualTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/completable/CompletableSequenceEqualTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/completable/CompletableSequenceEqualTest.java\n@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.rxjava3.internal.operators.completable;\n+\n+import org.junit.Test;\n+\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.exceptions.TestException;\n+\n+public class CompletableSequenceEqualTest {\n+\n+    @Test\n+    public void bothComplete() {\n+        Completable.sequenceEqual(Completable.complete(), Completable.complete())\n+        .test()\n+        .assertResult(true);\n+    }\n+\n+    @Test\n+    public void firstFails() {\n+        Completable.sequenceEqual(Completable.error(new TestException()), Completable.complete())\n+        .test()\n+        .assertFailure(TestException.class);\n+    }\n+\n+    @Test\n+    public void secondFails() {\n+        Completable.sequenceEqual(Completable.complete(), Completable.error(new TestException()))\n+        .test()\n+        .assertFailure(TestException.class);\n+    }\n+}",
    "output": "Add Completable.sequenceEqual"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java b/src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java\n@@ -61,7 +61,7 @@ public static void main(String[] args) throws IOException {\n         List<String> sortedOperators = new ArrayList<>(operatorSet);\n         sortedOperators.sort(Comparator.naturalOrder());\n \n-        try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(Paths.get(\"docs\", \"Operator-Matrix.md\"), StandardOpenOption.CREATE))) {\n+        try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(Paths.get(\"docs\", \"Operator-Matrix.md\"), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING))) {\n             out.print(\"Operator |\");\n             for (Class<?> clazz : CLASSES) {\n                 out.print(\" `\");",
    "output": "Fix a minor mistake in the generator and docs"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java b/src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java\n@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.rxjava3.internal.util;\n+\n+import java.io.*;\n+import java.lang.reflect.Method;\n+import java.nio.file.*;\n+import java.util.*;\n+\n+import io.reactivex.rxjava3.core.*;\n+import io.reactivex.rxjava3.core.Observable;\n+\n+/**\n+ * Generate a table of available operators across base classes in {@code Operator-Matrix.md}.\n+ * \n+ * Should be run with the main project directory as working directory where the {@code docs}\n+ * folder is.\n+ */\n+public final class OperatorMatrixGenerator {\n+\n+    private OperatorMatrixGenerator() {\n+        throw new IllegalStateException(\"No instances!\");\n+    }\n+\n+    static final String PRESENT = \"![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)\";\n+    static final String ABSENT = \"![absent](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_off.png)\";\n+\n+    static final Class<?>[] CLASSES = {\n+            Flowable.class, Observable.class, Maybe.class, Single.class, Completable.class\n+    };\n+\n+    public static void main(String[] args) throws IOException {\n+        Set<String> operatorSet = new HashSet<>();\n+        Map<Class<?>, Set<String>> operatorMap = new HashMap<>();\n+\n+        for (Class<?> clazz : CLASSES) {\n+            Set<String> set = operatorMap.computeIfAbsent(clazz, c -> new HashSet<String>());\n+\n+            for (Method m : clazz.getMethods()) {\n+                String name = m.getName();\n+                if (!name.equals(\"bufferSize\")\n+                        && m.getDeclaringClass() == clazz\n+                        && !m.isSynthetic()) {\n+                    operatorSet.add(m.getName());\n+                    set.add(m.getName());\n+                }\n+            }\n+        }\n+\n+        List<String> sortedOperators = new ArrayList<>(operatorSet);\n+        sortedOperators.sort(Comparator.naturalOrder());\n+\n+        try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(Paths.get(\"docs\", \"Operator-Matrix.md\"), StandardOpenOption.CREATE))) {\n+            out.print(\"Operator |\");\n+            for (Class<?> clazz : CLASSES) {\n+                out.print(\" `\");\n+                out.print(clazz.getSimpleName());\n+                out.print(\"` |\");\n+            }\n+            out.println();\n+            out.print(\"-----|\");\n+            for (int i = 0; i < CLASSES.length; i++) {\n+                out.print(\":---:|\");\n+            }\n+            out.println();\n+            for (String operatorName : sortedOperators) {\n+                out.print(\"`\");\n+                out.print(operatorName);\n+                out.print(\"`|\");\n+                for (Class<?> clazz : CLASSES) {\n+                    if (operatorMap.get(clazz).contains(operatorName)) {\n+                        out.print(PRESENT);\n+                    } else {\n+                        out.print(ABSENT);\n+                    }\n+                    out.print(\"|\");\n+                }\n+                out.println();\n+            }\n+        }\n+    }\n+}",
    "output": "Add operator matrix wiki + auto-extractor\n\n* Add operator matrix wiki + auto-extractor\r\n\r\n* Skip Object methods\r\n\r\n* Only declared in that class\r\n\r\n* Remove onExceptionResumeNext"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Maybe.java b/src/main/java/io/reactivex/rxjava3/core/Maybe.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Maybe.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Maybe.java\n@@ -3939,7 +3939,7 @@ public final Maybe<T> onErrorResumeWith(@NonNull MaybeSource<? extends T> next)\n     @SchedulerSupport(SchedulerSupport.NONE)\n     public final Maybe<T> onErrorResumeNext(@NonNull Function<? super Throwable, ? extends MaybeSource<? extends T>> resumeFunction) {\n         Objects.requireNonNull(resumeFunction, \"resumeFunction is null\");\n-        return RxJavaPlugins.onAssembly(new MaybeOnErrorNext<>(this, resumeFunction, true));\n+        return RxJavaPlugins.onAssembly(new MaybeOnErrorNext<>(this, resumeFunction));\n     }\n \n     /**\n@@ -3996,37 +3996,6 @@ public final Maybe<T> onErrorReturnItem(@NonNull T item) {\n         return onErrorReturn(Functions.justFunction(item));\n     }\n \n-    /**\n-     * Resumes the flow with the given {@link MaybeSource} when the current {@code Maybe} fails\n-     * with an {@link Exception} subclass instead of signaling the error via {@code onError}.\n-     * <p>\n-     * This differs from {@link #onErrorResumeNext} in that this one does not handle {@link java.lang.Throwable}\n-     * or {@link java.lang.Error} but lets those continue through.\n-     * <p>\n-     * <img width=\"640\" height=\"333\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onExceptionResumeNextViaMaybe.png\" alt=\"\">\n-     * <p>\n-     * You can use this to prevent exceptions from propagating or to supply fallback data should exceptions be\n-     * encountered.\n-     * <dl>\n-     *  <dt><b>Scheduler:</b></dt>\n-     *  <dd>{@code onExceptionResumeNext} does not operate by default on a particular {@link Scheduler}.</dd>\n-     * </dl>\n-     *\n-     * @param next\n-     *            the next {@code MaybeSource} that will take over if the current {@code Maybe} encounters\n-     *            an exception\n-     * @return the new {@code Maybe} instance\n-     * @throws NullPointerException if {@code next} is {@code null}\n-     * @see <a href=\"http://reactivex.io/documentation/operators/catch.html\">ReactiveX operators documentation: Catch</a>\n-     */\n-    @CheckReturnValue\n-    @NonNull\n-    @SchedulerSupport(SchedulerSupport.NONE)\n-    public final Maybe<T> onExceptionResumeNext(@NonNull MaybeSource<? extends T> next) {\n-        Objects.requireNonNull(next, \"next is null\");\n-        return RxJavaPlugins.onAssembly(new MaybeOnErrorNext<>(this, Functions.justFunction(next), false));\n-    }\n-\n     /**\n      * Nulls out references to the upstream producer and downstream {@link MaybeObserver} if\n      * the sequence is terminated or downstream calls {@code dispose()}.\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorNext.java b/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorNext.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorNext.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorNext.java\n@@ -31,19 +31,15 @@ public final class MaybeOnErrorNext<T> extends AbstractMaybeWithUpstream<T, T> {\n \n     final Function<? super Throwable, ? extends MaybeSource<? extends T>> resumeFunction;\n \n-    final boolean allowFatal;\n-\n     public MaybeOnErrorNext(MaybeSource<T> source,\n-            Function<? super Throwable, ? extends MaybeSource<? extends T>> resumeFunction,\n-                    boolean allowFatal) {\n+            Function<? super Throwable, ? extends MaybeSource<? extends T>> resumeFunction) {\n         super(source);\n         this.resumeFunction = resumeFunction;\n-        this.allowFatal = allowFatal;\n     }\n \n     @Override\n     protected void subscribeActual(MaybeObserver<? super T> observer) {\n-        source.subscribe(new OnErrorNextMaybeObserver<>(observer, resumeFunction, allowFatal));\n+        source.subscribe(new OnErrorNextMaybeObserver<>(observer, resumeFunction));\n     }\n \n     static final class OnErrorNextMaybeObserver<T>\n@@ -56,14 +52,10 @@ static final class OnErrorNextMaybeObserver<T>\n \n         final Function<? super Throwable, ? extends MaybeSource<? extends T>> resumeFunction;\n \n-        final boolean allowFatal;\n-\n         OnErrorNextMaybeObserver(MaybeObserver<? super T> actual,\n-                Function<? super Throwable, ? extends MaybeSource<? extends T>> resumeFunction,\n-                        boolean allowFatal) {\n+                Function<? super Throwable, ? extends MaybeSource<? extends T>> resumeFunction) {\n             this.downstream = actual;\n             this.resumeFunction = resumeFunction;\n-            this.allowFatal = allowFatal;\n         }\n \n         @Override\n@@ -90,10 +82,6 @@ public void onSuccess(T value) {\n \n         @Override\n         public void onError(Throwable e) {\n-            if (!allowFatal && !(e instanceof Exception)) {\n-                downstream.onError(e);\n-                return;\n-            }\n             MaybeSource<? extends T> m;\n \n             try {\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorXTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorXTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorXTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorXTest.java\n@@ -98,22 +98,6 @@ public void onErrorResumeNext() {\n         .assertResult(1);\n     }\n \n-    @Test\n-    public void onExceptionResumeNext() {\n-        Maybe.error(new TestException())\n-        .onExceptionResumeNext(Maybe.just(1))\n-        .test()\n-        .assertResult(1);\n-    }\n-\n-    @Test\n-    public void onExceptionResumeNextPassthrough() {\n-        Maybe.error(new AssertionError())\n-        .onExceptionResumeNext(Maybe.just(1))\n-        .test()\n-        .assertFailure(AssertionError.class);\n-    }\n-\n     @Test\n     public void onErrorResumeNextFunctionThrows() {\n         TestHelper.assertCompositeExceptions(Maybe.error(new TestException())",
    "output": "Remove Maybe.onExceptionResumeNext"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Observable.java b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Observable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n@@ -7112,39 +7112,6 @@ public final <U> Observable<U> concatMapIterable(@NonNull Function<? super T, ?\n         return RxJavaPlugins.onAssembly(new ObservableFlattenIterable<>(this, mapper));\n     }\n \n-    /**\n-     * Returns an {@code Observable} that concatenate each item emitted by the current {@code Observable} with the values in an\n-     * {@link Iterable} corresponding to that item that is generated by a selector.\n-     * <p>\n-     * <img width=\"640\" height=\"275\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapIterable.o.png\" alt=\"\">\n-     *\n-     * <dl>\n-     *  <dt><b>Scheduler:</b></dt>\n-     *  <dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.</dd>\n-     * </dl>\n-     *\n-     * @param <U>\n-     *            the type of item emitted by the resulting {@code Observable}\n-     * @param mapper\n-     *            a function that returns an {@code Iterable} sequence of values for when given an item emitted by the\n-     *            current {@code Observable}\n-     * @param bufferSize\n-     *            the number of elements expected from the current {@code Observable} to be buffered\n-     * @return an {@code Observable} that emits the results of concatenating the items emitted by the current {@code Observable} with\n-     *         the values in the {@code Iterable}s corresponding to those items\n-     * @throws NullPointerException if {@code mapper} is {@code null}\n-     * @throws IllegalArgumentException if {@code bufferSize} is non-positive\n-     * @see <a href=\"http://reactivex.io/documentation/operators/flatmap.html\">ReactiveX operators documentation: FlatMap</a>\n-     */\n-    @CheckReturnValue\n-    @SchedulerSupport(SchedulerSupport.NONE)\n-    @NonNull\n-    public final <U> Observable<U> concatMapIterable(@NonNull Function<? super T, ? extends Iterable<? extends U>> mapper, int bufferSize) {\n-        Objects.requireNonNull(mapper, \"mapper is null\");\n-        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n-        return concatMap(ObservableInternalHelper.flatMapIntoIterable(mapper), bufferSize);\n-    }\n-\n     /**\n      * Maps the upstream items into {@link MaybeSource}s and subscribes to them one after the\n      * other succeeds or completes, emits their success value if available or terminates immediately if\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatTest.java\n@@ -879,7 +879,7 @@ public void concatMapIterableBufferSize() {\n             public Iterable<Integer> apply(Integer v) throws Exception {\n                 return Arrays.asList(1, 2, 3, 4, 5);\n             }\n-        }, 1)\n+        })\n         .test()\n         .assertResult(1, 2, 3, 4, 5, 1, 2, 3, 4, 5);\n     }",
    "output": "Remove a pointless concatMapIterable overload"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMap.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMap.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMap.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMap.java\n@@ -321,6 +321,11 @@ public void onError(Throwable t) {\n             }\n             if (errors.tryAddThrowableOrReport(t)) {\n                 done = true;\n+                if (!delayErrors) {\n+                    for (InnerSubscriber<?, ?> a : subscribers.getAndSet(CANCELLED)) {\n+                        a.dispose();\n+                    }\n+                }\n                 drain();\n             }\n         }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapTest.java\n@@ -1116,4 +1116,38 @@ public Publisher<Integer> apply(Integer v) throws Throwable {\n             }\n         });\n     }\n+\n+    @Test\n+    public void mainErrorsInnerCancelled() {\n+        PublishProcessor<Integer> pp1 = PublishProcessor.create();\n+        PublishProcessor<Integer> pp2 = PublishProcessor.create();\n+\n+        pp1\n+        .flatMap(v -> pp2)\n+        .test();\n+\n+        pp1.onNext(1);\n+        assertTrue(\"No subscribers?\", pp2.hasSubscribers());\n+\n+        pp1.onError(new TestException());\n+\n+        assertFalse(\"Has subscribers?\", pp2.hasSubscribers());\n+    }\n+\n+    @Test\n+    public void innerErrorsMainCancelled() {\n+        PublishProcessor<Integer> pp1 = PublishProcessor.create();\n+        PublishProcessor<Integer> pp2 = PublishProcessor.create();\n+\n+        pp1\n+        .flatMap(v -> pp2)\n+        .test();\n+\n+        pp1.onNext(1);\n+        assertTrue(\"No subscribers?\", pp2.hasSubscribers());\n+\n+        pp2.onError(new TestException());\n+\n+        assertFalse(\"Has subscribers?\", pp1.hasSubscribers());\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapTest.java\n@@ -26,7 +26,7 @@\n import io.reactivex.rxjava3.core.*;\n import io.reactivex.rxjava3.core.Observable;\n import io.reactivex.rxjava3.core.Observer;\n-import io.reactivex.rxjava3.disposables.*;\n+import io.reactivex.rxjava3.disposables.Disposable;\n import io.reactivex.rxjava3.exceptions.*;\n import io.reactivex.rxjava3.functions.*;\n import io.reactivex.rxjava3.internal.functions.Functions;\n@@ -1079,4 +1079,38 @@ public Observable<Integer> apply(Integer v) throws Throwable {\n             }\n         });\n     }\n+\n+    @Test\n+    public void mainErrorsInnerCancelled() {\n+        PublishSubject<Integer> ps1 = PublishSubject.create();\n+        PublishSubject<Integer> ps2 = PublishSubject.create();\n+\n+        ps1\n+        .flatMap(v -> ps2)\n+        .test();\n+\n+        ps1.onNext(1);\n+        assertTrue(\"No subscribers?\", ps2.hasObservers());\n+\n+        ps1.onError(new TestException());\n+\n+        assertFalse(\"Has subscribers?\", ps2.hasObservers());\n+    }\n+\n+    @Test\n+    public void innerErrorsMainCancelled() {\n+        PublishSubject<Integer> ps1 = PublishSubject.create();\n+        PublishSubject<Integer> ps2 = PublishSubject.create();\n+\n+        ps1\n+        .flatMap(v -> ps2)\n+        .test();\n+\n+        ps1.onNext(1);\n+        assertTrue(\"No subscribers?\", ps2.hasObservers());\n+\n+        ps2.onError(new TestException());\n+\n+        assertFalse(\"Has subscribers?\", ps1.hasObservers());\n+    }\n }",
    "output": "Fix Flowable.flatMap not canceling the inner sources on outer error"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/core/Observable.java b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n--- a/src/main/java/io/reactivex/rxjava3/core/Observable.java\n+++ b/src/main/java/io/reactivex/rxjava3/core/Observable.java\n@@ -14692,7 +14692,7 @@ public final Flowable<T> toFlowable(@NonNull BackpressureStrategy strategy) {\n     @SchedulerSupport(SchedulerSupport.NONE)\n     @NonNull\n     public final Single<@NonNull List<T>> toSortedList() {\n-        return toSortedList(Functions.naturalOrder());\n+        return toSortedList(Functions.naturalComparator());\n     }\n \n     /**\n@@ -14786,7 +14786,7 @@ public final Flowable<T> toFlowable(@NonNull BackpressureStrategy strategy) {\n     @SchedulerSupport(SchedulerSupport.NONE)\n     @NonNull\n     public final Single<@NonNull List<T>> toSortedList(int capacityHint) {\n-        return toSortedList(Functions.naturalOrder(), capacityHint);\n+        return toSortedList(Functions.naturalComparator(), capacityHint);\n     }\n \n     /**\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/functions/Functions.java b/src/main/java/io/reactivex/rxjava3/internal/functions/Functions.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/functions/Functions.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/functions/Functions.java\n@@ -124,8 +124,6 @@ public static <T> Consumer<T> emptyConsumer() {\n \n     static final Supplier<Object> NULL_SUPPLIER = new NullProvider();\n \n-    static final Comparator<Object> NATURAL_COMPARATOR = new NaturalObjectComparator();\n-\n     @SuppressWarnings(\"unchecked\")\n     @NonNull\n     public static <T> Predicate<T> alwaysTrue() {\n@@ -144,17 +142,6 @@ public static <T> Supplier<T> nullSupplier() {\n         return (Supplier<T>)NULL_SUPPLIER;\n     }\n \n-    /**\n-     * Returns a natural order comparator which casts the parameters to Comparable.\n-     * @param <T> the value type\n-     * @return a natural order comparator which casts the parameters to Comparable\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    @NonNull\n-    public static <T> Comparator<T> naturalOrder() {\n-        return (Comparator<T>)NATURAL_COMPARATOR;\n-    }\n-\n     static final class FutureAction implements Action {\n         final Future<?> future;\n \n@@ -767,14 +754,6 @@ public Object get() {\n         }\n     }\n \n-    static final class NaturalObjectComparator implements Comparator<Object> {\n-        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-        @Override\n-        public int compare(Object a, Object b) {\n-            return ((Comparable)a).compareTo(b);\n-        }\n-    }\n-\n     static final class MaxRequestSubscription implements Consumer<Subscription> {\n         @Override\n         public void accept(Subscription t) {",
    "output": "Remove Functions.naturalOrder"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/functions/ObjectHelper.java b/src/main/java/io/reactivex/rxjava3/internal/functions/ObjectHelper.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/functions/ObjectHelper.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/functions/ObjectHelper.java\n@@ -128,17 +128,4 @@ public boolean test(Object o1, Object o2) {\n             return ObjectHelper.equals(o1, o2);\n         }\n     }\n-\n-    /**\n-     * Trap null-check attempts on primitives.\n-     * @param value the value to check\n-     * @param message the message to print\n-     * @return the value\n-     * @deprecated this method should not be used as there is no need\n-     * to check primitives for nullness.\n-     */\n-    @Deprecated\n-    public static long requireNonNull(long value, String message) {\n-        throw new InternalError(\"Null check on a primitive: \" + message);\n-    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/functions/ObjectHelperTest.java b/src/test/java/io/reactivex/rxjava3/internal/functions/ObjectHelperTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/functions/ObjectHelperTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/functions/ObjectHelperTest.java\n@@ -67,10 +67,4 @@ public void compareLong() {\n         assertEquals(0, ObjectHelper.compare(0L, 0L));\n         assertEquals(1, ObjectHelper.compare(2L, 0L));\n     }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @Test(expected = InternalError.class)\n-    public void requireNonNullPrimitive() {\n-        ObjectHelper.requireNonNull(0, \"value\");\n-    }\n }",
    "output": "Remove deprecated method from 2.x"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/disposables/CompositeDisposable.java b/src/main/java/io/reactivex/rxjava3/disposables/CompositeDisposable.java\n--- a/src/main/java/io/reactivex/rxjava3/disposables/CompositeDisposable.java\n+++ b/src/main/java/io/reactivex/rxjava3/disposables/CompositeDisposable.java\n@@ -16,7 +16,6 @@\n \n import io.reactivex.rxjava3.annotations.NonNull;\n import io.reactivex.rxjava3.exceptions.*;\n-import io.reactivex.rxjava3.internal.disposables.DisposableContainer;\n import io.reactivex.rxjava3.internal.functions.ObjectHelper;\n import io.reactivex.rxjava3.internal.util.*;\n \n\ndiff --git a/src/main/java/io/reactivex/rxjava3/disposables/DisposableContainer.java b/src/main/java/io/reactivex/rxjava3/disposables/DisposableContainer.java\n--- a/src/main/java/io/reactivex/rxjava3/disposables/DisposableContainer.java\n+++ b/src/main/java/io/reactivex/rxjava3/disposables/DisposableContainer.java\n@@ -11,9 +11,7 @@\n  * the License for the specific language governing permissions and limitations under the License.\n  */\n \n-package io.reactivex.rxjava3.internal.disposables;\n-\n-import io.reactivex.rxjava3.disposables.Disposable;\n+package io.reactivex.rxjava3.disposables;\n \n /**\n  * Common interface to add and remove disposables from a container.\n@@ -38,7 +36,7 @@ public interface DisposableContainer {\n     boolean remove(Disposable d);\n \n     /**\n-     * Removes (but does not dispose) the given disposable if it is part of this\n+     * Removes but does not dispose the given disposable if it is part of this\n      * container.\n      * @param d the disposable to remove, not null\n      * @return true if the operation was successful\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/disposables/ListCompositeDisposable.java b/src/main/java/io/reactivex/rxjava3/internal/disposables/ListCompositeDisposable.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/disposables/ListCompositeDisposable.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/disposables/ListCompositeDisposable.java\n@@ -14,7 +14,7 @@\n \n import java.util.*;\n \n-import io.reactivex.rxjava3.disposables.Disposable;\n+import io.reactivex.rxjava3.disposables.*;\n import io.reactivex.rxjava3.exceptions.*;\n import io.reactivex.rxjava3.internal.functions.ObjectHelper;\n import io.reactivex.rxjava3.internal.util.ExceptionHelper;\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/schedulers/NewThreadWorker.java b/src/main/java/io/reactivex/rxjava3/internal/schedulers/NewThreadWorker.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/schedulers/NewThreadWorker.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/schedulers/NewThreadWorker.java\n@@ -17,7 +17,7 @@\n \n import io.reactivex.rxjava3.annotations.*;\n import io.reactivex.rxjava3.core.Scheduler;\n-import io.reactivex.rxjava3.disposables.Disposable;\n+import io.reactivex.rxjava3.disposables.*;\n import io.reactivex.rxjava3.internal.disposables.*;\n import io.reactivex.rxjava3.plugins.RxJavaPlugins;\n \n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/schedulers/ScheduledRunnable.java b/src/main/java/io/reactivex/rxjava3/internal/schedulers/ScheduledRunnable.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/schedulers/ScheduledRunnable.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/schedulers/ScheduledRunnable.java\n@@ -16,8 +16,7 @@\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n \n-import io.reactivex.rxjava3.disposables.Disposable;\n-import io.reactivex.rxjava3.internal.disposables.DisposableContainer;\n+import io.reactivex.rxjava3.disposables.*;\n import io.reactivex.rxjava3.plugins.RxJavaPlugins;\n \n public final class ScheduledRunnable extends AtomicReferenceArray<Object>",
    "output": "Make DisposableContainer public API"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n@@ -743,19 +743,27 @@ public T poll() {\n                 produced++;\n                 return v;\n             }\n+            tryReplenish();\n+            return null;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            if (queue.isEmpty()) {\n+                tryReplenish();\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        void tryReplenish() {\n             int p = produced;\n             if (p != 0) {\n                 produced = 0;\n                 if ((once.get() & ABANDONED) == 0) {\n                     parent.upstream.request(p);\n                 }\n             }\n-            return null;\n-        }\n-\n-        @Override\n-        public boolean isEmpty() {\n-            return queue.isEmpty();\n         }\n \n         @Override\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n@@ -2413,4 +2413,34 @@ public void run() {\n             }\n         }\n     }\n+\n+    @Test\n+    public void fusedParallelGroupProcessing() {\n+        Flowable.range(0, 500000)\n+        .subscribeOn(Schedulers.single())\n+        .groupBy(new Function<Integer, Integer>() {\n+            @Override\n+            public Integer apply(Integer i) throws Throwable {\n+                return i % 2;\n+            }\n+        })\n+        .flatMap(new Function<GroupedFlowable<Integer, Integer>, Publisher<Integer>>() {\n+            @Override\n+            public Publisher<Integer> apply(GroupedFlowable<Integer, Integer> g) {\n+                return g.getKey() == 0\n+                    ? g\n+                        .parallel()\n+                        .runOn(Schedulers.computation())\n+                        .map(Functions.<Integer>identity())\n+                        .sequential()\n+                    : g.map(Functions.<Integer>identity()) // no need to use hide\n+                ;\n+            }\n+        })\n+        .test()\n+        .awaitDone(20, TimeUnit.SECONDS)\n+        .assertValueCount(500000)\n+        .assertComplete()\n+        .assertNoErrors();\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOnTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOnTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOnTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOnTest.java\n@@ -1972,4 +1972,20 @@ public void fusedNoConcurrentCleanDueToCancel() {\n             }\n         }\n     }\n+\n+    @Test\n+    public void fusedParallelProcessing() {\n+        Flowable.range(0, 500000)\n+        .subscribeOn(Schedulers.single())\n+        .observeOn(Schedulers.computation())\n+        .parallel()\n+        .runOn(Schedulers.computation())\n+        .map(Functions.<Integer>identity())\n+        .sequential()\n+        .test()\n+        .awaitDone(20, TimeUnit.SECONDS)\n+        .assertValueCount(500000)\n+        .assertComplete()\n+        .assertNoErrors();\n+    }\n }",
    "output": "Fix parallel() on grouped flowable not replenishing properly\n\n* Fix parallel() on grouped flowable not replenishing properly\r\n\r\n* Remove accidental import\r\n\r\n* Avoid calling `isEmpty`\r\n\r\n* Undo some of the parallel changes\r\n\r\n* Undo all changes to ParallelFromPublisher\r\n\r\n* Again, undo"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/processors/MulticastProcessor.java b/src/main/java/io/reactivex/rxjava3/processors/MulticastProcessor.java\n--- a/src/main/java/io/reactivex/rxjava3/processors/MulticastProcessor.java\n+++ b/src/main/java/io/reactivex/rxjava3/processors/MulticastProcessor.java\n@@ -570,6 +570,7 @@ void drain() {\n                 }\n             }\n \n+            consumed = c;\n             missed = wip.addAndGet(-missed);\n             if (missed == 0) {\n                 break;\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/processors/MulticastProcessorTest.java b/src/test/java/io/reactivex/rxjava3/processors/MulticastProcessorTest.java\n--- a/src/test/java/io/reactivex/rxjava3/processors/MulticastProcessorTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/processors/MulticastProcessorTest.java\n@@ -784,4 +784,41 @@ public void noUpstream() {\n         assertTrue(mp.hasSubscribers());\n     }\n \n+    @Test\n+    public void requestUpstreamPrefetchNonFused() {\n+        for (int j = 1; j < 12; j++) {\n+            MulticastProcessor<Integer> mp = MulticastProcessor.create(j, true);\n+\n+            TestSubscriber<Integer> ts = mp.test(0).withTag(\"Prefetch: \" + j);\n+\n+            Flowable.range(1, 10).hide().subscribe(mp);\n+\n+            ts.assertEmpty()\n+            .requestMore(3)\n+            .assertValuesOnly(1, 2, 3)\n+            .requestMore(3)\n+            .assertValuesOnly(1, 2, 3, 4, 5, 6)\n+            .requestMore(4)\n+            .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+        }\n+    }\n+\n+    @Test\n+    public void requestUpstreamPrefetchNonFused2() {\n+        for (int j = 1; j < 12; j++) {\n+            MulticastProcessor<Integer> mp = MulticastProcessor.create(j, true);\n+\n+            TestSubscriber<Integer> ts = mp.test(0).withTag(\"Prefetch: \" + j);\n+\n+            Flowable.range(1, 10).hide().subscribe(mp);\n+\n+            ts.assertEmpty()\n+            .requestMore(2)\n+            .assertValuesOnly(1, 2)\n+            .requestMore(2)\n+            .assertValuesOnly(1, 2, 3, 4)\n+            .requestMore(6)\n+            .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+        }\n+    }\n }",
    "output": "Fix MulticastProcessor not requesting more after limit is reached\n\n* Fix MulticastProcessor not requesting more after limit is reached\r\n\r\n* Test for more prefetch values and patterns"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.java\n@@ -154,7 +154,7 @@ public final void cancel() {\n             upstream.cancel();\n             worker.dispose();\n \n-            if (getAndIncrement() == 0) {\n+            if (!outputFused && getAndIncrement() == 0) {\n                 queue.clear();\n             }\n         }\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableObserveOn.java b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableObserveOn.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableObserveOn.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableObserveOn.java\n@@ -145,7 +145,7 @@ public void dispose() {\n                 disposed = true;\n                 upstream.dispose();\n                 worker.dispose();\n-                if (getAndIncrement() == 0) {\n+                if (!outputFused && getAndIncrement() == 0) {\n                     queue.clear();\n                 }\n             }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOnTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOnTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOnTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOnTest.java\n@@ -35,6 +35,7 @@\n import io.reactivex.rxjava3.internal.operators.flowable.FlowableObserveOn.BaseObserveOnSubscriber;\n import io.reactivex.rxjava3.internal.schedulers.ImmediateThinScheduler;\n import io.reactivex.rxjava3.internal.subscriptions.BooleanSubscription;\n+import io.reactivex.rxjava3.observers.TestObserver;\n import io.reactivex.rxjava3.plugins.RxJavaPlugins;\n import io.reactivex.rxjava3.processors.*;\n import io.reactivex.rxjava3.schedulers.*;\n@@ -1938,4 +1939,37 @@ public void workerNotDisposedPrematurelyNormalInAsyncOutConditional() {\n \n         assertEquals(1, s.disposedCount.get());\n     }\n+\n+    @Test\n+    public void fusedNoConcurrentCleanDueToCancel() {\n+        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {\n+            List<Throwable> errors = TestHelper.trackPluginErrors();\n+            try {\n+                final UnicastProcessor<Integer> up = UnicastProcessor.create();\n+\n+                TestObserver<Integer> to = up.hide()\n+                .observeOn(Schedulers.io())\n+                .observeOn(Schedulers.single())\n+                .unsubscribeOn(Schedulers.computation())\n+                .firstOrError()\n+                .test();\n+\n+                for (int i = 0; up.hasSubscribers() && i < 10000; i++) {\n+                    up.onNext(i);\n+                }\n+\n+                to\n+                .awaitDone(5, TimeUnit.SECONDS)\n+                ;\n+\n+                if (!errors.isEmpty()) {\n+                    throw new CompositeException(errors);\n+                }\n+\n+                to.assertResult(0);\n+            } finally {\n+                RxJavaPlugins.reset();\n+            }\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableObserveOnTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableObserveOnTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableObserveOnTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableObserveOnTest.java\n@@ -29,7 +29,7 @@\n import io.reactivex.rxjava3.core.Observable;\n import io.reactivex.rxjava3.core.Observer;\n import io.reactivex.rxjava3.disposables.*;\n-import io.reactivex.rxjava3.exceptions.TestException;\n+import io.reactivex.rxjava3.exceptions.*;\n import io.reactivex.rxjava3.functions.*;\n import io.reactivex.rxjava3.internal.fuseable.*;\n import io.reactivex.rxjava3.internal.operators.flowable.FlowableObserveOnTest.DisposeTrackingScheduler;\n@@ -815,4 +815,36 @@ public void workerNotDisposedPrematurelyNormalInAsyncOut() {\n         assertEquals(1, s.disposedCount.get());\n     }\n \n+    @Test\n+    public void fusedNoConcurrentCleanDueToCancel() {\n+        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {\n+            List<Throwable> errors = TestHelper.trackPluginErrors();\n+            try {\n+                final UnicastSubject<Integer> us = UnicastSubject.create();\n+\n+                TestObserver<Integer> to = us.hide()\n+                .observeOn(Schedulers.io())\n+                .observeOn(Schedulers.single())\n+                .unsubscribeOn(Schedulers.computation())\n+                .firstOrError()\n+                .test();\n+\n+                for (int i = 0; us.hasObservers() && i < 10000; i++) {\n+                    us.onNext(i);\n+                }\n+\n+                to\n+                .awaitDone(5, TimeUnit.SECONDS)\n+                ;\n+\n+                if (!errors.isEmpty()) {\n+                    throw new CompositeException(errors);\n+                }\n+\n+                to.assertResult(0);\n+            } finally {\n+                RxJavaPlugins.reset();\n+            }\n+        }\n+    }\n }",
    "output": "Fix concurrent clear in observeOn while output-fused"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n@@ -2341,20 +2341,21 @@ public void fusedNoConcurrentCleanDueToCancel() {\n             try {\n                 final PublishProcessor<Integer> pp = PublishProcessor.create();\n \n-                final AtomicReference<QueueSubscription<GroupedFlowable<Object, Integer>>> qs = new AtomicReference<QueueSubscription<GroupedFlowable<Object, Integer>>>();\n+                final AtomicReference<QueueSubscription<GroupedFlowable<Integer, Integer>>> qs =\n+                        new AtomicReference<QueueSubscription<GroupedFlowable<Integer, Integer>>>();\n \n                 final TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>();\n \n-                pp.groupBy(Functions.identity(), Functions.<Integer>identity(), false, 4)\n-                .subscribe(new FlowableSubscriber<GroupedFlowable<Object, Integer>>() {\n+                pp.groupBy(Functions.<Integer>identity(), Functions.<Integer>identity(), false, 4)\n+                .subscribe(new FlowableSubscriber<GroupedFlowable<Integer, Integer>>() {\n \n                     boolean once;\n \n                     @Override\n-                    public void onNext(GroupedFlowable<Object, Integer> g) {\n+                    public void onNext(GroupedFlowable<Integer, Integer> g) {\n                         if (!once) {\n                             try {\n-                                GroupedFlowable<Object, Integer> t = qs.get().poll();\n+                                GroupedFlowable<Integer, Integer> t = qs.get().poll();\n                                 if (t != null) {\n                                     once = true;\n                                     t.subscribe(ts2);\n@@ -2376,7 +2377,7 @@ public void onComplete() {\n                     @Override\n                     public void onSubscribe(Subscription s) {\n                         @SuppressWarnings(\"unchecked\")\n-                        QueueSubscription<GroupedFlowable<Object, Integer>> q = (QueueSubscription<GroupedFlowable<Object, Integer>>)s;\n+                        QueueSubscription<GroupedFlowable<Integer, Integer>> q = (QueueSubscription<GroupedFlowable<Integer, Integer>>)s;\n                         qs.set(q);\n                         q.requestFusion(QueueFuseable.ANY);\n                         q.request(1);",
    "output": "Fix type inference problem when compiling with newer JDKs"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java\n@@ -168,6 +168,10 @@ public void onNext(T t) {\n             } catch (Throwable ex) {\n                 Exceptions.throwIfFatal(ex);\n                 upstream.cancel();\n+                if (newGroup) {\n+                    q.offer(group);\n+                    drain();\n+                }\n                 onError(ex);\n                 return;\n             }\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupBy.java b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupBy.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupBy.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupBy.java\n@@ -97,6 +97,7 @@ public void onNext(T t) {\n \n             Object mapKey = key != null ? key : NULL_KEY;\n             GroupedUnicast<K, V> group = groups.get(mapKey);\n+            boolean newGroup = false;\n             if (group == null) {\n                 // if the main has been cancelled, stop creating groups\n                 // and skip this value\n@@ -109,12 +110,7 @@ public void onNext(T t) {\n \n                 getAndIncrement();\n \n-                downstream.onNext(group);\n-\n-                if (group.state.tryAbandon()) {\n-                    cancel(key);\n-                    group.onComplete();\n-                }\n+                newGroup = true;\n             }\n \n             V v;\n@@ -123,11 +119,23 @@ public void onNext(T t) {\n             } catch (Throwable e) {\n                 Exceptions.throwIfFatal(e);\n                 upstream.dispose();\n+                if (newGroup) {\n+                    downstream.onNext(group);\n+                }\n                 onError(e);\n                 return;\n             }\n \n             group.onNext(v);\n+\n+            if (newGroup) {\n+                downstream.onNext(group);\n+\n+                if (group.state.tryAbandon()) {\n+                    cancel(key);\n+                    group.onComplete();\n+                }\n+            }\n         }\n \n         @Override\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java\n@@ -2275,4 +2275,61 @@ public void accept(GroupedFlowable<Integer, Integer> v) throws Throwable {\n         .assertNoErrors()\n         .assertComplete();\n     }\n+\n+    @Test\n+    public void newGroupValueSelectorFails() {\n+        TestSubscriber<Object> ts1 = new TestSubscriber<Object>();\n+        final TestSubscriber<Object> ts2 = new TestSubscriber<Object>();\n+\n+        Flowable.just(1)\n+        .groupBy(Functions.<Integer>identity(), new Function<Integer, Object>() {\n+            @Override\n+            public Object apply(Integer v) throws Throwable {\n+                throw new TestException();\n+            }\n+        })\n+        .doOnNext(new Consumer<GroupedFlowable<Integer, Object>>() {\n+            @Override\n+            public void accept(GroupedFlowable<Integer, Object> g) throws Throwable {\n+                g.subscribe(ts2);\n+            }\n+        })\n+        .subscribe(ts1);\n+\n+        ts1.assertValueCount(1)\n+        .assertError(TestException.class)\n+        .assertNotComplete();\n+\n+        ts2.assertFailure(TestException.class);\n+    }\n+\n+    @Test\n+    public void existingGroupValueSelectorFails() {\n+        TestSubscriber<Object> ts1 = new TestSubscriber<Object>();\n+        final TestSubscriber<Object> ts2 = new TestSubscriber<Object>();\n+\n+        Flowable.just(1, 2)\n+        .groupBy(Functions.justFunction(1), new Function<Integer, Object>() {\n+            @Override\n+            public Object apply(Integer v) throws Throwable {\n+                if (v == 2) {\n+                    throw new TestException();\n+                }\n+                return v;\n+            }\n+        })\n+        .doOnNext(new Consumer<GroupedFlowable<Integer, Object>>() {\n+            @Override\n+            public void accept(GroupedFlowable<Integer, Object> g) throws Throwable {\n+                g.subscribe(ts2);\n+            }\n+        })\n+        .subscribe(ts1);\n+\n+        ts1.assertValueCount(1)\n+        .assertError(TestException.class)\n+        .assertNotComplete();\n+\n+        ts2.assertFailure(TestException.class, 1);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupByTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupByTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupByTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupByTest.java\n@@ -1615,4 +1615,61 @@ public void accept(GroupedObservable<Integer, Integer> v) throws Throwable {\n         .assertNoErrors()\n         .assertComplete();\n     }\n+\n+    @Test\n+    public void newGroupValueSelectorFails() {\n+        TestObserver<Object> to1 = new TestObserver<Object>();\n+        final TestObserver<Object> to2 = new TestObserver<Object>();\n+\n+        Observable.just(1)\n+        .groupBy(Functions.<Integer>identity(), new Function<Integer, Object>() {\n+            @Override\n+            public Object apply(Integer v) throws Throwable {\n+                throw new TestException();\n+            }\n+        })\n+        .doOnNext(new Consumer<GroupedObservable<Integer, Object>>() {\n+            @Override\n+            public void accept(GroupedObservable<Integer, Object> g) throws Throwable {\n+                g.subscribe(to2);\n+            }\n+        })\n+        .subscribe(to1);\n+\n+        to1.assertValueCount(1)\n+        .assertError(TestException.class)\n+        .assertNotComplete();\n+\n+        to2.assertFailure(TestException.class);\n+    }\n+\n+    @Test\n+    public void existingGroupValueSelectorFails() {\n+        TestObserver<Object> to1 = new TestObserver<Object>();\n+        final TestObserver<Object> to2 = new TestObserver<Object>();\n+\n+        Observable.just(1, 2)\n+        .groupBy(Functions.justFunction(1), new Function<Integer, Object>() {\n+            @Override\n+            public Object apply(Integer v) throws Throwable {\n+                if (v == 2) {\n+                    throw new TestException();\n+                }\n+                return v;\n+            }\n+        })\n+        .doOnNext(new Consumer<GroupedObservable<Integer, Object>>() {\n+            @Override\n+            public void accept(GroupedObservable<Integer, Object> g) throws Throwable {\n+                g.subscribe(to2);\n+            }\n+        })\n+        .subscribe(to1);\n+\n+        to1.assertValueCount(1)\n+        .assertError(TestException.class)\n+        .assertNotComplete();\n+\n+        to2.assertFailure(TestException.class, 1);\n+    }\n }",
    "output": "Fix groupBy group emission in some cases\n\n* Fix Observable.groupBy group emission in some cases\r\n\r\n* Test non-fresh group with value selector failure"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowTimed.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowTimed.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowTimed.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowTimed.java\n@@ -498,7 +498,7 @@ void drainLoop() {\n \n                     if (isHolder) {\n                         ConsumerIndexHolder consumerIndexHolder = (ConsumerIndexHolder) o;\n-                        if (restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {\n+                        if (!restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {\n                             w.onComplete();\n                             count = 0;\n                             w = UnicastProcessor.<T>create(bufferSize);\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowTimed.java b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowTimed.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowTimed.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowTimed.java\n@@ -444,7 +444,7 @@ void drainLoop() {\n \n                     if (isHolder) {\n                         ConsumerIndexHolder consumerIndexHolder = (ConsumerIndexHolder) o;\n-                        if (restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {\n+                        if (!restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {\n                             w.onComplete();\n                             count = 0;\n                             w = UnicastSubject.create(bufferSize);\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/flowable/FlowableWindowTests.java b/src/test/java/io/reactivex/rxjava3/flowable/FlowableWindowTests.java\n--- a/src/test/java/io/reactivex/rxjava3/flowable/FlowableWindowTests.java\n+++ b/src/test/java/io/reactivex/rxjava3/flowable/FlowableWindowTests.java\n@@ -16,11 +16,15 @@\n import static org.junit.Assert.*;\n \n import java.util.*;\n+import java.util.concurrent.TimeUnit;\n \n import org.junit.Test;\n \n import io.reactivex.rxjava3.core.*;\n import io.reactivex.rxjava3.functions.*;\n+import io.reactivex.rxjava3.processors.PublishProcessor;\n+import io.reactivex.rxjava3.schedulers.TestScheduler;\n+import io.reactivex.rxjava3.subscribers.TestSubscriber;\n \n public class FlowableWindowTests extends RxJavaTest {\n \n@@ -50,4 +54,43 @@ public void accept(List<Integer> xs) {\n         assertEquals(2, lists.size());\n \n     }\n+\n+    @Test\n+    public void timeSizeWindowAlternatingBounds() {\n+        TestScheduler scheduler = new TestScheduler();\n+        PublishProcessor<Integer> pp = PublishProcessor.create();\n+\n+        TestSubscriber<List<Integer>> ts = pp.window(5, TimeUnit.SECONDS, scheduler, 2)\n+        .flatMapSingle(new Function<Flowable<Integer>, SingleSource<List<Integer>>>() {\n+            @Override\n+            public SingleSource<List<Integer>> apply(Flowable<Integer> v) throws Throwable {\n+                return v.toList();\n+            }\n+        })\n+        .test();\n+\n+        pp.onNext(1);\n+        pp.onNext(2);\n+        ts.assertValueCount(1); // size bound hit\n+\n+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);\n+        pp.onNext(3);\n+        scheduler.advanceTimeBy(6, TimeUnit.SECONDS);\n+        ts.assertValueCount(2); // time bound hit\n+\n+        pp.onNext(4);\n+        pp.onNext(5);\n+\n+        ts.assertValueCount(3); // size bound hit again\n+\n+        pp.onNext(4);\n+\n+        scheduler.advanceTimeBy(6, TimeUnit.SECONDS);\n+\n+        ts.assertValueCount(4)\n+        .assertNoErrors()\n+        .assertNotComplete();\n+\n+        ts.cancel();\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowWithTimeTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowWithTimeTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowWithTimeTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowWithTimeTest.java\n@@ -65,17 +65,19 @@ public void subscribe(Subscriber<? super String> subscriber) {\n         Flowable<Flowable<String>> windowed = source.window(100, TimeUnit.MILLISECONDS, scheduler, 2);\n         windowed.subscribe(observeWindow(list, lists));\n \n-        scheduler.advanceTimeTo(100, TimeUnit.MILLISECONDS);\n+        scheduler.advanceTimeTo(95, TimeUnit.MILLISECONDS);\n         assertEquals(1, lists.size());\n         assertEquals(lists.get(0), list(\"one\", \"two\"));\n \n-        scheduler.advanceTimeTo(200, TimeUnit.MILLISECONDS);\n-        assertEquals(2, lists.size());\n-        assertEquals(lists.get(1), list(\"three\", \"four\"));\n+        scheduler.advanceTimeTo(195, TimeUnit.MILLISECONDS);\n+        assertEquals(3, lists.size());\n+        assertTrue(lists.get(1).isEmpty());\n+        assertEquals(lists.get(2), list(\"three\", \"four\"));\n \n         scheduler.advanceTimeTo(300, TimeUnit.MILLISECONDS);\n-        assertEquals(3, lists.size());\n-        assertEquals(lists.get(2), list(\"five\"));\n+        assertEquals(5, lists.size());\n+        assertTrue(lists.get(3).isEmpty());\n+        assertEquals(lists.get(4), list(\"five\"));\n     }\n \n     @Test\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowWithTimeTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowWithTimeTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowWithTimeTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowWithTimeTest.java\n@@ -65,17 +65,19 @@ public void subscribe(Observer<? super String> observer) {\n         Observable<Observable<String>> windowed = source.window(100, TimeUnit.MILLISECONDS, scheduler, 2);\n         windowed.subscribe(observeWindow(list, lists));\n \n-        scheduler.advanceTimeTo(100, TimeUnit.MILLISECONDS);\n+        scheduler.advanceTimeTo(95, TimeUnit.MILLISECONDS);\n         assertEquals(1, lists.size());\n         assertEquals(lists.get(0), list(\"one\", \"two\"));\n \n-        scheduler.advanceTimeTo(200, TimeUnit.MILLISECONDS);\n-        assertEquals(2, lists.size());\n-        assertEquals(lists.get(1), list(\"three\", \"four\"));\n+        scheduler.advanceTimeTo(195, TimeUnit.MILLISECONDS);\n+        assertEquals(3, lists.size());\n+        assertTrue(lists.get(1).isEmpty());\n+        assertEquals(lists.get(2), list(\"three\", \"four\"));\n \n         scheduler.advanceTimeTo(300, TimeUnit.MILLISECONDS);\n-        assertEquals(3, lists.size());\n-        assertEquals(lists.get(2), list(\"five\"));\n+        assertEquals(5, lists.size());\n+        assertTrue(lists.get(3).isEmpty());\n+        assertEquals(lists.get(4), list(\"five\"));\n     }\n \n     @Test\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/observable/ObservableWindowTests.java b/src/test/java/io/reactivex/rxjava3/observable/ObservableWindowTests.java\n--- a/src/test/java/io/reactivex/rxjava3/observable/ObservableWindowTests.java\n+++ b/src/test/java/io/reactivex/rxjava3/observable/ObservableWindowTests.java\n@@ -16,12 +16,16 @@\n import static org.junit.Assert.*;\n \n import java.util.*;\n+import java.util.concurrent.TimeUnit;\n \n import org.junit.Test;\n \n+import io.reactivex.rxjava3.core.*;\n import io.reactivex.rxjava3.core.Observable;\n-import io.reactivex.rxjava3.core.RxJavaTest;\n import io.reactivex.rxjava3.functions.*;\n+import io.reactivex.rxjava3.observers.TestObserver;\n+import io.reactivex.rxjava3.schedulers.*;\n+import io.reactivex.rxjava3.subjects.PublishSubject;\n \n public class ObservableWindowTests extends RxJavaTest {\n \n@@ -51,4 +55,43 @@ public void accept(List<Integer> xs) {\n         assertEquals(2, lists.size());\n \n     }\n+\n+    @Test\n+    public void timeSizeWindowAlternatingBounds() {\n+        TestScheduler scheduler = new TestScheduler();\n+        PublishSubject<Integer> ps = PublishSubject.create();\n+\n+        TestObserver<List<Integer>> to = ps.window(5, TimeUnit.SECONDS, scheduler, 2)\n+        .flatMapSingle(new Function<Observable<Integer>, SingleSource<List<Integer>>>() {\n+            @Override\n+            public SingleSource<List<Integer>> apply(Observable<Integer> v) throws Throwable {\n+                return v.toList();\n+            }\n+        })\n+        .test();\n+\n+        ps.onNext(1);\n+        ps.onNext(2);\n+        to.assertValueCount(1); // size bound hit\n+\n+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);\n+        ps.onNext(3);\n+        scheduler.advanceTimeBy(6, TimeUnit.SECONDS);\n+        to.assertValueCount(2); // time bound hit\n+\n+        ps.onNext(4);\n+        ps.onNext(5);\n+\n+        to.assertValueCount(3); // size bound hit again\n+\n+        ps.onNext(4);\n+\n+        scheduler.advanceTimeBy(6, TimeUnit.SECONDS);\n+\n+        to.assertValueCount(4)\n+        .assertNoErrors()\n+        .assertNotComplete();\n+\n+        to.dispose();\n+    }\n }",
    "output": "Fix size+time bound window not creating windows properly"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTimed.java b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTimed.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTimed.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTimed.java\n@@ -139,6 +139,7 @@ void drain() {\n             final Observer<? super T> a = downstream;\n             final SpscLinkedArrayQueue<Object> q = queue;\n             final boolean delayError = this.delayError;\n+            final long timestampLimit = scheduler.now(unit) - time;\n \n             for (;;) {\n                 if (cancelled) {\n@@ -171,7 +172,7 @@ void drain() {\n                 @SuppressWarnings(\"unchecked\")\n                 T o = (T)q.poll();\n \n-                if ((Long)ts < scheduler.now(unit) - time) {\n+                if ((Long)ts < timestampLimit) {\n                     continue;\n                 }\n \n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLastTimedTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLastTimedTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLastTimedTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLastTimedTest.java\n@@ -28,7 +28,7 @@\n import io.reactivex.rxjava3.processors.PublishProcessor;\n import io.reactivex.rxjava3.schedulers.*;\n import io.reactivex.rxjava3.subscribers.TestSubscriber;\n-import io.reactivex.rxjava3.testsupport.TestHelper;\n+import io.reactivex.rxjava3.testsupport.*;\n \n public class FlowableTakeLastTimedTest extends RxJavaTest {\n \n@@ -338,4 +338,27 @@ public Publisher<Object> apply(Flowable<Object> f) throws Exception {\n     public void badRequest() {\n         TestHelper.assertBadRequestReported(PublishProcessor.create().takeLast(1, TimeUnit.SECONDS));\n     }\n+\n+    @Test\n+    public void lastWindowIsFixedInTime() {\n+        TimesteppingScheduler scheduler = new TimesteppingScheduler();\n+        scheduler.stepEnabled = false;\n+\n+        PublishProcessor<Integer> pp = PublishProcessor.create();\n+\n+        TestSubscriber<Integer> ts = pp\n+        .takeLast(2, TimeUnit.SECONDS, scheduler)\n+        .test();\n+\n+        pp.onNext(1);\n+        pp.onNext(2);\n+        pp.onNext(3);\n+        pp.onNext(4);\n+\n+        scheduler.stepEnabled = true;\n+\n+        pp.onComplete();\n+\n+        ts.assertResult(1, 2, 3, 4);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTimedTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTimedTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTimedTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTimedTest.java\n@@ -26,7 +26,7 @@\n import io.reactivex.rxjava3.observers.TestObserver;\n import io.reactivex.rxjava3.schedulers.*;\n import io.reactivex.rxjava3.subjects.PublishSubject;\n-import io.reactivex.rxjava3.testsupport.TestHelper;\n+import io.reactivex.rxjava3.testsupport.*;\n \n public class ObservableTakeLastTimedTest extends RxJavaTest {\n \n@@ -277,4 +277,27 @@ public void run() {\n             TestHelper.race(r1, r2);\n         }\n     }\n+\n+    @Test\n+    public void lastWindowIsFixedInTime() {\n+        TimesteppingScheduler scheduler = new TimesteppingScheduler();\n+        scheduler.stepEnabled = false;\n+\n+        PublishSubject<Integer> ps = PublishSubject.create();\n+\n+        TestObserver<Integer> to = ps\n+        .takeLast(2, TimeUnit.SECONDS, scheduler)\n+        .test();\n+\n+        ps.onNext(1);\n+        ps.onNext(2);\n+        ps.onNext(3);\n+        ps.onNext(4);\n+\n+        scheduler.stepEnabled = true;\n+\n+        ps.onComplete();\n+\n+        to.assertResult(1, 2, 3, 4);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/testsupport/TimesteppingScheduler.java b/src/test/java/io/reactivex/rxjava3/testsupport/TimesteppingScheduler.java\n--- a/src/test/java/io/reactivex/rxjava3/testsupport/TimesteppingScheduler.java\n+++ b/src/test/java/io/reactivex/rxjava3/testsupport/TimesteppingScheduler.java\n@@ -22,7 +22,7 @@\n  * Basic scheduler that produces an ever increasing {@link #now(TimeUnit)} value.\n  * Use this scheduler only as a time source!\n  */\n-public class TimesteppingScheduler extends Scheduler {\n+public final class TimesteppingScheduler extends Scheduler {\n \n     final class TimesteppingWorker extends Worker {\n         @Override\n@@ -42,11 +42,13 @@ public Disposable schedule(Runnable run, long delay, TimeUnit unit) {\n \n         @Override\n         public long now(TimeUnit unit) {\n-            return time++;\n+            return TimesteppingScheduler.this.now(unit);\n         }\n     }\n \n-    long time;\n+    public long time;\n+\n+    public boolean stepEnabled = true;\n \n     @Override\n     public Worker createWorker() {\n@@ -55,6 +57,9 @@ public Worker createWorker() {\n \n     @Override\n     public long now(TimeUnit unit) {\n-        return time++;\n+        if (stepEnabled) {\n+            return time++;\n+        }\n+        return time;\n     }\n }",
    "output": "Fix takeLast(time) last events time window calculation"
  },
  {
    "input": "diff --git a/src/jmh/java/io/reactivex/rxjava3/core/InputWithIncrementingInteger.java b/src/jmh/java/io/reactivex/rxjava3/core/InputWithIncrementingInteger.java\n--- a/src/jmh/java/io/reactivex/rxjava3/core/InputWithIncrementingInteger.java\n+++ b/src/jmh/java/io/reactivex/rxjava3/core/InputWithIncrementingInteger.java\n@@ -44,7 +44,8 @@ public void onNext(Integer t) {\n     }\n \n     final class IncrementingIterable implements Iterable<Integer> {\n-        private final class IncrementingIterator implements Iterator<Integer> {\n+\n+        final class IncrementingIterator implements Iterator<Integer> {\n             int i;\n \n             @Override\n@@ -64,9 +65,9 @@ public void remove() {\n             }\n         }\n \n-        private final int size;\n+        final int size;\n \n-        private IncrementingIterable(int size) {\n+        IncrementingIterable(int size) {\n             this.size = size;\n         }\n \n@@ -77,7 +78,8 @@ public Iterator<Integer> iterator() {\n     }\n \n     final class IncrementingPublisher implements Publisher<Integer> {\n-        private final int size;\n+\n+        final int size;\n \n         IncrementingPublisher(int size) {\n             this.size = size;\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/disposables/SequentialDisposableTest.java b/src/test/java/io/reactivex/rxjava3/disposables/SequentialDisposableTest.java\n--- a/src/test/java/io/reactivex/rxjava3/disposables/SequentialDisposableTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/disposables/SequentialDisposableTest.java\n@@ -21,7 +21,7 @@\n \n import org.junit.*;\n import org.junit.runner.RunWith;\n-import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.junit.MockitoJUnitRunner;\n \n import io.reactivex.rxjava3.core.RxJavaTest;\n import io.reactivex.rxjava3.internal.disposables.SequentialDisposable;\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/disposables/SerialDisposableTests.java b/src/test/java/io/reactivex/rxjava3/disposables/SerialDisposableTests.java\n--- a/src/test/java/io/reactivex/rxjava3/disposables/SerialDisposableTests.java\n+++ b/src/test/java/io/reactivex/rxjava3/disposables/SerialDisposableTests.java\n@@ -21,7 +21,7 @@\n \n import org.junit.*;\n import org.junit.runner.RunWith;\n-import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.junit.MockitoJUnitRunner;\n \n import io.reactivex.rxjava3.core.RxJavaTest;\n import io.reactivex.rxjava3.internal.disposables.DisposableHelper;",
    "output": "Upgrade Gradle & dependency versions\n\n* Upgrade Gradle & dependency versions\r\n\r\n* Add checkstyle version string to the top, fix JMH class"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java\n@@ -21,7 +21,7 @@\n \n import io.reactivex.rxjava3.core.*;\n import io.reactivex.rxjava3.disposables.Disposable;\n-import io.reactivex.rxjava3.exceptions.MissingBackpressureException;\n+import io.reactivex.rxjava3.exceptions.*;\n import io.reactivex.rxjava3.internal.queue.SpscArrayQueue;\n import io.reactivex.rxjava3.internal.subscriptions.SubscriptionHelper;\n import io.reactivex.rxjava3.internal.util.*;\n@@ -62,7 +62,7 @@ static final class BlockingFlowableIterator<T>\n         long produced;\n \n         volatile boolean done;\n-        Throwable error;\n+        volatile Throwable error;\n \n         BlockingFlowableIterator(int batchSize) {\n             this.queue = new SpscArrayQueue<T>(batchSize);\n@@ -75,6 +75,13 @@ static final class BlockingFlowableIterator<T>\n         @Override\n         public boolean hasNext() {\n             for (;;) {\n+                if (isDisposed()) {\n+                    Throwable e = error;\n+                    if (e != null) {\n+                        throw ExceptionHelper.wrapOrThrow(e);\n+                    }\n+                    return false;\n+                }\n                 boolean d = done;\n                 boolean empty = queue.isEmpty();\n                 if (d) {\n@@ -90,7 +97,7 @@ public boolean hasNext() {\n                     BlockingHelper.verifyNonBlocking();\n                     lock.lock();\n                     try {\n-                        while (!done && queue.isEmpty()) {\n+                        while (!done && queue.isEmpty() && !isDisposed()) {\n                             condition.await();\n                         }\n                     } catch (InterruptedException ex) {\n@@ -175,6 +182,7 @@ public void remove() {\n         @Override\n         public void dispose() {\n             SubscriptionHelper.cancel(this);\n+            signalConsumer(); // Just in case it is currently blocking in hasNext.\n         }\n \n         @Override\n\ndiff --git a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableIterable.java b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableIterable.java\n--- a/src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableIterable.java\n+++ b/src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableIterable.java\n@@ -53,7 +53,7 @@ static final class BlockingObservableIterator<T>\n         final Condition condition;\n \n         volatile boolean done;\n-        Throwable error;\n+        volatile Throwable error;\n \n         BlockingObservableIterator(int batchSize) {\n             this.queue = new SpscLinkedArrayQueue<T>(batchSize);\n@@ -64,6 +64,13 @@ static final class BlockingObservableIterator<T>\n         @Override\n         public boolean hasNext() {\n             for (;;) {\n+                if (isDisposed()) {\n+                    Throwable e = error;\n+                    if (e != null) {\n+                        throw ExceptionHelper.wrapOrThrow(e);\n+                    }\n+                    return false;\n+                }\n                 boolean d = done;\n                 boolean empty = queue.isEmpty();\n                 if (d) {\n@@ -80,7 +87,7 @@ public boolean hasNext() {\n                         BlockingHelper.verifyNonBlocking();\n                         lock.lock();\n                         try {\n-                            while (!done && queue.isEmpty()) {\n+                            while (!done && queue.isEmpty() && !isDisposed()) {\n                                 condition.await();\n                             }\n                         } finally {\n@@ -146,6 +153,7 @@ public void remove() {\n         @Override\n         public void dispose() {\n             DisposableHelper.dispose(this);\n+            signalConsumer(); // Just in case it is currently blocking in hasNext.\n         }\n \n         @Override\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableToIteratorTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableToIteratorTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableToIteratorTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableToIteratorTest.java\n@@ -16,14 +16,18 @@\n import static org.junit.Assert.*;\n \n import java.util.*;\n+import java.util.concurrent.TimeUnit;\n \n import org.junit.Test;\n import org.reactivestreams.*;\n \n import io.reactivex.rxjava3.core.*;\n+import io.reactivex.rxjava3.disposables.Disposable;\n import io.reactivex.rxjava3.exceptions.*;\n import io.reactivex.rxjava3.internal.operators.flowable.BlockingFlowableIterable.BlockingFlowableIterator;\n import io.reactivex.rxjava3.internal.subscriptions.BooleanSubscription;\n+import io.reactivex.rxjava3.processors.PublishProcessor;\n+import io.reactivex.rxjava3.schedulers.Schedulers;\n \n public class BlockingFlowableToIteratorTest extends RxJavaTest {\n \n@@ -163,4 +167,28 @@ protected void subscribeActual(Subscriber<? super Integer> s) {\n \n         it.next();\n     }\n+\n+    @Test(expected = NoSuchElementException.class)\n+    public void disposedIteratorHasNextReturns() {\n+        Iterator<Integer> it = PublishProcessor.<Integer>create()\n+                .blockingIterable().iterator();\n+        ((Disposable)it).dispose();\n+        assertFalse(it.hasNext());\n+        it.next();\n+    }\n+\n+    @Test\n+    public void asyncDisposeUnblocks() {\n+        final Iterator<Integer> it = PublishProcessor.<Integer>create()\n+                .blockingIterable().iterator();\n+\n+        Schedulers.single().scheduleDirect(new Runnable() {\n+            @Override\n+            public void run() {\n+                ((Disposable)it).dispose();\n+            }\n+        }, 1, TimeUnit.SECONDS);\n+\n+        assertFalse(it.hasNext());\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableNextTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableNextTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableNextTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableNextTest.java\n@@ -28,7 +28,6 @@\n import io.reactivex.rxjava3.exceptions.TestException;\n import io.reactivex.rxjava3.internal.operators.observable.BlockingObservableNext.NextObserver;\n import io.reactivex.rxjava3.plugins.RxJavaPlugins;\n-import io.reactivex.rxjava3.processors.BehaviorProcessor;\n import io.reactivex.rxjava3.schedulers.Schedulers;\n import io.reactivex.rxjava3.subjects.*;\n import io.reactivex.rxjava3.testsupport.TestHelper;\n@@ -333,9 +332,9 @@ public void singleSourceManyIterators() throws InterruptedException {\n \n     @Test\n     public void synchronousNext() {\n-        assertEquals(1, BehaviorProcessor.createDefault(1).take(1).blockingSingle().intValue());\n-        assertEquals(2, BehaviorProcessor.createDefault(2).blockingIterable().iterator().next().intValue());\n-        assertEquals(3, BehaviorProcessor.createDefault(3).blockingNext().iterator().next().intValue());\n+        assertEquals(1, BehaviorSubject.createDefault(1).take(1).blockingSingle().intValue());\n+        assertEquals(2, BehaviorSubject.createDefault(2).blockingIterable().iterator().next().intValue());\n+        assertEquals(3, BehaviorSubject.createDefault(3).blockingNext().iterator().next().intValue());\n     }\n \n     @Test\n\ndiff --git a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableToIteratorTest.java b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableToIteratorTest.java\n--- a/src/test/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableToIteratorTest.java\n+++ b/src/test/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableToIteratorTest.java\n@@ -16,15 +16,18 @@\n import static org.junit.Assert.*;\n \n import java.util.*;\n+import java.util.concurrent.TimeUnit;\n \n import org.junit.Test;\n \n import io.reactivex.rxjava3.core.*;\n import io.reactivex.rxjava3.core.Observable;\n import io.reactivex.rxjava3.core.Observer;\n-import io.reactivex.rxjava3.disposables.Disposables;\n+import io.reactivex.rxjava3.disposables.*;\n import io.reactivex.rxjava3.exceptions.TestException;\n import io.reactivex.rxjava3.internal.operators.observable.BlockingObservableIterable.BlockingObservableIterator;\n+import io.reactivex.rxjava3.schedulers.Schedulers;\n+import io.reactivex.rxjava3.subjects.PublishSubject;\n \n public class BlockingObservableToIteratorTest extends RxJavaTest {\n \n@@ -104,4 +107,28 @@ public void remove() {\n         BlockingObservableIterator<Integer> it = new BlockingObservableIterator<Integer>(128);\n         it.remove();\n     }\n+\n+    @Test(expected = NoSuchElementException.class)\n+    public void disposedIteratorHasNextReturns() {\n+        Iterator<Integer> it = PublishSubject.<Integer>create()\n+                .blockingIterable().iterator();\n+        ((Disposable)it).dispose();\n+        assertFalse(it.hasNext());\n+        it.next();\n+    }\n+\n+    @Test\n+    public void asyncDisposeUnblocks() {\n+        final Iterator<Integer> it = PublishSubject.<Integer>create()\n+                .blockingIterable().iterator();\n+\n+        Schedulers.single().scheduleDirect(new Runnable() {\n+            @Override\n+            public void run() {\n+                ((Disposable)it).dispose();\n+            }\n+        }, 1, TimeUnit.SECONDS);\n+\n+        assertFalse(it.hasNext());\n+    }\n }",
    "output": "Fix blockingIterable not unblocking when force-disposed\n\n* Fix blockingIterable not unblocking when force-disposed\r\n\r\n* Update src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java\r\n\r\nCo-Authored-By: Niklas Baudy <niklas.baudy@vanniktech.de>\r\n\r\n* Update src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableIterable.java\r\n\r\nCo-Authored-By: Niklas Baudy <niklas.baudy@vanniktech.de>\r\n\r\n* missed a volatile"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java\n@@ -311,7 +311,7 @@ void drain() {\n                             if (r != Long.MAX_VALUE) {\n                                 requested.addAndGet(-e);\n                             }\n-                            inner.get().request(e);\n+                            inner.request(e);\n                         }\n                     }\n \n@@ -395,6 +395,7 @@ public void onError(Throwable t) {\n             if (index == p.unique && p.errors.addThrowable(t)) {\n                 if (!p.delayErrors) {\n                     p.upstream.cancel();\n+                    p.done = true;\n                 }\n                 done = true;\n                 p.drain();\n@@ -415,5 +416,11 @@ public void onComplete() {\n         public void cancel() {\n             SubscriptionHelper.cancel(this);\n         }\n+\n+        public void request(long n) {\n+            if (fusionMode != QueueSubscription.SYNC) {\n+                get().request(n);\n+            }\n+        }\n     }\n }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java\n@@ -316,6 +316,7 @@ void innerError(SwitchMapInnerObserver<T, R> inner, Throwable ex) {\n             if (inner.index == unique && errors.addThrowable(ex)) {\n                 if (!delayErrors) {\n                     upstream.dispose();\n+                    done = true;\n                 }\n                 inner.done = true;\n                 drain();\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java\n@@ -1201,4 +1201,32 @@ public Publisher<Integer> apply(Integer v) throws Throwable {\n             RxJavaPlugins.reset();\n         }\n     }\n+\n+    @Test\n+    public void switchMapFusedIterable() {\n+        Flowable.range(1, 2)\n+        .switchMap(new Function<Integer, Publisher<Integer>>() {\n+            @Override\n+            public Publisher<Integer> apply(Integer v)\n+                    throws Throwable {\n+                return Flowable.fromIterable(Arrays.asList(v * 10));\n+            }\n+        })\n+        .test()\n+        .assertResult(10, 20);\n+    }\n+\n+    @Test\n+    public void switchMapHiddenIterable() {\n+        Flowable.range(1, 2)\n+        .switchMap(new Function<Integer, Publisher<Integer>>() {\n+            @Override\n+            public Publisher<Integer> apply(Integer v)\n+                    throws Throwable {\n+                return Flowable.fromIterable(Arrays.asList(v * 10)).hide();\n+            }\n+        })\n+        .test()\n+        .assertResult(10, 20);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java\n@@ -17,14 +17,16 @@\n import static org.mockito.ArgumentMatchers.*;\n import static org.mockito.Mockito.*;\n \n-import java.util.List;\n+import java.util.*;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.*;\n \n import org.junit.*;\n import org.mockito.InOrder;\n \n import io.reactivex.*;\n+import io.reactivex.Observable;\n+import io.reactivex.Observer;\n import io.reactivex.disposables.*;\n import io.reactivex.exceptions.*;\n import io.reactivex.functions.*;\n@@ -1226,4 +1228,32 @@ public Observable<Integer> apply(Integer v) throws Throwable {\n             RxJavaPlugins.reset();\n         }\n     }\n+\n+    @Test\n+    public void switchMapFusedIterable() {\n+        Observable.range(1, 2)\n+        .switchMap(new Function<Integer, Observable<Integer>>() {\n+            @Override\n+            public Observable<Integer> apply(Integer v)\n+                    throws Throwable {\n+                return Observable.fromIterable(Arrays.asList(v * 10));\n+            }\n+        })\n+        .test()\n+        .assertResult(10, 20);\n+    }\n+\n+    @Test\n+    public void switchMapHiddenIterable() {\n+        Observable.range(1, 2)\n+        .switchMap(new Function<Integer, Observable<Integer>>() {\n+            @Override\n+            public Observable<Integer> apply(Integer v)\n+                    throws Throwable {\n+                return Observable.fromIterable(Arrays.asList(v * 10)).hide();\n+            }\n+        })\n+        .test()\n+        .assertResult(10, 20);\n+    }\n }",
    "output": "Fix switchMap incorrect sync-fusion & error management"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java\n@@ -115,14 +115,15 @@ void cancel(RefConnection rc) {\n \n     void terminated(RefConnection rc) {\n         synchronized (this) {\n-            if (connection != null && connection == rc) {\n-                connection = null;\n+            if (connection == rc) {\n                 if (rc.timer != null) {\n                     rc.timer.dispose();\n+                    rc.timer = null;\n+                }\n+                if (--rc.subscriberCount == 0) {\n+                    connection = null;\n+                    source.reset();\n                 }\n-            }\n-            if (--rc.subscriberCount == 0) {\n-                source.reset();\n             }\n         }\n     }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java\n@@ -112,14 +112,15 @@ void cancel(RefConnection rc) {\n \n     void terminated(RefConnection rc) {\n         synchronized (this) {\n-            if (connection != null && connection == rc) {\n-                connection = null;\n+            if (connection == rc) {\n                 if (rc.timer != null) {\n                     rc.timer.dispose();\n+                    rc.timer = null;\n+                }\n+                if (--rc.subscriberCount == 0) {\n+                    connection = null;\n+                    source.reset();\n                 }\n-            }\n-            if (--rc.subscriberCount == 0) {\n-                source.reset();\n             }\n         }\n     }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n@@ -14,6 +14,7 @@\n package io.reactivex.internal.operators.flowable;\n \n import static org.junit.Assert.*;\n+import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.*;\n \n import java.io.IOException;\n@@ -1454,4 +1455,22 @@ public void publishRefCountShallBeThreadSafe() {\n             .assertComplete();\n         }\n     }\n-}\n+\n+    @Test\n+    public void upstreamTerminationTriggersAnotherCancel() throws Exception {\n+        ReplayProcessor<Integer> rp = ReplayProcessor.create();\n+        rp.onNext(1);\n+        rp.onComplete();\n+\n+        Flowable<Integer> shared = rp.share();\n+\n+        shared\n+        .buffer(shared.debounce(5, TimeUnit.SECONDS))\n+        .test()\n+        .assertValueCount(2);\n+\n+        shared\n+        .buffer(shared.debounce(5, TimeUnit.SECONDS))\n+        .test()\n+        .assertValueCount(2);\n+    }}\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java\n@@ -14,6 +14,7 @@\n package io.reactivex.internal.operators.observable;\n \n import static org.junit.Assert.*;\n+import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.*;\n \n import java.io.IOException;\n@@ -22,7 +23,7 @@\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.*;\n \n-import org.junit.Test;\n+import org.junit.*;\n import org.mockito.InOrder;\n \n import io.reactivex.*;\n@@ -1267,8 +1268,6 @@ public void cancelTerminateStateExclusion() {\n         .publish()\n         .refCount();\n \n-        o.cancel(null);\n-\n         o.cancel(new RefConnection(o));\n \n         RefConnection rc = new RefConnection(o);\n@@ -1412,4 +1411,23 @@ public void publishRefCountShallBeThreadSafe() {\n             .assertComplete();\n         }\n     }\n+\n+    @Test\n+    public void upstreamTerminationTriggersAnotherCancel() throws Exception {\n+        ReplaySubject<Integer> rs = ReplaySubject.create();\n+        rs.onNext(1);\n+        rs.onComplete();\n+\n+        Observable<Integer> shared = rs.share();\n+\n+        shared\n+        .buffer(shared.debounce(5, TimeUnit.SECONDS))\n+        .test()\n+        .assertValueCount(2);\n+\n+        shared\n+        .buffer(shared.debounce(5, TimeUnit.SECONDS))\n+        .test()\n+        .assertValueCount(2);\n+    }\n }",
    "output": "Fix refCount not resetting when termination triggers cross-cancel"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n@@ -731,13 +731,12 @@ static final class ExceptionData extends Exception {\n         }\n     }\n \n+    static final int GC_SLEEP_TIME = 250;\n+\n     @Test\n     public void publishNoLeak() throws Exception {\n-        Thread.sleep(100);\n         System.gc();\n-        Thread.sleep(100);\n-\n-        long start = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();\n+        Thread.sleep(GC_SLEEP_TIME);\n \n         source = Flowable.fromCallable(new Callable<Object>() {\n             @Override\n@@ -748,11 +747,12 @@ public Object call() throws Exception {\n         .publish()\n         .refCount();\n \n+        long start = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();\n+\n         source.subscribe(Functions.emptyConsumer(), Functions.emptyConsumer());\n \n-        Thread.sleep(100);\n         System.gc();\n-        Thread.sleep(200);\n+        Thread.sleep(GC_SLEEP_TIME);\n \n         long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();\n \n@@ -764,7 +764,7 @@ public Object call() throws Exception {\n     @Test\n     public void publishNoLeak2() throws Exception {\n         System.gc();\n-        Thread.sleep(100);\n+        Thread.sleep(GC_SLEEP_TIME);\n \n         long start = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();\n \n@@ -787,7 +787,7 @@ public Object call() throws Exception {\n         d2 = null;\n \n         System.gc();\n-        Thread.sleep(100);\n+        Thread.sleep(GC_SLEEP_TIME);\n \n         long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java\n@@ -704,12 +704,12 @@ static final class ExceptionData extends Exception {\n         }\n     }\n \n+    static final int GC_SLEEP_TIME = 250;\n+\n     @Test\n     public void publishNoLeak() throws Exception {\n         System.gc();\n-        Thread.sleep(100);\n-\n-        long start = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();\n+        Thread.sleep(GC_SLEEP_TIME);\n \n         source = Observable.fromCallable(new Callable<Object>() {\n             @Override\n@@ -720,12 +720,23 @@ public Object call() throws Exception {\n         .publish()\n         .refCount();\n \n+        long start = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();\n+\n         source.subscribe(Functions.emptyConsumer(), Functions.emptyConsumer());\n \n-        System.gc();\n-        Thread.sleep(100);\n+        long after = 0L;\n \n-        long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();\n+        for (int i = 0; i < 10; i++) {\n+            System.gc();\n+\n+            after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();\n+\n+            if (start + 20 * 1000 * 1000 > after) {\n+                break;\n+            }\n+\n+            Thread.sleep(GC_SLEEP_TIME);\n+        }\n \n         source = null;\n         assertTrue(String.format(\"%,3d -> %,3d%n\", start, after), start + 20 * 1000 * 1000 > after);\n@@ -734,7 +745,7 @@ public Object call() throws Exception {\n     @Test\n     public void publishNoLeak2() throws Exception {\n         System.gc();\n-        Thread.sleep(100);\n+        Thread.sleep(GC_SLEEP_TIME);\n \n         long start = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();\n \n@@ -757,7 +768,7 @@ public Object call() throws Exception {\n         d2 = null;\n \n         System.gc();\n-        Thread.sleep(100);\n+        Thread.sleep(GC_SLEEP_TIME);\n \n         long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();\n ",
    "output": "Add more time for GC in RefCountTest.publishNoLeak\n\n* Add more time for GC in RefCountTest.publishNoLeak\r\n\r\n* Some test restructuring and dynamic GC wait"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java\n@@ -61,7 +61,7 @@ public static <T> void subscribe(ObservableSource<? extends T> o, Observer<? sup\n                 }\n             }\n             if (bs.isDisposed()\n-                    || o == BlockingObserver.TERMINATED\n+                    || v == BlockingObserver.TERMINATED\n                     || NotificationLite.acceptFull(v, observer)) {\n                 break;\n             }",
    "output": "Fix issue #6576 - ObservableBlockingSubscribe compares BlockingObserver.TERMINATED with wrong object"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java\n@@ -119,7 +119,9 @@ public void onComplete() {\n             if (!DisposableHelper.isDisposed(d)) {\n                 @SuppressWarnings(\"unchecked\")\n                 DebounceInnerSubscriber<T, U> dis = (DebounceInnerSubscriber<T, U>)d;\n-                dis.emit();\n+                if (dis != null) {\n+                    dis.emit();\n+                }\n                 DisposableHelper.dispose(debouncer);\n                 downstream.onComplete();\n             }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java\n@@ -112,7 +112,9 @@ public void onComplete() {\n             if (d != DisposableHelper.DISPOSED) {\n                 @SuppressWarnings(\"unchecked\")\n                 DebounceInnerObserver<T, U> dis = (DebounceInnerObserver<T, U>)d;\n-                dis.emit();\n+                if (dis != null) {\n+                    dis.emit();\n+                }\n                 DisposableHelper.dispose(debouncer);\n                 downstream.onComplete();\n             }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java\n@@ -547,4 +547,14 @@ public void timedError() {\n         .test()\n         .assertFailure(TestException.class);\n     }\n+\n+    @Test\n+    public void debounceOnEmpty() {\n+        Flowable.empty().debounce(new Function<Object, Publisher<Object>>() {\n+            @Override\n+            public Publisher<Object> apply(Object o) {\n+                return Flowable.just(new Object());\n+            }\n+        }).subscribe();\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java\n@@ -506,4 +506,14 @@ public void timedError() {\n         .test()\n         .assertFailure(TestException.class);\n     }\n+\n+    @Test\n+    public void debounceOnEmpty() {\n+        Observable.empty().debounce(new Function<Object, ObservableSource<Object>>() {\n+            @Override\n+            public ObservableSource<Object> apply(Object o) {\n+                return Observable.just(new Object());\n+            }\n+        }).subscribe();\n+    }\n }",
    "output": "Fix NPE when debouncing empty source"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java\n@@ -519,10 +519,13 @@ void drain() {\n                                     vr = supplier.get();\n                                 } catch (Throwable e) {\n                                     Exceptions.throwIfFatal(e);\n-                                    upstream.cancel();\n                                     errors.addThrowable(e);\n-                                    downstream.onError(errors.terminate());\n-                                    return;\n+                                    if (!veryEnd) {\n+                                        upstream.cancel();\n+                                        downstream.onError(errors.terminate());\n+                                        return;\n+                                    }\n+                                    vr = null;\n                                 }\n \n                                 if (vr == null) {\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapTest.java\n@@ -15,14 +15,14 @@\n \n import static org.junit.Assert.assertEquals;\n \n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Test;\n import org.reactivestreams.Publisher;\n \n import io.reactivex.*;\n-import io.reactivex.exceptions.TestException;\n+import io.reactivex.exceptions.*;\n import io.reactivex.functions.*;\n import io.reactivex.internal.operators.flowable.FlowableConcatMap.WeakScalarSubscription;\n import io.reactivex.schedulers.Schedulers;\n@@ -169,4 +169,42 @@ public void run() throws Exception {\n \n         assertEquals(0, counter.get());\n     }\n+\n+    @Test\n+    public void delayErrorCallableTillTheEnd() {\n+        Flowable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)\n+        .concatMapDelayError(new Function<Integer, Flowable<Integer>>() {\n+          @Override public Flowable<Integer> apply(final Integer integer) throws Exception {\n+            return Flowable.fromCallable(new Callable<Integer>() {\n+              @Override public Integer call() throws Exception {\n+                if (integer >= 100) {\n+                  throw new NullPointerException(\"test null exp\");\n+                }\n+                return integer;\n+              }\n+            });\n+          }\n+        })\n+        .test()\n+        .assertFailure(CompositeException.class, 1, 2, 3, 23, 32);\n+    }\n+\n+    @Test\n+    public void delayErrorCallableEager() {\n+        Flowable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)\n+        .concatMapDelayError(new Function<Integer, Flowable<Integer>>() {\n+          @Override public Flowable<Integer> apply(final Integer integer) throws Exception {\n+            return Flowable.fromCallable(new Callable<Integer>() {\n+              @Override public Integer call() throws Exception {\n+                if (integer >= 100) {\n+                  throw new NullPointerException(\"test null exp\");\n+                }\n+                return integer;\n+              }\n+            });\n+          }\n+        }, 2, false)\n+        .test()\n+        .assertFailure(NullPointerException.class, 1, 2, 3);\n+    }\n }",
    "output": "Fix concatMapDelayError not continuing on fused inner source crash"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/validators/TestPrefixInMethodName.java b/src/test/java/io/reactivex/validators/TestPrefixInMethodName.java\n--- a/src/test/java/io/reactivex/validators/TestPrefixInMethodName.java\n+++ b/src/test/java/io/reactivex/validators/TestPrefixInMethodName.java\n@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.validators;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.io.*;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Check verifying there are no methods with the prefix \"test\" in the name\n+ */\n+public class TestPrefixInMethodName {\n+\n+    private static final String pattern = \"void\\\\s+test[a-zA-Z0-9]\";\n+    private static final String replacement = \"void \";\n+\n+    @Test\n+    @Ignore\n+    public void checkAndUpdateTestMethodNames() throws Exception {\n+        File f = MaybeNo2Dot0Since.findSource(\"Flowable\");\n+        if (f == null) {\n+            System.out.println(\"Unable to find sources of RxJava\");\n+            return;\n+        }\n+\n+        Queue<File> dirs = new ArrayDeque<File>();\n+\n+        StringBuilder fail = new StringBuilder();\n+        fail.append(\"The following code pattern was found: \").append(pattern).append(\"\\n\");\n+        fail.append(\"Refresh and re-run tests!\\n\\n\");\n+\n+        File parent = f.getParentFile();\n+\n+        dirs.offer(new File(parent.getAbsolutePath().replace('\\\\', '/')));\n+        dirs.offer(new File(parent.getAbsolutePath().replace('\\\\', '/').replace(\"src/main/java\", \"src/test/java\")));\n+\n+        Pattern p = Pattern.compile(pattern);\n+\n+        int total = 0;\n+\n+        while (!dirs.isEmpty()) {\n+            f = dirs.poll();\n+\n+            File[] list = f.listFiles();\n+            if (list != null && list.length != 0) {\n+\n+                for (File u : list) {\n+                    if (u.isDirectory()) {\n+                        dirs.offer(u);\n+                    } else {\n+                        String fname = u.getName();\n+                        if (fname.endsWith(\".java\")) {\n+\n+                            int lineNum = 0;\n+                            List<String> lines = new ArrayList<String>();\n+                            BufferedReader in = new BufferedReader(new FileReader(u));\n+                            boolean found = false;\n+                            try {\n+                                for (; ; ) {\n+                                    String line = in.readLine();\n+                                    if (line == null) {\n+                                        break;\n+                                    }\n+                                    lineNum++;\n+\n+                                    Matcher matcher = p.matcher(line);\n+                                    if (!line.startsWith(\"//\") && !line.startsWith(\"*\") && matcher.find()) {\n+                                        found = true;\n+                                        fail\n+                                                .append(fname)\n+                                                .append(\"#L\").append(lineNum)\n+                                                .append(\"    \").append(line)\n+                                                .append(\"\\n\");\n+                                        total++;\n+\n+                                        int methodNameStartIndex = matcher.end() - 1;\n+                                        char firstChar = Character.toLowerCase(line.charAt(methodNameStartIndex));\n+\n+                                        String newLine = matcher.replaceAll(replacement + firstChar);\n+\n+                                        lines.add(newLine);\n+                                    } else {\n+                                        lines.add(line);\n+                                    }\n+\n+                                }\n+                            } finally {\n+                                in.close();\n+                            }\n+\n+                            /*if (found && System.getenv(\"CI\") == null) {\n+                                PrintWriter w = new PrintWriter(new FileWriter(u));\n+\n+                                try {\n+                                    for (String s : lines) {\n+                                        w.println(s);\n+                                    }\n+                                } finally {\n+                                    w.close();\n+                                }\n+                            }*/\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (total != 0) {\n+            fail.append(\"Found \")\n+                    .append(total)\n+                    .append(\" instances\");\n+            System.out.println(fail);\n+            throw new AssertionError(fail.toString());\n+        }\n+    }\n+}",
    "output": "Remove `test` from `testXXX` method names, create a validator * Add a check to verify there are no methods with the prefix \"test\" in the name * Automatically rename methods \"testXXX\" to \"xxx\" * Do not remove comments * Run check on CI, but do not change the files * Do not automatically rename methods for now * Ignore test prefix check for now"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java\n@@ -176,7 +176,12 @@ void drainAndCancel() {\n         }\n \n         void cancelAll() {\n-            InnerQueuedSubscriber<R> inner;\n+            InnerQueuedSubscriber<R> inner = current;\n+            current = null;\n+\n+            if (inner != null) {\n+                inner.cancel();\n+            }\n \n             while ((inner = subscribers.poll()) != null) {\n                 inner.cancel();\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java\n@@ -162,10 +162,21 @@ public void onComplete() {\n \n         @Override\n         public void dispose() {\n+            if (cancelled) {\n+                return;\n+            }\n             cancelled = true;\n+            upstream.dispose();\n+\n+            drainAndDispose();\n+        }\n+\n+        void drainAndDispose() {\n             if (getAndIncrement() == 0) {\n-                queue.clear();\n-                disposeAll();\n+                do {\n+                    queue.clear();\n+                    disposeAll();\n+                } while (decrementAndGet() != 0);\n             }\n         }\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n@@ -1333,4 +1333,37 @@ public void arrayDelayErrorMaxConcurrencyErrorDelayed() {\n \n         ts.assertFailure(TestException.class, 1, 2);\n     }\n+\n+    @Test\n+    public void cancelActive() {\n+        PublishProcessor<Integer> pp1 = PublishProcessor.create();\n+        PublishProcessor<Integer> pp2 = PublishProcessor.create();\n+\n+        TestSubscriber<Integer> ts = Flowable\n+                .concatEager(Flowable.just(pp1, pp2))\n+                .test();\n+\n+        assertTrue(pp1.hasSubscribers());\n+        assertTrue(pp2.hasSubscribers());\n+\n+        ts.cancel();\n+\n+        assertFalse(pp1.hasSubscribers());\n+        assertFalse(pp2.hasSubscribers());\n+    }\n+\n+    @Test\n+    public void cancelNoInnerYet() {\n+        PublishProcessor<Flowable<Integer>> pp1 = PublishProcessor.create();\n+\n+        TestSubscriber<Integer> ts = Flowable\n+                .concatEager(pp1)\n+                .test();\n+\n+        assertTrue(pp1.hasSubscribers());\n+\n+        ts.cancel();\n+\n+        assertFalse(pp1.hasSubscribers());\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java\n@@ -1141,4 +1141,37 @@ public void arrayDelayErrorMaxConcurrencyErrorDelayed() {\n \n         to.assertFailure(TestException.class, 1, 2);\n     }\n+\n+    @Test\n+    public void cancelActive() {\n+        PublishSubject<Integer> ps1 = PublishSubject.create();\n+        PublishSubject<Integer> ps2 = PublishSubject.create();\n+\n+        TestObserver<Integer> to = Observable\n+                .concatEager(Observable.just(ps1, ps2))\n+                .test();\n+\n+        assertTrue(ps1.hasObservers());\n+        assertTrue(ps2.hasObservers());\n+\n+        to.dispose();\n+\n+        assertFalse(ps1.hasObservers());\n+        assertFalse(ps2.hasObservers());\n+    }\n+\n+    @Test\n+    public void cancelNoInnerYet() {\n+        PublishSubject<Observable<Integer>> ps1 = PublishSubject.create();\n+\n+        TestObserver<Integer> to = Observable\n+                .concatEager(ps1)\n+                .test();\n+\n+        assertTrue(ps1.hasObservers());\n+\n+        to.dispose();\n+\n+        assertFalse(ps1.hasObservers());\n+    }\n }",
    "output": "Fix concatEager to dispose sources & clean up properly"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/exceptions/CompositeException.java b/src/main/java/io/reactivex/exceptions/CompositeException.java\n--- a/src/main/java/io/reactivex/exceptions/CompositeException.java\n+++ b/src/main/java/io/reactivex/exceptions/CompositeException.java\n@@ -280,7 +280,7 @@ public int size() {\n      */\n     /*private */Throwable getRootCause(Throwable e) {\n         Throwable root = e.getCause();\n-        if (root == null || cause == root) {\n+        if (root == null || e == root) {\n             return e;\n         }\n         while (true) {\n\ndiff --git a/src/test/java/io/reactivex/exceptions/CompositeExceptionTest.java b/src/test/java/io/reactivex/exceptions/CompositeExceptionTest.java\n--- a/src/test/java/io/reactivex/exceptions/CompositeExceptionTest.java\n+++ b/src/test/java/io/reactivex/exceptions/CompositeExceptionTest.java\n@@ -364,7 +364,22 @@ public synchronized Throwable getCause() {\n             }\n         };\n         CompositeException ex = new CompositeException(throwable);\n-        assertSame(ex, ex.getRootCause(ex));\n+        assertSame(ex0, ex.getRootCause(ex));\n+    }\n+\n+    @Test\n+    public void rootCauseSelf() {\n+        Throwable throwable = new Throwable() {\n+\n+            private static final long serialVersionUID = -4398003222998914415L;\n+\n+            @Override\n+            public synchronized Throwable getCause() {\n+                return this;\n+            }\n+        };\n+        CompositeException tmp = new CompositeException(new TestException());\n+        assertSame(throwable, tmp.getRootCause(throwable));\n     }\n }\n ",
    "output": "Fix bug in CompositeException.getRootCause\n\n* Fix bug in CompositeException.getRootCause \r\n\r\nThe original code use to be `if (root == null || root == e)`, but apparently after some refactoring it ended up as `if (root == null || cause == root)`, which I believe is a bug.\r\n\r\nThis method should probably be `static` (that would have prevented the bug).\r\n\r\n* Update unit tests for CompositeException.getRootCause"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java\n@@ -557,12 +557,20 @@ void dispatch() {\n                         InnerSubscriber<T>[] freshArray = subscribers.get();\n                         if (subscribersChanged || freshArray != ps) {\n                             ps = freshArray;\n+\n+                            // if we did emit at least one element, request more to replenish the queue\n+                            if (d != 0) {\n+                                if (sourceMode != QueueSubscription.SYNC) {\n+                                    upstream.get().request(d);\n+                                }\n+                            }\n+\n                             continue outer;\n                         }\n                     }\n \n                     // if we did emit at least one element, request more to replenish the queue\n-                    if (d > 0) {\n+                    if (d != 0) {\n                         if (sourceMode != QueueSubscription.SYNC) {\n                             upstream.get().request(d);\n                         }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java\n@@ -1368,4 +1368,134 @@ public String apply(Integer t) throws Exception {\n     public void badRequest() {\n         TestHelper.assertBadRequestReported(Flowable.range(1, 5).publish());\n     }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void splitCombineSubscriberChangeAfterOnNext() {\n+        Flowable<Integer> source = Flowable.range(0, 20)\n+        .doOnSubscribe(new Consumer<Subscription>() {\n+            @Override\n+            public void accept(Subscription v) throws Exception {\n+                System.out.println(\"Subscribed\");\n+            }\n+        })\n+        .publish(10)\n+        .refCount()\n+        ;\n+\n+        Flowable<Integer> evenNumbers = source.filter(new Predicate<Integer>() {\n+            @Override\n+            public boolean test(Integer v) throws Exception {\n+                return v % 2 == 0;\n+            }\n+        });\n+\n+        Flowable<Integer> oddNumbers = source.filter(new Predicate<Integer>() {\n+            @Override\n+            public boolean test(Integer v) throws Exception {\n+                return v % 2 != 0;\n+            }\n+        });\n+\n+        final Single<Integer> getNextOdd = oddNumbers.first(0);\n+\n+        TestSubscriber<List<Integer>> ts = evenNumbers.concatMap(new Function<Integer, Publisher<List<Integer>>>() {\n+            @Override\n+            public Publisher<List<Integer>> apply(Integer v) throws Exception {\n+                return Single.zip(\n+                        Single.just(v), getNextOdd,\n+                        new BiFunction<Integer, Integer, List<Integer>>() {\n+                            @Override\n+                            public List<Integer> apply(Integer a, Integer b) throws Exception {\n+                                return Arrays.asList( a, b );\n+                            }\n+                        }\n+                )\n+                .toFlowable();\n+            }\n+        })\n+        .takeWhile(new Predicate<List<Integer>>() {\n+            @Override\n+            public boolean test(List<Integer> v) throws Exception {\n+                return v.get(0) < 20;\n+            }\n+        })\n+        .test();\n+\n+        ts\n+        .assertResult(\n+                Arrays.asList(0, 1),\n+                Arrays.asList(2, 3),\n+                Arrays.asList(4, 5),\n+                Arrays.asList(6, 7),\n+                Arrays.asList(8, 9),\n+                Arrays.asList(10, 11),\n+                Arrays.asList(12, 13),\n+                Arrays.asList(14, 15),\n+                Arrays.asList(16, 17),\n+                Arrays.asList(18, 19)\n+        );\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void splitCombineSubscriberChangeAfterOnNextFused() {\n+        Flowable<Integer> source = Flowable.range(0, 20)\n+        .publish(10)\n+        .refCount()\n+        ;\n+\n+        Flowable<Integer> evenNumbers = source.filter(new Predicate<Integer>() {\n+            @Override\n+            public boolean test(Integer v) throws Exception {\n+                return v % 2 == 0;\n+            }\n+        });\n+\n+        Flowable<Integer> oddNumbers = source.filter(new Predicate<Integer>() {\n+            @Override\n+            public boolean test(Integer v) throws Exception {\n+                return v % 2 != 0;\n+            }\n+        });\n+\n+        final Single<Integer> getNextOdd = oddNumbers.first(0);\n+\n+        TestSubscriber<List<Integer>> ts = evenNumbers.concatMap(new Function<Integer, Publisher<List<Integer>>>() {\n+            @Override\n+            public Publisher<List<Integer>> apply(Integer v) throws Exception {\n+                return Single.zip(\n+                        Single.just(v), getNextOdd,\n+                        new BiFunction<Integer, Integer, List<Integer>>() {\n+                            @Override\n+                            public List<Integer> apply(Integer a, Integer b) throws Exception {\n+                                return Arrays.asList( a, b );\n+                            }\n+                        }\n+                )\n+                .toFlowable();\n+            }\n+        })\n+        .takeWhile(new Predicate<List<Integer>>() {\n+            @Override\n+            public boolean test(List<Integer> v) throws Exception {\n+                return v.get(0) < 20;\n+            }\n+        })\n+        .test();\n+\n+        ts\n+        .assertResult(\n+                Arrays.asList(0, 1),\n+                Arrays.asList(2, 3),\n+                Arrays.asList(4, 5),\n+                Arrays.asList(6, 7),\n+                Arrays.asList(8, 9),\n+                Arrays.asList(10, 11),\n+                Arrays.asList(12, 13),\n+                Arrays.asList(14, 15),\n+                Arrays.asList(16, 17),\n+                Arrays.asList(18, 19)\n+        );\n+    }\n }",
    "output": "Fix publish not requesting upon client change\n\n* Fix publish not requesting upon client change\r\n\r\n* Add fused test, rename test method"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java\n--- a/src/main/java/io/reactivex/Flowable.java\n+++ b/src/main/java/io/reactivex/Flowable.java\n@@ -16983,7 +16983,7 @@ public final <K, V> Single<Map<K, Collection<V>>> toMultimap(\n      * @since 2.0\n      */\n     @CheckReturnValue\n-    @BackpressureSupport(BackpressureKind.NONE)\n+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)\n     @SchedulerSupport(SchedulerSupport.NONE)\n     public final Observable<T> toObservable() {\n         return RxJavaPlugins.onAssembly(new ObservableFromPublisher<T>(this));",
    "output": "Fix Flowable#toObservable backpressure support"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java\n@@ -141,7 +141,11 @@ void timeout(RefConnection rc) {\n                 if (source instanceof Disposable) {\n                     ((Disposable)source).dispose();\n                 } else if (source instanceof ResettableConnectable) {\n-                    ((ResettableConnectable)source).resetIf(connectionObject);\n+                    if (connectionObject == null) {\n+                        rc.disconnectedEarly = true;\n+                    } else {\n+                        ((ResettableConnectable)source).resetIf(connectionObject);\n+                    }\n                 }\n             }\n         }\n@@ -160,6 +164,8 @@ static final class RefConnection extends AtomicReference<Disposable>\n \n         boolean connected;\n \n+        boolean disconnectedEarly;\n+\n         RefConnection(FlowableRefCount<?> parent) {\n             this.parent = parent;\n         }\n@@ -172,6 +178,11 @@ public void run() {\n         @Override\n         public void accept(Disposable t) throws Exception {\n             DisposableHelper.replace(this, t);\n+            synchronized (parent) {\n+                if (disconnectedEarly) {\n+                    ((ResettableConnectable)parent.source).resetIf(t);\n+                }\n+            }\n         }\n     }\n \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java\n@@ -135,10 +135,15 @@ void timeout(RefConnection rc) {\n                 connection = null;\n                 Disposable connectionObject = rc.get();\n                 DisposableHelper.dispose(rc);\n+\n                 if (source instanceof Disposable) {\n                     ((Disposable)source).dispose();\n                 } else if (source instanceof ResettableConnectable) {\n-                    ((ResettableConnectable)source).resetIf(connectionObject);\n+                    if (connectionObject == null) {\n+                        rc.disconnectedEarly = true;\n+                    } else {\n+                        ((ResettableConnectable)source).resetIf(connectionObject);\n+                    }\n                 }\n             }\n         }\n@@ -157,6 +162,8 @@ static final class RefConnection extends AtomicReference<Disposable>\n \n         boolean connected;\n \n+        boolean disconnectedEarly;\n+\n         RefConnection(ObservableRefCount<?> parent) {\n             this.parent = parent;\n         }\n@@ -169,6 +176,11 @@ public void run() {\n         @Override\n         public void accept(Disposable t) throws Exception {\n             DisposableHelper.replace(this, t);\n+            synchronized (parent) {\n+                if (disconnectedEarly) {\n+                    ((ResettableConnectable)parent.source).resetIf(t);\n+                }\n+            }\n         }\n     }\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n@@ -1394,4 +1394,19 @@ public void timeoutDisposesSource() {\n \n         assertTrue(((Disposable)o.source).isDisposed());\n     }\n+\n+    @Test\n+    public void disconnectBeforeConnect() {\n+        BehaviorProcessor<Integer> processor = BehaviorProcessor.create();\n+\n+        Flowable<Integer> flowable = processor\n+                .replay(1)\n+                .refCount();\n+\n+        flowable.takeUntil(Flowable.just(1)).test();\n+\n+        processor.onNext(2);\n+\n+        flowable.take(1).test().assertResult(2);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java\n@@ -1345,4 +1345,19 @@ public void timeoutDisposesSource() {\n \n         assertTrue(((Disposable)o.source).isDisposed());\n     }\n+\n+    @Test\n+    public void disconnectBeforeConnect() {\n+        BehaviorSubject<Integer> subject = BehaviorSubject.create();\n+\n+        Observable<Integer> observable = subject\n+                .replay(1)\n+                .refCount();\n+\n+        observable.takeUntil(Observable.just(1)).test();\n+\n+        subject.onNext(2);\n+\n+        observable.take(1).test().assertResult(2);\n+    }\n }",
    "output": "Fix refCount eager disconnect not resetting the connection\n\n* Fix refCount eager disconnect not resetting the connection\r\n\r\n* Remove unnecessary comment"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java\n@@ -376,7 +376,7 @@ void drainLoop() {\n                     return;\n                 }\n \n-                boolean innerCompleted = false;\n+                int innerCompleted = 0;\n                 if (n != 0) {\n                     long startId = lastId;\n                     int index = lastIndex;\n@@ -423,7 +423,7 @@ void drainLoop() {\n                                         return;\n                                     }\n                                     removeInner(is);\n-                                    innerCompleted = true;\n+                                    innerCompleted++;\n                                     j++;\n                                     if (j == n) {\n                                         j = 0;\n@@ -449,7 +449,7 @@ void drainLoop() {\n                             if (checkTerminate()) {\n                                 return;\n                             }\n-                            innerCompleted = true;\n+                            innerCompleted++;\n                         }\n \n                         j++;\n@@ -461,17 +461,19 @@ void drainLoop() {\n                     lastId = inner[j].id;\n                 }\n \n-                if (innerCompleted) {\n+                if (innerCompleted != 0) {\n                     if (maxConcurrency != Integer.MAX_VALUE) {\n-                        ObservableSource<? extends U> p;\n-                        synchronized (this) {\n-                            p = sources.poll();\n-                            if (p == null) {\n-                                wip--;\n-                                continue;\n+                        while (innerCompleted-- != 0) {\n+                            ObservableSource<? extends U> p;\n+                            synchronized (this) {\n+                                p = sources.poll();\n+                                if (p == null) {\n+                                    wip--;\n+                                    continue;\n+                                }\n                             }\n+                            subscribeInner(p);\n                         }\n-                        subscribeInner(p);\n                     }\n                     continue;\n                 }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java\n@@ -1084,4 +1084,44 @@ public void remove() {\n \n         assertEquals(1, counter.get());\n     }\n+\n+    @Test\n+    public void maxConcurrencySustained() {\n+        final PublishProcessor<Integer> pp1 = PublishProcessor.create();\n+        final PublishProcessor<Integer> pp2 = PublishProcessor.create();\n+        PublishProcessor<Integer> pp3 = PublishProcessor.create();\n+        PublishProcessor<Integer> pp4 = PublishProcessor.create();\n+\n+        TestSubscriber<Integer> ts = Flowable.just(pp1, pp2, pp3, pp4)\n+        .flatMap(new Function<PublishProcessor<Integer>, Flowable<Integer>>() {\n+            @Override\n+            public Flowable<Integer> apply(PublishProcessor<Integer> v) throws Exception {\n+                return v;\n+            }\n+        }, 2)\n+        .doOnNext(new Consumer<Integer>() {\n+            @Override\n+            public void accept(Integer v) throws Exception {\n+                if (v == 1) {\n+                    // this will make sure the drain loop detects two completed\n+                    // inner sources and replaces them with fresh ones\n+                    pp1.onComplete();\n+                    pp2.onComplete();\n+                }\n+            }\n+        })\n+        .test();\n+\n+        pp1.onNext(1);\n+\n+        assertFalse(pp1.hasSubscribers());\n+        assertFalse(pp2.hasSubscribers());\n+        assertTrue(pp3.hasSubscribers());\n+        assertTrue(pp4.hasSubscribers());\n+\n+        ts.dispose();\n+\n+        assertFalse(pp3.hasSubscribers());\n+        assertFalse(pp4.hasSubscribers());\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java\n@@ -1045,4 +1045,44 @@ public Integer apply(Integer v)\n \n         to.assertValuesOnly(10, 11, 12, 13, 14, 20, 21, 22, 23, 24);\n     }\n+\n+    @Test\n+    public void maxConcurrencySustained() {\n+        final PublishSubject<Integer> ps1 = PublishSubject.create();\n+        final PublishSubject<Integer> ps2 = PublishSubject.create();\n+        PublishSubject<Integer> ps3 = PublishSubject.create();\n+        PublishSubject<Integer> ps4 = PublishSubject.create();\n+\n+        TestObserver<Integer> to = Observable.just(ps1, ps2, ps3, ps4)\n+        .flatMap(new Function<PublishSubject<Integer>, ObservableSource<Integer>>() {\n+            @Override\n+            public ObservableSource<Integer> apply(PublishSubject<Integer> v) throws Exception {\n+                return v;\n+            }\n+        }, 2)\n+        .doOnNext(new Consumer<Integer>() {\n+            @Override\n+            public void accept(Integer v) throws Exception {\n+                if (v == 1) {\n+                    // this will make sure the drain loop detects two completed\n+                    // inner sources and replaces them with fresh ones\n+                    ps1.onComplete();\n+                    ps2.onComplete();\n+                }\n+            }\n+        })\n+        .test();\n+\n+        ps1.onNext(1);\n+\n+        assertFalse(ps1.hasObservers());\n+        assertFalse(ps2.hasObservers());\n+        assertTrue(ps3.hasObservers());\n+        assertTrue(ps4.hasObservers());\n+\n+        to.dispose();\n+\n+        assertFalse(ps3.hasObservers());\n+        assertFalse(ps4.hasObservers());\n+    }\n }",
    "output": "Fix Observable.flatMap to sustain concurrency level"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/observers/BaseTestConsumer.java b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n--- a/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n@@ -351,11 +351,11 @@ public final U assertError(Predicate<Throwable> errorPredicate) {\n     public final U assertValue(T value) {\n         int s = values.size();\n         if (s != 1) {\n-            throw fail(\"Expected: \" + valueAndClass(value) + \", Actual: \" + values);\n+            throw fail(\"expected: \" + valueAndClass(value) + \" but was: \" + values);\n         }\n         T v = values.get(0);\n         if (!ObjectHelper.equals(value, v)) {\n-            throw fail(\"Expected: \" + valueAndClass(value) + \", Actual: \" + valueAndClass(v));\n+            throw fail(\"expected: \" + valueAndClass(value) + \" but was: \" + valueAndClass(v));\n         }\n         return (U)this;\n     }\n@@ -450,7 +450,7 @@ public final U assertValueAt(int index, T value) {\n \n         T v = values.get(index);\n         if (!ObjectHelper.equals(value, v)) {\n-            throw fail(\"Expected: \" + valueAndClass(value) + \", Actual: \" + valueAndClass(v));\n+            throw fail(\"expected: \" + valueAndClass(value) + \" but was: \" + valueAndClass(v));\n         }\n         return (U)this;\n     }\n@@ -512,7 +512,7 @@ public static String valueAndClass(Object o) {\n     public final U assertValueCount(int count) {\n         int s = values.size();\n         if (s != count) {\n-            throw fail(\"Value counts differ; Expected: \" + count + \", Actual: \" + s);\n+            throw fail(\"Value counts differ; expected: \" + count + \" but was: \" + s);\n         }\n         return (U)this;\n     }\n@@ -535,14 +535,14 @@ public final U assertNoValues() {\n     public final U assertValues(T... values) {\n         int s = this.values.size();\n         if (s != values.length) {\n-            throw fail(\"Value count differs; Expected: \" + values.length + \" \" + Arrays.toString(values)\n-            + \", Actual: \" + s + \" \" + this.values);\n+            throw fail(\"Value count differs; expected: \" + values.length + \" \" + Arrays.toString(values)\n+            + \" but was: \" + s + \" \" + this.values);\n         }\n         for (int i = 0; i < s; i++) {\n             T v = this.values.get(i);\n             T u = values[i];\n             if (!ObjectHelper.equals(u, v)) {\n-                throw fail(\"Values at position \" + i + \" differ; Expected: \" + valueAndClass(u) + \", Actual: \" + valueAndClass(v));\n+                throw fail(\"Values at position \" + i + \" differ; expected: \" + valueAndClass(u) + \" but was: \" + valueAndClass(v));\n             }\n         }\n         return (U)this;\n@@ -628,7 +628,7 @@ public final U assertValueSequence(Iterable<? extends T> sequence) {\n             T v = actualIterator.next();\n \n             if (!ObjectHelper.equals(u, v)) {\n-                throw fail(\"Values at position \" + i + \" differ; Expected: \" + valueAndClass(u) + \", Actual: \" + valueAndClass(v));\n+                throw fail(\"Values at position \" + i + \" differ; expected: \" + valueAndClass(u) + \" but was: \" + valueAndClass(v));\n             }\n             i++;\n         }\n@@ -738,7 +738,7 @@ public final U assertErrorMessage(String message) {\n             Throwable e = errors.get(0);\n             String errorMessage = e.getMessage();\n             if (!ObjectHelper.equals(message, errorMessage)) {\n-                throw fail(\"Error message differs; Expected: \" + message + \", Actual: \" + errorMessage);\n+                throw fail(\"Error message differs; exptected: \" + message + \" but was: \" + errorMessage);\n             }\n         } else {\n             throw fail(\"Multiple errors\");\n\ndiff --git a/src/test/java/io/reactivex/observers/TestObserverTest.java b/src/test/java/io/reactivex/observers/TestObserverTest.java\n--- a/src/test/java/io/reactivex/observers/TestObserverTest.java\n+++ b/src/test/java/io/reactivex/observers/TestObserverTest.java\n@@ -1407,7 +1407,7 @@ public void assertValueAtIndexNoMatch() {\n         Observable.just(\"a\", \"b\", \"c\").subscribe(to);\n \n         thrown.expect(AssertionError.class);\n-        thrown.expectMessage(\"Expected: b (class: String), Actual: c (class: String) (latch = 0, values = 3, errors = 0, completions = 1)\");\n+        thrown.expectMessage(\"expected: b (class: String) but was: c (class: String) (latch = 0, values = 3, errors = 0, completions = 1)\");\n         to.assertValueAt(2, \"b\");\n     }\n ",
    "output": "Use JUnit's assert format for assert messages to enable better suppor…\n\n* Use JUnit's assert format for assert messages to enable better support in IDEs\r\n\r\n* remove unnecessary < and > since it's not matched by IntelliJ's regex"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSampleTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSampleTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSampleTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSampleTest.java\n@@ -13,6 +13,7 @@\n \n package io.reactivex.internal.operators.flowable;\n \n+import static org.junit.Assert.assertFalse;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.*;\n \n@@ -306,11 +307,20 @@ public void backpressureOverflow() {\n \n     @Test\n     public void backpressureOverflowWithOtherPublisher() {\n-        BehaviorProcessor.createDefault(1)\n-        .sample(Flowable.timer(1, TimeUnit.MILLISECONDS))\n-        .test(0L)\n-        .awaitDone(5, TimeUnit.SECONDS)\n-        .assertFailure(MissingBackpressureException.class);\n+        PublishProcessor<Integer> pp1 = PublishProcessor.create();\n+        PublishProcessor<Integer> pp2 = PublishProcessor.create();\n+\n+        TestSubscriber<Integer> ts =  pp1\n+        .sample(pp2)\n+        .test(0L);\n+\n+        pp1.onNext(1);\n+        pp2.onNext(2);\n+\n+        ts.assertFailure(MissingBackpressureException.class);\n+\n+        assertFalse(pp1.hasSubscribers());\n+        assertFalse(pp2.hasSubscribers());\n     }\n \n     @Test\n@@ -455,5 +465,19 @@ public Flowable<Object> apply(Flowable<Object> f)\n                 return f.sample(1, TimeUnit.SECONDS);\n             }\n         });\n+\n+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {\n+            @Override\n+            public Flowable<Object> apply(Flowable<Object> f)\n+                    throws Exception {\n+                return f.sample(PublishProcessor.create());\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void badRequest() {\n+        TestHelper.assertBadRequestReported(PublishProcessor.create()\n+                .sample(PublishProcessor.create()));\n     }\n }",
    "output": "Fix flaky sample() backpressure test, improve coverage"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java\n--- a/src/main/java/io/reactivex/Completable.java\n+++ b/src/main/java/io/reactivex/Completable.java\n@@ -1390,6 +1390,51 @@ public final Completable delay(final long delay, final TimeUnit unit, final Sche\n         return RxJavaPlugins.onAssembly(new CompletableDelay(this, delay, unit, scheduler, delayError));\n     }\n \n+    /**\n+     * Returns a Completable that delays the subscription to the source CompletableSource by a given amount of time.\n+     * <p>\n+     * <dl>\n+     *  <dt><b>Scheduler:</b></dt>\n+     *  <dd>This version of {@code delaySubscription} operates by default on the {@code computation} {@link Scheduler}.</dd>\n+     * </dl>\n+     *\n+     * @param delay the time to delay the subscription\n+     * @param unit  the time unit of {@code delay}\n+     * @return a Completable that delays the subscription to the source CompletableSource by the given amount\n+     * @since 2.2.3 - experimental\n+     * @see <a href=\"http://reactivex.io/documentation/operators/delay.html\">ReactiveX operators documentation: Delay</a>\n+     */\n+    @CheckReturnValue\n+    @Experimental\n+    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n+    public final Completable delaySubscription(long delay, TimeUnit unit) {\n+        return delaySubscription(delay, unit, Schedulers.computation());\n+    }\n+\n+    /**\n+     * Returns a Completable that delays the subscription to the source CompletableSource by a given amount of time,\n+     * both waiting and subscribing on a given Scheduler.\n+     * <p>\n+     * <dl>\n+     *  <dt><b>Scheduler:</b></dt>\n+     *  <dd>You specify which {@link Scheduler} this operator will use.</dd>\n+     * </dl>\n+     *\n+     * @param delay     the time to delay the subscription\n+     * @param unit      the time unit of {@code delay}\n+     * @param scheduler the Scheduler on which the waiting and subscription will happen\n+     * @return a Completable that delays the subscription to the source CompletableSource by a given\n+     * amount, waiting and subscribing on the given Scheduler\n+     * @since 2.2.3 - experimental\n+     * @see <a href=\"http://reactivex.io/documentation/operators/delay.html\">ReactiveX operators documentation: Delay</a>\n+     */\n+    @CheckReturnValue\n+    @Experimental\n+    @SchedulerSupport(SchedulerSupport.CUSTOM)\n+    public final Completable delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {\n+        return Completable.timer(delay, unit, scheduler).andThen(this);\n+    }\n+\n     /**\n      * Returns a Completable which calls the given onComplete callback if this Completable completes.\n      * <p>\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java\n--- a/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java\n@@ -20,11 +20,14 @@\n \n import org.junit.Test;\n \n-import io.reactivex.*;\n+import io.reactivex.CompletableSource;\n+import io.reactivex.TestHelper;\n+import io.reactivex.Completable;\n import io.reactivex.exceptions.TestException;\n import io.reactivex.functions.*;\n import io.reactivex.observers.TestObserver;\n-import io.reactivex.schedulers.*;\n+import io.reactivex.schedulers.Schedulers;\n+import io.reactivex.schedulers.TestScheduler;\n \n public class CompletableDelayTest {\n \n@@ -120,4 +123,69 @@ public void errorDelayed() {\n \n         to.assertFailure(TestException.class);\n     }\n+\n+    @Test\n+    public void errorDelayedSubscription() {\n+        TestScheduler scheduler = new TestScheduler();\n+\n+        TestObserver<Void> to = Completable.error(new TestException())\n+                .delaySubscription(100, TimeUnit.MILLISECONDS, scheduler)\n+                .test();\n+\n+        to.assertEmpty();\n+\n+        scheduler.advanceTimeBy(90, TimeUnit.MILLISECONDS);\n+\n+        to.assertEmpty();\n+\n+        scheduler.advanceTimeBy(15, TimeUnit.MILLISECONDS);\n+\n+        to.assertFailure(TestException.class);\n+    }\n+\n+    @Test\n+    public void errorDelayedSubscriptionDisposeBeforeTime() {\n+        TestScheduler scheduler = new TestScheduler();\n+\n+        Completable result = Completable.complete()\n+                .delaySubscription(100, TimeUnit.MILLISECONDS, scheduler);\n+        TestObserver<Void> to = result.test();\n+\n+        to.assertEmpty();\n+\n+        scheduler.advanceTimeBy(90, TimeUnit.MILLISECONDS);\n+        to.dispose();\n+\n+        scheduler.advanceTimeBy(15, TimeUnit.MILLISECONDS);\n+\n+        to.assertEmpty();\n+    }\n+\n+    @Test\n+    public void testDelaySubscriptionDisposeBeforeTime() {\n+        TestScheduler scheduler = new TestScheduler();\n+\n+        Completable result = Completable.complete()\n+                .delaySubscription(100, TimeUnit.MILLISECONDS, scheduler);\n+        TestObserver<Void> to = result.test();\n+\n+        to.assertEmpty();\n+        scheduler.advanceTimeBy(90, TimeUnit.MILLISECONDS);\n+        to.dispose();\n+        scheduler.advanceTimeBy(15, TimeUnit.MILLISECONDS);\n+        to.assertEmpty();\n+    }\n+\n+    @Test\n+    public void testDelaySubscription() {\n+        TestScheduler scheduler = new TestScheduler();\n+        Completable result = Completable.complete()\n+                .delaySubscription(100, TimeUnit.MILLISECONDS, scheduler);\n+        TestObserver<Void> to = result.test();\n+\n+        scheduler.advanceTimeBy(90, TimeUnit.MILLISECONDS);\n+        to.assertEmpty();\n+        scheduler.advanceTimeBy(15, TimeUnit.MILLISECONDS);\n+        to.assertResult();\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/validators/ParamValidationCheckerTest.java b/src/test/java/io/reactivex/validators/ParamValidationCheckerTest.java\n--- a/src/test/java/io/reactivex/validators/ParamValidationCheckerTest.java\n+++ b/src/test/java/io/reactivex/validators/ParamValidationCheckerTest.java\n@@ -261,6 +261,10 @@ public void checkParallelFlowable() {\n         addOverride(new ParamOverride(Completable.class, 0, ParamMode.ANY, \"delay\", Long.TYPE, TimeUnit.class, Scheduler.class));\n         addOverride(new ParamOverride(Completable.class, 0, ParamMode.ANY, \"delay\", Long.TYPE, TimeUnit.class, Scheduler.class, Boolean.TYPE));\n \n+        // negative time is considered as zero time\n+        addOverride(new ParamOverride(Completable.class, 0, ParamMode.ANY, \"delaySubscription\", Long.TYPE, TimeUnit.class));\n+        addOverride(new ParamOverride(Completable.class, 0, ParamMode.ANY, \"delaySubscription\", Long.TYPE, TimeUnit.class, Scheduler.class));\n+\n         // zero repeat is allowed\n         addOverride(new ParamOverride(Completable.class, 0, ParamMode.NON_NEGATIVE, \"repeat\", Long.TYPE));\n ",
    "output": "Add delaySubscription() methods to Completable #5081\n\n* Add delaySubscription() methods to Completable #5081\r\n\r\n* fix parameter test and documentation for delaySubscription()\r\n\r\n* add tests to delayCompletable()\r\n\r\n* remove mocked observer from delaySubscription() tests for Completable"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java\n--- a/src/main/java/io/reactivex/Completable.java\n+++ b/src/main/java/io/reactivex/Completable.java\n@@ -1227,6 +1227,7 @@ public final boolean blockingAwait(long timeout, TimeUnit unit) {\n      * @return the throwable if this terminated with an error, null otherwise\n      * @throws RuntimeException that wraps an InterruptedException if the wait is interrupted\n      */\n+    @Nullable\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n     public final Throwable blockingGet() {\n@@ -1250,6 +1251,7 @@ public final Throwable blockingGet() {\n      * @throws RuntimeException that wraps an InterruptedException if the wait is interrupted or\n      * TimeoutException if the specified timeout elapsed before it\n      */\n+    @Nullable\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n     public final Throwable blockingGet(long timeout, TimeUnit unit) {",
    "output": "Add Nullable annotations for blocking methods in Completable"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java b/src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java\n--- a/src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java\n+++ b/src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java\n@@ -48,6 +48,6 @@ public OnErrorNotImplementedException(String message, @NonNull Throwable e) {\n      *          the {@code Throwable} to signal; if null, a NullPointerException is constructed\n      */\n     public OnErrorNotImplementedException(@NonNull Throwable e) {\n-        super(e != null ? e.getMessage() : null, e != null ? e : new NullPointerException());\n+        this(\"The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | \" + (e != null ? e.getMessage() : \"\"), e);\n     }\n }\n\\ No newline at end of file\n\ndiff --git a/src/main/java/io/reactivex/exceptions/UndeliverableException.java b/src/main/java/io/reactivex/exceptions/UndeliverableException.java\n--- a/src/main/java/io/reactivex/exceptions/UndeliverableException.java\n+++ b/src/main/java/io/reactivex/exceptions/UndeliverableException.java\n@@ -28,6 +28,6 @@ public final class UndeliverableException extends IllegalStateException {\n      * @param cause the cause, not null\n      */\n     public UndeliverableException(Throwable cause) {\n-        super(cause);\n+        super(\"The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | \" + cause.getMessage(), cause);\n     }\n }\n\ndiff --git a/src/test/java/io/reactivex/exceptions/ExceptionsTest.java b/src/test/java/io/reactivex/exceptions/ExceptionsTest.java\n--- a/src/test/java/io/reactivex/exceptions/ExceptionsTest.java\n+++ b/src/test/java/io/reactivex/exceptions/ExceptionsTest.java\n@@ -53,7 +53,8 @@ public void accept(Integer t1) {\n \n         });\n \n-        TestHelper.assertError(errors, 0, RuntimeException.class, \"hello\");\n+        TestHelper.assertError(errors, 0, RuntimeException.class);\n+        assertTrue(errors.get(0).toString(), errors.get(0).getMessage().contains(\"hello\"));\n         RxJavaPlugins.reset();\n     }\n ",
    "output": "Add explanation text to Undeliverable & OnErrorNotImplemented exs\n\n* Add explanation text to Undeliverable & OnErrorNotImplemented exs\r\n\r\n* Link to the wiki instead of the docs directory due to broken [[]] links\r\n\r\n* Reword OnErrorNotImplemented"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java\n@@ -37,10 +37,8 @@\n import io.reactivex.internal.schedulers.ImmediateThinScheduler;\n import io.reactivex.observers.*;\n import io.reactivex.plugins.RxJavaPlugins;\n-import io.reactivex.processors.UnicastProcessor;\n import io.reactivex.schedulers.*;\n import io.reactivex.subjects.*;\n-import io.reactivex.subscribers.TestSubscriber;\n \n public class ObservableObserveOnTest {\n ",
    "output": "Remove unused imports"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java\n@@ -21,6 +21,7 @@\n import io.reactivex.exceptions.Exceptions;\n import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.subscriptions.DeferredScalarSubscription;\n+import io.reactivex.plugins.RxJavaPlugins;\n \n public final class FlowableFromCallable<T> extends Flowable<T> implements Callable<T> {\n     final Callable<? extends T> callable;\n@@ -38,7 +39,11 @@ public void subscribeActual(Subscriber<? super T> s) {\n             t = ObjectHelper.requireNonNull(callable.call(), \"The callable returned a null value\");\n         } catch (Throwable ex) {\n             Exceptions.throwIfFatal(ex);\n-            s.onError(ex);\n+            if (deferred.isCancelled()) {\n+                RxJavaPlugins.onError(ex);\n+            } else {\n+                s.onError(ex);\n+            }\n             return;\n         }\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromCallableTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromCallableTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromCallableTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromCallableTest.java\n@@ -16,9 +16,11 @@\n \n package io.reactivex.internal.operators.flowable;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.*;\n-import static org.junit.Assert.*;\n \n+import java.util.List;\n import java.util.concurrent.*;\n \n import org.junit.Test;\n@@ -27,7 +29,9 @@\n import org.reactivestreams.*;\n \n import io.reactivex.*;\n+import io.reactivex.exceptions.TestException;\n import io.reactivex.functions.Function;\n+import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.schedulers.Schedulers;\n import io.reactivex.subscribers.TestSubscriber;\n \n@@ -238,4 +242,27 @@ public Object call() throws Exception {\n         .test()\n         .assertFailure(NullPointerException.class);\n     }\n+\n+    @Test(timeout = 5000)\n+    public void undeliverableUponCancellation() throws Exception {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            final TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+\n+            Flowable.fromCallable(new Callable<Integer>() {\n+                @Override\n+                public Integer call() throws Exception {\n+                    ts.cancel();\n+                    throw new TestException();\n+                }\n+            })\n+            .subscribe(ts);\n+\n+            ts.assertEmpty();\n+\n+            TestHelper.assertUndeliverable(errors, 0, TestException.class);\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n }",
    "output": "Make Flowable.fromCallable consitent with the other fromCallables\n\n2.x: Make Flowable.fromCallable consistent with the other fromCallables"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java\n@@ -13,11 +13,14 @@\n \n package io.reactivex.internal.operators.completable;\n \n+import java.util.concurrent.atomic.AtomicReference;\n+\n import io.reactivex.*;\n import io.reactivex.disposables.Disposable;\n import io.reactivex.exceptions.*;\n import io.reactivex.functions.Function;\n-import io.reactivex.internal.disposables.SequentialDisposable;\n+import io.reactivex.internal.disposables.DisposableHelper;\n+import io.reactivex.internal.functions.ObjectHelper;\n \n public final class CompletableResumeNext extends Completable {\n \n@@ -35,20 +38,32 @@ public CompletableResumeNext(CompletableSource source,\n \n     @Override\n     protected void subscribeActual(final CompletableObserver observer) {\n-\n-        final SequentialDisposable sd = new SequentialDisposable();\n-        observer.onSubscribe(sd);\n-        source.subscribe(new ResumeNext(observer, sd));\n+        ResumeNextObserver parent = new ResumeNextObserver(observer, errorMapper);\n+        observer.onSubscribe(parent);\n+        source.subscribe(parent);\n     }\n \n-    final class ResumeNext implements CompletableObserver {\n+    static final class ResumeNextObserver\n+    extends AtomicReference<Disposable>\n+    implements CompletableObserver, Disposable {\n+\n+        private static final long serialVersionUID = 5018523762564524046L;\n \n         final CompletableObserver downstream;\n-        final SequentialDisposable sd;\n \n-        ResumeNext(CompletableObserver observer, SequentialDisposable sd) {\n+        final Function<? super Throwable, ? extends CompletableSource> errorMapper;\n+\n+        boolean once;\n+\n+        ResumeNextObserver(CompletableObserver observer, Function<? super Throwable, ? extends CompletableSource> errorMapper) {\n             this.downstream = observer;\n-            this.sd = sd;\n+            this.errorMapper = errorMapper;\n+        }\n+\n+\n+        @Override\n+        public void onSubscribe(Disposable d) {\n+            DisposableHelper.replace(this, d);\n         }\n \n         @Override\n@@ -58,48 +73,33 @@ public void onComplete() {\n \n         @Override\n         public void onError(Throwable e) {\n+            if (once) {\n+                downstream.onError(e);\n+                return;\n+            }\n+            once = true;\n+\n             CompletableSource c;\n \n             try {\n-                c = errorMapper.apply(e);\n+                c = ObjectHelper.requireNonNull(errorMapper.apply(e), \"The errorMapper returned a null CompletableSource\");\n             } catch (Throwable ex) {\n                 Exceptions.throwIfFatal(ex);\n-                downstream.onError(new CompositeException(ex, e));\n+                downstream.onError(new CompositeException(e, ex));\n                 return;\n             }\n \n-            if (c == null) {\n-                NullPointerException npe = new NullPointerException(\"The CompletableConsumable returned is null\");\n-                npe.initCause(e);\n-                downstream.onError(npe);\n-                return;\n-            }\n-\n-            c.subscribe(new OnErrorObserver());\n+            c.subscribe(this);\n         }\n \n         @Override\n-        public void onSubscribe(Disposable d) {\n-            sd.update(d);\n+        public boolean isDisposed() {\n+            return DisposableHelper.isDisposed(get());\n         }\n \n-        final class OnErrorObserver implements CompletableObserver {\n-\n-            @Override\n-            public void onComplete() {\n-                downstream.onComplete();\n-            }\n-\n-            @Override\n-            public void onError(Throwable e) {\n-                downstream.onError(e);\n-            }\n-\n-            @Override\n-            public void onSubscribe(Disposable d) {\n-                sd.update(d);\n-            }\n-\n+        @Override\n+        public void dispose() {\n+            DisposableHelper.dispose(this);\n         }\n     }\n }\n\ndiff --git a/src/test/java/io/reactivex/completable/CompletableTest.java b/src/test/java/io/reactivex/completable/CompletableTest.java\n--- a/src/test/java/io/reactivex/completable/CompletableTest.java\n+++ b/src/test/java/io/reactivex/completable/CompletableTest.java\n@@ -2170,8 +2170,11 @@ public Completable apply(Throwable e) {\n         try {\n             c.blockingAwait();\n             Assert.fail(\"Did not throw an exception\");\n-        } catch (NullPointerException ex) {\n-            Assert.assertTrue(ex.getCause() instanceof TestException);\n+        } catch (CompositeException ex) {\n+            List<Throwable> errors = ex.getExceptions();\n+            TestHelper.assertError(errors, 0, TestException.class);\n+            TestHelper.assertError(errors, 1, NullPointerException.class);\n+            assertEquals(2, errors.size());\n         }\n     }\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableResumeNextTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableResumeNextTest.java\n--- a/src/test/java/io/reactivex/internal/operators/completable/CompletableResumeNextTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableResumeNextTest.java\n@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.completable;\n+\n+import org.junit.Test;\n+\n+import io.reactivex.*;\n+import io.reactivex.exceptions.TestException;\n+import io.reactivex.functions.Function;\n+import io.reactivex.internal.functions.Functions;\n+\n+public class CompletableResumeNextTest {\n+\n+    @Test\n+    public void resumeWithError() {\n+        Completable.error(new TestException())\n+        .onErrorResumeNext(Functions.justFunction(Completable.error(new TestException(\"second\"))))\n+        .test()\n+        .assertFailureAndMessage(TestException.class, \"second\");\n+    }\n+\n+    @Test\n+    public void disposeInMain() {\n+        TestHelper.checkDisposedCompletable(new Function<Completable, CompletableSource>() {\n+            @Override\n+            public CompletableSource apply(Completable c) throws Exception {\n+                return c.onErrorResumeNext(Functions.justFunction(Completable.complete()));\n+            }\n+        });\n+    }\n+\n+\n+    @Test\n+    public void disposeInResume() {\n+        TestHelper.checkDisposedCompletable(new Function<Completable, CompletableSource>() {\n+            @Override\n+            public CompletableSource apply(Completable c) throws Exception {\n+                return Completable.error(new TestException()).onErrorResumeNext(Functions.justFunction(c));\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void disposed() {\n+        TestHelper.checkDisposed(\n+                Completable.error(new TestException())\n+                .onErrorResumeNext(Functions.justFunction(Completable.never()))\n+        );\n+    }\n+}",
    "output": "Improve Completable.onErrorResumeNext internals\n\n* Improve Completable.onErrorResumeNext internals\r\n\r\n* Use ObjectHelper"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java\n@@ -14,9 +14,11 @@\n package io.reactivex.internal.operators.completable;\n \n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import io.reactivex.*;\n-import io.reactivex.disposables.*;\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.internal.disposables.DisposableHelper;\n \n public final class CompletableDelay extends Completable {\n \n@@ -40,54 +42,70 @@ public CompletableDelay(CompletableSource source, long delay, TimeUnit unit, Sch\n \n     @Override\n     protected void subscribeActual(final CompletableObserver s) {\n-        final CompositeDisposable set = new CompositeDisposable();\n-\n-        source.subscribe(new Delay(set, s));\n+        source.subscribe(new Delay(s, delay, unit, scheduler, delayError));\n     }\n \n-    final class Delay implements CompletableObserver {\n+    static final class Delay extends AtomicReference<Disposable>\n+    implements CompletableObserver, Runnable, Disposable {\n+\n+        private static final long serialVersionUID = 465972761105851022L;\n+\n+        final CompletableObserver downstream;\n+\n+        final long delay;\n+\n+        final TimeUnit unit;\n \n-        private final CompositeDisposable set;\n-        final CompletableObserver s;\n+        final Scheduler scheduler;\n \n-        Delay(CompositeDisposable set, CompletableObserver s) {\n-            this.set = set;\n-            this.s = s;\n+        final boolean delayError;\n+\n+        Throwable error;\n+\n+        Delay(CompletableObserver downstream, long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n+            this.downstream = downstream;\n+            this.delay = delay;\n+            this.unit = unit;\n+            this.scheduler = scheduler;\n+            this.delayError = delayError;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Disposable d) {\n+            if (DisposableHelper.setOnce(this, d)) {\n+                downstream.onSubscribe(this);\n+            }\n         }\n \n         @Override\n         public void onComplete() {\n-            set.add(scheduler.scheduleDirect(new OnComplete(), delay, unit));\n+            DisposableHelper.replace(this, scheduler.scheduleDirect(this, delay, unit));\n         }\n \n         @Override\n         public void onError(final Throwable e) {\n-            set.add(scheduler.scheduleDirect(new OnError(e), delayError ? delay : 0, unit));\n+            error = e;\n+            DisposableHelper.replace(this, scheduler.scheduleDirect(this, delayError ? delay : 0, unit));\n         }\n \n         @Override\n-        public void onSubscribe(Disposable d) {\n-            set.add(d);\n-            s.onSubscribe(set);\n+        public void dispose() {\n+            DisposableHelper.dispose(this);\n         }\n \n-        final class OnComplete implements Runnable {\n-            @Override\n-            public void run() {\n-                s.onComplete();\n-            }\n+        @Override\n+        public boolean isDisposed() {\n+            return DisposableHelper.isDisposed(get());\n         }\n \n-        final class OnError implements Runnable {\n-            private final Throwable e;\n-\n-            OnError(Throwable e) {\n-                this.e = e;\n-            }\n-\n-            @Override\n-            public void run() {\n-                s.onError(e);\n+        @Override\n+        public void run() {\n+            Throwable e = error;\n+            error = null;\n+            if (e != null) {\n+                downstream.onError(e);\n+            } else {\n+                downstream.onComplete();\n             }\n         }\n     }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java\n--- a/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java\n@@ -13,17 +13,18 @@\n \n package io.reactivex.internal.operators.completable;\n \n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n+import static org.junit.Assert.assertNotEquals;\n+\n+import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import io.reactivex.functions.Consumer;\n import org.junit.Test;\n \n-import io.reactivex.Completable;\n-import io.reactivex.schedulers.Schedulers;\n-\n-import static org.junit.Assert.assertNotEquals;\n+import io.reactivex.*;\n+import io.reactivex.exceptions.TestException;\n+import io.reactivex.functions.*;\n+import io.reactivex.observers.TestObserver;\n+import io.reactivex.schedulers.*;\n \n public class CompletableDelayTest {\n \n@@ -58,4 +59,65 @@ public void accept(Throwable throwable) throws Exception {\n         assertNotEquals(Thread.currentThread(), thread.get());\n     }\n \n+    @Test\n+    public void disposed() {\n+        TestHelper.checkDisposed(Completable.never().delay(1, TimeUnit.MINUTES));\n+    }\n+\n+    @Test\n+    public void doubleOnSubscribe() {\n+        TestHelper.checkDoubleOnSubscribeCompletable(new Function<Completable, CompletableSource>() {\n+            @Override\n+            public CompletableSource apply(Completable c) throws Exception {\n+                return c.delay(1, TimeUnit.MINUTES);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void normal() {\n+        Completable.complete()\n+        .delay(1, TimeUnit.MILLISECONDS)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult();\n+    }\n+\n+    @Test\n+    public void errorNotDelayed() {\n+        TestScheduler scheduler = new TestScheduler();\n+\n+        TestObserver<Void> to = Completable.error(new TestException())\n+        .delay(100, TimeUnit.MILLISECONDS, scheduler, false)\n+        .test();\n+\n+        to.assertEmpty();\n+\n+        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);\n+\n+        to.assertFailure(TestException.class);\n+\n+        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n+\n+        to.assertFailure(TestException.class);\n+    }\n+\n+    @Test\n+    public void errorDelayed() {\n+        TestScheduler scheduler = new TestScheduler();\n+\n+        TestObserver<Void> to = Completable.error(new TestException())\n+        .delay(100, TimeUnit.MILLISECONDS, scheduler, true)\n+        .test();\n+\n+        to.assertEmpty();\n+\n+        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);\n+\n+        to.assertEmpty();\n+\n+        scheduler.advanceTimeBy(99, TimeUnit.MILLISECONDS);\n+\n+        to.assertFailure(TestException.class);\n+    }\n }",
    "output": "Improve Completable.delay operator internals"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java\n--- a/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java\n+++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java\n@@ -218,6 +218,7 @@ void drain() {\n                     if (cancelled) {\n                         queue.clear();\n                         item = null;\n+                        break;\n                     }\n \n                     int s = state;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java\n@@ -213,6 +213,7 @@ void drain() {\n                     if (cancelled) {\n                         queue.clear();\n                         item = null;\n+                        break;\n                     }\n \n                     int s = state;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java\n--- a/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java\n+++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java\n@@ -199,6 +199,7 @@ void drain() {\n                     if (cancelled) {\n                         queue.clear();\n                         item = null;\n+                        break;\n                     }\n \n                     int s = state;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java\n@@ -194,6 +194,7 @@ void drain() {\n                     if (cancelled) {\n                         queue.clear();\n                         item = null;\n+                        break;\n                     }\n \n                     int s = state;\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybeTest.java b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybeTest.java\n@@ -394,4 +394,35 @@ public void cancelNoConcurrentClean() {\n \n         assertTrue(operator.queue.isEmpty());\n     }\n+\n+    @Test\n+    public void innerSuccessDisposeRace() {\n+        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {\n+\n+            final MaybeSubject<Integer> ms = MaybeSubject.create();\n+\n+            final TestSubscriber<Integer> ts = Flowable.just(1)\n+                    .hide()\n+                    .concatMapMaybe(Functions.justFunction(ms))\n+                    .test();\n+\n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ms.onSuccess(1);\n+                }\n+            };\n+            Runnable r2 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ts.dispose();\n+                }\n+            };\n+\n+            TestHelper.race(r1, r2);\n+\n+            ts.assertNoErrors();\n+        }\n+    }\n+\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingleTest.java b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingleTest.java\n--- a/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingleTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingleTest.java\n@@ -309,4 +309,34 @@ public void cancelNoConcurrentClean() {\n \n         assertTrue(operator.queue.isEmpty());\n     }\n+\n+    @Test\n+    public void innerSuccessDisposeRace() {\n+        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {\n+\n+            final SingleSubject<Integer> ss = SingleSubject.create();\n+\n+            final TestSubscriber<Integer> ts = Flowable.just(1)\n+                    .hide()\n+                    .concatMapSingle(Functions.justFunction(ss))\n+                    .test();\n+\n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ss.onSuccess(1);\n+                }\n+            };\n+            Runnable r2 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ts.dispose();\n+                }\n+            };\n+\n+            TestHelper.race(r1, r2);\n+\n+            ts.assertNoErrors();\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java\n@@ -416,4 +416,34 @@ public void checkUnboundedInnerQueue() {\n \n         to.assertResult(1, 2, 3, 4);\n     }\n+\n+    @Test\n+    public void innerSuccessDisposeRace() {\n+        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {\n+\n+            final MaybeSubject<Integer> ms = MaybeSubject.create();\n+\n+            final TestObserver<Integer> to = Observable.just(1)\n+                    .hide()\n+                    .concatMapMaybe(Functions.justFunction(ms))\n+                    .test();\n+\n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ms.onSuccess(1);\n+                }\n+            };\n+            Runnable r2 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    to.dispose();\n+                }\n+            };\n+\n+            TestHelper.race(r1, r2);\n+\n+            to.assertNoErrors();\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java\n--- a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java\n@@ -353,4 +353,35 @@ public void checkUnboundedInnerQueue() {\n \n         to.assertResult(1, 2, 3, 4);\n     }\n+\n+    @Test\n+    public void innerSuccessDisposeRace() {\n+        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {\n+\n+            final SingleSubject<Integer> ss = SingleSubject.create();\n+\n+            final TestObserver<Integer> to = Observable.just(1)\n+                    .hide()\n+                    .concatMapSingle(Functions.justFunction(ss))\n+                    .test();\n+\n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ss.onSuccess(1);\n+                }\n+            };\n+            Runnable r2 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    to.dispose();\n+                }\n+            };\n+\n+            TestHelper.race(r1, r2);\n+\n+            to.assertNoErrors();\n+        }\n+    }\n+\n }",
    "output": "Fix concatMap{Single|Maybe} null emission on dispose race"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java\n@@ -63,7 +63,7 @@ public static <T> void subscribe(Publisher<? extends T> o, Subscriber<? super T>\n                 if (bs.isCancelled()) {\n                     break;\n                 }\n-                if (o == BlockingSubscriber.TERMINATED\n+                if (v == BlockingSubscriber.TERMINATED\n                         || NotificationLite.acceptFull(v, subscriber)) {\n                     break;\n                 }",
    "output": "Fix check that would always be false\n\nChecking `BlockingSubscriber.TERMINATED` (`new Object()`) against `o` would always be false since `o` is a publisher. Since `v` comes from the queue this is presumably the variable that should be checked.\r\n\r\nHowever the check might even be redundant with this change since that variable can only appear in the queue after the subscriber has been cancelled. I am not familiar enough with the memory model to say whether the object appearing in the queue implies the cancelled subscriber is visible"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/observers/LambdaObserver.java b/src/main/java/io/reactivex/internal/observers/LambdaObserver.java\n--- a/src/main/java/io/reactivex/internal/observers/LambdaObserver.java\n+++ b/src/main/java/io/reactivex/internal/observers/LambdaObserver.java\n@@ -79,6 +79,8 @@ public void onError(Throwable t) {\n                 Exceptions.throwIfFatal(e);\n                 RxJavaPlugins.onError(new CompositeException(t, e));\n             }\n+        } else {\n+            RxJavaPlugins.onError(t);\n         }\n     }\n \n\ndiff --git a/src/test/java/io/reactivex/internal/observers/LambdaObserverTest.java b/src/test/java/io/reactivex/internal/observers/LambdaObserverTest.java\n--- a/src/test/java/io/reactivex/internal/observers/LambdaObserverTest.java\n+++ b/src/test/java/io/reactivex/internal/observers/LambdaObserverTest.java\n@@ -15,6 +15,7 @@\n \n import static org.junit.Assert.*;\n \n+import java.io.IOException;\n import java.util.*;\n \n import io.reactivex.internal.functions.Functions;\n@@ -363,4 +364,32 @@ public void customOnErrorShouldReportCustomOnError() {\n \n         assertTrue(o.hasCustomOnError());\n     }\n+\n+    @Test\n+    public void disposedObserverShouldReportErrorOnGlobalErrorHandler() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            final List<Throwable> observerErrors = Collections.synchronizedList(new ArrayList<Throwable>());\n+\n+            LambdaObserver<Integer> o = new LambdaObserver<Integer>(Functions.<Integer>emptyConsumer(),\n+                    new Consumer<Throwable>() {\n+                        @Override\n+                        public void accept(Throwable t) {\n+                            observerErrors.add(t);\n+                        }\n+                    },\n+                    Functions.EMPTY_ACTION,\n+                    Functions.<Disposable>emptyConsumer());\n+\n+            o.dispose();\n+            o.onError(new IOException());\n+            o.onError(new IOException());\n+\n+            assertTrue(observerErrors.isEmpty());\n+            TestHelper.assertUndeliverable(errors, 0, IOException.class);\n+            TestHelper.assertUndeliverable(errors, 1, IOException.class);\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n }",
    "output": "Fix disposed LambdaObserver onError to route to global error handler"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java\n@@ -1948,16 +1948,16 @@ public void run() throws Exception {\n             }\n         };\n     }\n-    \n+\n     private static final class TestTicker extends Ticker {\n-        long tick = 0;\n+        long tick;\n \n         @Override\n         public long read() {\n             return tick;\n         }\n     }\n-    \n+\n     @Test\n     public void testGroupByEvictionCancellationOfSource5933() {\n         PublishProcessor<Integer> source = PublishProcessor.create();\n@@ -2022,11 +2022,11 @@ public void run() throws Exception {\n         source.onNext(1);\n         source.onNext(1);\n         ts.awaitCount(3);\n-        \n+\n         // Advance time far enough to evict the group.\n         // NOTE -- Comment this line out to make the test \"pass\".\n         testTicker.tick = TimeUnit.SECONDS.toNanos(6);\n-        \n+\n         // Send more data in the group (triggering eviction and recreation)\n         source.onNext(1);\n \n@@ -2042,12 +2042,12 @@ public void run() throws Exception {\n         assertTrue(list.contains(\"Source canceled\"));\n         assertEquals(Arrays.asList(\n                 \"Group completed\", // this is here when eviction occurs\n-                \"Outer group by canceled\", \n+                \"Outer group by canceled\",\n                 \"Group canceled\",\n                 \"Source canceled\"  // This is *not* here when eviction occurs\n         ), list);\n     }\n-    \n+\n     @Test\n     public void testCancellationOfUpstreamWhenGroupedFlowableCompletes() {\n         final AtomicBoolean cancelled = new AtomicBoolean();",
    "output": "Remove whitespaces"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableTakeUntil.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableTakeUntil.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableTakeUntil.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableTakeUntil.java\n@@ -13,103 +13,120 @@\n \n package io.reactivex.internal.operators.observable;\n \n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.*;\n \n import io.reactivex.*;\n import io.reactivex.disposables.Disposable;\n-import io.reactivex.internal.disposables.*;\n-import io.reactivex.observers.SerializedObserver;\n+import io.reactivex.internal.disposables.DisposableHelper;\n+import io.reactivex.internal.util.*;\n \n public final class ObservableTakeUntil<T, U> extends AbstractObservableWithUpstream<T, T> {\n+\n     final ObservableSource<? extends U> other;\n+\n     public ObservableTakeUntil(ObservableSource<T> source, ObservableSource<? extends U> other) {\n         super(source);\n         this.other = other;\n     }\n     @Override\n     public void subscribeActual(Observer<? super T> child) {\n-        final SerializedObserver<T> serial = new SerializedObserver<T>(child);\n+        TakeUntilMainObserver<T, U> parent = new TakeUntilMainObserver<T, U>(child);\n+        child.onSubscribe(parent);\n \n-        final ArrayCompositeDisposable frc = new ArrayCompositeDisposable(2);\n+        other.subscribe(parent.otherObserver);\n+        source.subscribe(parent);\n+    }\n \n-        final TakeUntilObserver<T> tus = new TakeUntilObserver<T>(serial, frc);\n+    static final class TakeUntilMainObserver<T, U> extends AtomicInteger\n+    implements Observer<T>, Disposable {\n \n-        child.onSubscribe(frc);\n+        private static final long serialVersionUID = 1418547743690811973L;\n \n-        other.subscribe(new TakeUntil(frc, serial));\n+        final Observer<? super T> downstream;\n \n-        source.subscribe(tus);\n-    }\n+        final AtomicReference<Disposable> upstream;\n \n-    static final class TakeUntilObserver<T> extends AtomicBoolean implements Observer<T> {\n+        final OtherObserver otherObserver;\n \n-        private static final long serialVersionUID = 3451719290311127173L;\n-        final Observer<? super T> actual;\n-        final ArrayCompositeDisposable frc;\n+        final AtomicThrowable error;\n \n-        Disposable s;\n-\n-        TakeUntilObserver(Observer<? super T> actual, ArrayCompositeDisposable frc) {\n-            this.actual = actual;\n-            this.frc = frc;\n+        TakeUntilMainObserver(Observer<? super T> downstream) {\n+            this.downstream = downstream;\n+            this.upstream = new AtomicReference<Disposable>();\n+            this.otherObserver = new OtherObserver();\n+            this.error = new AtomicThrowable();\n         }\n \n         @Override\n-        public void onSubscribe(Disposable s) {\n-            if (DisposableHelper.validate(this.s, s)) {\n-                this.s = s;\n-                frc.setResource(0, s);\n-            }\n+        public void dispose() {\n+            DisposableHelper.dispose(upstream);\n+            DisposableHelper.dispose(otherObserver);\n         }\n \n         @Override\n-        public void onNext(T t) {\n-            actual.onNext(t);\n+        public boolean isDisposed() {\n+            return DisposableHelper.isDisposed(upstream.get());\n         }\n \n         @Override\n-        public void onError(Throwable t) {\n-            frc.dispose();\n-            actual.onError(t);\n+        public void onSubscribe(Disposable d) {\n+            DisposableHelper.setOnce(upstream, d);\n         }\n \n         @Override\n-        public void onComplete() {\n-            frc.dispose();\n-            actual.onComplete();\n+        public void onNext(T t) {\n+            HalfSerializer.onNext(downstream, t, this, error);\n         }\n-    }\n-\n-    final class TakeUntil implements Observer<U> {\n-        private final ArrayCompositeDisposable frc;\n-        private final SerializedObserver<T> serial;\n \n-        TakeUntil(ArrayCompositeDisposable frc, SerializedObserver<T> serial) {\n-            this.frc = frc;\n-            this.serial = serial;\n+        @Override\n+        public void onError(Throwable e) {\n+            DisposableHelper.dispose(otherObserver);\n+            HalfSerializer.onError(downstream, e, this, error);\n         }\n \n         @Override\n-        public void onSubscribe(Disposable s) {\n-            frc.setResource(1, s);\n+        public void onComplete() {\n+            DisposableHelper.dispose(otherObserver);\n+            HalfSerializer.onComplete(downstream, this, error);\n         }\n \n-        @Override\n-        public void onNext(U t) {\n-            frc.dispose();\n-            serial.onComplete();\n+        void otherError(Throwable e) {\n+            DisposableHelper.dispose(upstream);\n+            HalfSerializer.onError(downstream, e, this, error);\n         }\n \n-        @Override\n-        public void onError(Throwable t) {\n-            frc.dispose();\n-            serial.onError(t);\n+        void otherComplete() {\n+            DisposableHelper.dispose(upstream);\n+            HalfSerializer.onComplete(downstream, this, error);\n         }\n \n-        @Override\n-        public void onComplete() {\n-            frc.dispose();\n-            serial.onComplete();\n+        final class OtherObserver extends AtomicReference<Disposable>\n+        implements Observer<U> {\n+\n+            private static final long serialVersionUID = -8693423678067375039L;\n+\n+            @Override\n+            public void onSubscribe(Disposable d) {\n+                DisposableHelper.setOnce(this, d);\n+            }\n+\n+            @Override\n+            public void onNext(U t) {\n+                DisposableHelper.dispose(this);\n+                otherComplete();\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                otherError(e);\n+            }\n+\n+            @Override\n+            public void onComplete() {\n+                otherComplete();\n+            }\n+\n         }\n     }\n+\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeUntilTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeUntilTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeUntilTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeUntilTest.java\n@@ -70,7 +70,7 @@ public void testTakeUntilSourceCompleted() {\n \n         verify(result, times(1)).onNext(\"one\");\n         verify(result, times(1)).onNext(\"two\");\n-        verify(sSource, times(1)).dispose();\n+        verify(sSource, never()).dispose(); // no longer disposing itself on terminal events\n         verify(sOther, times(1)).dispose();\n \n     }\n@@ -95,7 +95,7 @@ public void testTakeUntilSourceError() {\n         verify(result, times(1)).onNext(\"two\");\n         verify(result, times(0)).onNext(\"three\");\n         verify(result, times(1)).onError(error);\n-        verify(sSource, times(1)).dispose();\n+        verify(sSource, never()).dispose(); // no longer disposing itself on terminal events\n         verify(sOther, times(1)).dispose();\n \n     }\n@@ -122,7 +122,7 @@ public void testTakeUntilOtherError() {\n         verify(result, times(1)).onError(error);\n         verify(result, times(0)).onComplete();\n         verify(sSource, times(1)).dispose();\n-        verify(sOther, times(1)).dispose();\n+        verify(sOther, never()).dispose(); // no longer disposing itself on termination\n \n     }\n \n@@ -149,7 +149,7 @@ public void testTakeUntilOtherCompleted() {\n         verify(result, times(0)).onNext(\"three\");\n         verify(result, times(1)).onComplete();\n         verify(sSource, times(1)).dispose();\n-        verify(sOther, times(1)).dispose(); // unsubscribed since SafeSubscriber unsubscribes after onComplete\n+        verify(sOther, never()).dispose(); // no longer disposing itself on terminal events\n \n     }\n ",
    "output": "Improve Observable.takeUntil"
  },
  {
    "input": "diff --git a/src/jmh/java/io/reactivex/TakeUntilPerf.java b/src/jmh/java/io/reactivex/TakeUntilPerf.java\n--- a/src/jmh/java/io/reactivex/TakeUntilPerf.java\n+++ b/src/jmh/java/io/reactivex/TakeUntilPerf.java\n@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex;\n+\n+import java.util.concurrent.*;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import io.reactivex.functions.*;\n+import io.reactivex.internal.functions.Functions;\n+import io.reactivex.schedulers.Schedulers;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@Fork(value = 1)\n+@State(Scope.Thread)\n+@AuxCounters\n+public class TakeUntilPerf implements Consumer<Integer> {\n+\n+    public volatile int items;\n+\n+    static final int count = 10000;\n+\n+    Flowable<Integer> flowable;\n+\n+    Observable<Integer> observable;\n+\n+    @Override\n+    public void accept(Integer t) throws Exception {\n+        items++;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+\n+        flowable = Flowable.range(1, 1000 * 1000).takeUntil(Flowable.fromCallable(new Callable<Object>() {\n+            @Override\n+            public Object call() throws Exception {\n+                int c = count;\n+                while (items < c) { }\n+                return 1;\n+            }\n+        }).subscribeOn(Schedulers.single()));\n+\n+        observable = Observable.range(1, 1000 * 1000).takeUntil(Observable.fromCallable(new Callable<Object>() {\n+            @Override\n+            public Object call() throws Exception {\n+                int c = count;\n+                while (items < c) { }\n+                return 1;\n+            }\n+        }).subscribeOn(Schedulers.single()));\n+    }\n+\n+    @Benchmark\n+    public void flowable() {\n+        final CountDownLatch cdl = new CountDownLatch(1);\n+\n+        flowable.subscribe(this, Functions.emptyConsumer(), new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                cdl.countDown();\n+            }\n+        });\n+\n+        while (cdl.getCount() != 0) { }\n+    }\n+\n+    @Benchmark\n+    public void observable() {\n+        final CountDownLatch cdl = new CountDownLatch(1);\n+\n+        observable.subscribe(this, Functions.emptyConsumer(), new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                cdl.countDown();\n+            }\n+        });\n+\n+        while (cdl.getCount() != 0) { }\n+    }\n+}",
    "output": "Upgrade to Gradle 4.3.1, add TakeUntilPerf"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/processors/MulticastProcessor.java b/src/main/java/io/reactivex/processors/MulticastProcessor.java\n--- a/src/main/java/io/reactivex/processors/MulticastProcessor.java\n+++ b/src/main/java/io/reactivex/processors/MulticastProcessor.java\n@@ -102,14 +102,14 @@\n  * <p>\n  * Example:\n  * <pre><code>\n-    MulticastProcessor&lt;Integer> mp = Flowable.range(1, 10)\n+    MulticastProcessor&lt;Integer&gt; mp = Flowable.range(1, 10)\n     .subscribeWith(MulticastProcessor.create());\n \n     mp.test().assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n \n     // --------------------\n \n-    MulticastProcessor&lt;Integer> mp2 = MulticastProcessor.create(4);\n+    MulticastProcessor&lt;Integer&gt; mp2 = MulticastProcessor.create(4);\n     mp2.start();\n \n     assertTrue(mp2.offer(1));",
    "output": "Fix MulticastProcessor JavaDoc warnings"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java\n--- a/src/main/java/io/reactivex/Single.java\n+++ b/src/main/java/io/reactivex/Single.java\n@@ -2460,7 +2460,8 @@ public final <R> Maybe<R> flatMapMaybe(final Function<? super T, ? extends Maybe\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n     public final <R> Flowable<R> flatMapPublisher(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n-        return toFlowable().flatMap(mapper);\n+        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n+        return RxJavaPlugins.onAssembly(new SingleFlatMapPublisher<T, R>(this, mapper));\n     }\n \n     /**\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/single/SingleFlatMapPublisher.java b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMapPublisher.java\n--- a/src/main/java/io/reactivex/internal/operators/single/SingleFlatMapPublisher.java\n+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMapPublisher.java\n@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.single;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.FlowableSubscriber;\n+import io.reactivex.Scheduler;\n+import io.reactivex.SingleObserver;\n+import io.reactivex.SingleSource;\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.exceptions.Exceptions;\n+import io.reactivex.functions.Function;\n+import io.reactivex.internal.functions.ObjectHelper;\n+import io.reactivex.internal.subscriptions.SubscriptionHelper;\n+\n+/**\n+ * A Flowable that emits items based on applying a specified function to the item emitted by the\n+ * source Single, where that function returns a Publisher.\n+ * <p>\n+ * <img width=\"640\" height=\"305\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapPublisher.png\" alt=\"\">\n+ * <dl>\n+ *  <dt><b>Backpressure:</b></dt>\n+ *  <dd>The returned {@code Flowable} honors the backpressure of the downstream consumer\n+ *  and the {@code Publisher} returned by the mapper function is expected to honor it as well.</dd>\n+ * <dt><b>Scheduler:</b></dt>\n+ * <dd>{@code flatMapPublisher} does not operate by default on a particular {@link Scheduler}.</dd>\n+ * </dl>\n+ * \n+ * @param <T> the source value type\n+ * @param <R> the result value type\n+ * \n+ * @see <a href=\"http://reactivex.io/documentation/operators/flatmap.html\">ReactiveX operators documentation: FlatMap</a>\n+ * @since 2.1.15\n+ */\n+public final class SingleFlatMapPublisher<T, R> extends Flowable<R> {\n+\n+    final SingleSource<T> source;\n+    final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+    public SingleFlatMapPublisher(SingleSource<T> source,\n+            Function<? super T, ? extends Publisher<? extends R>> mapper) {\n+        this.source = source;\n+        this.mapper = mapper;\n+    }\n+\n+    @Override\n+    protected void subscribeActual(Subscriber<? super R> actual) {\n+        source.subscribe(new SingleFlatMapPublisherObserver<T, R>(actual, mapper));\n+    }\n+\n+    static final class SingleFlatMapPublisherObserver<S, T> extends AtomicLong\n+            implements SingleObserver<S>, FlowableSubscriber<T>, Subscription {\n+\n+        private static final long serialVersionUID = 7759721921468635667L;\n+\n+        final Subscriber<? super T> actual;\n+        final Function<? super S, ? extends Publisher<? extends T>> mapper;\n+        final AtomicReference<Subscription> parent;\n+        Disposable disposable;\n+\n+        SingleFlatMapPublisherObserver(Subscriber<? super T> actual,\n+                Function<? super S, ? extends Publisher<? extends T>> mapper) {\n+            this.actual = actual;\n+            this.mapper = mapper;\n+            this.parent = new AtomicReference<Subscription>();\n+        }\n+\n+        @Override\n+        public void onSubscribe(Disposable d) {\n+            this.disposable = d;\n+            actual.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onSuccess(S value) {\n+            Publisher<? extends T> f;\n+            try {\n+                f = ObjectHelper.requireNonNull(mapper.apply(value), \"the mapper returned a null Publisher\");\n+            } catch (Throwable e) {\n+                Exceptions.throwIfFatal(e);\n+                actual.onError(e);\n+                return;\n+            }\n+            f.subscribe(this);\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription s) {\n+            SubscriptionHelper.deferredSetOnce(parent, this, s);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            actual.onNext(t);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        public void onError(Throwable e) {\n+            actual.onError(e);\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            SubscriptionHelper.deferredRequest(parent, this, n);\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            disposable.dispose();\n+            SubscriptionHelper.cancel(parent);\n+        }\n+    }\n+\n+}\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/single/SingleFlatMapTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleFlatMapTest.java\n--- a/src/test/java/io/reactivex/internal/operators/single/SingleFlatMapTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/single/SingleFlatMapTest.java\n@@ -15,12 +15,15 @@\n \n import static org.junit.Assert.*;\n \n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import org.junit.Test;\n import org.reactivestreams.Publisher;\n \n import io.reactivex.*;\n import io.reactivex.exceptions.TestException;\n import io.reactivex.functions.*;\n+import io.reactivex.subscribers.TestSubscriber;\n \n public class SingleFlatMapTest {\n \n@@ -126,6 +129,92 @@ public Publisher<Integer> apply(Integer v) throws Exception {\n         .test()\n         .assertResult(1, 2, 3, 4, 5);\n     }\n+    \n+    @Test(expected = NullPointerException.class)\n+    public void flatMapPublisherMapperNull() {\n+        Single.just(1).flatMapPublisher(null);\n+    }\n+    \n+    @Test\n+    public void flatMapPublisherMapperThrows() {\n+        final TestException ex = new TestException();\n+        Single.just(1) \n+        .flatMapPublisher(new Function<Integer, Publisher<Integer>>() {\n+            @Override\n+            public Publisher<Integer> apply(Integer v) throws Exception {\n+                throw ex;\n+            }\n+        })\n+        .test()\n+        .assertNoValues()\n+        .assertError(ex);\n+    }\n+    \n+    @Test\n+    public void flatMapPublisherSingleError() {\n+        final TestException ex = new TestException();\n+        Single.<Integer>error(ex) \n+        .flatMapPublisher(new Function<Integer, Publisher<Integer>>() {\n+            @Override\n+            public Publisher<Integer> apply(Integer v) throws Exception {\n+                return Flowable.just(1);\n+            }\n+        })\n+        .test()\n+        .assertNoValues()\n+        .assertError(ex);\n+    }\n+    \n+    @Test\n+    public void flatMapPublisherCancelDuringSingle() {\n+        final AtomicBoolean disposed = new AtomicBoolean();\n+        TestSubscriber<Integer> ts = Single.<Integer>never()\n+        .doOnDispose(new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                disposed.set(true);\n+            }\n+        })\n+        .flatMapPublisher(new Function<Integer, Publisher<Integer>>() {\n+            @Override\n+            public Publisher<Integer> apply(Integer v) throws Exception {\n+                return Flowable.range(v, 5);\n+            }\n+        })\n+        .test()\n+        .assertNoValues() \n+        .assertNotTerminated();\n+        assertFalse(disposed.get());\n+        ts.cancel();\n+        assertTrue(disposed.get());\n+        ts.assertNotTerminated();\n+    }\n+    \n+    @Test\n+    public void flatMapPublisherCancelDuringFlowable() {\n+        final AtomicBoolean disposed = new AtomicBoolean();\n+        TestSubscriber<Integer> ts = \n+        Single.just(1)\n+        .flatMapPublisher(new Function<Integer, Publisher<Integer>>() {\n+            @Override\n+            public Publisher<Integer> apply(Integer v) throws Exception {\n+                return Flowable.<Integer>never()\n+                        .doOnCancel(new Action() {\n+                            @Override\n+                            public void run() throws Exception {\n+                                disposed.set(true);\n+                            }\n+                        });\n+            }\n+        })\n+        .test()\n+        .assertNoValues() \n+        .assertNotTerminated();\n+        assertFalse(disposed.get());\n+        ts.cancel();\n+        assertTrue(disposed.get());\n+        ts.assertNotTerminated();\n+    }\n \n     @Test(expected = NullPointerException.class)\n     public void flatMapNull() {",
    "output": "Add full implementation for Single.flatMapPublisher so doesn't batch requests"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java\n--- a/src/main/java/io/reactivex/Observable.java\n+++ b/src/main/java/io/reactivex/Observable.java\n@@ -1455,8 +1455,6 @@ public static <T> Observable<T> concatEager(ObservableSource<? extends Observabl\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n     public static <T> Observable<T> concatEager(ObservableSource<? extends ObservableSource<? extends T>> sources, int maxConcurrency, int prefetch) {\n-        ObjectHelper.requireNonNull(maxConcurrency, \"maxConcurrency is null\");\n-        ObjectHelper.requireNonNull(prefetch, \"prefetch is null\");\n         return wrap(sources).concatMapEager((Function)Functions.identity(), maxConcurrency, prefetch);\n     }\n \n@@ -1507,8 +1505,6 @@ public static <T> Observable<T> concatEager(Iterable<? extends ObservableSource<\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n     public static <T> Observable<T> concatEager(Iterable<? extends ObservableSource<? extends T>> sources, int maxConcurrency, int prefetch) {\n-        ObjectHelper.requireNonNull(maxConcurrency, \"maxConcurrency is null\");\n-        ObjectHelper.requireNonNull(prefetch, \"prefetch is null\");\n         return fromIterable(sources).concatMapEagerDelayError((Function)Functions.identity(), maxConcurrency, prefetch, false);\n     }\n \n\ndiff --git a/src/main/java/io/reactivex/internal/functions/ObjectHelper.java b/src/main/java/io/reactivex/internal/functions/ObjectHelper.java\n--- a/src/main/java/io/reactivex/internal/functions/ObjectHelper.java\n+++ b/src/main/java/io/reactivex/internal/functions/ObjectHelper.java\n@@ -128,4 +128,17 @@ public boolean test(Object o1, Object o2) {\n             return ObjectHelper.equals(o1, o2);\n         }\n     }\n+\n+    /**\n+     * Trap null-check attempts on primitives.\n+     * @param value the value to check\n+     * @param message the message to print\n+     * @return the value\n+     * @deprecated this method should not be used as there is no need\n+     * to check primitives for nullness.\n+     */\n+    @Deprecated\n+    public static long requireNonNull(long value, String message) {\n+        throw new InternalError(\"Null check on a primitive: \" + message);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java b/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java\n--- a/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java\n+++ b/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java\n@@ -65,4 +65,10 @@ public void compareLong() {\n         assertEquals(0, ObjectHelper.compare(0L, 0L));\n         assertEquals(1, ObjectHelper.compare(2L, 0L));\n     }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test(expected = InternalError.class)\n+    public void requireNonNullPrimitive() {\n+        ObjectHelper.requireNonNull(0, \"value\");\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCreateTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCreateTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCreateTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCreateTest.java\n@@ -934,6 +934,7 @@ public void subscribe(FlowableEmitter<Object> e) throws Exception {\n         }\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n     @Test\n     public void emittersHasToString() {\n         Map<BackpressureStrategy, Class<? extends FlowableEmitter>> emitterMap =",
    "output": "Fix & prevent null checks on primitives"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java\n@@ -18,12 +18,12 @@\n import io.reactivex.*;\n import io.reactivex.annotations.Experimental;\n import io.reactivex.disposables.Disposable;\n-import io.reactivex.exceptions.*;\n+import io.reactivex.exceptions.Exceptions;\n import io.reactivex.functions.Function;\n import io.reactivex.internal.disposables.DisposableHelper;\n import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.fuseable.SimplePlainQueue;\n-import io.reactivex.internal.queue.SpscArrayQueue;\n+import io.reactivex.internal.queue.SpscLinkedArrayQueue;\n import io.reactivex.internal.util.*;\n import io.reactivex.plugins.RxJavaPlugins;\n \n@@ -107,7 +107,7 @@ static final class ConcatMapSingleMainObserver<T, R>\n             this.errorMode = errorMode;\n             this.errors = new AtomicThrowable();\n             this.inner = new ConcatMapSingleObserver<R>(this);\n-            this.queue = new SpscArrayQueue<T>(prefetch);\n+            this.queue = new SpscLinkedArrayQueue<T>(prefetch);\n         }\n \n         @Override\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java\n@@ -399,4 +399,21 @@ public void cancelNoConcurrentClean() {\n \n         assertTrue(operator.queue.isEmpty());\n     }\n+\n+    @Test\n+    public void checkUnboundedInnerQueue() {\n+        MaybeSubject<Integer> ms = MaybeSubject.create();\n+        \n+        @SuppressWarnings(\"unchecked\")\n+        TestObserver<Integer> to = Observable\n+                .fromArray(ms, Maybe.just(2), Maybe.just(3), Maybe.just(4))\n+                .concatMapMaybe(Functions.<Maybe<Integer>>identity(), 2)\n+                .test();\n+\n+        to.assertEmpty();\n+\n+        ms.onSuccess(1);\n+\n+        to.assertResult(1, 2, 3, 4);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java\n--- a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java\n@@ -336,4 +336,21 @@ public void cancelNoConcurrentClean() {\n \n         assertTrue(operator.queue.isEmpty());\n     }\n+\n+    @Test\n+    public void checkUnboundedInnerQueue() {\n+        SingleSubject<Integer> ss = SingleSubject.create();\n+        \n+        @SuppressWarnings(\"unchecked\")\n+        TestObserver<Integer> to = Observable\n+                .fromArray(ss, Single.just(2), Single.just(3), Single.just(4))\n+                .concatMapSingle(Functions.<Single<Integer>>identity(), 2)\n+                .test();\n+\n+        to.assertEmpty();\n+\n+        ss.onSuccess(1);\n+\n+        to.assertResult(1, 2, 3, 4);\n+    }\n }",
    "output": "Fix Observable.concatMapSingle dropping upstream items"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java b/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java\n--- a/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java\n+++ b/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java\n@@ -91,7 +91,7 @@ public void forEachWhile(NonThrowingPredicate<? super T> consumer) {\n                     break;\n                 }\n                 if (consumer.test((T)o)) {\n-                    break;\n+                    return;\n                 }\n             }\n             a = (Object[])a[c];\n\ndiff --git a/src/test/java/io/reactivex/internal/util/MiscUtilTest.java b/src/test/java/io/reactivex/internal/util/MiscUtilTest.java\n--- a/src/test/java/io/reactivex/internal/util/MiscUtilTest.java\n+++ b/src/test/java/io/reactivex/internal/util/MiscUtilTest.java\n@@ -75,6 +75,27 @@ public void appendOnlyLinkedArrayListForEachWhile() throws Exception {\n \n         final List<Integer> out = new ArrayList<Integer>();\n \n+        list.forEachWhile(new NonThrowingPredicate<Integer>() {\n+            @Override\n+            public boolean test(Integer t2) {\n+                out.add(t2);\n+                return t2 == 2;\n+            }\n+        });\n+\n+        assertEquals(Arrays.asList(1, 2), out);\n+    }\n+\n+    @Test\n+    public void appendOnlyLinkedArrayListForEachWhileBi() throws Exception {\n+        AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(2);\n+\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+\n+        final List<Integer> out = new ArrayList<Integer>();\n+\n         list.forEachWhile(2, new BiPredicate<Integer, Integer>() {\n             @Override\n             public boolean test(Integer t1, Integer t2) throws Exception {\n@@ -86,7 +107,6 @@ public boolean test(Integer t1, Integer t2) throws Exception {\n         assertEquals(Arrays.asList(1, 2), out);\n     }\n \n-\n     @Test\n     public void appendOnlyLinkedArrayListForEachWhilePreGrow() throws Exception {\n         AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(12);",
    "output": "Fix conditional iteration breaking"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/processors/PublishProcessor.java b/src/main/java/io/reactivex/processors/PublishProcessor.java\n--- a/src/main/java/io/reactivex/processors/PublishProcessor.java\n+++ b/src/main/java/io/reactivex/processors/PublishProcessor.java\n@@ -189,9 +189,6 @@ public void onSubscribe(Subscription s) {\n     @Override\n     public void onNext(T t) {\n         ObjectHelper.requireNonNull(t, \"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\");\n-        if (subscribers.get() == TERMINATED) {\n-            return;\n-        }\n         for (PublishSubscription<T> s : subscribers.get()) {\n             s.onNext(t);\n         }\n\ndiff --git a/src/main/java/io/reactivex/subjects/PublishSubject.java b/src/main/java/io/reactivex/subjects/PublishSubject.java\n--- a/src/main/java/io/reactivex/subjects/PublishSubject.java\n+++ b/src/main/java/io/reactivex/subjects/PublishSubject.java\n@@ -225,10 +225,6 @@ public void onSubscribe(Disposable s) {\n     @Override\n     public void onNext(T t) {\n         ObjectHelper.requireNonNull(t, \"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\");\n-\n-        if (subscribers.get() == TERMINATED) {\n-            return;\n-        }\n         for (PublishDisposable<T> s : subscribers.get()) {\n             s.onNext(t);\n         }",
    "output": "Remove TERMINATED check in onNext * Removed pointless code. * Removed unnecessary TERMINATED check"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java\n--- a/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java\n+++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java\n@@ -170,7 +170,7 @@ public void cancel() {\n             cancelled = true;\n             upstream.cancel();\n             inner.dispose();\n-            if (getAndIncrement() != 0) {\n+            if (getAndIncrement() == 0) {\n                 queue.clear();\n                 item = null;\n             }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java\n@@ -170,7 +170,7 @@ public void cancel() {\n             cancelled = true;\n             upstream.cancel();\n             inner.dispose();\n-            if (getAndIncrement() != 0) {\n+            if (getAndIncrement() == 0) {\n                 queue.clear();\n                 item = null;\n             }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java\n--- a/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java\n+++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java\n@@ -148,7 +148,7 @@ public void dispose() {\n             cancelled = true;\n             upstream.dispose();\n             inner.dispose();\n-            if (getAndIncrement() != 0) {\n+            if (getAndIncrement() == 0) {\n                 queue.clear();\n                 item = null;\n             }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java\n@@ -148,7 +148,7 @@ public void dispose() {\n             cancelled = true;\n             upstream.dispose();\n             inner.dispose();\n-            if (getAndIncrement() != 0) {\n+            if (getAndIncrement() == 0) {\n                 queue.clear();\n                 item = null;\n             }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybeTest.java b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybeTest.java\n@@ -27,7 +27,9 @@\n import io.reactivex.exceptions.*;\n import io.reactivex.functions.*;\n import io.reactivex.internal.functions.Functions;\n+import io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe.ConcatMapMaybeSubscriber;\n import io.reactivex.internal.subscriptions.BooleanSubscription;\n+import io.reactivex.internal.util.ErrorMode;\n import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.processors.PublishProcessor;\n import io.reactivex.schedulers.Schedulers;\n@@ -368,4 +370,28 @@ public MaybeSource<? extends Object> apply(Integer v)\n \n         assertFalse(pp.hasSubscribers());\n     }\n+\n+    @Test(timeout = 10000)\n+    public void cancelNoConcurrentClean() {\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        ConcatMapMaybeSubscriber<Integer, Integer> operator =\n+                new ConcatMapMaybeSubscriber<Integer, Integer>(\n+                        ts, Functions.justFunction(Maybe.<Integer>never()), 16, ErrorMode.IMMEDIATE);\n+\n+        operator.onSubscribe(new BooleanSubscription());\n+\n+        operator.queue.offer(1);\n+\n+        operator.getAndIncrement();\n+\n+        ts.cancel();\n+\n+        assertFalse(operator.queue.isEmpty());\n+\n+        operator.addAndGet(-2);\n+\n+        operator.cancel();\n+\n+        assertTrue(operator.queue.isEmpty());\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingleTest.java b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingleTest.java\n--- a/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingleTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingleTest.java\n@@ -26,7 +26,9 @@\n import io.reactivex.exceptions.*;\n import io.reactivex.functions.*;\n import io.reactivex.internal.functions.Functions;\n+import io.reactivex.internal.operators.mixed.FlowableConcatMapSingle.ConcatMapSingleSubscriber;\n import io.reactivex.internal.subscriptions.BooleanSubscription;\n+import io.reactivex.internal.util.ErrorMode;\n import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.processors.PublishProcessor;\n import io.reactivex.subjects.SingleSubject;\n@@ -283,4 +285,28 @@ public SingleSource<? extends Object> apply(Integer v)\n \n         assertFalse(pp.hasSubscribers());\n     }\n+\n+    @Test(timeout = 10000)\n+    public void cancelNoConcurrentClean() {\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        ConcatMapSingleSubscriber<Integer, Integer> operator =\n+                new ConcatMapSingleSubscriber<Integer, Integer>(\n+                        ts, Functions.justFunction(Single.<Integer>never()), 16, ErrorMode.IMMEDIATE);\n+\n+        operator.onSubscribe(new BooleanSubscription());\n+\n+        operator.queue.offer(1);\n+\n+        operator.getAndIncrement();\n+\n+        ts.cancel();\n+\n+        assertFalse(operator.queue.isEmpty());\n+\n+        operator.addAndGet(-2);\n+\n+        operator.cancel();\n+\n+        assertTrue(operator.queue.isEmpty());\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java\n@@ -26,6 +26,8 @@\n import io.reactivex.exceptions.*;\n import io.reactivex.functions.*;\n import io.reactivex.internal.functions.Functions;\n+import io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe.ConcatMapMaybeMainObserver;\n+import io.reactivex.internal.util.ErrorMode;\n import io.reactivex.observers.TestObserver;\n import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.schedulers.Schedulers;\n@@ -373,4 +375,28 @@ public void scalarEmptySource() {\n \n         assertFalse(ms.hasObservers());\n     }\n+\n+    @Test(timeout = 10000)\n+    public void cancelNoConcurrentClean() {\n+        TestObserver<Integer> to = new TestObserver<Integer>();\n+        ConcatMapMaybeMainObserver<Integer, Integer> operator =\n+                new ConcatMapMaybeMainObserver<Integer, Integer>(\n+                        to, Functions.justFunction(Maybe.<Integer>never()), 16, ErrorMode.IMMEDIATE);\n+\n+        operator.onSubscribe(Disposables.empty());\n+\n+        operator.queue.offer(1);\n+\n+        operator.getAndIncrement();\n+\n+        to.dispose();\n+\n+        assertFalse(operator.queue.isEmpty());\n+\n+        operator.addAndGet(-2);\n+\n+        operator.dispose();\n+\n+        assertTrue(operator.queue.isEmpty());\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java\n--- a/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingleTest.java\n@@ -25,6 +25,8 @@\n import io.reactivex.exceptions.*;\n import io.reactivex.functions.*;\n import io.reactivex.internal.functions.Functions;\n+import io.reactivex.internal.operators.mixed.ObservableConcatMapSingle.ConcatMapSingleMainObserver;\n+import io.reactivex.internal.util.ErrorMode;\n import io.reactivex.observers.TestObserver;\n import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.subjects.*;\n@@ -310,4 +312,28 @@ public void scalarEmptySource() {\n \n         assertFalse(ss.hasObservers());\n     }\n+\n+    @Test(timeout = 10000)\n+    public void cancelNoConcurrentClean() {\n+        TestObserver<Integer> to = new TestObserver<Integer>();\n+        ConcatMapSingleMainObserver<Integer, Integer> operator =\n+                new ConcatMapSingleMainObserver<Integer, Integer>(\n+                        to, Functions.justFunction(Single.<Integer>never()), 16, ErrorMode.IMMEDIATE);\n+\n+        operator.onSubscribe(Disposables.empty());\n+\n+        operator.queue.offer(1);\n+\n+        operator.getAndIncrement();\n+\n+        to.cancel();\n+\n+        assertFalse(operator.queue.isEmpty());\n+\n+        operator.addAndGet(-2);\n+\n+        operator.dispose();\n+\n+        assertTrue(operator.queue.isEmpty());\n+    }\n }",
    "output": "Fix concatMapSingle & concatMapMaybe dispose-cleanup crash"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/processors/AsyncProcessor.java b/src/main/java/io/reactivex/processors/AsyncProcessor.java\n--- a/src/main/java/io/reactivex/processors/AsyncProcessor.java\n+++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java\n@@ -138,6 +138,7 @@ public boolean hasComplete() {\n     }\n \n     @Override\n+    @Nullable\n     public Throwable getThrowable() {\n         return subscribers.get() == TERMINATED ? error : null;\n     }\n@@ -244,6 +245,7 @@ public boolean hasValue() {\n      * <p>The method is thread-safe.\n      * @return a single value the Subject currently has or null if no such value exists\n      */\n+    @Nullable\n     public T getValue() {\n         return subscribers.get() == TERMINATED ? value : null;\n     }\n\ndiff --git a/src/main/java/io/reactivex/processors/BehaviorProcessor.java b/src/main/java/io/reactivex/processors/BehaviorProcessor.java\n--- a/src/main/java/io/reactivex/processors/BehaviorProcessor.java\n+++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java\n@@ -348,6 +348,7 @@ public boolean hasSubscribers() {\n     }\n \n     @Override\n+    @Nullable\n     public Throwable getThrowable() {\n         Object o = value.get();\n         if (NotificationLite.isError(o)) {\n@@ -361,6 +362,7 @@ public Throwable getThrowable() {\n      * <p>The method is thread-safe.\n      * @return a single value the BehaviorProcessor currently has or null if no such value exists\n      */\n+    @Nullable\n     public T getValue() {\n         Object o = value.get();\n         if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {\n\ndiff --git a/src/main/java/io/reactivex/processors/PublishProcessor.java b/src/main/java/io/reactivex/processors/PublishProcessor.java\n--- a/src/main/java/io/reactivex/processors/PublishProcessor.java\n+++ b/src/main/java/io/reactivex/processors/PublishProcessor.java\n@@ -261,6 +261,7 @@ public boolean hasSubscribers() {\n     }\n \n     @Override\n+    @Nullable\n     public Throwable getThrowable() {\n         if (subscribers.get() == TERMINATED) {\n             return error;\n\ndiff --git a/src/main/java/io/reactivex/processors/ReplayProcessor.java b/src/main/java/io/reactivex/processors/ReplayProcessor.java\n--- a/src/main/java/io/reactivex/processors/ReplayProcessor.java\n+++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java\n@@ -354,6 +354,7 @@ public boolean hasSubscribers() {\n     }\n \n     @Override\n+    @Nullable\n     public Throwable getThrowable() {\n         ReplayBuffer<T> b = buffer;\n         if (b.isDone()) {\n@@ -510,6 +511,7 @@ interface ReplayBuffer<T> {\n \n         int size();\n \n+        @Nullable\n         T getValue();\n \n         T[] getValues(T[] array);\n@@ -598,6 +600,7 @@ public void trimHead() {\n         }\n \n         @Override\n+        @Nullable\n         public T getValue() {\n             int s = size;\n             if (s == 0) {\n@@ -1091,6 +1094,7 @@ public void complete() {\n         }\n \n         @Override\n+        @Nullable\n         public T getValue() {\n             TimedNode<T> h = head;\n \n\ndiff --git a/src/main/java/io/reactivex/processors/SerializedProcessor.java b/src/main/java/io/reactivex/processors/SerializedProcessor.java\n--- a/src/main/java/io/reactivex/processors/SerializedProcessor.java\n+++ b/src/main/java/io/reactivex/processors/SerializedProcessor.java\n@@ -13,6 +13,7 @@\n \n package io.reactivex.processors;\n \n+import io.reactivex.annotations.Nullable;\n import org.reactivestreams.*;\n \n import io.reactivex.internal.util.*;\n@@ -187,6 +188,7 @@ public boolean hasThrowable() {\n     }\n \n     @Override\n+    @Nullable\n     public Throwable getThrowable() {\n         return actual.getThrowable();\n     }\n\ndiff --git a/src/main/java/io/reactivex/processors/UnicastProcessor.java b/src/main/java/io/reactivex/processors/UnicastProcessor.java\n--- a/src/main/java/io/reactivex/processors/UnicastProcessor.java\n+++ b/src/main/java/io/reactivex/processors/UnicastProcessor.java\n@@ -457,6 +457,7 @@ public boolean hasSubscribers() {\n     }\n \n     @Override\n+    @Nullable\n     public Throwable getThrowable() {\n         if (done) {\n             return error;",
    "output": "Add @Nullable annotations to Processors"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/schedulers/TestScheduler.java b/src/main/java/io/reactivex/schedulers/TestScheduler.java\n--- a/src/main/java/io/reactivex/schedulers/TestScheduler.java\n+++ b/src/main/java/io/reactivex/schedulers/TestScheduler.java\n@@ -35,6 +35,25 @@ public final class TestScheduler extends Scheduler {\n     // Storing time in nanoseconds internally.\n     volatile long time;\n \n+    /**\n+     * Creates a new TestScheduler with initial virtual time of zero.\n+     */\n+    public TestScheduler() {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Creates a new TestScheduler with the specified initial virtual time.\n+     *\n+     * @param delayTime\n+     *          the point in time to move the Scheduler's clock to\n+     * @param unit\n+     *          the units of time that {@code delayTime} is expressed in\n+     */\n+    public TestScheduler(long delayTime, TimeUnit unit) {\n+        time = unit.toNanos(delayTime);\n+    }\n+\n     static final class TimedRunnable implements Comparable<TimedRunnable> {\n \n         final long time;\n\ndiff --git a/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java b/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java\n--- a/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java\n+++ b/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java\n@@ -253,5 +253,10 @@ public void workerDisposed() {\n         assertTrue(w.isDisposed());\n     }\n \n-\n+    @Test\n+    public void constructorTimeSetsTime() {\n+        TestScheduler ts = new TestScheduler(5, TimeUnit.SECONDS);\n+        assertEquals(5, ts.now(TimeUnit.SECONDS));\n+        assertEquals(5000, ts.now(TimeUnit.MILLISECONDS));\n+    }\n }",
    "output": "Add public constructor for TestScheduler that takes the time.\n\n* Add public constructor for TestScheduler that takes the time.\r\n\r\n* Wording"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingle.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingle.java\n@@ -13,6 +13,8 @@\n \n package io.reactivex.internal.operators.flowable;\n \n+import java.util.NoSuchElementException;\n+\n import org.reactivestreams.*;\n \n import io.reactivex.*;\n@@ -23,14 +25,17 @@ public final class FlowableSingle<T> extends AbstractFlowableWithUpstream<T, T>\n \n     final T defaultValue;\n \n-    public FlowableSingle(Flowable<T> source, T defaultValue) {\n+    final boolean failOnEmpty;\n+\n+    public FlowableSingle(Flowable<T> source, T defaultValue, boolean failOnEmpty) {\n         super(source);\n         this.defaultValue = defaultValue;\n+        this.failOnEmpty = failOnEmpty;\n     }\n \n     @Override\n     protected void subscribeActual(Subscriber<? super T> s) {\n-        source.subscribe(new SingleElementSubscriber<T>(s, defaultValue));\n+        source.subscribe(new SingleElementSubscriber<T>(s, defaultValue, failOnEmpty));\n     }\n \n     static final class SingleElementSubscriber<T> extends DeferredScalarSubscription<T>\n@@ -40,13 +45,16 @@ static final class SingleElementSubscriber<T> extends DeferredScalarSubscription\n \n         final T defaultValue;\n \n+        final boolean failOnEmpty;\n+\n         Subscription s;\n \n         boolean done;\n \n-        SingleElementSubscriber(Subscriber<? super T> actual, T defaultValue) {\n+        SingleElementSubscriber(Subscriber<? super T> actual, T defaultValue, boolean failOnEmpty) {\n             super(actual);\n             this.defaultValue = defaultValue;\n+            this.failOnEmpty = failOnEmpty;\n         }\n \n         @Override\n@@ -94,7 +102,11 @@ public void onComplete() {\n                 v = defaultValue;\n             }\n             if (v == null) {\n-                actual.onComplete();\n+                if (failOnEmpty) {\n+                    actual.onError(new NoSuchElementException());\n+                } else {\n+                    actual.onComplete();\n+                }\n             } else {\n                 complete(v);\n             }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleMaybe.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleMaybe.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleMaybe.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleMaybe.java\n@@ -36,7 +36,7 @@ protected void subscribeActual(MaybeObserver<? super T> s) {\n \n     @Override\n     public Flowable<T> fuseToFlowable() {\n-        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(source, null));\n+        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(source, null, false));\n     }\n \n     static final class SingleElementSubscriber<T>\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleSingle.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleSingle.java\n@@ -41,7 +41,7 @@ protected void subscribeActual(SingleObserver<? super T> s) {\n \n     @Override\n     public Flowable<T> fuseToFlowable() {\n-        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(source, defaultValue));\n+        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(source, defaultValue, true));\n     }\n \n     static final class SingleElementSubscriber<T>\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java\n@@ -796,4 +796,13 @@ public void cancelAsFlowable() {\n \n         assertFalse(pp.hasSubscribers());\n     }\n+\n+    @Test\n+    public void singleOrError() {\n+        Flowable.empty()\n+        .singleOrError()\n+        .toFlowable()\n+        .test()\n+        .assertFailure(NoSuchElementException.class);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSingleTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSingleTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSingleTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSingleTest.java\n@@ -556,4 +556,13 @@ public MaybeSource<Object> apply(Observable<Object> o) throws Exception {\n             }\n         });\n     }\n+\n+    @Test\n+    public void singleOrError() {\n+        Observable.empty()\n+        .singleOrError()\n+        .toObservable()\n+        .test()\n+        .assertFailure(NoSuchElementException.class);\n+    }\n }",
    "output": "Fix Flowable.singleOrError().toFlowable() not signalling NSEE"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java\n@@ -143,16 +143,19 @@ public void onNext(T t) {\n         void subscribeInner(ObservableSource<? extends U> p) {\n             for (;;) {\n                 if (p instanceof Callable) {\n-                    tryEmitScalar(((Callable<? extends U>)p));\n-\n-                    if (maxConcurrency != Integer.MAX_VALUE) {\n+                    if (tryEmitScalar(((Callable<? extends U>)p)) && maxConcurrency != Integer.MAX_VALUE) {\n+                        boolean empty = false;\n                         synchronized (this) {\n                             p = sources.poll();\n                             if (p == null) {\n                                 wip--;\n-                                break;\n+                                empty = true;\n                             }\n                         }\n+                        if (empty) {\n+                            drain();\n+                            break;\n+                        }\n                     } else {\n                         break;\n                     }\n@@ -214,26 +217,26 @@ void removeInner(InnerObserver<T, U> inner) {\n             }\n         }\n \n-        void tryEmitScalar(Callable<? extends U> value) {\n+        boolean tryEmitScalar(Callable<? extends U> value) {\n             U u;\n             try {\n                 u = value.call();\n             } catch (Throwable ex) {\n                 Exceptions.throwIfFatal(ex);\n                 errors.addThrowable(ex);\n                 drain();\n-                return;\n+                return true;\n             }\n \n             if (u == null) {\n-                return;\n+                return true;\n             }\n \n \n             if (get() == 0 && compareAndSet(0, 1)) {\n                 actual.onNext(u);\n                 if (decrementAndGet() == 0) {\n-                    return;\n+                    return true;\n                 }\n             } else {\n                 SimplePlainQueue<U> q = queue;\n@@ -248,13 +251,14 @@ void tryEmitScalar(Callable<? extends U> value) {\n \n                 if (!q.offer(u)) {\n                     onError(new IllegalStateException(\"Scalar queue full?!\"));\n-                    return;\n+                    return true;\n                 }\n                 if (getAndIncrement() != 0) {\n-                    return;\n+                    return false;\n                 }\n             }\n             drainLoop();\n+            return true;\n         }\n \n         void tryEmit(U value, InnerObserver<T, U> inner) {\n@@ -360,7 +364,14 @@ void drainLoop() {\n                 InnerObserver<?, ?>[] inner = observers.get();\n                 int n = inner.length;\n \n-                if (d && (svq == null || svq.isEmpty()) && n == 0) {\n+                int nSources = 0;\n+                if (maxConcurrency != Integer.MAX_VALUE) {\n+                    synchronized (this) {\n+                        nSources = sources.size();\n+                    }\n+                }\n+\n+                if (d && (svq == null || svq.isEmpty()) && n == 0 && nSources == 0) {\n                     Throwable ex = errors.terminate();\n                     if (ex != ExceptionHelper.TERMINATED) {\n                         if (ex == null) {\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapTest.java\n@@ -22,7 +22,7 @@\n \n import io.reactivex.*;\n import io.reactivex.disposables.*;\n-import io.reactivex.exceptions.TestException;\n+import io.reactivex.exceptions.*;\n import io.reactivex.functions.Function;\n import io.reactivex.internal.functions.Functions;\n import io.reactivex.observers.TestObserver;\n@@ -431,4 +431,71 @@ public void onComplete() {\n \n         assertTrue(disposable[0].isDisposed());\n     }\n+\n+    @Test\n+    public void reentrantNoOverflow() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            final PublishSubject<Integer> ps = PublishSubject.create();\n+\n+            TestObserver<Integer> to = ps.concatMap(new Function<Integer, Observable<Integer>>() {\n+                @Override\n+                public Observable<Integer> apply(Integer v)\n+                        throws Exception {\n+                    return Observable.just(v + 1);\n+                }\n+            }, 1)\n+            .subscribeWith(new TestObserver<Integer>() {\n+                @Override\n+                public void onNext(Integer t) {\n+                    super.onNext(t);\n+                    if (t == 1) {\n+                        for (int i = 1; i < 10; i++) {\n+                            ps.onNext(i);\n+                        }\n+                        ps.onComplete();\n+                    }\n+                }\n+            });\n+\n+            ps.onNext(0);\n+\n+            if (!errors.isEmpty()) {\n+                to.onError(new CompositeException(errors));\n+            }\n+\n+            to.assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n+\n+    @Test\n+    public void reentrantNoOverflowHidden() {\n+        final PublishSubject<Integer> ps = PublishSubject.create();\n+\n+        TestObserver<Integer> to = ps.concatMap(new Function<Integer, Observable<Integer>>() {\n+            @Override\n+            public Observable<Integer> apply(Integer v)\n+                    throws Exception {\n+                return Observable.just(v + 1).hide();\n+            }\n+        }, 1)\n+        .subscribeWith(new TestObserver<Integer>() {\n+            @Override\n+            public void onNext(Integer t) {\n+                super.onNext(t);\n+                if (t == 1) {\n+                    for (int i = 1; i < 10; i++) {\n+                        ps.onNext(i);\n+                    }\n+                    ps.onComplete();\n+                }\n+            }\n+        });\n+\n+        ps.onNext(0);\n+\n+        to.assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java\n@@ -938,4 +938,71 @@ public void remove() {\n \n         assertEquals(1, counter.get());\n     }\n+\n+    @Test\n+    public void scalarQueueNoOverflow() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            final PublishSubject<Integer> ps = PublishSubject.create();\n+\n+            TestObserver<Integer> to = ps.flatMap(new Function<Integer, Observable<Integer>>() {\n+                @Override\n+                public Observable<Integer> apply(Integer v)\n+                        throws Exception {\n+                    return Observable.just(v + 1);\n+                }\n+            }, 1)\n+            .subscribeWith(new TestObserver<Integer>() {\n+                @Override\n+                public void onNext(Integer t) {\n+                    super.onNext(t);\n+                    if (t == 1) {\n+                        for (int i = 1; i < 10; i++) {\n+                            ps.onNext(i);\n+                        }\n+                        ps.onComplete();\n+                    }\n+                }\n+            });\n+\n+            ps.onNext(0);\n+\n+            if (!errors.isEmpty()) {\n+                to.onError(new CompositeException(errors));\n+            }\n+\n+            to.assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n+\n+    @Test\n+    public void scalarQueueNoOverflowHidden() {\n+        final PublishSubject<Integer> ps = PublishSubject.create();\n+\n+        TestObserver<Integer> to = ps.flatMap(new Function<Integer, Observable<Integer>>() {\n+            @Override\n+            public Observable<Integer> apply(Integer v)\n+                    throws Exception {\n+                return Observable.just(v + 1).hide();\n+            }\n+        }, 1)\n+        .subscribeWith(new TestObserver<Integer>() {\n+            @Override\n+            public void onNext(Integer t) {\n+                super.onNext(t);\n+                if (t == 1) {\n+                    for (int i = 1; i < 10; i++) {\n+                        ps.onNext(i);\n+                    }\n+                    ps.onComplete();\n+                }\n+            }\n+        });\n+\n+        ps.onNext(0);\n+\n+        to.assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+    }\n }",
    "output": "Fix Observable.flatMap scalar maxConcurrency overflow"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/subjects/ReplaySubject.java b/src/main/java/io/reactivex/subjects/ReplaySubject.java\n--- a/src/main/java/io/reactivex/subjects/ReplaySubject.java\n+++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java\n@@ -13,15 +13,14 @@\n \n package io.reactivex.subjects;\n \n-import io.reactivex.annotations.Nullable;\n import java.lang.reflect.Array;\n import java.util.*;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.*;\n \n import io.reactivex.Observer;\n import io.reactivex.Scheduler;\n-import io.reactivex.annotations.CheckReturnValue;\n+import io.reactivex.annotations.*;\n import io.reactivex.disposables.Disposable;\n import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.util.NotificationLite;\n@@ -94,8 +93,9 @@\n  * in a non-blocking and thread-safe manner via {@link #hasValue()}, {@link #getValue()},\n  * {@link #getValues()} or {@link #getValues(Object[])}.\n  * <p>\n- * Note that due to concurrency requirements, a size-bounded {@code ReplaySubject} may hold strong references to more\n- * source emissions than specified.\n+ * Note that due to concurrency requirements, a size- and time-bounded {@code ReplaySubject} may hold strong references to more\n+ * source emissions than specified while it isn't terminated yet. Use the {@link #cleanupBuffer()} to allow\n+ * such inaccessible items to be cleaned up by GC once no consumer references it anymore.\n  * <dl>\n  *  <dt><b>Scheduler:</b></dt>\n  *  <dd>{@code ReplaySubject} does not operate by default on a particular {@link io.reactivex.Scheduler} and\n@@ -415,6 +415,24 @@ public T getValue() {\n         return buffer.getValue();\n     }\n \n+    /**\n+     * Makes sure the item cached by the head node in a bounded\n+     * ReplaySubject is released (as it is never part of a replay).\n+     * <p>\n+     * By default, live bounded buffers will remember one item before\n+     * the currently receivable one to ensure subscribers can always\n+     * receive a continuous sequence of items. A terminated ReplaySubject\n+     * automatically releases this inaccessible item.\n+     * <p>\n+     * The method must be called sequentially, similar to the standard\n+     * {@code onXXX} methods.\n+     * @since 2.1.11 - experimental\n+     */\n+    @Experimental\n+    public void cleanupBuffer() {\n+        buffer.trimHead();\n+    }\n+\n     /** An empty array to avoid allocation in getValues(). */\n     private static final Object[] EMPTY_ARRAY = new Object[0];\n \n@@ -563,6 +581,12 @@ interface ReplayBuffer<T> {\n          * @return true if successful\n          */\n         boolean compareAndSet(Object expected, Object next);\n+\n+        /**\n+         * Make sure an old inaccessible head value is released\n+         * in a bounded buffer.\n+         */\n+        void trimHead();\n     }\n \n     static final class ReplayDisposable<T> extends AtomicInteger implements Disposable {\n@@ -619,10 +643,16 @@ public void add(T value) {\n         @Override\n         public void addFinal(Object notificationLite) {\n             buffer.add(notificationLite);\n+            trimHead();\n             size++;\n             done = true;\n         }\n \n+        @Override\n+        public void trimHead() {\n+            // no-op in this type of buffer\n+        }\n+\n         @Override\n         @Nullable\n         @SuppressWarnings(\"unchecked\")\n@@ -839,9 +869,24 @@ public void addFinal(Object notificationLite) {\n             size++;\n             t.lazySet(n); // releases both the tail and size\n \n+            trimHead();\n             done = true;\n         }\n \n+        /**\n+         * Replace a non-empty head node with an empty one to\n+         * allow the GC of the inaccessible old value.\n+         */\n+        @Override\n+        public void trimHead() {\n+            Node<Object> h = head;\n+            if (h.value != null) {\n+                Node<Object> n = new Node<Object>(null);\n+                n.lazySet(h.get());\n+                head = n;\n+            }\n+        }\n+\n         @Override\n         @Nullable\n         @SuppressWarnings(\"unchecked\")\n@@ -1047,12 +1092,24 @@ void trimFinal() {\n             for (;;) {\n                 TimedNode<Object> next = h.get();\n                 if (next.get() == null) {\n-                    head = h;\n+                    if (h.value != null) {\n+                        TimedNode<Object> lasth = new TimedNode<Object>(null, 0L);\n+                        lasth.lazySet(h.get());\n+                        head = lasth;\n+                    } else {\n+                        head = h;\n+                    }\n                     break;\n                 }\n \n                 if (next.time > limit) {\n-                    head = h;\n+                    if (h.value != null) {\n+                        TimedNode<Object> lasth = new TimedNode<Object>(null, 0L);\n+                        lasth.lazySet(h.get());\n+                        head = lasth;\n+                    } else {\n+                        head = h;\n+                    }\n                     break;\n                 }\n \n@@ -1085,6 +1142,20 @@ public void addFinal(Object notificationLite) {\n             done = true;\n         }\n \n+        /**\n+         * Replace a non-empty head node with an empty one to\n+         * allow the GC of the inaccessible old value.\n+         */\n+        @Override\n+        public void trimHead() {\n+            TimedNode<Object> h = head;\n+            if (h.value != null) {\n+                TimedNode<Object> n = new TimedNode<Object>(null, 0);\n+                n.lazySet(h.get());\n+                head = n;\n+            }\n+        }\n+\n         @Override\n         @Nullable\n         @SuppressWarnings(\"unchecked\")\n\ndiff --git a/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java b/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java\n--- a/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java\n+++ b/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java\n@@ -30,6 +30,7 @@\n import io.reactivex.functions.Function;\n import io.reactivex.observers.*;\n import io.reactivex.schedulers.*;\n+import io.reactivex.subjects.ReplaySubject.*;\n \n public class ReplaySubjectTest extends SubjectTest<Integer> {\n \n@@ -1184,4 +1185,92 @@ public void timedNoOutdatedData() {\n \n         source.test().assertResult();\n     }\n+\n+    @Test\n+    public void noHeadRetentionCompleteSize() {\n+        ReplaySubject<Integer> source = ReplaySubject.createWithSize(1);\n+\n+        source.onNext(1);\n+        source.onNext(2);\n+        source.onComplete();\n+\n+        SizeBoundReplayBuffer<Integer> buf = (SizeBoundReplayBuffer<Integer>)source.buffer;\n+\n+        assertNull(buf.head.value);\n+\n+        Object o = buf.head;\n+\n+        source.cleanupBuffer();\n+\n+        assertSame(o, buf.head);\n+    }\n+\n+\n+    @Test\n+    public void noHeadRetentionSize() {\n+        ReplaySubject<Integer> source = ReplaySubject.createWithSize(1);\n+\n+        source.onNext(1);\n+        source.onNext(2);\n+\n+        SizeBoundReplayBuffer<Integer> buf = (SizeBoundReplayBuffer<Integer>)source.buffer;\n+\n+        assertNotNull(buf.head.value);\n+\n+        source.cleanupBuffer();\n+\n+        assertNull(buf.head.value);\n+\n+        Object o = buf.head;\n+\n+        source.cleanupBuffer();\n+\n+        assertSame(o, buf.head);\n+    }\n+\n+    @Test\n+    public void noHeadRetentionCompleteTime() {\n+        ReplaySubject<Integer> source = ReplaySubject.createWithTime(1, TimeUnit.MINUTES, Schedulers.computation());\n+\n+        source.onNext(1);\n+        source.onNext(2);\n+        source.onComplete();\n+\n+        SizeAndTimeBoundReplayBuffer<Integer> buf = (SizeAndTimeBoundReplayBuffer<Integer>)source.buffer;\n+\n+        assertNull(buf.head.value);\n+\n+        Object o = buf.head;\n+\n+        source.cleanupBuffer();\n+\n+        assertSame(o, buf.head);\n+    }\n+\n+    @Test\n+    public void noHeadRetentionTime() {\n+        TestScheduler sch = new TestScheduler();\n+\n+        ReplaySubject<Integer> source = ReplaySubject.createWithTime(1, TimeUnit.MILLISECONDS, sch);\n+\n+        source.onNext(1);\n+\n+        sch.advanceTimeBy(2, TimeUnit.MILLISECONDS);\n+\n+        source.onNext(2);\n+\n+        SizeAndTimeBoundReplayBuffer<Integer> buf = (SizeAndTimeBoundReplayBuffer<Integer>)source.buffer;\n+\n+        assertNotNull(buf.head.value);\n+\n+        source.cleanupBuffer();\n+\n+        assertNull(buf.head.value);\n+\n+        Object o = buf.head;\n+\n+        source.cleanupBuffer();\n+\n+        assertSame(o, buf.head);\n+    }\n }",
    "output": "Fix the extra retention problem in ReplaySubject\n\n* Fix the extra retention problem in ReplaySubject\r\n\r\n* Cover the already-trimmed case"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/CompletableObserver.java b/src/main/java/io/reactivex/CompletableObserver.java\n--- a/src/main/java/io/reactivex/CompletableObserver.java\n+++ b/src/main/java/io/reactivex/CompletableObserver.java\n@@ -28,7 +28,6 @@\n  * Calling the {@code CompletableObserver}'s method must happen in a serialized fashion, that is, they must not\n  * be invoked concurrently by multiple threads in an overlapping fashion and the invocation pattern must\n  * adhere to the following protocol:\n- * <p>\n  * <pre><code>    onSubscribe (onError | onComplete)?</code></pre>\n  * <p>\n  * Subscribing a {@code CompletableObserver} to multiple {@code CompletableSource}s is not recommended. If such reuse\n\ndiff --git a/src/main/java/io/reactivex/MaybeObserver.java b/src/main/java/io/reactivex/MaybeObserver.java\n--- a/src/main/java/io/reactivex/MaybeObserver.java\n+++ b/src/main/java/io/reactivex/MaybeObserver.java\n@@ -28,7 +28,6 @@\n  * Calling the {@code MaybeObserver}'s method must happen in a serialized fashion, that is, they must not\n  * be invoked concurrently by multiple threads in an overlapping fashion and the invocation pattern must\n  * adhere to the following protocol:\n- * <p>\n  * <pre><code>    onSubscribe (onSuccess | onError | onComplete)?</code></pre>\n  * <p>\n  * Note that unlike with the {@code Observable} protocol, {@link #onComplete()} is not called after the success item has been\n\ndiff --git a/src/main/java/io/reactivex/Observer.java b/src/main/java/io/reactivex/Observer.java\n--- a/src/main/java/io/reactivex/Observer.java\n+++ b/src/main/java/io/reactivex/Observer.java\n@@ -30,7 +30,6 @@\n  * Calling the {@code Observer}'s method must happen in a serialized fashion, that is, they must not\n  * be invoked concurrently by multiple threads in an overlapping fashion and the invocation pattern must\n  * adhere to the following protocol:\n- * <p>\n  * <pre><code>    onSubscribe onNext* (onError | onComplete)?</code></pre>\n  * <p>\n  * Subscribing an {@code Observer} to multiple {@code ObservableSource}s is not recommended. If such reuse\n\ndiff --git a/src/main/java/io/reactivex/SingleObserver.java b/src/main/java/io/reactivex/SingleObserver.java\n--- a/src/main/java/io/reactivex/SingleObserver.java\n+++ b/src/main/java/io/reactivex/SingleObserver.java\n@@ -28,7 +28,6 @@\n  * Calling the {@code SingleObserver}'s method must happen in a serialized fashion, that is, they must not\n  * be invoked concurrently by multiple threads in an overlapping fashion and the invocation pattern must\n  * adhere to the following protocol:\n- * <p>\n  * <pre><code>    onSubscribe (onSuccess | onError)?</code></pre>\n  * <p>\n  * Subscribing a {@code SingleObserver} to multiple {@code SingleSource}s is not recommended. If such reuse",
    "output": "Fix Javadoc warnings, links to the JDK types"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java\n--- a/src/main/java/io/reactivex/Observable.java\n+++ b/src/main/java/io/reactivex/Observable.java\n@@ -12337,7 +12337,7 @@ public final Observable<Timed<T>> timeInterval(Scheduler scheduler) {\n      * @see <a href=\"http://reactivex.io/documentation/operators/timeinterval.html\">ReactiveX operators documentation: TimeInterval</a>\n      */\n     @CheckReturnValue\n-    @SchedulerSupport(SchedulerSupport.NONE) // Trampoline scheduler is only used for creating timestamps.\n+    @SchedulerSupport(SchedulerSupport.NONE)\n     public final Observable<Timed<T>> timeInterval(TimeUnit unit) {\n         return timeInterval(unit, Schedulers.computation());\n     }",
    "output": "Remove unnecessary comment from Observable.timeInterval(TimeUnit)"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java\n--- a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java\n+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java\n@@ -86,6 +86,7 @@ public final class RxJavaPlugins {\n     @Nullable\n     static volatile Function<? super Single, ? extends Single> onSingleAssembly;\n \n+    @Nullable\n     static volatile Function<? super Completable, ? extends Completable> onCompletableAssembly;\n \n     @SuppressWarnings(\"rawtypes\")",
    "output": "Add nullability annotation for completable assembly"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java\n@@ -131,15 +131,15 @@ public void onNext(T t) {\n \n         @Override\n         public void onError(Throwable t) {\n-            if (done || !errors.addThrowable(t)) {\n+            if (!done && errors.addThrowable(t)) {\n                 if (!delayErrors) {\n                     disposeInner();\n                 }\n+                done = true;\n+                drain();\n+            } else {\n                 RxJavaPlugins.onError(t);\n-                return;\n             }\n-            done = true;\n-            drain();\n         }\n \n         @Override\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java\n@@ -1153,4 +1153,25 @@ public Object apply(Integer v) throws Exception {\n         .test()\n         .assertFailure(TestException.class);\n     }\n+\n+    @Test\n+    public void innerCancelledOnMainError() {\n+        final PublishProcessor<Integer> main = PublishProcessor.create();\n+        final PublishProcessor<Integer> inner = PublishProcessor.create();\n+\n+        TestSubscriber<Integer> to = main.switchMap(Functions.justFunction(inner))\n+        .test();\n+\n+        assertTrue(main.hasSubscribers());\n+\n+        main.onNext(1);\n+\n+        assertTrue(inner.hasSubscribers());\n+\n+        main.onError(new TestException());\n+\n+        assertFalse(inner.hasSubscribers());\n+\n+        to.assertFailure(TestException.class);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java\n@@ -18,7 +18,7 @@\n \n import java.util.List;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.*;\n \n import org.junit.*;\n import org.mockito.InOrder;\n@@ -768,7 +768,7 @@ public void run() {\n \n     @Test\n     public void outerInnerErrorRace() {\n-        for (int i = 0; i < 500; i++) {\n+        for (int i = 0; i < 5000; i++) {\n             List<Throwable> errors = TestHelper.trackPluginErrors();\n             try {\n \n@@ -786,6 +786,8 @@ public ObservableSource<Integer> apply(Integer v) throws Exception {\n                 })\n                 .test();\n \n+                ps1.onNext(1);\n+\n                 final TestException ex1 = new TestException();\n \n                 Runnable r1 = new Runnable() {\n@@ -807,7 +809,7 @@ public void run() {\n                 TestHelper.race(r1, r2);\n \n                 for (Throwable e : errors) {\n-                    assertTrue(e.toString(), e instanceof TestException);\n+                    assertTrue(e.getCause().toString(), e.getCause() instanceof TestException);\n                 }\n             } finally {\n                 RxJavaPlugins.reset();\n@@ -963,4 +965,93 @@ public void onNext(Integer t) {\n \n         to.assertFailure(TestException.class, 1);\n     }\n+\n+    @Test\n+    public void innerDisposedOnMainError() {\n+        final PublishSubject<Integer> main = PublishSubject.create();\n+        final PublishSubject<Integer> inner = PublishSubject.create();\n+\n+        TestObserver<Integer> to = main.switchMap(Functions.justFunction(inner))\n+        .test();\n+\n+        assertTrue(main.hasObservers());\n+\n+        main.onNext(1);\n+\n+        assertTrue(inner.hasObservers());\n+\n+        main.onError(new TestException());\n+\n+        assertFalse(inner.hasObservers());\n+\n+        to.assertFailure(TestException.class);\n+    }\n+\n+    @Test\n+    public void outerInnerErrorRaceIgnoreDispose() {\n+        for (int i = 0; i < 5000; i++) {\n+            List<Throwable> errors = TestHelper.trackPluginErrors();\n+            try {\n+\n+                final AtomicReference<Observer<? super Integer>> obs1 = new AtomicReference<Observer<? super Integer>>();\n+                final Observable<Integer> ps1 = new Observable<Integer>() {\n+                    @Override\n+                    protected void subscribeActual(\n+                            Observer<? super Integer> observer) {\n+                        obs1.set(observer);\n+                    }\n+                };\n+                final AtomicReference<Observer<? super Integer>> obs2 = new AtomicReference<Observer<? super Integer>>();\n+                final Observable<Integer> ps2 = new Observable<Integer>() {\n+                    @Override\n+                    protected void subscribeActual(\n+                            Observer<? super Integer> observer) {\n+                        obs2.set(observer);\n+                    }\n+                };\n+\n+                ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {\n+                    @Override\n+                    public ObservableSource<Integer> apply(Integer v) throws Exception {\n+                        if (v == 1) {\n+                            return ps2;\n+                        }\n+                        return Observable.never();\n+                    }\n+                })\n+                .test();\n+\n+                obs1.get().onSubscribe(Disposables.empty());\n+                obs1.get().onNext(1);\n+\n+                obs2.get().onSubscribe(Disposables.empty());\n+\n+                final TestException ex1 = new TestException();\n+\n+                Runnable r1 = new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        obs1.get().onError(ex1);\n+                    }\n+                };\n+\n+                final TestException ex2 = new TestException();\n+\n+                Runnable r2 = new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        obs2.get().onError(ex2);\n+                    }\n+                };\n+\n+                TestHelper.race(r1, r2);\n+\n+                for (Throwable e : errors) {\n+                    assertTrue(e.toString(), e.getCause() instanceof TestException);\n+                }\n+            } finally {\n+                RxJavaPlugins.reset();\n+            }\n+        }\n+    }\n }",
    "output": "Fix Observable.switchMap main onError not disposing the current inner source\n\n* Fix Obs.switchMap main onError not disposing the current inner src\r\n\r\n* Fix error-error race test"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeat.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeat.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeat.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeat.java\n@@ -36,7 +36,6 @@ public void subscribeActual(Subscriber<? super T> s) {\n         rs.subscribeNext();\n     }\n \n-    // FIXME update to a fresh Rsc algorithm\n     static final class RepeatSubscriber<T> extends AtomicInteger implements FlowableSubscriber<T> {\n \n         private static final long serialVersionUID = -7098360935104053232L;\n@@ -45,6 +44,9 @@ static final class RepeatSubscriber<T> extends AtomicInteger implements Flowable\n         final SubscriptionArbiter sa;\n         final Publisher<? extends T> source;\n         long remaining;\n+\n+        long produced;\n+\n         RepeatSubscriber(Subscriber<? super T> actual, long count, SubscriptionArbiter sa, Publisher<? extends T> source) {\n             this.actual = actual;\n             this.sa = sa;\n@@ -59,8 +61,8 @@ public void onSubscribe(Subscription s) {\n \n         @Override\n         public void onNext(T t) {\n+            produced++;\n             actual.onNext(t);\n-            sa.produced(1L);\n         }\n         @Override\n         public void onError(Throwable t) {\n@@ -90,6 +92,11 @@ void subscribeNext() {\n                     if (sa.isCancelled()) {\n                         return;\n                     }\n+                    long p = produced;\n+                    if (p != 0L) {\n+                        produced = 0L;\n+                        sa.produced(p);\n+                    }\n                     source.subscribe(this);\n \n                     missed = addAndGet(-missed);\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatUntil.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatUntil.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatUntil.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatUntil.java\n@@ -38,7 +38,6 @@ public void subscribeActual(Subscriber<? super T> s) {\n         rs.subscribeNext();\n     }\n \n-    // FIXME update to a fresh Rsc algorithm\n     static final class RepeatSubscriber<T> extends AtomicInteger implements FlowableSubscriber<T> {\n \n         private static final long serialVersionUID = -7098360935104053232L;\n@@ -47,6 +46,9 @@ static final class RepeatSubscriber<T> extends AtomicInteger implements Flowable\n         final SubscriptionArbiter sa;\n         final Publisher<? extends T> source;\n         final BooleanSupplier stop;\n+\n+        long produced;\n+\n         RepeatSubscriber(Subscriber<? super T> actual, BooleanSupplier until, SubscriptionArbiter sa, Publisher<? extends T> source) {\n             this.actual = actual;\n             this.sa = sa;\n@@ -61,8 +63,8 @@ public void onSubscribe(Subscription s) {\n \n         @Override\n         public void onNext(T t) {\n+            produced++;\n             actual.onNext(t);\n-            sa.produced(1L);\n         }\n         @Override\n         public void onError(Throwable t) {\n@@ -93,6 +95,16 @@ void subscribeNext() {\n             if (getAndIncrement() == 0) {\n                 int missed = 1;\n                 for (;;) {\n+                    if (sa.isCancelled()) {\n+                        return;\n+                    }\n+\n+                    long p = produced;\n+                    if (p != 0L) {\n+                        produced = 0L;\n+                        sa.produced(p);\n+                    }\n+\n                     source.subscribe(this);\n \n                     missed = addAndGet(-missed);\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryBiPredicate.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryBiPredicate.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryBiPredicate.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryBiPredicate.java\n@@ -40,7 +40,6 @@ public void subscribeActual(Subscriber<? super T> s) {\n         rs.subscribeNext();\n     }\n \n-    // FIXME update to a fresh Rsc algorithm\n     static final class RetryBiSubscriber<T> extends AtomicInteger implements FlowableSubscriber<T> {\n \n         private static final long serialVersionUID = -7098360935104053232L;\n@@ -50,6 +49,9 @@ static final class RetryBiSubscriber<T> extends AtomicInteger implements Flowabl\n         final Publisher<? extends T> source;\n         final BiPredicate<? super Integer, ? super Throwable> predicate;\n         int retries;\n+\n+        long produced;\n+\n         RetryBiSubscriber(Subscriber<? super T> actual,\n                 BiPredicate<? super Integer, ? super Throwable> predicate, SubscriptionArbiter sa, Publisher<? extends T> source) {\n             this.actual = actual;\n@@ -65,8 +67,8 @@ public void onSubscribe(Subscription s) {\n \n         @Override\n         public void onNext(T t) {\n+            produced++;\n             actual.onNext(t);\n-            sa.produced(1L);\n         }\n         @Override\n         public void onError(Throwable t) {\n@@ -100,6 +102,13 @@ void subscribeNext() {\n                     if (sa.isCancelled()) {\n                         return;\n                     }\n+\n+                    long p = produced;\n+                    if (p != 0L) {\n+                        produced = 0L;\n+                        sa.produced(p);\n+                    }\n+\n                     source.subscribe(this);\n \n                     missed = addAndGet(-missed);\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryPredicate.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryPredicate.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryPredicate.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryPredicate.java\n@@ -38,12 +38,11 @@ public void subscribeActual(Subscriber<? super T> s) {\n         SubscriptionArbiter sa = new SubscriptionArbiter();\n         s.onSubscribe(sa);\n \n-        RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, count, predicate, sa, source);\n+        RetrySubscriber<T> rs = new RetrySubscriber<T>(s, count, predicate, sa, source);\n         rs.subscribeNext();\n     }\n \n-    // FIXME update to a fresh Rsc algorithm\n-    static final class RepeatSubscriber<T> extends AtomicInteger implements FlowableSubscriber<T> {\n+    static final class RetrySubscriber<T> extends AtomicInteger implements FlowableSubscriber<T> {\n \n         private static final long serialVersionUID = -7098360935104053232L;\n \n@@ -52,7 +51,10 @@ static final class RepeatSubscriber<T> extends AtomicInteger implements Flowable\n         final Publisher<? extends T> source;\n         final Predicate<? super Throwable> predicate;\n         long remaining;\n-        RepeatSubscriber(Subscriber<? super T> actual, long count,\n+\n+        long produced;\n+\n+        RetrySubscriber(Subscriber<? super T> actual, long count,\n                 Predicate<? super Throwable> predicate, SubscriptionArbiter sa, Publisher<? extends T> source) {\n             this.actual = actual;\n             this.sa = sa;\n@@ -68,8 +70,8 @@ public void onSubscribe(Subscription s) {\n \n         @Override\n         public void onNext(T t) {\n+            produced++;\n             actual.onNext(t);\n-            sa.produced(1L);\n         }\n         @Override\n         public void onError(Throwable t) {\n@@ -111,6 +113,13 @@ void subscribeNext() {\n                     if (sa.isCancelled()) {\n                         return;\n                     }\n+\n+                    long p = produced;\n+                    if (p != 0L) {\n+                        produced = 0L;\n+                        sa.produced(p);\n+                    }\n+\n                     source.subscribe(this);\n \n                     missed = addAndGet(-missed);\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java\n@@ -259,6 +259,19 @@ public boolean getAsBoolean() throws Exception {\n         .assertResult(1, 1, 1, 1, 1);\n     }\n \n+    @Test\n+    public void repeatUntilCancel() {\n+        Flowable.just(1)\n+        .repeatUntil(new BooleanSupplier() {\n+            @Override\n+            public boolean getAsBoolean() throws Exception {\n+                return true;\n+            }\n+        })\n+        .test(2L, true)\n+        .assertEmpty();\n+    }\n+\n     @Test\n     public void repeatLongPredicateInvalid() {\n         try {",
    "output": "Improve request accounting overhead in retry/repeat * improve request accounting overhead in retry/repeat * Test repeatUntil cancelled case"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java\n@@ -166,7 +166,7 @@ public void onComplete() {\n             queue.offer(b);\n             done = true;\n             if (enter()) {\n-                QueueDrainHelper.drainMaxLoop(queue, actual, false, this, this);\n+                QueueDrainHelper.drainMaxLoop(queue, actual, false, null, this);\n             }\n         }\n \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java\n@@ -161,7 +161,7 @@ public void onComplete() {\n                 queue.offer(b);\n                 done = true;\n                 if (enter()) {\n-                    QueueDrainHelper.drainLoop(queue, actual, false, this, this);\n+                    QueueDrainHelper.drainLoop(queue, actual, false, null, this);\n                 }\n             }\n             DisposableHelper.dispose(timer);\n\ndiff --git a/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java\n--- a/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java\n+++ b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java\n@@ -168,7 +168,9 @@ public static <T, U> boolean checkTerminated(boolean d, boolean empty,\n         if (d) {\n             if (delayError) {\n                 if (empty) {\n-                    disposable.dispose();\n+                    if (disposable != null) {\n+                        disposable.dispose();\n+                    }\n                     Throwable err = qd.error();\n                     if (err != null) {\n                         s.onError(err);\n@@ -181,12 +183,16 @@ public static <T, U> boolean checkTerminated(boolean d, boolean empty,\n                 Throwable err = qd.error();\n                 if (err != null) {\n                     q.clear();\n-                    disposable.dispose();\n+                    if (disposable != null) {\n+                        disposable.dispose();\n+                    }\n                     s.onError(err);\n                     return true;\n                 } else\n                 if (empty) {\n-                    disposable.dispose();\n+                    if (disposable != null) {\n+                        disposable.dispose();\n+                    }\n                     s.onComplete();\n                     return true;\n                 }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java\n@@ -2014,4 +2014,64 @@ public void run() {\n             assertEquals(\"Round: \" + i, 5, items);\n         }\n     }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void noCompletionCancelExact() {\n+        final AtomicInteger counter = new AtomicInteger();\n+\n+        Flowable.<Integer>empty()\n+        .doOnCancel(new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                counter.getAndIncrement();\n+            }\n+        })\n+        .buffer(5, TimeUnit.SECONDS)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult(Collections.<Integer>emptyList());\n+\n+        assertEquals(0, counter.get());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void noCompletionCancelSkip() {\n+        final AtomicInteger counter = new AtomicInteger();\n+\n+        Flowable.<Integer>empty()\n+        .doOnCancel(new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                counter.getAndIncrement();\n+            }\n+        })\n+        .buffer(5, 10, TimeUnit.SECONDS)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult(Collections.<Integer>emptyList());\n+\n+        assertEquals(0, counter.get());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void noCompletionCancelOverlap() {\n+        final AtomicInteger counter = new AtomicInteger();\n+\n+        Flowable.<Integer>empty()\n+        .doOnCancel(new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                counter.getAndIncrement();\n+            }\n+        })\n+        .buffer(10, 5, TimeUnit.SECONDS)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult(Collections.<Integer>emptyList());\n+\n+        assertEquals(0, counter.get());\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java\n@@ -19,6 +19,7 @@\n \n import java.util.*;\n import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.*;\n import org.mockito.*;\n@@ -1439,4 +1440,64 @@ public void run() {\n             assertEquals(\"Round: \" + i, 5, items);\n         }\n     }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void noCompletionCancelExact() {\n+        final AtomicInteger counter = new AtomicInteger();\n+\n+        Observable.<Integer>empty()\n+        .doOnDispose(new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                counter.getAndIncrement();\n+            }\n+        })\n+        .buffer(5, TimeUnit.SECONDS)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult(Collections.<Integer>emptyList());\n+\n+        assertEquals(0, counter.get());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void noCompletionCancelSkip() {\n+        final AtomicInteger counter = new AtomicInteger();\n+\n+        Observable.<Integer>empty()\n+        .doOnDispose(new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                counter.getAndIncrement();\n+            }\n+        })\n+        .buffer(5, 10, TimeUnit.SECONDS)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult(Collections.<Integer>emptyList());\n+\n+        assertEquals(0, counter.get());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void noCompletionCancelOverlap() {\n+        final AtomicInteger counter = new AtomicInteger();\n+\n+        Observable.<Integer>empty()\n+        .doOnDispose(new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                counter.getAndIncrement();\n+            }\n+        })\n+        .buffer(10, 5, TimeUnit.SECONDS)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult(Collections.<Integer>emptyList());\n+\n+        assertEquals(0, counter.get());\n+    }\n }",
    "output": "Fix timed exact buffer calling cancel unnecessarily"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java b/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java\n--- a/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java\n+++ b/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java\n@@ -49,7 +49,7 @@ public Worker createWorker() {\n     @NonNull\n     @Override\n     public Disposable scheduleDirect(@NonNull Runnable run) {\n-        run.run();\n+        RxJavaPlugins.onSchedule(run).run();\n         return EmptyDisposable.INSTANCE;\n     }\n \n@@ -58,7 +58,7 @@ public Disposable scheduleDirect(@NonNull Runnable run) {\n     public Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) {\n         try {\n             unit.sleep(delay);\n-            run.run();\n+            RxJavaPlugins.onSchedule(run).run();\n         } catch (InterruptedException ex) {\n             Thread.currentThread().interrupt();\n             RxJavaPlugins.onError(ex);\n\ndiff --git a/src/test/java/io/reactivex/schedulers/AbstractSchedulerTests.java b/src/test/java/io/reactivex/schedulers/AbstractSchedulerTests.java\n--- a/src/test/java/io/reactivex/schedulers/AbstractSchedulerTests.java\n+++ b/src/test/java/io/reactivex/schedulers/AbstractSchedulerTests.java\n@@ -20,6 +20,8 @@\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.*;\n \n+import io.reactivex.internal.functions.Functions;\n+import io.reactivex.plugins.RxJavaPlugins;\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.invocation.InvocationOnMock;\n@@ -41,6 +43,7 @@ public abstract class AbstractSchedulerTests {\n \n     /**\n      * The scheduler to test.\n+     *\n      * @return the Scheduler instance\n      */\n     protected abstract Scheduler getScheduler();\n@@ -576,6 +579,7 @@ public void schedulePeriodicallyDirectZeroPeriod() throws Exception {\n             try {\n                 sd.replace(s.schedulePeriodicallyDirect(new Runnable() {\n                     int count;\n+\n                     @Override\n                     public void run() {\n                         if (++count == 10) {\n@@ -610,6 +614,7 @@ public void schedulePeriodicallyZeroPeriod() throws Exception {\n             try {\n                 sd.replace(w.schedulePeriodically(new Runnable() {\n                     int count;\n+\n                     @Override\n                     public void run() {\n                         if (++count == 10) {\n@@ -626,4 +631,71 @@ public void run() {\n             }\n         }\n     }\n+\n+    private void assertRunnableDecorated(Runnable scheduleCall) throws InterruptedException {\n+        try {\n+            final CountDownLatch decoratedCalled = new CountDownLatch(1);\n+\n+            RxJavaPlugins.setScheduleHandler(new Function<Runnable, Runnable>() {\n+                @Override\n+                public Runnable apply(final Runnable actual) throws Exception {\n+                    return new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            decoratedCalled.countDown();\n+                            actual.run();\n+                        }\n+                    };\n+                }\n+            });\n+\n+            scheduleCall.run();\n+\n+            assertTrue(decoratedCalled.await(5, TimeUnit.SECONDS));\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n+\n+    @Test(timeout = 6000)\n+    public void scheduleDirectDecoratesRunnable() throws InterruptedException {\n+        assertRunnableDecorated(new Runnable() {\n+            @Override\n+            public void run() {\n+                getScheduler().scheduleDirect(Functions.EMPTY_RUNNABLE);\n+            }\n+        });\n+    }\n+\n+    @Test(timeout = 6000)\n+    public void scheduleDirectWithDelayDecoratesRunnable() throws InterruptedException {\n+        assertRunnableDecorated(new Runnable() {\n+            @Override\n+            public void run() {\n+                getScheduler().scheduleDirect(Functions.EMPTY_RUNNABLE, 1, TimeUnit.MILLISECONDS);\n+            }\n+        });\n+    }\n+\n+    @Test(timeout = 6000)\n+    public void schedulePeriodicallyDirectDecoratesRunnable() throws InterruptedException {\n+        final Scheduler scheduler = getScheduler();\n+        if (scheduler instanceof TrampolineScheduler) {\n+            // Can't properly stop a trampolined periodic task.\n+            return;\n+        }\n+\n+        final AtomicReference<Disposable> disposable = new AtomicReference<Disposable>();\n+\n+        try {\n+            assertRunnableDecorated(new Runnable() {\n+                @Override\n+                public void run() {\n+                    disposable.set(scheduler.schedulePeriodicallyDirect(Functions.EMPTY_RUNNABLE, 1, 10000, TimeUnit.MILLISECONDS));\n+                }\n+            });\n+        } finally {\n+            disposable.get().dispose();\n+        }\n+    }\n }",
    "output": "Fix TrampolineScheduler not calling RxJavaPlugins.onSchedule(), add tests for all schedulers"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java\n--- a/src/main/java/io/reactivex/Observable.java\n+++ b/src/main/java/io/reactivex/Observable.java\n@@ -12538,7 +12538,6 @@ public final <K, V> Single<Map<K, V>> toMap(\n             final Function<? super T, ? extends V> valueSelector,\n             Callable<? extends Map<K, V>> mapSupplier) {\n         ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n-        ObjectHelper.requireNonNull(keySelector, \"keySelector is null\");\n         ObjectHelper.requireNonNull(valueSelector, \"valueSelector is null\");\n         ObjectHelper.requireNonNull(mapSupplier, \"mapSupplier is null\");\n         return collect(mapSupplier, Functions.toMapKeyValueSelector(keySelector, valueSelector));",
    "output": "Remove duplicate nullity check line"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatArray.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatArray.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatArray.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatArray.java\n@@ -52,7 +52,7 @@ static final class ConcatInnerObserver extends AtomicInteger implements Completa\n \n         @Override\n         public void onSubscribe(Disposable d) {\n-            sd.update(d);\n+            sd.replace(d);\n         }\n \n         @Override\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java\n@@ -64,7 +64,7 @@ static final class ConcatInnerObserver extends AtomicInteger implements Completa\n \n         @Override\n         public void onSubscribe(Disposable d) {\n-            sd.update(d);\n+            sd.replace(d);\n         }\n \n         @Override\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableAndThenTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableAndThenTest.java\n--- a/src/test/java/io/reactivex/internal/operators/completable/CompletableAndThenTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableAndThenTest.java\n@@ -15,7 +15,13 @@\n \n import io.reactivex.Completable;\n import io.reactivex.Maybe;\n+import io.reactivex.functions.Action;\n+import io.reactivex.schedulers.Schedulers;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n import org.junit.Test;\n+import static org.junit.Assert.*;\n \n public class CompletableAndThenTest {\n     @Test(expected = NullPointerException.class)\n@@ -63,4 +69,39 @@ public void andThenMaybeError() {\n             .assertError(RuntimeException.class)\n             .assertErrorMessage(\"bla\");\n     }\n+\n+    @Test\n+    public void andThenNoInterrupt() throws InterruptedException {\n+        for (int k = 0; k < 100; k++) {\n+            final int count = 10;\n+            final CountDownLatch latch = new CountDownLatch(count);\n+            final boolean[] interrupted = { false };\n+\n+            for (int i = 0; i < count; i++) {\n+                Completable.complete()\n+                .subscribeOn(Schedulers.io())\n+                .observeOn(Schedulers.io())\n+                .andThen(Completable.fromAction(new Action() {\n+                    @Override\n+                    public void run() throws Exception {\n+                        try {\n+                            Thread.sleep(30);\n+                        } catch (InterruptedException e) {\n+                            System.out.println(\"Interrupted! \" + Thread.currentThread());\n+                            interrupted[0] = true;\n+                        }\n+                    }\n+                }))\n+                .subscribe(new Action() {\n+                    @Override\n+                    public void run() throws Exception {\n+                        latch.countDown();\n+                    }\n+                });\n+            }\n+\n+            latch.await();\n+            assertFalse(\"The second Completable was interrupted!\", interrupted[0]);\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java\n--- a/src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java\n@@ -16,14 +16,15 @@\n import static org.junit.Assert.*;\n \n import java.util.*;\n+import java.util.concurrent.CountDownLatch;\n \n import org.junit.Test;\n import org.reactivestreams.*;\n \n import io.reactivex.*;\n import io.reactivex.disposables.Disposables;\n import io.reactivex.exceptions.*;\n-import io.reactivex.functions.Function;\n+import io.reactivex.functions.*;\n import io.reactivex.internal.subscriptions.BooleanSubscription;\n import io.reactivex.observers.*;\n import io.reactivex.plugins.RxJavaPlugins;\n@@ -254,4 +255,41 @@ public void run() {\n             TestHelper.race(r1, r2, Schedulers.single());\n         }\n     }\n+\n+    @Test\n+    public void noInterrupt() throws InterruptedException {\n+        for (int k = 0; k < 100; k++) {\n+            final int count = 10;\n+            final CountDownLatch latch = new CountDownLatch(count);\n+            final boolean[] interrupted = { false };\n+\n+            for (int i = 0; i < count; i++) {\n+                Completable c0 = Completable.fromAction(new Action() {\n+                    @Override\n+                    public void run() throws Exception {\n+                        try {\n+                            Thread.sleep(30);\n+                        } catch (InterruptedException e) {\n+                            System.out.println(\"Interrupted! \" + Thread.currentThread());\n+                            interrupted[0] = true;\n+                        }\n+                    }\n+                });\n+                Completable.concat(Arrays.asList(Completable.complete()\n+                    .subscribeOn(Schedulers.io())\n+                    .observeOn(Schedulers.io()),\n+                    c0)\n+                )\n+                .subscribe(new Action() {\n+                    @Override\n+                    public void run() throws Exception {\n+                        latch.countDown();\n+                    }\n+                });\n+            }\n+\n+            latch.await();\n+            assertFalse(\"The second Completable was interrupted!\", interrupted[0]);\n+        }\n+    }\n }",
    "output": "Fix Completable.concat to use replace (don't dispose old) * fix Completable.concat to use replace (don't dispose old) * Remove comments from original issue report"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/tck/LimitTckTest.java b/src/test/java/io/reactivex/tck/LimitTckTest.java\n--- a/src/test/java/io/reactivex/tck/LimitTckTest.java\n+++ b/src/test/java/io/reactivex/tck/LimitTckTest.java\n@@ -0,0 +1,30 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.tck;\n+\n+import org.reactivestreams.Publisher;\n+import org.testng.annotations.Test;\n+\n+import io.reactivex.Flowable;\n+\n+@Test\n+public class LimitTckTest extends BaseTck<Integer> {\n+\n+    @Override\n+    public Publisher<Integer> createPublisher(long elements) {\n+        return\n+                Flowable.range(0, (int)elements * 2).limit(elements)\n+        ;\n+    }\n+}",
    "output": "Add TCK test for limit()"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/parallel/ParallelFromPublisher.java b/src/main/java/io/reactivex/internal/operators/parallel/ParallelFromPublisher.java\n--- a/src/main/java/io/reactivex/internal/operators/parallel/ParallelFromPublisher.java\n+++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelFromPublisher.java\n@@ -116,7 +116,7 @@ public void onSubscribe(Subscription s) {\n                     @SuppressWarnings(\"unchecked\")\n                     QueueSubscription<T> qs = (QueueSubscription<T>) s;\n \n-                    int m = qs.requestFusion(QueueSubscription.ANY);\n+                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);\n \n                     if (m == QueueSubscription.SYNC) {\n                         sourceMode = m;\n\ndiff --git a/src/test/java/io/reactivex/parallel/ParallelFromPublisherTest.java b/src/test/java/io/reactivex/parallel/ParallelFromPublisherTest.java\n--- a/src/test/java/io/reactivex/parallel/ParallelFromPublisherTest.java\n+++ b/src/test/java/io/reactivex/parallel/ParallelFromPublisherTest.java\n@@ -14,15 +14,22 @@\n package io.reactivex.parallel;\n \n import static org.junit.Assert.*;\n+\n+import java.util.*;\n+import java.util.concurrent.*;\n+\n import org.junit.Test;\n-import org.reactivestreams.Subscriber;\n+import org.reactivestreams.*;\n \n-import io.reactivex.Flowable;\n+import io.reactivex.*;\n import io.reactivex.exceptions.*;\n-import io.reactivex.functions.Function;\n+import io.reactivex.functions.*;\n import io.reactivex.internal.functions.Functions;\n+import io.reactivex.internal.fuseable.QueueSubscription;\n+import io.reactivex.internal.subscribers.BasicFuseableSubscriber;\n import io.reactivex.internal.subscriptions.BooleanSubscription;\n import io.reactivex.processors.UnicastProcessor;\n+import io.reactivex.schedulers.Schedulers;\n \n public class ParallelFromPublisherTest {\n \n@@ -53,6 +60,53 @@ public void fusedFilterBecomesEmpty() {\n         .assertResult();\n     }\n \n+    static final class StripBoundary<T> extends Flowable<T> implements FlowableTransformer<T, T> {\n+\n+        final Flowable<T> source;\n+\n+        StripBoundary(Flowable<T> source) {\n+            this.source = source;\n+        }\n+\n+        @Override\n+        public Publisher<T> apply(Flowable<T> upstream) {\n+            return new StripBoundary<T>(upstream);\n+        }\n+\n+        @Override\n+        protected void subscribeActual(Subscriber<? super T> s) {\n+            source.subscribe(new StripBoundarySubscriber<T>(s));\n+        }\n+\n+        static final class StripBoundarySubscriber<T> extends BasicFuseableSubscriber<T, T> {\n+\n+            StripBoundarySubscriber(Subscriber<? super T> actual) {\n+                super(actual);\n+            }\n+\n+            @Override\n+            public void onNext(T t) {\n+                actual.onNext(t);\n+            }\n+\n+            @Override\n+            public int requestFusion(int mode) {\n+                QueueSubscription<T> fs = qs;\n+                if (fs != null) {\n+                    int m = fs.requestFusion(mode & ~QueueSubscription.BOUNDARY);\n+                    this.sourceMode = m;\n+                    return m;\n+                }\n+                return QueueSubscription.NONE;\n+            }\n+\n+            @Override\n+            public T poll() throws Exception {\n+                return qs.poll();\n+            }\n+        }\n+    }\n+\n     @Test\n     public void syncFusedMapCrash() {\n         Flowable.just(1)\n@@ -62,6 +116,7 @@ public Object apply(Integer v) throws Exception {\n                 throw new TestException();\n             }\n         })\n+        .compose(new StripBoundary<Object>(null))\n         .parallel()\n         .sequential()\n         .test()\n@@ -81,11 +136,53 @@ public Object apply(Integer v) throws Exception {\n                 throw new TestException();\n             }\n         })\n+        .compose(new StripBoundary<Object>(null))\n         .parallel()\n         .sequential()\n         .test()\n         .assertFailure(TestException.class);\n \n         assertFalse(up.hasSubscribers());\n     }\n+\n+    @Test\n+    public void boundaryConfinement() {\n+        final Set<String> between = new HashSet<String>();\n+        final ConcurrentHashMap<String, String> processing = new ConcurrentHashMap<String, String>();\n+\n+        Flowable.range(1, 10)\n+        .observeOn(Schedulers.single(), false, 1)\n+        .doOnNext(new Consumer<Integer>() {\n+            @Override\n+            public void accept(Integer v) throws Exception {\n+                between.add(Thread.currentThread().getName());\n+            }\n+        })\n+        .parallel(2, 1)\n+        .runOn(Schedulers.computation(), 1)\n+        .map(new Function<Integer, Object>() {\n+            @Override\n+            public Object apply(Integer v) throws Exception {\n+                processing.putIfAbsent(Thread.currentThread().getName(), \"\");\n+                return v;\n+            }\n+        })\n+        .sequential()\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertSubscribed()\n+        .assertValueSet(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n+        .assertComplete()\n+        .assertNoErrors()\n+        ;\n+\n+        assertEquals(between.toString(), 1, between.size());\n+        assertTrue(between.toString(), between.iterator().next().contains(\"RxSingleScheduler\"));\n+\n+        Map<String, String> map = processing; // AnimalSniffer: CHM.keySet() in Java 8 returns KeySetView\n+\n+        for (String e : map.keySet()) {\n+            assertTrue(map.toString(), e.contains(\"RxComputationThreadPool\"));\n+        }\n+    }\n }",
    "output": "Make parallel() a fusion-async-boundary"
  },
  {
    "input": "diff --git a/src/jmh/java/io/reactivex/PerfBoundedSubscriber.java b/src/jmh/java/io/reactivex/PerfBoundedSubscriber.java\n--- a/src/jmh/java/io/reactivex/PerfBoundedSubscriber.java\n+++ b/src/jmh/java/io/reactivex/PerfBoundedSubscriber.java\n@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Performance subscriber with a one-time request from the upstream.\n+ */\n+public class PerfBoundedSubscriber extends CountDownLatch implements FlowableSubscriber<Object> {\n+\n+    final Blackhole bh;\n+\n+    final long request;\n+\n+    public PerfBoundedSubscriber(Blackhole bh, long request) {\n+        super(1);\n+        this.bh = bh;\n+        this.request = request;\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription s) {\n+        s.request(request);\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        countDown();\n+    }\n+\n+    @Override\n+    public void onError(Throwable e) {\n+        countDown();\n+    }\n+\n+    @Override\n+    public void onNext(Object t) {\n+        bh.consume(t);\n+    }\n+\n+}\n\ndiff --git a/src/jmh/java/io/reactivex/PublishProcessorPerf.java b/src/jmh/java/io/reactivex/PublishProcessorPerf.java\n--- a/src/jmh/java/io/reactivex/PublishProcessorPerf.java\n+++ b/src/jmh/java/io/reactivex/PublishProcessorPerf.java\n@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import io.reactivex.processors.PublishProcessor;\n+import io.reactivex.subjects.PublishSubject;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@Fork(value = 1)\n+@State(Scope.Thread)\n+public class PublishProcessorPerf {\n+\n+    PublishProcessor<Integer> unbounded;\n+\n+    PublishProcessor<Integer> bounded;\n+\n+    PublishSubject<Integer> subject;\n+\n+    @Setup\n+    public void setup(Blackhole bh) {\n+        unbounded = PublishProcessor.create();\n+        unbounded.subscribe(new PerfConsumer(bh));\n+\n+        bounded = PublishProcessor.create();\n+        bounded.subscribe(new PerfBoundedSubscriber(bh, 1000 * 1000));\n+\n+        subject = PublishSubject.create();\n+        subject.subscribe(new PerfConsumer(bh));\n+    }\n+\n+    @Benchmark\n+    public void unbounded1() {\n+        unbounded.onNext(1);\n+    }\n+\n+    @Benchmark\n+    public void unbounded1k() {\n+        for (int i = 0; i < 1000; i++) {\n+            unbounded.onNext(1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void unbounded1m() {\n+        for (int i = 0; i < 1000000; i++) {\n+            unbounded.onNext(1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bounded1() {\n+        bounded.onNext(1);\n+    }\n+\n+\n+    @Benchmark\n+    public void bounded1k() {\n+        for (int i = 0; i < 1000; i++) {\n+            bounded.onNext(1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bounded1m() {\n+        for (int i = 0; i < 1000000; i++) {\n+            bounded.onNext(1);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void subject1() {\n+        subject.onNext(1);\n+    }\n+\n+\n+    @Benchmark\n+    public void subject1k() {\n+        for (int i = 0; i < 1000; i++) {\n+            subject.onNext(1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void subject1m() {\n+        for (int i = 0; i < 1000000; i++) {\n+            subject.onNext(1);\n+        }\n+    }\n+}",
    "output": "Add PublishProcessor JMH perf comparison"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/processors/PublishProcessor.java b/src/main/java/io/reactivex/processors/PublishProcessor.java\n--- a/src/main/java/io/reactivex/processors/PublishProcessor.java\n+++ b/src/main/java/io/reactivex/processors/PublishProcessor.java\n@@ -313,9 +313,7 @@ public void onNext(T t) {\n             }\n             if (r != 0L) {\n                 actual.onNext(t);\n-                if (r != Long.MAX_VALUE) {\n-                    decrementAndGet();\n-                }\n+                BackpressureHelper.producedCancel(this, 1);\n             } else {\n                 cancel();\n                 actual.onError(new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n\ndiff --git a/src/test/java/io/reactivex/processors/BehaviorProcessorTest.java b/src/test/java/io/reactivex/processors/BehaviorProcessorTest.java\n--- a/src/test/java/io/reactivex/processors/BehaviorProcessorTest.java\n+++ b/src/test/java/io/reactivex/processors/BehaviorProcessorTest.java\n@@ -812,4 +812,37 @@ public void run() {\n             ts.assertFailure(TestException.class);\n         }\n     }\n+\n+    @Test(timeout = 10000)\n+    public void subscriberCancelOfferRace() {\n+        for (int i = 0; i < 1000; i++) {\n+            final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();\n+\n+            final TestSubscriber<Integer> ts = pp.test(1);\n+\n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    for (int i = 0; i < 2; i++) {\n+                        while (!pp.offer(i)) ;\n+                    }\n+                }\n+            };\n+\n+            Runnable r2 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ts.cancel();\n+                }\n+            };\n+\n+            TestHelper.race(r1, r2);\n+\n+            if (ts.valueCount() > 0) {\n+                ts.assertValuesOnly(0);\n+            } else {\n+                ts.assertEmpty();\n+            }\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/processors/PublishProcessorTest.java b/src/test/java/io/reactivex/processors/PublishProcessorTest.java\n--- a/src/test/java/io/reactivex/processors/PublishProcessorTest.java\n+++ b/src/test/java/io/reactivex/processors/PublishProcessorTest.java\n@@ -677,4 +677,37 @@ public void run() {\n         .awaitDone(5, TimeUnit.SECONDS)\n         .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     }\n+\n+    @Test(timeout = 10000)\n+    public void subscriberCancelOfferRace() {\n+        for (int i = 0; i < 1000; i++) {\n+            final PublishProcessor<Integer> pp = PublishProcessor.create();\n+\n+            final TestSubscriber<Integer> ts = pp.test(1);\n+\n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    for (int i = 0; i < 2; i++) {\n+                        while (!pp.offer(i)) ;\n+                    }\n+                }\n+            };\n+\n+            Runnable r2 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ts.cancel();\n+                }\n+            };\n+\n+            TestHelper.race(r1, r2);\n+\n+            if (ts.valueCount() > 0) {\n+                ts.assertValuesOnly(0);\n+            } else {\n+                ts.assertEmpty();\n+            }\n+        }\n+    }\n }",
    "output": "Fix PublishProcessor cancel/emission overflow bug"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java\n--- a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java\n+++ b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java\n@@ -137,7 +137,7 @@ public static boolean set(AtomicReference<Subscription> field, Subscription s) {\n      * @return true if the operation succeeded, false if the target field was not null.\n      */\n     public static boolean setOnce(AtomicReference<Subscription> field, Subscription s) {\n-        ObjectHelper.requireNonNull(s, \"d is null\");\n+        ObjectHelper.requireNonNull(s, \"s is null\");\n         if (!field.compareAndSet(null, s)) {\n             s.cancel();\n             if (field.get() != CANCELLED) {",
    "output": "Fix incorrect error message at SubscriptionHelper.setOnce"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java\n--- a/src/main/java/io/reactivex/Single.java\n+++ b/src/main/java/io/reactivex/Single.java\n@@ -1617,32 +1617,53 @@ public final Flowable<T> concatWith(SingleSource<? extends T> other) {\n     }\n \n     /**\n-     * Delays the emission of the success or error signal from the current Single by\n-     * the specified amount.\n+     * Delays the emission of the success signal from the current Single by the specified amount.\n+     * An error signal will not be delayed.\n      * <dl>\n      * <dt><b>Scheduler:</b></dt>\n      * <dd>{@code delay} operates by default on the {@code computation} {@link Scheduler}.</dd>\n      * </dl>\n      *\n-     * @param time the time amount to delay the signals\n+     * @param time the amount of time the success signal should be delayed for\n      * @param unit the time unit\n      * @return the new Single instance\n      * @since 2.0\n      */\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.COMPUTATION)\n     public final Single<T> delay(long time, TimeUnit unit) {\n-        return delay(time, unit, Schedulers.computation());\n+        return delay(time, unit, Schedulers.computation(), false);\n+    }\n+\n+    /**\n+     * Delays the emission of the success or error signal from the current Single by the specified amount.\n+     * <dl>\n+     * <dt><b>Scheduler:</b></dt>\n+     * <dd>{@code delay} operates by default on the {@code computation} {@link Scheduler}.</dd>\n+     * </dl>\n+     *\n+     * @param time the amount of time the success or error signal should be delayed for\n+     * @param unit the time unit\n+     * @param delayError if true, both success and error signals are delayed. if false, only success signals are delayed.\n+     * @return the new Single instance\n+     * @since 2.1.5 - experimental\n+     */\n+    @Experimental\n+    @CheckReturnValue\n+    @SchedulerSupport(SchedulerSupport.COMPUTATION)\n+    public final Single<T> delay(long time, TimeUnit unit, boolean delayError) {\n+        return delay(time, unit, Schedulers.computation(), delayError);\n     }\n \n     /**\n      * Delays the emission of the success signal from the current Single by the specified amount.\n+     * An error signal will not be delayed.\n      * <dl>\n      * <dt><b>Scheduler:</b></dt>\n      * <dd>you specify the {@link Scheduler} where the non-blocking wait and emission happens</dd>\n      * </dl>\n      *\n-     * @param time the time amount to delay the emission of the success signal\n+     * @param time the amount of time the success signal should be delayed for\n      * @param unit the time unit\n      * @param scheduler the target scheduler to use for the non-blocking wait and emission\n      * @return the new Single instance\n@@ -1654,9 +1675,33 @@ public final Single<T> delay(long time, TimeUnit unit) {\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.CUSTOM)\n     public final Single<T> delay(final long time, final TimeUnit unit, final Scheduler scheduler) {\n+        return delay(time, unit, scheduler, false);\n+    }\n+\n+    /**\n+     * Delays the emission of the success or error signal from the current Single by the specified amount.\n+     * <dl>\n+     * <dt><b>Scheduler:</b></dt>\n+     * <dd>you specify the {@link Scheduler} where the non-blocking wait and emission happens</dd>\n+     * </dl>\n+     *\n+     * @param time the amount of time the success or error signal should be delayed for\n+     * @param unit the time unit\n+     * @param scheduler the target scheduler to use for the non-blocking wait and emission\n+     * @param delayError if true, both success and error signals are delayed. if false, only success signals are delayed.\n+     * @return the new Single instance\n+     * @throws NullPointerException\n+     *             if unit is null, or\n+     *             if scheduler is null\n+     * @since 2.1.5 - experimental\n+     */\n+    @Experimental\n+    @CheckReturnValue\n+    @SchedulerSupport(SchedulerSupport.CUSTOM)\n+    public final Single<T> delay(final long time, final TimeUnit unit, final Scheduler scheduler, boolean delayError) {\n         ObjectHelper.requireNonNull(unit, \"unit is null\");\n         ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n-        return RxJavaPlugins.onAssembly(new SingleDelay<T>(this, time, unit, scheduler));\n+        return RxJavaPlugins.onAssembly(new SingleDelay<T>(this, time, unit, scheduler, delayError));\n     }\n \n     /**\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java b/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java\n--- a/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java\n+++ b/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java\n@@ -21,17 +21,18 @@\n \n public final class SingleDelay<T> extends Single<T> {\n \n-\n     final SingleSource<? extends T> source;\n     final long time;\n     final TimeUnit unit;\n     final Scheduler scheduler;\n+    final boolean delayError;\n \n-    public SingleDelay(SingleSource<? extends T> source, long time, TimeUnit unit, Scheduler scheduler) {\n+    public SingleDelay(SingleSource<? extends T> source, long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {\n         this.source = source;\n         this.time = time;\n         this.unit = unit;\n         this.scheduler = scheduler;\n+        this.delayError = delayError;\n     }\n \n     @Override\n@@ -63,7 +64,7 @@ public void onSuccess(final T value) {\n \n         @Override\n         public void onError(final Throwable e) {\n-            sd.replace(scheduler.scheduleDirect(new OnError(e), 0, unit));\n+            sd.replace(scheduler.scheduleDirect(new OnError(e), delayError ? time : 0, unit));\n         }\n \n         final class OnSuccess implements Runnable {\n\ndiff --git a/src/test/java/io/reactivex/ParamValidationCheckerTest.java b/src/test/java/io/reactivex/ParamValidationCheckerTest.java\n--- a/src/test/java/io/reactivex/ParamValidationCheckerTest.java\n+++ b/src/test/java/io/reactivex/ParamValidationCheckerTest.java\n@@ -312,7 +312,9 @@ public void checkParallelFlowable() {\n \n         // negative time is considered as zero time\n         addOverride(new ParamOverride(Single.class, 0, ParamMode.ANY, \"delay\", Long.TYPE, TimeUnit.class));\n+        addOverride(new ParamOverride(Single.class, 0, ParamMode.ANY, \"delay\", Long.TYPE, TimeUnit.class, Boolean.TYPE));\n         addOverride(new ParamOverride(Single.class, 0, ParamMode.ANY, \"delay\", Long.TYPE, TimeUnit.class, Scheduler.class));\n+        addOverride(new ParamOverride(Single.class, 0, ParamMode.ANY, \"delay\", Long.TYPE, TimeUnit.class, Scheduler.class, Boolean.TYPE));\n \n \n         // zero repeat is allowed\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/single/SingleDelayTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleDelayTest.java\n--- a/src/test/java/io/reactivex/internal/operators/single/SingleDelayTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/single/SingleDelayTest.java\n@@ -27,38 +27,64 @@\n import io.reactivex.exceptions.TestException;\n import io.reactivex.functions.*;\n import io.reactivex.internal.subscriptions.BooleanSubscription;\n+import io.reactivex.observers.TestObserver;\n import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.schedulers.Schedulers;\n+import io.reactivex.schedulers.TestScheduler;\n import io.reactivex.subjects.PublishSubject;\n \n public class SingleDelayTest {\n     @Test\n-    public void delay() throws Exception {\n-        final AtomicInteger value = new AtomicInteger();\n+    public void delayOnSuccess() {\n+        final TestScheduler scheduler = new TestScheduler();\n+        final TestObserver<Integer> observer = Single.just(1)\n+            .delay(5, TimeUnit.SECONDS, scheduler)\n+            .test();\n \n-        Single.just(1).delay(200, TimeUnit.MILLISECONDS)\n-        .subscribe(new BiConsumer<Integer, Throwable>() {\n-            @Override\n-            public void accept(Integer v, Throwable e) throws Exception {\n-                value.set(v);\n-            }\n-        });\n+        scheduler.advanceTimeTo(2, TimeUnit.SECONDS);\n+        observer.assertNoValues();\n \n-        Thread.sleep(100);\n+        scheduler.advanceTimeTo(5, TimeUnit.SECONDS);\n+        observer.assertValue(1);\n+    }\n+\n+    @Test\n+    public void delayOnError() {\n+        final TestScheduler scheduler = new TestScheduler();\n+        final TestObserver<?> observer = Single.error(new TestException())\n+            .delay(5, TimeUnit.SECONDS, scheduler)\n+            .test();\n+\n+        scheduler.triggerActions();\n+        observer.assertError(TestException.class);\n+    }\n \n-        assertEquals(0, value.get());\n+    @Test\n+    public void delayedErrorOnSuccess() {\n+        final TestScheduler scheduler = new TestScheduler();\n+        final TestObserver<Integer> observer = Single.just(1)\n+            .delay(5, TimeUnit.SECONDS, scheduler, true)\n+            .test();\n \n-        Thread.sleep(200);\n+        scheduler.advanceTimeTo(2, TimeUnit.SECONDS);\n+        observer.assertNoValues();\n \n-        assertEquals(1, value.get());\n+        scheduler.advanceTimeTo(5, TimeUnit.SECONDS);\n+        observer.assertValue(1);\n     }\n \n     @Test\n-    public void delayError() {\n-        Single.error(new TestException()).delay(5, TimeUnit.SECONDS)\n-        .test()\n-        .awaitDone(1, TimeUnit.SECONDS)\n-        .assertFailure(TestException.class);\n+    public void delayedErrorOnError() {\n+        final TestScheduler scheduler = new TestScheduler();\n+        final TestObserver<?> observer = Single.error(new TestException())\n+            .delay(5, TimeUnit.SECONDS, scheduler, true)\n+            .test();\n+\n+        scheduler.advanceTimeTo(2, TimeUnit.SECONDS);\n+        observer.assertNoErrors();\n+\n+        scheduler.advanceTimeTo(5, TimeUnit.SECONDS);\n+        observer.assertError(TestException.class);\n     }\n \n     @Test",
    "output": "Add Single.delay overload that delays errors"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java\n@@ -24,6 +24,7 @@\n import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.fuseable.*;\n import io.reactivex.internal.observers.*;\n+import io.reactivex.internal.queue.SpscLinkedArrayQueue;\n import io.reactivex.internal.util.*;\n import io.reactivex.plugins.RxJavaPlugins;\n \n@@ -129,7 +130,7 @@ public void onSubscribe(Disposable d) {\n                     }\n                 }\n \n-                queue = QueueDrainHelper.createQueue(prefetch);\n+                queue = new SpscLinkedArrayQueue<T>(prefetch);\n \n                 actual.onSubscribe(this);\n             }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n@@ -1193,4 +1193,39 @@ public Flowable<Integer> apply(Integer i) throws Exception {\n         .assertResult(1, 2, 3, 4, 5)\n         ;\n     }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void maxConcurrencyOf2() {\n+        List<Integer>[] list = new ArrayList[100];\n+        for (int i = 0; i < 100; i++) {\n+            List<Integer> lst = new ArrayList<Integer>();\n+            list[i] = lst;\n+            for (int k = 1; k <= 10; k++) {\n+                lst.add((i) * 10 + k);\n+            }\n+        }\n+\n+        Flowable.range(1, 1000)\n+        .buffer(10)\n+        .concatMapEager(new Function<List<Integer>, Flowable<List<Integer>>>() {\n+            @Override\n+            public Flowable<List<Integer>> apply(List<Integer> v)\n+                    throws Exception {\n+                return Flowable.just(v)\n+                        .subscribeOn(Schedulers.io())\n+                        .doOnNext(new Consumer<List<Integer>>() {\n+                            @Override\n+                            public void accept(List<Integer> v)\n+                                    throws Exception {\n+                                Thread.sleep(new Random().nextInt(20));\n+                            }\n+                        });\n+            }\n+        }\n+                , 2, 3)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult(list);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java\n@@ -1001,4 +1001,39 @@ public ObservableSource<Integer> apply(Integer i) throws Exception {\n         .assertResult(1, 2, 3, 4, 5)\n         ;\n     }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void maxConcurrencyOf2() {\n+        List<Integer>[] list = new ArrayList[100];\n+        for (int i = 0; i < 100; i++) {\n+            List<Integer> lst = new ArrayList<Integer>();\n+            list[i] = lst;\n+            for (int k = 1; k <= 10; k++) {\n+                lst.add((i) * 10 + k);\n+            }\n+        }\n+\n+        Observable.range(1, 1000)\n+        .buffer(10)\n+        .concatMapEager(new Function<List<Integer>, ObservableSource<List<Integer>>>() {\n+            @Override\n+            public ObservableSource<List<Integer>> apply(List<Integer> v)\n+                    throws Exception {\n+                return Observable.just(v)\n+                        .subscribeOn(Schedulers.io())\n+                        .doOnNext(new Consumer<List<Integer>>() {\n+                            @Override\n+                            public void accept(List<Integer> v)\n+                                    throws Exception {\n+                                Thread.sleep(new Random().nextInt(20));\n+                            }\n+                        });\n+            }\n+        }\n+                , 2, 3)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult(list);\n+    }\n }",
    "output": "Fix Observable.concatMapEager queueing of source items"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/observers/BaseTestConsumer.java b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n--- a/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n@@ -567,20 +567,20 @@ public final U assertValueSet(Collection<? extends T> expected) {\n     @SuppressWarnings(\"unchecked\")\n     public final U assertValueSequence(Iterable<? extends T> sequence) {\n         int i = 0;\n-        Iterator<T> vit = values.iterator();\n-        Iterator<? extends T> it = sequence.iterator();\n+        Iterator<T> actualIterator = values.iterator();\n+        Iterator<? extends T> expectedIterator = sequence.iterator();\n         boolean actualNext;\n         boolean expectedNext;\n         for (;;) {\n-            actualNext = it.hasNext();\n-            expectedNext = vit.hasNext();\n+            expectedNext = expectedIterator.hasNext();\n+            actualNext = actualIterator.hasNext();\n \n             if (!actualNext || !expectedNext) {\n                 break;\n             }\n \n-            T v = it.next();\n-            T u = vit.next();\n+            T u = expectedIterator.next();\n+            T v = actualIterator.next();\n \n             if (!ObjectHelper.equals(u, v)) {\n                 throw fail(\"Values at position \" + i + \" differ; Expected: \" + valueAndClass(u) + \", Actual: \" + valueAndClass(v));\n\ndiff --git a/src/test/java/io/reactivex/observers/TestObserverTest.java b/src/test/java/io/reactivex/observers/TestObserverTest.java\n--- a/src/test/java/io/reactivex/observers/TestObserverTest.java\n+++ b/src/test/java/io/reactivex/observers/TestObserverTest.java\n@@ -956,24 +956,24 @@ public void assertValueSequence() {\n         try {\n             ts.assertValueSequence(Collections.<Integer>emptyList());\n             throw new RuntimeException(\"Should have thrown\");\n-        } catch (AssertionError ex) {\n-            // expected\n+        } catch (AssertionError expected) {\n+            assertTrue(expected.getMessage(), expected.getMessage().startsWith(\"More values received than expected (0)\"));\n         }\n \n         try {\n             ts.assertValueSequence(Collections.singletonList(1));\n             throw new RuntimeException(\"Should have thrown\");\n-        } catch (AssertionError ex) {\n-            // expected\n+        } catch (AssertionError expected) {\n+            assertTrue(expected.getMessage(), expected.getMessage().startsWith(\"More values received than expected (1)\"));\n         }\n \n         ts.assertValueSequence(Arrays.asList(1, 2));\n \n         try {\n             ts.assertValueSequence(Arrays.asList(1, 2, 3));\n             throw new RuntimeException(\"Should have thrown\");\n-        } catch (AssertionError ex) {\n-            // expected\n+        } catch (AssertionError expected) {\n+            assertTrue(expected.getMessage(), expected.getMessage().startsWith(\"Fewer values received than expected (2)\"));\n         }\n     }\n ",
    "output": "Fix assertValueSequence reversed error message * fix assertValueSequence reversed error message * Fix variable naming instead * Adjust according to the feedback"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/observers/BaseTestConsumer.java b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n--- a/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n@@ -522,6 +522,21 @@ public final U assertValues(T... values) {\n         return (U)this;\n     }\n \n+    /**\n+     * Assert that the TestObserver/TestSubscriber received only the specified values in the specified order without terminating.\n+     * @param values the values expected\n+     * @return this;\n+     * @since 2.1.4\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Experimental\n+    public final U assertValuesOnly(T... values) {\n+        return assertSubscribed()\n+                .assertValues(values)\n+                .assertNoErrors()\n+                .assertNotComplete();\n+    }\n+\n     /**\n      * Assert that the TestObserver/TestSubscriber received only the specified values in any order.\n      * <p>This helps asserting when the order of the values is not guaranteed, i.e., when merging\n\ndiff --git a/src/test/java/io/reactivex/observers/TestObserverTest.java b/src/test/java/io/reactivex/observers/TestObserverTest.java\n--- a/src/test/java/io/reactivex/observers/TestObserverTest.java\n+++ b/src/test/java/io/reactivex/observers/TestObserverTest.java\n@@ -1439,4 +1439,66 @@ public void withTag() {\n             assertTrue(ex.toString(), ex.toString().contains(\"testing with item=2\"));\n         }\n     }\n+\n+    @Test\n+    public void assertValuesOnly() {\n+        TestObserver<Integer> to = TestObserver.create();\n+        to.onSubscribe(Disposables.empty());\n+        to.assertValuesOnly();\n+\n+        to.onNext(5);\n+        to.assertValuesOnly(5);\n+\n+        to.onNext(-1);\n+        to.assertValuesOnly(5, -1);\n+    }\n+\n+    @Test\n+    public void assertValuesOnlyThrowsOnUnexpectedValue() {\n+        TestObserver<Integer> to = TestObserver.create();\n+        to.onSubscribe(Disposables.empty());\n+        to.assertValuesOnly();\n+\n+        to.onNext(5);\n+        to.assertValuesOnly(5);\n+\n+        to.onNext(-1);\n+\n+        try {\n+            to.assertValuesOnly(5);\n+            fail();\n+        } catch (AssertionError ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void assertValuesOnlyThrowsWhenCompleted() {\n+        TestObserver<Integer> to = TestObserver.create();\n+        to.onSubscribe(Disposables.empty());\n+\n+        to.onComplete();\n+\n+        try {\n+            to.assertValuesOnly();\n+            fail();\n+        } catch (AssertionError ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void assertValuesOnlyThrowsWhenErrored() {\n+        TestObserver<Integer> to = TestObserver.create();\n+        to.onSubscribe(Disposables.empty());\n+\n+        to.onError(new TestException());\n+\n+        try {\n+            to.assertValuesOnly();\n+            fail();\n+        } catch (AssertionError ex) {\n+            // expected\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java b/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n--- a/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n+++ b/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n@@ -1997,4 +1997,66 @@ public void waitStrategyRuns() {\n             ws.run();\n         }\n     }\n+\n+    @Test\n+    public void assertValuesOnly() {\n+        TestSubscriber<Integer> ts = TestSubscriber.create();\n+        ts.onSubscribe(new BooleanSubscription());\n+        ts.assertValuesOnly();\n+\n+        ts.onNext(5);\n+        ts.assertValuesOnly(5);\n+\n+        ts.onNext(-1);\n+        ts.assertValuesOnly(5, -1);\n+    }\n+\n+    @Test\n+    public void assertValuesOnlyThrowsOnUnexpectedValue() {\n+        TestSubscriber<Integer> ts = TestSubscriber.create();\n+        ts.onSubscribe(new BooleanSubscription());\n+        ts.assertValuesOnly();\n+\n+        ts.onNext(5);\n+        ts.assertValuesOnly(5);\n+\n+        ts.onNext(-1);\n+\n+        try {\n+            ts.assertValuesOnly(5);\n+            fail();\n+        } catch (AssertionError ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void assertValuesOnlyThrowsWhenCompleted() {\n+        TestSubscriber<Integer> ts = TestSubscriber.create();\n+        ts.onSubscribe(new BooleanSubscription());\n+\n+        ts.onComplete();\n+\n+        try {\n+            ts.assertValuesOnly();\n+            fail();\n+        } catch (AssertionError ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void assertValuesOnlyThrowsWhenErrored() {\n+        TestSubscriber<Integer> ts = TestSubscriber.create();\n+        ts.onSubscribe(new BooleanSubscription());\n+\n+        ts.onError(new TestException());\n+\n+        try {\n+            ts.assertValuesOnly();\n+            fail();\n+        } catch (AssertionError ex) {\n+            // expected\n+        }\n+    }\n }",
    "output": "Add assertValuesOnly to BaseTestConsumer.\n\n* Add assertValuesOnly to BaseTestConsumer.\r\n\r\n* Address comments"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromActionTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromActionTest.java\n--- a/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromActionTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromActionTest.java\n@@ -135,16 +135,14 @@ public void noErrorLoss() throws Exception {\n                 @Override\n                 public void run() throws Exception {\n                     cdl1.countDown();\n-                    cdl2.await();\n+                    cdl2.await(5, TimeUnit.SECONDS);\n                 }\n             }).subscribeOn(Schedulers.single()).test();\n \n             assertTrue(cdl1.await(5, TimeUnit.SECONDS));\n \n             to.cancel();\n \n-            cdl2.countDown();\n-\n             int timeout = 10;\n \n             while (timeout-- > 0 && errors.isEmpty()) {\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromCallableTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromCallableTest.java\n--- a/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromCallableTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromCallableTest.java\n@@ -138,7 +138,7 @@ public void noErrorLoss() throws Exception {\n                 @Override\n                 public Integer call() throws Exception {\n                     cdl1.countDown();\n-                    cdl2.await();\n+                    cdl2.await(5, TimeUnit.SECONDS);\n                     return 1;\n                 }\n             }).subscribeOn(Schedulers.single()).test();\n@@ -147,8 +147,6 @@ public Integer call() throws Exception {\n \n             to.cancel();\n \n-            cdl2.countDown();\n-\n             int timeout = 10;\n \n             while (timeout-- > 0 && errors.isEmpty()) {\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromRunnableTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromRunnableTest.java\n--- a/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromRunnableTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromRunnableTest.java\n@@ -134,7 +134,7 @@ public void noErrorLoss() throws Exception {\n                 public void run() {\n                     cdl1.countDown();\n                     try {\n-                        cdl2.await();\n+                        cdl2.await(5, TimeUnit.SECONDS);\n                     } catch (InterruptedException ex) {\n                         throw new RuntimeException(ex);\n                     }\n@@ -145,8 +145,6 @@ public void run() {\n \n             to.cancel();\n \n-            cdl2.countDown();\n-\n             int timeout = 10;\n \n             while (timeout-- > 0 && errors.isEmpty()) {",
    "output": "Fix flaky MaybeFromCallableTest.noErrorLoss\n\n* Fix flaky MaybeFromCallableTest.noErrorLoss\r\n\r\n* Fix the same error in 2 other Maybe tests"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/observers/BaseTestConsumer.java b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n--- a/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n@@ -17,6 +17,7 @@\n import java.util.concurrent.*;\n \n import io.reactivex.Notification;\n+import io.reactivex.annotations.Experimental;\n import io.reactivex.disposables.Disposable;\n import io.reactivex.exceptions.CompositeException;\n import io.reactivex.functions.Predicate;\n@@ -335,7 +336,7 @@ public final U assertValue(T value) {\n \n     /**\n      * Assert that this TestObserver/TestSubscriber did not receive an onNext value which is equal to\n-     * the given value with respect to Objects.equals.\n+     * the given value with respect to null-safe Object.equals.\n      *\n      * <p>History: 2.0.5 - experimental\n      * @param value the value to expect not being received\n@@ -401,6 +402,33 @@ public final U assertNever(Predicate<? super T> valuePredicate) {\n         return (U)this;\n     }\n \n+    /**\n+     * Asserts that this TestObserver/TestSubscriber received an onNext value at the given index\n+     * which is equal to the given value with respect to null-safe Object.equals.\n+     * @param index the position to assert on\n+     * @param value the value to expect\n+     * @return this\n+     * @since 2.1.3 - experimental\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Experimental\n+    public final U assertValueAt(int index, T value) {\n+        int s = values.size();\n+        if (s == 0) {\n+            throw fail(\"No values\");\n+        }\n+\n+        if (index >= s) {\n+            throw fail(\"Invalid index: \" + index);\n+        }\n+\n+        T v = values.get(index);\n+        if (!ObjectHelper.equals(value, v)) {\n+            throw fail(\"Expected: \" + valueAndClass(value) + \", Actual: \" + valueAndClass(v));\n+        }\n+        return (U)this;\n+    }\n+\n     /**\n      * Asserts that this TestObserver/TestSubscriber received an onNext value at the given index\n      * for the provided predicate returns true.\n\ndiff --git a/src/test/java/io/reactivex/observers/TestObserverTest.java b/src/test/java/io/reactivex/observers/TestObserverTest.java\n--- a/src/test/java/io/reactivex/observers/TestObserverTest.java\n+++ b/src/test/java/io/reactivex/observers/TestObserverTest.java\n@@ -1382,6 +1382,48 @@ public void assertValueAtInvalidIndex() {\n         });\n     }\n \n+    @Test\n+    public void assertValueAtIndexEmpty() {\n+        TestObserver<Object> ts = new TestObserver<Object>();\n+\n+        Observable.empty().subscribe(ts);\n+\n+        thrown.expect(AssertionError.class);\n+        thrown.expectMessage(\"No values\");\n+        ts.assertValueAt(0, \"a\");\n+    }\n+\n+    @Test\n+    public void assertValueAtIndexMatch() {\n+        TestObserver<String> ts = new TestObserver<String>();\n+\n+        Observable.just(\"a\", \"b\").subscribe(ts);\n+\n+        ts.assertValueAt(1, \"b\");\n+    }\n+\n+    @Test\n+    public void assertValueAtIndexNoMatch() {\n+        TestObserver<String> ts = new TestObserver<String>();\n+\n+        Observable.just(\"a\", \"b\", \"c\").subscribe(ts);\n+\n+        thrown.expect(AssertionError.class);\n+        thrown.expectMessage(\"Expected: b (class: String), Actual: c (class: String) (latch = 0, values = 3, errors = 0, completions = 1)\");\n+        ts.assertValueAt(2, \"b\");\n+    }\n+\n+    @Test\n+    public void assertValueAtIndexInvalidIndex() {\n+        TestObserver<String> ts = new TestObserver<String>();\n+\n+        Observable.just(\"a\", \"b\").subscribe(ts);\n+\n+        thrown.expect(AssertionError.class);\n+        thrown.expectMessage(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\");\n+        ts.assertValueAt(2, \"c\");\n+    }\n+\n     @Test\n     public void withTag() {\n         try {",
    "output": "Add assertValueAt(int, value) to TestObserver\n\n* Add assertValueAt(int, value) to TestObserver\r\n\r\n* Fix test to call correct method\r\n\r\n* David's comments\r\n\r\n* Artem's comments\r\n\r\n* Try fixing Travis CI lack of java\r\n\r\n* Try fixing Travis CI lack of java\r\n\r\n* Force dist: precise\r\n\r\n* Oracle JDK 8 is then"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java\n--- a/src/main/java/io/reactivex/Single.java\n+++ b/src/main/java/io/reactivex/Single.java\n@@ -1752,15 +1752,14 @@ public final <U> Single<T> delaySubscription(Publisher<U> other) {\n      * <dd>{@code delaySubscription} does by default subscribe to the current Single\n      * on the {@code computation} {@link Scheduler} after the delay.</dd>\n      * </dl>\n-     * @param <U> the element type of the other source\n      * @param time the time amount to wait with the subscription\n      * @param unit the time unit of the waiting\n      * @return the new Single instance\n      * @since 2.0\n      */\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.COMPUTATION)\n-    public final <U> Single<T> delaySubscription(long time, TimeUnit unit) {\n+    public final Single<T> delaySubscription(long time, TimeUnit unit) {\n         return delaySubscription(time, unit, Schedulers.computation());\n     }\n \n@@ -1771,7 +1770,6 @@ public final <U> Single<T> delaySubscription(long time, TimeUnit unit) {\n      * <dd>{@code delaySubscription} does by default subscribe to the current Single\n      * on the {@link Scheduler} you provided, after the delay.</dd>\n      * </dl>\n-     * @param <U> the element type of the other source\n      * @param time the time amount to wait with the subscription\n      * @param unit the time unit of the waiting\n      * @param scheduler the scheduler to wait on and subscribe on to the current Single\n@@ -1780,7 +1778,7 @@ public final <U> Single<T> delaySubscription(long time, TimeUnit unit) {\n      */\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.CUSTOM)\n-    public final <U> Single<T> delaySubscription(long time, TimeUnit unit, Scheduler scheduler) {\n+    public final Single<T> delaySubscription(long time, TimeUnit unit, Scheduler scheduler) {\n         return delaySubscription(Observable.timer(time, unit, scheduler));\n     }\n ",
    "output": "Remove unnecessary generic type parameters for delaySubscription methods in Single"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java\n--- a/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java\n+++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java\n@@ -114,8 +114,11 @@ private void soNext(AtomicReferenceArray<Object> curr, AtomicReferenceArray<Obje\n         soElement(curr, calcDirectOffset(curr.length() - 1), next);\n     }\n     @SuppressWarnings(\"unchecked\")\n-    private AtomicReferenceArray<Object> lvNext(AtomicReferenceArray<Object> curr) {\n-        return (AtomicReferenceArray<Object>)lvElement(curr, calcDirectOffset(curr.length() - 1));\n+    private AtomicReferenceArray<Object> lvNextBufferAndUnlink(AtomicReferenceArray<Object> curr, int nextIndex) {\n+        int nextOffset = calcDirectOffset(nextIndex);\n+        AtomicReferenceArray<Object> nextBuffer = (AtomicReferenceArray<Object>)lvElement(curr, nextOffset);\n+        soElement(curr, nextOffset, null); // Avoid GC nepotism\n+        return nextBuffer;\n     }\n     /**\n      * {@inheritDoc}\n@@ -138,7 +141,7 @@ public T poll() {\n             soConsumerIndex(index + 1);// this ensures correctness on 32bit platforms\n             return (T) e;\n         } else if (isNextBuffer) {\n-            return newBufferPoll(lvNext(buffer), index, mask);\n+            return newBufferPoll(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);\n         }\n \n         return null;\n@@ -164,7 +167,7 @@ public T peek() {\n         final int offset = calcWrappedOffset(index, mask);\n         final Object e = lvElement(buffer, offset);// LoadLoad\n         if (e == HAS_NEXT) {\n-            return newBufferPeek(lvNext(buffer), index, mask);\n+            return newBufferPeek(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);\n         }\n \n         return (T) e;\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java\n@@ -42,7 +42,7 @@ public class FlowableRefCountTest {\n     public void testRefCountAsync() {\n         final AtomicInteger subscribeCount = new AtomicInteger();\n         final AtomicInteger nextCount = new AtomicInteger();\n-        Flowable<Long> r = Flowable.interval(0, 5, TimeUnit.MILLISECONDS)\n+        Flowable<Long> r = Flowable.interval(0, 20, TimeUnit.MILLISECONDS)\n                 .doOnSubscribe(new Consumer<Subscription>() {\n                     @Override\n                     public void accept(Subscription s) {\n@@ -67,12 +67,27 @@ public void accept(Long l) {\n \n         Disposable s2 = r.subscribe();\n \n-        // give time to emit\n         try {\n-            Thread.sleep(52);\n+            Thread.sleep(10);\n         } catch (InterruptedException e) {\n         }\n \n+        for (;;) {\n+            int a = nextCount.get();\n+            int b = receivedCount.get();\n+            if (a > 10 && a < 20 && a == b) {\n+                break;\n+            }\n+            if (a >= 20) {\n+                break;\n+            }\n+            try {\n+                Thread.sleep(20);\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+        // give time to emit\n+\n         // now unsubscribe\n         s2.dispose(); // unsubscribe s2 first as we're counting in 1 and there can be a race between unsubscribe and one subscriber getting a value but not the other\n         s1.dispose();\n\ndiff --git a/src/test/java/io/reactivex/internal/queue/SimpleQueueTest.java b/src/test/java/io/reactivex/internal/queue/SimpleQueueTest.java\n--- a/src/test/java/io/reactivex/internal/queue/SimpleQueueTest.java\n+++ b/src/test/java/io/reactivex/internal/queue/SimpleQueueTest.java\n@@ -20,7 +20,7 @@\n \n import static org.junit.Assert.*;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.*;\n \n import org.junit.Test;\n \n@@ -155,4 +155,23 @@ public void run() {\n         t1.join();\n         t2.join();\n     }\n+\n+    @Test\n+    public void spscLinkedArrayQueueNoNepotism() {\n+        SpscLinkedArrayQueue<Integer> q = new SpscLinkedArrayQueue<Integer>(16);\n+\n+        AtomicReferenceArray<Object> ara = q.producerBuffer;\n+\n+        for (int i = 0; i < 20; i++) {\n+            q.offer(i);\n+        }\n+\n+        assertNotNull(ara.get(16));\n+\n+        for (int i = 0; i < 20; i++) {\n+            assertEquals(i, q.poll().intValue());\n+        }\n+\n+        assertNull(ara.get(16));\n+    }\n }",
    "output": "Fix SpscLAQ nepotism, FlowableRefCountTest.testRefCountAsync flaky"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java\n@@ -68,7 +68,7 @@ static final class TimeoutTimedOtherSubscriber<T> implements FlowableSubscriber<\n \n         final FullArbiter<T> arbiter;\n \n-        final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();\n+        Disposable timer;\n \n         volatile long index;\n \n@@ -110,16 +110,11 @@ public void onNext(T t) {\n         }\n \n         void scheduleTimeout(final long idx) {\n-            Disposable d = timer.get();\n-            if (d != null) {\n-                d.dispose();\n+            if (timer != null) {\n+                timer.dispose();\n             }\n \n-            if (timer.compareAndSet(d, NEW_TIMER)) {\n-                d = worker.schedule(new TimeoutTask(idx), timeout, unit);\n-\n-                DisposableHelper.replace(timer, d);\n-            }\n+            timer = worker.schedule(new TimeoutTask(idx), timeout, unit);\n         }\n \n         void subscribeNext() {\n@@ -170,11 +165,10 @@ public void run() {\n                 if (idx == index) {\n                     done = true;\n                     s.cancel();\n-                    DisposableHelper.dispose(timer);\n+                    worker.dispose();\n \n                     subscribeNext();\n \n-                    worker.dispose();\n                 }\n             }\n         }\n@@ -188,7 +182,7 @@ static final class TimeoutTimedSubscriber<T> implements FlowableSubscriber<T>, D\n \n         Subscription s;\n \n-        final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();\n+        Disposable timer;\n \n         volatile long index;\n \n@@ -224,16 +218,11 @@ public void onNext(T t) {\n         }\n \n         void scheduleTimeout(final long idx) {\n-            Disposable d = timer.get();\n-            if (d != null) {\n-                d.dispose();\n+            if (timer != null) {\n+                timer.dispose();\n             }\n \n-            if (timer.compareAndSet(d, NEW_TIMER)) {\n-                d = worker.schedule(new TimeoutTask(idx), timeout, unit);\n-\n-                DisposableHelper.replace(timer, d);\n-            }\n+            timer = worker.schedule(new TimeoutTask(idx), timeout, unit);\n         }\n \n         @Override",
    "output": "Use a mutable field in FlowableTimeoutTimed instead of an AtomicReference"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/functions/Function.java b/src/main/java/io/reactivex/functions/Function.java\n--- a/src/main/java/io/reactivex/functions/Function.java\n+++ b/src/main/java/io/reactivex/functions/Function.java\n@@ -29,6 +29,5 @@ public interface Function<T, R> {\n      * @return the output value\n      * @throws Exception on error\n      */\n-    @NonNull\n     R apply(@NonNull T t) throws Exception;\n }",
    "output": "Remove the @NonNull annotation from Function\n\nAs per per the discussion in #5447"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java b/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java\n--- a/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java\n+++ b/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java\n@@ -57,6 +57,9 @@ private SchedulerPoolFactory() {\n      * Starts the purge thread if not already started.\n      */\n     public static void start() {\n+        if (!PURGE_ENABLED) {\n+            return;\n+        }\n         for (;;) {\n             ScheduledExecutorService curr = PURGE_THREAD.get();\n             if (curr != null && !curr.isShutdown()) {\n@@ -78,7 +81,10 @@ public static void start() {\n      * Stops the purge thread.\n      */\n     public static void shutdown() {\n-        PURGE_THREAD.get().shutdownNow();\n+        ScheduledExecutorService exec = PURGE_THREAD.get();\n+        if (exec != null) {\n+            exec.shutdownNow();\n+        }\n         POOLS.clear();\n     }\n \n@@ -90,10 +96,10 @@ public static void shutdown() {\n \n         if (properties.containsKey(PURGE_ENABLED_KEY)) {\n             purgeEnable = Boolean.getBoolean(PURGE_ENABLED_KEY);\n+        }\n \n-            if (purgeEnable && properties.containsKey(PURGE_PERIOD_SECONDS_KEY)) {\n-                purgePeriod = Integer.getInteger(PURGE_PERIOD_SECONDS_KEY, purgePeriod);\n-            }\n+        if (purgeEnable && properties.containsKey(PURGE_PERIOD_SECONDS_KEY)) {\n+            purgePeriod = Integer.getInteger(PURGE_PERIOD_SECONDS_KEY, purgePeriod);\n         }\n \n         PURGE_ENABLED = purgeEnable;\n@@ -109,7 +115,7 @@ public static void shutdown() {\n      */\n     public static ScheduledExecutorService create(ThreadFactory factory) {\n         final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory);\n-        if (exec instanceof ScheduledThreadPoolExecutor) {\n+        if (PURGE_ENABLED && exec instanceof ScheduledThreadPoolExecutor) {\n             ScheduledThreadPoolExecutor e = (ScheduledThreadPoolExecutor) exec;\n             POOLS.put(e, exec);\n         }",
    "output": "Fix periodic scheduler purging config not honored"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/functions/Consumer.java b/src/main/java/io/reactivex/functions/Consumer.java\n--- a/src/main/java/io/reactivex/functions/Consumer.java\n+++ b/src/main/java/io/reactivex/functions/Consumer.java\n@@ -13,8 +13,6 @@\n \n package io.reactivex.functions;\n \n-import io.reactivex.annotations.NonNull;\n-\n /**\n  * A functional interface (callback) that accepts a single value.\n  * @param <T> the value type\n@@ -25,5 +23,5 @@ public interface Consumer<T> {\n      * @param t the value\n      * @throws Exception on error\n      */\n-    void accept(@NonNull T t) throws Exception;\n+    void accept(T t) throws Exception;\n }",
    "output": "Remove @NonNull annotation in Consumer method parameter\n\nThis fixes #5442"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/processors/ReplayProcessor.java b/src/main/java/io/reactivex/processors/ReplayProcessor.java\n--- a/src/main/java/io/reactivex/processors/ReplayProcessor.java\n+++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java\n@@ -1052,6 +1052,11 @@ public T getValue() {\n                 h = next;\n             }\n \n+            long limit = scheduler.now(unit) - maxAge;\n+            if (h.time < limit) {\n+                return null;\n+            }\n+\n             Object v = h.value;\n             if (v == null) {\n                 return null;\n\ndiff --git a/src/main/java/io/reactivex/subjects/ReplaySubject.java b/src/main/java/io/reactivex/subjects/ReplaySubject.java\n--- a/src/main/java/io/reactivex/subjects/ReplaySubject.java\n+++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java\n@@ -1018,6 +1018,11 @@ public T getValue() {\n                 h = next;\n             }\n \n+            long limit = scheduler.now(unit) - maxAge;\n+            if (h.time < limit) {\n+                return null;\n+            }\n+\n             Object v = h.value;\n             if (v == null) {\n                 return null;\n\ndiff --git a/src/test/java/io/reactivex/processors/ReplayProcessorTest.java b/src/test/java/io/reactivex/processors/ReplayProcessorTest.java\n--- a/src/test/java/io/reactivex/processors/ReplayProcessorTest.java\n+++ b/src/test/java/io/reactivex/processors/ReplayProcessorTest.java\n@@ -1030,6 +1030,26 @@ public void peekStateTimeAndSizeValue() {\n         assertNull(rp.getValues(new Integer[2])[0]);\n     }\n \n+    @Test\n+    public void peekStateTimeAndSizeValueExpired() {\n+        TestScheduler scheduler = new TestScheduler();\n+        ReplayProcessor<Integer> rp = ReplayProcessor.createWithTime(1, TimeUnit.DAYS, scheduler);\n+\n+        assertNull(rp.getValue());\n+        assertNull(rp.getValues(new Integer[2])[0]);\n+\n+        rp.onNext(2);\n+\n+        assertEquals((Integer)2, rp.getValue());\n+        assertEquals(2, rp.getValues()[0]);\n+\n+        scheduler.advanceTimeBy(2, TimeUnit.DAYS);\n+\n+        assertEquals(null, rp.getValue());\n+        assertEquals(0, rp.getValues().length);\n+        assertNull(rp.getValues(new Integer[2])[0]);\n+    }\n+\n     @Test\n     public void capacityHint() {\n         ReplayProcessor<Integer> rp = ReplayProcessor.create(8);\n\ndiff --git a/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java b/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java\n--- a/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java\n+++ b/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java\n@@ -931,6 +931,26 @@ public void peekStateTimeAndSizeValue() {\n         assertNull(rp.getValues(new Integer[2])[0]);\n     }\n \n+    @Test\n+    public void peekStateTimeAndSizeValueExpired() {\n+        TestScheduler scheduler = new TestScheduler();\n+        ReplaySubject<Integer> rp = ReplaySubject.createWithTime(1, TimeUnit.DAYS, scheduler);\n+\n+        assertNull(rp.getValue());\n+        assertNull(rp.getValues(new Integer[2])[0]);\n+\n+        rp.onNext(2);\n+\n+        assertEquals((Integer)2, rp.getValue());\n+        assertEquals(2, rp.getValues()[0]);\n+\n+        scheduler.advanceTimeBy(2, TimeUnit.DAYS);\n+\n+        assertEquals(null, rp.getValue());\n+        assertEquals(0, rp.getValues().length);\n+        assertNull(rp.getValues(new Integer[2])[0]);\n+    }\n+\n     @Test\n     public void onNextNull() {\n         final ReplaySubject<Object> s = ReplaySubject.create();",
    "output": "Fix time bounded replaySubject getValue() inconsistency with getValues() on old items * Add breaking test for expected peek behavior in a time bound replay subject. * Add possible fix for fixing peek behavior. * Add test & fix for ReplayProcessor::getValue. * Roll-back auto-formatted imports"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java\n@@ -460,12 +460,12 @@ public void onNext(T t) {\n                 if (b.size() < maxSize) {\n                     return;\n                 }\n-            }\n \n-            if (restartTimerOnMaxSize) {\n                 buffer = null;\n                 producerIndex++;\n+            }\n \n+            if (restartTimerOnMaxSize) {\n                 timer.dispose();\n             }\n \n@@ -480,17 +480,12 @@ public void onNext(T t) {\n                 return;\n             }\n \n+            synchronized (this) {\n+                buffer = b;\n+                consumerIndex++;\n+            }\n             if (restartTimerOnMaxSize) {\n-                synchronized (this) {\n-                    buffer = b;\n-                    consumerIndex++;\n-                }\n-\n                 timer = w.schedulePeriodically(this, timespan, timespan, unit);\n-            } else {\n-                synchronized (this) {\n-                    buffer = b;\n-                }\n             }\n         }\n \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java\n@@ -458,12 +458,11 @@ public void onNext(T t) {\n                 if (b.size() < maxSize) {\n                     return;\n                 }\n-            }\n-\n-            if (restartTimerOnMaxSize) {\n                 buffer = null;\n                 producerIndex++;\n+            }\n \n+            if (restartTimerOnMaxSize) {\n                 timer.dispose();\n             }\n \n@@ -478,17 +477,12 @@ public void onNext(T t) {\n                 return;\n             }\n \n+            synchronized (this) {\n+                buffer = b;\n+                consumerIndex++;\n+            }\n             if (restartTimerOnMaxSize) {\n-                synchronized (this) {\n-                    buffer = b;\n-                    consumerIndex++;\n-                }\n-\n                 timer = w.schedulePeriodically(this, timespan, timespan, unit);\n-            } else {\n-                synchronized (this) {\n-                    buffer = b;\n-                }\n             }\n         }\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java\n@@ -1973,4 +1973,45 @@ public void skipBackpressure() {\n         .test()\n         .assertResult(Arrays.asList(1, 2), Arrays.asList(4, 5), Arrays.asList(7, 8), Arrays.asList(10));\n     }\n+\n+    @Test\n+    public void withTimeAndSizeCapacityRace() {\n+        for (int i = 0; i < 1000; i++) {\n+            final TestScheduler scheduler = new TestScheduler();\n+\n+            final PublishProcessor<Object> ps = PublishProcessor.create();\n+\n+            TestSubscriber<List<Object>> ts = ps.buffer(1, TimeUnit.SECONDS, scheduler, 5).test();\n+\n+            ps.onNext(1);\n+            ps.onNext(2);\n+            ps.onNext(3);\n+            ps.onNext(4);\n+\n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ps.onNext(5);\n+                }\n+            };\n+\n+            Runnable r2 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);\n+                }\n+            };\n+\n+            TestHelper.race(r1, r2);\n+\n+            ps.onComplete();\n+\n+            int items = 0;\n+            for (List<Object> o : ts.values()) {\n+                items += o.size();\n+            }\n+\n+            assertEquals(\"Round: \" + i, 5, items);\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java\n@@ -1398,4 +1398,45 @@ public void bufferTimedExactBoundedError() {\n         to\n         .assertFailure(TestException.class);\n     }\n+\n+    @Test\n+    public void withTimeAndSizeCapacityRace() {\n+        for (int i = 0; i < 1000; i++) {\n+            final TestScheduler scheduler = new TestScheduler();\n+\n+            final PublishSubject<Object> ps = PublishSubject.create();\n+\n+            TestObserver<List<Object>> ts = ps.buffer(1, TimeUnit.SECONDS, scheduler, 5).test();\n+\n+            ps.onNext(1);\n+            ps.onNext(2);\n+            ps.onNext(3);\n+            ps.onNext(4);\n+\n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ps.onNext(5);\n+                }\n+            };\n+\n+            Runnable r2 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);\n+                }\n+            };\n+\n+            TestHelper.race(r1, r2);\n+\n+            ps.onComplete();\n+\n+            int items = 0;\n+            for (List<Object> o : ts.values()) {\n+                items += o.size();\n+            }\n+\n+            assertEquals(\"Round: \" + i, 5, items);\n+        }\n+    }\n }",
    "output": "Fix buffer(time, maxSize) duplicating buffers on time-size race"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java\n--- a/src/main/java/io/reactivex/Flowable.java\n+++ b/src/main/java/io/reactivex/Flowable.java\n@@ -13045,6 +13045,44 @@ public final <E extends Subscriber<? super T>> E subscribeWith(E subscriber) {\n     /**\n      * Asynchronously subscribes Subscribers to this Publisher on the specified {@link Scheduler}.\n      * <p>\n+     * If there is a {@link #create(FlowableOnSubscribe, BackpressureStrategy)} type source up in the\n+     * chain, it is recommended to use {@code subscribeOn(scheduler, false)} instead\n+     * to avoid same-pool deadlock because requests may pile up behind a eager/blocking emitter.\n+     * <p>\n+     * <img width=\"640\" height=\"305\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/subscribeOn.png\" alt=\"\">\n+     * <dl>\n+     *  <dt><b>Backpressure:</b></dt>\n+     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n+     *  behavior.</dd>\n+     *  <dt><b>Scheduler:</b></dt>\n+     *  <dd>You specify which {@link Scheduler} this operator will use</dd>\n+     * </dl>\n+     *\n+     * @param scheduler\n+     *            the {@link Scheduler} to perform subscription actions on\n+     * @return the source Publisher modified so that its subscriptions happen on the\n+     *         specified {@link Scheduler}\n+     * @see <a href=\"http://reactivex.io/documentation/operators/subscribeon.html\">ReactiveX operators documentation: SubscribeOn</a>\n+     * @see <a href=\"http://www.grahamlea.com/2014/07/rxjava-threading-examples/\">RxJava Threading Examples</a>\n+     * @see #observeOn\n+     * @see #subscribeOn(Scheduler, boolean)\n+     */\n+    @CheckReturnValue\n+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n+    @SchedulerSupport(SchedulerSupport.CUSTOM)\n+    public final Flowable<T> subscribeOn(@NonNull Scheduler scheduler) {\n+        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n+        return subscribeOn(scheduler, !(this instanceof FlowableCreate));\n+    }\n+\n+    /**\n+     * Asynchronously subscribes Subscribers to this Publisher on the specified {@link Scheduler}\n+     * optionally reroutes requests from other threads to the same {@link Scheduler} thread.\n+     * <p>\n+     * If there is a {@link #create(FlowableOnSubscribe, BackpressureStrategy)} type source up in the\n+     * chain, it is recommended to have {@code requestOn} false to avoid same-pool deadlock\n+     * because requests may pile up behind a eager/blocking emitter.\n+     * <p>\n      * <img width=\"640\" height=\"305\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/subscribeOn.png\" alt=\"\">\n      * <dl>\n      *  <dt><b>Backpressure:</b></dt>\n@@ -13056,18 +13094,23 @@ public final <E extends Subscriber<? super T>> E subscribeWith(E subscriber) {\n      *\n      * @param scheduler\n      *            the {@link Scheduler} to perform subscription actions on\n+     * @param requestOn if true, requests are rerouted to the given Scheduler as well (strong pipelining)\n+     *                  if false, requests coming from any thread are simply forwarded to\n+     *                  the upstream on the same thread (weak pipelining)\n      * @return the source Publisher modified so that its subscriptions happen on the\n      *         specified {@link Scheduler}\n      * @see <a href=\"http://reactivex.io/documentation/operators/subscribeon.html\">ReactiveX operators documentation: SubscribeOn</a>\n      * @see <a href=\"http://www.grahamlea.com/2014/07/rxjava-threading-examples/\">RxJava Threading Examples</a>\n      * @see #observeOn\n+     * @since 2.1.1 - experimental\n      */\n     @CheckReturnValue\n     @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n     @SchedulerSupport(SchedulerSupport.CUSTOM)\n-    public final Flowable<T> subscribeOn(Scheduler scheduler) {\n+    @Experimental\n+    public final Flowable<T> subscribeOn(@NonNull Scheduler scheduler, boolean requestOn) {\n         ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n-        return RxJavaPlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, this instanceof FlowableCreate));\n+        return RxJavaPlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, requestOn));\n     }\n \n     /**\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java\n@@ -65,13 +65,13 @@ static final class SubscribeOnSubscriber<T> extends AtomicReference<Thread>\n \n         Publisher<T> source;\n \n-        SubscribeOnSubscriber(Subscriber<? super T> actual, Scheduler.Worker worker, Publisher<T> source, boolean nonScheduledRequests) {\n+        SubscribeOnSubscriber(Subscriber<? super T> actual, Scheduler.Worker worker, Publisher<T> source, boolean requestOn) {\n             this.actual = actual;\n             this.worker = worker;\n             this.source = source;\n             this.s = new AtomicReference<Subscription>();\n             this.requested = new AtomicLong();\n-            this.nonScheduledRequests = nonScheduledRequests;\n+            this.nonScheduledRequests = !requestOn;\n         }\n \n         @Override\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOnTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOnTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOnTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOnTest.java\n@@ -372,4 +372,51 @@ public void subscribe(FlowableEmitter<Object> s) throws Exception {\n         .assertNoErrors()\n         .assertComplete();\n     }\n+\n+    @Test\n+    public void nonScheduledRequestsNotSubsequentSubscribeOn() {\n+        TestSubscriber<Object> ts = Flowable.create(new FlowableOnSubscribe<Object>() {\n+            @Override\n+            public void subscribe(FlowableEmitter<Object> s) throws Exception {\n+                for (int i = 1; i < 1001; i++) {\n+                    s.onNext(i);\n+                    Thread.sleep(1);\n+                }\n+                s.onComplete();\n+            }\n+        }, BackpressureStrategy.DROP)\n+        .map(Functions.identity())\n+        .subscribeOn(Schedulers.single(), false)\n+        .observeOn(Schedulers.computation())\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertNoErrors()\n+        .assertComplete();\n+\n+        int c = ts.valueCount();\n+\n+        assertTrue(\"\" + c, c > Flowable.bufferSize());\n+    }\n+\n+    @Test\n+    public void scheduledRequestsNotSubsequentSubscribeOn() {\n+        Flowable.create(new FlowableOnSubscribe<Object>() {\n+            @Override\n+            public void subscribe(FlowableEmitter<Object> s) throws Exception {\n+                for (int i = 1; i < 1001; i++) {\n+                    s.onNext(i);\n+                    Thread.sleep(1);\n+                }\n+                s.onComplete();\n+            }\n+        }, BackpressureStrategy.DROP)\n+        .map(Functions.identity())\n+        .subscribeOn(Schedulers.single(), true)\n+        .observeOn(Schedulers.computation())\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertValueCount(Flowable.bufferSize())\n+        .assertNoErrors()\n+        .assertComplete();\n+    }\n }",
    "output": "Add subscribeOn overload to avoid same-pool deadlock with create"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java\n--- a/src/main/java/io/reactivex/Flowable.java\n+++ b/src/main/java/io/reactivex/Flowable.java\n@@ -60,7 +60,7 @@ public abstract class Flowable<T> implements Publisher<T> {\n     /** The default buffer size. */\n     static final int BUFFER_SIZE;\n     static {\n-        BUFFER_SIZE = Math.max(16, Integer.getInteger(\"rx2.buffer-size\", 128));\n+        BUFFER_SIZE = Math.max(1, Integer.getInteger(\"rx2.buffer-size\", 128));\n     }\n \n     /**",
    "output": "Change minimum value of rx2.buffer-size to 1 Before the minimum value you could set with the system variable `rx2.buffer-size` was 16. With this commit, that is changed to 1"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/single/SingleMap.java b/src/main/java/io/reactivex/internal/operators/single/SingleMap.java\n--- a/src/main/java/io/reactivex/internal/operators/single/SingleMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/single/SingleMap.java\n@@ -17,6 +17,7 @@\n import io.reactivex.disposables.Disposable;\n import io.reactivex.exceptions.Exceptions;\n import io.reactivex.functions.Function;\n+import io.reactivex.internal.functions.ObjectHelper;\n \n public final class SingleMap<T, R> extends Single<R> {\n     final SingleSource<? extends T> source;\n@@ -53,7 +54,7 @@ public void onSubscribe(Disposable d) {\n         public void onSuccess(T value) {\n             R v;\n             try {\n-                v = mapper.apply(value);\n+                v = ObjectHelper.requireNonNull(mapper.apply(value), \"The mapper function returned a null value.\");\n             } catch (Throwable e) {\n                 Exceptions.throwIfFatal(e);\n                 onError(e);\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/single/SingleMapTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleMapTest.java\n--- a/src/test/java/io/reactivex/internal/operators/single/SingleMapTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/single/SingleMapTest.java\n@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.single;\n+\n+import org.junit.Test;\n+\n+import io.reactivex.Single;\n+import io.reactivex.SingleSource;\n+import io.reactivex.functions.Function;\n+\n+public class SingleMapTest {\n+\n+    @Test(expected = NullPointerException.class)\n+    public void mapNull() {\n+        Single.just(1).map(null);\n+    }\n+\n+    @Test\n+    public void mapValue() {\n+        Single.just(1).map(new Function<Integer, Integer>() {\n+            @Override\n+            public Integer apply(final Integer integer) throws Exception {\n+                if (integer == 1) {\n+                    return 2;\n+                }\n+\n+                return 1;\n+            }\n+        })\n+        .test()\n+        .assertResult(2);\n+    }\n+\n+    @Test\n+    public void mapValueNull() {\n+        Single.just(1).map(new Function<Integer, SingleSource<Integer>>() {\n+            @Override\n+            public SingleSource<Integer> apply(final Integer integer) throws Exception {\n+                return null;\n+            }\n+        })\n+        .test()\n+        .assertNoValues()\n+        .assertError(NullPointerException.class)\n+        .assertErrorMessage(\"The mapper function returned a null value.\");\n+    }\n+\n+    @Test\n+    public void mapValueErrorThrown() {\n+        Single.just(1).map(new Function<Integer, SingleSource<Integer>>() {\n+            @Override\n+            public SingleSource<Integer> apply(final Integer integer) throws Exception {\n+                throw new RuntimeException(\"something went terribly wrong!\");\n+            }\n+        })\n+        .test()\n+        .assertNoValues()\n+        .assertError(RuntimeException.class)\n+        .assertErrorMessage(\"something went terribly wrong!\");\n+    }\n+\n+    @Test\n+    public void mapError() {\n+        RuntimeException exception = new RuntimeException(\"test\");\n+\n+        Single.error(exception).map(new Function<Object, Object>() {\n+            @Override\n+            public Object apply(final Object integer) throws Exception {\n+                return new Object();\n+            }\n+        })\n+        .test()\n+        .assertError(exception);\n+    }\n+}",
    "output": "Make SingleMap not allow map function return null"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/observers/BaseTestConsumer.java b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n--- a/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n@@ -549,7 +549,7 @@ public final U assertValueSequence(Iterable<? extends T> sequence) {\n             throw fail(\"More values received than expected (\" + i + \")\");\n         }\n         if (expectedNext) {\n-            throw fail(\"Fever values received than expected (\" + i + \")\");\n+            throw fail(\"Fewer values received than expected (\" + i + \")\");\n         }\n         return (U)this;\n     }",
    "output": "Fix typo in error message"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java\n--- a/src/main/java/io/reactivex/Single.java\n+++ b/src/main/java/io/reactivex/Single.java\n@@ -16,6 +16,8 @@\n import java.util.NoSuchElementException;\n import java.util.concurrent.*;\n \n+import org.reactivestreams.Publisher;\n+\n import io.reactivex.annotations.*;\n import io.reactivex.disposables.Disposable;\n import io.reactivex.exceptions.Exceptions;\n@@ -32,7 +34,6 @@\n import io.reactivex.observers.TestObserver;\n import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.schedulers.Schedulers;\n-import org.reactivestreams.Publisher;\n \n /**\n  * The Single class implements the Reactive Pattern for a single value response.\n@@ -3067,6 +3068,26 @@ public final Observable<T> toObservable() {\n         return RxJavaPlugins.onAssembly(new SingleToObservable<T>(this));\n     }\n \n+    /**\n+     * Returns a Single which makes sure when a SingleObserver disposes the Disposable,\n+     * that call is propagated up on the specified scheduler\n+     * <dl>\n+     *  <dt><b>Scheduler:</b></dt>\n+     *  <dd>{@code unsubscribeOn} calls dispose() of the upstream on the {@link Scheduler} you specify.</dd>\n+     * </dl>\n+     * @param scheduler the target scheduler where to execute the cancellation\n+     * @return the new Single instance\n+     * @throws NullPointerException if scheduler is null\n+     * @since 2.0.9 - experimental\n+     */\n+    @CheckReturnValue\n+    @SchedulerSupport(SchedulerSupport.CUSTOM)\n+    @Experimental\n+    public final Single<T> unsubscribeOn(final Scheduler scheduler) {\n+        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n+        return RxJavaPlugins.onAssembly(new SingleUnsubscribeOn<T>(this, scheduler));\n+    }\n+\n     /**\n      * Returns a Single that emits the result of applying a specified function to the pair of items emitted by\n      * the source Single and another specified Single.\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/single/SingleUnsubscribeOn.java b/src/main/java/io/reactivex/internal/operators/single/SingleUnsubscribeOn.java\n--- a/src/main/java/io/reactivex/internal/operators/single/SingleUnsubscribeOn.java\n+++ b/src/main/java/io/reactivex/internal/operators/single/SingleUnsubscribeOn.java\n@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.single;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.*;\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.internal.disposables.DisposableHelper;\n+\n+/**\n+ * Makes sure a dispose() call from downstream happens on the specified scheduler.\n+ * \n+ * @param <T> the value type\n+ */\n+public final class SingleUnsubscribeOn<T> extends Single<T> {\n+\n+    final SingleSource<T> source;\n+\n+    final Scheduler scheduler;\n+\n+    public SingleUnsubscribeOn(SingleSource<T> source, Scheduler scheduler) {\n+        this.source = source;\n+        this.scheduler = scheduler;\n+    }\n+\n+    @Override\n+    protected void subscribeActual(SingleObserver<? super T> observer) {\n+        source.subscribe(new UnsubscribeOnSingleObserver<T>(observer, scheduler));\n+    }\n+\n+    static final class UnsubscribeOnSingleObserver<T> extends AtomicReference<Disposable>\n+    implements SingleObserver<T>, Disposable, Runnable {\n+\n+        private static final long serialVersionUID = 3256698449646456986L;\n+\n+        final SingleObserver<? super T> actual;\n+\n+        final Scheduler scheduler;\n+\n+        Disposable ds;\n+\n+        UnsubscribeOnSingleObserver(SingleObserver<? super T> actual, Scheduler scheduler) {\n+            this.actual = actual;\n+            this.scheduler = scheduler;\n+        }\n+\n+        @Override\n+        public void dispose() {\n+            Disposable d = getAndSet(DisposableHelper.DISPOSED);\n+            if (d != DisposableHelper.DISPOSED) {\n+                this.ds = d;\n+                scheduler.scheduleDirect(this);\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            ds.dispose();\n+        }\n+\n+        @Override\n+        public boolean isDisposed() {\n+            return DisposableHelper.isDisposed(get());\n+        }\n+\n+        @Override\n+        public void onSubscribe(Disposable d) {\n+            if (DisposableHelper.setOnce(this, d)) {\n+                actual.onSubscribe(this);\n+            }\n+        }\n+\n+        @Override\n+        public void onSuccess(T value) {\n+            actual.onSuccess(value);\n+        }\n+\n+        @Override\n+        public void onError(Throwable e) {\n+            actual.onError(e);\n+        }\n+    }\n+}\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/single/SingleUnsubscribeOnTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleUnsubscribeOnTest.java\n--- a/src/test/java/io/reactivex/internal/operators/single/SingleUnsubscribeOnTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/single/SingleUnsubscribeOnTest.java\n@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.single;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.concurrent.*;\n+\n+import org.junit.Test;\n+\n+import io.reactivex.*;\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.exceptions.TestException;\n+import io.reactivex.functions.*;\n+import io.reactivex.processors.PublishProcessor;\n+import io.reactivex.schedulers.Schedulers;\n+\n+public class SingleUnsubscribeOnTest {\n+\n+    @Test\n+    public void normal() throws Exception {\n+        PublishProcessor<Integer> pp = PublishProcessor.create();\n+\n+        final String[] name = { null };\n+\n+        final CountDownLatch cdl = new CountDownLatch(1);\n+\n+        pp.doOnCancel(new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                name[0] = Thread.currentThread().getName();\n+                cdl.countDown();\n+            }\n+        })\n+        .single(-99)\n+        .unsubscribeOn(Schedulers.single())\n+        .test(true)\n+        ;\n+\n+        assertTrue(cdl.await(5, TimeUnit.SECONDS));\n+\n+        int times = 10;\n+\n+        while (times-- > 0 && pp.hasSubscribers()) {\n+            Thread.sleep(100);\n+        }\n+\n+        assertFalse(pp.hasSubscribers());\n+\n+        assertNotEquals(Thread.currentThread().getName(), name[0]);\n+    }\n+\n+    @Test\n+    public void just() {\n+        Single.just(1)\n+        .unsubscribeOn(Schedulers.single())\n+        .test()\n+        .assertResult(1);\n+    }\n+\n+    @Test\n+    public void error() {\n+        Single.<Integer>error(new TestException())\n+        .unsubscribeOn(Schedulers.single())\n+        .test()\n+        .assertFailure(TestException.class);\n+    }\n+\n+    @Test\n+    public void dispose() {\n+        TestHelper.checkDisposed(Single.just(1)\n+        .unsubscribeOn(Schedulers.single()));\n+    }\n+\n+    @Test\n+    public void doubleOnSubscribe() {\n+        TestHelper.checkDoubleOnSubscribeSingle(new Function<Single<Object>, SingleSource<Object>>() {\n+            @Override\n+            public SingleSource<Object> apply(Single<Object> v) throws Exception {\n+                return v.unsubscribeOn(Schedulers.single());\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void disposeRace() {\n+        for (int i = 0; i < 500; i++) {\n+            PublishProcessor<Integer> pp = PublishProcessor.create();\n+\n+            final Disposable[] ds = { null };\n+            pp.single(-99).unsubscribeOn(Schedulers.computation())\n+            .subscribe(new SingleObserver<Integer>() {\n+                @Override\n+                public void onSubscribe(Disposable d) {\n+                    ds[0] = d;\n+                }\n+\n+                @Override\n+                public void onSuccess(Integer value) {\n+\n+                }\n+\n+                @Override\n+                public void onError(Throwable e) {\n+\n+                }\n+            });\n+\n+            Runnable r = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ds[0].dispose();\n+                }\n+            };\n+\n+            TestHelper.race(r, r, Schedulers.single());\n+        }\n+    }\n+}",
    "output": "Add Single.unsubscribeOn() * Add Single.unsubscribeOn() * Fix experimental marker location"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java\n--- a/src/main/java/io/reactivex/Observable.java\n+++ b/src/main/java/io/reactivex/Observable.java\n@@ -203,7 +203,6 @@ public static <T, R> Observable<R> combineLatest(Iterable<? extends ObservableSo\n         return combineLatest(sources, combiner, bufferSize());\n     }\n \n-\n     /**\n      * Combines a collection of source ObservableSources by emitting an item that aggregates the latest values of each of\n      * the source ObservableSources each time an item is received from any of the source ObservableSources, where this\n\ndiff --git a/src/main/java/io/reactivex/observables/ConnectableObservable.java b/src/main/java/io/reactivex/observables/ConnectableObservable.java\n--- a/src/main/java/io/reactivex/observables/ConnectableObservable.java\n+++ b/src/main/java/io/reactivex/observables/ConnectableObservable.java\n@@ -87,6 +87,7 @@ public Observable<T> refCount() {\n     public Observable<T> autoConnect() {\n         return autoConnect(1);\n     }\n+\n     /**\n      * Returns an Observable that automatically connects to this ConnectableObservable\n      * when the specified number of Observers subscribe to it.",
    "output": "Add/remove empty lines in ConnectableObservable and Observable * Multiple lines * Less line of space"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java\n@@ -230,6 +230,10 @@ void innerError(InnerObserver inner, Throwable e) {\n                 if (!delayErrors) {\n                     s.cancel();\n                     set.dispose();\n+                } else {\n+                    if (maxConcurrency != Integer.MAX_VALUE) {\n+                        s.request(1);\n+                    }\n                 }\n                 active.decrementAndGet();\n                 drain();\n@@ -254,12 +258,19 @@ void innerComplete(InnerObserver inner) {\n                     }\n                     return;\n                 }\n+\n+                if (maxConcurrency != Integer.MAX_VALUE) {\n+                    s.request(1);\n+                }\n                 if (decrementAndGet() == 0) {\n                     return;\n                 }\n                 drainLoop();\n             } else {\n                 active.decrementAndGet();\n+                if (maxConcurrency != Integer.MAX_VALUE) {\n+                    s.request(1);\n+                }\n                 drain();\n             }\n         }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java\n@@ -230,6 +230,10 @@ void innerError(InnerObserver inner, Throwable e) {\n                 if (!delayErrors) {\n                     s.cancel();\n                     set.dispose();\n+                } else {\n+                    if (maxConcurrency != Integer.MAX_VALUE) {\n+                        s.request(1);\n+                    }\n                 }\n                 active.decrementAndGet();\n                 drain();\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybeTest.java\n@@ -320,6 +320,36 @@ public MaybeSource<Integer> apply(Integer v) throws Exception {\n         .assertResult();\n     }\n \n+    @Test\n+    public void asyncFlattenNoneMaxConcurrency() {\n+        Flowable.range(1, 1000)\n+        .flatMapMaybe(new Function<Integer, MaybeSource<Integer>>() {\n+            @Override\n+            public MaybeSource<Integer> apply(Integer v) throws Exception {\n+                return Maybe.<Integer>empty().subscribeOn(Schedulers.computation());\n+            }\n+        }, false, 128)\n+        .take(500)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult();\n+    }\n+\n+    @Test\n+    public void asyncFlattenErrorMaxConcurrency() {\n+        Flowable.range(1, 1000)\n+        .flatMapMaybe(new Function<Integer, MaybeSource<Integer>>() {\n+            @Override\n+            public MaybeSource<Integer> apply(Integer v) throws Exception {\n+                return Maybe.<Integer>error(new TestException()).subscribeOn(Schedulers.computation());\n+            }\n+        }, true, 128)\n+        .take(500)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertFailure(CompositeException.class);\n+    }\n+\n     @Test\n     public void successError() {\n         final PublishProcessor<Integer> ps = PublishProcessor.create();\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingleTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingleTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingleTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingleTest.java\n@@ -490,4 +490,19 @@ public void run() {\n             TestHelper.race(r1, r2);\n         }\n     }\n+\n+    @Test\n+    public void asyncFlattenErrorMaxConcurrency() {\n+        Flowable.range(1, 1000)\n+        .flatMapMaybe(new Function<Integer, MaybeSource<Integer>>() {\n+            @Override\n+            public MaybeSource<Integer> apply(Integer v) throws Exception {\n+                return Maybe.<Integer>error(new TestException()).subscribeOn(Schedulers.computation());\n+            }\n+        }, true, 128)\n+        .take(500)\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertFailure(CompositeException.class);\n+    }\n }",
    "output": "Fix Flowable.flatMapMaybe/Single maxConcurrency not requesting more"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java b/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java\n--- a/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java\n+++ b/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java\n@@ -210,12 +210,6 @@ public void dispose() {\n                 tasks.dispose();\n \n                 // releasing the pool should be the last action\n-                // should prevent pool reuse in case there is a blocking\n-                // action not responding to cancellation\n-//                threadWorker.scheduleDirect(() -> {\n-//                    pool.release(threadWorker);\n-//                }, 0, TimeUnit.MILLISECONDS);\n-\n                 pool.release(threadWorker);\n             }\n         }",
    "output": "Remove commented out code from IoScheduler"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/flowables/GroupedFlowable.java b/src/main/java/io/reactivex/flowables/GroupedFlowable.java\n--- a/src/main/java/io/reactivex/flowables/GroupedFlowable.java\n+++ b/src/main/java/io/reactivex/flowables/GroupedFlowable.java\n@@ -31,7 +31,7 @@\n  * @see <a href=\"http://reactivex.io/documentation/operators/groupby.html\">ReactiveX documentation: GroupBy</a>\n  */\n public abstract class GroupedFlowable<K, T> extends Flowable<T> {\n-    \n+\n     final K key;\n \n     /**\n\ndiff --git a/src/main/java/io/reactivex/observables/GroupedObservable.java b/src/main/java/io/reactivex/observables/GroupedObservable.java\n--- a/src/main/java/io/reactivex/observables/GroupedObservable.java\n+++ b/src/main/java/io/reactivex/observables/GroupedObservable.java\n@@ -31,7 +31,7 @@\n  * @see <a href=\"http://reactivex.io/documentation/operators/groupby.html\">ReactiveX documentation: GroupBy</a>\n  */\n public abstract class GroupedObservable<K, T> extends Observable<T> {\n-    \n+\n     final K key;\n \n     /**\n\ndiff --git a/src/main/java/io/reactivex/observers/DisposableMaybeObserver.java b/src/main/java/io/reactivex/observers/DisposableMaybeObserver.java\n--- a/src/main/java/io/reactivex/observers/DisposableMaybeObserver.java\n+++ b/src/main/java/io/reactivex/observers/DisposableMaybeObserver.java\n@@ -61,7 +61,7 @@\n  * @param <T> the received value type\n  */\n public abstract class DisposableMaybeObserver<T> implements MaybeObserver<T>, Disposable {\n-    \n+\n     final AtomicReference<Disposable> s = new AtomicReference<Disposable>();\n \n     @Override\n\ndiff --git a/src/main/java/io/reactivex/observers/DisposableObserver.java b/src/main/java/io/reactivex/observers/DisposableObserver.java\n--- a/src/main/java/io/reactivex/observers/DisposableObserver.java\n+++ b/src/main/java/io/reactivex/observers/DisposableObserver.java\n@@ -64,7 +64,7 @@\n  * @param <T> the received value type\n  */\n public abstract class DisposableObserver<T> implements Observer<T>, Disposable {\n-   \n+\n     final AtomicReference<Disposable> s = new AtomicReference<Disposable>();\n \n     @Override\n\ndiff --git a/src/main/java/io/reactivex/observers/DisposableSingleObserver.java b/src/main/java/io/reactivex/observers/DisposableSingleObserver.java\n--- a/src/main/java/io/reactivex/observers/DisposableSingleObserver.java\n+++ b/src/main/java/io/reactivex/observers/DisposableSingleObserver.java\n@@ -53,7 +53,7 @@\n  * @param <T> the received value type\n  */\n public abstract class DisposableSingleObserver<T> implements SingleObserver<T>, Disposable {\n-    \n+\n     final AtomicReference<Disposable> s = new AtomicReference<Disposable>();\n \n     @Override\n\ndiff --git a/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java b/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java\n--- a/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java\n+++ b/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java\n@@ -33,22 +33,22 @@ public void hashCodeOf() {\n     }\n \n     @Test\n-    public void verifyPositiveInt() throws Exception{\n+    public void verifyPositiveInt() throws Exception {\n         assertEquals(1, ObjectHelper.verifyPositive(1, \"param\"));\n     }\n \n     @Test\n-    public void verifyPositiveLong() throws Exception{\n+    public void verifyPositiveLong() throws Exception {\n         assertEquals(1L, ObjectHelper.verifyPositive(1L, \"param\"));\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void verifyPositiveIntFail() throws Exception{\n+    public void verifyPositiveIntFail() throws Exception {\n         assertEquals(-1, ObjectHelper.verifyPositive(-1, \"param\"));\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void verifyPositiveLongFail() throws Exception{\n+    public void verifyPositiveLongFail() throws Exception {\n         assertEquals(-1L, ObjectHelper.verifyPositive(-1L, \"param\"));\n     }\n ",
    "output": "Fix whitespaces"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/functions/BiConsumer.java b/src/main/java/io/reactivex/functions/BiConsumer.java\n--- a/src/main/java/io/reactivex/functions/BiConsumer.java\n+++ b/src/main/java/io/reactivex/functions/BiConsumer.java\n@@ -13,8 +13,6 @@\n \n package io.reactivex.functions;\n \n-import io.reactivex.annotations.NonNull;\n-\n /**\n  * A functional interface (callback) that accepts two values (of possibly different types).\n  * @param <T1> the first value type\n@@ -28,5 +26,5 @@ public interface BiConsumer<T1, T2> {\n      * @param t2 the second value\n      * @throws Exception on error\n      */\n-    void accept(@NonNull T1 t1, @NonNull T2 t2) throws Exception;\n+    void accept(T1 t1, T2 t2) throws Exception;\n }",
    "output": "Remove @NonNull annotations in BiConsumer"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java\n@@ -411,7 +411,10 @@ public void clear() {\n         @Override\n         public boolean isEmpty() {\n             Iterator<? extends R> it = current;\n-            return (it != null && !it.hasNext()) || queue.isEmpty();\n+            if (it == null) {\n+                return queue.isEmpty();\n+            }\n+            return !it.hasNext();\n         }\n \n         @Nullable\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java\n@@ -863,4 +863,55 @@ public void remove() {\n \n         ts.assertResult(1);\n     }\n+\n+    @Test\n+    public void doubleShare() {\n+        Iterable<Integer> it = Flowable.range(1, 300).blockingIterable();\n+            Flowable.just(it, it)\n+            .flatMapIterable(Functions.<Iterable<Integer>>identity())\n+            .share()\n+            .share()\n+            .count()\n+            .test()\n+            .assertResult(600L);\n+    }\n+\n+    @Test\n+    public void multiShare() {\n+        Iterable<Integer> it = Flowable.range(1, 300).blockingIterable();\n+        for (int i = 0; i < 5; i++) {\n+            Flowable<Integer> f = Flowable.just(it, it)\n+            .flatMapIterable(Functions.<Iterable<Integer>>identity());\n+\n+            for (int j = 0; j < i; j++) {\n+                f = f.share();\n+            }\n+\n+            f\n+            .count()\n+            .test()\n+            .withTag(\"Share: \" + i)\n+            .assertResult(600L);\n+        }\n+    }\n+\n+    @Test\n+    public void multiShareHidden() {\n+        Iterable<Integer> it = Flowable.range(1, 300).blockingIterable();\n+        for (int i = 0; i < 5; i++) {\n+            Flowable<Integer> f = Flowable.just(it, it)\n+            .flatMapIterable(Functions.<Iterable<Integer>>identity())\n+            .hide();\n+\n+            for (int j = 0; j < i; j++) {\n+                f = f.share();\n+            }\n+\n+            f\n+            .count()\n+            .test()\n+            .withTag(\"Share: \" + i)\n+            .assertResult(600L);\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java\n@@ -395,7 +395,7 @@ public void onNextCancelRace() {\n         for (int i = 0; i < 1000; i++) {\n             final PublishProcessor<Integer> pp = PublishProcessor.create();\n             final TestObserver<List<Integer>> ts = pp.toList().test();\n-            \n+\n             Runnable r1 = new Runnable() {\n                 @Override\n                 public void run() {\n@@ -408,18 +408,17 @@ public void run() {\n                     ts.cancel();\n                 }\n             };\n-            \n+\n             TestHelper.race(r1, r2);\n         }\n-        \n     }\n \n     @Test\n     public void onNextCancelRaceFlowable() {\n         for (int i = 0; i < 1000; i++) {\n             final PublishProcessor<Integer> pp = PublishProcessor.create();\n             final TestSubscriber<List<Integer>> ts = pp.toList().toFlowable().test();\n-            \n+\n             Runnable r1 = new Runnable() {\n                 @Override\n                 public void run() {\n@@ -432,20 +431,20 @@ public void run() {\n                     ts.cancel();\n                 }\n             };\n-            \n+\n             TestHelper.race(r1, r2);\n         }\n-        \n+\n     }\n \n     @Test\n     public void onCompleteCancelRaceFlowable() {\n         for (int i = 0; i < 1000; i++) {\n             final PublishProcessor<Integer> pp = PublishProcessor.create();\n             final TestSubscriber<List<Integer>> ts = pp.toList().toFlowable().test();\n-            \n+\n             pp.onNext(1);\n-            \n+\n             Runnable r1 = new Runnable() {\n                 @Override\n                 public void run() {\n@@ -458,14 +457,13 @@ public void run() {\n                     ts.cancel();\n                 }\n             };\n-            \n+\n             TestHelper.race(r1, r2);\n-            \n+\n             if (ts.valueCount() != 0) {\n                 ts.assertValue(Arrays.asList(1))\n                 .assertNoErrors();\n             }\n         }\n-        \n     }\n }",
    "output": "Fix flatMapIterable appearing to be empty when fused"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java\n@@ -69,7 +69,10 @@ public void onSubscribe(Subscription s) {\n \n         @Override\n         public void onNext(T t) {\n-            value.add(t);\n+            U v = value;\n+            if (v != null) {\n+                v.add(t);\n+            }\n         }\n \n         @Override\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java\n@@ -13,6 +13,7 @@\n \n package io.reactivex.internal.operators.flowable;\n \n+import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.*;\n \n import java.util.*;\n@@ -23,7 +24,6 @@\n import org.reactivestreams.Subscriber;\n \n import io.reactivex.*;\n-import io.reactivex.Flowable;\n import io.reactivex.exceptions.TestException;\n import io.reactivex.observers.TestObserver;\n import io.reactivex.processors.PublishProcessor;\n@@ -389,4 +389,83 @@ public Collection<Integer> call() throws Exception {\n         .assertFailure(NullPointerException.class)\n         .assertErrorMessage(\"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");\n     }\n+\n+    @Test\n+    public void onNextCancelRace() {\n+        for (int i = 0; i < 1000; i++) {\n+            final PublishProcessor<Integer> pp = PublishProcessor.create();\n+            final TestObserver<List<Integer>> ts = pp.toList().test();\n+            \n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    pp.onNext(1);\n+                }\n+            };\n+            Runnable r2 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ts.cancel();\n+                }\n+            };\n+            \n+            TestHelper.race(r1, r2);\n+        }\n+        \n+    }\n+\n+    @Test\n+    public void onNextCancelRaceFlowable() {\n+        for (int i = 0; i < 1000; i++) {\n+            final PublishProcessor<Integer> pp = PublishProcessor.create();\n+            final TestSubscriber<List<Integer>> ts = pp.toList().toFlowable().test();\n+            \n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    pp.onNext(1);\n+                }\n+            };\n+            Runnable r2 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ts.cancel();\n+                }\n+            };\n+            \n+            TestHelper.race(r1, r2);\n+        }\n+        \n+    }\n+\n+    @Test\n+    public void onCompleteCancelRaceFlowable() {\n+        for (int i = 0; i < 1000; i++) {\n+            final PublishProcessor<Integer> pp = PublishProcessor.create();\n+            final TestSubscriber<List<Integer>> ts = pp.toList().toFlowable().test();\n+            \n+            pp.onNext(1);\n+            \n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    pp.onComplete();\n+                }\n+            };\n+            Runnable r2 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    ts.cancel();\n+                }\n+            };\n+            \n+            TestHelper.race(r1, r2);\n+            \n+            if (ts.valueCount() != 0) {\n+                ts.assertValue(Arrays.asList(1))\n+                .assertNoErrors();\n+            }\n+        }\n+        \n+    }\n }",
    "output": "Fix Flowable.toList() onNext/cancel race"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java\n@@ -421,10 +421,12 @@ void drainLoop() {\n \n                 if (d && (svq == null || svq.isEmpty()) && n == 0) {\n                     Throwable ex = errs.terminate();\n-                    if (ex == null) {\n-                        child.onComplete();\n-                    } else {\n-                        child.onError(ex);\n+                    if (ex != ExceptionHelper.TERMINATED) {\n+                        if (ex == null) {\n+                            child.onComplete();\n+                        } else {\n+                            child.onError(ex);\n+                        }\n                     }\n                     return;\n                 }\n@@ -556,7 +558,10 @@ boolean checkTerminate() {\n             }\n             if (!delayErrors && errs.get() != null) {\n                 clearScalarQueue();\n-                actual.onError(errs.terminate());\n+                Throwable ex = errs.terminate();\n+                if (ex != ExceptionHelper.TERMINATED) {\n+                    actual.onError(ex);\n+                }\n                 return true;\n             }\n             return false;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java\n@@ -361,11 +361,13 @@ void drainLoop() {\n                 int n = inner.length;\n \n                 if (d && (svq == null || svq.isEmpty()) && n == 0) {\n-                    Throwable ex = errors.get();\n-                    if (ex == null) {\n-                        child.onComplete();\n-                    } else {\n-                        child.onError(errors.terminate());\n+                    Throwable ex = errors.terminate();\n+                    if (ex != ExceptionHelper.TERMINATED) {\n+                        if (ex == null) {\n+                            child.onComplete();\n+                        } else {\n+                            child.onError(ex);\n+                        }\n                     }\n                     return;\n                 }\n@@ -488,7 +490,10 @@ boolean checkTerminate() {\n             Throwable e = errors.get();\n             if (!delayErrors && (e != null)) {\n                 disposeAll();\n-                actual.onError(errors.terminate());\n+                e = errors.terminate();\n+                if (e != ExceptionHelper.TERMINATED) {\n+                    actual.onError(e);\n+                }\n                 return true;\n             }\n             return false;\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java\n@@ -28,6 +28,7 @@\n import io.reactivex.exceptions.*;\n import io.reactivex.functions.*;\n import io.reactivex.internal.functions.Functions;\n+import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.processors.PublishProcessor;\n import io.reactivex.schedulers.Schedulers;\n import io.reactivex.subscribers.TestSubscriber;\n@@ -926,4 +927,74 @@ public Object apply(Integer v) throws Exception {\n             assertTrue(list.toString(), list.contains(\"RxCo\"));\n         }\n     }\n+\n+    @Test\n+    public void cancelScalarDrainRace() {\n+        for (int i = 0; i < 1000; i++) {\n+            List<Throwable> errors = TestHelper.trackPluginErrors();\n+            try {\n+\n+                final PublishProcessor<Flowable<Integer>> pp = PublishProcessor.create();\n+\n+                final TestSubscriber<Integer> ts = pp.flatMap(Functions.<Flowable<Integer>>identity()).test(0);\n+\n+                Runnable r1 = new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        ts.cancel();\n+                    }\n+                };\n+                Runnable r2 = new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        pp.onComplete();\n+                    }\n+                };\n+\n+                TestHelper.race(r1, r2);\n+\n+                assertTrue(errors.toString(), errors.isEmpty());\n+            } finally {\n+                RxJavaPlugins.reset();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void cancelDrainRace() {\n+        for (int i = 0; i < 1000; i++) {\n+            for (int j = 1; j < 50; j += 5) {\n+                List<Throwable> errors = TestHelper.trackPluginErrors();\n+                try {\n+\n+                    final PublishProcessor<Flowable<Integer>> pp = PublishProcessor.create();\n+\n+                    final TestSubscriber<Integer> ts = pp.flatMap(Functions.<Flowable<Integer>>identity()).test(0);\n+\n+                    final PublishProcessor<Integer> just = PublishProcessor.create();\n+                    pp.onNext(just);\n+\n+                    Runnable r1 = new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            ts.request(1);\n+                            ts.cancel();\n+                        }\n+                    };\n+                    Runnable r2 = new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            just.onNext(1);\n+                        }\n+                    };\n+\n+                    TestHelper.race(r1, r2);\n+\n+                    assertTrue(errors.toString(), errors.isEmpty());\n+                } finally {\n+                    RxJavaPlugins.reset();\n+                }\n+            }\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java\n@@ -29,7 +29,9 @@\n import io.reactivex.disposables.Disposable;\n import io.reactivex.exceptions.*;\n import io.reactivex.functions.*;\n+import io.reactivex.internal.functions.Functions;\n import io.reactivex.observers.TestObserver;\n+import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.schedulers.Schedulers;\n import io.reactivex.subjects.PublishSubject;\n \n@@ -784,4 +786,76 @@ public Object apply(Integer v) throws Exception {\n             assertTrue(list.toString(), list.contains(\"RxCo\"));\n         }\n     }\n+\n+    @Test\n+    public void cancelScalarDrainRace() {\n+        for (int i = 0; i < 1000; i++) {\n+            List<Throwable> errors = TestHelper.trackPluginErrors();\n+            try {\n+\n+                final PublishSubject<Observable<Integer>> pp = PublishSubject.create();\n+\n+                final TestObserver<Integer> ts = pp.flatMap(Functions.<Observable<Integer>>identity()).test();\n+\n+                Runnable r1 = new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        ts.cancel();\n+                    }\n+                };\n+                Runnable r2 = new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        pp.onComplete();\n+                    }\n+                };\n+\n+                TestHelper.race(r1, r2);\n+\n+                assertTrue(errors.toString(), errors.isEmpty());\n+            } finally {\n+                RxJavaPlugins.reset();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void cancelDrainRace() {\n+        for (int i = 0; i < 1000; i++) {\n+            for (int j = 1; j < 50; j += 5) {\n+                List<Throwable> errors = TestHelper.trackPluginErrors();\n+                try {\n+\n+                    final PublishSubject<Observable<Integer>> pp = PublishSubject.create();\n+\n+                    final TestObserver<Integer> ts = pp.flatMap(Functions.<Observable<Integer>>identity()).test();\n+\n+                    final PublishSubject<Integer> just = PublishSubject.create();\n+                    final PublishSubject<Integer> just2 = PublishSubject.create();\n+                    pp.onNext(just);\n+                    pp.onNext(just2);\n+\n+                    Runnable r1 = new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            just2.onNext(1);\n+                            ts.cancel();\n+                        }\n+                    };\n+                    Runnable r2 = new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            just.onNext(1);\n+                        }\n+                    };\n+\n+                    TestHelper.race(r1, r2);\n+\n+                    assertTrue(errors.toString(), errors.isEmpty());\n+                } finally {\n+                    RxJavaPlugins.reset();\n+                }\n+            }\n+        }\n+    }\n }",
    "output": "Fix flatMap emitting the terminal exception indicator on cancel"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java\n@@ -48,7 +48,7 @@ protected void subscribeActual(final CompletableObserver s) {\n     final class Delay implements CompletableObserver {\n \n         private final CompositeDisposable set;\n-        private final CompletableObserver s;\n+        final CompletableObserver s;\n \n         Delay(CompositeDisposable set, CompletableObserver s) {\n             this.set = set;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java b/src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java\n@@ -57,7 +57,7 @@ final class CompletableObserverImplementation implements CompletableObserver, Di\n \n         Disposable d;\n \n-        private CompletableObserverImplementation(CompletableObserver actual) {\n+        CompletableObserverImplementation(CompletableObserver actual) {\n             this.actual = actual;\n         }\n \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java\n@@ -43,8 +43,8 @@ protected void subscribeActual(final CompletableObserver s) {\n \n     final class ResumeNext implements CompletableObserver {\n \n-        private final CompletableObserver s;\n-        private final SequentialDisposable sd;\n+        final CompletableObserver s;\n+        final SequentialDisposable sd;\n \n         ResumeNext(CompletableObserver s, SequentialDisposable sd) {\n             this.s = s;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableTimeout.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableTimeout.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableTimeout.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableTimeout.java\n@@ -90,8 +90,8 @@ public void onComplete() {\n \n     final class DisposeTask implements Runnable {\n         private final AtomicBoolean once;\n-        private final CompositeDisposable set;\n-        private final CompletableObserver s;\n+        final CompositeDisposable set;\n+        final CompletableObserver s;\n \n         DisposeTask(AtomicBoolean once, CompositeDisposable set, CompletableObserver s) {\n             this.once = once;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelaySubscriptionOther.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelaySubscriptionOther.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelaySubscriptionOther.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelaySubscriptionOther.java\n@@ -44,8 +44,8 @@ public void subscribeActual(final Subscriber<? super T> child) {\n     }\n \n     final class DelaySubscriber implements FlowableSubscriber<U> {\n-        private final SubscriptionArbiter serial;\n-        private final Subscriber<? super T> child;\n+        final SubscriptionArbiter serial;\n+        final Subscriber<? super T> child;\n         boolean done;\n \n         DelaySubscriber(SubscriptionArbiter serial, Subscriber<? super T> child) {\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java\n@@ -1256,7 +1256,7 @@ public void subscribe(Subscriber<? super T> child) {\n         }\n     }\n \n-    static final class DefaultUnboundedFactory implements Callable {\n+    static final class DefaultUnboundedFactory implements Callable<Object> {\n         @Override\n         public Object call() {\n             return new UnboundedReplayBuffer<Object>(16);\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java\n@@ -40,7 +40,7 @@ protected void subscribeActual(Subscriber<? super R> s) {\n \n         serial.onSubscribe(wlf);\n \n-        other.subscribe(new FlowableWithLatestSubscriber<U>(wlf));\n+        other.subscribe(new FlowableWithLatestSubscriber(wlf));\n \n         source.subscribe(wlf);\n     }\n@@ -117,7 +117,7 @@ public void otherError(Throwable e) {\n         }\n     }\n \n-    final class FlowableWithLatestSubscriber<U> implements FlowableSubscriber<U> {\n+    final class FlowableWithLatestSubscriber implements FlowableSubscriber<U> {\n         private final WithLatestFromSubscriber<T, U, R> wlf;\n \n         FlowableWithLatestSubscriber(WithLatestFromSubscriber<T, U, R> wlf) {\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableDelaySubscriptionOther.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableDelaySubscriptionOther.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableDelaySubscriptionOther.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDelaySubscriptionOther.java\n@@ -44,8 +44,8 @@ public void subscribeActual(final Observer<? super T> child) {\n     }\n \n     final class DelayObserver implements Observer<U> {\n-        private final SequentialDisposable serial;\n-        private final Observer<? super T> child;\n+        final SequentialDisposable serial;\n+        final Observer<? super T> child;\n         boolean done;\n \n         DelayObserver(SequentialDisposable serial, Observer<? super T> child) {\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java\n@@ -892,9 +892,9 @@ Node getHead() {\n         }\n     }\n \n-    static final class UnBoundedFactory implements BufferSupplier {\n+    static final class UnBoundedFactory implements BufferSupplier<Object> {\n         @Override\n-        public ReplayBuffer call() {\n+        public ReplayBuffer<Object> call() {\n             return new UnboundedReplayBuffer<Object>(16);\n         }\n     }\n@@ -1027,7 +1027,7 @@ protected void subscribeActual(Observer<? super R> child) {\n \n             observable.subscribe(srw);\n \n-            co.connect(new DisposeConsumer(srw));\n+            co.connect(new DisposeConsumer<R>(srw));\n         }\n     }\n \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java b/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java\n--- a/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java\n+++ b/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java\n@@ -44,7 +44,7 @@ protected void subscribeActual(final SingleObserver<? super T> s) {\n \n     final class Delay implements SingleObserver<T> {\n         private final SequentialDisposable sd;\n-        private final SingleObserver<? super T> s;\n+        final SingleObserver<? super T> s;\n \n         Delay(SequentialDisposable sd, SingleObserver<? super T> s) {\n             this.sd = sd;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/single/SingleTimeout.java b/src/main/java/io/reactivex/internal/operators/single/SingleTimeout.java\n--- a/src/main/java/io/reactivex/internal/operators/single/SingleTimeout.java\n+++ b/src/main/java/io/reactivex/internal/operators/single/SingleTimeout.java\n@@ -58,8 +58,8 @@ protected void subscribeActual(final SingleObserver<? super T> s) {\n \n     final class TimeoutDispose implements Runnable {\n         private final AtomicBoolean once;\n-        private final CompositeDisposable set;\n-        private final SingleObserver<? super T> s;\n+        final CompositeDisposable set;\n+        final SingleObserver<? super T> s;\n \n         TimeoutDispose(AtomicBoolean once, CompositeDisposable set, SingleObserver<? super T> s) {\n             this.once = once;",
    "output": "Fix private field access, few generics problems"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Emitter.java b/src/main/java/io/reactivex/Emitter.java\n--- a/src/main/java/io/reactivex/Emitter.java\n+++ b/src/main/java/io/reactivex/Emitter.java\n@@ -12,6 +12,8 @@\n  */\n package io.reactivex;\n \n+import io.reactivex.annotations.NonNull;\n+\n /**\n  * Base interface for emitting signals in a push-fashion in various generator-like source\n  * operators (create, generate).\n@@ -24,13 +26,13 @@ public interface Emitter<T> {\n      * Signal a normal value.\n      * @param value the value to signal, not null\n      */\n-    void onNext(T value);\n+    void onNext(@NonNull T value);\n \n     /**\n      * Signal a Throwable exception.\n      * @param error the Throwable to signal, not null\n      */\n-    void onError(Throwable error);\n+    void onError(@NonNull Throwable error);\n \n     /**\n      * Signal a completion.",
    "output": "Add @NonNull to the methods of Emitter"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/observers/BaseTestConsumer.java b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n--- a/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n@@ -48,6 +48,8 @@ public abstract class BaseTestConsumer<T, U extends BaseTestConsumer<T, U>> impl\n \n     protected int establishedFusionMode;\n \n+    protected CharSequence tag;\n+\n     public BaseTestConsumer() {\n         this.values = new ArrayList<T>();\n         this.errors = new ArrayList<Throwable>();\n@@ -129,6 +131,15 @@ protected final AssertionError fail(String message) {\n         .append(\"values = \").append(values.size()).append(\", \")\n         .append(\"errors = \").append(errors.size()).append(\", \")\n         .append(\"completions = \").append(completions)\n+        ;\n+\n+        CharSequence tag = this.tag;\n+        if (tag != null) {\n+            b.append(\", tag = \")\n+            .append(tag);\n+        }\n+\n+        b\n         .append(')')\n         ;\n \n@@ -747,4 +758,18 @@ public final U assertEmpty() {\n                 .assertNoErrors()\n                 .assertNotComplete();\n     }\n+\n+    /**\n+     * Set the tag displayed along with an assertion failure's\n+     * other state information.\n+     * @param tag the string to display (null won't print any tag)\n+     * @return this\n+     * @since 2.0.7 - experimental\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Experimental\n+    public final U withTag(CharSequence tag) {\n+        this.tag = tag;\n+        return (U)this;\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/observers/TestObserverTest.java b/src/test/java/io/reactivex/observers/TestObserverTest.java\n--- a/src/test/java/io/reactivex/observers/TestObserverTest.java\n+++ b/src/test/java/io/reactivex/observers/TestObserverTest.java\n@@ -1381,4 +1381,20 @@ public void assertValueAtInvalidIndex() {\n             }\n         });\n     }\n+\n+    @Test\n+    public void withTag() {\n+        try {\n+            for (int i = 1; i < 3; i++) {\n+                Observable.just(i)\n+                .test()\n+                .withTag(\"testing with item=\" + i)\n+                .assertResult(1)\n+                ;\n+            }\n+            fail(\"Should have thrown!\");\n+        } catch (AssertionError ex) {\n+            assertTrue(ex.toString(), ex.toString().contains(\"testing with item=2\"));\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java b/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n--- a/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n+++ b/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n@@ -1777,4 +1777,20 @@ public void requestMore() {\n         .requestMore(3)\n         .assertResult(1, 2, 3, 4, 5);\n     }\n+\n+    @Test\n+    public void withTag() {\n+        try {\n+            for (int i = 1; i < 3; i++) {\n+                Flowable.just(i)\n+                .test()\n+                .withTag(\"testing with item=\" + i)\n+                .assertResult(1)\n+                ;\n+            }\n+            fail(\"Should have thrown!\");\n+        } catch (AssertionError ex) {\n+            assertTrue(ex.toString(), ex.toString().contains(\"testing with item=2\"));\n+        }\n+    }\n }",
    "output": "Add TestSubscriber.withTag"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java\n@@ -551,19 +551,24 @@ void drainLoop() {\n \n         boolean checkTerminate() {\n             if (cancelled) {\n-                SimpleQueue<U> q = queue;\n-                if (q != null) {\n-                    q.clear();\n-                }\n+                clearScalarQueue();\n                 return true;\n             }\n             if (!delayErrors && errs.get() != null) {\n+                clearScalarQueue();\n                 actual.onError(errs.terminate());\n                 return true;\n             }\n             return false;\n         }\n \n+        void clearScalarQueue() {\n+            SimpleQueue<U> q = queue;\n+            if (q != null) {\n+                q.clear();\n+            }\n+        }\n+\n         void disposeAll() {\n             InnerSubscriber<?, ?>[] a = subscribers.get();\n             if (a != CANCELLED) {\n@@ -579,6 +584,21 @@ void disposeAll() {\n                 }\n             }\n         }\n+\n+        void innerError(InnerSubscriber<T, U> inner, Throwable t) {\n+            if (errs.addThrowable(t)) {\n+                inner.done = true;\n+                if (!delayErrors) {\n+                    s.cancel();\n+                    for (InnerSubscriber<?, ?> a : subscribers.getAndSet(CANCELLED)) {\n+                        a.dispose();\n+                    }\n+                }\n+                drain();\n+            } else {\n+                RxJavaPlugins.onError(t);\n+            }\n+        }\n     }\n \n     static final class InnerSubscriber<T, U> extends AtomicReference<Subscription>\n@@ -636,12 +656,8 @@ public void onNext(U t) {\n         }\n         @Override\n         public void onError(Throwable t) {\n-            if (parent.errs.addThrowable(t)) {\n-                done = true;\n-                parent.drain();\n-            } else {\n-                RxJavaPlugins.onError(t);\n-            }\n+            lazySet(SubscriptionHelper.CANCELLED);\n+            parent.innerError(this, t);\n         }\n         @Override\n         public void onComplete() {\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java\n@@ -28,10 +28,12 @@\n \n import io.reactivex.*;\n import io.reactivex.Scheduler.Worker;\n+import io.reactivex.exceptions.TestException;\n import io.reactivex.functions.*;\n import io.reactivex.internal.functions.Functions;\n import io.reactivex.internal.subscriptions.*;\n import io.reactivex.internal.util.*;\n+import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.processors.PublishProcessor;\n import io.reactivex.schedulers.*;\n import io.reactivex.subscribers.*;\n@@ -1630,4 +1632,21 @@ public void mergeArray() {\n         .test()\n         .assertResult(1, 2);\n     }\n+\n+    @Test\n+    public void mergeErrors() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            Flowable<Integer> source1 = Flowable.error(new TestException(\"First\"));\n+            Flowable<Integer> source2 = Flowable.error(new TestException(\"Second\"));\n+\n+            Flowable.merge(source1, source2)\n+            .test()\n+            .assertFailureAndMessage(TestException.class, \"First\");\n+\n+            assertTrue(errors.toString(), errors.isEmpty());\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java\n@@ -27,8 +27,10 @@\n import io.reactivex.Observer;\n import io.reactivex.Scheduler.Worker;\n import io.reactivex.disposables.*;\n+import io.reactivex.exceptions.TestException;\n import io.reactivex.functions.*;\n import io.reactivex.observers.*;\n+import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.schedulers.*;\n \n public class ObservableMergeTest {\n@@ -1125,4 +1127,21 @@ public void mergeArray() {\n         .test()\n         .assertResult(1, 2);\n     }\n+\n+    @Test\n+    public void mergeErrors() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            Observable<Integer> source1 = Observable.error(new TestException(\"First\"));\n+            Observable<Integer> source2 = Observable.error(new TestException(\"Second\"));\n+\n+            Observable.merge(source1, source2)\n+            .test()\n+            .assertFailureAndMessage(TestException.class, \"First\");\n+\n+            assertTrue(errors.toString(), errors.isEmpty());\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/single/SingleMergeTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleMergeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/single/SingleMergeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/single/SingleMergeTest.java\n@@ -13,9 +13,15 @@\n \n package io.reactivex.internal.operators.single;\n \n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.List;\n+\n import org.junit.Test;\n \n-import io.reactivex.Single;\n+import io.reactivex.*;\n+import io.reactivex.exceptions.TestException;\n+import io.reactivex.plugins.RxJavaPlugins;\n \n public class SingleMergeTest {\n \n@@ -48,4 +54,20 @@ public void merge4() {\n         .assertResult(1, 2, 3, 4);\n     }\n \n+    @Test\n+    public void mergeErrors() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            Single<Integer> source1 = Single.error(new TestException(\"First\"));\n+            Single<Integer> source2 = Single.error(new TestException(\"Second\"));\n+\n+            Single.merge(source1, source2)\n+            .test()\n+            .assertFailureAndMessage(TestException.class, \"First\");\n+\n+            assertTrue(errors.toString(), errors.isEmpty());\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n }",
    "output": "Fix flatMap not cancelling the upstream eagerly"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java\n@@ -115,6 +115,7 @@ public void subscribe(ObservableSource<? extends T>[] sources, int bufferSize) {\n         public void dispose() {\n             if (!cancelled) {\n                 cancelled = true;\n+                cancelSources();\n                 if (getAndIncrement() == 0) {\n                     clear();\n                 }\n@@ -126,9 +127,19 @@ public boolean isDisposed() {\n             return cancelled;\n         }\n \n-        void clear() {\n+        void cancel() {\n+            clear();\n+            cancelSources();\n+        }\n+\n+        void cancelSources() {\n             for (ZipObserver<?, ?> zs : observers) {\n                 zs.dispose();\n+            }\n+        }\n+\n+        void clear() {\n+            for (ZipObserver<?, ?> zs : observers) {\n                 zs.queue.clear();\n             }\n         }\n@@ -168,7 +179,7 @@ public void drain() {\n                             if (z.done && !delayError) {\n                                 Throwable ex = z.error;\n                                 if (ex != null) {\n-                                    clear();\n+                                    cancel();\n                                     a.onError(ex);\n                                     return;\n                                 }\n@@ -186,7 +197,7 @@ public void drain() {\n                         v = ObjectHelper.requireNonNull(zipper.apply(os.clone()), \"The zipper returned a null value\");\n                     } catch (Throwable ex) {\n                         Exceptions.throwIfFatal(ex);\n-                        clear();\n+                        cancel();\n                         a.onError(ex);\n                         return;\n                     }\n@@ -205,15 +216,15 @@ public void drain() {\n \n         boolean checkTerminated(boolean d, boolean empty, Observer<? super R> a, boolean delayError, ZipObserver<?, ?> source) {\n             if (cancelled) {\n-                clear();\n+                cancel();\n                 return true;\n             }\n \n             if (d) {\n                 if (delayError) {\n                     if (empty) {\n                         Throwable e = source.error;\n-                        clear();\n+                        cancel();\n                         if (e != null) {\n                             a.onError(e);\n                         } else {\n@@ -224,12 +235,12 @@ boolean checkTerminated(boolean d, boolean empty, Observer<? super R> a, boolean\n                 } else {\n                     Throwable e = source.error;\n                     if (e != null) {\n-                        clear();\n+                        cancel();\n                         a.onError(e);\n                         return true;\n                     } else\n                     if (empty) {\n-                        clear();\n+                        cancel();\n                         a.onComplete();\n                         return true;\n                     }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableZipTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableZipTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableZipTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableZipTest.java\n@@ -1392,4 +1392,39 @@ public List<Object> apply(Object t1, Object t2) throws Exception {\n             assertTrue(list.toString(), list.contains(\"RxSi\"));\n             assertTrue(list.toString(), list.contains(\"RxCo\"));\n         }\n-    }}\n+    }\n+\n+    @Test\n+    public void eagerDispose() {\n+        final PublishSubject<Integer> ps1 = PublishSubject.create();\n+        final PublishSubject<Integer> ps2 = PublishSubject.create();\n+\n+        TestObserver<Integer> ts = new TestObserver<Integer>() {\n+            @Override\n+            public void onNext(Integer t) {\n+                super.onNext(t);\n+                cancel();\n+                if (ps1.hasObservers()) {\n+                    onError(new IllegalStateException(\"ps1 not disposed\"));\n+                } else\n+                if (ps2.hasObservers()) {\n+                    onError(new IllegalStateException(\"ps2 not disposed\"));\n+                } else {\n+                    onComplete();\n+                }\n+            }\n+        };\n+\n+        Observable.zip(ps1, ps2, new BiFunction<Integer, Integer, Integer>() {\n+            @Override\n+            public Integer apply(Integer t1, Integer t2) throws Exception {\n+                return t1 + t2;\n+            }\n+        })\n+        .subscribe(ts);\n+\n+        ps1.onNext(1);\n+        ps2.onNext(2);\n+        ts.assertResult(3);\n+    }\n+}",
    "output": "Fix Observable.zip to dispose eagerly"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java\n@@ -124,9 +124,9 @@ public void subscribe(ObservableSource<? extends T>[] sources) {\n         public void dispose() {\n             if (!cancelled) {\n                 cancelled = true;\n-\n+                cancelSources();\n                 if (getAndIncrement() == 0) {\n-                    cancel(queue);\n+                    clear(queue);\n                 }\n             }\n         }\n@@ -138,6 +138,10 @@ public boolean isDisposed() {\n \n         void cancel(SpscLinkedArrayQueue<?> q) {\n             clear(q);\n+            cancelSources();\n+        }\n+\n+        void cancelSources() {\n             for (CombinerObserver<T, R> s : observers) {\n                 s.dispose();\n             }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java\n@@ -1517,4 +1517,38 @@ public void run() throws Exception {\n             RxJavaPlugins.reset();\n         }\n     }\n+\n+    @Test\n+    public void eagerDispose() {\n+        final PublishProcessor<Integer> pp1 = PublishProcessor.create();\n+        final PublishProcessor<Integer> pp2 = PublishProcessor.create();\n+\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {\n+            @Override\n+            public void onNext(Integer t) {\n+                super.onNext(t);\n+                cancel();\n+                if (pp1.hasSubscribers()) {\n+                    onError(new IllegalStateException(\"pp1 not disposed\"));\n+                } else\n+                if (pp2.hasSubscribers()) {\n+                    onError(new IllegalStateException(\"pp2 not disposed\"));\n+                } else {\n+                    onComplete();\n+                }\n+            }\n+        };\n+\n+        Flowable.combineLatest(pp1, pp2, new BiFunction<Integer, Integer, Integer>() {\n+            @Override\n+            public Integer apply(Integer t1, Integer t2) throws Exception {\n+                return t1 + t2;\n+            }\n+        })\n+        .subscribe(ts);\n+\n+        pp1.onNext(1);\n+        pp2.onNext(2);\n+        ts.assertResult(3);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java\n@@ -1165,4 +1165,37 @@ public void run() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void eagerDispose() {\n+        final PublishSubject<Integer> ps1 = PublishSubject.create();\n+        final PublishSubject<Integer> ps2 = PublishSubject.create();\n+\n+        TestObserver<Integer> ts = new TestObserver<Integer>() {\n+            @Override\n+            public void onNext(Integer t) {\n+                super.onNext(t);\n+                cancel();\n+                if (ps1.hasObservers()) {\n+                    onError(new IllegalStateException(\"ps1 not disposed\"));\n+                } else\n+                if (ps2.hasObservers()) {\n+                    onError(new IllegalStateException(\"ps2 not disposed\"));\n+                } else {\n+                    onComplete();\n+                }\n+            }\n+        };\n+\n+        Observable.combineLatest(ps1, ps2, new BiFunction<Integer, Integer, Integer>() {\n+            @Override\n+            public Integer apply(Integer t1, Integer t2) throws Exception {\n+                return t1 + t2;\n+            }\n+        })\n+        .subscribe(ts);\n+\n+        ps1.onNext(1);\n+        ps2.onNext(2);\n+        ts.assertResult(3);\n+    }\n }",
    "output": "Fix Obs.combineLatest to dispose eagerly"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java\n@@ -496,6 +496,8 @@ void drainLoop() {\n                     if (isHolder) {\n                         ConsumerIndexHolder consumerIndexHolder = (ConsumerIndexHolder) o;\n                         if (producerIndex == consumerIndexHolder.index) {\n+                            w.onComplete();\n+\n                             w = UnicastProcessor.<T>create(bufferSize);\n                             window = w;\n \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java\n@@ -439,6 +439,8 @@ void drainLoop() {\n                     if (isHolder) {\n                         ConsumerIndexHolder consumerIndexHolder = (ConsumerIndexHolder) o;\n                         if (producerIndex == consumerIndexHolder.index) {\n+                            w.onComplete();\n+\n                             w = UnicastSubject.create(bufferSize);\n                             window = w;\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java\n@@ -686,4 +686,22 @@ public Flowable<Integer> apply(Flowable<Integer> v) throws Exception {\n         .awaitDone(1, TimeUnit.SECONDS)\n         .assertResult(1, 2);\n     }\n+\n+    @Test\n+    public void sizeTimeTimeout() {\n+        TestScheduler scheduler = new TestScheduler();\n+        PublishProcessor<Integer> ps = PublishProcessor.<Integer>create();\n+\n+        TestSubscriber<Flowable<Integer>> ts = ps.window(5, TimeUnit.MILLISECONDS, scheduler, 100)\n+        .test()\n+        .assertValueCount(1);\n+\n+        scheduler.advanceTimeBy(5, TimeUnit.MILLISECONDS);\n+\n+        ts.assertValueCount(2)\n+        .assertNoErrors()\n+        .assertNotComplete();\n+\n+        ts.values().get(0).test().assertResult();\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java\n@@ -585,4 +585,22 @@ public ObservableSource<Integer> apply(Observable<Integer> v) throws Exception {\n         .awaitDone(1, TimeUnit.SECONDS)\n         .assertResult(1, 2);\n     }\n+\n+    @Test\n+    public void sizeTimeTimeout() {\n+        TestScheduler scheduler = new TestScheduler();\n+        Subject<Integer> ps = PublishSubject.<Integer>create();\n+\n+        TestObserver<Observable<Integer>> ts = ps.window(5, TimeUnit.MILLISECONDS, scheduler, 100)\n+        .test()\n+        .assertValueCount(1);\n+\n+        scheduler.advanceTimeBy(5, TimeUnit.MILLISECONDS);\n+\n+        ts.assertValueCount(2)\n+        .assertNoErrors()\n+        .assertNotComplete();\n+\n+        ts.values().get(0).test().assertResult();\n+    }\n }",
    "output": "Fix window(time, size) not completing windows on timeout"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/functions/Function7.java b/src/main/java/io/reactivex/functions/Function7.java\n--- a/src/main/java/io/reactivex/functions/Function7.java\n+++ b/src/main/java/io/reactivex/functions/Function7.java\n@@ -13,6 +13,8 @@\n \n package io.reactivex.functions;\n \n+import io.reactivex.annotations.NonNull;\n+\n /**\n  * A functional interface (callback) that computes a value based on multiple input values.\n  * @param <T1> the first value type\n@@ -37,5 +39,6 @@ public interface Function7<T1, T2, T3, T4, T5, T6, T7, R> {\n      * @return the result value\n      * @throws Exception on error\n      */\n-    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) throws Exception;\n+    @NonNull\n+    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6, @NonNull T7 t7) throws Exception;\n }",
    "output": "Add missing @NonNull attribute to Function7"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java\n--- a/src/main/java/io/reactivex/Single.java\n+++ b/src/main/java/io/reactivex/Single.java\n@@ -1798,6 +1798,32 @@ public final Single<T> doAfterSuccess(Consumer<? super T> onAfterSuccess) {\n         return RxJavaPlugins.onAssembly(new SingleDoAfterSuccess<T>(this, onAfterSuccess));\n     }\n \n+    /**\n+     * Registers an {@link Action} to be called after this Single invokes either onSuccess or onError.\n+     * * <p>Note that the {@code doAfterSuccess} action is shared between subscriptions and as such\n+     * should be thread-safe.</p>\n+     * <p>\n+     * <img width=\"640\" height=\"310\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterTerminate.png\" alt=\"\">\n+     * <dl>\n+     *  <dt><b>Scheduler:</b></dt>\n+     *  <dd>{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.</dd>\n+     * </dl>\n+     *\n+     * @param onAfterTerminate\n+     *            an {@link Action} to be invoked when the source Single finishes\n+     * @return a Single that emits the same items as the source Single, then invokes the\n+     *         {@link Action}\n+     * @see <a href=\"http://reactivex.io/documentation/operators/do.html\">ReactiveX operators documentation: Do</a>\n+     * @since 2.0.6 - experimental\n+     */\n+    @CheckReturnValue\n+    @SchedulerSupport(SchedulerSupport.NONE)\n+    @Experimental\n+    public final Single<T> doAfterTerminate(Action onAfterTerminate) {\n+        ObjectHelper.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\");\n+        return RxJavaPlugins.onAssembly(new SingleDoAfterTerminate<T>(this, onAfterTerminate));\n+    }\n+\n     /**\n      * Calls the specified action after this Single signals onSuccess or onError or gets disposed by\n      * the downstream.\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/single/SingleDoAfterTerminate.java b/src/main/java/io/reactivex/internal/operators/single/SingleDoAfterTerminate.java\n--- a/src/main/java/io/reactivex/internal/operators/single/SingleDoAfterTerminate.java\n+++ b/src/main/java/io/reactivex/internal/operators/single/SingleDoAfterTerminate.java\n@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.single;\n+\n+import io.reactivex.Single;\n+import io.reactivex.SingleObserver;\n+import io.reactivex.SingleSource;\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.exceptions.Exceptions;\n+import io.reactivex.functions.Action;\n+import io.reactivex.internal.disposables.DisposableHelper;\n+import io.reactivex.plugins.RxJavaPlugins;\n+\n+/**\n+ * Calls an action after pushing the current item or an error to the downstream.\n+ * @param <T> the value type\n+ * @since 2.0.6 - experimental\n+ */\n+public final class SingleDoAfterTerminate<T> extends Single<T> {\n+\n+    final SingleSource<T> source;\n+\n+    final Action onAfterTerminate;\n+\n+    public SingleDoAfterTerminate(SingleSource<T> source, Action onAfterTerminate) {\n+        this.source = source;\n+        this.onAfterTerminate = onAfterTerminate;\n+    }\n+\n+    @Override\n+    protected void subscribeActual(SingleObserver<? super T> s) {\n+        source.subscribe(new DoAfterTerminateObserver<T>(s, onAfterTerminate));\n+    }\n+\n+    static final class DoAfterTerminateObserver<T> implements SingleObserver<T>, Disposable {\n+\n+        final SingleObserver<? super T> actual;\n+\n+        final Action onAfterTerminate;\n+\n+        Disposable d;\n+\n+        DoAfterTerminateObserver(SingleObserver<? super T> actual, Action onAfterTerminate) {\n+            this.actual = actual;\n+            this.onAfterTerminate = onAfterTerminate;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Disposable d) {\n+            if (DisposableHelper.validate(this.d, d)) {\n+                this.d = d;\n+\n+                actual.onSubscribe(this);\n+            }\n+        }\n+\n+        @Override\n+        public void onSuccess(T t) {\n+            actual.onSuccess(t);\n+\n+            onAfterTerminate();\n+        }\n+\n+        @Override\n+        public void onError(Throwable e) {\n+            actual.onError(e);\n+\n+            onAfterTerminate();\n+        }\n+\n+        @Override\n+        public void dispose() {\n+            d.dispose();\n+        }\n+\n+        @Override\n+        public boolean isDisposed() {\n+            return d.isDisposed();\n+        }\n+\n+        private void onAfterTerminate() {\n+            try {\n+                onAfterTerminate.run();\n+            } catch (Throwable ex) {\n+                Exceptions.throwIfFatal(ex);\n+                RxJavaPlugins.onError(ex);\n+            }\n+        }\n+    }\n+}\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/single/SingleDoAfterTerminateTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleDoAfterTerminateTest.java\n--- a/src/test/java/io/reactivex/internal/operators/single/SingleDoAfterTerminateTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/single/SingleDoAfterTerminateTest.java\n@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2016-present, RxJava Contributors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.single;\n+\n+import io.reactivex.Single;\n+import io.reactivex.SingleSource;\n+import io.reactivex.TestHelper;\n+import io.reactivex.exceptions.TestException;\n+import io.reactivex.functions.Action;\n+import io.reactivex.functions.Function;\n+import io.reactivex.internal.functions.Functions;\n+import io.reactivex.observers.TestObserver;\n+import io.reactivex.plugins.RxJavaPlugins;\n+import io.reactivex.subjects.PublishSubject;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class SingleDoAfterTerminateTest {\n+\n+    private final int[] call = { 0 };\n+\n+    private final Action afterTerminate = new Action() {\n+        @Override\n+        public void run() throws Exception {\n+            call[0]++;\n+        }\n+    };\n+\n+    private final TestObserver<Integer> ts = new TestObserver<Integer>();\n+\n+    @Test\n+    public void just() {\n+        Single.just(1)\n+        .doAfterTerminate(afterTerminate)\n+        .subscribeWith(ts)\n+        .assertResult(1);\n+\n+        assertAfterTerminateCalledOnce();\n+    }\n+\n+    @Test\n+    public void error() {\n+        Single.<Integer>error(new TestException())\n+        .doAfterTerminate(afterTerminate)\n+        .subscribeWith(ts)\n+        .assertFailure(TestException.class);\n+\n+        assertAfterTerminateCalledOnce();\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void afterTerminateActionNull() {\n+        Single.just(1).doAfterTerminate(null);\n+    }\n+\n+    @Test\n+    public void justConditional() {\n+        Single.just(1)\n+        .doAfterTerminate(afterTerminate)\n+        .filter(Functions.alwaysTrue())\n+        .subscribeWith(ts)\n+        .assertResult(1);\n+\n+        assertAfterTerminateCalledOnce();\n+    }\n+\n+    @Test\n+    public void errorConditional() {\n+        Single.<Integer>error(new TestException())\n+        .doAfterTerminate(afterTerminate)\n+        .filter(Functions.alwaysTrue())\n+        .subscribeWith(ts)\n+        .assertFailure(TestException.class);\n+\n+        assertAfterTerminateCalledOnce();\n+    }\n+\n+    @Test\n+    public void actionThrows() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            Single.just(1)\n+            .doAfterTerminate(new Action() {\n+                @Override\n+                public void run() throws Exception {\n+                    throw new TestException();\n+                }\n+            })\n+            .test()\n+            .assertResult(1);\n+\n+            TestHelper.assertUndeliverable(errors, 0, TestException.class);\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n+\n+    @Test\n+    public void dispose() {\n+        TestHelper.checkDisposed(PublishSubject.<Integer>create().singleOrError().doAfterTerminate(afterTerminate));\n+    }\n+\n+    @Test\n+    public void doubleOnSubscribe() {\n+        TestHelper.checkDoubleOnSubscribeSingle(new Function<Single<Integer>, SingleSource<Integer>>() {\n+            @Override\n+            public SingleSource<Integer> apply(Single<Integer> m) throws Exception {\n+                return m.doAfterTerminate(afterTerminate);\n+            }\n+        });\n+    }\n+\n+    private void assertAfterTerminateCalledOnce() {\n+        assertEquals(1, call[0]);\n+    }\n+}",
    "output": "Add doAfterTerminate callback to the Single type.\n\n* Add doAfterTerminate callback to the Single type.\r\n\r\n* Mark the doAfterTerminate() experimental since 2.0.6"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java\n--- a/src/main/java/io/reactivex/Completable.java\n+++ b/src/main/java/io/reactivex/Completable.java\n@@ -1708,8 +1708,6 @@ public final Disposable subscribe(final Action onComplete, final Consumer<? supe\n      * If the Completable emits an error, it is wrapped into an\n      * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}\n      * and routed to the RxJavaPlugins.onError handler.\n-     * <p>\n-     * If this Completable emits an error, it is sent to RxJavaPlugins.onError and gets swallowed.\n      * <dl>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.</dd>",
    "output": "Remove documentation leftover That wrongly states that the error will be swallowed"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java\n@@ -336,7 +336,10 @@ public void connect(Consumer<? super Disposable> connection) {\n     }\n \n     @SuppressWarnings(\"rawtypes\")\n-    static final class ReplaySubscriber<T> implements Subscriber<T>, Disposable {\n+    static final class ReplaySubscriber<T>\n+    extends AtomicReference<Subscription>\n+    implements Subscriber<T>, Disposable {\n+        private static final long serialVersionUID = 7224554242710036740L;\n         /** Holds notifications from upstream. */\n         final ReplayBuffer<T> buffer;\n         /** Indicates this Subscriber received a terminal event. */\n@@ -361,8 +364,6 @@ static final class ReplaySubscriber<T> implements Subscriber<T>, Disposable {\n         long maxChildRequested;\n         /** Counts the outstanding upstream requests until the producer arrives. */\n         long maxUpstreamRequested;\n-        /** The upstream producer. */\n-        volatile Subscription subscription;\n \n         @SuppressWarnings(\"unchecked\")\n         ReplaySubscriber(ReplayBuffer<T> buffer) {\n@@ -386,7 +387,7 @@ public void dispose() {\n             // current.compareAndSet(ReplaySubscriber.this, null);\n             // we don't care if it fails because it means the current has\n             // been replaced in the meantime\n-            subscription.cancel();\n+            SubscriptionHelper.cancel(this);\n         }\n \n         /**\n@@ -476,8 +477,7 @@ void remove(InnerSubscription<T> p) {\n \n         @Override\n         public void onSubscribe(Subscription p) {\n-            if (SubscriptionHelper.validate(subscription, p)) {\n-                subscription = p;\n+            if (SubscriptionHelper.setOnce(this, p)) {\n                 manageRequests();\n                 for (InnerSubscription<T> rp : subscribers.get()) {\n                     buffer.replay(rp);\n@@ -548,7 +548,7 @@ void manageRequests() {\n                 }\n \n                 long ur = maxUpstreamRequested;\n-                Subscription p = subscription;\n+                Subscription p = get();\n \n                 long diff = maxTotalRequests - ri;\n                 if (diff != 0L) {\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java\n@@ -316,7 +316,10 @@ public void connect(Consumer<? super Disposable> connection) {\n     }\n \n     @SuppressWarnings(\"rawtypes\")\n-    static final class ReplayObserver<T> implements Observer<T>, Disposable {\n+    static final class ReplayObserver<T>\n+    extends AtomicReference<Disposable>\n+    implements Observer<T>, Disposable {\n+        private static final long serialVersionUID = -533785617179540163L;\n         /** Holds notifications from upstream. */\n         final ReplayBuffer<T> buffer;\n         /** Indicates this Observer received a terminal event. */\n@@ -335,9 +338,6 @@ static final class ReplayObserver<T> implements Observer<T>, Disposable {\n          */\n         final AtomicBoolean shouldConnect;\n \n-        /** The upstream producer. */\n-        volatile Disposable subscription;\n-\n         ReplayObserver(ReplayBuffer<T> buffer) {\n             this.buffer = buffer;\n \n@@ -358,7 +358,7 @@ public void dispose() {\n             // current.compareAndSet(ReplayObserver.this, null);\n             // we don't care if it fails because it means the current has\n             // been replaced in the meantime\n-            subscription.dispose();\n+            DisposableHelper.dispose(this);\n         }\n \n         /**\n@@ -444,8 +444,7 @@ void remove(InnerDisposable<T> producer) {\n \n         @Override\n         public void onSubscribe(Disposable p) {\n-            if (DisposableHelper.validate(this.subscription, p)) {\n-                subscription = p;\n+            if (DisposableHelper.setOnce(this, p)) {\n                 replay();\n             }\n         }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java\n@@ -873,4 +873,25 @@ public void subscribe(FlowableEmitter<Object> s) throws Exception {\n         .test(0L)\n         .assertFailure(MissingBackpressureException.class);\n     }\n+\n+    @Test\n+    public void delayedUpstreamOnSubscribe() {\n+        final Subscriber<?>[] sub = { null };\n+\n+        new Flowable<Integer>() {\n+            @Override\n+            protected void subscribeActual(Subscriber<? super Integer> s) {\n+                sub[0] = s;\n+            }\n+        }\n+        .publish()\n+        .connect()\n+        .dispose();\n+\n+        BooleanSubscription bs = new BooleanSubscription();\n+\n+        sub[0].onSubscribe(bs);\n+\n+        assertTrue(bs.isCancelled());\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java\n@@ -1711,4 +1711,24 @@ public void testSizedTruncation() {\n         Assert.assertFalse(buf.hasError());\n     }\n \n+    @Test\n+    public void delayedUpstreamOnSubscribe() {\n+        final Subscriber<?>[] sub = { null };\n+\n+        new Flowable<Integer>() {\n+            @Override\n+            protected void subscribeActual(Subscriber<? super Integer> s) {\n+                sub[0] = s;\n+            }\n+        }\n+        .replay()\n+        .connect()\n+        .dispose();\n+\n+        BooleanSubscription bs = new BooleanSubscription();\n+\n+        sub[0].onSubscribe(bs);\n+\n+        assertTrue(bs.isCancelled());\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservablePublishTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservablePublishTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservablePublishTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservablePublishTest.java\n@@ -699,4 +699,25 @@ public ObservableSource<Integer> apply(Observable<Integer> v) throws Exception {\n \n         assertFalse(ps.hasObservers());\n     }\n+\n+    @Test\n+    public void delayedUpstreamOnSubscribe() {\n+        final Observer<?>[] sub = { null };\n+\n+        new Observable<Integer>() {\n+            @Override\n+            protected void subscribeActual(Observer<? super Integer> s) {\n+                sub[0] = s;\n+            }\n+        }\n+        .publish()\n+        .connect()\n+        .dispose();\n+\n+        Disposable bs = Disposables.empty();\n+\n+        sub[0].onSubscribe(bs);\n+\n+        assertTrue(bs.isDisposed());\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java\n@@ -21,14 +21,14 @@\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-import io.reactivex.annotations.NonNull;\n import org.junit.*;\n import org.mockito.InOrder;\n \n import io.reactivex.*;\n import io.reactivex.Observable;\n import io.reactivex.Observer;\n import io.reactivex.Scheduler.Worker;\n+import io.reactivex.annotations.NonNull;\n import io.reactivex.disposables.*;\n import io.reactivex.exceptions.TestException;\n import io.reactivex.functions.*;\n@@ -1490,4 +1490,25 @@ public void onNext(Integer t) {\n \n         to.assertValues(1);\n     }\n+\n+    @Test\n+    public void delayedUpstreamOnSubscribe() {\n+        final Observer<?>[] sub = { null };\n+\n+        new Observable<Integer>() {\n+            @Override\n+            protected void subscribeActual(Observer<? super Integer> s) {\n+                sub[0] = s;\n+            }\n+        }\n+        .replay()\n+        .connect()\n+        .dispose();\n+\n+        Disposable bs = Disposables.empty();\n+\n+        sub[0].onSubscribe(bs);\n+\n+        assertTrue(bs.isDisposed());\n+    }\n }",
    "output": "Fix replay() cancel/dispose NPE"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java\n--- a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java\n+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java\n@@ -49,7 +49,7 @@\n  */\n public final class RxJavaPlugins {\n     @Nullable\n-    static volatile Consumer<Throwable> errorHandler;\n+    static volatile Consumer<? super Throwable> errorHandler;\n \n     @Nullable\n     static volatile Function<Runnable, Runnable> onScheduleHandler;\n@@ -197,7 +197,7 @@ public static Function<Scheduler, Scheduler> getComputationSchedulerHandler() {\n      * @return the hook consumer, may be null\n      */\n     @Nullable\n-    public static Consumer<Throwable> getErrorHandler() {\n+    public static Consumer<? super Throwable> getErrorHandler() {\n         return errorHandler;\n     }\n \n@@ -356,7 +356,7 @@ public static Scheduler onComputationScheduler(@NonNull Scheduler defaultSchedul\n      * @param error the error to report\n      */\n     public static void onError(@NonNull Throwable error) {\n-        Consumer<Throwable> f = errorHandler;\n+        Consumer<? super Throwable> f = errorHandler;\n \n         if (error == null) {\n             error = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\");\n@@ -497,7 +497,7 @@ public static void setComputationSchedulerHandler(@Nullable Function<Scheduler,\n      * Sets the specific hook function.\n      * @param handler the hook function to set, null allowed\n      */\n-    public static void setErrorHandler(@Nullable Consumer<Throwable> handler) {\n+    public static void setErrorHandler(@Nullable Consumer<? super Throwable> handler) {\n         if (lockdown) {\n             throw new IllegalStateException(\"Plugins can't be changed anymore\");\n         }\n\ndiff --git a/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java\n--- a/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java\n+++ b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java\n@@ -1168,7 +1168,28 @@ public void uncaughtException(Thread t, Throwable e) {\n         }\n     }\n \n-    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    /**\n+     * Ensure setErrorHandler() accepts a consumer with \"? super Throwable\"\n+     */\n+    @Test\n+    public void onErrorWithSuper() throws Exception {\n+        try {\n+            Consumer<? super Throwable> errorHandler = new Consumer<Throwable>() {\n+                @Override\n+                public void accept(Throwable t) {\n+                    throw new TestException(\"Forced failure 2\");\n+                }\n+            };\n+            RxJavaPlugins.setErrorHandler(errorHandler);\n+\n+            Consumer<? super Throwable> errorHandler1 = RxJavaPlugins.getErrorHandler();\n+            assertSame(errorHandler, errorHandler1);\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\" })\n     @Test\n     public void clearIsPassthrough() {\n         try {",
    "output": "Use bounded wildcards for errorHandler (fixes #5045) * use bounded wildcards for errorHandler (fixes #5045) * add test to ensure signature"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java\n@@ -14,7 +14,6 @@\n package io.reactivex.internal.operators.observable;\n \n import java.util.ArrayDeque;\n-import java.util.concurrent.Callable;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import io.reactivex.*;\n@@ -218,7 +217,6 @@ public void innerComplete(InnerQueuedObserver<R> inner) {\n             drain();\n         }\n \n-        @SuppressWarnings(\"unchecked\")\n         @Override\n         public void drain() {\n             if (getAndIncrement() != 0) {\n@@ -276,23 +274,6 @@ public void drain() {\n                         return;\n                     }\n \n-                    if (source instanceof Callable) {\n-                        R w;\n-\n-                        try {\n-                            w = ((Callable<R>)source).call();\n-                        } catch (Throwable ex) {\n-                            Exceptions.throwIfFatal(ex);\n-                            error.addThrowable(ex);\n-                            continue;\n-                        }\n-\n-                        if (w != null) {\n-                            a.onNext(w);\n-                        }\n-                        continue;\n-                    }\n-\n                     InnerQueuedObserver<R> inner = new InnerQueuedObserver<R>(this, prefetch);\n \n                     observers.offer(inner);\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n@@ -1175,4 +1175,22 @@ public void innerLong() {\n         .assertComplete()\n         .assertNoErrors();\n     }\n+\n+    @Test\n+    public void oneDelayed() {\n+        Flowable.just(1, 2, 3, 4, 5)\n+        .concatMapEager(new Function<Integer, Flowable<Integer>>() {\n+            @Override\n+            public Flowable<Integer> apply(Integer i) throws Exception {\n+                return i == 3 ? Flowable.just(i) : Flowable\n+                        .just(i)\n+                        .delay(1, TimeUnit.MILLISECONDS, Schedulers.io());\n+            }\n+        })\n+        .observeOn(Schedulers.io())\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult(1, 2, 3, 4, 5)\n+        ;\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java\n@@ -983,4 +983,22 @@ public ObservableSource<Object> apply(Object v) throws Exception {\n             }\n         });\n     }\n+\n+    @Test\n+    public void oneDelayed() {\n+        Observable.just(1, 2, 3, 4, 5)\n+        .concatMapEager(new Function<Integer, ObservableSource<Integer>>() {\n+            @Override\n+            public ObservableSource<Integer> apply(Integer i) throws Exception {\n+                return i == 3 ? Observable.just(i) : Observable\n+                        .just(i)\n+                        .delay(1, TimeUnit.MILLISECONDS, Schedulers.io());\n+            }\n+        })\n+        .observeOn(Schedulers.io())\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertResult(1, 2, 3, 4, 5)\n+        ;\n+    }\n }",
    "output": "Fix Observable.concatMapEager bad logic for immediate scalars * fix Observable.concatMapEager bad logic for immediate scalars * Don't print-log"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java\n@@ -13,14 +13,14 @@\n \n package io.reactivex.internal.operators.flowable;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.*;\n \n import org.reactivestreams.*;\n \n import io.reactivex.exceptions.Exceptions;\n import io.reactivex.functions.BiFunction;\n-import io.reactivex.internal.subscriptions.*;\n-import io.reactivex.plugins.RxJavaPlugins;\n+import io.reactivex.internal.functions.ObjectHelper;\n+import io.reactivex.internal.subscriptions.SubscriptionHelper;\n import io.reactivex.subscribers.SerializedSubscriber;\n \n public final class FlowableWithLatestFrom<T, U, R> extends AbstractFlowableWithUpstream<T, R> {\n@@ -37,6 +37,8 @@ protected void subscribeActual(Subscriber<? super R> s) {\n         final SerializedSubscriber<R> serial = new SerializedSubscriber<R>(s);\n         final WithLatestFromSubscriber<T, U, R> wlf = new WithLatestFromSubscriber<T, U, R>(serial, combiner);\n \n+        serial.onSubscribe(wlf);\n+\n         other.subscribe(new Subscriber<U>() {\n             @Override\n             public void onSubscribe(Subscription s) {\n@@ -73,6 +75,8 @@ static final class WithLatestFromSubscriber<T, U, R> extends AtomicReference<U>\n \n         final AtomicReference<Subscription> s = new AtomicReference<Subscription>();\n \n+        final AtomicLong requested = new AtomicLong();\n+\n         final AtomicReference<Subscription> other = new AtomicReference<Subscription>();\n \n         WithLatestFromSubscriber(Subscriber<? super R> actual, BiFunction<? super T, ? super U, ? extends R> combiner) {\n@@ -81,9 +85,7 @@ static final class WithLatestFromSubscriber<T, U, R> extends AtomicReference<U>\n         }\n         @Override\n         public void onSubscribe(Subscription s) {\n-            if (SubscriptionHelper.setOnce(this.s, s)) {\n-                actual.onSubscribe(this);\n-            }\n+            SubscriptionHelper.deferredSetOnce(this.s, requested, s);\n         }\n \n         @Override\n@@ -92,7 +94,7 @@ public void onNext(T t) {\n             if (u != null) {\n                 R r;\n                 try {\n-                    r = combiner.apply(t, u);\n+                    r = ObjectHelper.requireNonNull(combiner.apply(t, u), \"The combiner returned a null value\");\n                 } catch (Throwable e) {\n                     Exceptions.throwIfFatal(e);\n                     cancel();\n@@ -117,12 +119,12 @@ public void onComplete() {\n \n         @Override\n         public void request(long n) {\n-            s.get().request(n);\n+            SubscriptionHelper.deferredRequest(s, requested, n);\n         }\n \n         @Override\n         public void cancel() {\n-            s.get().cancel();\n+            SubscriptionHelper.cancel(s);\n             SubscriptionHelper.cancel(other);\n         }\n \n@@ -131,16 +133,8 @@ public boolean setOther(Subscription o) {\n         }\n \n         public void otherError(Throwable e) {\n-            if (s.compareAndSet(null, SubscriptionHelper.CANCELLED)) {\n-                EmptySubscription.error(e, actual);\n-            } else {\n-                if (s.get() != SubscriptionHelper.CANCELLED) {\n-                    cancel();\n-                    actual.onError(e);\n-                } else {\n-                    RxJavaPlugins.onError(e);\n-                }\n-            }\n+            SubscriptionHelper.cancel(s);\n+            actual.onError(e);\n         }\n     }\n }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFrom.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFrom.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFrom.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFrom.java\n@@ -20,6 +20,7 @@\n import io.reactivex.exceptions.Exceptions;\n import io.reactivex.functions.BiFunction;\n import io.reactivex.internal.disposables.DisposableHelper;\n+import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.observers.SerializedObserver;\n \n public final class ObservableWithLatestFrom<T, U, R> extends AbstractObservableWithUpstream<T, R> {\n@@ -37,7 +38,7 @@ public void subscribeActual(Observer<? super R> t) {\n         final SerializedObserver<R> serial = new SerializedObserver<R>(t);\n         final WithLatestFromObserver<T, U, R> wlf = new WithLatestFromObserver<T, U, R>(serial, combiner);\n \n-        t.onSubscribe(wlf);\n+        serial.onSubscribe(wlf);\n \n         other.subscribe(new Observer<U>() {\n             @Override\n@@ -91,7 +92,7 @@ public void onNext(T t) {\n             if (u != null) {\n                 R r;\n                 try {\n-                    r = combiner.apply(t, u);\n+                    r = ObjectHelper.requireNonNull(combiner.apply(t, u), \"The combiner returned a null value\");\n                 } catch (Throwable e) {\n                     Exceptions.throwIfFatal(e);\n                     dispose();\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java\n@@ -681,4 +681,31 @@ public Integer apply(Integer a, Integer b) throws Exception {\n             RxJavaPlugins.reset();\n         }\n     }\n+\n+    @Test\n+    public void combineToNull1() {\n+        Flowable.just(1)\n+        .withLatestFrom(Flowable.just(2), new BiFunction<Integer, Integer, Object>() {\n+            @Override\n+            public Object apply(Integer a, Integer b) throws Exception {\n+                return null;\n+            }\n+        })\n+        .test()\n+        .assertFailure(NullPointerException.class);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void combineToNull2() {\n+        Flowable.just(1)\n+        .withLatestFrom(Arrays.asList(Flowable.just(2), Flowable.just(3)), new Function<Object[], Object>() {\n+            @Override\n+            public Object apply(Object[] o) throws Exception {\n+                return null;\n+            }\n+        })\n+        .test()\n+        .assertFailure(NullPointerException.class);\n+    }\n }\n\\ No newline at end of file\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromTest.java\n@@ -21,9 +21,9 @@\n import org.junit.*;\n import org.mockito.InOrder;\n \n+import io.reactivex.*;\n import io.reactivex.Observable;\n import io.reactivex.Observer;\n-import io.reactivex.TestHelper;\n import io.reactivex.disposables.Disposables;\n import io.reactivex.exceptions.TestException;\n import io.reactivex.functions.*;\n@@ -620,4 +620,31 @@ public Object apply(Integer a, Integer b, Integer c) throws Exception {\n             RxJavaPlugins.reset();\n         }\n     }\n+\n+    @Test\n+    public void combineToNull1() {\n+        Observable.just(1)\n+        .withLatestFrom(Observable.just(2), new BiFunction<Integer, Integer, Object>() {\n+            @Override\n+            public Object apply(Integer a, Integer b) throws Exception {\n+                return null;\n+            }\n+        })\n+        .test()\n+        .assertFailure(NullPointerException.class);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void combineToNull2() {\n+        Observable.just(1)\n+        .withLatestFrom(Arrays.asList(Observable.just(2), Observable.just(3)), new Function<Object[], Object>() {\n+            @Override\n+            public Object apply(Object[] o) throws Exception {\n+                return null;\n+            }\n+        })\n+        .test()\n+        .assertFailure(NullPointerException.class);\n+    }\n }\n\\ No newline at end of file",
    "output": "Fix withLatestFrom null checks, lifecycle"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java\n--- a/src/main/java/io/reactivex/Completable.java\n+++ b/src/main/java/io/reactivex/Completable.java\n@@ -1586,6 +1586,24 @@ public final <T> Flowable<T> startWith(Publisher<T> other) {\n         return this.<T>toFlowable().startWith(other);\n     }\n \n+    /**\n+     * Hides the identity of this Completable and its Disposable.\n+     * <p>Allows preventing certain identity-based\n+     * optimizations (fusion).\n+     * <dl>\n+     *  <dt><b>Scheduler:</b></dt>\n+     *  <dd>{@code hide} does not operate by default on a particular {@link Scheduler}.</dd>\n+     * </dl>\n+     * @return the new Completable instance\n+     * @since 2.0.5 - experimental\n+     */\n+    @Experimental\n+    @CheckReturnValue\n+    @SchedulerSupport(SchedulerSupport.NONE)\n+    public final Completable hide() {\n+        return RxJavaPlugins.onAssembly(new CompletableHide(this));\n+    }\n+\n     /**\n      * Subscribes to this CompletableConsumable and returns a Disposable which can be used to cancel\n      * the subscription.\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableHide.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableHide.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableHide.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableHide.java\n@@ -0,0 +1,78 @@\n+/**\n+ * Copyright 2016 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.completable;\n+\n+import io.reactivex.Completable;\n+import io.reactivex.CompletableObserver;\n+import io.reactivex.CompletableSource;\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.internal.disposables.DisposableHelper;\n+\n+/**\n+ * Hides the identity of the upstream Completable and its Disposable sent through onSubscribe.\n+ */\n+public final class CompletableHide extends Completable {\n+\n+    final CompletableSource source;\n+\n+    public CompletableHide(CompletableSource source) {\n+        this.source = source;\n+    }\n+\n+    @Override\n+    protected void subscribeActual(CompletableObserver observer) {\n+        source.subscribe(new HideCompletableObserver(observer));\n+    }\n+\n+    static final class HideCompletableObserver implements CompletableObserver, Disposable {\n+\n+        final CompletableObserver actual;\n+\n+        Disposable d;\n+\n+        HideCompletableObserver(CompletableObserver actual) {\n+            this.actual = actual;\n+        }\n+\n+        @Override\n+        public void dispose() {\n+            d.dispose();\n+            d = DisposableHelper.DISPOSED;\n+        }\n+\n+        @Override\n+        public boolean isDisposed() {\n+            return d.isDisposed();\n+        }\n+\n+        @Override\n+        public void onSubscribe(Disposable d) {\n+            if (DisposableHelper.validate(this.d, d)) {\n+                this.d = d;\n+\n+                actual.onSubscribe(this);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable e) {\n+            actual.onError(e);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            actual.onComplete();\n+        }\n+    }\n+}\n\ndiff --git a/src/test/java/io/reactivex/TestHelper.java b/src/test/java/io/reactivex/TestHelper.java\n--- a/src/test/java/io/reactivex/TestHelper.java\n+++ b/src/test/java/io/reactivex/TestHelper.java\n@@ -32,6 +32,7 @@\n import io.reactivex.functions.*;\n import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.fuseable.*;\n+import io.reactivex.internal.operators.completable.CompletableToFlowable;\n import io.reactivex.internal.operators.maybe.MaybeToFlowable;\n import io.reactivex.internal.operators.single.SingleToFlowable;\n import io.reactivex.internal.subscriptions.BooleanSubscription;\n@@ -1962,6 +1963,28 @@ public static <T, U> void checkDisposedMaybe(Function<Maybe<T>, ? extends MaybeS\n         assertFalse(\"Dispose not propagated!\", pp.hasSubscribers());\n     }\n \n+    /**\n+     * Check if the operator applied to a Completable source propagates dispose properly.\n+     * @param composer the function to apply an operator to the provided Completable source\n+     */\n+    public static void checkDisposedCompletable(Function<Completable, ? extends CompletableSource> composer) {\n+        PublishProcessor<Integer> pp = PublishProcessor.create();\n+\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+\n+        try {\n+            new CompletableToFlowable<Integer>(composer.apply(pp.ignoreElements())).subscribe(ts);\n+        } catch (Throwable ex) {\n+            throw ExceptionHelper.wrapOrThrow(ex);\n+        }\n+\n+        assertTrue(\"Not subscribed to source!\", pp.hasSubscribers());\n+\n+        ts.cancel();\n+\n+        assertFalse(\"Dispose not propagated!\", pp.hasSubscribers());\n+    }\n+\n     /**\n      * Check if the operator applied to a Maybe source propagates dispose properly.\n      * @param <T> the source value type\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableHideTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableHideTest.java\n--- a/src/test/java/io/reactivex/internal/operators/completable/CompletableHideTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableHideTest.java\n@@ -0,0 +1,85 @@\n+/**\n+ * Copyright 2016 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.completable;\n+\n+import io.reactivex.Completable;\n+import io.reactivex.CompletableSource;\n+import io.reactivex.TestHelper;\n+import io.reactivex.exceptions.TestException;\n+import io.reactivex.functions.Function;\n+import io.reactivex.processors.PublishProcessor;\n+import io.reactivex.subjects.CompletableSubject;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertFalse;\n+\n+public class CompletableHideTest {\n+\n+    @Test\n+    public void never() {\n+        Completable.never()\n+        .hide()\n+        .test()\n+        .assertNotComplete()\n+        .assertNoErrors();\n+    }\n+\n+    @Test\n+    public void complete() {\n+        Completable.complete()\n+        .hide()\n+        .test()\n+        .assertResult();\n+    }\n+\n+    @Test\n+    public void error() {\n+        Completable.error(new TestException())\n+        .hide()\n+        .test()\n+        .assertFailure(TestException.class);\n+    }\n+\n+    @Test\n+    public void hidden() {\n+        assertFalse(CompletableSubject.create().hide() instanceof CompletableSubject);\n+    }\n+\n+    @Test\n+    public void dispose() {\n+        TestHelper.checkDisposedCompletable(new Function<Completable, CompletableSource>() {\n+            @Override\n+            public CompletableSource apply(Completable m) throws Exception {\n+                return m.hide();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void isDisposed() {\n+        PublishProcessor<Integer> pp = PublishProcessor.create();\n+\n+        TestHelper.checkDisposed(pp.ignoreElements().hide());\n+    }\n+\n+    @Test\n+    public void doubleOnSubscribe() {\n+        TestHelper.checkDoubleOnSubscribeCompletable(new Function<Completable, Completable>() {\n+            @Override\n+            public Completable apply(Completable f) throws Exception {\n+                return f.hide();\n+            }\n+        });\n+    }\n+}",
    "output": "Add Completable.hide()"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java\n--- a/src/main/java/io/reactivex/Flowable.java\n+++ b/src/main/java/io/reactivex/Flowable.java\n@@ -6483,11 +6483,12 @@ public final <U> Single<U> collectInto(final U initialItem, BiConsumer<? super U\n      * @return the source Publisher, transformed by the transformer function\n      * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators</a>\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @CheckReturnValue\n     @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    public final <R> Flowable<R> compose(FlowableTransformer<T, R> composer) {\n-        return fromPublisher(composer.apply(this));\n+    public final <R> Flowable<R> compose(FlowableTransformer<? super T, ? extends R> composer) {\n+        return fromPublisher(((FlowableTransformer<T, R>) composer).apply(this));\n     }\n \n     /**\n\ndiff --git a/src/main/java/io/reactivex/Maybe.java b/src/main/java/io/reactivex/Maybe.java\n--- a/src/main/java/io/reactivex/Maybe.java\n+++ b/src/main/java/io/reactivex/Maybe.java\n@@ -2074,10 +2074,11 @@ public final <U> Maybe<U> cast(final Class<? extends U> clazz) {\n      * @return a Maybe, transformed by the transformer function\n      * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators</a>\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    public final <R> Maybe<R> compose(MaybeTransformer<T, R> transformer) {\n-        return wrap(transformer.apply(this));\n+    public final <R> Maybe<R> compose(MaybeTransformer<? super T, ? extends R> transformer) {\n+        return wrap(((MaybeTransformer<T, R>) transformer).apply(this));\n     }\n \n     /**\n\ndiff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java\n--- a/src/main/java/io/reactivex/Observable.java\n+++ b/src/main/java/io/reactivex/Observable.java\n@@ -5722,10 +5722,11 @@ public final <U> Single<U> collectInto(final U initialValue, BiConsumer<? super\n      * @return the source ObservableSource, transformed by the transformer function\n      * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators</a>\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    public final <R> Observable<R> compose(ObservableTransformer<T, R> composer) {\n-        return wrap(composer.apply(this));\n+    public final <R> Observable<R> compose(ObservableTransformer<? super T, ? extends R> composer) {\n+        return wrap(((ObservableTransformer<T, R>) composer).apply(this));\n     }\n \n     /**\n\ndiff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java\n--- a/src/main/java/io/reactivex/Single.java\n+++ b/src/main/java/io/reactivex/Single.java\n@@ -1540,10 +1540,11 @@ public final Single<T> hide() {\n      * @return the source Single, transformed by the transformer function\n      * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators</a>\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    public final <R> Single<R> compose(SingleTransformer<T, R> transformer) {\n-        return wrap(transformer.apply(this));\n+    public final <R> Single<R> compose(SingleTransformer<? super T, ? extends R> transformer) {\n+        return wrap(((SingleTransformer<T, R>) transformer).apply(this));\n     }\n \n     /**\n\ndiff --git a/src/test/java/io/reactivex/TransformerTest.java b/src/test/java/io/reactivex/TransformerTest.java\n--- a/src/test/java/io/reactivex/TransformerTest.java\n+++ b/src/test/java/io/reactivex/TransformerTest.java\n@@ -13,12 +13,11 @@\n \n package io.reactivex;\n \n-import static org.junit.Assert.*;\n-\n+import io.reactivex.exceptions.TestException;\n import org.junit.Test;\n import org.reactivestreams.Publisher;\n \n-import io.reactivex.exceptions.TestException;\n+import static org.junit.Assert.*;\n \n public class TransformerTest {\n \n@@ -83,7 +82,7 @@ public Maybe<Integer> apply(Maybe<Integer> v) {\n     }\n \n     @Test\n-    public void completabeTransformerThrows() {\n+    public void completableTransformerThrows() {\n         try {\n             Completable.complete().compose(new CompletableTransformer() {\n                 @Override\n@@ -96,4 +95,73 @@ public Completable apply(Completable v) {\n             assertEquals(\"Forced failure\", ex.getMessage());\n         }\n     }\n+\n+    // Test demos for signature generics in compose() methods. Just needs to compile.\n+\n+    @Test\n+    public void observableGenericsSignatureTest() {\n+        A<String, Integer> a = new A<String, Integer>() { };\n+\n+        Observable.just(a).compose(TransformerTest.<String>testObservableTransformerCreator());\n+    }\n+\n+    @Test\n+    public void singleGenericsSignatureTest() {\n+        A<String, Integer> a = new A<String, Integer>() { };\n+\n+        Single.just(a).compose(TransformerTest.<String>testSingleTransformerCreator());\n+    }\n+\n+    @Test\n+    public void maybeGenericsSignatureTest() {\n+        A<String, Integer> a = new A<String, Integer>() { };\n+\n+        Maybe.just(a).compose(TransformerTest.<String>testMaybeTransformerCreator());\n+    }\n+\n+    @Test\n+    public void flowableGenericsSignatureTest() {\n+        A<String, Integer> a = new A<String, Integer>() { };\n+\n+        Flowable.just(a).compose(TransformerTest.<String>testFlowableTransformerCreator());\n+    }\n+\n+    interface A<T, R> {}\n+    interface B<T> {}\n+\n+    private static <T> ObservableTransformer<A<T, ?>, B<T>> testObservableTransformerCreator() {\n+        return new ObservableTransformer<A<T, ?>, B<T>>() {\n+            @Override\n+            public ObservableSource<B<T>> apply(Observable<A<T, ?>> a) {\n+                return Observable.empty();\n+            }\n+        };\n+    }\n+\n+    private static <T> SingleTransformer<A<T, ?>, B<T>> testSingleTransformerCreator() {\n+        return new SingleTransformer<A<T, ?>, B<T>>() {\n+            @Override\n+            public SingleSource<B<T>> apply(Single<A<T, ?>> a) {\n+                return Single.never();\n+            }\n+        };\n+    }\n+\n+    private static <T> MaybeTransformer<A<T, ?>, B<T>> testMaybeTransformerCreator() {\n+        return new MaybeTransformer<A<T, ?>, B<T>>() {\n+            @Override\n+            public MaybeSource<B<T>> apply(Maybe<A<T, ?>> a) {\n+                return Maybe.empty();\n+            }\n+        };\n+    }\n+\n+    private static <T> FlowableTransformer<A<T, ?>, B<T>> testFlowableTransformerCreator() {\n+        return new FlowableTransformer<A<T, ?>, B<T>>() {\n+            @Override\n+            public Publisher<B<T>> apply(Flowable<A<T, ?>> a) {\n+                return Flowable.empty();\n+            }\n+        };\n+    }\n }",
    "output": "Improve compose() generics\n\nResolves #4950"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java b/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java\n--- a/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java\n+++ b/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java\n@@ -147,7 +147,7 @@ public void onSubscribe(Subscription s) {\n         @Override\n         public void onNext(Object t) {\n             if (SubscriptionHelper.cancel(this)) {\n-                onComplete();\n+                parent.otherError(new CancellationException());\n             }\n         }\n \n@@ -158,7 +158,10 @@ public void onError(Throwable t) {\n \n         @Override\n         public void onComplete() {\n-            parent.otherError(new CancellationException());\n+            if (get() != SubscriptionHelper.CANCELLED) {\n+                lazySet(SubscriptionHelper.CANCELLED);\n+                parent.otherError(new CancellationException());\n+            }\n         }\n \n         public void dispose() {\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisherTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisherTest.java\n--- a/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisherTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisherTest.java\n@@ -184,4 +184,18 @@ public void run() {\n             to.assertResult();\n         }\n     }\n+\n+    @Test\n+    public void otherSignalsAndCompletes() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            Maybe.just(1).takeUntil(Flowable.just(1).take(1))\n+            .test()\n+            .assertResult();\n+\n+            assertTrue(errors.toString(), errors.isEmpty());\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/single/SingleTakeUntilTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleTakeUntilTest.java\n--- a/src/test/java/io/reactivex/internal/operators/single/SingleTakeUntilTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/single/SingleTakeUntilTest.java\n@@ -16,6 +16,7 @@\n import java.util.List;\n import java.util.concurrent.CancellationException;\n \n+import static org.junit.Assert.*;\n import org.junit.Test;\n \n import io.reactivex.*;\n@@ -259,4 +260,18 @@ public void run() {\n             }\n         }\n     }\n+\n+    @Test\n+    public void otherSignalsAndCompletes() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            Single.just(1).takeUntil(Flowable.just(1).take(1))\n+            .test()\n+            .assertFailure(CancellationException.class);\n+\n+            assertTrue(errors.toString(), errors.isEmpty());\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n }",
    "output": "Fix takeUntil() other triggering twice"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/subjects/BehaviorSubject.java b/src/main/java/io/reactivex/subjects/BehaviorSubject.java\n--- a/src/main/java/io/reactivex/subjects/BehaviorSubject.java\n+++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java\n@@ -34,30 +34,30 @@\n  * <p>\n  * <pre> {@code\n \n-  // observer will receive all events.\n-  BehaviorSubject<Object> subject = BehaviorSubject.create(\"default\");\n+  // observer will receive all 4 events (including \"default\").\n+  BehaviorSubject<Object> subject = BehaviorSubject.createDefault(\"default\");\n   subject.subscribe(observer);\n   subject.onNext(\"one\");\n   subject.onNext(\"two\");\n   subject.onNext(\"three\");\n \n   // observer will receive the \"one\", \"two\" and \"three\" events, but not \"zero\"\n-  BehaviorSubject<Object> subject = BehaviorSubject.create(\"default\");\n+  BehaviorSubject<Object> subject = BehaviorSubject.create();\n   subject.onNext(\"zero\");\n   subject.onNext(\"one\");\n   subject.subscribe(observer);\n   subject.onNext(\"two\");\n   subject.onNext(\"three\");\n \n   // observer will receive only onComplete\n-  BehaviorSubject<Object> subject = BehaviorSubject.create(\"default\");\n+  BehaviorSubject<Object> subject = BehaviorSubject.create();\n   subject.onNext(\"zero\");\n   subject.onNext(\"one\");\n   subject.onComplete();\n   subject.subscribe(observer);\n \n   // observer will receive only onError\n-  BehaviorSubject<Object> subject = BehaviorSubject.create(\"default\");\n+  BehaviorSubject<Object> subject = BehaviorSubject.create();\n   subject.onNext(\"zero\");\n   subject.onNext(\"one\");\n   subject.onError(new RuntimeException(\"error\"));",
    "output": "Fix javadoc for BehaviorSubject -fix examples for creating BehaviorSubject with or without initial value"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java\n@@ -137,6 +137,8 @@ static final class MulticastProcessor<T> extends Flowable<T> implements Subscrib\n         final AtomicReference<MulticastSubscription<T>[]> subscribers;\n \n         final int prefetch;\n+        \n+        final int limit;\n \n         final boolean delayError;\n \n@@ -148,10 +150,13 @@ static final class MulticastProcessor<T> extends Flowable<T> implements Subscrib\n \n         volatile boolean done;\n         Throwable error;\n+        \n+        int consumed;\n \n         @SuppressWarnings(\"unchecked\")\n         MulticastProcessor(int prefetch, boolean delayError) {\n             this.prefetch = prefetch;\n+            this.limit = prefetch - (prefetch >> 2); // request after 75% consumption\n             this.delayError = delayError;\n             this.wip = new AtomicInteger();\n             this.s = new AtomicReference<Subscription>();\n@@ -314,7 +319,11 @@ void drain() {\n             int missed = 1;\n \n             SimpleQueue<T> q = queue;\n-\n+            \n+            int upstreamConsumed = consumed;\n+            int localLimit = limit;\n+            boolean canRequest = sourceMode != QueueSubscription.SYNC;\n+            \n             for (;;) {\n                 MulticastSubscription<T>[] array = subscribers.get();\n \n@@ -383,6 +392,11 @@ void drain() {\n                         }\n \n                         e++;\n+\n+                        if (canRequest && ++upstreamConsumed == localLimit) {\n+                            upstreamConsumed = 0;\n+                            s.get().request(localLimit);\n+                        }\n                     }\n \n                     if (e == r) {\n@@ -417,6 +431,7 @@ void drain() {\n                     }\n                 }\n \n+                consumed = upstreamConsumed;\n                 missed = wip.addAndGet(-missed);\n                 if (missed == 0) {\n                     break;\n@@ -472,8 +487,10 @@ public void request(long n) {\n \n         @Override\n         public void cancel() {\n-            getAndSet(Long.MIN_VALUE);\n-            parent.remove(this);\n+            if (getAndSet(Long.MIN_VALUE) != Long.MIN_VALUE) {\n+                parent.remove(this);\n+                parent.drain(); // unblock the others\n+            }\n         }\n \n         public boolean isCancelled() {\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishFunctionTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishFunctionTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishFunctionTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishFunctionTest.java\n@@ -26,7 +26,7 @@\n \n import io.reactivex.*;\n import io.reactivex.exceptions.*;\n-import io.reactivex.functions.Function;\n+import io.reactivex.functions.*;\n import io.reactivex.internal.functions.Functions;\n import io.reactivex.internal.subscriptions.BooleanSubscription;\n import io.reactivex.processors.PublishProcessor;\n@@ -408,7 +408,7 @@ public Publisher<Integer> apply(Flowable<Integer> f) throws Exception {\n \n         for (int i = 0; i < 500; i++) {\n             source.test()\n-            .awaitDone(5, TimeUnit.MILLISECONDS)\n+            .awaitDone(5, TimeUnit.SECONDS)\n             .assertResult(1);\n         }\n     }\n@@ -420,7 +420,7 @@ public void inputOutputSubscribeRace2() {\n \n         for (int i = 0; i < 500; i++) {\n             source.test()\n-            .awaitDone(5, TimeUnit.MILLISECONDS)\n+            .awaitDone(5, TimeUnit.SECONDS)\n             .assertResult(1);\n         }\n     }\n@@ -459,4 +459,86 @@ public void run() {\n             ts1.assertResult(1);\n         }\n     }\n+\n+    @Test\n+    public void longFlow() {\n+        Flowable.range(1, 1000000)\n+        .publish(new Function<Flowable<Integer>, Publisher<Integer>>() {\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public Publisher<Integer> apply(Flowable<Integer> v) throws Exception {\n+                return Flowable.mergeArray(\n+                        v.filter(new Predicate<Integer>() {\n+                            @Override\n+                            public boolean test(Integer w) throws Exception {\n+                                return w % 2 == 0;\n+                            }\n+                        }), \n+                        v.filter(new Predicate<Integer>() {\n+                            @Override\n+                            public boolean test(Integer w) throws Exception {\n+                                return w % 2 != 0;\n+                            }\n+                        }));\n+            }\n+        })\n+        .takeLast(1)\n+        .test()\n+        .assertResult(1000000);\n+    }\n+\n+    @Test\n+    public void longFlow2() {\n+        Flowable.range(1, 100000)\n+        .publish(new Function<Flowable<Integer>, Publisher<Integer>>() {\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public Publisher<Integer> apply(Flowable<Integer> v) throws Exception {\n+                return Flowable.mergeArray(\n+                        v.filter(new Predicate<Integer>() {\n+                            @Override\n+                            public boolean test(Integer w) throws Exception {\n+                                return w % 2 == 0;\n+                            }\n+                        }), \n+                        v.filter(new Predicate<Integer>() {\n+                            @Override\n+                            public boolean test(Integer w) throws Exception {\n+                                return w % 2 != 0;\n+                            }\n+                        }));\n+            }\n+        })\n+        .test()\n+        .assertValueCount(100000)\n+        .assertNoErrors()\n+        .assertComplete();\n+    }\n+\n+    @Test\n+    public void longFlowHidden() {\n+        Flowable.range(1, 1000000).hide()\n+        .publish(new Function<Flowable<Integer>, Publisher<Integer>>() {\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public Publisher<Integer> apply(Flowable<Integer> v) throws Exception {\n+                return Flowable.mergeArray(\n+                        v.filter(new Predicate<Integer>() {\n+                            @Override\n+                            public boolean test(Integer w) throws Exception {\n+                                return w % 2 == 0;\n+                            }\n+                        }), \n+                        v.filter(new Predicate<Integer>() {\n+                            @Override\n+                            public boolean test(Integer w) throws Exception {\n+                                return w % 2 != 0;\n+                            }\n+                        }));\n+            }\n+        })\n+        .takeLast(1)\n+        .test()\n+        .assertResult(1000000);\n+    }\n }",
    "output": "Fix publish(Function) not replenishing its queue"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java\n--- a/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java\n+++ b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java\n@@ -29,10 +29,21 @@ public enum DisposableHelper implements Disposable {\n     DISPOSED\n     ;\n \n+    /**\n+     * Checks if the given Disposable is the common {@link #DISPOSED} enum value.\n+     * @param d the disposable to check\n+     * @return true if d is {@link #DISPOSED}\n+     */\n     public static boolean isDisposed(Disposable d) {\n         return d == DISPOSED;\n     }\n \n+    /**\n+     * Atomically sets the field and disposes the old contents.\n+     * @param field the target field\n+     * @param d the new Disposable to set\n+     * @return true if successful, false if the field contains the {@link #DISPOSED} instance.\n+     */\n     public static boolean set(AtomicReference<Disposable> field, Disposable d) {\n         for (;;) {\n             Disposable current = field.get();\n@@ -144,6 +155,23 @@ public static void reportDisposableSet() {\n         RxJavaPlugins.onError(new IllegalStateException(\"Disposable already set!\"));\n     }\n \n+    /**\n+     * Atomically tries to set the given Disposable on the field if it is null or disposes it if\n+     * the field contains {@link #DISPOSED}.\n+     * @param field the target field\n+     * @param d the disposable to set\n+     * @return true if successful, false otherwise\n+     */\n+    public static boolean trySet(AtomicReference<Disposable> field, Disposable d) {\n+        if (!field.compareAndSet(null, d)) {\n+            if (field.get() == DISPOSED) {\n+                d.dispose();\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     @Override\n     public void dispose() {\n         // deliberately no-op\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimer.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimer.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimer.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimer.java\n@@ -36,15 +36,15 @@ public FlowableTimer(long delay, TimeUnit unit, Scheduler scheduler) {\n \n     @Override\n     public void subscribeActual(Subscriber<? super Long> s) {\n-        IntervalOnceSubscriber ios = new IntervalOnceSubscriber(s);\n+        TimerSubscriber ios = new TimerSubscriber(s);\n         s.onSubscribe(ios);\n \n         Disposable d = scheduler.scheduleDirect(ios, delay, unit);\n \n         ios.setResource(d);\n     }\n \n-    static final class IntervalOnceSubscriber extends AtomicReference<Disposable>\n+    static final class TimerSubscriber extends AtomicReference<Disposable>\n     implements Subscription, Runnable {\n \n         private static final long serialVersionUID = -2809475196591179431L;\n@@ -53,7 +53,7 @@ static final class IntervalOnceSubscriber extends AtomicReference<Disposable>\n \n         volatile boolean requested;\n \n-        IntervalOnceSubscriber(Subscriber<? super Long> actual) {\n+        TimerSubscriber(Subscriber<? super Long> actual) {\n             this.actual = actual;\n         }\n \n@@ -74,16 +74,17 @@ public void run() {\n             if (get() != DisposableHelper.DISPOSED) {\n                 if (requested) {\n                     actual.onNext(0L);\n+                    lazySet(EmptyDisposable.INSTANCE);\n                     actual.onComplete();\n                 } else {\n+                    lazySet(EmptyDisposable.INSTANCE);\n                     actual.onError(new MissingBackpressureException(\"Can't deliver value due to lack of requests\"));\n                 }\n-                lazySet(EmptyDisposable.INSTANCE);\n             }\n         }\n \n         public void setResource(Disposable d) {\n-            DisposableHelper.setOnce(this, d);\n+            DisposableHelper.trySet(this, d);\n         }\n     }\n }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableTimer.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimer.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableTimer.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimer.java\n@@ -32,22 +32,22 @@ public ObservableTimer(long delay, TimeUnit unit, Scheduler scheduler) {\n \n     @Override\n     public void subscribeActual(Observer<? super Long> s) {\n-        IntervalOnceObserver ios = new IntervalOnceObserver(s);\n+        TimerObserver ios = new TimerObserver(s);\n         s.onSubscribe(ios);\n \n         Disposable d = scheduler.scheduleDirect(ios, delay, unit);\n \n         ios.setResource(d);\n     }\n \n-    static final class IntervalOnceObserver extends AtomicReference<Disposable>\n+    static final class TimerObserver extends AtomicReference<Disposable>\n     implements Disposable, Runnable {\n \n         private static final long serialVersionUID = -2809475196591179431L;\n \n         final Observer<? super Long> actual;\n \n-        IntervalOnceObserver(Observer<? super Long> actual) {\n+        TimerObserver(Observer<? super Long> actual) {\n             this.actual = actual;\n         }\n \n@@ -65,13 +65,13 @@ public boolean isDisposed() {\n         public void run() {\n             if (!isDisposed()) {\n                 actual.onNext(0L);\n-                actual.onComplete();\n                 lazySet(EmptyDisposable.INSTANCE);\n+                actual.onComplete();\n             }\n         }\n \n         public void setResource(Disposable d) {\n-            DisposableHelper.setOnce(this, d);\n+            DisposableHelper.trySet(this, d);\n         }\n     }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimerTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimerTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimerTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimerTest.java\n@@ -13,9 +13,11 @@\n \n package io.reactivex.internal.operators.flowable;\n \n+import static org.junit.Assert.*;\n import static org.mockito.ArgumentMatchers.*;\n import static org.mockito.Mockito.*;\n \n+import java.util.List;\n import java.util.concurrent.TimeUnit;\n \n import org.junit.*;\n@@ -25,6 +27,7 @@\n import io.reactivex.*;\n import io.reactivex.exceptions.*;\n import io.reactivex.flowables.ConnectableFlowable;\n+import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.schedulers.TestScheduler;\n import io.reactivex.subscribers.*;\n \n@@ -324,4 +327,18 @@ public void run() {\n             TestHelper.race(r1, r2);\n         }\n     }\n+\n+    @Test\n+    public void timerDelayZero() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            for (int i = 0; i < 1000; i++) {\n+                Flowable.timer(0, TimeUnit.MILLISECONDS).blockingFirst();\n+            }\n+\n+            assertTrue(errors.toString(), errors.isEmpty());\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n }\n\\ No newline at end of file\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableTimerTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableTimerTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableTimerTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableTimerTest.java\n@@ -13,8 +13,10 @@\n \n package io.reactivex.internal.operators.observable;\n \n+import static org.junit.Assert.assertTrue;\n import static org.mockito.Mockito.*;\n \n+import java.util.List;\n import java.util.concurrent.TimeUnit;\n \n import org.junit.*;\n@@ -24,6 +26,7 @@\n import io.reactivex.exceptions.TestException;\n import io.reactivex.observables.ConnectableObservable;\n import io.reactivex.observers.*;\n+import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.schedulers.TestScheduler;\n \n public class ObservableTimerTest {\n@@ -286,4 +289,18 @@ public void onComplete() {\n     public void disposed() {\n         TestHelper.checkDisposed(Observable.timer(1, TimeUnit.DAYS));\n     }\n+\n+    @Test\n+    public void timerDelayZero() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            for (int i = 0; i < 1000; i++) {\n+                Observable.timer(0, TimeUnit.MILLISECONDS).blockingFirst();\n+            }\n+\n+            assertTrue(errors.toString(), errors.isEmpty());\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n }\n\\ No newline at end of file",
    "output": "Fix timer() ISE due to bad resource mgmt"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Maybe.java b/src/main/java/io/reactivex/Maybe.java\n--- a/src/main/java/io/reactivex/Maybe.java\n+++ b/src/main/java/io/reactivex/Maybe.java\n@@ -2842,7 +2842,7 @@ public final <R> Maybe<R> flatMapSingleElement(final Function<? super T, ? exten\n      */\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    public final Completable flatMapCompletable(final Function<? super T, ? extends Completable> mapper) {\n+    public final Completable flatMapCompletable(final Function<? super T, ? extends CompletableSource> mapper) {\n         ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n         return RxJavaPlugins.onAssembly(new MaybeFlatMapCompletable<T>(this, mapper));\n     }\n\ndiff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java\n--- a/src/main/java/io/reactivex/Single.java\n+++ b/src/main/java/io/reactivex/Single.java\n@@ -2097,7 +2097,7 @@ public final <R> Observable<R> flatMapObservable(Function<? super T, ? extends O\n      */\n     @CheckReturnValue\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    public final Completable flatMapCompletable(final Function<? super T, ? extends Completable> mapper) {\n+    public final Completable flatMapCompletable(final Function<? super T, ? extends CompletableSource> mapper) {\n         ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n         return RxJavaPlugins.onAssembly(new SingleFlatMapCompletable<T>(this, mapper));\n     }",
    "output": "Change Completable to CompletableSource"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/observers/TestObserver.java b/src/main/java/io/reactivex/observers/TestObserver.java\n--- a/src/main/java/io/reactivex/observers/TestObserver.java\n+++ b/src/main/java/io/reactivex/observers/TestObserver.java\n@@ -149,7 +149,7 @@ public void onNext(T t) {\n         values.add(t);\n \n         if (t == null) {\n-            errors.add(new NullPointerException(\"onNext received a null Subscription\"));\n+            errors.add(new NullPointerException(\"onNext received a null value\"));\n         }\n \n         actual.onNext(t);\n\ndiff --git a/src/main/java/io/reactivex/subscribers/TestSubscriber.java b/src/main/java/io/reactivex/subscribers/TestSubscriber.java\n--- a/src/main/java/io/reactivex/subscribers/TestSubscriber.java\n+++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java\n@@ -207,7 +207,7 @@ public void onNext(T t) {\n         values.add(t);\n \n         if (t == null) {\n-            errors.add(new NullPointerException(\"onNext received a null Subscription\"));\n+            errors.add(new NullPointerException(\"onNext received a null value\"));\n         }\n \n         actual.onNext(t);\n@@ -226,7 +226,7 @@ public void onError(Throwable t) {\n             errors.add(t);\n \n             if (t == null) {\n-                errors.add(new IllegalStateException(\"onError received a null Subscription\"));\n+                errors.add(new IllegalStateException(\"onError received a null Throwable\"));\n             }\n \n             actual.onError(t);",
    "output": "Fix TestSubscriber/Observer message texts"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/MaybeObserver.java b/src/main/java/io/reactivex/MaybeObserver.java\n--- a/src/main/java/io/reactivex/MaybeObserver.java\n+++ b/src/main/java/io/reactivex/MaybeObserver.java\n@@ -45,10 +45,10 @@ public interface MaybeObserver<T> {\n      * <p>\n      * The {@link Maybe} will not call this method if it calls {@link #onError}.\n      *\n-     * @param value\n+     * @param t\n      *          the item emitted by the Maybe\n      */\n-    void onSuccess(T value);\n+    void onSuccess(T t);\n \n     /**\n      * Notifies the MaybeObserver that the {@link Maybe} has experienced an error condition.\n\ndiff --git a/src/main/java/io/reactivex/Observer.java b/src/main/java/io/reactivex/Observer.java\n--- a/src/main/java/io/reactivex/Observer.java\n+++ b/src/main/java/io/reactivex/Observer.java\n@@ -50,10 +50,10 @@ public interface Observer<T> {\n      * The {@code Observable} will not call this method again after it calls either {@link #onComplete} or\n      * {@link #onError}.\n      *\n-     * @param value\n+     * @param t\n      *          the item emitted by the Observable\n      */\n-    void onNext(T value);\n+    void onNext(T t);\n \n     /**\n      * Notifies the Observer that the {@link Observable} has experienced an error condition.\n\ndiff --git a/src/main/java/io/reactivex/SingleObserver.java b/src/main/java/io/reactivex/SingleObserver.java\n--- a/src/main/java/io/reactivex/SingleObserver.java\n+++ b/src/main/java/io/reactivex/SingleObserver.java\n@@ -47,10 +47,10 @@ public interface SingleObserver<T> {\n      * <p>\n      * The {@link Single} will not call this method if it calls {@link #onError}.\n      *\n-     * @param value\n+     * @param t\n      *          the item emitted by the Single\n      */\n-    void onSuccess(T value);\n+    void onSuccess(T t);\n \n     /**\n      * Notifies the SingleObserver that the {@link Single} has experienced an error condition.",
    "output": "Use t instead of value to allow for IDE naming"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java\n--- a/src/main/java/io/reactivex/Flowable.java\n+++ b/src/main/java/io/reactivex/Flowable.java\n@@ -1886,12 +1886,13 @@ public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeou\n      * @return a Flowable that emits the item from the source {@link Future}\n      * @see <a href=\"http://reactivex.io/documentation/operators/from.html\">ReactiveX operators documentation: From</a>\n      */\n+    @SuppressWarnings({ \"unchecked\", \"cast\" })\n     @CheckReturnValue\n     @BackpressureSupport(BackpressureKind.FULL)\n     @SchedulerSupport(SchedulerSupport.CUSTOM)\n     public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit, Scheduler scheduler) {\n         ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n-        return fromFuture(future, timeout, unit).subscribeOn(scheduler);\n+        return fromFuture((Future<T>)future, timeout, unit).subscribeOn(scheduler);\n     }\n \n     /**\n@@ -1923,12 +1924,13 @@ public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeou\n      * @return a Flowable that emits the item from the source {@link Future}\n      * @see <a href=\"http://reactivex.io/documentation/operators/from.html\">ReactiveX operators documentation: From</a>\n      */\n+    @SuppressWarnings({ \"cast\", \"unchecked\" })\n     @CheckReturnValue\n     @BackpressureSupport(BackpressureKind.FULL)\n     @SchedulerSupport(SchedulerSupport.CUSTOM)\n     public static <T> Flowable<T> fromFuture(Future<? extends T> future, Scheduler scheduler) {\n         ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n-        return fromFuture(future).subscribeOn(scheduler);\n+        return fromFuture((Future<T>)future).subscribeOn(scheduler);\n     }\n \n     /**\n@@ -4145,13 +4147,14 @@ public static <T, R> Flowable<R> zip(Iterable<? extends Publisher<? extends T>>\n      * @return a Flowable that emits the zipped results\n      * @see <a href=\"http://reactivex.io/documentation/operators/zip.html\">ReactiveX operators documentation: Zip</a>\n      */\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\", \"cast\" })\n     @CheckReturnValue\n     @BackpressureSupport(BackpressureKind.FULL)\n     @SchedulerSupport(SchedulerSupport.NONE)\n     public static <T, R> Flowable<R> zip(Publisher<? extends Publisher<? extends T>> sources,\n             final Function<? super Object[], ? extends R> zipper) {\n         ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n-        return fromPublisher(sources).toList().flatMapPublisher(FlowableInternalHelper.<T, R>zipIterable(zipper));\n+        return fromPublisher(sources).toList().flatMapPublisher((Function)FlowableInternalHelper.<T, R>zipIterable(zipper));\n     }\n \n     /**\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java\n@@ -1638,10 +1638,10 @@ public void accept(GroupedFlowable<Integer, Integer> g) {\n     @Test\n     public void keySelectorAndDelayError() {\n         Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))\n-        .groupBy(Functions.identity(), true)\n-        .flatMap(new Function<GroupedFlowable<Object, Integer>, Flowable<Integer>>() {\n+        .groupBy(Functions.<Integer>identity(), true)\n+        .flatMap(new Function<GroupedFlowable<Integer, Integer>, Flowable<Integer>>() {\n             @Override\n-            public Flowable<Integer> apply(GroupedFlowable<Object, Integer> g) throws Exception {\n+            public Flowable<Integer> apply(GroupedFlowable<Integer, Integer> g) throws Exception {\n                 return g;\n             }\n         })\n@@ -1652,10 +1652,10 @@ public Flowable<Integer> apply(GroupedFlowable<Object, Integer> g) throws Except\n     @Test\n     public void keyAndValueSelectorAndDelayError() {\n         Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))\n-        .groupBy(Functions.identity(), Functions.<Integer>identity(), true)\n-        .flatMap(new Function<GroupedFlowable<Object, Integer>, Flowable<Integer>>() {\n+        .groupBy(Functions.<Integer>identity(), Functions.<Integer>identity(), true)\n+        .flatMap(new Function<GroupedFlowable<Integer, Integer>, Flowable<Integer>>() {\n             @Override\n-            public Flowable<Integer> apply(GroupedFlowable<Object, Integer> g) throws Exception {\n+            public Flowable<Integer> apply(GroupedFlowable<Integer, Integer> g) throws Exception {\n                 return g;\n             }\n         })\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java\n@@ -1448,10 +1448,10 @@ public Integer apply(Integer i) {\n     @Test\n     public void keySelectorAndDelayError() {\n         Observable.just(1).concatWith(Observable.<Integer>error(new TestException()))\n-        .groupBy(Functions.identity(), true)\n-        .flatMap(new Function<GroupedObservable<Object, Integer>, ObservableSource<Integer>>() {\n+        .groupBy(Functions.<Integer>identity(), true)\n+        .flatMap(new Function<GroupedObservable<Integer, Integer>, ObservableSource<Integer>>() {\n             @Override\n-            public ObservableSource<Integer> apply(GroupedObservable<Object, Integer> g) throws Exception {\n+            public ObservableSource<Integer> apply(GroupedObservable<Integer, Integer> g) throws Exception {\n                 return g;\n             }\n         })\n@@ -1462,10 +1462,10 @@ public ObservableSource<Integer> apply(GroupedObservable<Object, Integer> g) thr\n     @Test\n     public void keyAndValueSelectorAndDelayError() {\n         Observable.just(1).concatWith(Observable.<Integer>error(new TestException()))\n-        .groupBy(Functions.identity(), Functions.<Integer>identity(), true)\n-        .flatMap(new Function<GroupedObservable<Object, Integer>, ObservableSource<Integer>>() {\n+        .groupBy(Functions.<Integer>identity(), Functions.<Integer>identity(), true)\n+        .flatMap(new Function<GroupedObservable<Integer, Integer>, ObservableSource<Integer>>() {\n             @Override\n-            public ObservableSource<Integer> apply(GroupedObservable<Object, Integer> g) throws Exception {\n+            public ObservableSource<Integer> apply(GroupedObservable<Integer, Integer> g) throws Exception {\n                 return g;\n             }\n         })",
    "output": "Fix compilation errors when using Java 8 * Fix Java 8 compilation problems * Suppress warnings for java 6"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceSeedSingle.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceSeedSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceSeedSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceSeedSingle.java\n@@ -59,7 +59,7 @@ static final class ReduceSeedObserver<T, R> implements Subscriber<T>, Disposable\n \n         Subscription s;\n \n-        public ReduceSeedObserver(SingleObserver<? super R> actual, BiFunction<R, ? super T, R> reducer, R value) {\n+        ReduceSeedObserver(SingleObserver<? super R> actual, BiFunction<R, ? super T, R> reducer, R value) {\n             this.actual = actual;\n             this.value = value;\n             this.reducer = reducer;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableReduceMaybe.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableReduceMaybe.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableReduceMaybe.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReduceMaybe.java\n@@ -55,7 +55,7 @@ static final class ReduceObserver<T> implements Observer<T>, Disposable {\n \n         Disposable d;\n \n-        public ReduceObserver(MaybeObserver<? super T> observer, BiFunction<T, T, T> reducer) {\n+        ReduceObserver(MaybeObserver<? super T> observer, BiFunction<T, T, T> reducer) {\n             this.actual = observer;\n             this.reducer = reducer;\n         }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableReduceSeedSingle.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableReduceSeedSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableReduceSeedSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReduceSeedSingle.java\n@@ -57,7 +57,7 @@ static final class ReduceSeedObserver<T, R> implements Observer<T>, Disposable {\n \n         Disposable d;\n \n-        public ReduceSeedObserver(SingleObserver<? super R> actual, BiFunction<R, ? super T, R> reducer, R value) {\n+        ReduceSeedObserver(SingleObserver<? super R> actual, BiFunction<R, ? super T, R> reducer, R value) {\n             this.actual = actual;\n             this.value = value;\n             this.reducer = reducer;",
    "output": "Fix code style"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/internal/util/OpenHashSetTest.java b/src/test/java/io/reactivex/internal/util/OpenHashSetTest.java\n--- a/src/test/java/io/reactivex/internal/util/OpenHashSetTest.java\n+++ b/src/test/java/io/reactivex/internal/util/OpenHashSetTest.java\n@@ -25,6 +25,10 @@ public int hashCode() {\n             return 1;\n         }\n \n+        @Override\n+        public boolean equals(Object o) {\n+            return this == o;\n+        }\n     }\n \n     @Test",
    "output": "Add equals() to the unit test to satisfy checkstyle"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/package-info.java b/src/main/java/io/reactivex/package-info.java\n--- a/src/main/java/io/reactivex/package-info.java\n+++ b/src/main/java/io/reactivex/package-info.java\n@@ -38,7 +38,6 @@\n  * <li>Observable == Observable (factory methods)</li>\n  * <li>Flowable == IAsyncEnumerable (backpressure)</li>\n  * <li>Subscriber == IAsyncEnumerator</li>\n- * <li>\n  * </ul>\n  * The Single and Completable reactive base types have no equivalent in Rx.NET as of 3.x.\n  * </p>",
    "output": "Remove empty list item from `io.reactivex.package-info.java`"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/subscribers/TestSubscriber.java b/src/main/java/io/reactivex/subscribers/TestSubscriber.java\n--- a/src/main/java/io/reactivex/subscribers/TestSubscriber.java\n+++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java\n@@ -16,11 +16,12 @@\n \n import org.reactivestreams.*;\n \n+import io.reactivex.annotations.Experimental;\n import io.reactivex.disposables.Disposable;\n import io.reactivex.functions.Consumer;\n import io.reactivex.internal.fuseable.QueueSubscription;\n import io.reactivex.internal.subscriptions.SubscriptionHelper;\n-import io.reactivex.internal.util.*;\n+import io.reactivex.internal.util.ExceptionHelper;\n import io.reactivex.observers.BaseTestConsumer;\n \n /**\n@@ -403,6 +404,18 @@ public final TestSubscriber<T> assertOf(Consumer<? super TestSubscriber<T>> chec\n         return this;\n     }\n \n+    /**\n+     * Calls {@link #request(long)} and returns this.\n+     * @param n the request amount\n+     * @return this\n+     * @since 2.0.1 - experimental\n+     */\n+    @Experimental\n+    public final TestSubscriber<T> requestMore(long n) {\n+        request(n);\n+        return this;\n+    }\n+\n     /**\n      * A subscriber that ignores all events and does not report errors.\n      */\n\ndiff --git a/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java b/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n--- a/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n+++ b/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n@@ -1707,4 +1707,16 @@ public void assertValueAtInvalidIndex() {\n             }\n         });\n     }\n+\n+    @Test\n+    public void requestMore() {\n+        Flowable.range(1, 5)\n+        .test(0)\n+        .requestMore(1)\n+        .assertValue(1)\n+        .requestMore(2)\n+        .assertValues(1, 2, 3)\n+        .requestMore(3)\n+        .assertResult(1, 2, 3, 4, 5);\n+    }\n }",
    "output": "Add fluent requestMore to TestSubscriber"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/ObservableEmitter.java b/src/main/java/io/reactivex/ObservableEmitter.java\n--- a/src/main/java/io/reactivex/ObservableEmitter.java\n+++ b/src/main/java/io/reactivex/ObservableEmitter.java\n@@ -51,7 +51,7 @@ public interface ObservableEmitter<T> extends Emitter<T> {\n \n     /**\n      * Ensures that calls to onNext, onError and onComplete are properly serialized.\n-     * @return the serialized FlowableEmitter\n+     * @return the serialized ObservableEmitter\n      */\n     ObservableEmitter<T> serialize();\n-}\n\\ No newline at end of file\n+}",
    "output": "Upgrade ObservableEmitter.java"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java\n--- a/src/main/java/io/reactivex/Single.java\n+++ b/src/main/java/io/reactivex/Single.java\n@@ -27,7 +27,7 @@\n import io.reactivex.internal.operators.completable.*;\n import io.reactivex.internal.operators.flowable.*;\n import io.reactivex.internal.operators.maybe.*;\n-import io.reactivex.internal.operators.observable.ObservableConcatMap;\n+import io.reactivex.internal.operators.observable.*;\n import io.reactivex.internal.operators.single.*;\n import io.reactivex.internal.util.*;\n import io.reactivex.observers.TestObserver;\n@@ -573,6 +573,27 @@ public static <T> Single<T> fromPublisher(final Publisher<? extends T> publisher\n         return RxJavaPlugins.onAssembly(new SingleFromPublisher<T>(publisher));\n     }\n \n+    /**\n+     * Wraps a specific ObservableSource into a Single and signals its single element or error.\n+     * <p>If the ObservableSource is empty, a NoSuchElementException is signalled.\n+     * If the source has more than one element, an IndexOutOfBoundsException is signalled.\n+     * <p>\n+     * <dl>\n+     *   <dt><b>Scheduler:</b></dt>\n+     *   <dd>{@code fromObservable} does not operate by default on a particular {@link Scheduler}.</dd>\n+     * </dl>\n+     *\n+     * @param observableSource the source Observable, not null\n+     * @param <T>\n+     *         the type of the item emitted by the {@link Single}.\n+     * @return the new Single instance\n+     */\n+    @SchedulerSupport(SchedulerSupport.NONE)\n+    public static <T> Single<T> fromObservable(ObservableSource<? extends T> observableSource) {\n+        ObjectHelper.requireNonNull(observableSource, \"observableSource is null\");\n+        return RxJavaPlugins.onAssembly(new ObservableSingleSingle<T>(observableSource, null));\n+    }\n+\n     /**\n      * Returns a {@code Single} that emits a specified item.\n      * <p>\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableSingleSingle.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableSingleSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableSingleSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSingleSingle.java\n@@ -21,11 +21,11 @@\n \n public final class ObservableSingleSingle<T> extends Single<T> {\n \n-    final ObservableSource<T> source;\n+    final ObservableSource<? extends T> source;\n \n     final T defaultValue;\n \n-    public ObservableSingleSingle(ObservableSource<T> source, T defaultValue) {\n+    public ObservableSingleSingle(ObservableSource<? extends T> source, T defaultValue) {\n         this.source = source;\n         this.defaultValue = defaultValue;\n     }\n\ndiff --git a/src/test/java/io/reactivex/single/SingleTest.java b/src/test/java/io/reactivex/single/SingleTest.java\n--- a/src/test/java/io/reactivex/single/SingleTest.java\n+++ b/src/test/java/io/reactivex/single/SingleTest.java\n@@ -22,6 +22,7 @@\n import org.junit.*;\n \n import io.reactivex.*;\n+import io.reactivex.Observable;\n import io.reactivex.disposables.*;\n import io.reactivex.exceptions.TestException;\n import io.reactivex.functions.*;\n@@ -541,5 +542,40 @@ public Integer apply(Single<Integer> v) throws Exception {\n             }\n         }).intValue());\n     }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void fromObservableNull() {\n+        Single.fromObservable(null);\n+    }\n+\n+    @Test\n+    public void fromObservableEmpty() {\n+        Single.fromObservable(Observable.empty())\n+            .test()\n+            .assertFailure(NoSuchElementException.class);\n+    }\n+\n+    @Test\n+    public void fromObservableMoreThan1Elements() {\n+        Single.fromObservable(Observable.just(1, 2))\n+            .test()\n+            .assertFailure(IllegalArgumentException.class)\n+            .assertErrorMessage(\"Sequence contains more than one element!\");\n+    }\n+\n+    @Test\n+    public void fromObservableOneElement() {\n+        Single.fromObservable(Observable.just(1))\n+            .test()\n+            .assertResult(1);\n+    }\n+\n+    @Test\n+    public void fromObservableError() {\n+        Single.fromObservable(Observable.error(new RuntimeException(\"some error\")))\n+            .test()\n+            .assertFailure(RuntimeException.class)\n+            .assertErrorMessage(\"some error\");\n+    }\n }\n ",
    "output": "Add Single.fromObservable(ObservableSource)\n\n* Add Single.fromObservable(ObservableSource)\r\n\r\n* Add Null test"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java\n@@ -18,11 +18,10 @@\n \n import org.reactivestreams.*;\n \n-import io.reactivex.disposables.Disposable;\n import io.reactivex.exceptions.Exceptions;\n import io.reactivex.functions.Function;\n import io.reactivex.internal.functions.ObjectHelper;\n-import io.reactivex.internal.fuseable.*;\n+import io.reactivex.internal.fuseable.QueueFuseable;\n import io.reactivex.internal.subscribers.BasicFuseableSubscriber;\n import io.reactivex.internal.subscriptions.EmptySubscription;\n import io.reactivex.plugins.RxJavaPlugins;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java\n@@ -17,12 +17,10 @@\n import java.util.concurrent.Callable;\n \n import io.reactivex.*;\n-import io.reactivex.disposables.Disposable;\n import io.reactivex.exceptions.Exceptions;\n import io.reactivex.functions.Function;\n import io.reactivex.internal.disposables.EmptyDisposable;\n import io.reactivex.internal.functions.ObjectHelper;\n-import io.reactivex.internal.fuseable.SimpleQueue;\n import io.reactivex.internal.observers.BasicFuseableObserver;\n import io.reactivex.plugins.RxJavaPlugins;\n \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java\n@@ -14,7 +14,6 @@\n package io.reactivex.internal.operators.observable;\n \n import io.reactivex.*;\n-import io.reactivex.disposables.Disposable;\n import io.reactivex.functions.Predicate;\n import io.reactivex.internal.observers.BasicFuseableObserver;\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java\n@@ -17,7 +17,7 @@\n \n import java.util.*;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.*;\n \n import org.junit.*;\n import org.reactivestreams.*;\n@@ -528,8 +528,15 @@ public void exactBoundaryError() {\n     }\n \n     @Test\n-    public void restartTimerMany() {\n+    public void restartTimerMany() throws Exception {\n+        final AtomicBoolean cancel1 = new AtomicBoolean();\n         Flowable.intervalRange(1, 1000, 1, 1, TimeUnit.MILLISECONDS)\n+        .doOnCancel(new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                cancel1.set(true);\n+            }\n+        })\n         .window(1, TimeUnit.MILLISECONDS, Schedulers.single(), 2, true)\n         .flatMap(Functions.<Flowable<Long>>identity())\n         .take(500)\n@@ -539,6 +546,13 @@ public void restartTimerMany() {\n         .assertValueCount(500)\n         .assertNoErrors()\n         .assertComplete();\n+\n+        int timeout = 20;\n+        while (timeout-- > 0 && !cancel1.get()) {\n+            Thread.sleep(100);\n+        }\n+\n+        assertTrue(\"intervalRange was not cancelled!\", cancel1.get());\n     }\n \n     @Test",
    "output": "Fix window-timed test leaking an MBE that affects unrelated tests"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java\n@@ -45,8 +45,6 @@ public final class BlockingFlowableIterator<T>\n     volatile boolean done;\n     Throwable error;\n \n-    volatile boolean cancelled;\n-\n     public BlockingFlowableIterator(int batchSize) {\n         this.queue = new SpscLinkedArrayQueue<T>(batchSize);\n         this.batchSize = batchSize;\n@@ -58,9 +56,6 @@ public BlockingFlowableIterator(int batchSize) {\n     @Override\n     public boolean hasNext() {\n         for (;;) {\n-            if (cancelled) {\n-                return false;\n-            }\n             boolean d = done;\n             boolean empty = queue.isEmpty();\n             if (d) {\n@@ -75,7 +70,7 @@ public boolean hasNext() {\n             if (empty) {\n                 lock.lock();\n                 try {\n-                    while (!cancelled && !done && queue.isEmpty()) {\n+                    while (!done && queue.isEmpty()) {\n                         condition.await();\n                     }\n                 } catch (InterruptedException ex) {\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java\n@@ -60,10 +60,6 @@ static final class DistinctSubscriber<T, K> extends BasicFuseableSubscriber<T, T\n \n         final Function<? super T, K> keySelector;\n \n-        Disposable d;\n-\n-        SimpleQueue<T> queue;\n-\n         DistinctSubscriber(Subscriber<? super T> actual, Function<? super T, K> keySelector, Collection<? super K> collection) {\n             super(actual);\n             this.keySelector = keySelector;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java\n@@ -59,10 +59,6 @@ static final class DistinctObserver<T, K> extends BasicFuseableObserver<T, T> {\n \n         final Function<? super T, K> keySelector;\n \n-        Disposable d;\n-\n-        SimpleQueue<T> queue;\n-\n         DistinctObserver(Observer<? super T> actual, Function<? super T, K> keySelector, Collection<? super K> collection) {\n             super(actual);\n             this.keySelector = keySelector;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java\n@@ -33,8 +33,6 @@ public void subscribeActual(Observer<? super T> s) {\n     static final class FilterObserver<T> extends BasicFuseableObserver<T, T> {\n         final Predicate<? super T> filter;\n \n-        Disposable s;\n-\n         FilterObserver(Observer<? super T> actual, Predicate<? super T> filter) {\n             super(actual);\n             this.filter = filter;",
    "output": "Remove some unused fields"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java\n@@ -233,12 +233,11 @@ public void drain() {\n             int missed = 1;\n             InnerQueuedSubscriber<R> inner = current;\n             Subscriber<? super R> a = actual;\n-            long r = requested.get();\n-            long e = 0L;\n             ErrorMode em = errorMode;\n \n-            outer:\n             for (;;) {\n+                long r = requested.get();\n+                long e = 0L;\n \n                 if (inner == null) {\n \n@@ -271,6 +270,8 @@ public void drain() {\n                     }\n                 }\n \n+                boolean continueNextSource = false;\n+\n                 if (inner != null) {\n                     SimpleQueue<R> q = inner.queue();\n                     if (q != null) {\n@@ -313,7 +314,8 @@ public void drain() {\n                                 inner = null;\n                                 current = null;\n                                 s.request(1);\n-                                continue outer;\n+                                continueNextSource = true;\n+                                break;\n                             }\n \n                             if (empty) {\n@@ -353,15 +355,18 @@ public void drain() {\n                                 inner = null;\n                                 current = null;\n                                 s.request(1);\n-                                continue;\n+                                continueNextSource = true;\n                             }\n                         }\n                     }\n                 }\n \n                 if (e != 0L && r != Long.MAX_VALUE) {\n-                    r = requested.addAndGet(-e);\n-                    e = 0L;\n+                    requested.addAndGet(-e);\n+                }\n+\n+                if (continueNextSource) {\n+                    continue;\n                 }\n \n                 missed = addAndGet(-missed);\n\ndiff --git a/src/main/java/io/reactivex/internal/subscribers/InnerQueuedSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/InnerQueuedSubscriber.java\n--- a/src/main/java/io/reactivex/internal/subscribers/InnerQueuedSubscriber.java\n+++ b/src/main/java/io/reactivex/internal/subscribers/InnerQueuedSubscriber.java\n@@ -72,14 +72,14 @@ public void onSubscribe(Subscription s) {\n                 if (m == QueueSubscription.ASYNC) {\n                     fusionMode = m;\n                     queue = qs;\n-                    QueueDrainHelper.request(get(), prefetch);\n+                    QueueDrainHelper.request(s, prefetch);\n                     return;\n                 }\n             }\n \n             queue = QueueDrainHelper.createQueue(prefetch);\n \n-            QueueDrainHelper.request(get(), prefetch);\n+            QueueDrainHelper.request(s, prefetch);\n         }\n     }\n \n@@ -104,22 +104,26 @@ public void onComplete() {\n \n     @Override\n     public void request(long n) {\n-        long p = produced + n;\n-        if (p >= limit) {\n-            produced = 0L;\n-            get().request(p);\n-        } else {\n-            produced = p;\n+        if (fusionMode != QueueSubscription.SYNC) {\n+            long p = produced + n;\n+            if (p >= limit) {\n+                produced = 0L;\n+                get().request(p);\n+            } else {\n+                produced = p;\n+            }\n         }\n     }\n \n     public void requestOne() {\n-        long p = produced + 1;\n-        if (p == limit) {\n-            produced = 0L;\n-            get().request(p);\n-        } else {\n-            produced = p;\n+        if (fusionMode != QueueSubscription.SYNC) {\n+            long p = produced + 1;\n+            if (p == limit) {\n+                produced = 0L;\n+                get().request(p);\n+            } else {\n+                produced = p;\n+            }\n         }\n     }\n \n\ndiff --git a/src/test/java/io/reactivex/TestHelper.java b/src/test/java/io/reactivex/TestHelper.java\n--- a/src/test/java/io/reactivex/TestHelper.java\n+++ b/src/test/java/io/reactivex/TestHelper.java\n@@ -30,6 +30,7 @@\n import io.reactivex.disposables.*;\n import io.reactivex.exceptions.*;\n import io.reactivex.functions.*;\n+import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.fuseable.*;\n import io.reactivex.internal.operators.maybe.MaybeToFlowable;\n import io.reactivex.internal.operators.single.SingleToFlowable;\n@@ -144,21 +145,25 @@ public void accept(Throwable t) {\n     }\n \n     public static void assertError(List<Throwable> list, int index, Class<? extends Throwable> clazz) {\n-        try {\n-            assertTrue(list.get(index).toString(), clazz.isInstance(list.get(index)));\n-        } catch (AssertionError e) {\n-            list.get(index).printStackTrace();\n-            throw e;\n+        Throwable ex = list.get(index);\n+        if (!clazz.isInstance(ex)) {\n+            AssertionError err = new AssertionError(clazz + \" expected but got \" + list.get(index));\n+            err.initCause(list.get(index));\n+            throw err;\n         }\n     }\n \n     public static void assertError(List<Throwable> list, int index, Class<? extends Throwable> clazz, String message) {\n-        try {\n-            assertTrue(list.get(index).toString(), clazz.isInstance(list.get(index)));\n-            assertEquals(message, list.get(index).getMessage());\n-        } catch (AssertionError e) {\n-            list.get(index).printStackTrace();\n-            throw e;\n+        Throwable ex = list.get(index);\n+        if (!clazz.isInstance(ex)) {\n+            AssertionError err = new AssertionError(\"Type \" + clazz + \" expected but got \" + ex);\n+            err.initCause(ex);\n+            throw err;\n+        }\n+        if (!ObjectHelper.equals(message, ex.getMessage())) {\n+            AssertionError err = new AssertionError(\"Message \" + message + \" expected but got \" + ex.getMessage());\n+            err.initCause(ex);\n+            throw err;\n         }\n     }\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java\n@@ -577,11 +577,12 @@ public void testAsynchronousRun() {\n             public Flowable<Integer> apply(Integer t) {\n                 return Flowable.range(1, 1000).subscribeOn(Schedulers.computation());\n             }\n-        }).observeOn(Schedulers.newThread()).subscribe(ts);\n-\n-        ts.awaitTerminalEvent(5, TimeUnit.SECONDS);\n-        ts.assertNoErrors();\n-        ts.assertValueCount(2000);\n+        }).observeOn(Schedulers.single())\n+        .test()\n+        .awaitDone(5, TimeUnit.SECONDS)\n+        .assertNoErrors()\n+        .assertValueCount(2000)\n+        .assertComplete();\n     }\n \n     @Test",
    "output": "Fix Flowable.concatMapEager hang due to bad request management * fix Flowable.concatMapEager hang due to bad request management * Missed negation of check"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureError.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureError.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureError.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureError.java\n@@ -38,6 +38,7 @@ protected void subscribeActual(Subscriber<? super T> s) {\n \n     static final class BackpressureErrorSubscriber<T>\n             extends AtomicLong implements Subscriber<T>, Subscription {\n+        private static final long serialVersionUID = -3176480756392482682L;\n \n         final Subscriber<? super T> actual;\n         Subscription s;\n\ndiff --git a/src/test/java/io/reactivex/TransformerTest.java b/src/test/java/io/reactivex/TransformerTest.java\n--- a/src/test/java/io/reactivex/TransformerTest.java\n+++ b/src/test/java/io/reactivex/TransformerTest.java\n@@ -15,8 +15,6 @@\n \n import static org.junit.Assert.*;\n \n-import java.io.IOException;\n-\n import org.junit.Test;\n import org.reactivestreams.Publisher;\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java\n@@ -13,8 +13,6 @@\n \n package io.reactivex.internal.operators.flowable;\n \n-import static org.junit.Assert.*;\n-\n import org.junit.*;\n import org.reactivestreams.*;\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableToXTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableToXTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableToXTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableToXTest.java\n@@ -52,7 +52,7 @@ public void toFlowableLatest() {\n \n     @Test\n     public void toFlowableError1() {\n-        TestSubscriber<Integer> ts = Observable.range(1, 5)\n+        Observable.range(1, 5)\n         .toFlowable(BackpressureStrategy.ERROR)\n         .test(1)\n         .assertFailure(MissingBackpressureException.class, 1);",
    "output": "Fix warnings"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java\n--- a/src/main/java/io/reactivex/Completable.java\n+++ b/src/main/java/io/reactivex/Completable.java\n@@ -1415,7 +1415,7 @@ public final Completable retry(Predicate<? super Throwable> predicate) {\n      * @throws NullPointerException if handler is null\n      */\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    public final Completable retryWhen(Function<? super Flowable<? extends Throwable>, ? extends Publisher<Object>> handler) {\n+    public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler) {\n         return fromPublisher(toFlowable().retryWhen(handler));\n     }\n \n\ndiff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java\n--- a/src/main/java/io/reactivex/Flowable.java\n+++ b/src/main/java/io/reactivex/Flowable.java\n@@ -11105,7 +11105,7 @@ public final Flowable<T> retryUntil(final BooleanSupplier stop) {\n     @BackpressureSupport(BackpressureKind.FULL)\n     @SchedulerSupport(SchedulerSupport.NONE)\n     public final Flowable<T> retryWhen(\n-            final Function<? super Flowable<? extends Throwable>, ? extends Publisher<?>> handler) {\n+            final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {\n         ObjectHelper.requireNonNull(handler, \"handler is null\");\n \n         return RxJavaPlugins.onAssembly(new FlowableRetryWhen<T>(this, handler));\n\ndiff --git a/src/main/java/io/reactivex/Maybe.java b/src/main/java/io/reactivex/Maybe.java\n--- a/src/main/java/io/reactivex/Maybe.java\n+++ b/src/main/java/io/reactivex/Maybe.java\n@@ -3390,7 +3390,7 @@ public final Maybe<T> retryUntil(final BooleanSupplier stop) {\n      */\n     @SchedulerSupport(SchedulerSupport.NONE)\n     public final Maybe<T> retryWhen(\n-            final Function<? super Flowable<? extends Throwable>, ? extends Publisher<?>> handler) {\n+            final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {\n         return toFlowable().retryWhen(handler).singleElement();\n     }\n \n\ndiff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java\n--- a/src/main/java/io/reactivex/Observable.java\n+++ b/src/main/java/io/reactivex/Observable.java\n@@ -9196,7 +9196,7 @@ public final Observable<T> retryUntil(final BooleanSupplier stop) {\n      */\n     @SchedulerSupport(SchedulerSupport.NONE)\n     public final Observable<T> retryWhen(\n-            final Function<? super Observable<? extends Throwable>, ? extends ObservableSource<?>> handler) {\n+            final Function<? super Observable<Throwable>, ? extends ObservableSource<?>> handler) {\n         ObjectHelper.requireNonNull(handler, \"handler is null\");\n         return RxJavaPlugins.onAssembly(new ObservableRedo<T>(this, ObservableInternalHelper.retryWhenHandler(handler)));\n     }\n\ndiff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java\n--- a/src/main/java/io/reactivex/Single.java\n+++ b/src/main/java/io/reactivex/Single.java\n@@ -2396,7 +2396,7 @@ public final Single<T> retry(Predicate<? super Throwable> predicate) {\n      * @return the new Single instance\n      */\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    public final Single<T> retryWhen(Function<? super Flowable<? extends Throwable>, ? extends Publisher<Object>> handler) {\n+    public final Single<T> retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler) {\n         return toSingle(toFlowable().retryWhen(handler));\n     }\n \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableInternalHelper.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableInternalHelper.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableInternalHelper.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableInternalHelper.java\n@@ -277,10 +277,10 @@ public boolean test(Notification<Object> t) throws Exception {\n \n     static final class RetryWhenInner\n     implements Function<Observable<Notification<Object>>, ObservableSource<?>> {\n-        private final Function<? super Observable<? extends Throwable>, ? extends ObservableSource<?>> handler;\n+        private final Function<? super Observable<Throwable>, ? extends ObservableSource<?>> handler;\n \n         RetryWhenInner(\n-                Function<? super Observable<? extends Throwable>, ? extends ObservableSource<?>> handler) {\n+                Function<? super Observable<Throwable>, ? extends ObservableSource<?>> handler) {\n             this.handler = handler;\n         }\n \n@@ -293,7 +293,7 @@ public ObservableSource<?> apply(Observable<Notification<Object>> no) throws Exc\n         }\n     }\n \n-    public static <T> Function<Observable<Notification<Object>>, ObservableSource<?>> retryWhenHandler(final Function<? super Observable<? extends Throwable>, ? extends ObservableSource<?>> handler) {\n+    public static <T> Function<Observable<Notification<Object>>, ObservableSource<?>> retryWhenHandler(final Function<? super Observable<Throwable>, ? extends ObservableSource<?>> handler) {\n         return new RetryWhenInner(handler);\n     }\n ",
    "output": "Remove variance from the input source of retryWhen"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java\n@@ -87,7 +87,7 @@ public void onError(Throwable t) {\n \n         @Override\n         public void onComplete() {\n-            if (index <= count && !done) {\n+            if (!done) {\n                 done = true;\n                 T v = defaultValue;\n                 if (v == null) {\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java\n@@ -15,10 +15,15 @@\n \n import static org.junit.Assert.*;\n \n+import io.reactivex.*;\n+import io.reactivex.exceptions.TestException;\n+import io.reactivex.functions.Function;\n+import io.reactivex.internal.subscriptions.BooleanSubscription;\n+import io.reactivex.plugins.RxJavaPlugins;\n+import java.util.List;\n import java.util.NoSuchElementException;\n import org.junit.Test;\n-\n-import io.reactivex.Flowable;\n+import org.reactivestreams.*;\n \n public class FlowableElementAtTest {\n \n@@ -175,4 +180,59 @@ public void elementAtOrErrorIndex1OnEmptySource() {\n             .test()\n             .assertFailure(NoSuchElementException.class);\n     }\n+\n+\n+    @Test\n+    public void doubleOnSubscribe() {\n+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Publisher<Object>>() {\n+            @Override\n+            public Publisher<Object> apply(Flowable<Object> o) throws Exception {\n+                return o.elementAt(0).toFlowable();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void elementAtIndex1WithDefaultOnEmptySourceObservable() {\n+        Flowable.empty()\n+            .elementAt(1, 10)\n+            .toFlowable()\n+            .test()\n+            .assertResult(10);\n+    }\n+\n+    @Test\n+    public void errorFlowable() {\n+        Flowable.error(new TestException())\n+            .elementAt(1, 10)\n+            .toFlowable()\n+            .test()\n+            .assertFailure(TestException.class);\n+    }\n+\n+    @Test\n+    public void badSource() {\n+        List<Throwable> errors = TestHelper.trackPluginErrors();\n+        try {\n+            new Flowable<Integer>() {\n+                @Override\n+                protected void subscribeActual(Subscriber<? super Integer> subscriber) {\n+                    subscriber.onSubscribe(new BooleanSubscription());\n+\n+                    subscriber.onNext(1);\n+                    subscriber.onNext(2);\n+                    subscriber.onError(new TestException());\n+                    subscriber.onComplete();\n+                }\n+            }\n+            .elementAt(0)\n+            .toFlowable()\n+            .test()\n+            .assertResult(1);\n+\n+            TestHelper.assertError(errors, 0, TestException.class);\n+        } finally {\n+            RxJavaPlugins.reset();\n+        }\n+    }\n }",
    "output": "Fix Flowable.elementAt on empty sources. Plus sync tests"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeIterable.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeIterable.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeIterable.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeIterable.java\n@@ -13,7 +13,6 @@\n \n package io.reactivex.internal.operators.completable;\n \n-import io.reactivex.internal.functions.ObjectHelper;\n import java.util.Iterator;\n import java.util.concurrent.atomic.*;\n ",
    "output": "Fix unnecessary import"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java\n@@ -97,7 +97,7 @@ public void onError(Throwable t) {\n         @Override\n         public void onComplete() {\n             s = SubscriptionHelper.CANCELLED;\n-            if (index <= count && !done) {\n+            if (!done) {\n                 done = true;\n                 actual.onComplete();\n             }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java\n@@ -103,7 +103,7 @@ public void onError(Throwable t) {\n         @Override\n         public void onComplete() {\n             s = SubscriptionHelper.CANCELLED;\n-            if (index <= count && !done) {\n+            if (!done) {\n                 done = true;\n \n                 T v = defaultValue;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtMaybe.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtMaybe.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtMaybe.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtMaybe.java\n@@ -98,7 +98,7 @@ public void onError(Throwable t) {\n \n         @Override\n         public void onComplete() {\n-            if (index <= count && !done) {\n+            if (!done) {\n                 done = true;\n                 actual.onComplete();\n             }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtSingle.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtSingle.java\n@@ -99,7 +99,7 @@ public void onError(Throwable t) {\n \n         @Override\n         public void onComplete() {\n-            if (index <= count && !done) {\n+            if (!done) {\n                 done = true;\n \n                 T v = defaultValue;\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java\n@@ -135,4 +135,44 @@ public void elementAtOrErrorError() {\n             .assertErrorMessage(\"error\")\n             .assertError(RuntimeException.class);\n     }\n+\n+    @Test\n+    public void elementAtIndex0OnEmptySource() {\n+        Flowable.empty()\n+            .elementAt(0)\n+            .test()\n+            .assertResult();\n+    }\n+\n+    @Test\n+    public void elementAtIndex0WithDefaultOnEmptySource() {\n+        Flowable.empty()\n+            .elementAt(0, 5)\n+            .test()\n+            .assertResult(5);\n+    }\n+\n+    @Test\n+    public void elementAtIndex1OnEmptySource() {\n+        Flowable.empty()\n+            .elementAt(1)\n+            .test()\n+            .assertResult();\n+    }\n+\n+    @Test\n+    public void elementAtIndex1WithDefaultOnEmptySource() {\n+        Flowable.empty()\n+            .elementAt(1, 10)\n+            .test()\n+            .assertResult(10);\n+    }\n+\n+    @Test\n+    public void elementAtOrErrorIndex1OnEmptySource() {\n+        Flowable.empty()\n+            .elementAtOrError(1)\n+            .test()\n+            .assertFailure(NoSuchElementException.class);\n+    }\n }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableElementAtTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableElementAtTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableElementAtTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableElementAtTest.java\n@@ -126,4 +126,44 @@ public void elementAtOrErrorError() {\n             .assertErrorMessage(\"error\")\n             .assertError(RuntimeException.class);\n     }\n+\n+    @Test\n+    public void elementAtIndex0OnEmptySource() {\n+        Observable.empty()\n+            .elementAt(0)\n+            .test()\n+            .assertResult();\n+    }\n+\n+    @Test\n+    public void elementAtIndex0WithDefaultOnEmptySource() {\n+        Observable.empty()\n+            .elementAt(0, 5)\n+            .test()\n+            .assertResult(5);\n+    }\n+\n+    @Test\n+    public void elementAtIndex1OnEmptySource() {\n+        Observable.empty()\n+            .elementAt(1)\n+            .test()\n+            .assertResult();\n+    }\n+\n+    @Test\n+    public void elementAtIndex1WithDefaultOnEmptySource() {\n+        Observable.empty()\n+            .elementAt(1, 10)\n+            .test()\n+            .assertResult(10);\n+    }\n+\n+    @Test\n+    public void elementAtOrErrorIndex1OnEmptySource() {\n+        Observable.empty()\n+            .elementAtOrError(1)\n+            .test()\n+            .assertFailure(NoSuchElementException.class);\n+    }\n }",
    "output": "Fix Flowable + Single elementAt and elementAtOrError operators on empty sources"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java\n@@ -191,14 +191,18 @@ void innerSuccess(InnerObserver inner, R value) {\n                     }\n                 } else {\n                     SpscLinkedArrayQueue<R> q = getOrCreateQueue();\n-                    q.offer(value);\n+                    synchronized (q) {\n+                        q.offer(value);\n+                    }\n                 }\n                 if (decrementAndGet() == 0) {\n                     return;\n                 }\n             } else {\n                 SpscLinkedArrayQueue<R> q = getOrCreateQueue();\n-                q.offer(value);\n+                synchronized (q) {\n+                    q.offer(value);\n+                }\n                 active.decrementAndGet();\n                 if (getAndIncrement() != 0) {\n                     return;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java\n@@ -191,14 +191,18 @@ void innerSuccess(InnerObserver inner, R value) {\n                     }\n                 } else {\n                     SpscLinkedArrayQueue<R> q = getOrCreateQueue();\n-                    q.offer(value);\n+                    synchronized (q) {\n+                        q.offer(value);\n+                    }\n                 }\n                 if (decrementAndGet() == 0) {\n                     return;\n                 }\n             } else {\n                 SpscLinkedArrayQueue<R> q = getOrCreateQueue();\n-                q.offer(value);\n+                synchronized (q) {\n+                    q.offer(value);\n+                }\n                 active.decrementAndGet();\n                 if (getAndIncrement() != 0) {\n                     return;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapMaybe.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapMaybe.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapMaybe.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapMaybe.java\n@@ -167,7 +167,9 @@ void innerSuccess(InnerObserver inner, R value) {\n                 }\n             } else {\n                 SpscLinkedArrayQueue<R> q = getOrCreateQueue();\n-                q.offer(value);\n+                synchronized (q) {\n+                    q.offer(value);\n+                }\n                 active.decrementAndGet();\n                 if (getAndIncrement() != 0) {\n                     return;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapSingle.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapSingle.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapSingle.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapSingle.java\n@@ -167,7 +167,9 @@ void innerSuccess(InnerObserver inner, R value) {\n                 }\n             } else {\n                 SpscLinkedArrayQueue<R> q = getOrCreateQueue();\n-                q.offer(value);\n+                synchronized (q) {\n+                    q.offer(value);\n+                }\n                 active.decrementAndGet();\n                 if (getAndIncrement() != 0) {\n                     return;",
    "output": "Fix flatMapX calling SpscLinkedArrayQueue.offer concurrently"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/observers/BasicFuseableObserver.java b/src/main/java/io/reactivex/internal/observers/BasicFuseableObserver.java\n--- a/src/main/java/io/reactivex/internal/observers/BasicFuseableObserver.java\n+++ b/src/main/java/io/reactivex/internal/observers/BasicFuseableObserver.java\n@@ -17,7 +17,6 @@\n import io.reactivex.disposables.Disposable;\n import io.reactivex.exceptions.Exceptions;\n import io.reactivex.internal.disposables.DisposableHelper;\n-import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.fuseable.QueueDisposable;\n import io.reactivex.plugins.RxJavaPlugins;\n \n@@ -91,17 +90,6 @@ protected void afterDownstream() {\n     // Convenience and state-aware methods\n     // -----------------------------------\n \n-    /**\n-     * Emits the value to the actual subscriber if {@link #done} is false.\n-     * @param value the value to signal\n-     */\n-    protected final void next(R value) {\n-        if (done) {\n-            return;\n-        }\n-        actual.onNext(value);\n-    }\n-\n     @Override\n     public void onError(Throwable t) {\n         if (done) {\n@@ -131,16 +119,6 @@ public void onComplete() {\n         actual.onComplete();\n     }\n \n-    /**\n-     * Checks if the value is null and if so, throws a NullPointerException.\n-     * @param value the value to check\n-     * @param message the message to indicate the source of the value\n-     * @return the value if not null\n-     */\n-    protected final <V> V nullCheck(V value, String message) {\n-        return ObjectHelper.requireNonNull(value, message);\n-    }\n-\n     /**\n      * Calls the upstream's QueueDisposable.requestFusion with the mode and\n      * saves the established mode in {@link #sourceMode}.",
    "output": "Remove unused methods in BasicFuseableObserver"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java\n--- a/src/main/java/io/reactivex/Completable.java\n+++ b/src/main/java/io/reactivex/Completable.java\n@@ -339,6 +339,23 @@ public static Completable fromFuture(final Future<?> future) {\n         return fromAction(Functions.futureAction(future));\n     }\n \n+    /**\n+     * Returns a Completable instance that runs the given Runnable for each subscriber and\n+     * emits either its exception or simply completes.\n+     * <dl>\n+     *  <dt><b>Scheduler:</b></dt>\n+     *  <dd>{@code fromRunnable} does not operate by default on a particular {@link Scheduler}.</dd>\n+     * </dl>\n+     * @param run the runnable to run for each subscriber\n+     * @return the new Completable instance\n+     * @throws NullPointerException if run is null\n+     */\n+    @SchedulerSupport(SchedulerSupport.NONE)\n+    public static Completable fromRunnable(final Runnable run) {\n+        ObjectHelper.requireNonNull(run, \"run is null\");\n+        return RxJavaPlugins.onAssembly(new CompletableFromRunnable(run));\n+    }\n+\n     /**\n      * Returns a Completable instance that subscribes to the given Observable, ignores all values and\n      * emits only the terminal event.\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableFromRunnable.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableFromRunnable.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableFromRunnable.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableFromRunnable.java\n@@ -0,0 +1,47 @@\n+/**\n+ * Copyright 2016 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.completable;\n+\n+import io.reactivex.Completable;\n+import io.reactivex.CompletableObserver;\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.disposables.Disposables;\n+import io.reactivex.exceptions.Exceptions;\n+\n+public final class CompletableFromRunnable extends Completable {\n+\n+    final Runnable runnable;\n+\n+    public CompletableFromRunnable(Runnable runnable) {\n+        this.runnable = runnable;\n+    }\n+\n+    @Override\n+    protected void subscribeActual(CompletableObserver s) {\n+        Disposable d = Disposables.empty();\n+        s.onSubscribe(d);\n+        try {\n+            runnable.run();\n+        } catch (Throwable e) {\n+            Exceptions.throwIfFatal(e);\n+            if (!d.isDisposed()) {\n+                s.onError(e);\n+            }\n+            return;\n+        }\n+        if (!d.isDisposed()) {\n+            s.onComplete();\n+        }\n+    }\n+}\n\ndiff --git a/src/test/java/io/reactivex/completable/CompletableTest.java b/src/test/java/io/reactivex/completable/CompletableTest.java\n--- a/src/test/java/io/reactivex/completable/CompletableTest.java\n+++ b/src/test/java/io/reactivex/completable/CompletableTest.java\n@@ -4473,6 +4473,37 @@ public void run() {\n         }\n     }\n \n+    @Test(expected = NullPointerException.class)\n+    public void fromRunnableNull() {\n+        Completable.fromRunnable(null);\n+    }\n+\n+    @Test(timeout = 1000)\n+    public void fromRunnableNormal() {\n+        final AtomicInteger calls = new AtomicInteger();\n+\n+        Completable c = Completable.fromRunnable(new Runnable() {\n+            @Override\n+            public void run() {\n+                calls.getAndIncrement();\n+            }\n+        });\n+\n+        c.blockingAwait();\n+\n+        Assert.assertEquals(1, calls.get());\n+    }\n+\n+    @Test(timeout = 1000, expected = TestException.class)\n+    public void fromRunnableThrows() {\n+        Completable c = Completable.fromRunnable(new Runnable() {\n+            @Override\n+            public void run() { throw new TestException(); }\n+        });\n+\n+        c.blockingAwait();\n+    }\n+\n     @Test(expected = NullPointerException.class)\n     public void doOnErrorNullValue() {\n         Completable.complete().doOnError(null);",
    "output": "Add Completable.fromRunnable()"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/observers/BaseTestConsumer.java b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n--- a/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java\n@@ -20,6 +20,7 @@\n import io.reactivex.disposables.Disposable;\n import io.reactivex.exceptions.CompositeException;\n import io.reactivex.functions.Predicate;\n+import io.reactivex.internal.functions.Functions;\n import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.util.ExceptionHelper;\n \n@@ -227,18 +228,7 @@ public final U assertNoErrors() {\n      */\n     @SuppressWarnings(\"unchecked\")\n     public final U assertError(Throwable error) {\n-        int s = errors.size();\n-        if (s == 0) {\n-            throw fail(\"No errors\");\n-        }\n-        if (errors.contains(error)) {\n-            if (s != 1) {\n-                throw fail(\"Error present but other errors as well\");\n-            }\n-        } else {\n-            throw fail(\"Error not present\");\n-        }\n-        return (U)this;\n+        return (U)assertError(Functions.equalsWith(error));\n     }\n \n     /**\n@@ -249,28 +239,7 @@ public final U assertError(Throwable error) {\n      */\n     @SuppressWarnings(\"unchecked\")\n     public final U assertError(Class<? extends Throwable> errorClass) {\n-        int s = errors.size();\n-        if (s == 0) {\n-            throw fail(\"No errors\");\n-        }\n-\n-        boolean found = false;\n-\n-        for (Throwable e : errors) {\n-            if (errorClass.isInstance(e)) {\n-                found = true;\n-                break;\n-            }\n-        }\n-\n-        if (found) {\n-            if (s != 1) {\n-                throw fail(\"Error present but other errors as well\");\n-            }\n-        } else {\n-            throw fail(\"Error not present\");\n-        }\n-        return (U)this;\n+        return (U)assertError((Predicate)Functions.isInstanceOf(errorClass));\n     }\n \n     /**\n\ndiff --git a/src/test/java/io/reactivex/observers/TestObserverTest.java b/src/test/java/io/reactivex/observers/TestObserverTest.java\n--- a/src/test/java/io/reactivex/observers/TestObserverTest.java\n+++ b/src/test/java/io/reactivex/observers/TestObserverTest.java\n@@ -295,10 +295,10 @@ public void createDelegate() {\n             // expected\n         }\n \n-        ts.assertValueSequence(Arrays.asList(1));\n+        ts.assertValueSequence(Collections.singletonList(1));\n \n         try {\n-            ts.assertValueSequence(Arrays.asList(2));\n+            ts.assertValueSequence(Collections.singletonList(2));\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError exc) {\n             // expected\n@@ -344,21 +344,21 @@ public void assertError() {\n             ts.assertErrorMessage(\"\");\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError exc) {\n-\n+            // expected\n         }\n \n         try {\n             ts.assertSubscribed();\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError exc) {\n-\n+            // expected\n         }\n \n         try {\n             ts.assertTerminated();\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError exc) {\n-\n+            // expected\n         }\n \n         ts.onSubscribe(Disposables.empty());\n@@ -390,7 +390,7 @@ public boolean test(Throwable t) throws Exception {\n             ts.assertErrorMessage(\"\");\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError exc) {\n-\n+            // expected\n         }\n \n         try {\n@@ -671,11 +671,11 @@ public void onNext() {\n \n         assertEquals(0, ts.valueCount());\n \n-        assertEquals(Arrays.asList(), ts.values());\n+        assertEquals(Collections.emptyList(), ts.values());\n \n         ts.onNext(1);\n \n-        assertEquals(Arrays.asList(1), ts.values());\n+        assertEquals(Collections.singletonList(1), ts.values());\n \n         ts.cancel();\n \n@@ -684,11 +684,11 @@ public void onNext() {\n \n         ts.assertValue(1);\n \n-        assertEquals(Arrays.asList(Arrays.asList(1), Collections.emptyList(), Collections.emptyList()), ts.getEvents());\n+        assertEquals(Arrays.asList(Collections.singletonList(1), Collections.emptyList(), Collections.emptyList()), ts.getEvents());\n \n         ts.onComplete();\n \n-        assertEquals(Arrays.asList(Arrays.asList(1), Collections.emptyList(), Collections.singletonList(Notification.createOnComplete())), ts.getEvents());\n+        assertEquals(Arrays.asList(Collections.singletonList(1), Collections.emptyList(), Collections.singletonList(Notification.createOnComplete())), ts.getEvents());\n     }\n \n     @Test\n@@ -896,14 +896,14 @@ public void assertValueSequence() {\n         ts.onNext(2);\n \n         try {\n-            ts.assertValueSequence(Arrays.<Integer>asList());\n+            ts.assertValueSequence(Collections.<Integer>emptyList());\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError ex) {\n             // expected\n         }\n \n         try {\n-            ts.assertValueSequence(Arrays.asList(1));\n+            ts.assertValueSequence(Collections.singletonList(1));\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError ex) {\n             // expected\n\ndiff --git a/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java b/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n--- a/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n+++ b/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java\n@@ -738,10 +738,10 @@ public void createDelegate() {\n             // expected\n         }\n \n-        ts.assertValueSequence(Arrays.asList(1));\n+        ts.assertValueSequence(Collections.singletonList(1));\n \n         try {\n-            ts.assertValueSequence(Arrays.asList(2));\n+            ts.assertValueSequence(Collections.singletonList(2));\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError exc) {\n             // expected\n@@ -780,7 +780,7 @@ public void assertError() {\n             ts.assertErrorMessage(\"\");\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError exc) {\n-\n+            // expected\n         }\n \n         try {\n@@ -794,14 +794,14 @@ public void assertError() {\n             ts.assertSubscribed();\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError exc) {\n-\n+            // expected\n         }\n \n         try {\n             ts.assertTerminated();\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError exc) {\n-\n+            // expected\n         }\n \n         ts.onSubscribe(new BooleanSubscription());\n@@ -833,7 +833,7 @@ public boolean test(Throwable t) {\n             ts.assertErrorMessage(\"\");\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError exc) {\n-\n+            // expected\n         }\n \n         try {\n@@ -1113,11 +1113,11 @@ public void onNext() {\n \n         assertEquals(0, ts.valueCount());\n \n-        assertEquals(Arrays.asList(), ts.values());\n+        assertEquals(Collections.emptyList(), ts.values());\n \n         ts.onNext(1);\n \n-        assertEquals(Arrays.asList(1), ts.values());\n+        assertEquals(Collections.singletonList(1), ts.values());\n \n         ts.cancel();\n \n@@ -1126,11 +1126,11 @@ public void onNext() {\n \n         ts.assertValue(1);\n \n-        assertEquals(Arrays.asList(Arrays.asList(1), Collections.emptyList(), Collections.emptyList()), ts.getEvents());\n+        assertEquals(Arrays.asList(Collections.singletonList(1), Collections.emptyList(), Collections.emptyList()), ts.getEvents());\n \n         ts.onComplete();\n \n-        assertEquals(Arrays.asList(Arrays.asList(1), Collections.emptyList(), Collections.singletonList(Notification.createOnComplete())), ts.getEvents());\n+        assertEquals(Arrays.asList(Collections.singletonList(1), Collections.emptyList(), Collections.singletonList(Notification.createOnComplete())), ts.getEvents());\n     }\n \n     @Test\n@@ -1338,14 +1338,14 @@ public void assertValueSequence() {\n         ts.onNext(2);\n \n         try {\n-            ts.assertValueSequence(Arrays.<Integer>asList());\n+            ts.assertValueSequence(Collections.<Integer>emptyList());\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError ex) {\n             // expected\n         }\n \n         try {\n-            ts.assertValueSequence(Arrays.asList(1));\n+            ts.assertValueSequence(Collections.singletonList(1));\n             throw new RuntimeException(\"Should have thrown\");\n         } catch (AssertionError ex) {\n             // expected",
    "output": "Use predicates in BaseTestConsumer assertError(Class/Throwable) to remove duplicate code, tests tweaks to remove few IDE warnings\n\n* BaseTestConsumer use predicates in assertError with class and exception to remove duplicate code\r\n\r\n* TestObserver & TestSubscriber tests cleanup to remove IDE warnings"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java\n--- a/src/main/java/io/reactivex/Completable.java\n+++ b/src/main/java/io/reactivex/Completable.java\n@@ -26,6 +26,7 @@\n import io.reactivex.internal.operators.completable.*;\n import io.reactivex.internal.operators.flowable.FlowableDelaySubscriptionOther;\n import io.reactivex.internal.operators.maybe.MaybeFromCompletable;\n+import io.reactivex.internal.operators.maybe.MaybeDelayWithCompletable;\n import io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther;\n import io.reactivex.internal.operators.single.SingleDelayWithCompletable;\n import io.reactivex.internal.util.ExceptionHelper;\n@@ -799,6 +800,26 @@ public final <T> Single<T> andThen(SingleSource<T> next) {\n         return RxJavaPlugins.onAssembly(new SingleDelayWithCompletable<T>(next, this));\n     }\n \n+    /**\n+     * Returns a {@link Maybe} which will subscribe to this Completable and once that is completed then\n+     * will subscribe to the {@code next} MaybeSource. An error event from this Completable will be\n+     * propagated to the downstream subscriber and will result in skipping the subscription of the\n+     * Maybe.\n+     * <dl>\n+     *  <dt><b>Scheduler:</b></dt>\n+     *  <dd>{@code andThen} does not operate by default on a particular {@link Scheduler}.</dd>\n+     * </dl>\n+     *\n+     * @param <T> the value type of the next MaybeSource\n+     * @param next the Maybe to subscribe after this Completable is completed, not null\n+     * @return Maybe that composes this Completable and next\n+     */\n+    @SchedulerSupport(SchedulerSupport.NONE)\n+    public final <T> Maybe<T> andThen(MaybeSource<T> next) {\n+        ObjectHelper.requireNonNull(next, \"next is null\");\n+        return RxJavaPlugins.onAssembly(new MaybeDelayWithCompletable<T>(next, this));\n+    }\n+\n     /**\n      * Returns a Completable that first runs this Completable\n      * and then the other completable.\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/maybe/MaybeDelayWithCompletable.java b/src/main/java/io/reactivex/internal/operators/maybe/MaybeDelayWithCompletable.java\n--- a/src/main/java/io/reactivex/internal/operators/maybe/MaybeDelayWithCompletable.java\n+++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeDelayWithCompletable.java\n@@ -0,0 +1,115 @@\n+/**\n+ * Copyright 2016 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.maybe;\n+\n+import io.reactivex.CompletableObserver;\n+import io.reactivex.CompletableSource;\n+import io.reactivex.Maybe;\n+import io.reactivex.MaybeObserver;\n+import io.reactivex.MaybeSource;\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.internal.disposables.DisposableHelper;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public final class MaybeDelayWithCompletable<T> extends Maybe<T> {\n+\n+    final MaybeSource<T> source;\n+\n+    final CompletableSource other;\n+\n+    public MaybeDelayWithCompletable(MaybeSource<T> source, CompletableSource other) {\n+        this.source = source;\n+        this.other = other;\n+    }\n+\n+    @Override\n+    protected void subscribeActual(MaybeObserver<? super T> subscriber) {\n+        other.subscribe(new OtherObserver<T>(subscriber, source));\n+    }\n+\n+    static final class OtherObserver<T>\n+    extends AtomicReference<Disposable>\n+    implements CompletableObserver, Disposable {\n+        private static final long serialVersionUID = 703409937383992161L;\n+\n+        final MaybeObserver<? super T> actual;\n+\n+        final MaybeSource<T> source;\n+\n+        OtherObserver(MaybeObserver<? super T> actual, MaybeSource<T> source) {\n+            this.actual = actual;\n+            this.source = source;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Disposable d) {\n+            if (DisposableHelper.setOnce(this, d)) {\n+\n+                actual.onSubscribe(this);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable e) {\n+            actual.onError(e);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            source.subscribe(new DelayWithMainObserver<T>(this, actual));\n+        }\n+\n+        @Override\n+        public void dispose() {\n+            DisposableHelper.dispose(this);\n+        }\n+\n+        @Override\n+        public boolean isDisposed() {\n+            return DisposableHelper.isDisposed(get());\n+        }\n+    }\n+\n+    static final class DelayWithMainObserver<T> implements MaybeObserver<T> {\n+\n+        final AtomicReference<Disposable> parent;\n+\n+        final MaybeObserver<? super T> actual;\n+\n+        DelayWithMainObserver(AtomicReference<Disposable> parent, MaybeObserver<? super T> actual) {\n+            this.parent = parent;\n+            this.actual = actual;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Disposable d) {\n+            DisposableHelper.replace(parent, d);\n+        }\n+\n+        @Override\n+        public void onSuccess(T value) {\n+            actual.onSuccess(value);\n+        }\n+\n+        @Override\n+        public void onError(Throwable e) {\n+            actual.onError(e);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            actual.onComplete();\n+        }\n+    }\n+}\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/single/SingleDelayWithCompletable.java b/src/main/java/io/reactivex/internal/operators/single/SingleDelayWithCompletable.java\n--- a/src/main/java/io/reactivex/internal/operators/single/SingleDelayWithCompletable.java\n+++ b/src/main/java/io/reactivex/internal/operators/single/SingleDelayWithCompletable.java\n@@ -53,7 +53,7 @@ static final class OtherObserver<T>\n \n         @Override\n         public void onSubscribe(Disposable d) {\n-            if (DisposableHelper.set(this, d)) {\n+            if (DisposableHelper.setOnce(this, d)) {\n \n                 actual.onSubscribe(this);\n             }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableAndThenTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableAndThenTest.java\n--- a/src/test/java/io/reactivex/internal/operators/completable/CompletableAndThenTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableAndThenTest.java\n@@ -0,0 +1,66 @@\n+/**\n+ * Copyright 2016 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.completable;\n+\n+import io.reactivex.Completable;\n+import io.reactivex.Maybe;\n+import org.junit.Test;\n+\n+public class CompletableAndThenTest {\n+    @Test(expected = NullPointerException.class)\n+    public void andThenMaybeNull() {\n+        Completable.complete()\n+            .andThen((Maybe<Object>) null);\n+    }\n+\n+    @Test\n+    public void andThenMaybeCompleteValue() {\n+        Completable.complete()\n+            .andThen(Maybe.just(1))\n+            .test()\n+            .assertResult(1);\n+    }\n+\n+    @Test\n+    public void andThenMaybeCompleteError() {\n+        Completable.complete()\n+            .andThen(Maybe.error(new RuntimeException(\"test\")))\n+            .test()\n+            .assertNotComplete()\n+            .assertNoValues()\n+            .assertError(RuntimeException.class)\n+            .assertErrorMessage(\"test\");\n+    }\n+\n+    @Test\n+    public void andThenMaybeCompleteEmpty() {\n+        Completable.complete()\n+            .andThen(Maybe.empty())\n+            .test()\n+            .assertNoValues()\n+            .assertNoErrors()\n+            .assertComplete();\n+    }\n+\n+    @Test\n+    public void andThenMaybeError() {\n+        Completable.error(new RuntimeException(\"bla\"))\n+            .andThen(Maybe.empty())\n+            .test()\n+            .assertNotComplete()\n+            .assertNoValues()\n+            .assertError(RuntimeException.class)\n+            .assertErrorMessage(\"bla\");\n+    }\n+}",
    "output": "Add Completable.andThen(MaybeSource)\n\n* Add Completable.andThen(MaybeSource)\r\n\r\n* Add missing import\r\n\r\n* Requested changes"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/processors/UnicastProcessorTest.java b/src/test/java/io/reactivex/processors/UnicastProcessorTest.java\n--- a/src/test/java/io/reactivex/processors/UnicastProcessorTest.java\n+++ b/src/test/java/io/reactivex/processors/UnicastProcessorTest.java\n@@ -13,16 +13,16 @@\n \n package io.reactivex.processors;\n \n-import org.junit.Test;\n import static org.junit.Assert.assertEquals;\n \n import java.util.concurrent.atomic.AtomicBoolean;\n \n+import org.junit.Test;\n+\n+import io.reactivex.Observable;\n+import io.reactivex.disposables.Disposable;\n import io.reactivex.internal.fuseable.QueueSubscription;\n import io.reactivex.subscribers.*;\n-import io.reactivex.observers.*;\n-import io.reactivex.*;\n-import io.reactivex.disposables.*;\n \n public class UnicastProcessorTest {\n \n\ndiff --git a/src/test/java/io/reactivex/subjects/UnicastSubjectTest.java b/src/test/java/io/reactivex/subjects/UnicastSubjectTest.java\n--- a/src/test/java/io/reactivex/subjects/UnicastSubjectTest.java\n+++ b/src/test/java/io/reactivex/subjects/UnicastSubjectTest.java\n@@ -13,15 +13,16 @@\n \n package io.reactivex.subjects;\n \n-import io.reactivex.Observable;\n-import io.reactivex.disposables.Disposable;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import org.junit.Test;\n \n+import io.reactivex.Observable;\n+import io.reactivex.disposables.Disposable;\n import io.reactivex.internal.fuseable.QueueDisposable;\n import io.reactivex.observers.*;\n-import io.reactivex.*;\n \n public class UnicastSubjectTest {\n ",
    "output": "Remove unused imports"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java\n@@ -787,6 +787,8 @@ public void testErrorRunsBeforeOnNext() {\n         ts.assertError(TestException.class);\n         ts.assertNotComplete();\n     }\n+\n+    @Test\n     public void testDelaySupplierSimple() {\n         final PublishProcessor<Integer> ps = PublishProcessor.create();\n \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java\n@@ -252,6 +252,8 @@ public void testDownstreamUnsubscribes() {\n         assertFalse(\"Until still has observers\", until.hasSubscribers());\n         assertFalse(\"TestSubscriber is unsubscribed\", ts.isCancelled());\n     }\n+\n+    @Test\n     public void testBackpressure() {\n         PublishProcessor<Integer> until = PublishProcessor.create();\n \n@@ -267,6 +269,11 @@ public void testBackpressure() {\n         ts.assertNoErrors();\n         ts.assertNotComplete();\n \n+        until.onNext(5);\n+\n+        ts.assertComplete();\n+        ts.assertNoErrors();\n+\n         assertFalse(\"Until still has observers\", until.hasSubscribers());\n         assertFalse(\"TestSubscriber is unsubscribed\", ts.isCancelled());\n     }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableDelayTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableDelayTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableDelayTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableDelayTest.java\n@@ -789,6 +789,7 @@ public void testErrorRunsBeforeOnNext() {\n         ts.assertNotComplete();\n     }\n \n+    @Test\n     public void testDelaySupplierSimple() {\n         final PublishSubject<Integer> ps = PublishSubject.create();\n ",
    "output": "Add missing @Test annotation on tests\n\n* Add missing @Test annotation on tests\r\n\r\n* Fix test"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java\n--- a/src/main/java/io/reactivex/Flowable.java\n+++ b/src/main/java/io/reactivex/Flowable.java\n@@ -12341,32 +12341,6 @@ public final Flowable<T> take(long time, TimeUnit unit, Scheduler scheduler) {\n         return takeUntil(timer(time, unit, scheduler));\n     }\n \n-    /**\n-     * Returns a Flowable that emits only the very first item emitted by the source Publisher that satisfies\n-     * a specified condition.\n-     * <p>\n-     * <img width=\"640\" height=\"305\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeFirstN.png\" alt=\"\">\n-     * <dl>\n-     *  <dt><b>Backpressure:</b></dt>\n-     *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure\n-     *  behavior.</dd>\n-     *  <dt><b>Scheduler:</b></dt>\n-     *  <dd>{@code takeFirst} does not operate by default on a particular {@link Scheduler}.</dd>\n-     * </dl>\n-     *\n-     * @param predicate\n-     *            the condition any item emitted by the source Publisher has to satisfy\n-     * @return a Flowable that emits only the very first item emitted by the source Publisher that satisfies\n-     *         the given condition, or that completes without emitting anything if the source Publisher\n-     *         completes without emitting a single condition-satisfying item\n-     * @see <a href=\"http://reactivex.io/documentation/operators/first.html\">ReactiveX operators documentation: First</a>\n-     */\n-    @BackpressureSupport(BackpressureKind.SPECIAL) // may trigger UNBOUNDED_IN\n-    @SchedulerSupport(SchedulerSupport.NONE)\n-    public final Flowable<T> takeFirst(Predicate<? super T> predicate) {\n-        return filter(predicate).take(1);\n-    }\n-\n     /**\n      * Returns a Flowable that emits at most the last {@code count} items emitted by the source Publisher. If the source emits fewer than\n      * {@code count} items then all of its items are emitted.\n\ndiff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java\n--- a/src/main/java/io/reactivex/Observable.java\n+++ b/src/main/java/io/reactivex/Observable.java\n@@ -10333,28 +10333,6 @@ public final Observable<T> take(long time, TimeUnit unit, Scheduler scheduler) {\n         return takeUntil(timer(time, unit, scheduler));\n     }\n \n-    /**\n-     * Returns an Observable that emits only the very first item emitted by the source ObservableSource that satisfies\n-     * a specified condition.\n-     * <p>\n-     * <img width=\"640\" height=\"305\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeFirstN.png\" alt=\"\">\n-     * <dl>\n-     *  <dt><b>Scheduler:</b></dt>\n-     *  <dd>{@code takeFirst} does not operate by default on a particular {@link Scheduler}.</dd>\n-     * </dl>\n-     *\n-     * @param predicate\n-     *            the condition any item emitted by the source ObservableSource has to satisfy\n-     * @return an Observable that emits only the very first item emitted by the source ObservableSource that satisfies\n-     *         the given condition, or that completes without emitting anything if the source ObservableSource\n-     *         completes without emitting a single condition-satisfying item\n-     * @see <a href=\"http://reactivex.io/documentation/operators/first.html\">ReactiveX operators documentation: First</a>\n-     */\n-    @SchedulerSupport(SchedulerSupport.NONE)\n-    public final Observable<T> takeFirst(Predicate<? super T> predicate) {\n-        return filter(predicate).take(1);\n-    }\n-\n     /**\n      * Returns an Observable that emits at most the last {@code count} items emitted by the source ObservableSource. If the source emits fewer than\n      * {@code count} items then all of its items are emitted.\n\ndiff --git a/src/test/java/io/reactivex/flowable/FlowableNullTests.java b/src/test/java/io/reactivex/flowable/FlowableNullTests.java\n--- a/src/test/java/io/reactivex/flowable/FlowableNullTests.java\n+++ b/src/test/java/io/reactivex/flowable/FlowableNullTests.java\n@@ -2179,11 +2179,6 @@ public void takeTimedSchedulerNull() {\n         just1.take(1, TimeUnit.SECONDS, null);\n     }\n \n-    @Test(expected = NullPointerException.class)\n-    public void takeFirstNull() {\n-        just1.takeFirst(null);\n-    }\n-\n     @Test(expected = NullPointerException.class)\n     public void takeLastTimedUnitNull() {\n         just1.takeLast(1, null, Schedulers.single());\n@@ -2957,4 +2952,4 @@ public Object apply(Object[] v) {\n             }\n         }, 128, just1).blockingLast();\n     }\n-}\n\\ No newline at end of file\n+}\n\ndiff --git a/src/test/java/io/reactivex/flowable/FlowableTests.java b/src/test/java/io/reactivex/flowable/FlowableTests.java\n--- a/src/test/java/io/reactivex/flowable/FlowableTests.java\n+++ b/src/test/java/io/reactivex/flowable/FlowableTests.java\n@@ -182,9 +182,10 @@ public Throwable call() {\n         verify(wo, times(1)).onError(any(RuntimeException.class));\n     }\n \n+    @Test\n     public void testTakeFirstWithPredicateOfSome() {\n         Flowable<Integer> observable = Flowable.just(1, 3, 5, 4, 6, 3);\n-        observable.takeFirst(IS_EVEN).subscribe(w);\n+        observable.filter(IS_EVEN).take(1).subscribe(w);\n         verify(w, times(1)).onNext(anyInt());\n         verify(w).onNext(4);\n         verify(w, times(1)).onComplete();\n@@ -194,7 +195,7 @@ public void testTakeFirstWithPredicateOfSome() {\n     @Test\n     public void testTakeFirstWithPredicateOfNoneMatchingThePredicate() {\n         Flowable<Integer> observable = Flowable.just(1, 3, 5, 7, 9, 7, 5, 3, 1);\n-        observable.takeFirst(IS_EVEN).subscribe(w);\n+        observable.filter(IS_EVEN).take(1).subscribe(w);\n         verify(w, never()).onNext(anyInt());\n         verify(w, times(1)).onComplete();\n         verify(w, never()).onError(any(Throwable.class));\n\ndiff --git a/src/test/java/io/reactivex/observable/ObservableNullTests.java b/src/test/java/io/reactivex/observable/ObservableNullTests.java\n--- a/src/test/java/io/reactivex/observable/ObservableNullTests.java\n+++ b/src/test/java/io/reactivex/observable/ObservableNullTests.java\n@@ -2250,11 +2250,6 @@ public void takeTimedSchedulerNull() {\n         just1.take(1, TimeUnit.SECONDS, null);\n     }\n \n-    @Test(expected = NullPointerException.class)\n-    public void takeFirstNull() {\n-        just1.takeFirst(null);\n-    }\n-\n     @Test(expected = NullPointerException.class)\n     public void takeLastTimedUnitNull() {\n         just1.takeLast(1, null, Schedulers.single());\n\ndiff --git a/src/test/java/io/reactivex/observable/ObservableTest.java b/src/test/java/io/reactivex/observable/ObservableTest.java\n--- a/src/test/java/io/reactivex/observable/ObservableTest.java\n+++ b/src/test/java/io/reactivex/observable/ObservableTest.java\n@@ -186,7 +186,7 @@ public Throwable call() {\n     @Test\n     public void testTakeFirstWithPredicateOfSome() {\n         Observable<Integer> o = Observable.just(1, 3, 5, 4, 6, 3);\n-        o.takeFirst(IS_EVEN).subscribe(w);\n+        o.filter(IS_EVEN).take(1).subscribe(w);\n         verify(w, times(1)).onNext(anyInt());\n         verify(w).onNext(4);\n         verify(w, times(1)).onComplete();\n@@ -196,7 +196,7 @@ public void testTakeFirstWithPredicateOfSome() {\n     @Test\n     public void testTakeFirstWithPredicateOfNoneMatchingThePredicate() {\n         Observable<Integer> o = Observable.just(1, 3, 5, 7, 9, 7, 5, 3, 1);\n-        o.takeFirst(IS_EVEN).subscribe(w);\n+        o.filter(IS_EVEN).take(1).subscribe(w);\n         verify(w, never()).onNext(anyInt());\n         verify(w, times(1)).onComplete();\n         verify(w, never()).onError(any(Throwable.class));",
    "output": "Remove takeFirst(predicate) in Observable & Flowable"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java\n@@ -20,7 +20,6 @@\n \n import io.reactivex.exceptions.Exceptions;\n import io.reactivex.internal.subscriptions.*;\n-import io.reactivex.internal.util.ArrayListSupplier;\n \n public final class FlowableToList<T, U extends Collection<? super T>> extends AbstractFlowableWithUpstream<T, U> {\n     final Callable<U> collectionSupplier;",
    "output": "Remove unused import"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/observers/InnerQueuedObserver.java b/src/main/java/io/reactivex/internal/observers/InnerQueuedObserver.java\n--- a/src/main/java/io/reactivex/internal/observers/InnerQueuedObserver.java\n+++ b/src/main/java/io/reactivex/internal/observers/InnerQueuedObserver.java\n@@ -42,8 +42,6 @@ public final class InnerQueuedObserver<T>\n \n     volatile boolean done;\n \n-    long produced;\n-\n     int fusionMode;\n \n     public InnerQueuedObserver(InnerQueuedObserverSupport<T> parent, int prefetch) {\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java\n@@ -188,14 +188,6 @@ public static <T, U> Function<T, Publisher<U>> flatMapIntoIterable(final Functio\n         return new FlatMapIntoIterable<T, U>(mapper);\n     }\n \n-    enum MapToInt implements Function<Object, Object> {\n-        INSTANCE;\n-        @Override\n-        public Object apply(Object t) throws Exception {\n-            return 0;\n-        }\n-    }\n-\n     public static <T> Callable<ConnectableFlowable<T>> replayCallable(final Flowable<T> parent) {\n         return new Callable<ConnectableFlowable<T>>() {\n             @Override\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java\n@@ -53,8 +53,6 @@ static final class EqualCoordinator<T> extends DeferredScalarSubscription<Boolea\n \n         final BiPredicate<? super T, ? super T> comparer;\n \n-        final int prefetch;\n-\n         final EqualSubscriber<T> first;\n \n         final EqualSubscriber<T> second;\n@@ -69,7 +67,6 @@ static final class EqualCoordinator<T> extends DeferredScalarSubscription<Boolea\n \n         EqualCoordinator(Subscriber<? super Boolean> actual, int prefetch, BiPredicate<? super T, ? super T> comparer) {\n             super(actual);\n-            this.prefetch = prefetch;\n             this.comparer = comparer;\n             this.wip = new AtomicInteger();\n             this.first = new EqualSubscriber<T>(this, prefetch);\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java\n@@ -25,11 +25,6 @@\n public final class FlowableToList<T, U extends Collection<? super T>> extends AbstractFlowableWithUpstream<T, U> {\n     final Callable<U> collectionSupplier;\n \n-    @SuppressWarnings(\"unchecked\")\n-    public FlowableToList(Publisher<T> source) {\n-        this(source, (Callable<U>)ArrayListSupplier.asCallable());\n-    }\n-\n     public FlowableToList(Publisher<T> source, Callable<U> collectionSupplier) {\n         super(source);\n         this.collectionSupplier = collectionSupplier;\n\ndiff --git a/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java b/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java\n--- a/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java\n+++ b/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java\n@@ -98,14 +98,6 @@ public void setFuture(Future<?> f) {\n         }\n     }\n \n-    /**\n-     * Returns true if this ScheduledRunnable has been scheduled.\n-     * @return true if this ScheduledRunnable has been scheduled.\n-     */\n-    public boolean wasScheduled() {\n-        return get(FUTURE_INDEX) != null;\n-    }\n-\n     @Override\n     public void dispose() {\n         for (;;) {\n\ndiff --git a/src/main/java/io/reactivex/internal/subscribers/SubscriberResourceWrapper.java b/src/main/java/io/reactivex/internal/subscribers/SubscriberResourceWrapper.java\n--- a/src/main/java/io/reactivex/internal/subscribers/SubscriberResourceWrapper.java\n+++ b/src/main/java/io/reactivex/internal/subscribers/SubscriberResourceWrapper.java\n@@ -29,8 +29,6 @@ public final class SubscriberResourceWrapper<T> extends AtomicReference<Disposab\n \n     final AtomicReference<Subscription> subscription = new AtomicReference<Subscription>();\n \n-    static final Object TERMINATED = new Object();\n-\n     public SubscriberResourceWrapper(Subscriber<? super T> actual) {\n         this.actual = actual;\n     }",
    "output": "Remove some dead code"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/maybe/MaybeTest.java b/src/test/java/io/reactivex/maybe/MaybeTest.java\n--- a/src/test/java/io/reactivex/maybe/MaybeTest.java\n+++ b/src/test/java/io/reactivex/maybe/MaybeTest.java\n@@ -3045,4 +3045,83 @@ public Publisher<Object> apply(Flowable<? extends Throwable> v) throws Exception\n             }\n         }).test().assertResult(1);\n     }\n+\n+    @Test\n+    public void onErrorResumeNextEmpty() {\n+        Maybe.empty()\n+            .onErrorResumeNext(Maybe.just(1))\n+            .test()\n+            .assertNoValues()\n+            .assertNoErrors()\n+            .assertComplete();\n+    }\n+\n+    @Test\n+    public void onErrorResumeNextValue() {\n+        Maybe.just(1)\n+            .onErrorResumeNext(Maybe.<Integer>empty())\n+            .test()\n+            .assertNoErrors()\n+            .assertValue(1);\n+    }\n+\n+    @Test\n+    public void onErrorResumeNextError() {\n+        Maybe.error(new RuntimeException(\"some error\"))\n+            .onErrorResumeNext(Maybe.empty())\n+            .test()\n+            .assertNoValues()\n+            .assertNoErrors()\n+            .assertComplete();\n+    }\n+\n+    @Test\n+    public void valueConcatWithValue() {\n+        Maybe.just(1)\n+            .concatWith(Maybe.just(2))\n+            .test()\n+            .assertNoErrors()\n+            .assertComplete()\n+            .assertValues(1, 2);\n+    }\n+\n+    @Test\n+    public void errorConcatWithValue() {\n+        Maybe.<Integer>error(new RuntimeException(\"error\"))\n+            .concatWith(Maybe.just(2))\n+            .test()\n+            .assertError(RuntimeException.class)\n+            .assertErrorMessage(\"error\")\n+            .assertNoValues();\n+    }\n+\n+    @Test\n+    public void valueConcatWithError() {\n+        Maybe.just(1)\n+            .concatWith(Maybe.<Integer>error(new RuntimeException(\"error\")))\n+            .test()\n+            .assertValue(1)\n+            .assertError(RuntimeException.class)\n+            .assertErrorMessage(\"error\");\n+    }\n+\n+    @Test\n+    public void emptyConcatWithValue() {\n+        Maybe.<Integer>empty()\n+            .concatWith(Maybe.just(2))\n+            .test()\n+            .assertNoErrors()\n+            .assertComplete()\n+            .assertValues(2);\n+    }\n+\n+    @Test\n+    public void emptyConcatWithError() {\n+        Maybe.<Integer>empty()\n+            .concatWith(Maybe.<Integer>error(new RuntimeException(\"error\")))\n+            .test()\n+            .assertNoValues()\n+            .assertError(RuntimeException.class)\n+            .assertErrorMessage(\"error\");\n+    }\n }",
    "output": "Add missing Maybe tests for concatWith & onErrorResumeNext"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableSubscribeOn.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableSubscribeOn.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableSubscribeOn.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSubscribeOn.java\n@@ -22,7 +22,7 @@\n public final class ObservableSubscribeOn<T> extends AbstractObservableWithUpstream<T, T> {\n     final Scheduler scheduler;\n \n-    public ObservableSubscribeOn(Observable<T> source, Scheduler scheduler) {\n+    public ObservableSubscribeOn(ObservableSource<T> source, Scheduler scheduler) {\n         super(source);\n         this.scheduler = scheduler;\n     }",
    "output": "Fix wrong upstream type"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/maybe/MaybeTest.java b/src/test/java/io/reactivex/maybe/MaybeTest.java\n--- a/src/test/java/io/reactivex/maybe/MaybeTest.java\n+++ b/src/test/java/io/reactivex/maybe/MaybeTest.java\n@@ -1700,6 +1700,30 @@ public void ambIterable2SignalsSuccess() {\n         ts.assertResult(2);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void ambIterable2SignalsSuccessWithOverlap() {\n+        PublishProcessor<Integer> pp1 = PublishProcessor.create();\n+        PublishProcessor<Integer> pp2 = PublishProcessor.create();\n+\n+        TestSubscriber<Integer> ts = Maybe.amb(Arrays.asList(pp1.toMaybe(), pp2.toMaybe()))\n+                .test();\n+\n+        ts.assertEmpty();\n+\n+        assertTrue(pp1.hasSubscribers());\n+        assertTrue(pp2.hasSubscribers());\n+\n+        pp2.onNext(2);\n+        pp1.onNext(1);\n+        pp2.onComplete();\n+\n+        assertFalse(pp1.hasSubscribers());\n+        assertFalse(pp2.hasSubscribers());\n+\n+        ts.assertResult(2);\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     @Test\n     public void ambIterable1SignalsError() {\n@@ -1744,6 +1768,29 @@ public void ambIterable2SignalsError() {\n         ts.assertFailure(TestException.class);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void ambIterable2SignalsErrorWithOverlap() {\n+        PublishProcessor<Integer> pp1 = PublishProcessor.create();\n+        PublishProcessor<Integer> pp2 = PublishProcessor.create();\n+\n+        TestSubscriber<Integer> ts = Maybe.amb(Arrays.asList(pp1.toMaybe(), pp2.toMaybe()))\n+                .test();\n+\n+        ts.assertEmpty();\n+\n+        assertTrue(pp1.hasSubscribers());\n+        assertTrue(pp2.hasSubscribers());\n+\n+        pp2.onError(new TestException(\"2\"));\n+        pp1.onError(new TestException(\"1\"));\n+\n+        assertFalse(pp1.hasSubscribers());\n+        assertFalse(pp2.hasSubscribers());\n+\n+        ts.assertFailureAndMessage(TestException.class, \"2\");\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     @Test\n     public void ambIterable1SignalsComplete() {",
    "output": "Add extra Maybe iterable Amb tests for overlapped emissions\n\n- Asserting that downstream will get the results of the first source that began emission, even if multiple sources have overlapped emissions\r\n- Testing Success and Error paths"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeUnsubscribeOnTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeUnsubscribeOnTest.java\n--- a/src/test/java/io/reactivex/internal/operators/maybe/MaybeUnsubscribeOnTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeUnsubscribeOnTest.java\n@@ -47,6 +47,12 @@ public void run() throws Exception {\n \n         assertTrue(cdl.await(5, TimeUnit.SECONDS));\n \n+        int times = 10;\n+\n+        while (times-- > 0 && pp.hasSubscribers()) {\n+            Thread.sleep(100);\n+        }\n+\n         assertFalse(pp.hasSubscribers());\n \n         assertNotEquals(Thread.currentThread().getName(), name[0]);",
    "output": "Fix flaky MaybeUnbsubscribeOnTest.normal"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java\n@@ -21,7 +21,6 @@\n \n import io.reactivex.exceptions.Exceptions;\n import io.reactivex.functions.BooleanSupplier;\n-import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.subscriptions.SubscriptionHelper;\n import io.reactivex.internal.util.*;\n import io.reactivex.plugins.RxJavaPlugins;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java\n@@ -142,7 +142,7 @@ public void subscribeActual(Subscriber<? super R> s) {\n             new FlowableMap<T, R>((Publisher<T>)a[0], new Function<T, R>() {\n                 @Override\n                 public R apply(T t) throws Exception {\n-                    return combiner.apply((T[])new Object[] { t });\n+                    return combiner.apply(new Object[] { t });\n                 }\n             }).subscribe(s);\n             return;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java\n@@ -19,7 +19,6 @@\n \n import io.reactivex.exceptions.Exceptions;\n import io.reactivex.functions.Function;\n-import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.fuseable.*;\n import io.reactivex.internal.queue.SpscArrayQueue;\n import io.reactivex.internal.subscriptions.*;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java\n@@ -21,7 +21,6 @@\n \n import io.reactivex.exceptions.*;\n import io.reactivex.functions.Function;\n-import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.fuseable.*;\n import io.reactivex.internal.queue.SpscArrayQueue;\n import io.reactivex.internal.subscriptions.*;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java\n@@ -20,7 +20,6 @@\n import io.reactivex.Scheduler;\n import io.reactivex.Scheduler.Worker;\n import io.reactivex.exceptions.*;\n-import io.reactivex.internal.functions.ObjectHelper;\n import io.reactivex.internal.fuseable.*;\n import io.reactivex.internal.queue.SpscArrayQueue;\n import io.reactivex.internal.subscriptions.*;\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipArray.java b/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipArray.java\n--- a/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipArray.java\n+++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipArray.java\n@@ -42,10 +42,9 @@ protected void subscribeActual(MaybeObserver<? super R> observer) {\n \n         if (n == 1) {\n             sources[0].subscribe(new MaybeMap.MapMaybeObserver<T, R>(observer, new Function<T, R>() {\n-                @SuppressWarnings(\"unchecked\")\n                 @Override\n                 public R apply(T t) throws Exception {\n-                    return zipper.apply((T[])new Object[] { t });\n+                    return zipper.apply(new Object[] { t });\n                 }\n             }));\n             return;\n@@ -104,14 +103,13 @@ public void dispose() {\n             }\n         }\n \n-        @SuppressWarnings(\"unchecked\")\n         void innerSuccess(T value, int index) {\n             values[index] = value;\n             if (decrementAndGet() == 0) {\n                 R v;\n \n                 try {\n-                    v = ObjectHelper.requireNonNull(zipper.apply((T[])values), \"The zipper returned a null value\");\n+                    v = ObjectHelper.requireNonNull(zipper.apply(values), \"The zipper returned a null value\");\n                 } catch (Throwable ex) {\n                     Exceptions.throwIfFatal(ex);\n                     actual.onError(ex);\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipIterable.java b/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipIterable.java\n--- a/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipIterable.java\n+++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipIterable.java\n@@ -58,10 +58,9 @@ protected void subscribeActual(MaybeObserver<? super R> observer) {\n \n         if (n == 1) {\n             a[0].subscribe(new MaybeMap.MapMaybeObserver<T, R>(observer, new Function<T, R>() {\n-                @SuppressWarnings(\"unchecked\")\n                 @Override\n                 public R apply(T t) throws Exception {\n-                    return zipper.apply((T[])new Object[] { t });\n+                    return zipper.apply(new Object[] { t });\n                 }\n             }));\n             return;\n\ndiff --git a/src/test/java/io/reactivex/flowable/FlowableTests.java b/src/test/java/io/reactivex/flowable/FlowableTests.java\n--- a/src/test/java/io/reactivex/flowable/FlowableTests.java\n+++ b/src/test/java/io/reactivex/flowable/FlowableTests.java\n@@ -1063,6 +1063,7 @@ public void toObservableError() {\n \n     @Test\n     public void zipIterableObject() {\n+        @SuppressWarnings(\"unchecked\")\n         final List<Flowable<Integer>> flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3));\n         Flowable.zip(flowables, new Function<Object[], Object>() {\n             @Override\n@@ -1078,6 +1079,7 @@ public Object apply(Object[] o) throws Exception {\n \n     @Test\n     public void combineLatestObject() {\n+        @SuppressWarnings(\"unchecked\")\n         final List<Flowable<Integer>> flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3));\n         Flowable.combineLatest(flowables, new Function<Object[], Object>() {\n             @Override\n\ndiff --git a/src/test/java/io/reactivex/maybe/MaybeTest.java b/src/test/java/io/reactivex/maybe/MaybeTest.java\n--- a/src/test/java/io/reactivex/maybe/MaybeTest.java\n+++ b/src/test/java/io/reactivex/maybe/MaybeTest.java\n@@ -2860,6 +2860,7 @@ public void ambWith2SignalsSuccess() {\n \n     @Test\n     public void zipIterableObject() {\n+        @SuppressWarnings(\"unchecked\")\n         final List<Maybe<Integer>> maybes = Arrays.asList(Maybe.just(1), Maybe.just(4));\n         Maybe.zip(maybes, new Function<Object[], Object>() {\n             @Override\n\ndiff --git a/src/test/java/io/reactivex/observable/ObservableTest.java b/src/test/java/io/reactivex/observable/ObservableTest.java\n--- a/src/test/java/io/reactivex/observable/ObservableTest.java\n+++ b/src/test/java/io/reactivex/observable/ObservableTest.java\n@@ -1059,6 +1059,7 @@ public void singleDefault() {\n \n     @Test\n     public void zipIterableObject() {\n+        @SuppressWarnings(\"unchecked\")\n         final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3));\n         Observable.zip(observables, new Function<Object[], Object>() {\n             @Override\n@@ -1074,6 +1075,7 @@ public Object apply(Object[] o) throws Exception {\n \n     @Test\n     public void combineLatestObject() {\n+        @SuppressWarnings(\"unchecked\")\n         final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3));\n         Observable.combineLatest(observables, new Function<Object[], Object>() {\n             @Override\n\ndiff --git a/src/test/java/io/reactivex/single/SingleTest.java b/src/test/java/io/reactivex/single/SingleTest.java\n--- a/src/test/java/io/reactivex/single/SingleTest.java\n+++ b/src/test/java/io/reactivex/single/SingleTest.java\n@@ -518,6 +518,7 @@ public void toFlowableIterableRemove() {\n \n     @Test\n     public void zipIterableObject() {\n+        @SuppressWarnings(\"unchecked\")\n         final List<Single<Integer>> singles = Arrays.asList(Single.just(1), Single.just(4));\n         Single.zip(singles, new Function<Object[], Object>() {\n             @Override",
    "output": "Fix compile warnings"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java\n--- a/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java\n@@ -41,7 +41,7 @@ public void testOnErrorCalledOnScheduler() throws Exception {\n         final CountDownLatch latch = new CountDownLatch(1);\n         final AtomicReference<Thread> thread = new AtomicReference<Thread>();\n \n-        Completable.<String>error(new Exception())\n+        Completable.error(new Exception())\n                 .delay(0, TimeUnit.MILLISECONDS, Schedulers.newThread())\n                 .doOnError(new Consumer<Throwable>() {\n                     @Override",
    "output": "Fix compilation error in Eclipse"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java\n@@ -175,6 +175,7 @@ public void request(long n) {\n         public void cancel() {\n             if (!cancelled) {\n                 cancelled = true;\n+                s.cancel();\n \n                 disposeInner();\n             }\n@@ -186,7 +187,7 @@ void disposeInner() {\n             if (a != CANCELLED) {\n                 a = active.getAndSet((SwitchMapInnerSubscriber<T, R>)CANCELLED);\n                 if (a != CANCELLED && a != null) {\n-                    s.cancel();\n+                    a.cancel();\n                 }\n             }\n         }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java\n@@ -160,7 +160,7 @@ public void onComplete() {\n         public void dispose() {\n             if (!cancelled) {\n                 cancelled = true;\n-\n+                s.dispose();\n                 disposeInner();\n             }\n         }\n@@ -176,7 +176,7 @@ void disposeInner() {\n             if (a != CANCELLED) {\n                 a = active.getAndSet((SwitchMapInnerSubscriber<T, R>)CANCELLED);\n                 if (a != CANCELLED && a != null) {\n-                    s.dispose();\n+                    a.cancel();\n                 }\n             }\n         }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java\n@@ -797,4 +797,18 @@ public Publisher<Integer> apply(Object v) throws Exception {\n \n     }\n \n+    @Test\n+    public void switchMapInnerCancelled() {\n+        PublishProcessor<Integer> pp = PublishProcessor.create();\n+\n+        TestSubscriber<Integer> ts = Flowable.just(1)\n+                .switchMap(Functions.justFunction(pp))\n+                .test();\n+\n+        assertTrue(pp.hasSubscribers());\n+\n+        ts.cancel();\n+\n+        assertFalse(pp.hasSubscribers());\n+    }\n }\n\\ No newline at end of file\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java\n@@ -607,4 +607,20 @@ public ObservableSource<Integer> apply(Object v) throws Exception {\n \n     }\n \n+\n+    @Test\n+    public void switchMapInnerCancelled() {\n+        PublishSubject<Integer> pp = PublishSubject.create();\n+\n+        TestObserver<Integer> ts = Observable.just(1)\n+                .switchMap(Functions.justFunction(pp))\n+                .test();\n+\n+        assertTrue(pp.hasObservers());\n+\n+        ts.cancel();\n+\n+        assertFalse(pp.hasObservers());\n+    }\n+\n }",
    "output": "Fix switchMap bad cancellation"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java b/src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java\n--- a/src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java\n+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java\n@@ -36,7 +36,7 @@ protected void subscribeActual(SingleObserver<? super T> s) {\n             if (v != null) {\n                 s.onSuccess(v);\n             } else {\n-                s.onError(new NullPointerException());\n+                s.onError(new NullPointerException(\"The callable returned a null value\"));\n             }\n         } catch (Throwable e) {\n             Exceptions.throwIfFatal(e);",
    "output": "Add exception message in SingleFromCallable"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java\n@@ -33,33 +33,35 @@\n public final class FlowableRefCount<T> extends AbstractFlowableWithUpstream<T, T> {\n     final ConnectableFlowable<? extends T> source;\n     volatile CompositeDisposable baseSubscription = new CompositeDisposable();\n-    final AtomicInteger subscriptionCount = new AtomicInteger(0);\n+    final AtomicInteger subscriptionCount = new AtomicInteger();\n \n     /**\n      * Use this lock for every subscription and disconnect action.\n      */\n     final ReentrantLock lock = new ReentrantLock();\n \n-    final class ConnectionSubscriber implements Subscriber<T>, Subscription {\n+    final class ConnectionSubscriber\n+    extends AtomicReference<Subscription>\n+    implements Subscriber<T>, Subscription {\n+        /** */\n+        private static final long serialVersionUID = 152064694420235350L;\n         final Subscriber<? super T> subscriber;\n         final CompositeDisposable currentBase;\n         final Disposable resource;\n \n-        Subscription s;\n+        final AtomicLong requested;\n \n         ConnectionSubscriber(Subscriber<? super T> subscriber,\n                 CompositeDisposable currentBase, Disposable resource) {\n             this.subscriber = subscriber;\n             this.currentBase = currentBase;\n             this.resource = resource;\n+            this.requested = new AtomicLong();\n         }\n \n         @Override\n         public void onSubscribe(Subscription s) {\n-            if (SubscriptionHelper.validate(this.s, s)) {\n-                this.s = s;\n-                subscriber.onSubscribe(this);\n-            }\n+            SubscriptionHelper.deferredSetOnce(this, requested, s);\n         }\n \n         @Override\n@@ -81,12 +83,12 @@ public void onComplete() {\n \n         @Override\n         public void request(long n) {\n-            s.request(n);\n+            SubscriptionHelper.deferredRequest(this, requested, n);\n         }\n \n         @Override\n         public void cancel() {\n-            s.cancel();\n+            SubscriptionHelper.cancel(this);\n             resource.dispose();\n         }\n \n@@ -173,9 +175,10 @@ void doSubscribe(final Subscriber<? super T> subscriber, final CompositeDisposab\n         // handle unsubscribing from the base subscription\n         Disposable d = disconnect(currentBase);\n \n-        ConnectionSubscriber s = new ConnectionSubscriber(subscriber, currentBase, d);\n+        ConnectionSubscriber connection = new ConnectionSubscriber(subscriber, currentBase, d);\n+        subscriber.onSubscribe(connection);\n \n-        source.subscribe(s);\n+        source.subscribe(connection);\n     }\n \n     private Disposable disconnect(final CompositeDisposable current) {\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java\n@@ -87,15 +87,15 @@ public void subscribeActual(final Observer<? super T> subscriber) {\n \n     }\n \n-    private Consumer<Disposable> onSubscribe(final Observer<? super T> subscriber,\n+    private Consumer<Disposable> onSubscribe(final Observer<? super T> observer,\n             final AtomicBoolean writeLocked) {\n         return  new Consumer<Disposable>() {\n             @Override\n             public void accept(Disposable subscription) {\n                 try {\n                     baseSubscription.add(subscription);\n                     // ready to subscribe to source so do it\n-                    doSubscribe(subscriber, baseSubscription);\n+                    doSubscribe(observer, baseSubscription);\n                 } finally {\n                     // release the write lock\n                     lock.unlock();\n@@ -105,11 +105,12 @@ public void accept(Disposable subscription) {\n         };\n     }\n \n-    void doSubscribe(final Observer<? super T> subscriber, final CompositeDisposable currentBase) {\n+    void doSubscribe(final Observer<? super T> observer, final CompositeDisposable currentBase) {\n         // handle unsubscribing from the base subscription\n         Disposable d = disconnect(currentBase);\n \n-        ConnectionSubscriber s = new ConnectionSubscriber(subscriber, currentBase, d);\n+        ConnectionSubscriber s = new ConnectionSubscriber(observer, currentBase, d);\n+        observer.onSubscribe(s);\n \n         source.subscribe(s);\n     }\n@@ -135,13 +136,16 @@ public void run() {\n         });\n     }\n \n-    final class ConnectionSubscriber implements Observer<T>, Disposable {\n+    final class ConnectionSubscriber\n+    extends AtomicReference<Disposable>\n+    implements Observer<T>, Disposable {\n+        /** */\n+        private static final long serialVersionUID = 3813126992133394324L;\n+\n         final Observer<? super T> subscriber;\n         final CompositeDisposable currentBase;\n         final Disposable resource;\n \n-        Disposable s;\n-\n         ConnectionSubscriber(Observer<? super T> subscriber,\n                 CompositeDisposable currentBase, Disposable resource) {\n             this.subscriber = subscriber;\n@@ -151,10 +155,7 @@ final class ConnectionSubscriber implements Observer<T>, Disposable {\n \n         @Override\n         public void onSubscribe(Disposable s) {\n-            if (DisposableHelper.validate(this.s, s)) {\n-                this.s = s;\n-                subscriber.onSubscribe(this);\n-            }\n+            DisposableHelper.setOnce(this, s);\n         }\n \n         @Override\n@@ -176,13 +177,13 @@ public void onComplete() {\n \n         @Override\n         public void dispose() {\n-            s.dispose();\n+            DisposableHelper.dispose(this);\n             resource.dispose();\n         }\n \n         @Override\n         public boolean isDisposed() {\n-            return s.isDisposed();\n+            return DisposableHelper.isDisposed(get());\n         }\n \n         void cleanup() {\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java\n@@ -132,7 +132,7 @@ public void accept(Integer t1) {\n                         if (count.incrementAndGet() == 500000) {\n                             // give it a small break halfway through\n                             try {\n-                                Thread.sleep(1);\n+                                Thread.sleep(5);\n                             } catch (InterruptedException ex) {\n                                 // ignored\n                             }",
    "output": "Fix operator RefCount, disable FindBugs (due to Travis OOM)"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java\n@@ -103,27 +103,28 @@ public void onNext(T t) {\n                 return;\n             }\n             boolean callOnOverflow = false;\n+            boolean callError = false;\n             Deque<T> dq = deque;\n             synchronized (dq) {\n                if (dq.size() == bufferSize) {\n                    switch (strategy) {\n                    case DROP_LATEST:\n-                       dq.poll();\n+                       dq.pollLast();\n                        dq.offer(t);\n                        callOnOverflow = true;\n                        break;\n                    case DROP_OLDEST:\n-                       dq.pollLast();\n+                       dq.poll();\n                        dq.offer(t);\n                        callOnOverflow = true;\n                        break;\n                    default:\n                        // signal error\n+                       callError = true;\n                        break;\n                    }\n                } else {\n                    dq.offer(t);\n-                   return;\n                }\n             }\n \n@@ -137,9 +138,11 @@ public void onNext(T t) {\n                         onError(ex);\n                     }\n                 }\n-            } else {\n+            } else if(callError) {\n                 s.cancel();\n                 onError(new MissingBackpressureException());\n+            } else {\n+                drain();\n             }\n         }\n         \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java\n@@ -0,0 +1,130 @@\n+/**\n+ * Copyright 2016 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.flowable;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.functions.Action;\n+import io.reactivex.internal.subscriptions.BooleanSubscription;\n+import io.reactivex.subscribers.DefaultSubscriber;\n+import io.reactivex.subscribers.TestSubscriber;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static io.reactivex.BackpressureOverflowStrategy.DROP_LATEST;\n+import static io.reactivex.BackpressureOverflowStrategy.DROP_OLDEST;\n+import static io.reactivex.internal.functions.Functions.EMPTY_ACTION;\n+import static org.junit.Assert.assertEquals;\n+\n+public class FlowableOnBackpressureBufferStrategyTest {\n+\n+    @Test(timeout = 2000)\n+    public void backpressureWithBufferDropOldest() throws InterruptedException {\n+        int bufferSize = 3;\n+        final AtomicInteger droppedCount = new AtomicInteger(0);\n+        Action incrementOnDrop = new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                droppedCount.incrementAndGet();\n+            }\n+        };\n+        TestSubscriber<Long> ts = createTestSubscriber();\n+        Flowable.fromPublisher(send500ValuesAndComplete.onBackpressureBuffer(bufferSize, incrementOnDrop, DROP_OLDEST))\n+                .subscribe(ts);\n+        // we request 10 but only 3 should come from the buffer\n+        ts.request(10);\n+        ts.awaitTerminalEvent();\n+        assertEquals(bufferSize, ts.values().size());\n+        ts.assertNoErrors();\n+        assertEquals(497, ts.values().get(0).intValue());\n+        assertEquals(498, ts.values().get(1).intValue());\n+        assertEquals(499, ts.values().get(2).intValue());\n+        assertEquals(droppedCount.get(), 500 - bufferSize);\n+    }\n+\n+    private TestSubscriber<Long> createTestSubscriber() {\n+        return new TestSubscriber<Long>(new DefaultSubscriber<Long>() {\n+\n+            @Override\n+            protected void onStart() {\n+            }\n+\n+            @Override\n+            public void onComplete() {\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+            }\n+\n+            @Override\n+            public void onNext(Long t) {\n+            }\n+\n+        }, 0L);\n+    }\n+\n+    @Test(timeout = 2000)\n+    public void backpressureWithBufferDropLatest() throws InterruptedException {\n+        int bufferSize = 3;\n+        final AtomicInteger droppedCount = new AtomicInteger(0);\n+        Action incrementOnDrop = new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                droppedCount.incrementAndGet();\n+            }\n+        };\n+        TestSubscriber<Long> ts = createTestSubscriber();\n+        Flowable.fromPublisher(send500ValuesAndComplete.onBackpressureBuffer(bufferSize, incrementOnDrop, DROP_LATEST))\n+                .subscribe(ts);\n+        // we request 10 but only 3 should come from the buffer\n+        ts.request(10);\n+        ts.awaitTerminalEvent();\n+        assertEquals(bufferSize, ts.values().size());\n+        ts.assertNoErrors();\n+        assertEquals(0, ts.values().get(0).intValue());\n+        assertEquals(1, ts.values().get(1).intValue());\n+        assertEquals(499, ts.values().get(2).intValue());\n+        assertEquals(droppedCount.get(), 500 - bufferSize);\n+    }\n+\n+    private static final Flowable<Long> send500ValuesAndComplete = Flowable.unsafeCreate(new Publisher<Long>() {\n+        @Override\n+        public void subscribe(Subscriber<? super Long> s) {\n+            BooleanSubscription bs = new BooleanSubscription();\n+            s.onSubscribe(bs);\n+            long i = 0;\n+            while (!bs.isCancelled() && i < 500) {\n+                s.onNext(i++);\n+            }\n+            if(!bs.isCancelled()){\n+                s.onComplete();\n+            }\n+        }\n+    });\n+\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void backpressureBufferNegativeCapacity() throws InterruptedException {\n+        Flowable.empty().onBackpressureBuffer(-1, EMPTY_ACTION , DROP_OLDEST);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void backpressureBufferZeroCapacity() throws InterruptedException {\n+        Flowable.empty().onBackpressureBuffer(0, EMPTY_ACTION , DROP_OLDEST);\n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Fix FlowableOnBackpressureBufferStrategy\n\n* Fix buffered objects not propagated downstream in FlowableOnBackpressureBufferStrategy\r\nFix drop strategy logic in FlowableOnBackpressureBufferStrategy\r\nAdd unit test for FlowableOnBackpressureBufferStrategy, copied from FlowableOnBackpressureBufferTest, there is still some work needed to have a better coverage\r\n\r\n* Fix FlowableOnBackpressureBufferStrategy\r\n\r\nMove the call to drain out of the synchronized block\r\nCleaned up unit tests to follow recommendations from akarnokd"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java\n@@ -103,6 +103,7 @@ public void onNext(T t) {\n                 return;\n             }\n             boolean callOnOverflow = false;\n+            boolean callError = false;\n             Deque<T> dq = deque;\n             synchronized (dq) {\n                if (dq.size() == bufferSize) {\n@@ -119,12 +120,11 @@ public void onNext(T t) {\n                        break;\n                    default:\n                        // signal error\n+                       callError = true;\n                        break;\n                    }\n                } else {\n                    dq.offer(t);\n-                   drain();\n-                   return;\n                }\n             }\n \n@@ -138,9 +138,11 @@ public void onNext(T t) {\n                         onError(ex);\n                     }\n                 }\n-            } else {\n+            } else if(callError) {\n                 s.cancel();\n                 onError(new MissingBackpressureException());\n+            } else {\n+                drain();\n             }\n         }\n         \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java\n@@ -1,62 +1,67 @@\n /**\n  * Copyright 2016 Netflix, Inc.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n  * compliance with the License. You may obtain a copy of the License at\n- * \n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software distributed under the License is\n  * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n  * the License for the specific language governing permissions and limitations under the License.\n  */\n \n package io.reactivex.internal.operators.flowable;\n \n-import static io.reactivex.BackpressureOverflowStrategy.DROP_OLDEST;\n-import static org.junit.Assert.assertEquals;\n-\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.junit.Test;\n-\n import io.reactivex.Flowable;\n import io.reactivex.functions.Action;\n import io.reactivex.internal.subscriptions.BooleanSubscription;\n-import io.reactivex.schedulers.Schedulers;\n import io.reactivex.subscribers.DefaultSubscriber;\n import io.reactivex.subscribers.TestSubscriber;\n+import org.junit.Test;\n import org.reactivestreams.Publisher;\n import org.reactivestreams.Subscriber;\n \n-public class FlowableOnBackpressureBufferStrategyTest {\n+import java.util.concurrent.atomic.AtomicInteger;\n \n-    private static Action onOverFlow = new Action() {\n-        @Override\n-        public void run() throws Exception {\n-            // Nothing\n-        }\n-    };\n+import static io.reactivex.BackpressureOverflowStrategy.DROP_LATEST;\n+import static io.reactivex.BackpressureOverflowStrategy.DROP_OLDEST;\n+import static io.reactivex.internal.functions.Functions.EMPTY_ACTION;\n+import static org.junit.Assert.assertEquals;\n \n+public class FlowableOnBackpressureBufferStrategyTest {\n \n     @Test(timeout = 2000)\n-    public void testFixBackpressureWithBuffer() throws InterruptedException {\n-        final CountDownLatch l1 = new CountDownLatch(100);\n-        final CountDownLatch l2 = new CountDownLatch(150);\n+    public void backpressureWithBufferDropOldest() throws InterruptedException {\n+        int bufferSize = 3;\n         final AtomicInteger droppedCount = new AtomicInteger(0);\n         Action incrementOnDrop = new Action() {\n             @Override\n             public void run() throws Exception {\n                 droppedCount.incrementAndGet();\n             }\n         };\n-        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() {\n+        TestSubscriber<Long> ts = createTestSubscriber();\n+        Flowable.fromPublisher(send500ValuesAndComplete.onBackpressureBuffer(bufferSize, incrementOnDrop, DROP_OLDEST))\n+                .subscribe(ts);\n+        // we request 10 but only 3 should come from the buffer\n+        ts.request(10);\n+        ts.awaitTerminalEvent();\n+        assertEquals(bufferSize, ts.values().size());\n+        ts.assertNoErrors();\n+        assertEquals(497, ts.values().get(0).intValue());\n+        assertEquals(498, ts.values().get(1).intValue());\n+        assertEquals(499, ts.values().get(2).intValue());\n+        assertEquals(droppedCount.get(), 500 - bufferSize);\n+    }\n+\n+    private TestSubscriber<Long> createTestSubscriber() {\n+        return new TestSubscriber<Long>(new DefaultSubscriber<Long>() {\n \n             @Override\n             protected void onStart() {\n             }\n-            \n+\n             @Override\n             public void onComplete() {\n             }\n@@ -67,67 +72,59 @@ public void onError(Throwable e) {\n \n             @Override\n             public void onNext(Long t) {\n-                l1.countDown();\n-                l2.countDown();\n             }\n \n         }, 0L);\n-        // this will be ignored\n-        ts.request(100);\n-        // we take 500 so it unsubscribes\n-        Flowable.fromPublisher(infinite.subscribeOn(Schedulers.computation())\n-        .onBackpressureBuffer(1, incrementOnDrop , DROP_OLDEST))\n-        .take(500)\n-        .subscribe(ts);\n-        \n-        // it completely ignores the `request(100)` and we get 500\n-        l1.await();\n-        assertEquals(100, ts.values().size());\n-        ts.request(50);\n-        l2.await();\n-        assertEquals(150, ts.values().size());\n-        ts.request(350);\n+    }\n+\n+    @Test(timeout = 2000)\n+    public void backpressureWithBufferDropLatest() throws InterruptedException {\n+        int bufferSize = 3;\n+        final AtomicInteger droppedCount = new AtomicInteger(0);\n+        Action incrementOnDrop = new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                droppedCount.incrementAndGet();\n+            }\n+        };\n+        TestSubscriber<Long> ts = createTestSubscriber();\n+        Flowable.fromPublisher(send500ValuesAndComplete.onBackpressureBuffer(bufferSize, incrementOnDrop, DROP_LATEST))\n+                .subscribe(ts);\n+        // we request 10 but only 3 should come from the buffer\n+        ts.request(10);\n         ts.awaitTerminalEvent();\n-        assertEquals(500, ts.values().size());\n+        assertEquals(bufferSize, ts.values().size());\n         ts.assertNoErrors();\n         assertEquals(0, ts.values().get(0).intValue());\n-        assertEquals(499 + droppedCount.get(), ts.values().get(499).intValue());\n+        assertEquals(1, ts.values().get(1).intValue());\n+        assertEquals(499, ts.values().get(2).intValue());\n+        assertEquals(droppedCount.get(), 500 - bufferSize);\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n-    public void testFixBackpressureBufferNegativeCapacity() throws InterruptedException {\n-        Flowable.empty().onBackpressureBuffer(-1, onOverFlow , DROP_OLDEST);\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n-    public void testFixBackpressureBufferZeroCapacity() throws InterruptedException {\n-        Flowable.empty().onBackpressureBuffer(0, onOverFlow , DROP_OLDEST);\n-    }\n-\n-\n-    static final Flowable<Long> infinite = Flowable.unsafeCreate(new Publisher<Long>() {\n-\n+    private static final Flowable<Long> send500ValuesAndComplete = Flowable.unsafeCreate(new Publisher<Long>() {\n         @Override\n         public void subscribe(Subscriber<? super Long> s) {\n             BooleanSubscription bs = new BooleanSubscription();\n             s.onSubscribe(bs);\n             long i = 0;\n-            while (!bs.isCancelled()) {\n+            while (!bs.isCancelled() && i < 500) {\n                 s.onNext(i++);\n             }\n+            if(!bs.isCancelled()){\n+                s.onComplete();\n+            }\n         }\n-\n     });\n \n \n     @Test(expected = IllegalArgumentException.class)\n-    public void fixBackpressureBufferNegativeCapacity() throws InterruptedException {\n-        Flowable.empty().onBackpressureBuffer(-1, onOverFlow , DROP_OLDEST);\n+    public void backpressureBufferNegativeCapacity() throws InterruptedException {\n+        Flowable.empty().onBackpressureBuffer(-1, EMPTY_ACTION , DROP_OLDEST);\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void fixBackpressureBufferZeroCapacity() throws InterruptedException {\n-        Flowable.empty().onBackpressureBuffer(0, onOverFlow , DROP_OLDEST);\n+    public void backpressureBufferZeroCapacity() throws InterruptedException {\n+        Flowable.empty().onBackpressureBuffer(0, EMPTY_ACTION , DROP_OLDEST);\n     }\n \n }\n\\ No newline at end of file",
    "output": "Fix FlowableOnBackpressureBufferStrategy\n\nMove the call to drain out of the synchronized block\nCleaned up unit tests to follow recommendations from akarnokd"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java\n@@ -108,12 +108,12 @@ public void onNext(T t) {\n                if (dq.size() == bufferSize) {\n                    switch (strategy) {\n                    case DROP_LATEST:\n-                       dq.poll();\n+                       dq.pollLast();\n                        dq.offer(t);\n                        callOnOverflow = true;\n                        break;\n                    case DROP_OLDEST:\n-                       dq.pollLast();\n+                       dq.poll();\n                        dq.offer(t);\n                        callOnOverflow = true;\n                        break;\n@@ -123,6 +123,7 @@ public void onNext(T t) {\n                    }\n                } else {\n                    dq.offer(t);\n+                   drain();\n                    return;\n                }\n             }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java\n@@ -0,0 +1,133 @@\n+/**\n+ * Copyright 2016 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.flowable;\n+\n+import static io.reactivex.BackpressureOverflowStrategy.DROP_OLDEST;\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.Test;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.functions.Action;\n+import io.reactivex.internal.subscriptions.BooleanSubscription;\n+import io.reactivex.schedulers.Schedulers;\n+import io.reactivex.subscribers.DefaultSubscriber;\n+import io.reactivex.subscribers.TestSubscriber;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+\n+public class FlowableOnBackpressureBufferStrategyTest {\n+\n+    private static Action onOverFlow = new Action() {\n+        @Override\n+        public void run() throws Exception {\n+            // Nothing\n+        }\n+    };\n+\n+\n+    @Test(timeout = 2000)\n+    public void testFixBackpressureWithBuffer() throws InterruptedException {\n+        final CountDownLatch l1 = new CountDownLatch(100);\n+        final CountDownLatch l2 = new CountDownLatch(150);\n+        final AtomicInteger droppedCount = new AtomicInteger(0);\n+        Action incrementOnDrop = new Action() {\n+            @Override\n+            public void run() throws Exception {\n+                droppedCount.incrementAndGet();\n+            }\n+        };\n+        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() {\n+\n+            @Override\n+            protected void onStart() {\n+            }\n+            \n+            @Override\n+            public void onComplete() {\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+            }\n+\n+            @Override\n+            public void onNext(Long t) {\n+                l1.countDown();\n+                l2.countDown();\n+            }\n+\n+        }, 0L);\n+        // this will be ignored\n+        ts.request(100);\n+        // we take 500 so it unsubscribes\n+        Flowable.fromPublisher(infinite.subscribeOn(Schedulers.computation())\n+        .onBackpressureBuffer(1, incrementOnDrop , DROP_OLDEST))\n+        .take(500)\n+        .subscribe(ts);\n+        \n+        // it completely ignores the `request(100)` and we get 500\n+        l1.await();\n+        assertEquals(100, ts.values().size());\n+        ts.request(50);\n+        l2.await();\n+        assertEquals(150, ts.values().size());\n+        ts.request(350);\n+        ts.awaitTerminalEvent();\n+        assertEquals(500, ts.values().size());\n+        ts.assertNoErrors();\n+        assertEquals(0, ts.values().get(0).intValue());\n+        assertEquals(499 + droppedCount.get(), ts.values().get(499).intValue());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testFixBackpressureBufferNegativeCapacity() throws InterruptedException {\n+        Flowable.empty().onBackpressureBuffer(-1, onOverFlow , DROP_OLDEST);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testFixBackpressureBufferZeroCapacity() throws InterruptedException {\n+        Flowable.empty().onBackpressureBuffer(0, onOverFlow , DROP_OLDEST);\n+    }\n+\n+\n+    static final Flowable<Long> infinite = Flowable.unsafeCreate(new Publisher<Long>() {\n+\n+        @Override\n+        public void subscribe(Subscriber<? super Long> s) {\n+            BooleanSubscription bs = new BooleanSubscription();\n+            s.onSubscribe(bs);\n+            long i = 0;\n+            while (!bs.isCancelled()) {\n+                s.onNext(i++);\n+            }\n+        }\n+\n+    });\n+\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void fixBackpressureBufferNegativeCapacity() throws InterruptedException {\n+        Flowable.empty().onBackpressureBuffer(-1, onOverFlow , DROP_OLDEST);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void fixBackpressureBufferZeroCapacity() throws InterruptedException {\n+        Flowable.empty().onBackpressureBuffer(0, onOverFlow , DROP_OLDEST);\n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Fix buffered objects not propagated downstream in FlowableOnBackpressureBufferStrategy\nFix drop strategy logic in FlowableOnBackpressureBufferStrategy\nAdd unit test for FlowableOnBackpressureBufferStrategy, copied from FlowableOnBackpressureBufferTest, there is still some work needed to have a better coverage"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java\n--- a/src/main/java/io/reactivex/Completable.java\n+++ b/src/main/java/io/reactivex/Completable.java\n@@ -1413,6 +1413,31 @@ public final void subscribe(CompletableObserver s) {\n      */\n     protected abstract void subscribeActual(CompletableObserver s);\n \n+    /**\n+     * Subscribes a given CompletableObserver (subclass) to this Completable and returns the given\n+     * CompletableObserver as is.\n+     * <p>Usage example:\n+     * <pre><code>\n+     * Completable<Integer> source = Completable.complete().delay(1, TimeUnit.SECONDS);\n+     * CompositeDisposable composite = new CompositeDisposable();\n+     * \n+     * class ResourceCompletableObserver implements CompletableObserver, Disposable {\n+     *     // ...\n+     * }\n+     * \n+     * composite.add(source.subscribeWith(new ResourceCompletableObserver()));\n+     * </code></pre>\n+     * @param <E> the type of the CompletableObserver to use and return\n+     * @param observer the CompletableObserver (subclass) to use and return, not null\n+     * @return the input {@code observer}\n+     * @throws NullPointerException if {@code observer} is null\n+     * @since 2.0\n+     */\n+    public final <E extends CompletableObserver> E subscribeWith(E observer) {\n+        subscribe(observer);\n+        return observer;\n+    }\n+    \n     /**\n      * Subscribes to this Completable and calls back either the onError or onComplete functions.\n      * <dl>\n\ndiff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java\n--- a/src/main/java/io/reactivex/Flowable.java\n+++ b/src/main/java/io/reactivex/Flowable.java\n@@ -11709,7 +11709,32 @@ public final void subscribe(Subscriber<? super T> s) {\n      * @param s the incoming Subscriber, never null\n      */\n     protected abstract void subscribeActual(Subscriber<? super T> s);\n-    \n+\n+    /**\n+     * Subscribes a given Subscriber (subclass) to this Flowable and returns the given\n+     * Subscriber as is.\n+     * <p>Usage example:\n+     * <pre><code>\n+     * Flowable<Integer> source = Flowable.range(1, 10);\n+     * CompositeDisposable composite = new CompositeDisposable();\n+     * \n+     * ResourceSubscriber&lt;Integer> rs = new ResourceSubscriber&lt;>() {\n+     *     // ...\n+     * };\n+     * \n+     * composite.add(source.subscribeWith(rs));\n+     * </code></pre>\n+     * @param <E> the type of the Subscriber to use and return\n+     * @param subscriber the Subscriber (subclass) to use and return, not null\n+     * @return the input {@code subscriber}\n+     * @throws NullPointerException if {@code subscriber} is null\n+     * @since 2.0\n+     */\n+    public final <E extends Subscriber<? super T>> E subscribeWith(E subscriber) {\n+        subscribe(subscriber);\n+        return subscriber;\n+    }\n+\n     /**\n      * Asynchronously subscribes Observers to this Publisher on the specified {@link Scheduler}.\n      * <p>\n\ndiff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java\n--- a/src/main/java/io/reactivex/Observable.java\n+++ b/src/main/java/io/reactivex/Observable.java\n@@ -9886,6 +9886,31 @@ public final void subscribe(Observer<? super T> observer) {\n      */\n     protected abstract void subscribeActual(Observer<? super T> observer);\n \n+    /**\n+     * Subscribes a given Observer (subclass) to this Observable and returns the given\n+     * Observer as is.\n+     * <p>Usage example:\n+     * <pre><code>\n+     * Observable<Integer> source = Observable.range(1, 10);\n+     * CompositeDisposable composite = new CompositeDisposable();\n+     * \n+     * ResourceObserver&lt;Integer> rs = new ResourceSubscriber&lt;>() {\n+     *     // ...\n+     * };\n+     * \n+     * composite.add(source.subscribeWith(rs));\n+     * </code></pre>\n+     * @param <E> the type of the Observer to use and return\n+     * @param observer the Observer (subclass) to use and return, not null\n+     * @return the input {@code observer}\n+     * @throws NullPointerException if {@code observer} is null\n+     * @since 2.0\n+     */\n+    public final <E extends Observer<? super T>> E subscribeWith(E observer) {\n+        subscribe(observer);\n+        return observer;\n+    }\n+\n     /**\n      * Asynchronously subscribes Observers to this ObservableSource on the specified {@link Scheduler}.\n      * <p>\n\ndiff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java\n--- a/src/main/java/io/reactivex/Single.java\n+++ b/src/main/java/io/reactivex/Single.java\n@@ -2156,7 +2156,32 @@ public final void subscribe(SingleObserver<? super T> subscriber) {\n      * @param observer the SingleObserver to handle, not null\n      */\n     protected abstract void subscribeActual(SingleObserver<? super T> observer);\n-    \n+\n+    /**\n+     * Subscribes a given SingleObserver (subclass) to this Single and returns the given\n+     * SingleObserver as is.\n+     * <p>Usage example:\n+     * <pre><code>\n+     * Single<Integer> source = Single.just(1);\n+     * CompositeDisposable composite = new CompositeDisposable();\n+     * \n+     * class ResourceSingleObserver implements SingleObserver&lt;Integer>, Disposable {\n+     *     // ...\n+     * }\n+     * \n+     * composite.add(source.subscribeWith(new ResourceSingleObserver()));\n+     * </code></pre>\n+     * @param <E> the type of the SingleObserver to use and return\n+     * @param observer the SingleObserver (subclass) to use and return, not null\n+     * @return the input {@code observer}\n+     * @throws NullPointerException if {@code observer} is null\n+     * @since 2.0\n+     */\n+    public final <E extends SingleObserver<? super T>> E subscribeWith(E observer) {\n+        subscribe(observer);\n+        return observer;\n+    }\n+\n     /**\n      * Asynchronously subscribes subscribers to this Single on the specified {@link Scheduler}.\n      * <p>\n\ndiff --git a/src/test/java/io/reactivex/internal/SubscribeWithTest.java b/src/test/java/io/reactivex/internal/SubscribeWithTest.java\n--- a/src/test/java/io/reactivex/internal/SubscribeWithTest.java\n+++ b/src/test/java/io/reactivex/internal/SubscribeWithTest.java\n@@ -0,0 +1,76 @@\n+/**\n+ * Copyright 2016 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal;\n+\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+import io.reactivex.*;\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+import io.reactivex.subscribers.TestSubscriber;\n+\n+public class SubscribeWithTest {\n+\n+    @Test\n+    public void withFlowable() {\n+        Flowable.range(1, 10)\n+        .subscribeWith(new TestSubscriber<Integer>())\n+        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+    }\n+\n+\n+    @Test\n+    public void withObservable() {\n+        Observable.range(1, 10)\n+        .subscribeWith(new TestObserver<Integer>())\n+        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+    }\n+    \n+\n+    class ObserverImpl implements SingleObserver<Object>, CompletableObserver {\n+        Object value;\n+\n+        @Override\n+        public void onSubscribe(Disposable d) {\n+            \n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            this.value = 100;\n+        }\n+        \n+        @Override\n+        public void onSuccess(Object value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public void onError(Throwable e) {\n+            this.value = e;\n+        }\n+    }\n+    \n+    @Test\n+    public void withSingle() {\n+        assertEquals(1, Single.just(1).subscribeWith(new ObserverImpl()).value);\n+    }\n+\n+    @Test\n+    public void withCompletable() {\n+        assertEquals(100, Completable.complete().subscribeWith(new ObserverImpl()).value);\n+    }\n+\n+}",
    "output": "Add subscribeWith to get back the subscriber/observer fluently"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/exceptions/Exceptions.java b/src/main/java/io/reactivex/exceptions/Exceptions.java\n--- a/src/main/java/io/reactivex/exceptions/Exceptions.java\n+++ b/src/main/java/io/reactivex/exceptions/Exceptions.java\n@@ -52,7 +52,6 @@ public static RuntimeException propagate(Throwable t) {\n      * Throws a particular {@code Throwable} only if it belongs to a set of \"fatal\" error varieties. These\n      * varieties are as follows:\n      * <ul>\n-     * <li>{@code StackOverflowError}</li>\n      * <li>{@code VirtualMachineError}</li>\n      * <li>{@code ThreadDeath}</li>\n      * <li>{@code LinkageError}</li>\n@@ -68,9 +67,7 @@ public static RuntimeException propagate(Throwable t) {\n      */\n     public static void throwIfFatal(Throwable t) {\n         // values here derived from https://github.com/ReactiveX/RxJava/issues/748#issuecomment-32471495\n-        if (t instanceof StackOverflowError) {\n-            throw (StackOverflowError) t;\n-        } else if (t instanceof VirtualMachineError) {\n+        if (t instanceof VirtualMachineError) {\n             throw (VirtualMachineError) t;\n         } else if (t instanceof ThreadDeath) {\n             throw (ThreadDeath) t;",
    "output": "Remove explicit StackOverflow check as its a VirtualMachineError.\n\nLooks like [the linked comment][1] was misinterpreted (but not in a way that affected the implementation) as Scala considered StackOverflowError as non-fatal but RxJava always considered it fatal. As such, its explicit check was redundant.\r\n\r\n [1]: https://github.com/ReactiveX/RxJava/issues/748#issuecomment-32471495"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/observers/SafeObserver.java b/src/main/java/io/reactivex/observers/SafeObserver.java\n--- a/src/main/java/io/reactivex/observers/SafeObserver.java\n+++ b/src/main/java/io/reactivex/observers/SafeObserver.java\n@@ -186,8 +186,4 @@ public void onComplete() {\n             RxJavaPlugins.onError(e);\n         }\n     }\n-    \n-    /* test */ Observer<? super T> actual() {\n-        return actual;\n-    }\n }\n\ndiff --git a/src/main/java/io/reactivex/subscribers/SafeSubscriber.java b/src/main/java/io/reactivex/subscribers/SafeSubscriber.java\n--- a/src/main/java/io/reactivex/subscribers/SafeSubscriber.java\n+++ b/src/main/java/io/reactivex/subscribers/SafeSubscriber.java\n@@ -192,8 +192,4 @@ public void onComplete() {\n             RxJavaPlugins.onError(e);\n         }\n     }\n-    \n-    /* test */ Subscriber<? super T> actual() {\n-        return actual;\n-    }\n }\n\ndiff --git a/src/test/java/io/reactivex/subscribers/SafeObserverTest.java b/src/test/java/io/reactivex/subscribers/SafeObserverTest.java\n--- a/src/test/java/io/reactivex/subscribers/SafeObserverTest.java\n+++ b/src/test/java/io/reactivex/subscribers/SafeObserverTest.java\n@@ -516,7 +516,7 @@ public void onComplete() {\n             }\n         };\n         SafeSubscriber<Integer> s = new SafeSubscriber<Integer>(actual);\n-        \n-        assertSame(actual, s.actual());\n+\n+        assertSame(actual, s.actual);\n     }\n }",
    "output": "Remove unused test methods from safe observer/subscriber"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/disposables/RefCountDisposable.java b/src/main/java/io/reactivex/disposables/RefCountDisposable.java\n--- a/src/main/java/io/reactivex/disposables/RefCountDisposable.java\n+++ b/src/main/java/io/reactivex/disposables/RefCountDisposable.java\n@@ -1,88 +0,0 @@\n-/**\n- * Copyright 2016 Netflix, Inc.\n- * \n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n- * compliance with the License. You may obtain a copy of the License at\n- * \n- * http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software distributed under the License is\n- * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n- * the License for the specific language governing permissions and limitations under the License.\n- */\n-\n-package io.reactivex.disposables;\n-\n-import java.util.concurrent.atomic.*;\n-\n-import io.reactivex.internal.disposables.DisposableHelper;\n-import io.reactivex.internal.functions.Objects;\n-\n-/**\n- * Keeps track of the sub-subscriptions and unsubscribes the underlying subscription once all sub-subscriptions\n- * have unsubscribed.\n- */\n-public final class RefCountDisposable implements Disposable {\n-\n-    final AtomicReference<Disposable> resource = new AtomicReference<Disposable>();\n-\n-    final AtomicInteger count = new AtomicInteger();\n-\n-    final AtomicBoolean once = new AtomicBoolean();\n-\n-    /**\n-     * Creates a {@code RefCountDisposable} by wrapping the given non-null {@code Subscription}.\n-     * \n-     * @param resource\n-     *          the {@link Disposable} to wrap\n-     * @throws NullPointerException\n-     *          if {@code s} is {@code null}\n-     */\n-    public RefCountDisposable(Disposable resource) {\n-        Objects.requireNonNull(resource, \"resource is null\");\n-        this.resource.lazySet(resource);\n-        count.lazySet(1);\n-    }\n-    \n-    @Override\n-    public void dispose() {\n-        if (once.compareAndSet(false, true)) {\n-            release();\n-        }\n-    }\n-\n-    /**\n-     * Returns a new sub-Disposable\n-     *\n-     * @return a new sub-Disposable.\n-     */\n-    public Disposable get() {\n-        count.getAndIncrement();\n-        return new InnerDisposable(this);\n-    }\n-    \n-    void release() {\n-        if (count.decrementAndGet() == 0) {\n-            DisposableHelper.dispose(resource);\n-        }\n-    }\n-    \n-    @Override\n-    public boolean isDisposed() {\n-        return resource.get() == DisposableHelper.DISPOSED;\n-    }\n-    \n-    static final class InnerDisposable extends ReferenceDisposable<RefCountDisposable> {\n-        /** */\n-        private static final long serialVersionUID = -6066815451193282256L;\n-\n-        InnerDisposable(RefCountDisposable parent) {\n-            super(parent);\n-        }\n-\n-        @Override\n-        protected void onDisposed(RefCountDisposable parent) {\n-            parent.release();\n-        }\n-    }\n-}\n\ndiff --git a/src/test/java/io/reactivex/disposables/RefCountDisposableTest.java b/src/test/java/io/reactivex/disposables/RefCountDisposableTest.java\n--- a/src/test/java/io/reactivex/disposables/RefCountDisposableTest.java\n+++ b/src/test/java/io/reactivex/disposables/RefCountDisposableTest.java\n@@ -1,108 +0,0 @@\n-/**\n- * Copyright 2016 Netflix, Inc.\n- * \n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n- * compliance with the License. You may obtain a copy of the License at\n- * \n- * http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software distributed under the License is\n- * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n- * the License for the specific language governing permissions and limitations under the License.\n- */\n-\n-package io.reactivex.disposables;\n-\n-import static org.mockito.Mockito.*;\n-\n-import org.junit.*;\n-import org.mockito.InOrder;\n-\n-public class RefCountDisposableTest {\n-    Runnable main;\n-    RefCountDisposable rcs;\n-\n-    @Before\n-    public void before() {\n-        main = mock(Runnable.class);\n-        rcs = new RefCountDisposable(Disposables.from(main));\n-    }\n-\n-    @Test\n-    public void testImmediateUnsubscribe() {\n-        InOrder inOrder = inOrder(main);\n-\n-        rcs.dispose();\n-\n-        inOrder.verify(main, times(1)).run();\n-\n-        rcs.dispose();\n-\n-        inOrder.verifyNoMoreInteractions();\n-    }\n-\n-    @Test\n-    public void testRCSUnsubscribeBeforeClient() {\n-        InOrder inOrder = inOrder(main);\n-\n-        Disposable s = rcs.get();\n-\n-        rcs.dispose();\n-\n-        inOrder.verify(main, never()).run();\n-\n-        s.dispose();\n-\n-        inOrder.verify(main, times(1)).run();\n-\n-        rcs.dispose();\n-        s.dispose();\n-\n-        inOrder.verifyNoMoreInteractions();\n-\n-    }\n-\n-    @Test\n-    public void testMultipleClientsUnsubscribeFirst() {\n-        InOrder inOrder = inOrder(main);\n-\n-        Disposable s1 = rcs.get();\n-        Disposable s2 = rcs.get();\n-\n-        s1.dispose();\n-        inOrder.verify(main, never()).run();\n-        s2.dispose();\n-        inOrder.verify(main, never()).run();\n-\n-        rcs.dispose();\n-        inOrder.verify(main, times(1)).run();\n-\n-        s1.dispose();\n-        s2.dispose();\n-        rcs.dispose();\n-\n-        inOrder.verifyNoMoreInteractions();\n-    }\n-\n-    @Test\n-    public void testMultipleClientsMainUnsubscribeFirst() {\n-        InOrder inOrder = inOrder(main);\n-\n-        Disposable s1 = rcs.get();\n-        Disposable s2 = rcs.get();\n-\n-        rcs.dispose();\n-        inOrder.verify(main, never()).run();\n-        s1.dispose();\n-        inOrder.verify(main, never()).run();\n-        s2.dispose();\n-\n-        inOrder.verify(main, times(1)).run();\n-\n-        s1.dispose();\n-        s2.dispose();\n-        rcs.dispose();\n-\n-        inOrder.verifyNoMoreInteractions();\n-    }\n-}\n\\ No newline at end of file",
    "output": "Remove reference counted Disposable public type.\n\nThis is a very specific use case to provide as a first-party type which can always be added back later should there be sufficient demand"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java\n--- a/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java\n+++ b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java\n@@ -30,7 +30,7 @@ public final class ComputationScheduler extends Scheduler {\n     /** This will indicate no pool is active. */\n     static final FixedSchedulerPool NONE = new FixedSchedulerPool(0);\n     /** Manages a fixed number of workers. */\n-    private static final String THREAD_NAME_PREFIX = \"RxComputationThreadPool-\";\n+    private static final String THREAD_NAME_PREFIX = \"RxComputationThreadPool\";\n     private static final RxThreadFactory THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX);\n     /** \n      * Key to setting the maximum number of computation scheduler threads.\n@@ -55,7 +55,7 @@ public final class ComputationScheduler extends Scheduler {\n         }\n         MAX_THREADS = max;\n \n-        SHUTDOWN_WORKER = new PoolWorker(new RxThreadFactory(\"RxComputationShutdown-\"));\n+        SHUTDOWN_WORKER = new PoolWorker(new RxThreadFactory(\"RxComputationShutdown\"));\n         SHUTDOWN_WORKER.dispose();\n     }\n \n\ndiff --git a/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java b/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java\n--- a/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java\n+++ b/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java\n@@ -28,11 +28,11 @@\n  * Scheduler that creates and caches a set of thread pools and reuses them if possible.\n  */\n public final class IoScheduler extends Scheduler {\n-    private static final String WORKER_THREAD_NAME_PREFIX = \"RxCachedThreadScheduler-\";\n+    private static final String WORKER_THREAD_NAME_PREFIX = \"RxCachedThreadScheduler\";\n     private static final RxThreadFactory WORKER_THREAD_FACTORY =\n             new RxThreadFactory(WORKER_THREAD_NAME_PREFIX);\n \n-    private static final String EVICTOR_THREAD_NAME_PREFIX = \"RxCachedWorkerPoolEvictor-\";\n+    private static final String EVICTOR_THREAD_NAME_PREFIX = \"RxCachedWorkerPoolEvictor\";\n     private static final RxThreadFactory EVICTOR_THREAD_FACTORY =\n             new RxThreadFactory(EVICTOR_THREAD_NAME_PREFIX);\n \n@@ -47,7 +47,7 @@ public final class IoScheduler extends Scheduler {\n         NONE = new CachedWorkerPool(0, null);\n         NONE.shutdown();\n \n-        SHUTDOWN_THREADWORKER = new ThreadWorker(new RxThreadFactory(\"RxCachedThreadSchedulerShutdown-\"));\n+        SHUTDOWN_THREADWORKER = new ThreadWorker(new RxThreadFactory(\"RxCachedThreadSchedulerShutdown\"));\n         SHUTDOWN_THREADWORKER.dispose();\n     }\n     \n\ndiff --git a/src/main/java/io/reactivex/internal/schedulers/NewThreadScheduler.java b/src/main/java/io/reactivex/internal/schedulers/NewThreadScheduler.java\n--- a/src/main/java/io/reactivex/internal/schedulers/NewThreadScheduler.java\n+++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadScheduler.java\n@@ -23,7 +23,7 @@\n  */\n public final class NewThreadScheduler extends Scheduler {\n \n-    private static final String THREAD_NAME_PREFIX = \"RxNewThreadScheduler-\";\n+    private static final String THREAD_NAME_PREFIX = \"RxNewThreadScheduler\";\n     private static final RxThreadFactory THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX);\n     private static final NewThreadScheduler INSTANCE = new NewThreadScheduler();\n \n\ndiff --git a/src/main/java/io/reactivex/internal/schedulers/RxThreadFactory.java b/src/main/java/io/reactivex/internal/schedulers/RxThreadFactory.java\n--- a/src/main/java/io/reactivex/internal/schedulers/RxThreadFactory.java\n+++ b/src/main/java/io/reactivex/internal/schedulers/RxThreadFactory.java\n@@ -30,10 +30,7 @@ public RxThreadFactory(String prefix) {\n     \n     @Override\n     public Thread newThread(Runnable r) {\n-        StringBuilder nameBuilder = new StringBuilder();\n-        nameBuilder.append(prefix)\n-        .append('-')\n-        .append(incrementAndGet());\n+        StringBuilder nameBuilder = new StringBuilder(prefix).append('-').append(incrementAndGet());\n         \n         if (CREATE_TRACE) {\n             nameBuilder.append(\"\\r\\n\");\n\ndiff --git a/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java b/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java\n--- a/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java\n+++ b/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java\n@@ -58,7 +58,7 @@ public static void start() {\n             if (curr != null && !curr.isShutdown()) {\n                 return;\n             }\n-            ScheduledExecutorService next = Executors.newScheduledThreadPool(1, new RxThreadFactory(\"RxSchedulerPurge-\"));\n+            ScheduledExecutorService next = Executors.newScheduledThreadPool(1, new RxThreadFactory(\"RxSchedulerPurge\"));\n             if (PURGE_THREAD.compareAndSet(curr, next)) {\n                 \n                 next.scheduleAtFixedRate(new Runnable() {\n\ndiff --git a/src/main/java/io/reactivex/internal/schedulers/SingleScheduler.java b/src/main/java/io/reactivex/internal/schedulers/SingleScheduler.java\n--- a/src/main/java/io/reactivex/internal/schedulers/SingleScheduler.java\n+++ b/src/main/java/io/reactivex/internal/schedulers/SingleScheduler.java\n@@ -35,7 +35,7 @@ public SingleScheduler() {\n     }\n \n     static ScheduledExecutorService createExecutor() {\n-        return SchedulerPoolFactory.create(new RxThreadFactory(\"RxSingleScheduler-\"));\n+        return SchedulerPoolFactory.create(new RxThreadFactory(\"RxSingleScheduler\"));\n     }\n     \n     @Override\n\ndiff --git a/src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java b/src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java\n--- a/src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java\n+++ b/src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java\n@@ -37,7 +37,7 @@\n \n public class ExecutorSchedulerTest extends AbstractSchedulerConcurrencyTests {\n \n-    final static Executor executor = Executors.newFixedThreadPool(2, new RxThreadFactory(\"TestCustomPool-\"));\n+    final static Executor executor = Executors.newFixedThreadPool(2, new RxThreadFactory(\"TestCustomPool\"));\n     \n     @Override\n     protected Scheduler getScheduler() {",
    "output": "Remove double dash on RxThreadFactory thread names.\n\nAlso optimize name creation to avoid StringBuilder having to expand its underlying char[]"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/observable/ObservableTests.java b/src/test/java/io/reactivex/observable/ObservableTests.java\n--- a/src/test/java/io/reactivex/observable/ObservableTests.java\n+++ b/src/test/java/io/reactivex/observable/ObservableTests.java\n@@ -143,6 +143,7 @@ public Throwable call() {\n         verify(w, times(1)).onError(any(RuntimeException.class));\n     }\n \n+    @Test\n     public void testTakeFirstWithPredicateOfSome() {\n         Observable<Integer> o = Observable.just(1, 3, 5, 4, 6, 3);\n         o.takeFirst(IS_EVEN).subscribe(w);",
    "output": "Add missing @Test annotation"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java\n--- a/src/main/java/io/reactivex/Flowable.java\n+++ b/src/main/java/io/reactivex/Flowable.java\n@@ -49,7 +49,7 @@\n  * <p>\n  * The Flowable hosts the default buffer size of 128 elements for operators, accessible via {@link #bufferSize()},\n  * that can be overridden globally via the system parameter {@code rx2.buffer-size}. Most operators, however, have\n- * overloads that allow setting their internal buffer size explicity.\n+ * overloads that allow setting their internal buffer size explicitly.\n  * <p>\n  * The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:\n  * <p>\n@@ -2688,7 +2688,7 @@ public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v\n         Objects.requireNonNull(v5, \"The fifth value is null\");\n         Objects.requireNonNull(v6, \"The sixth value is null\");\n         Objects.requireNonNull(v7, \"The seventh value is null\");\n-        Objects.requireNonNull(v8, \"The eigth value is null\");\n+        Objects.requireNonNull(v8, \"The eighth value is null\");\n         \n         return fromArray(v1, v2, v3, v4, v5, v6, v7, v8);\n     }\n@@ -2738,7 +2738,7 @@ public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v\n         Objects.requireNonNull(v5, \"The fifth value is null\");\n         Objects.requireNonNull(v6, \"The sixth value is null\");\n         Objects.requireNonNull(v7, \"The seventh value is null\");\n-        Objects.requireNonNull(v8, \"The eigth value is null\");\n+        Objects.requireNonNull(v8, \"The eighth value is null\");\n         Objects.requireNonNull(v9, \"The ninth is null\");\n         \n         return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9);\n@@ -2791,7 +2791,7 @@ public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v\n         Objects.requireNonNull(v5, \"The fifth value is null\");\n         Objects.requireNonNull(v6, \"The sixth value is null\");\n         Objects.requireNonNull(v7, \"The seventh value is null\");\n-        Objects.requireNonNull(v8, \"The eigth value is null\");\n+        Objects.requireNonNull(v8, \"The eighth value is null\");\n         Objects.requireNonNull(v9, \"The ninth is null\");\n         Objects.requireNonNull(v10, \"The tenth is null\");\n         \n@@ -5060,7 +5060,7 @@ public final Flowable<T> ambWith(Publisher<? extends T> other) {\n      * <dl>\n      *  <dt><b>Backpressure:</b></dt>\n      *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n-     *  (i.e., no backkpressure applied to it).</dd>\n+     *  (i.e., no backpressure applied to it).</dd>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code exists} does not operate by default on a particular {@link Scheduler}.</dd>\n      * </dl>\n@@ -6042,7 +6042,7 @@ public final <R> Flowable<R> compose(FlowableTransformer<T, R> composer) {\n      *  <dd>{@code concatMap} does not operate by default on a particular {@link Scheduler}.</dd>\n      * </dl>\n      * \n-     * @param <R> the type of the inner Publisher sources and thus the ouput type\n+     * @param <R> the type of the inner Publisher sources and thus the output type\n      * @param mapper\n      *            a function that, when applied to an item emitted by the source Publisher, returns an\n      *            Publisher\n@@ -6073,7 +6073,7 @@ public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<?\n      *  <dd>{@code concatMap} does not operate by default on a particular {@link Scheduler}.</dd>\n      * </dl>\n      * \n-     * @param <R> the type of the inner Publisher sources and thus the ouput type\n+     * @param <R> the type of the inner Publisher sources and thus the output type\n      * @param mapper\n      *            a function that, when applied to an item emitted by the source Publisher, returns an\n      *            Publisher\n@@ -7281,7 +7281,7 @@ public final Flowable<T> doOnError(Consumer<? super Throwable> onError) {\n     }\n \n     /**\n-     * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecylce events of\n+     * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecylcle events of\n      * the sequence (subscription, cancellation, requesting).\n      * <p>\n      * <img width=\"640\" height=\"310\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.png\" alt=\"\">\n@@ -7431,7 +7431,7 @@ public void accept(Throwable e) {\n      * <dl>\n      *  <dt><b>Backpressure:</b></dt>\n      *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n-     *  (i.e., no backkpressure applied to it).</dd>\n+     *  (i.e., no backpressure applied to it).</dd>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code elementAt} does not operate by default on a particular {@link Scheduler}.</dd>\n      * </dl>\n@@ -7463,7 +7463,7 @@ public final Flowable<T> elementAt(long index) {\n      * <dl>\n      *  <dt><b>Backpressure:</b></dt>\n      *  <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner\n-     *  (i.e., no backkpressure applied to it).</dd>\n+     *  (i.e., no backpressure applied to it).</dd>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code elementAtOrDefault} does not operate by default on a particular {@link Scheduler}.</dd>\n      * </dl>\n@@ -7969,7 +7969,7 @@ public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<\n      *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate\n      *            if false, the first one signalling an exception will terminate the whole sequence immediately\n      * @param bufferSize\n-     *            the numer of elements to prefetch from the innner Publishers.\n+     *            the number of elements to prefetch from the innner Publishers.\n      * @return a Flowable that emits the results of applying a function to a pair of values emitted by the\n      *         source Publisher and the collection Publisher\n      * @see <a href=\"http://reactivex.io/documentation/operators/flatmap.html\">ReactiveX operators documentation: FlatMap</a>\n@@ -8081,7 +8081,7 @@ public final <U> Flowable<U> flatMapIterable(final Function<? super T, ? extends\n      *            a function that returns an Iterable sequence of values for when given an item emitted by the\n      *            source Publisher\n      * @param bufferSize\n-     *            the numer of elements to prefetch from the current Flowable\n+     *            the number of elements to prefetch from the current Flowable\n      * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n      *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n      * @see <a href=\"http://reactivex.io/documentation/operators/flatmap.html\">ReactiveX operators documentation: FlatMap</a>\n@@ -8159,7 +8159,7 @@ public Publisher<U> apply(T t) throws Exception {\n      *            a function that returns an item based on the item emitted by the source Publisher and the\n      *            Iterable returned for that item by the {@code collectionSelector}\n      * @param prefetch\n-     *            the numer of elements to prefetch from the current Flowable\n+     *            the number of elements to prefetch from the current Flowable\n      * @return a Flowable that emits the results of merging the items emitted by the source Publisher with\n      *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n      * @throws IllegalArgumentException\n@@ -9813,7 +9813,7 @@ public final <R> Flowable<R> reduce(R seed, BiFunction<R, ? super T, R> reducer)\n      * \n      * @param <R> the accumulator and output value type\n      * @param seedSupplier\n-     *            the Callbable that provides the initial (seed) accumulator value for each individual Subscriber\n+     *            the Callable that provides the initial (seed) accumulator value for each individual Subscriber\n      * @param reducer\n      *            an accumulator function to be invoked on each item emitted by the source Publisher, the\n      *            result of which will be used in the next accumulator call\n\ndiff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java\n--- a/src/main/java/io/reactivex/Observable.java\n+++ b/src/main/java/io/reactivex/Observable.java\n@@ -628,7 +628,7 @@ public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T\n         Objects.requireNonNull(v5, \"The fifth value is null\");\n         Objects.requireNonNull(v6, \"The sixth value is null\");\n         Objects.requireNonNull(v7, \"The seventh value is null\");\n-        Objects.requireNonNull(v8, \"The eigth value is null\");\n+        Objects.requireNonNull(v8, \"The eighth value is null\");\n         \n         return fromArray(v1, v2, v3, v4, v5, v6, v7, v8);\n     }\n@@ -643,7 +643,7 @@ public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T\n         Objects.requireNonNull(v5, \"The fifth value is null\");\n         Objects.requireNonNull(v6, \"The sixth value is null\");\n         Objects.requireNonNull(v7, \"The seventh value is null\");\n-        Objects.requireNonNull(v8, \"The eigth value is null\");\n+        Objects.requireNonNull(v8, \"The eighth value is null\");\n         Objects.requireNonNull(v9, \"The ninth is null\");\n         \n         return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9);",
    "output": "Fix some typos in Flowable + Observer documentation"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableFromSource.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableFromSource.java\n--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableFromSource.java\n+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableFromSource.java\n@@ -38,6 +38,8 @@ static final class DisposeAwareCompletableObserver\n     extends AtomicBoolean\n     implements CompletableObserver, Disposable {\n \n+        /** */\n+        private static final long serialVersionUID = -1520879094105684863L;\n         private final CompletableObserver o;\n         private Disposable d;\n \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFromSource.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFromSource.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFromSource.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFromSource.java\n@@ -38,6 +38,8 @@ static final class DisposedAwareObserver<T>\n     extends AtomicBoolean\n     implements Observer<T>, Disposable {\n \n+        /** */\n+        private static final long serialVersionUID = -7920748056724379224L;\n         private final Observer<? super T> o;\n         private Disposable d;\n \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/single/SingleFromSource.java b/src/main/java/io/reactivex/internal/operators/single/SingleFromSource.java\n--- a/src/main/java/io/reactivex/internal/operators/single/SingleFromSource.java\n+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFromSource.java\n@@ -36,6 +36,8 @@ public SingleFromSource(SingleSource<T> source) {\n     static final class DisposeAwareSingleObserver<T>\n     extends AtomicBoolean\n     implements SingleObserver<T>, Disposable {\n+        /** */\n+        private static final long serialVersionUID = -166991076349162358L;\n         private final SingleObserver<? super T> o;\n         private Disposable d;\n \n\ndiff --git a/src/test/java/io/reactivex/subscribers/SafeSubscriberWithPluginTest.java b/src/test/java/io/reactivex/subscribers/SafeSubscriberWithPluginTest.java\n--- a/src/test/java/io/reactivex/subscribers/SafeSubscriberWithPluginTest.java\n+++ b/src/test/java/io/reactivex/subscribers/SafeSubscriberWithPluginTest.java\n@@ -13,7 +13,7 @@\n \n package io.reactivex.subscribers;\n \n-import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.*;\n \n import java.util.concurrent.atomic.AtomicInteger;\n \n@@ -55,7 +55,7 @@ public void onComplete() {\n         SafeSubscriber<Integer> safe = new SafeSubscriber<Integer>(ts);\n         try {\n             safe.onComplete();\n-            Assert.fail();\n+            fail();\n         } catch (RuntimeException e) {\n             // FIXME no longer assertable\n             // assertTrue(safe.isUnsubscribed());",
    "output": "Fix compilation warnings"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRedo.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRedo.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRedo.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRedo.java\n@@ -22,7 +22,7 @@\n import io.reactivex.functions.*;\n import io.reactivex.internal.subscribers.flowable.ToNotificationSubscriber;\n import io.reactivex.internal.subscriptions.SubscriptionArbiter;\n-import io.reactivex.processors.BehaviorProcessor;\n+import io.reactivex.processors.*;\n \n // FIXME split and update to the Rsc version\n public final class FlowableRedo<T> extends Flowable<T> {\n@@ -39,7 +39,7 @@ public FlowableRedo(Publisher<? extends T> source,\n     public void subscribeActual(Subscriber<? super T> s) {\n         \n         // FIXE use BehaviorSubject? (once available)\n-        BehaviorProcessor<Try<Optional<Object>>> subject = BehaviorProcessor.create();\n+        FlowProcessor<Try<Optional<Object>>> subject = BehaviorProcessor.<Try<Optional<Object>>>create().toSerialized();\n         \n         final RedoSubscriber<T> parent = new RedoSubscriber<T>(s, subject, source);\n \n@@ -70,13 +70,13 @@ static final class RedoSubscriber<T> extends AtomicBoolean implements Subscriber\n         /** */\n         private static final long serialVersionUID = -1151903143112844287L;\n         final Subscriber<? super T> actual;\n-        final BehaviorProcessor<Try<Optional<Object>>> subject;\n+        final FlowProcessor<Try<Optional<Object>>> subject;\n         final Publisher<? extends T> source;\n         final SubscriptionArbiter arbiter;\n         \n         final AtomicInteger wip = new AtomicInteger();\n         \n-        public RedoSubscriber(Subscriber<? super T> actual, BehaviorProcessor<Try<Optional<Object>>> subject, Publisher<? extends T> source) {\n+        public RedoSubscriber(Subscriber<? super T> actual, FlowProcessor<Try<Optional<Object>>> subject, Publisher<? extends T> source) {\n             this.actual = actual;\n             this.subject = subject;\n             this.source = source;\n\ndiff --git a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java\n--- a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java\n+++ b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java\n@@ -96,15 +96,14 @@ public final void setSubscription(Subscription s) {\n             actual = s;\n             \n             long r = requested;\n-            if (r != 0L) {\n-                s.request(r);\n-            }\n             \n-            if (decrementAndGet() == 0) {\n-                return;\n+            if (decrementAndGet() != 0) {\n+                drainLoop();\n             }\n \n-            drainLoop();\n+            if (r != 0L) {\n+                s.request(r);\n+            }\n \n             return;\n         }\n@@ -133,15 +132,14 @@ public final void request(long n) {\n                     }\n                 }\n                 Subscription a = actual;\n-                if (a != null) {\n-                    a.request(n);\n-                }\n \n-                if (decrementAndGet() == 0) {\n-                    return;\n+                if (decrementAndGet() != 0) {\n+                    drainLoop();\n                 }\n \n-                drainLoop();\n+                if (a != null) {\n+                    a.request(n);\n+                }\n \n                 return;\n             }\n@@ -235,6 +233,9 @@ final void drain() {\n     final void drainLoop() {\n         int missed = 1;\n \n+        long requestAmount = 0L;\n+        Subscription requestTarget = null;\n+        \n         for (; ; ) {\n \n             Subscription ms = missedSubscription.get();\n@@ -287,15 +288,20 @@ final void drainLoop() {\n                     }\n                     actual = ms;\n                     if (r != 0L) {\n-                        ms.request(r);\n+                        requestAmount = BackpressureHelper.addCap(requestAmount, r);\n+                        requestTarget = ms;\n                     }\n-                } else if (mr != 0L && a != null) {\n-                    a.request(mr);\n+                } else if (a != null && mr != 0L) {\n+                    requestAmount = BackpressureHelper.addCap(requestAmount, mr);\n+                    requestTarget = a;\n                 }\n             }\n \n             missed = addAndGet(-missed);\n             if (missed == 0) {\n+                if (requestAmount != 0L) {\n+                    requestTarget.request(requestAmount);\n+                }\n                 return;\n             }\n         }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java\n@@ -1007,4 +1007,35 @@ public void startWith() throws Exception {\n             ts.assertComplete();\n         }\n     }\n+    \n+    static final class InfiniteIterator implements Iterator<Integer>, Iterable<Integer> {\n+\n+        int count;\n+        \n+        @Override\n+        public boolean hasNext() {\n+            return true;\n+        }\n+\n+        @Override\n+        public Integer next() {\n+            return count++;\n+        }\n+        \n+        @Override\n+        public void remove() {\n+        }\n+        \n+        @Override\n+        public Iterator<Integer> iterator() {\n+            return this;\n+        }\n+    }\n+    \n+    @Test(timeout = 5000)\n+    public void veryLongTake() {\n+        Flowable.fromIterable(new InfiniteIterator()).concatWith(Flowable.<Integer>empty()).take(10)\n+        .test()\n+        .assertResult(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+    }\n }\n\\ No newline at end of file",
    "output": "Fix SubscriptionArbiter reentrancy/cancel bug * fix SubscriptionArbiter reentrancy/cancel bug * Use an infinite source with timeout as 1G element takes only 2 secs"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/subscribers/single/SingleSerializedSubscriber.java b/src/main/java/io/reactivex/subscribers/single/SingleSerializedSubscriber.java\n--- a/src/main/java/io/reactivex/subscribers/single/SingleSerializedSubscriber.java\n+++ b/src/main/java/io/reactivex/subscribers/single/SingleSerializedSubscriber.java\n@@ -0,0 +1,49 @@\n+/**\n+ * Copyright 2016 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.subscribers.single;\n+\n+import io.reactivex.SingleSubscriber;\n+import io.reactivex.disposables.Disposable;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public final class SingleSerializedSubscriber implements SingleSubscriber {\n+\n+    final SingleSubscriber actual;\n+\n+    final AtomicBoolean once = new AtomicBoolean();\n+\n+    public SingleSerializedSubscriber(SingleSubscriber actual) {\n+        this.actual = actual;\n+    }\n+    \n+    @Override\n+    public void onSubscribe(Disposable d) {\n+        actual.onSubscribe(d);\n+    }\n+\n+    @Override\n+    public void onSuccess(Object value) {\n+        if (once.compareAndSet(false, true)) {\n+            actual.onSuccess(value);\n+        }\n+    }\n+\n+    @Override\n+    public void onError(Throwable e) {\n+        if (once.compareAndSet(false, true)) {\n+            actual.onError(e);\n+        }\n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Add serialized single subscriber wrapper"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java\n--- a/src/main/java/io/reactivex/Observable.java\n+++ b/src/main/java/io/reactivex/Observable.java\n@@ -40,11 +40,11 @@\n public abstract class Observable<T> implements ObservableConsumable<T> {\n     static final Object OBJECT = new Object();\n     \n-    public interface NbpOperator<Downstream, Upstream> extends Function<Observer<? super Downstream>, Observer<? super Upstream>> {\n+    public interface Operator<Downstream, Upstream> extends Function<Observer<? super Downstream>, Observer<? super Upstream>> {\n         \n     }\n     \n-    public interface NbpTransformer<Upstream, Downstream> extends Function<Observable<Upstream>, ObservableConsumable<Downstream>> {\n+    public interface Transformer<Upstream, Downstream> extends Function<Observable<Upstream>, ObservableConsumable<Downstream>> {\n         \n     }\n     \n@@ -1617,7 +1617,7 @@ public final Observable<T> doOnError(Consumer<? super Throwable> onError) {\n     public final Observable<T> doOnLifecycle(final Consumer<? super Disposable> onSubscribe, final Runnable onCancel) {\n         Objects.requireNonNull(onSubscribe, \"onSubscribe is null\");\n         Objects.requireNonNull(onCancel, \"onCancel is null\");\n-        return lift(new NbpOperator<T, T>() {\n+        return lift(new Operator<T, T>() {\n             @Override\n             public Observer<? super T> apply(Observer<? super T> s) {\n                 return new SubscriptionLambdaObserver<T>(s, onSubscribe, onCancel);\n@@ -2005,7 +2005,7 @@ public final Observable<T> last(T defaultValue) {\n         return takeLast(1).single(defaultValue);\n     }\n \n-    public final <R> Observable<R> lift(NbpOperator<? extends R, ? super T> onLift) {\n+    public final <R> Observable<R> lift(Operator<? extends R, ? super T> onLift) {\n         Objects.requireNonNull(onLift, \"onLift is null\");\n         return new ObservableLift<R, T>(this, onLift);\n     }\n@@ -2457,7 +2457,7 @@ public final <R> Observable<R> scanWith(Callable<R> seedSupplier, BiFunction<R,\n \n     @SchedulerSupport(SchedulerSupport.NONE)\n     public final Observable<T> serialize() {\n-        return lift(new NbpOperator<T, T>() {\n+        return lift(new Operator<T, T>() {\n             @Override\n             public Observer<? super T> apply(Observer<? super T> s) {\n                 return new SerializedObserver<T>(s);\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableLift.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableLift.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableLift.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableLift.java\n@@ -27,11 +27,11 @@\n  */\n public final class ObservableLift<R, T> extends Observable<R> {\n     /** The actual operator. */\n-    final NbpOperator<? extends R, ? super T> operator;\n+    final Operator<? extends R, ? super T> operator;\n     /** The source publisher. */\n     final ObservableConsumable<? extends T> source;\n     \n-    public ObservableLift(ObservableConsumable<? extends T> source, NbpOperator<? extends R, ? super T> operator) {\n+    public ObservableLift(ObservableConsumable<? extends T> source, Operator<? extends R, ? super T> operator) {\n         this.source = source;\n         this.operator = operator;\n     }\n@@ -40,7 +40,7 @@ public ObservableLift(ObservableConsumable<? extends T> source, NbpOperator<? ex\n      * Returns the operator of this lift publisher.\n      * @return the operator of this lift publisher\n      */\n-    public NbpOperator<? extends R, ? super T> operator() {\n+    public Operator<? extends R, ? super T> operator() {\n         return operator;\n     }\n     \n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorResumeNextViaFunctionTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorResumeNextViaFunctionTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorResumeNextViaFunctionTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorResumeNextViaFunctionTest.java\n@@ -24,7 +24,7 @@\n import org.reactivestreams.Subscription;\n \n import io.reactivex.*;\n-import io.reactivex.Observable.NbpOperator;\n+import io.reactivex.Observable.Operator;\n import io.reactivex.disposables.Disposable;\n import io.reactivex.functions.Function;\n import io.reactivex.internal.disposables.EmptyDisposable;\n@@ -152,7 +152,7 @@ public Observable<String> apply(Throwable t1) {\n     @Ignore(\"Failed operator may leave the child NbpSubscriber in an inconsistent state which prevents further error delivery.\")\n     public void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperator() {\n         TestObserver<String> ts = new TestObserver<String>();\n-        Observable.just(1).lift(new NbpOperator<String, Integer>() {\n+        Observable.just(1).lift(new Operator<String, Integer>() {\n \n             @Override\n             public Observer<? super Integer> apply(Observer<? super String> t1) {\n@@ -185,7 +185,7 @@ public Observable<String> apply(Throwable t1) {\n     @Ignore(\"A crashing operator may leave the downstream in an inconsistent state and not suitable for event delivery\")\n     public void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperatorOnNext() {\n         TestObserver<String> ts = new TestObserver<String>();\n-        Observable.just(1).lift(new NbpOperator<String, Integer>() {\n+        Observable.just(1).lift(new Operator<String, Integer>() {\n \n             @Override\n             public Observer<? super Integer> apply(final Observer<? super String> t1) {\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchIfEmptyTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchIfEmptyTest.java\n--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchIfEmptyTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchIfEmptyTest.java\n@@ -67,7 +67,7 @@ public void subscribe(final Observer<? super Long> NbpSubscriber) {\n \n         Observable.<Long>empty()\n                 .switchIfEmpty(withProducer)\n-                .lift(new Observable.NbpOperator<Long, Long>() {\n+                .lift(new Observable.Operator<Long, Long>() {\n             @Override\n             public Observer<? super Long> apply(final Observer<? super Long> child) {\n                 return new DefaultObserver<Long>() {\n\ndiff --git a/src/test/java/io/reactivex/observable/ObservableCovarianceTest.java b/src/test/java/io/reactivex/observable/ObservableCovarianceTest.java\n--- a/src/test/java/io/reactivex/observable/ObservableCovarianceTest.java\n+++ b/src/test/java/io/reactivex/observable/ObservableCovarianceTest.java\n@@ -23,7 +23,7 @@\n import org.junit.Test;\n \n import io.reactivex.Observable;\n-import io.reactivex.Observable.NbpTransformer;\n+import io.reactivex.Observable.Transformer;\n import io.reactivex.functions.*;\n import io.reactivex.observables.GroupedObservable;\n import io.reactivex.observers.TestObserver;\n@@ -207,7 +207,7 @@ public Observable<Movie> apply(List<List<Movie>> listOfLists) {\n         }\n     };\n     \n-    static NbpTransformer<List<Movie>, Movie> deltaTransformer = new NbpTransformer<List<Movie>, Movie>() {\n+    static Transformer<List<Movie>, Movie> deltaTransformer = new Transformer<List<Movie>, Movie>() {\n         @Override\n         public Observable<Movie> apply(Observable<List<Movie>> movieList) {\n             return movieList\n\ndiff --git a/src/test/java/io/reactivex/observable/ObservableNullTests.java b/src/test/java/io/reactivex/observable/ObservableNullTests.java\n--- a/src/test/java/io/reactivex/observable/ObservableNullTests.java\n+++ b/src/test/java/io/reactivex/observable/ObservableNullTests.java\n@@ -21,7 +21,7 @@\n \n import io.reactivex.*;\n import io.reactivex.Observable;\n-import io.reactivex.Observable.NbpOperator;\n+import io.reactivex.Observable.Operator;\n import io.reactivex.Observer;\n import io.reactivex.Optional;\n import io.reactivex.disposables.Disposable;\n@@ -1618,7 +1618,7 @@ public void liftNull() {\n     \n     @Test(expected = NullPointerException.class)\n     public void liftReturnsNull() {\n-        just1.lift(new NbpOperator<Object, Integer>() {\n+        just1.lift(new Operator<Object, Integer>() {\n             @Override\n             public Observer<? super Integer> apply(Observer<? super Object> s) {\n                 return null;\n\ndiff --git a/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java b/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java\n--- a/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java\n+++ b/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java\n@@ -20,7 +20,7 @@\n import org.junit.Test;\n \n import io.reactivex.*;\n-import io.reactivex.Observable.NbpOperator;\n+import io.reactivex.Observable.Operator;\n import io.reactivex.observers.DefaultObserver;\n \n public class ObservableSubscriberTest {\n@@ -85,7 +85,7 @@ public void onNext(Integer t) {\n     @Test\n     public void testOnStartCalledOnceViaLift() {\n         final AtomicInteger c = new AtomicInteger();\n-        Observable.just(1, 2, 3, 4).lift(new NbpOperator<Integer, Integer>() {\n+        Observable.just(1, 2, 3, 4).lift(new Operator<Integer, Integer>() {\n \n             @Override\n             public Observer<? super Integer> apply(final Observer<? super Integer> child) {",
    "output": "Remove defunct 'Nbp' prefix from Observable interfaces"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java\n@@ -19,7 +19,8 @@\n \n import org.reactivestreams.*;\n \n-import io.reactivex.functions.*;\n+import io.reactivex.exceptions.MissingBackpressureException;\n+import io.reactivex.functions.Function;\n import io.reactivex.internal.functions.Objects;\n import io.reactivex.internal.fuseable.QueueSubscription;\n import io.reactivex.internal.queue.SpscArrayQueue;\n@@ -166,7 +167,7 @@ public void onSubscribe(Subscription s) {\n         @Override\n         public void onNext(T t) {\n             if (fusionMode != ASYNC && !queue.offer(t)) {\n-                onError(new IllegalStateException(\"Queue is full?!\"));\n+                onError(new MissingBackpressureException(\"Queue is full?!\"));\n                 return;\n             }\n             drain();\n@@ -363,13 +364,14 @@ boolean checkTerminated(boolean d, boolean empty, Subscriber<?> a, Queue<?> q) {\n                 return true;\n             }\n             if (d) {\n-                if (error != null) {\n-                    Throwable e = Exceptions.terminate(error);\n+                Throwable ex = error.get();\n+                if (ex != null) {\n+                    ex = Exceptions.terminate(error);\n \n                     current = null;\n                     q.clear();\n \n-                    a.onError(e);\n+                    a.onError(ex);\n                     return true;\n                 } else\n                     if (empty) {\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java\n--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java\n@@ -0,0 +1,50 @@\n+/**\n+ * Copyright 2016 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See\n+ * the License for the specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.reactivex.internal.operators.flowable;\n+\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.functions.*;\n+import io.reactivex.subscribers.TestSubscriber;\n+\n+public class FlowableFlattenIterableTest {\n+\n+    @Test\n+    public void normal() {\n+        \n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        \n+        Flowable.range(1, 2)\n+        .reduce(new BiFunction<Integer, Integer, Integer>() {\n+            @Override\n+            public Integer apply(Integer a, Integer b) {\n+                return Math.max(a, b);\n+            }\n+        })\n+        .flatMapIterable(new Function<Integer, Iterable<Integer>>() {\n+            @Override\n+            public Iterable<Integer> apply(Integer v) {\n+                return Arrays.asList(v, v + 1);\n+            }\n+        })\n+        .subscribe(ts);\n+        \n+        ts.assertValues(2, 3)\n+        .assertNoErrors()\n+        .assertComplete();\n+    }\n+}",
    "output": "Fix wrong reference check in FlattenIterable"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java\n@@ -243,6 +243,7 @@ void dispatch() {\n     static final class ReplaySubscription<T> extends AtomicLong implements Subscription, Disposable {\n         /** */\n         private static final long serialVersionUID = -2557562030197141021L;\n+        private static final long CANCELLED = -1;\n         /** The actual child subscriber. */\n         final Subscriber<? super T> child;\n         /** The cache state object. */\n@@ -268,9 +269,6 @@ static final class ReplaySubscription<T> extends AtomicLong implements Subscript\n         /** Indicates there were some state changes/replay attempts; guarded by this. */\n         boolean missed;\n         \n-        /** Set if the Subscription has been cancelled/disposed. */\n-        volatile boolean cancelled;\n-        \n         public ReplaySubscription(Subscriber<? super T> child, CacheState<T> state) {\n             this.child = child;\n             this.state = state;\n@@ -282,7 +280,7 @@ public void request(long n) {\n             }\n             for (;;) {\n                 long r = get();\n-                if (r < 0) {\n+                if (r == CANCELLED) {\n                     return;\n                 }\n                 long u = BackpressureHelper.addCap(r, n);\n@@ -303,18 +301,15 @@ public long produced(long n) {\n         \n         @Override\n         public boolean isDisposed() {\n-            return cancelled;\n+            return get() == CANCELLED;\n         }\n         @Override\n         public void dispose() {\n-            if (!cancelled) {\n-                cancelled = true;\n-                long r = get();\n-                if (r >= 0) {\n-                    r = getAndSet(-1L); // unsubscribed state is negative\n-                    if (r >= 0) {\n-                        state.removeProducer(this);\n-                    }\n+            long r = get();\n+            if (r != CANCELLED) {\n+                r = getAndSet(CANCELLED);\n+                if (r != CANCELLED) {\n+                    state.removeProducer(this);\n                 }\n             }\n         }\n@@ -383,7 +378,7 @@ public void replay() {\n                             int valuesProduced = 0;\n                             \n                             while (j < s && r > 0) {\n-                                if (cancelled) {\n+                                if (get() == CANCELLED) {\n                                     skipFinal = true;\n                                     return;\n                                 }\n@@ -414,7 +409,7 @@ public void replay() {\n                                 valuesProduced++;\n                             }\n                             \n-                            if (cancelled) {\n+                            if (get() == CANCELLED) {\n                                 skipFinal = true;\n                                 return;\n                             }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java\n@@ -57,8 +57,6 @@ static final class IntervalSubscriber extends AtomicLong\n         \n         long count;\n         \n-        volatile boolean cancelled;\n-        \n         final AtomicReference<Disposable> resource = new AtomicReference<Disposable>();\n         \n         public IntervalSubscriber(Subscriber<? super Long> actual) {\n@@ -74,19 +72,12 @@ public void request(long n) {\n         \n         @Override\n         public void cancel() {\n-            if (!cancelled) {\n-                cancelled = true;\n-                disposeResource();\n-            }\n-        }\n-        \n-        void disposeResource() {\n             DisposableHelper.dispose(resource);\n         }\n-        \n+\n         @Override\n         public void run() {\n-            if (!cancelled) {\n+            if (resource.get() != DisposableHelper.DISPOSED) {\n                 long r = get();\n                 \n                 if (r != 0L) {\n@@ -95,11 +86,10 @@ public void run() {\n                         decrementAndGet();\n                     }\n                 } else {\n-                    cancelled = true;\n                     try {\n                         actual.onError(new MissingBackpressureException(\"Can't deliver value \" + count + \" due to lack of requests\"));\n                     } finally {\n-                        disposeResource();\n+                        DisposableHelper.dispose(resource);\n                     }\n                 }\n             }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java\n@@ -331,9 +331,7 @@ static final class ReplaySubscriber<T> implements Subscriber<T>, Disposable {\n         long maxUpstreamRequested;\n         /** The upstream producer. */\n         volatile Subscription subscription;\n-        \n-        volatile boolean cancelled;\n-        \n+\n         public ReplaySubscriber(AtomicReference<ReplaySubscriber<T>> current,\n                 ReplayBuffer<T> buffer) {\n             this.buffer = buffer;\n@@ -344,12 +342,12 @@ public ReplaySubscriber(AtomicReference<ReplaySubscriber<T>> current,\n \n         @Override\n         public boolean isDisposed() {\n-            return cancelled;\n+            return producers.get() == TERMINATED;\n         }\n         \n         @Override\n         public void dispose() {\n-            producers.getAndSet(TERMINATED);\n+            producers.set(TERMINATED);\n             // unlike OperatorPublish, we can't null out the terminated so\n             // late subscribers can still get replay\n             // current.compareAndSet(ReplaySubscriber.this, null);\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorReplay.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorReplay.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorReplay.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorReplay.java\n@@ -314,8 +314,6 @@ static final class ReplaySubscriber<T> implements Observer<T>, Disposable {\n         /** The upstream producer. */\n         volatile Disposable subscription;\n         \n-        volatile boolean cancelled;\n-        \n         public ReplaySubscriber(AtomicReference<ReplaySubscriber<T>> current,\n                 ReplayBuffer<T> buffer) {\n             this.buffer = buffer;\n@@ -326,12 +324,12 @@ public ReplaySubscriber(AtomicReference<ReplaySubscriber<T>> current,\n \n         @Override\n         public boolean isDisposed() {\n-            return cancelled;\n+            return producers.get() == TERMINATED;\n         }\n         \n         @Override\n         public void dispose() {\n-            producers.getAndSet(TERMINATED);\n+            producers.set(TERMINATED);\n             // unlike OperatorPublish, we can't null out the terminated so\n             // late subscribers can still get replay\n             // current.compareAndSet(ReplaySubscriber.this, null);\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableInterval.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableInterval.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableInterval.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableInterval.java\n@@ -45,46 +45,36 @@ public void subscribeActual(Observer<? super Long> s) {\n     }\n     \n     static final class IntervalSubscriber\n+    extends AtomicReference<Disposable>\n     implements Disposable, Runnable {\n \n         final Observer<? super Long> actual;\n         \n         long count;\n         \n-        volatile boolean cancelled;\n-        \n-        final AtomicReference<Disposable> resource = new AtomicReference<Disposable>();\n-        \n         public IntervalSubscriber(Observer<? super Long> actual) {\n             this.actual = actual;\n         }\n         \n         @Override\n         public void dispose() {\n-            if (!cancelled) {\n-                cancelled = true;\n-                disposeResource();\n-            }\n+            DisposableHelper.dispose(this);\n         }\n \n         @Override\n         public boolean isDisposed() {\n-            return cancelled;\n+            return get() == DisposableHelper.DISPOSED;\n         }\n \n-        void disposeResource() {\n-            DisposableHelper.dispose(resource);\n-        }\n-        \n         @Override\n         public void run() {\n-            if (!cancelled) {\n+            if (get() != DisposableHelper.DISPOSED) {\n                 actual.onNext(count++);\n             }\n         }\n         \n         public void setResource(Disposable d) {\n-            DisposableHelper.setOnce(resource, d);\n+            DisposableHelper.setOnce(this, d);\n         }\n     }\n }",
    "output": "Remove explicit cancel flags where it can be inferred"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java\n--- a/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java\n+++ b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java\n@@ -84,8 +84,10 @@ public static boolean dispose(AtomicReference<Disposable> field) {\n         Disposable current = field.get();\n         if (current != DISPOSED) {\n             current = field.getAndSet(DISPOSED);\n-            if (current != null && current != DISPOSED) {\n-                current.dispose();\n+            if (current != DISPOSED) {\n+                if (current != null) {\n+                    current.dispose();\n+                }\n                 return true;\n             }\n         }\n\ndiff --git a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java\n--- a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java\n+++ b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java\n@@ -182,8 +182,10 @@ public static boolean dispose(AtomicReference<Subscription> field) {\n         Subscription current = field.get();\n         if (current != CANCELLED) {\n             current = field.getAndSet(CANCELLED);\n-            if (current != null && current != CANCELLED) { // FIXME return true if current was null?\n-                current.cancel();\n+            if (current != CANCELLED) {\n+                if (current != null) {\n+                    current.cancel();\n+                }\n                 return true;\n             }\n         }",
    "output": "Make sure the helper returns true if the pre-swap value was null"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java\n@@ -173,9 +173,7 @@ public void request(long n) {\n         \n         @Override\n         public void cancel() {\n-            if (!cancelled) {\n-                cancelled = true;\n-            }\n+            cancelled = true;\n         }\n \n         void drainLoop() {\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java\n@@ -188,9 +188,7 @@ public void request(long n) {\n         \n         @Override\n         public void cancel() {\n-            if (!cancelled) {\n-                cancelled = true;\n-            }\n+            cancelled = true;\n         }\n         \n         void dispose() {\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java\n@@ -192,9 +192,7 @@ public void request(long n) {\n         \n         @Override\n         public void cancel() {\n-            if (!cancelled) {\n-                cancelled = true;\n-            }\n+            cancelled = true;\n         }\n \n         void drainLoop() {\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java\n@@ -474,9 +474,7 @@ public void request(long n) {\n         \n         @Override\n         public void cancel() {\n-            if (!cancelled) {\n-                cancelled = true;\n-            }\n+            cancelled = true;\n         }\n         \n         @Override\n@@ -753,9 +751,7 @@ public void request(long n) {\n         \n         @Override\n         public void cancel() {\n-            if (!cancelled) {\n-                cancelled = true;\n-            }\n+            cancelled = true;\n         }\n         \n         @Override\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundary.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundary.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundary.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundary.java\n@@ -151,9 +151,7 @@ public void onComplete() {\n         \n         @Override\n         public void dispose() {\n-            if (!cancelled) {\n-                cancelled = true;\n-            }\n+            cancelled = true;\n         }\n \n         @Override\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySelector.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySelector.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySelector.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySelector.java\n@@ -173,9 +173,7 @@ void error(Throwable t) {\n         \n         @Override\n         public void dispose() {\n-            if (!cancelled) {\n-                cancelled = true;\n-            }\n+            cancelled = true;\n         }\n \n         @Override\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySupplier.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySupplier.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySupplier.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySupplier.java\n@@ -169,9 +169,7 @@ public void onComplete() {\n         \n         @Override\n         public void dispose() {\n-            if (!cancelled) {\n-                cancelled = true;\n-            }\n+            cancelled = true;\n         }\n \n         @Override\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowTimed.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowTimed.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowTimed.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowTimed.java\n@@ -404,9 +404,7 @@ public void onComplete() {\n         \n         @Override\n         public void dispose() {\n-            if (!cancelled) {\n-                cancelled = true;\n-            }\n+            cancelled = true;\n         }\n \n         @Override\n@@ -636,9 +634,7 @@ public void onComplete() {\n         \n         @Override\n         public void dispose() {\n-            if (!cancelled) {\n-                cancelled = true;\n-            }\n+            cancelled = true;\n         }\n \n         @Override\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableGenerate.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableGenerate.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableGenerate.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableGenerate.java\n@@ -113,9 +113,7 @@ private void dispose(S s) {\n         \n         @Override\n         public void dispose() {\n-            if (!cancelled) {\n-                cancelled = true;\n-            }\n+            cancelled = true;\n         }\n \n         @Override",
    "output": "Remove some superfluous reads before writes"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java\n@@ -159,17 +159,11 @@ public AmbInnerSubscriber(AmbCoordinator<T> parent, int index, Subscriber<? supe\n         \n         @Override\n         public void onSubscribe(Subscription s) {\n-            if (!compareAndSet(null, s)) {\n-                s.cancel();\n-                if (get() != SubscriptionHelper.CANCELLED) {\n-                    SubscriptionHelper.reportSubscriptionSet();\n+            if (SubscriptionHelper.setOnce(this, s)) {\n+                long r = missedRequested.getAndSet(0L);\n+                if (r != 0L) {\n+                    s.request(r);\n                 }\n-                return;\n-            }\n-            \n-            long r = missedRequested.getAndSet(0L);\n-            if (r != 0L) {\n-                s.request(r);\n             }\n         }\n         \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java\n@@ -354,14 +354,9 @@ public CombinerSubscriber(LatestCoordinator<T, R> parent, int index) {\n         \n         @Override\n         public void onSubscribe(Subscription s) {\n-            if (!this.s.compareAndSet(null, s)) {\n-                s.cancel();\n-                if (this.s.get() != SubscriptionHelper.CANCELLED) {\n-                    SubscriptionHelper.reportSubscriptionSet();\n-                }\n-                return;\n+            if (SubscriptionHelper.setOnce(this.s, s)) {\n+                s.request(parent.bufferSize);\n             }\n-            s.request(parent.bufferSize);\n         }\n         \n         @Override\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java\n@@ -580,15 +580,10 @@ public InnerSubscriber(MergeSubscriber<T, U> parent, long id) {\n         }\n         @Override\n         public void onSubscribe(Subscription s) {\n-            if (!compareAndSet(null, s)) {\n-                s.cancel();\n-                if (get() != SubscriptionHelper.CANCELLED) {\n-                    SubscriptionHelper.reportSubscriptionSet();\n-                }\n-                return;\n+            if (SubscriptionHelper.setOnce(this, s)) {\n+                outstanding = bufferSize;\n+                s.request(outstanding);\n             }\n-            outstanding = bufferSize;\n-            s.request(outstanding);\n         }\n         @Override\n         public void onNext(U t) {\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java\n@@ -256,14 +256,9 @@ public boolean isDisposed() {\n         \n         @Override\n         public void onSubscribe(Subscription s) {\n-            if (!this.s.compareAndSet(null, s)) {\n-                s.cancel();\n-                if (this.s.get() != SubscriptionHelper.CANCELLED) {\n-                    SubscriptionHelper.reportSubscriptionSet();\n-                }\n-                return;\n+            if (SubscriptionHelper.setOnce(this.s, s)) {\n+                s.request(bufferSize);\n             }\n-            s.request(bufferSize);\n         }\n         \n         @Override\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java\n@@ -337,14 +337,9 @@ public SwitchMapInnerSubscriber(SwitchMapSubscriber<T, R> parent, long index, in\n         @Override\n         public void onSubscribe(Subscription s) {\n             if (index == parent.unique) {\n-                if (!compareAndSet(null, s)) {\n-                    s.cancel();\n-                    if (get() != SubscriptionHelper.CANCELLED) {\n-                        SubscriptionHelper.reportSubscriptionSet();\n-                    }\n-                    return;\n+                if (SubscriptionHelper.setOnce(this, s)) {\n+                    s.request(bufferSize);\n                 }\n-                s.request(bufferSize);\n             } else {\n                 s.cancel();\n             }\n\ndiff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java\n--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java\n+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java\n@@ -82,13 +82,8 @@ public WithLatestFromSubscriber(Subscriber<? super R> actual, BiFunction<? super\n         }\n         @Override\n         public void onSubscribe(Subscription s) {\n-            if (this.s.compareAndSet(null, s)) {\n+            if (SubscriptionHelper.setOnce(this.s, s)) {\n                 actual.onSubscribe(this);\n-            } else {\n-                s.cancel();\n-                if (this.s.get() != SubscriptionHelper.CANCELLED) {\n-                    SubscriptionHelper.reportSubscriptionSet();\n-                }\n             }\n         }\n         \n\ndiff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSwitchMap.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSwitchMap.java\n--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSwitchMap.java\n+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSwitchMap.java\n@@ -24,7 +24,6 @@\n import io.reactivex.functions.Function;\n import io.reactivex.internal.disposables.DisposableHelper;\n import io.reactivex.internal.queue.*;\n-import io.reactivex.internal.subscriptions.SubscriptionHelper;\n import io.reactivex.internal.util.Pow2;\n import io.reactivex.plugins.RxJavaPlugins;\n \n@@ -306,13 +305,7 @@ public SwitchMapInnerSubscriber(SwitchMapSubscriber<T, R> parent, long index, in\n         @Override\n         public void onSubscribe(Disposable s) {\n             if (index == parent.unique) {\n-                if (!compareAndSet(null, s)) {\n-                    s.dispose();\n-                    if (get() != DisposableHelper.DISPOSED) {\n-                        SubscriptionHelper.reportSubscriptionSet();\n-                    }\n-                    return;\n-                }\n+                DisposableHelper.setOnce(this, s);\n             } else {\n                 s.dispose();\n             }\n\ndiff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/DisposableSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/DisposableSubscriber.java\n--- a/src/main/java/io/reactivex/internal/subscribers/flowable/DisposableSubscriber.java\n+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/DisposableSubscriber.java\n@@ -30,14 +30,9 @@ public abstract class DisposableSubscriber<T> implements Subscriber<T>, Disposab\n \n     @Override\n     public final void onSubscribe(Subscription s) {\n-        if (!this.s.compareAndSet(null, s)) {\n-            s.cancel();\n-            if (this.s.get() != SubscriptionHelper.CANCELLED) {\n-                SubscriptionHelper.reportSubscriptionSet();\n-            }\n-            return;\n+        if (SubscriptionHelper.setOnce(this.s, s)) {\n+            onStart();\n         }\n-        onStart();\n     }\n     \n     protected final Subscription subscription() {\n\ndiff --git a/src/main/java/io/reactivex/internal/subscribers/observable/NbpDisposableSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/observable/NbpDisposableSubscriber.java\n--- a/src/main/java/io/reactivex/internal/subscribers/observable/NbpDisposableSubscriber.java\n+++ b/src/main/java/io/reactivex/internal/subscribers/observable/NbpDisposableSubscriber.java\n@@ -18,7 +18,6 @@\n \n import io.reactivex.Observer;\n import io.reactivex.disposables.Disposable;\n-import io.reactivex.internal.subscriptions.SubscriptionHelper;\n \n /**\n  * An abstract subscription that allows asynchronous cancellation.\n@@ -30,14 +29,9 @@ public abstract class NbpDisposableSubscriber<T> implements Observer<T>, Disposa\n \n     @Override\n     public final void onSubscribe(Disposable s) {\n-        if (!this.s.compareAndSet(null, s)) {\n-            s.dispose();\n-            if (this.s.get() != DisposableHelper.DISPOSED) {\n-                SubscriptionHelper.reportSubscriptionSet();\n-            }\n-            return;\n+        if (DisposableHelper.setOnce(this.s, s)) {\n+            onStart();\n         }\n-        onStart();\n     }\n     \n     protected void onStart() {",
    "output": "Use more DisposableHelper and SubscriptionHelper in operators"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java\n--- a/src/main/java/io/reactivex/Observable.java\n+++ b/src/main/java/io/reactivex/Observable.java\n@@ -3106,7 +3106,7 @@ public Collection<V> apply(K k) {\n         });\n     }\n     \n-    public final Flowable<T> toObservable(BackpressureStrategy strategy) {\n+    public final Flowable<T> toFlowable(BackpressureStrategy strategy) {\n         Flowable<T> o = Flowable.create(new Publisher<T>() {\n             @Override\n             public void subscribe(final Subscriber<? super T> s) {",
    "output": "Upgrade conversion method name to reflect new base type names"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/schedulers/TestScheduler.java b/src/main/java/io/reactivex/schedulers/TestScheduler.java\n--- a/src/main/java/io/reactivex/schedulers/TestScheduler.java\n+++ b/src/main/java/io/reactivex/schedulers/TestScheduler.java\n@@ -14,6 +14,7 @@\n package io.reactivex.schedulers;\n \n import java.util.*;\n+import java.util.concurrent.PriorityBlockingQueue;\n import java.util.concurrent.TimeUnit;\n \n import io.reactivex.Scheduler;\n@@ -28,7 +29,7 @@\n  */\n public final class TestScheduler extends Scheduler {\n     /** The ordered queue for the runnable tasks. */\n-    private final Queue<TimedRunnable> queue = new PriorityQueue<TimedRunnable>(11);\n+    private final Queue<TimedRunnable> queue = new PriorityBlockingQueue<TimedRunnable>(11);\n     /** The per-scheduler global order counter. */\n     long counter;\n \n@@ -61,7 +62,7 @@ public int compareTo(TimedRunnable o) {\n     }\n \n     // Storing time in nanoseconds internally.\n-    private long time;\n+    private volatile long time;\n \n     @Override\n     public long now(TimeUnit unit) {\n\ndiff --git a/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java b/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java\n--- a/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java\n+++ b/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java\n@@ -14,9 +14,13 @@\n package io.reactivex.schedulers;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n import static org.mockito.Matchers.anyLong;\n import static org.mockito.Mockito.*;\n \n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n@@ -216,4 +220,5 @@ public void run() {\n             inner.dispose();\n         }\n     }\n+\n }\n\\ No newline at end of file",
    "output": "Add support for concurrently inserting actions while advancing time\n\n* Adding support for concurrently inserting actions while advancing time\r\n\r\n* Removing the unit test proving the thread safety of\r\na BlockingPriorityQueue"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/schedulers/SchedulerLifecycleTest.java b/src/test/java/io/reactivex/schedulers/SchedulerLifecycleTest.java\n--- a/src/test/java/io/reactivex/schedulers/SchedulerLifecycleTest.java\n+++ b/src/test/java/io/reactivex/schedulers/SchedulerLifecycleTest.java\n@@ -18,7 +18,7 @@\n import java.util.*;\n import java.util.concurrent.*;\n \n-import org.junit.Test;\n+import org.junit.*;\n \n import io.reactivex.Scheduler.Worker;\n import io.reactivex.disposables.CompositeDisposable;\n@@ -109,10 +109,10 @@ public void testStartIdempotence() throws InterruptedException {\n         System.out.println(\"testStartIdempotence >> giving some time\");\n         Thread.sleep(500);\n         \n-        Set<Thread> rxThreads = new HashSet<Thread>();\n+        Set<Thread> rxThreadsBefore = new HashSet<Thread>();\n         for (Thread t : Thread.getAllStackTraces().keySet()) {\n             if (t.getName().startsWith(\"Rx\")) {\n-                rxThreads.add(t);\n+                rxThreadsBefore.add(t);\n                 System.out.println(\"testStartIdempotence >> \" + t);\n             }\n         }\n@@ -121,14 +121,17 @@ public void testStartIdempotence() throws InterruptedException {\n         System.out.println(\"testStartIdempotence >> giving some time again\");\n         Thread.sleep(500);\n         \n-        Set<Thread> rxThreads2 = new HashSet<Thread>();\n+        Set<Thread> rxThreadsAfter = new HashSet<Thread>();\n         for (Thread t : Thread.getAllStackTraces().keySet()) {\n             if (t.getName().startsWith(\"Rx\")) {\n-                rxThreads2.add(t);\n+                rxThreadsAfter.add(t);\n                 System.out.println(\"testStartIdempotence >>>> \" + t);\n             }\n         }\n+\n+        // cached threads may get dropped between the two checks\n+        rxThreadsAfter.removeAll(rxThreadsBefore);\n         \n-        assertEquals(rxThreads, rxThreads2);\n+        Assert.assertTrue(\"Some new threads appeared: \" + rxThreadsAfter, rxThreadsAfter.isEmpty());\n     }\n }\n\\ No newline at end of file",
    "output": "Fix SchedulerLifecycle.testStartIdempotence vs cached threads dying"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/observables/BlockingObservable.java b/src/main/java/io/reactivex/observables/BlockingObservable.java\n--- a/src/main/java/io/reactivex/observables/BlockingObservable.java\n+++ b/src/main/java/io/reactivex/observables/BlockingObservable.java\n@@ -164,57 +164,35 @@ public Optional<T> firstOption() {\n     }\n     \n     public T first() {\n-        Optional<T> o = firstOption();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        throw new NoSuchElementException();\n+        return firstOption().get();\n     }\n     \n     public T first(T defaultValue) {\n-        Optional<T> o = firstOption();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        return defaultValue;\n+        return firstOption().orElse(defaultValue);\n     }\n     \n     public Optional<T> lastOption() {\n         return stream().reduce((a, b) -> b);\n     }\n     \n     public T last() {\n-        Optional<T> o = lastOption();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        throw new NoSuchElementException();\n+        return lastOption().get();\n     }\n     \n     public T last(T defaultValue) {\n-        Optional<T> o = lastOption();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        return defaultValue;\n+        return lastOption().orElse(defaultValue);\n     }\n     \n     public T single() {\n         Iterator<T> it = iterate(Observable.fromPublisher(o).single());\n         Optional<T> o = makeStream(it, false).findFirst();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        throw new NoSuchElementException();\n+        return o.get();\n     }\n     \n     public T single(T defaultValue) {\n         Iterator<T> it = iterate(Observable.<T>fromPublisher(o).single(defaultValue));\n         Optional<T> o = makeStream(it, false).findFirst();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        return defaultValue;\n+        return o.orElse(defaultValue);\n     }\n     \n     public Iterable<T> mostRecent(T initialValue) {\n\ndiff --git a/src/main/java/io/reactivex/observables/nbp/NbpBlockingObservable.java b/src/main/java/io/reactivex/observables/nbp/NbpBlockingObservable.java\n--- a/src/main/java/io/reactivex/observables/nbp/NbpBlockingObservable.java\n+++ b/src/main/java/io/reactivex/observables/nbp/NbpBlockingObservable.java\n@@ -159,58 +159,36 @@ public Optional<T> firstOption() {\n     }\n     \n     public T first() {\n-        Optional<T> o = firstOption();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        throw new NoSuchElementException();\n+        return firstOption().get();\n     }\n     \n     public T first(T defaultValue) {\n-        Optional<T> o = firstOption();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        return defaultValue;\n+        return firstOption().orElse(defaultValue);\n     }\n     \n     public Optional<T> lastOption() {\n         return stream().reduce((a, b) -> b);\n     }\n     \n     public T last() {\n-        Optional<T> o = lastOption();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        throw new NoSuchElementException();\n+        return lastOption().get();\n     }\n     \n     public T last(T defaultValue) {\n-        Optional<T> o = lastOption();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        return defaultValue;\n+        return lastOption().orElse(defaultValue);\n     }\n     \n     public T single() {\n         Iterator<T> it = iterate(o.single());\n         Optional<T> o = makeStream(it, false).findFirst();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        throw new NoSuchElementException();\n+        return o.get();\n     }\n     \n     public T single(T defaultValue) {\n         @SuppressWarnings(\"unchecked\")\n         Iterator<T> it = iterate(((NbpObservable<T>)o).single(defaultValue));\n         Optional<T> o = makeStream(it, false).findFirst();\n-        if (o.isPresent()) {\n-            return o.get();\n-        }\n-        return defaultValue;\n+        return o.orElse(defaultValue);\n     }\n     \n     public Iterable<T> mostRecent(T initialValue) {",
    "output": "Remove duplication of Optional API behavior.\n\nget() throws NSE when absent and orElse(T) returns the provided value when absent"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java\n--- a/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java\n+++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java\n@@ -79,7 +79,7 @@ public final boolean offer(final T e) {\n             if (null == lvElement(buffer, lookAheadElementOffset)) {// LoadLoad\n                 producerLookAhead = index + lookAheadStep - 1; // joy, there's plenty of room\n                 return writeToQueue(buffer, e, index, offset);\n-            } else if (null != lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full\n+            } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full\n                 return writeToQueue(buffer, e, index, offset);\n             } else {\n                 resize(buffer, index, offset, e, mask); // add a buffer and link old to new",
    "output": "Fix SpscLinkedArrayQueue leaves 1 slot null just before growing"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/OperatorTake.java b/src/main/java/io/reactivex/internal/operators/OperatorTake.java\n--- a/src/main/java/io/reactivex/internal/operators/OperatorTake.java\n+++ b/src/main/java/io/reactivex/internal/operators/OperatorTake.java\n@@ -62,9 +62,10 @@ public void onSubscribe(Subscription s) {\n         }\n         @Override\n         public void onNext(T t) {\n-            if (!done) {\n+            if (!done && remaining-- > 0) {\n+                boolean stop = remaining == 0;\n                 actual.onNext(t);\n-                if (--remaining == 0L) {\n+                if (stop) {\n                     onComplete();\n                 }\n             }\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/OperatorTakeTest.java b/src/test/java/io/reactivex/internal/operators/OperatorTakeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/OperatorTakeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/OperatorTakeTest.java\n@@ -30,6 +30,7 @@\n import io.reactivex.exceptions.TestException;\n import io.reactivex.internal.subscriptions.*;\n import io.reactivex.schedulers.Schedulers;\n+import io.reactivex.subjects.PublishSubject;\n import io.reactivex.subscribers.TestSubscriber;\n \n public class OperatorTakeTest {\n@@ -420,4 +421,19 @@ public void onNext(Integer t) {\n         ts.assertError(TestException.class);\n         ts.assertNotComplete();\n     }\n+    \n+    @Test\n+    public void testReentrantTake() {\n+        PublishSubject<Integer> source = PublishSubject.create();\n+        \n+        TestSubscriber<Integer> ts = new TestSubscriber<>();\n+        \n+        source.take(1).doOnNext(v -> source.onNext(2)).subscribe(ts);\n+        \n+        source.onNext(1);\n+        \n+        ts.assertValue(1);\n+        ts.assertNoErrors();\n+        ts.assertComplete();\n+    }\n }\n\\ No newline at end of file\n\ndiff --git a/src/test/java/io/reactivex/internal/operators/nbp/NbpOperatorTakeTest.java b/src/test/java/io/reactivex/internal/operators/nbp/NbpOperatorTakeTest.java\n--- a/src/test/java/io/reactivex/internal/operators/nbp/NbpOperatorTakeTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/nbp/NbpOperatorTakeTest.java\n@@ -31,6 +31,7 @@\n import io.reactivex.exceptions.TestException;\n import io.reactivex.internal.disposables.EmptyDisposable;\n import io.reactivex.schedulers.Schedulers;\n+import io.reactivex.subjects.nbp.NbpPublishSubject;\n import io.reactivex.subscribers.nbp.NbpTestSubscriber;\n \n public class NbpOperatorTakeTest {\n@@ -338,4 +339,19 @@ public void onNext(Integer t) {\n         ts.assertError(TestException.class);\n         ts.assertNotComplete();\n     }\n+    \n+    @Test\n+    public void testReentrantTake() {\n+        NbpPublishSubject<Integer> source = NbpPublishSubject.create();\n+        \n+        NbpTestSubscriber<Integer> ts = new NbpTestSubscriber<>();\n+        \n+        source.take(1).doOnNext(v -> source.onNext(2)).subscribe(ts);\n+        \n+        source.onNext(1);\n+        \n+        ts.assertValue(1);\n+        ts.assertNoErrors();\n+        ts.assertComplete();\n+    }\n }\n\\ No newline at end of file",
    "output": "Fix take() reentrancy problem. Discovered by @mgp in #3346 and using his supplied fix. I've already applied it to NbpObservable's take this Monday so all that's left was the unit test"
  },
  {
    "input": "diff --git a/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java b/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java\n--- a/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java\n+++ b/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java\n@@ -131,8 +131,10 @@ public void testSimpleAsyncConcat() {\n \n     @Test\n     public void testNestedAsyncConcatLoop() throws Throwable {\n-        for (int i = 0; i < 100; i++) {\n-            System.out.println(\"testNestedAsyncConcat >> \" + i);\n+        for (int i = 0; i < 500; i++) {\n+            if (i % 10 == 0) {\n+                System.out.println(\"testNestedAsyncConcat >> \" + i);\n+            }\n             testNestedAsyncConcat();\n         }\n     }\n@@ -151,6 +153,9 @@ public void testNestedAsyncConcat() throws Throwable {\n \n         final AtomicReference<Thread> parent = new AtomicReference<>();\n         final CountDownLatch parentHasStarted = new CountDownLatch(1);\n+        final CountDownLatch parentHasFinished = new CountDownLatch(1);\n+        \n+        \n         Observable<Observable<String>> observableOfObservables = Observable.create(new Publisher<Observable<String>>() {\n \n             @Override\n@@ -198,6 +203,7 @@ public void run() {\n                         } finally {\n                             System.out.println(\"Done parent Observable\");\n                             observer.onComplete();\n+                            parentHasFinished.countDown();\n                         }\n                     }\n                 }));\n@@ -246,6 +252,15 @@ public void run() {\n             throw new RuntimeException(\"failed waiting on threads\", e);\n         }\n \n+        try {\n+            // wait for the parent to complete\n+            if (!parentHasFinished.await(5, TimeUnit.SECONDS)) {\n+                fail(\"Parent didn't finish within the time limit\");\n+            }\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"failed waiting on threads\", e);\n+        }\n+        \n         inOrder.verify(observer, times(1)).onNext(\"seven\");\n         inOrder.verify(observer, times(1)).onNext(\"eight\");\n         inOrder.verify(observer, times(1)).onNext(\"nine\");",
    "output": "Fix testNestedAsyncConcat not waiting for the parent to complete and misses the last onComplete"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/operators/OperatorReplay.java b/src/main/java/io/reactivex/internal/operators/OperatorReplay.java\n--- a/src/main/java/io/reactivex/internal/operators/OperatorReplay.java\n+++ b/src/main/java/io/reactivex/internal/operators/OperatorReplay.java\n@@ -23,8 +23,8 @@\n import io.reactivex.Observable;\n import io.reactivex.Scheduler;\n import io.reactivex.disposables.Disposable;\n-import io.reactivex.internal.subscriptions.EmptySubscription;\n-import io.reactivex.internal.util.NotificationLite;\n+import io.reactivex.internal.subscriptions.*;\n+import io.reactivex.internal.util.*;\n import io.reactivex.observables.ConnectableObservable;\n import io.reactivex.plugins.RxJavaPlugins;\n import io.reactivex.schedulers.Timed;\n@@ -555,8 +555,7 @@ public InnerSubscription(ReplaySubscriber<T> parent, Subscriber<? super T> child\n         @Override\n         public void request(long n) {\n             // ignore negative requests\n-            if (n < 0) {\n-                RxJavaPlugins.onError(new IllegalArgumentException(\"n > 0 required but it was \" + n));\n+            if (SubscriptionHelper.validateRequest(n)) {\n                 return;\n             }\n             // In general, RxJava doesn't prevent concurrent requests (with each other or with\n@@ -574,16 +573,12 @@ public void request(long n) {\n                     return;\n                 }\n                 // otherwise, increase the request count\n-                long u = r + n;\n-                // and check for long overflow\n-                if (u < 0) {\n-                    // cap at max value, which is essentially unlimited\n-                    u = Long.MAX_VALUE;\n-                }\n+                long u = BackpressureHelper.addCap(r, n);\n+                \n                 // try setting the new request value\n                 if (compareAndSet(r, u)) {\n                     // increment the total request counter\n-                    addTotalRequested(n);\n+                    BackpressureHelper.add(totalRequested, n);\n                     // if successful, notify the parent dispacher this child can receive more\n                     // elements\n                     parent.manageRequests();\n@@ -596,23 +591,6 @@ public void request(long n) {\n             }\n         }\n         \n-        /**\n-         * Increments the total requested amount.\n-         * @param n the additional request amount\n-         */\n-        void addTotalRequested(long n) {\n-            for (;;) {\n-                long r = totalRequested.get();\n-                long u = r + n;\n-                if (u < 0) {\n-                    u = Long.MAX_VALUE;\n-                }\n-                if (totalRequested.compareAndSet(r, u)) {\n-                    return;\n-                }\n-            }\n-        }\n-        \n         /**\n          * Indicate that values have been emitted to this child subscriber by the dispatch() method.\n          * @param n the number of items emitted\n@@ -756,6 +734,8 @@ public void replay(InnerSubscription<T> output) {\n                 }\n                 output.emitting = true;\n             }\n+            final Subscriber<? super T> child = output.child;\n+            \n             for (;;) {\n                 if (output.isDisposed()) {\n                     return;\n@@ -772,13 +752,13 @@ public void replay(InnerSubscription<T> output) {\n                 while (r != 0L && destIndex < sourceIndex) {\n                     Object o = get(destIndex);\n                     try {\n-                        if (NotificationLite.accept(o, output.child)) {\n+                        if (NotificationLite.accept(o, child)) {\n                             return;\n                         }\n                     } catch (Throwable err) {\n                         output.dispose();\n                         if (!NotificationLite.isError(o) && !NotificationLite.isComplete(o)) {\n-                            output.child.onError(err);\n+                            child.onError(err);\n                         }\n                         return;\n                     }\n\ndiff --git a/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java\n--- a/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java\n+++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java\n@@ -47,7 +47,7 @@ public MpscLinkedQueue() {\n      */\n     @Override\n     public final boolean offer(final T nextValue) {\n-        final LinkedQueueNode<T> nextNode = new LinkedQueueNode<>();\n+        final LinkedQueueNode<T> nextNode = new LinkedQueueNode<>(nextValue);\n         final LinkedQueueNode<T> prevProducerNode = xchgProducerNode(nextNode);\n         // Should a producer thread get interrupted here the chain WILL be broken until that thread is resumed\n         // and completes the store in prev.next.\n\ndiff --git a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java\n--- a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java\n+++ b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java\n@@ -68,8 +68,7 @@ private long addRequested(long n) {\n     \n     @Override\n     public void request(long n) {\n-        if (n <= 0) {\n-            RxJavaPlugins.onError(new IllegalArgumentException(\"n > 0 required but it was \" + n));\n+        if (SubscriptionHelper.validateRequest(n)) {\n             return;\n         }\n         if (cancelled) {\n\ndiff --git a/src/main/java/io/reactivex/internal/util/NotificationLite.java b/src/main/java/io/reactivex/internal/util/NotificationLite.java\n--- a/src/main/java/io/reactivex/internal/util/NotificationLite.java\n+++ b/src/main/java/io/reactivex/internal/util/NotificationLite.java\n@@ -28,6 +28,10 @@ public enum NotificationLite {\n      */\n     private enum Complete {\n         INSTANCE;\n+        @Override\n+        public String toString() {\n+            return \"NotificationLite.Complete\";\n+        };\n     }\n     \n     /**\n@@ -40,6 +44,11 @@ private static final class ErrorNotification implements Serializable {\n         ErrorNotification(Throwable e) {\n             this.e = e;\n         }\n+        \n+        @Override\n+        public String toString() {\n+            return \"NotificationLite.Error[\" + e + \"]\";\n+        }\n     }\n     \n     /**\n@@ -52,6 +61,11 @@ private static final class SubscriptionNotification implements Serializable {\n         SubscriptionNotification(Subscription s) {\n             this.s = s;\n         }\n+        \n+        @Override\n+        public String toString() {\n+            return \"NotificationLite.Subscription[\" + s + \"]\";\n+        }\n     }\n     \n     /**",
    "output": "Fix to MpscLinkedQueue, some minor refactorings"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/internal/subscribers/EmptySubscriber.java b/src/main/java/io/reactivex/internal/subscribers/EmptySubscriber.java\n--- a/src/main/java/io/reactivex/internal/subscribers/EmptySubscriber.java\n+++ b/src/main/java/io/reactivex/internal/subscribers/EmptySubscriber.java\n@@ -21,7 +21,16 @@\n  * A subscriber that ignores all events (onError is forwarded to RxJavaPlugins though).\n  */\n public enum EmptySubscriber implements Subscriber<Object> {\n-    INSTANCE;\n+    /** Empty instance that reports error to the plugins. */\n+    INSTANCE(true),\n+    /** Empty instance that doesn't report to the plugins to avoid flooding the test output. */\n+    INSTANCE_NOERROR(false);\n+    \n+    final boolean reportError;\n+    \n+    EmptySubscriber(boolean reportError) {\n+        this.reportError = reportError;\n+    }\n     \n     @Override\n     public void onSubscribe(Subscription s) {\n@@ -35,7 +44,9 @@ public void onNext(Object t) {\n     \n     @Override\n     public void onError(Throwable t) {\n-        RxJavaPlugins.onError(t);\n+        if (reportError) {\n+            RxJavaPlugins.onError(t);\n+        }\n     }\n     \n     @Override\n\ndiff --git a/src/main/java/io/reactivex/subscribers/TestSubscriber.java b/src/main/java/io/reactivex/subscribers/TestSubscriber.java\n--- a/src/main/java/io/reactivex/subscribers/TestSubscriber.java\n+++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java\n@@ -85,7 +85,7 @@ public void cancel() {\n      * Constructs a non-forwarding TestSubscriber with an initial request value of Long.MAX_VALUE.\n      */\n     public TestSubscriber() {\n-        this(EmptySubscriber.INSTANCE, Long.MAX_VALUE);\n+        this(EmptySubscriber.INSTANCE_NOERROR, Long.MAX_VALUE);\n     }\n \n     /**\n@@ -95,7 +95,7 @@ public TestSubscriber() {\n      * @param initialRequest the initial request value if not null\n      */\n     public TestSubscriber(Long initialRequest) {\n-        this(EmptySubscriber.INSTANCE, initialRequest);\n+        this(EmptySubscriber.INSTANCE_NOERROR, initialRequest);\n     }\n \n     /**\n\ndiff --git a/src/test/java/io/reactivex/BackpressureTests.java b/src/test/java/io/reactivex/BackpressureTests.java\n--- a/src/test/java/io/reactivex/BackpressureTests.java\n+++ b/src/test/java/io/reactivex/BackpressureTests.java\n@@ -51,9 +51,12 @@ public void request(long n) {\n             }\n             if (compareAndSet(false, true)) {\n                 int i = 0;\n+                final Subscriber<? super Integer> a = s;\n+                final AtomicInteger c = counter;\n+                \n                 while (!cancelled) {\n-                    s.onNext(i++);\n-                    counter.incrementAndGet();\n+                    a.onNext(i++);\n+                    c.incrementAndGet();\n                 }\n                 System.out.println(\"unsubscribed after: \" + i);\n             }\n@@ -464,6 +467,13 @@ public void testFirehoseFailsAsExpected() {\n         \n         ts.assertError(MissingBackpressureException.class);\n     }\n+    \n+    @Test\n+    public void testFirehoseFailsAsExpectedLoop() {\n+        for (int i = 0; i < 1000; i++) {\n+            testFirehoseFailsAsExpected();\n+        }\n+    }\n \n     @Test(timeout = 10000)\n     public void testOnBackpressureDrop() {",
    "output": "Fix attempt to the firehose test"
  },
  {
    "input": "diff --git a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java\n--- a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java\n+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java\n@@ -36,13 +36,17 @@ public final class RxJavaPlugins {\n     static volatile Function<Scheduler, Scheduler> onInitSingleHandler;\n     \n     static volatile Function<Scheduler, Scheduler> onInitIOHandler;\n+\n+    static volatile Function<Scheduler, Scheduler> onInitNewThreadHandler;\n     \n     static volatile Function<Scheduler, Scheduler> onComputationHandler;\n     \n     static volatile Function<Scheduler, Scheduler> onSingleHandler;\n     \n     static volatile Function<Scheduler, Scheduler> onIOHandler;\n-    \n+\n+    static volatile Function<Scheduler, Scheduler> onNewThreadHandler;\n+\n     /** Prevents changing the plugins. */\n     private static volatile boolean lockdown;\n     \n@@ -83,15 +87,23 @@ public static Function<Scheduler, Scheduler> getInitComputationSchedulerHandler(\n     public static Function<Scheduler, Scheduler> getInitIOSchedulerHandler() {\n         return onInitIOHandler;\n     }\n-    \n+\n+    public static Function<Scheduler, Scheduler> getInitNewThreadSchedulerHandler() {\n+        return onInitNewThreadHandler;\n+    }\n+\n     public static Function<Scheduler, Scheduler> getInitSingleSchedulerHandler() {\n         return onInitSingleHandler;\n     }\n \n     public static Function<Scheduler, Scheduler> getIOSchedulerHandler() {\n         return onIOHandler;\n     }\n-    \n+\n+    public static Function<Scheduler, Scheduler> getNewThreadSchedulerHandler() {\n+        return onNewThreadHandler;\n+    }\n+\n     public static Function<Runnable, Runnable> getScheduleHandler() {\n         return onScheduleHandler;\n     }\n@@ -119,6 +131,14 @@ public static Scheduler initIOScheduler(Scheduler defaultScheduler) {\n         return f.apply(defaultScheduler);\n     }\n \n+    public static Scheduler initNewThreadScheduler(Scheduler defaultScheduler) {\n+        Function<Scheduler, Scheduler> f = onInitNewThreadHandler;\n+        if (f == null) {\n+            return defaultScheduler;\n+        }\n+        return f.apply(defaultScheduler);\n+    }\n+\n     public static Scheduler initSingleScheduler(Scheduler defaultScheduler) {\n         Function<Scheduler, Scheduler> f = onInitSingleHandler;\n         if (f == null) {\n@@ -179,6 +199,14 @@ public static Scheduler onIOScheduler(Scheduler defaultScheduler) {\n         return f.apply(defaultScheduler);\n     }\n \n+    public static Scheduler onNewThreadScheduler(Scheduler defaultScheduler) {\n+        Function<Scheduler, Scheduler> f = onNewThreadHandler;\n+        if (f == null) {\n+            return defaultScheduler;\n+        }\n+        return f.apply(defaultScheduler);\n+    }\n+\n     /**\n      * Called when a task is scheduled.\n      * @param run\n@@ -225,10 +253,15 @@ public static void reset() {\n         \n         setComputationSchedulerHandler(null);\n         setInitComputationSchedulerHandler(null);\n-        setInitIOSchedulerHandler(null);\n+        \n         setIOSchedulerHandler(null);\n-        setInitSingleSchedulerHandler(null);\n+        setInitIOSchedulerHandler(null);\n+\n         setSingleSchedulerHandler(null);\n+        setInitSingleSchedulerHandler(null);\n+\n+        setNewThreadSchedulerHandler(null);\n+        setInitNewThreadSchedulerHandler(null);\n     }\n \n     public static void setComputationSchedulerHandler(Function<Scheduler, Scheduler> handler) {\n@@ -267,6 +300,14 @@ public static void setInitIOSchedulerHandler(Function<Scheduler, Scheduler> hand\n         onInitIOHandler = handler;\n     }\n \n+    public static void setInitNewThreadSchedulerHandler(Function<Scheduler, Scheduler> handler) {\n+        if (lockdown) {\n+            throw new IllegalStateException(\"Plugins can't be changed anymore\");\n+        }\n+        onInitNewThreadHandler = handler;\n+    }\n+\n+    \n     public static void setInitSingleSchedulerHandler(Function<Scheduler, Scheduler> handler) {\n         if (lockdown) {\n             throw new IllegalStateException(\"Plugins can't be changed anymore\");\n@@ -281,6 +322,13 @@ public static void setIOSchedulerHandler(Function<Scheduler, Scheduler> handler)\n         onIOHandler = handler;\n     }\n \n+    public static void setNewThreadSchedulerHandler(Function<Scheduler, Scheduler> handler) {\n+        if (lockdown) {\n+            throw new IllegalStateException(\"Plugins can't be changed anymore\");\n+        }\n+        onNewThreadHandler = handler;\n+    }\n+\n     public static void setScheduleHandler(Function<Runnable, Runnable> handler) {\n         if (lockdown) {\n             throw new IllegalStateException(\"Plugins can't be changed anymore\");\n\ndiff --git a/src/main/java/io/reactivex/schedulers/Schedulers.java b/src/main/java/io/reactivex/schedulers/Schedulers.java\n--- a/src/main/java/io/reactivex/schedulers/Schedulers.java\n+++ b/src/main/java/io/reactivex/schedulers/Schedulers.java\n@@ -50,7 +50,7 @@ private Schedulers() {\n         \n         TRAMPOLINE = TrampolineScheduler.instance();\n         \n-        NEW_THREAD = NewThreadScheduler.instance();\n+        NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(NewThreadScheduler.instance());\n     }\n     \n     public static Scheduler computation() {\n@@ -70,7 +70,7 @@ public static Scheduler trampoline() {\n     }\n \n     public static Scheduler newThread() {\n-        return NEW_THREAD;\n+        return RxJavaPlugins.onNewThreadScheduler(NEW_THREAD);\n     }\n     \n     /*",
    "output": "Add plugin handler for creating and receiving the new thread scheduler"
  },
  {
    "input": "diff --git a/src/main/java/rx/functions/Actions.java b/src/main/java/rx/functions/Actions.java\n--- a/src/main/java/rx/functions/Actions.java\n+++ b/src/main/java/rx/functions/Actions.java\n@@ -24,7 +24,7 @@ private Actions() {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> empty() {\n+    public static <T0, T1, T2, T3, T4, T5, T6, T7, T8> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> empty() {\n         return EMPTY_ACTION;\n     }\n ",
    "output": "Remove redundant final modifier from static method in Actions"
  },
  {
    "input": "diff --git a/src/main/java/rx/Notification.java b/src/main/java/rx/Notification.java\n--- a/src/main/java/rx/Notification.java\n+++ b/src/main/java/rx/Notification.java\n@@ -162,7 +162,7 @@ public void accept(Observer<? super T> observer) {\n         }\n     }\n \n-    public static enum Kind {\n+    public enum Kind {\n         OnNext, OnError, OnCompleted\n     }\n \n\ndiff --git a/src/main/java/rx/Single.java b/src/main/java/rx/Single.java\n--- a/src/main/java/rx/Single.java\n+++ b/src/main/java/rx/Single.java\n@@ -147,7 +147,7 @@ public final static <T> Single<T> create(OnSubscribe<T> f) {\n     /**\n      * Invoked when Single.execute is called.\n      */\n-    public static interface OnSubscribe<T> extends Action1<SingleSubscriber<? super T>> {\n+    public interface OnSubscribe<T> extends Action1<SingleSubscriber<? super T>> {\n         // cover for generics insanity\n     }\n \n@@ -235,7 +235,7 @@ public <R> Single<R> compose(Transformer<? super T, ? extends R> transformer) {\n      * \n      * @warn more complete description needed\n      */\n-    public static interface Transformer<T, R> extends Func1<Single<T>, Single<R>> {\n+    public interface Transformer<T, R> extends Func1<Single<T>, Single<R>> {\n         // cover for generics insanity\n     }\n ",
    "output": "Remove unnecessary static modifier"
  },
  {
    "input": "diff --git a/src/main/java/rx/exceptions/Exceptions.java b/src/main/java/rx/exceptions/Exceptions.java\n--- a/src/main/java/rx/exceptions/Exceptions.java\n+++ b/src/main/java/rx/exceptions/Exceptions.java\n@@ -77,7 +77,7 @@ public static void throwIfFatal(Throwable t) {\n         if (t instanceof OnErrorNotImplementedException) {\n             throw (OnErrorNotImplementedException) t;\n         } else if (t instanceof OnErrorFailedException) {\n-            Throwable cause = ((OnErrorFailedException) t).getCause();\n+            Throwable cause = t.getCause();\n             if (cause instanceof RuntimeException) {\n                 throw (RuntimeException) cause;\n             } else {",
    "output": "Remove redundant cast in Exceptions"
  },
  {
    "input": "diff --git a/src/main/java/rx/functions/Actions.java b/src/main/java/rx/functions/Actions.java\n--- a/src/main/java/rx/functions/Actions.java\n+++ b/src/main/java/rx/functions/Actions.java\n@@ -24,14 +24,14 @@ private Actions() {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> empty() {\n+    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> empty() {\n         return EMPTY_ACTION;\n     }\n \n     @SuppressWarnings(\"rawtypes\")\n     private static final EmptyAction EMPTY_ACTION = new EmptyAction();\n \n-    private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> implements\n+    private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> implements\n             Action0,\n             Action1<T0>,\n             Action2<T0, T1>,",
    "output": "Remove redundant type parameter in EmptyAction"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorOnErrorFlatMap.java b/src/main/java/rx/internal/operators/OperatorOnErrorFlatMap.java\n--- a/src/main/java/rx/internal/operators/OperatorOnErrorFlatMap.java\n+++ b/src/main/java/rx/internal/operators/OperatorOnErrorFlatMap.java\n@@ -1,84 +0,0 @@\n-/**\n- * Copyright 2014 Netflix, Inc.\n- * \n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * \n- * http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package rx.internal.operators;\n-\n-import rx.Observable;\n-import rx.Observable.Operator;\n-import rx.Subscriber;\n-import rx.exceptions.OnErrorThrowable;\n-import rx.functions.Func1;\n-import rx.plugins.RxJavaPlugins;\n-\n-/**\n- * Allows inserting onNext events into a stream when onError events are received\n- * and continuing the original sequence instead of terminating. Thus it allows a sequence\n- * with multiple onError events.\n- */\n-public final class OperatorOnErrorFlatMap<T> implements Operator<T, T> {\n-\n-    private final Func1<OnErrorThrowable, ? extends Observable<? extends T>> resumeFunction;\n-\n-    public OperatorOnErrorFlatMap(Func1<OnErrorThrowable, ? extends Observable<? extends T>> f) {\n-        this.resumeFunction = f;\n-    }\n-\n-    @Override\n-    public Subscriber<? super T> call(final Subscriber<? super T> child) {\n-        return new Subscriber<T>(child) {\n-\n-            @Override\n-            public void onCompleted() {\n-                child.onCompleted();\n-            }\n-\n-            @Override\n-            public void onError(Throwable e) {\n-                try {\n-                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);\n-                    Observable<? extends T> resume = resumeFunction.call(OnErrorThrowable.from(e));\n-                    resume.unsafeSubscribe(new Subscriber<T>() {\n-\n-                        @Override\n-                        public void onCompleted() {\n-                            // ignore as we will continue the parent Observable\n-                        }\n-\n-                        @Override\n-                        public void onError(Throwable e) {\n-                            // if the splice also fails we shut it all down\n-                            child.onError(e);\n-                        }\n-\n-                        @Override\n-                        public void onNext(T t) {\n-                            child.onNext(t);\n-                        }\n-\n-                    });\n-                } catch (Throwable e2) {\n-                    child.onError(e2);\n-                }\n-            }\n-\n-            @Override\n-            public void onNext(T t) {\n-                child.onNext(t);\n-            }\n-\n-        };\n-    }\n-\n-}",
    "output": "Remove OperatorOnErrorFlatMap because unused"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorTake.java b/src/main/java/rx/internal/operators/OperatorTake.java\n--- a/src/main/java/rx/internal/operators/OperatorTake.java\n+++ b/src/main/java/rx/internal/operators/OperatorTake.java\n@@ -43,33 +43,41 @@ public OperatorTake(int limit) {\n     public Subscriber<? super T> call(final Subscriber<? super T> child) {\n         final Subscriber<T> parent = new Subscriber<T>() {\n \n-            int count = 0;\n-            boolean completed = false;\n+            int count;\n+            boolean completed;\n \n             @Override\n             public void onCompleted() {\n                 if (!completed) {\n+                    completed = true;\n                     child.onCompleted();\n                 }\n             }\n \n             @Override\n             public void onError(Throwable e) {\n                 if (!completed) {\n-                    child.onError(e);\n+                    completed = true;\n+                    try {\n+                        child.onError(e);\n+                    } finally {\n+                        unsubscribe();\n+                    }\n                 }\n             }\n \n             @Override\n             public void onNext(T i) {\n                 if (!isUnsubscribed()) {\n-                    if (++count >= limit) {\n-                        completed = true;\n-                    }\n+                    boolean stop = ++count >= limit;\n                     child.onNext(i);\n-                    if (completed) {\n-                        child.onCompleted();\n-                        unsubscribe();\n+                    if (stop && !completed) {\n+                        completed = true;\n+                        try {\n+                            child.onCompleted();\n+                        } finally {\n+                            unsubscribe();\n+                        }\n                     }\n                 }\n             }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorTakeTest.java b/src/test/java/rx/internal/operators/OperatorTakeTest.java\n--- a/src/test/java/rx/internal/operators/OperatorTakeTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorTakeTest.java\n@@ -16,36 +16,21 @@\n package rx.internal.operators;\n \n import static org.junit.Assert.*;\n-import static org.mockito.Matchers.any;\n-import static org.mockito.Matchers.anyString;\n-import static org.mockito.Mockito.inOrder;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n \n import java.util.Arrays;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.*;\n \n import org.junit.Test;\n import org.mockito.InOrder;\n \n-import rx.Observable;\n+import rx.*;\n import rx.Observable.OnSubscribe;\n-import rx.Observer;\n-import rx.Producer;\n-import rx.Subscriber;\n-import rx.Subscription;\n-import rx.functions.Action1;\n-import rx.functions.Func1;\n-import rx.observers.Subscribers;\n-import rx.observers.TestSubscriber;\n+import rx.exceptions.TestException;\n+import rx.functions.*;\n+import rx.observers.*;\n import rx.schedulers.Schedulers;\n \n public class OperatorTakeTest {\n@@ -414,4 +399,22 @@ public void call(Long n) {\n         ts.assertNoErrors();\n         assertEquals(2,requests.get());\n     }\n+    \n+    @Test\n+    public void takeFinalValueThrows() {\n+        Observable<Integer> source = Observable.just(1).take(1);\n+        \n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {\n+            @Override\n+            public void onNext(Integer t) {\n+                throw new TestException();\n+            }\n+        };\n+        \n+        source.subscribe(ts);\n+        \n+        ts.assertNoValues();\n+        ts.assertError(TestException.class);\n+        ts.assertNotCompleted();\n+    }\n }",
    "output": "Fix take swallowing exception if thrown by the exactly the nth onNext\ncall to it"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/util/SynchronizedQueue.java b/src/main/java/rx/internal/util/SynchronizedQueue.java\n--- a/src/main/java/rx/internal/util/SynchronizedQueue.java\n+++ b/src/main/java/rx/internal/util/SynchronizedQueue.java\n@@ -99,13 +99,25 @@ public synchronized String toString() {\n     }\n \n     @Override\n-    public synchronized boolean equals(Object o) {\n-        return list.equals(o);\n+    public int hashCode() {\n+        return list.hashCode();\n     }\n \n     @Override\n-    public synchronized int hashCode() {\n-        return list.hashCode();\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        SynchronizedQueue<?> other = (SynchronizedQueue<?>) obj;\n+        if (list == null) {\n+            if (other.list != null)\n+                return false;\n+        } else if (!list.equals(other.list))\n+            return false;\n+        return true;\n     }\n \n     @Override\n\ndiff --git a/src/test/java/rx/internal/util/SynchronizedQueueTest.java b/src/test/java/rx/internal/util/SynchronizedQueueTest.java\n--- a/src/test/java/rx/internal/util/SynchronizedQueueTest.java\n+++ b/src/test/java/rx/internal/util/SynchronizedQueueTest.java\n@@ -0,0 +1,15 @@\n+package rx.internal.util;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Test;\n+\n+public class SynchronizedQueueTest {\n+    \n+    @Test\n+    public void testEquals() {\n+         SynchronizedQueue<Object> q = new SynchronizedQueue<Object>();\n+         assertTrue(q.equals(q));\n+    }\n+\n+}",
    "output": "Fix SynchronizedQueue.equals"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorMerge.java b/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -315,7 +315,8 @@ void tryEmit(InnerSubscriber<T> subscriber, T value) {\n             if (r != 0L) {\n                 synchronized (this) {\n                     // if nobody is emitting and child has available requests\n-                    if (!emitting) {\n+                    r = producer.get();\n+                    if (!emitting && r != 0L) {\n                         emitting = true;\n                         success = true;\n                     }\n@@ -422,7 +423,8 @@ void tryEmit(T value) {\n             if (r != 0L) {\n                 synchronized (this) {\n                     // if nobody is emitting and child has available requests\n-                    if (!emitting) {\n+                    r = producer.get();\n+                    if (!emitting && r != 0L) {\n                         emitting = true;\n                         success = true;\n                     }\n\ndiff --git a/src/test/java/rx/BackpressureTests.java b/src/test/java/rx/BackpressureTests.java\n--- a/src/test/java/rx/BackpressureTests.java\n+++ b/src/test/java/rx/BackpressureTests.java\n@@ -123,6 +123,30 @@ public void testMergeAsync() {\n         assertTrue(c2.get() < RxRingBuffer.SIZE * 5);\n     }\n \n+    @Test\n+    public void testMergeAsyncThenObserveOnLoop() {\n+        for (int i = 0; i < 500; i++) {\n+            if (i % 10 == 0) {\n+                System.out.println(\"testMergeAsyncThenObserveOnLoop >> \" + i);\n+            }\n+            // Verify there is no MissingBackpressureException\n+            int NUM = (int) (RxRingBuffer.SIZE * 4.1);\n+            AtomicInteger c1 = new AtomicInteger();\n+            AtomicInteger c2 = new AtomicInteger();\n+            \n+            TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+            Observable<Integer> merged = Observable.merge(\n+                    incrementingIntegers(c1).subscribeOn(Schedulers.computation()),\n+                    incrementingIntegers(c2).subscribeOn(Schedulers.computation()));\n+\n+            merged.observeOn(Schedulers.io()).take(NUM).subscribe(ts);\n+            ts.awaitTerminalEvent();\n+            ts.assertNoErrors();\n+            System.out.println(\"testMergeAsyncThenObserveOn => Received: \" + ts.getOnNextEvents().size() + \"  Emitted: \" + c1.get() + \" / \" + c2.get());\n+            assertEquals(NUM, ts.getOnNextEvents().size());\n+        }\n+    }\n+    \n     @Test\n     public void testMergeAsyncThenObserveOn() {\n         int NUM = (int) (RxRingBuffer.SIZE * 4.1);",
    "output": "Fix request != 0 checking in the scalar paths of merge()"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeAutoConnect.java b/src/main/java/rx/internal/operators/OnSubscribeAutoConnect.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeAutoConnect.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeAutoConnect.java\n@@ -18,9 +18,11 @@\n import java.util.concurrent.atomic.AtomicInteger;\n \n import rx.Observable.OnSubscribe;\n-import rx.*;\n+import rx.Subscriber;\n+import rx.Subscription;\n import rx.functions.Action1;\n import rx.observables.ConnectableObservable;\n+import rx.observers.Subscribers;\n \n /**\n  * Wraps a ConnectableObservable and calls its connect() method once\n@@ -47,7 +49,7 @@ public OnSubscribeAutoConnect(ConnectableObservable<? extends T> source,\n     }\n     @Override\n     public void call(Subscriber<? super T> child) {\n-        source.unsafeSubscribe(child);\n+        source.unsafeSubscribe(Subscribers.wrap(child));\n         if (clients.incrementAndGet() == numberOfSubscribers) {\n             source.connect(connection);\n         }",
    "output": "Fix autoConnect calling onStart twice"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeDefer.java b/src/main/java/rx/internal/operators/OnSubscribeDefer.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeDefer.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeDefer.java\n@@ -19,6 +19,7 @@\n import rx.Observable.OnSubscribe;\n import rx.Subscriber;\n import rx.functions.Func0;\n+import rx.observers.Subscribers;\n \n /**\n  * Do not create the Observable until an Observer subscribes; create a fresh Observable on each\n@@ -46,20 +47,7 @@ public void call(final Subscriber<? super T> s) {\n             s.onError(t);\n             return;\n         }\n-        o.unsafeSubscribe(new Subscriber<T>(s) {\n-            @Override\n-            public void onNext(T t) {\n-                s.onNext(t);\n-            }\n-            @Override\n-            public void onError(Throwable e) {\n-                s.onError(e);\n-            }\n-            @Override\n-            public void onCompleted() {\n-                s.onCompleted();\n-            }\n-        });\n+        o.unsafeSubscribe(Subscribers.wrap(s));\n     }\n     \n }\n\ndiff --git a/src/main/java/rx/internal/operators/OnSubscribeDelaySubscription.java b/src/main/java/rx/internal/operators/OnSubscribeDelaySubscription.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeDelaySubscription.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeDelaySubscription.java\n@@ -21,6 +21,7 @@\n import rx.Observable.OnSubscribe;\n import rx.Scheduler.Worker;\n import rx.functions.Action0;\n+import rx.observers.Subscribers;\n \n /**\n  * Delays the subscription to the source by the given amount, running on the given scheduler.\n@@ -49,20 +50,7 @@ public void call(final Subscriber<? super T> s) {\n             @Override\n             public void call() {\n                 if (!s.isUnsubscribed()) {\n-                    source.unsafeSubscribe(new Subscriber<T>(s) {\n-                        @Override\n-                        public void onNext(T t) {\n-                            s.onNext(t);\n-                        }\n-                        @Override\n-                        public void onError(Throwable e) {\n-                            s.onError(e);\n-                        }\n-                        @Override\n-                        public void onCompleted() {\n-                            s.onCompleted();\n-                        }\n-                    });\n+                    source.unsafeSubscribe(Subscribers.wrap(s));\n                 }\n             }\n         }, time, unit);\n\ndiff --git a/src/main/java/rx/internal/operators/OnSubscribeDelaySubscriptionWithSelector.java b/src/main/java/rx/internal/operators/OnSubscribeDelaySubscriptionWithSelector.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeDelaySubscriptionWithSelector.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeDelaySubscriptionWithSelector.java\n@@ -18,6 +18,7 @@\n import rx.*;\n import rx.Observable.OnSubscribe;\n import rx.functions.Func0;\n+import rx.observers.Subscribers;\n \n /**\n  * Delays the subscription until the Observable<U> emits an event.\n@@ -42,20 +43,7 @@ public void call(final Subscriber<? super T> child) {\n                 @Override\n                 public void onCompleted() {\n                     // subscribe to actual source\n-                    source.unsafeSubscribe(new Subscriber<T>(child) {\n-                        @Override\n-                        public void onNext(T t) {\n-                            child.onNext(t);\n-                        }\n-                        @Override\n-                        public void onError(Throwable e) {\n-                            child.onError(e);\n-                        }\n-                        @Override\n-                        public void onCompleted() {\n-                            child.onCompleted();\n-                        }\n-                    });\n+                    source.unsafeSubscribe(Subscribers.wrap(child));\n                 }\n \n                 @Override\n\ndiff --git a/src/main/java/rx/internal/operators/OnSubscribeUsing.java b/src/main/java/rx/internal/operators/OnSubscribeUsing.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeUsing.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeUsing.java\n@@ -22,6 +22,7 @@\n import rx.Observable.OnSubscribe;\n import rx.exceptions.CompositeException;\n import rx.functions.*;\n+import rx.observers.Subscribers;\n \n /**\n  * Constructs an observable sequence that depends on a resource object.\n@@ -68,20 +69,7 @@ public void call(final Subscriber<? super T> subscriber) {\n                 observable = source;\n             try {\n                 // start\n-                observable.unsafeSubscribe(new Subscriber<T>(subscriber) {\n-                    @Override\n-                    public void onNext(T t) {\n-                        subscriber.onNext(t);\n-                    }\n-                    @Override\n-                    public void onError(Throwable e) {\n-                        subscriber.onError(e);\n-                    }\n-                    @Override\n-                    public void onCompleted() {\n-                        subscriber.onCompleted();\n-                    }\n-                });\n+                observable.unsafeSubscribe(Subscribers.wrap(subscriber));\n             } catch (Throwable e) {\n                 Throwable disposeError = disposeEagerlyIfRequested(disposeOnceOnly);\n                 if (disposeError != null)\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorDoOnSubscribe.java b/src/main/java/rx/internal/operators/OperatorDoOnSubscribe.java\n--- a/src/main/java/rx/internal/operators/OperatorDoOnSubscribe.java\n+++ b/src/main/java/rx/internal/operators/OperatorDoOnSubscribe.java\n@@ -18,6 +18,7 @@\n import rx.Observable.Operator;\n import rx.Subscriber;\n import rx.functions.Action0;\n+import rx.observers.Subscribers;\n \n /**\n  * This operator modifies an {@link rx.Observable} so a given action is invoked when the {@link rx.Observable} is subscribed.\n@@ -39,19 +40,6 @@ public Subscriber<? super T> call(final Subscriber<? super T> child) {\n         subscribe.call();\n         // Pass through since this operator is for notification only, there is\n         // no change to the stream whatsoever.\n-        return new Subscriber<T>(child) {\n-            @Override\n-            public void onNext(T t) {\n-                child.onNext(t);\n-            }\n-            @Override\n-            public void onError(Throwable e) {\n-                child.onError(e);\n-            }\n-            @Override\n-            public void onCompleted() {\n-                child.onCompleted();\n-            }\n-        };\n+        return Subscribers.wrap(child);\n     }\n }\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorDoOnUnsubscribe.java b/src/main/java/rx/internal/operators/OperatorDoOnUnsubscribe.java\n--- a/src/main/java/rx/internal/operators/OperatorDoOnUnsubscribe.java\n+++ b/src/main/java/rx/internal/operators/OperatorDoOnUnsubscribe.java\n@@ -18,6 +18,7 @@\n import rx.Observable.Operator;\n import rx.*;\n import rx.functions.Action0;\n+import rx.observers.Subscribers;\n import rx.subscriptions.Subscriptions;\n \n /**\n@@ -41,22 +42,6 @@ public Subscriber<? super T> call(final Subscriber<? super T> child) {\n \n         // Pass through since this operator is for notification only, there is\n         // no change to the stream whatsoever.\n-        return new Subscriber<T>(child) {\n-            @Override\n-            public void onStart() {\n-            }\n-            @Override\n-            public void onNext(T t) {\n-                child.onNext(t);\n-            }\n-            @Override\n-            public void onError(Throwable e) {\n-                child.onError(e);\n-            }\n-            @Override\n-            public void onCompleted() {\n-                child.onCompleted();\n-            }\n-        };\n+        return Subscribers.wrap(child);\n     }\n }\n\ndiff --git a/src/main/java/rx/observers/Subscribers.java b/src/main/java/rx/observers/Subscribers.java\n--- a/src/main/java/rx/observers/Subscribers.java\n+++ b/src/main/java/rx/observers/Subscribers.java\n@@ -17,6 +17,7 @@\n \n import rx.Observer;\n import rx.Subscriber;\n+import rx.annotations.Experimental;\n import rx.exceptions.OnErrorNotImplementedException;\n import rx.functions.Action0;\n import rx.functions.Action1;\n@@ -198,4 +199,41 @@ public final void onNext(T args) {\n         };\n     }\n \n+    /**\n+     * Returns a new {@link Subscriber} that passes all events to\n+     * <code>subscriber</code>, has backpressure controlled by\n+     * <code>subscriber</code> and uses the subscription list of\n+     * <code>subscriber</code> when {@link Subscriber#add(rx.Subscription)} is\n+     * called.\n+     * \n+     * @param subscriber\n+     *            the Subscriber to wrap.\n+     * \n+     * @return a new Subscriber that passes all events to\n+     *         <code>subscriber</code>, has backpressure controlled by\n+     *         <code>subscriber</code> and uses <code>subscriber</code> to\n+     *         manage unsubscription.\n+     * \n+     */\n+    @Experimental\n+    public static <T> Subscriber<T> wrap(final Subscriber<? super T> subscriber) {\n+        return new Subscriber<T>(subscriber) {\n+\n+            @Override\n+            public void onCompleted() {\n+                subscriber.onCompleted();\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                subscriber.onError(e);\n+            }\n+\n+            @Override\n+            public void onNext(T t) {\n+                subscriber.onNext(t);\n+            }\n+            \n+        };\n+    }\n }",
    "output": "Add Subscribers.wrap"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -19,6 +19,7 @@\n import rx.exceptions.*;\n import rx.functions.*;\n import rx.internal.operators.*;\n+import rx.internal.producers.SingleProducer;\n import rx.internal.util.*;\n import rx.observables.*;\n import rx.observers.SafeSubscriber;\n@@ -3857,8 +3858,14 @@ public final Observable<T> debounce(long timeout, TimeUnit unit, Scheduler sched\n      *         items, or the items emitted by the source Observable\n      * @see <a href=\"http://reactivex.io/documentation/operators/defaultifempty.html\">ReactiveX operators documentation: DefaultIfEmpty</a>\n      */\n-    public final Observable<T> defaultIfEmpty(T defaultValue) {\n-        return lift(new OperatorDefaultIfEmpty<T>(defaultValue));\n+    public final Observable<T> defaultIfEmpty(final T defaultValue) {\n+        //if empty switch to an observable that emits defaultValue and supports backpressure\n+        return switchIfEmpty(Observable.create(new OnSubscribe<T>() {\n+\n+            @Override\n+            public void call(Subscriber<? super T> subscriber) {\n+                subscriber.setProducer(new SingleProducer<T>(subscriber, defaultValue));\n+            }}));\n     }\n \n     /**\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorDefaultIfEmpty.java b/src/main/java/rx/internal/operators/OperatorDefaultIfEmpty.java\n--- a/src/main/java/rx/internal/operators/OperatorDefaultIfEmpty.java\n+++ b/src/main/java/rx/internal/operators/OperatorDefaultIfEmpty.java\n@@ -1,64 +0,0 @@\n-/**\n- * Copyright 2014 Netflix, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package rx.internal.operators;\n-\n-import rx.Observable.Operator;\n-import rx.Subscriber;\n-\n-/**\n- * Returns the elements of the specified sequence or the specified default value\n- * in a singleton sequence if the sequence is empty.\n- * @param <T> the value type\n- */\n-public class OperatorDefaultIfEmpty<T> implements Operator<T, T> {\n-    final T defaultValue;\n-\n-    public OperatorDefaultIfEmpty(T defaultValue) {\n-        this.defaultValue = defaultValue;\n-    }\n-    \n-    @Override\n-    public Subscriber<? super T> call(final Subscriber<? super T> child) {\n-        return new Subscriber<T>(child) {\n-            boolean hasValue;\n-            @Override\n-            public void onNext(T t) {\n-                hasValue = true;\n-                child.onNext(t);\n-            }\n-\n-            @Override\n-            public void onError(Throwable e) {\n-                child.onError(e);\n-            }\n-\n-            @Override\n-            public void onCompleted() {\n-                if (!hasValue) {\n-                    try {\n-                        child.onNext(defaultValue);\n-                    } catch (Throwable e) {\n-                        child.onError(e);\n-                        return;\n-                    }\n-                }\n-                child.onCompleted();\n-            }\n-            \n-        };\n-    }\n-    \n-}\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorDefaultIfEmptyTest.java b/src/test/java/rx/internal/operators/OperatorDefaultIfEmptyTest.java\n--- a/src/test/java/rx/internal/operators/OperatorDefaultIfEmptyTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorDefaultIfEmptyTest.java\n@@ -26,6 +26,7 @@\n import rx.Observer;\n import rx.Subscriber;\n import rx.exceptions.TestException;\n+import rx.observers.TestSubscriber;\n \n public class OperatorDefaultIfEmptyTest {\n \n@@ -85,4 +86,28 @@ public void onCompleted() {\n         verify(o, never()).onNext(any(Integer.class));\n         verify(o, never()).onCompleted();\n     }\n+    \n+    @Test\n+    public void testBackpressureEmpty() {\n+        TestSubscriber<Integer> ts = TestSubscriber.create(0);\n+        Observable.<Integer>empty().defaultIfEmpty(1).subscribe(ts);\n+        ts.assertNoValues();\n+        ts.assertNoTerminalEvent();\n+        ts.requestMore(1);\n+        ts.assertValue(1);\n+        ts.assertCompleted();\n+    }\n+    \n+    @Test\n+    public void testBackpressureNonEmpty() {\n+        TestSubscriber<Integer> ts = TestSubscriber.create(0);\n+        Observable.just(1,2,3).defaultIfEmpty(1).subscribe(ts);\n+        ts.assertNoValues();\n+        ts.assertNoTerminalEvent();\n+        ts.requestMore(2);\n+        ts.assertValues(1, 2);\n+        ts.requestMore(1);\n+        ts.assertValues(1, 2, 3);\n+        ts.assertCompleted();\n+    }\n }",
    "output": "Add backpressure support for defaultIfEmpty()"
  },
  {
    "input": "diff --git a/src/perf/java/rx/operators/OperatorFlatMapPerf.java b/src/perf/java/rx/operators/OperatorFlatMapPerf.java\n--- a/src/perf/java/rx/operators/OperatorFlatMapPerf.java\n+++ b/src/perf/java/rx/operators/OperatorFlatMapPerf.java\n@@ -28,6 +28,7 @@\n import rx.Observable;\n import rx.functions.Func1;\n import rx.jmh.InputWithIncrementingInteger;\n+import rx.jmh.LatchedObserver;\n import rx.schedulers.Schedulers;\n \n @BenchmarkMode(Mode.Throughput)\n@@ -62,14 +63,16 @@ public Observable<Integer> call(Integer i) {\n \n     @Benchmark\n     public void flatMapIntPassthruAsync(Input input) throws InterruptedException {\n+        LatchedObserver<Integer> latchedObserver = input.newLatchedObserver();\n         input.observable.flatMap(new Func1<Integer, Observable<Integer>>() {\n \n             @Override\n             public Observable<Integer> call(Integer i) {\n                 return Observable.just(i).subscribeOn(Schedulers.computation());\n             }\n \n-        }).subscribe(input.observer);\n+        }).subscribe(latchedObserver);\n+        latchedObserver.latch.await();\n     }\n \n     @Benchmark",
    "output": "Fix OperatorFlatMapPerf.flatMapIntPassthruAsync Perf Test\n\nThis test was reported broken in https://github.com/ReactiveX/RxJava/pull/2928#issuecomment-113229698\n\nFixing by adding the use of LatchedObserver.\n\nPreviously broken test results:\n\n```\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1  thrpt         5   363615.622   115041.519    ops/s\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000  thrpt         5      350.204      125.773    ops/s\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000  thrpt         5        0.319        0.184    ops/s\n```\n\nFixed results:\n\n```\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1  thrpt         5   102109.681     8709.920    ops/s\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000  thrpt         5      403.071      130.651    ops/s\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000  thrpt         5        0.355        0.070    ops/s\n```"
  },
  {
    "input": "diff --git a/src/main/java/rx/observers/TestSubscriber.java b/src/main/java/rx/observers/TestSubscriber.java\n--- a/src/main/java/rx/observers/TestSubscriber.java\n+++ b/src/main/java/rx/observers/TestSubscriber.java\n@@ -281,7 +281,7 @@ public void awaitTerminalEvent(long timeout, TimeUnit unit) {\n      * Blocks until this {@link Subscriber} receives a notification that the {@code Observable} is complete\n      * (either an {@code onCompleted} or {@code onError} notification), or until a timeout expires; if the\n      * Subscriber is interrupted before either of these events take place, this method unsubscribes the\n-     * Subscriber from the Observable).\n+     * Subscriber from the Observable). If timeout expires then the Subscriber is unsubscribed from the Observable.\n      *\n      * @param timeout\n      *          the duration of the timeout\n@@ -290,8 +290,12 @@ public void awaitTerminalEvent(long timeout, TimeUnit unit) {\n      */\n     public void awaitTerminalEventAndUnsubscribeOnTimeout(long timeout, TimeUnit unit) {\n         try {\n-            awaitTerminalEvent(timeout, unit);\n-        } catch (RuntimeException e) {\n+            boolean result = latch.await(timeout, unit);\n+            if (!result) {\n+                // timeout occurred\n+                unsubscribe();\n+            }\n+        } catch (InterruptedException e) {\n             unsubscribe();\n         }\n     }\n\ndiff --git a/src/test/java/rx/observers/TestSubscriberTest.java b/src/test/java/rx/observers/TestSubscriberTest.java\n--- a/src/test/java/rx/observers/TestSubscriberTest.java\n+++ b/src/test/java/rx/observers/TestSubscriberTest.java\n@@ -16,19 +16,24 @@\n package rx.observers;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n import static org.mockito.Mockito.inOrder;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n \n import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n+import org.junit.Assert;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.ExpectedException;\n import org.mockito.InOrder;\n \n import rx.Observable;\n import rx.Observer;\n+import rx.functions.Action0;\n import rx.subjects.PublishSubject;\n \n public class TestSubscriberTest {\n@@ -124,8 +129,35 @@ public void testWrappingMockWhenUnsubscribeInvolved() {\n     @Test\n     public void testAssertError() {\n         RuntimeException e = new RuntimeException(\"Oops\");\n-        TestSubscriber subscriber = new TestSubscriber();\n+        TestSubscriber<Object> subscriber = new TestSubscriber<Object>();\n         Observable.error(e).subscribe(subscriber);\n         subscriber.assertError(e);\n     }\n+    \n+    @Test\n+    public void testAwaitTerminalEventWithDuration() {\n+        TestSubscriber<Object> ts = new TestSubscriber<Object>();\n+        Observable.just(1).subscribe(ts);\n+        ts.awaitTerminalEvent(1, TimeUnit.SECONDS);\n+        ts.assertTerminalEvent();\n+    }\n+    \n+    @Test\n+    public void testAwaitTerminalEventWithDurationAndUnsubscribeOnTimeout() {\n+        TestSubscriber<Object> ts = new TestSubscriber<Object>();\n+        final AtomicBoolean unsub = new AtomicBoolean(false);\n+        Observable.just(1)\n+        //\n+                .doOnUnsubscribe(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        unsub.set(true);\n+                    }\n+                })\n+                //\n+                .delay(1000, TimeUnit.MILLISECONDS).subscribe(ts);\n+        ts.awaitTerminalEventAndUnsubscribeOnTimeout(100, TimeUnit.MILLISECONDS);\n+        assertTrue(unsub.get());\n+    }\n+\n }",
    "output": "Fix awaitTerminalEventAndUnsubscribeOnTimeout"
  },
  {
    "input": "diff --git a/src/test/java/rx/internal/operators/OperatorRetryWithPredicateTest.java b/src/test/java/rx/internal/operators/OperatorRetryWithPredicateTest.java\n--- a/src/test/java/rx/internal/operators/OperatorRetryWithPredicateTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorRetryWithPredicateTest.java\n@@ -20,7 +20,10 @@\n import static org.mockito.Mockito.*;\n \n import java.io.IOException;\n+import java.util.Arrays;\n import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.*;\n \n@@ -305,4 +308,56 @@ public Integer call(Integer t1) {\n \n         assertEquals(1, value);\n     }\n+    \n+    @Test\n+    public void testIssue3008RetryWithPredicate() {\n+        final List<Long> list = new CopyOnWriteArrayList<Long>();\n+        final AtomicBoolean isFirst = new AtomicBoolean(true);\n+        Observable.<Long> just(1L, 2L, 3L).map(new Func1<Long, Long>(){\n+            @Override\n+            public Long call(Long x) {\n+                System.out.println(\"map \" + x);\n+                if (x == 2 && isFirst.getAndSet(false)) {\n+                    throw new RuntimeException(\"retryable error\");\n+                }\n+                return x;\n+            }})\n+        .retry(new Func2<Integer, Throwable, Boolean>() {\n+            @Override\n+            public Boolean call(Integer t1, Throwable t2) {\n+                return true;\n+            }})\n+        .forEach(new Action1<Long>() {\n+\n+            @Override\n+            public void call(Long t) {\n+                System.out.println(t);\n+                list.add(t);\n+            }});\n+        assertEquals(Arrays.asList(1L,1L,2L,3L), list);\n+    }\n+    \n+    @Test\n+    public void testIssue3008RetryInfinite() {\n+        final List<Long> list = new CopyOnWriteArrayList<Long>();\n+        final AtomicBoolean isFirst = new AtomicBoolean(true);\n+        Observable.<Long> just(1L, 2L, 3L).map(new Func1<Long, Long>(){\n+            @Override\n+            public Long call(Long x) {\n+                System.out.println(\"map \" + x);\n+                if (x == 2 && isFirst.getAndSet(false)) {\n+                    throw new RuntimeException(\"retryable error\");\n+                }\n+                return x;\n+            }})\n+        .retry()\n+        .forEach(new Action1<Long>() {\n+\n+            @Override\n+            public void call(Long t) {\n+                System.out.println(t);\n+                list.add(t);\n+            }});\n+        assertEquals(Arrays.asList(1L,1L,2L,3L), list);\n+    }\n }",
    "output": "Add two unit tests for issue #3008"
  },
  {
    "input": "diff --git a/src/main/java/rx/observers/TestSubscriber.java b/src/main/java/rx/observers/TestSubscriber.java\n--- a/src/main/java/rx/observers/TestSubscriber.java\n+++ b/src/main/java/rx/observers/TestSubscriber.java\n@@ -356,12 +356,14 @@ public void assertError(Class<? extends Throwable> clazz) {\n             throw new AssertionError(\"No errors\");\n         } else\n         if (err.size() > 1) {\n-            // can't use AssertionError because (message, cause) doesn't exist until Java 7\n-            throw new RuntimeException(\"Multiple errors: \" + err.size(), new CompositeException(err));\n+            AssertionError ae = new AssertionError(\"Multiple errors: \" + err.size());\n+            ae.initCause(new CompositeException(err));\n+            throw ae;\n         } else\n         if (!clazz.isInstance(err.get(0))) {\n-            // can't use AssertionError because (message, cause) doesn't exist until Java 7\n-            throw new RuntimeException(\"Exceptions differ; expected: \" + clazz + \", actual: \" + err.get(0), err.get(0));\n+            AssertionError ae = new AssertionError(\"Exceptions differ; expected: \" + clazz + \", actual: \" + err.get(0));\n+            ae.initCause(err.get(0));\n+            throw ae;\n         }\n     }\n \n@@ -380,12 +382,14 @@ public void assertError(Throwable throwable) {\n             throw new AssertionError(\"No errors\");\n         } else\n         if (err.size() > 1) {\n-            // can't use AssertionError because (message, cause) doesn't exist until Java 7\n-            throw new RuntimeException(\"Multiple errors: \" + err.size(), new CompositeException(err));\n+            AssertionError ae = new AssertionError(\"Multiple errors: \" + err.size());\n+            ae.initCause(new CompositeException(err));\n+            throw ae;\n         } else\n         if (!throwable.equals(err.get(0))) {\n-            // can't use AssertionError because (message, cause) doesn't exist until Java 7\n-            throw new RuntimeException(\"Exceptions differ; expected: \" + throwable + \", actual: \" + err.get(0), err.get(0));\n+            AssertionError ae = new AssertionError(\"Exceptions differ; expected: \" + throwable + \", actual: \" + err.get(0));\n+            ae.initCause(err.get(0));\n+            throw ae;\n         }\n     }\n \n@@ -404,11 +408,13 @@ public void assertNoTerminalEvent() {\n                 throw new AssertionError(\"Found \" + err.size() + \" errors and \" + s + \" completion events instead of none\");\n             } else\n             if (err.size() == 1) {\n-                // can't use AssertionError because (message, cause) doesn't exist until Java 7\n-                throw new RuntimeException(\"Found \" + err.size() + \" errors and \" + s + \" completion events instead of none\", err.get(0));\n+                AssertionError ae = new AssertionError(\"Found \" + err.size() + \" errors and \" + s + \" completion events instead of none\");\n+                ae.initCause(err.get(0));\n+                throw ae;\n             } else {\n-                // can't use AssertionError because (message, cause) doesn't exist until Java 7\n-                throw new RuntimeException(\"Found \" + err.size() + \" errors and \" + s + \" completion events instead of none\", new CompositeException(err));\n+                AssertionError ae = new AssertionError(\"Found \" + err.size() + \" errors and \" + s + \" completion events instead of none\");\n+                ae.initCause(new CompositeException(err));\n+                throw ae;\n             }\n         }\n     }",
    "output": "Use initCause to initialize AssertionError"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorDelayWithSelector.java b/src/main/java/rx/internal/operators/OperatorDelayWithSelector.java\n--- a/src/main/java/rx/internal/operators/OperatorDelayWithSelector.java\n+++ b/src/main/java/rx/internal/operators/OperatorDelayWithSelector.java\n@@ -20,6 +20,7 @@\n import rx.Subscriber;\n import rx.functions.Func1;\n import rx.observers.SerializedSubscriber;\n+import rx.observers.Subscribers;\n import rx.subjects.PublishSubject;\n \n /**\n@@ -44,24 +45,7 @@ public Subscriber<? super T> call(final Subscriber<? super T> _child) {\n         final SerializedSubscriber<T> child = new SerializedSubscriber<T>(_child);\n         final PublishSubject<Observable<T>> delayedEmissions = PublishSubject.create();\n \n-        _child.add(Observable.merge(delayedEmissions).unsafeSubscribe(new Subscriber<T>() {\n-\n-            @Override\n-            public void onCompleted() {\n-                child.onCompleted();\n-            }\n-\n-            @Override\n-            public void onError(Throwable e) {\n-                child.onError(e);\n-            }\n-\n-            @Override\n-            public void onNext(T t) {\n-                child.onNext(t);\n-            }\n-\n-        }));\n+        _child.add(Observable.merge(delayedEmissions).unsafeSubscribe(Subscribers.from(child)));\n \n         return new Subscriber<T>(_child) {\n \n\ndiff --git a/src/main/java/rx/internal/operators/OperatorMulticast.java b/src/main/java/rx/internal/operators/OperatorMulticast.java\n--- a/src/main/java/rx/internal/operators/OperatorMulticast.java\n+++ b/src/main/java/rx/internal/operators/OperatorMulticast.java\n@@ -26,6 +26,7 @@\n import rx.functions.Action1;\n import rx.functions.Func0;\n import rx.observables.ConnectableObservable;\n+import rx.observers.Subscribers;\n import rx.subjects.Subject;\n import rx.subscriptions.Subscriptions;\n \n@@ -90,22 +91,7 @@ public void connect(Action1<? super Subscription> connection) {\n                 final Subject<? super T, ? extends R> subject = subjectFactory.call();\n                 // create new Subscriber that will pass-thru to the subject we just created\n                 // we do this since it is also a Subscription whereas the Subject is not\n-                subscription = new Subscriber<T>() {\n-                    @Override\n-                    public void onCompleted() {\n-                        subject.onCompleted();\n-                    }\n-\n-                    @Override\n-                    public void onError(Throwable e) {\n-                        subject.onError(e);\n-                    }\n-\n-                    @Override\n-                    public void onNext(T args) {\n-                        subject.onNext(args);\n-                    }\n-                };\n+                subscription = Subscribers.from(subject);\n                 final AtomicReference<Subscription> gs = new AtomicReference<Subscription>();\n                 gs.set(Subscriptions.create(new Action0() {\n                     @Override",
    "output": "Use Subscribers.from()"
  },
  {
    "input": "diff --git a/src/main/java/rx/observers/TestSubscriber.java b/src/main/java/rx/observers/TestSubscriber.java\n--- a/src/main/java/rx/observers/TestSubscriber.java\n+++ b/src/main/java/rx/observers/TestSubscriber.java\n@@ -380,7 +380,7 @@ public void assertError(Throwable throwable) {\n         if (err.size() > 1) {\n             throw new AssertionError(\"Multiple errors: \" + err.size(), new CompositeException(err));\n         } else\n-        if (throwable.equals(err.get(0))) {\n+        if (!throwable.equals(err.get(0))) {\n             throw new AssertionError(\"Exceptions differ; expected: \" + throwable + \", actual: \" + err.get(0), err.get(0));\n         }\n     }\n\ndiff --git a/src/test/java/rx/observers/TestSubscriberTest.java b/src/test/java/rx/observers/TestSubscriberTest.java\n--- a/src/test/java/rx/observers/TestSubscriberTest.java\n+++ b/src/test/java/rx/observers/TestSubscriberTest.java\n@@ -121,4 +121,11 @@ public void testWrappingMockWhenUnsubscribeInvolved() {\n         inOrder.verifyNoMoreInteractions();\n     }\n \n+    @Test\n+    public void testAssertError() {\n+        RuntimeException e = new RuntimeException(\"Oops\");\n+        TestSubscriber subscriber = new TestSubscriber();\n+        Observable.error(e).subscribe(subscriber);\n+        subscriber.assertError(e);\n+    }\n }",
    "output": "Fix a wrong assertion in assertError"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java b/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n--- a/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n+++ b/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n@@ -15,9 +15,9 @@\n  */\n package rx.internal.operators;\n \n-import java.util.concurrent.atomic.AtomicLong;\n \n import rx.*;\n+import rx.internal.producers.ProducerArbiter;\n import rx.subscriptions.SerialSubscription;\n \n /**\n@@ -35,36 +35,32 @@ public OperatorSwitchIfEmpty(Observable<? extends T> alternate) {\n     @Override\n     public Subscriber<? super T> call(Subscriber<? super T> child) {\n         final SerialSubscription ssub = new SerialSubscription();\n-        final SwitchIfEmptySubscriber parent = new SwitchIfEmptySubscriber(child, ssub);\n+        ProducerArbiter arbiter = new ProducerArbiter();\n+        final ParentSubscriber<T> parent = new ParentSubscriber<T>(child, ssub, arbiter, alternate);\n         ssub.set(parent);\n         child.add(ssub);\n+        child.setProducer(arbiter);\n         return parent;\n     }\n \n-    private class SwitchIfEmptySubscriber extends Subscriber<T> {\n-\n-        boolean empty = true;\n-        final AtomicLong consumerCapacity = new AtomicLong(0l);\n+    private static final class ParentSubscriber<T> extends Subscriber<T> {\n \n+        private boolean empty = true;\n         private final Subscriber<? super T> child;\n-        final SerialSubscription ssub;\n+        private final SerialSubscription ssub;\n+        private final ProducerArbiter arbiter;\n+        private final Observable<? extends T> alternate;\n \n-        public SwitchIfEmptySubscriber(Subscriber<? super T> child, final SerialSubscription ssub) {\n+        ParentSubscriber(Subscriber<? super T> child, final SerialSubscription ssub, ProducerArbiter arbiter, Observable<? extends T> alternate) {\n             this.child = child;\n             this.ssub = ssub;\n+            this.arbiter = arbiter;\n+            this.alternate = alternate;\n         }\n \n         @Override\n         public void setProducer(final Producer producer) {\n-            super.setProducer(new Producer() {\n-                @Override\n-                public void request(long n) {\n-                    if (empty) {\n-                        consumerCapacity.set(n);\n-                    }\n-                    producer.request(n);\n-                }\n-            });\n+            arbiter.setProducer(producer);\n         }\n \n         @Override\n@@ -77,41 +73,9 @@ public void onCompleted() {\n         }\n \n         private void subscribeToAlternate() {\n-            ssub.set(alternate.unsafeSubscribe(new Subscriber<T>() {\n-\n-                @Override\n-                public void setProducer(final Producer producer) {\n-                    child.setProducer(new Producer() {\n-                        @Override\n-                        public void request(long n) {\n-                            producer.request(n);\n-                        }\n-                    });\n-                }\n-\n-                @Override\n-                public void onStart() {\n-                    final long capacity = consumerCapacity.get();\n-                    if (capacity > 0) {\n-                        request(capacity);\n-                    }\n-                }\n-\n-                @Override\n-                public void onCompleted() {\n-                    child.onCompleted();\n-                }\n-\n-                @Override\n-                public void onError(Throwable e) {\n-                    child.onError(e);\n-                }\n-\n-                @Override\n-                public void onNext(T t) {\n-                    child.onNext(t);\n-                }\n-            }));\n+            AlternateSubscriber<T> as = new AlternateSubscriber<T>(child, arbiter);\n+            ssub.set(as);\n+            alternate.unsafeSubscribe(as);\n         }\n \n         @Override\n@@ -123,6 +87,39 @@ public void onError(Throwable e) {\n         public void onNext(T t) {\n             empty = false;\n             child.onNext(t);\n+            arbiter.produced(1);\n+        }\n+    }\n+    \n+    private static final class AlternateSubscriber<T> extends Subscriber<T> {\n+        \n+        private final ProducerArbiter arbiter;\n+        private final Subscriber<? super T> child;\n+\n+        AlternateSubscriber(Subscriber<? super T> child, ProducerArbiter arbiter) {\n+            this.child = child;\n+            this.arbiter = arbiter;\n+        }\n+        \n+        @Override\n+        public void setProducer(final Producer producer) {\n+            arbiter.setProducer(producer);\n+        }\n+\n+        @Override\n+        public void onCompleted() {\n+            child.onCompleted();\n         }\n+\n+        @Override\n+        public void onError(Throwable e) {\n+            child.onError(e);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            child.onNext(t);\n+            arbiter.produced(1);\n+        }        \n     }\n }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java b/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n--- a/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n@@ -18,14 +18,18 @@\n import static org.junit.Assert.*;\n \n import java.util.*;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.junit.Test;\n \n import rx.*;\n import rx.Observable;\n+import rx.Observable.OnSubscribe;\n import rx.functions.Action0;\n+import rx.functions.Action1;\n import rx.observers.TestSubscriber;\n+import rx.schedulers.Schedulers;\n import rx.subscriptions.Subscriptions;\n \n public class OperatorSwitchIfEmptyTest {\n@@ -142,6 +146,10 @@ public void onStart() {\n         \n         assertEquals(Arrays.asList(1), ts.getOnNextEvents());\n         ts.assertNoErrors();\n+        ts.requestMore(1);\n+        ts.assertValueCount(2);\n+        ts.requestMore(1);\n+        ts.assertValueCount(3);\n     }\n     @Test\n     public void testBackpressureNoRequest() {\n@@ -153,8 +161,51 @@ public void onStart() {\n             }\n         };\n         Observable.<Integer>empty().switchIfEmpty(Observable.just(1, 2, 3)).subscribe(ts);\n-        \n         assertTrue(ts.getOnNextEvents().isEmpty());\n         ts.assertNoErrors();\n     }\n+    \n+    @Test\n+    public void testBackpressureOnFirstObservable() {\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0);\n+        Observable.just(1,2,3).switchIfEmpty(Observable.just(4, 5, 6)).subscribe(ts);\n+        ts.assertNotCompleted();\n+        ts.assertNoErrors();\n+        ts.assertNoValues();\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testRequestsNotLost() throws InterruptedException {\n+        final TestSubscriber<Long> ts = new TestSubscriber<Long>(0);\n+        Observable.create(new OnSubscribe<Long>() {\n+\n+            @Override\n+            public void call(final Subscriber<? super Long> subscriber) {\n+                subscriber.setProducer(new Producer() {\n+                    final AtomicBoolean completed = new AtomicBoolean(false);\n+                    @Override\n+                    public void request(long n) {\n+                        if (n > 0 && completed.compareAndSet(false, true)) {\n+                            Schedulers.io().createWorker().schedule(new Action0() {\n+                                @Override\n+                                public void call() {\n+                                    subscriber.onCompleted();\n+                                }}, 100, TimeUnit.MILLISECONDS);\n+                        }\n+                    }});\n+            }})\n+          .switchIfEmpty(Observable.from(Arrays.asList(1L, 2L, 3L)))\n+          .subscribeOn(Schedulers.computation())\n+          .subscribe(ts);\n+        ts.requestMore(0);\n+        Thread.sleep(50);\n+        //request while first observable is still finishing (as empty)\n+        ts.requestMore(1);\n+        ts.requestMore(1);\n+        Thread.sleep(500);\n+        ts.assertNotCompleted();\n+        ts.assertNoErrors();\n+        ts.assertValueCount(2);\n+        ts.unsubscribe();\n+    }\n }\n\\ No newline at end of file",
    "output": "Fix request processing in OperatorSwitchIfNext"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorSwitch.java b/src/main/java/rx/internal/operators/OperatorSwitch.java\n--- a/src/main/java/rx/internal/operators/OperatorSwitch.java\n+++ b/src/main/java/rx/internal/operators/OperatorSwitch.java\n@@ -94,15 +94,26 @@ public void request(long n) {\n                     synchronized (guard) {\n                         localSubscriber = currentSubscriber;\n                         if (currentSubscriber == null) {\n-                            initialRequested = n;\n+                            long r = initialRequested + n;\n+                            if (r < 0) {\n+                                infinite = true;\n+                            } else {\n+                                initialRequested = r;\n+                            }\n                         } else {\n-                            // If n == Long.MAX_VALUE, infinite will become true. Then currentSubscriber.requested won't be used.\n-                            // Therefore we don't need to worry about overflow.\n-                            currentSubscriber.requested += n;\n+                            long r = currentSubscriber.requested + n;\n+                            if (r < 0) {\n+                                infinite = true;\n+                            } else {\n+                                currentSubscriber.requested = r;\n+                            }\n                         }\n                     }\n                     if (localSubscriber != null) {\n-                        localSubscriber.requestMore(n);\n+                        if (infinite)\n+                            localSubscriber.requestMore(Long.MAX_VALUE);\n+                        else \n+                            localSubscriber.requestMore(n);\n                     }\n                 }\n             });\n@@ -167,7 +178,8 @@ void emit(T value, int id, InnerSubscriber innerSubscriber) {\n                     if (queue == null) {\n                         queue = new ArrayList<Object>();\n                     }\n-                    innerSubscriber.requested--;\n+                    if (innerSubscriber.requested != Long.MAX_VALUE)\n+                        innerSubscriber.requested--;\n                     queue.add(value);\n                     return;\n                 }\n@@ -183,7 +195,8 @@ void emit(T value, int id, InnerSubscriber innerSubscriber) {\n                     if (once) {\n                         once = false;\n                         synchronized (guard) {\n-                            innerSubscriber.requested--;\n+                            if (innerSubscriber.requested != Long.MAX_VALUE)\n+                                innerSubscriber.requested--;\n                         }\n                         s.onNext(value);\n                     }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorSwitchTest.java b/src/test/java/rx/internal/operators/OperatorSwitchTest.java\n--- a/src/test/java/rx/internal/operators/OperatorSwitchTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorSwitchTest.java\n@@ -15,12 +15,20 @@\n  */\n package rx.internal.operators;\n \n+import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.Matchers.any;\n import static org.mockito.Matchers.anyString;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n@@ -36,6 +44,7 @@\n import rx.Subscriber;\n import rx.exceptions.TestException;\n import rx.functions.Action0;\n+import rx.functions.Action1;\n import rx.functions.Func1;\n import rx.observers.TestSubscriber;\n import rx.schedulers.TestScheduler;\n@@ -574,4 +583,91 @@ public void onNext(String t) {\n         \n         Assert.assertEquals(250, ts.getOnNextEvents().size());\n     }\n+    \n+    @Test(timeout = 10000)\n+    public void testInitialRequestsAreAdditive() {\n+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0);\n+        Observable.switchOnNext(\n+                Observable.interval(100, TimeUnit.MILLISECONDS)\n+                          .map(\n+                                new Func1<Long, Observable<Long>>() {\n+                                    @Override\n+                                    public Observable<Long> call(Long t) {\n+                                        return Observable.just(1L, 2L, 3L);\n+                                    }\n+                                }\n+                          ).take(3))\n+                          .subscribe(ts);\n+        ts.requestMore(Long.MAX_VALUE - 100);\n+        ts.requestMore(1);\n+        ts.awaitTerminalEvent();\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testInitialRequestsDontOverflow() {\n+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0);\n+        Observable.switchOnNext(\n+                Observable.interval(100, TimeUnit.MILLISECONDS)\n+                        .map(new Func1<Long, Observable<Long>>() {\n+                            @Override\n+                            public Observable<Long> call(Long t) {\n+                                return Observable.from(Arrays.asList(1L, 2L, 3L));\n+                            }\n+                        }).take(3)).subscribe(ts);\n+        ts.requestMore(Long.MAX_VALUE - 1);\n+        ts.requestMore(2);\n+        ts.awaitTerminalEvent();\n+        assertTrue(ts.getOnNextEvents().size() > 0);\n+    }\n+    \n+    \n+    @Test(timeout = 10000)\n+    public void testSecondaryRequestsDontOverflow() throws InterruptedException {\n+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0);\n+        Observable.switchOnNext(\n+                Observable.interval(100, TimeUnit.MILLISECONDS)\n+                        .map(new Func1<Long, Observable<Long>>() {\n+                            @Override\n+                            public Observable<Long> call(Long t) {\n+                                return Observable.from(Arrays.asList(1L, 2L, 3L));\n+                            }\n+                        }).take(3)).subscribe(ts);\n+        ts.requestMore(1);\n+        //we will miss two of the first observable\n+        Thread.sleep(250);\n+        ts.requestMore(Long.MAX_VALUE - 1);\n+        ts.requestMore(Long.MAX_VALUE - 1);\n+        ts.awaitTerminalEvent();\n+        ts.assertValueCount(7);\n+    }\n+    \n+    @Test(timeout = 10000)\n+    public void testSecondaryRequestsAdditivelyAreMoreThanLongMaxValueInducesMaxValueRequestFromUpstream() throws InterruptedException {\n+        final List<Long> requests = new CopyOnWriteArrayList<Long>();\n+        final Action1<Long> addRequest = new Action1<Long>() {\n+\n+            @Override\n+            public void call(Long n) {\n+                requests.add(n);\n+            }};\n+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0);\n+        Observable.switchOnNext(\n+                Observable.interval(100, TimeUnit.MILLISECONDS)\n+                        .map(new Func1<Long, Observable<Long>>() {\n+                            @Override\n+                            public Observable<Long> call(Long t) {\n+                                return Observable.from(Arrays.asList(1L, 2L, 3L)).doOnRequest(addRequest);\n+                            }\n+                        }).take(3)).subscribe(ts);\n+        ts.requestMore(1);\n+        //we will miss two of the first observable\n+        Thread.sleep(250);\n+        ts.requestMore(Long.MAX_VALUE - 1);\n+        ts.requestMore(Long.MAX_VALUE - 1);\n+        ts.awaitTerminalEvent();\n+        assertTrue(ts.getOnNextEvents().size() > 0);\n+        assertEquals(5, (int) requests.size());\n+        assertEquals(Long.MAX_VALUE, (long) requests.get(3));\n+        assertEquals(Long.MAX_VALUE, (long) requests.get(4));\n+    }\n }",
    "output": "Add request overflow checking to OperatorSwitch"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorTakeWhile.java b/src/main/java/rx/internal/operators/OperatorTakeWhile.java\n--- a/src/main/java/rx/internal/operators/OperatorTakeWhile.java\n+++ b/src/main/java/rx/internal/operators/OperatorTakeWhile.java\n@@ -17,6 +17,8 @@\n \n import rx.Observable.Operator;\n import rx.Subscriber;\n+import rx.exceptions.Exceptions;\n+import rx.exceptions.OnErrorThrowable;\n import rx.functions.Func1;\n import rx.functions.Func2;\n \n@@ -52,18 +54,19 @@ public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {\n             private boolean done = false;\n \n             @Override\n-            public void onNext(T args) {\n+            public void onNext(T t) {\n                 boolean isSelected;\n                 try {\n-                    isSelected = predicate.call(args, counter++);\n+                    isSelected = predicate.call(t, counter++);\n                 } catch (Throwable e) {\n                     done = true;\n-                    subscriber.onError(e);\n+                    Exceptions.throwIfFatal(e);\n+                    subscriber.onError(OnErrorThrowable.addValueAsLastCause(e, t));\n                     unsubscribe();\n                     return;\n                 }\n                 if (isSelected) {\n-                    subscriber.onNext(args);\n+                    subscriber.onNext(t);\n                 } else {\n                     done = true;\n                     subscriber.onCompleted();\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorTakeWhileTest.java b/src/test/java/rx/internal/operators/OperatorTakeWhileTest.java\n--- a/src/test/java/rx/internal/operators/OperatorTakeWhileTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorTakeWhileTest.java\n@@ -15,6 +15,7 @@\n  */\n package rx.internal.operators;\n \n+import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.*;\n@@ -25,6 +26,7 @@\n \n import rx.*;\n import rx.Observable.OnSubscribe;\n+import rx.exceptions.TestException;\n import rx.functions.Func1;\n import rx.observers.TestSubscriber;\n import rx.subjects.*;\n@@ -261,4 +263,20 @@ public Boolean call(Integer t1) {\n         \n         Assert.assertFalse(\"Unsubscribed!\", ts.isUnsubscribed());\n     }\n+    \n+    @Test\n+    public void testErrorCauseIncludesLastValue() {\n+        TestSubscriber<String> ts = new TestSubscriber<String>();\n+        Observable.just(\"abc\").takeWhile(new Func1<String, Boolean>() {\n+            @Override\n+            public Boolean call(String t1) {\n+                throw new TestException();\n+            }\n+        }).subscribe(ts);\n+        \n+        ts.assertTerminalEvent();\n+        ts.assertNoValues();\n+        assertTrue(ts.getOnErrorEvents().get(0).getCause().getMessage().contains(\"abc\"));\n+    }\n+    \n }",
    "output": "Add value as last cause to error in takeWhile(predicate)"
  },
  {
    "input": "diff --git a/src/main/java/rx/exceptions/OnErrorThrowable.java b/src/main/java/rx/exceptions/OnErrorThrowable.java\n--- a/src/main/java/rx/exceptions/OnErrorThrowable.java\n+++ b/src/main/java/rx/exceptions/OnErrorThrowable.java\n@@ -15,6 +15,9 @@\n  */\n package rx.exceptions;\n \n+import java.util.HashSet;\n+import java.util.Set;\n+\n import rx.plugins.RxJavaErrorHandler;\n import rx.plugins.RxJavaPlugins;\n \n@@ -109,6 +112,27 @@ public static Throwable addValueAsLastCause(Throwable e, Object value) {\n     public static class OnNextValue extends RuntimeException {\n \n         private static final long serialVersionUID = -3454462756050397899L;\n+        \n+        // Lazy loaded singleton \n+        private static final class Primitives {\n+            \n+            static final Set<Class<?>> INSTANCE = create();\n+\n+            private static Set<Class<?>> create() {\n+                Set<Class<?>> set = new HashSet<Class<?>>();\n+                set.add(Boolean.class);\n+                set.add(Character.class);\n+                set.add(Byte.class);\n+                set.add(Short.class);\n+                set.add(Integer.class);\n+                set.add(Long.class);\n+                set.add(Float.class);\n+                set.add(Double.class);\n+                // Void is another primitive but cannot be instantiated \n+                // and is caught by the null check in renderValue\n+                return set;\n+            }\n+        }\n \n         private final Object value;\n \n@@ -148,11 +172,11 @@ public Object getValue() {\n          * @return a string version of the object if primitive or managed through error plugin,\n          *        otherwise the classname of the object\n          */\n-        private static String renderValue(Object value){\n+        static String renderValue(Object value){\n             if (value == null) {\n                 return \"null\";\n             }\n-            if (value.getClass().isPrimitive()) {\n+            if (Primitives.INSTANCE.contains(value.getClass())) {\n                 return value.toString();\n             }\n             if (value instanceof String) {\n\ndiff --git a/src/test/java/rx/exceptions/OnNextValueTest.java b/src/test/java/rx/exceptions/OnNextValueTest.java\n--- a/src/test/java/rx/exceptions/OnNextValueTest.java\n+++ b/src/test/java/rx/exceptions/OnNextValueTest.java\n@@ -15,14 +15,18 @@\n  */\n package rx.exceptions;\n \n+import org.junit.Assert;\n import org.junit.Test;\n+\n import rx.Observable;\n import rx.Observer;\n+import rx.exceptions.OnErrorThrowable.OnNextValue;\n import rx.functions.Func1;\n \n import java.io.PrintWriter;\n import java.io.StringWriter;\n \n+import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n@@ -118,4 +122,49 @@ public BadToString call(BadToString badToString) {\n                 }).subscribe(observer);\n \n     }\n+    \n+    @Test\n+    public void testRenderInteger() {\n+        assertEquals(\"123\", OnNextValue.renderValue(123));\n+    }\n+    \n+    @Test\n+    public void testRenderByte() {\n+        assertEquals(\"10\", OnNextValue.renderValue((byte) 10));\n+    }\n+    \n+    @Test\n+    public void testRenderBoolean() {\n+        assertEquals(\"true\", OnNextValue.renderValue(true));\n+    }\n+    \n+    @Test\n+    public void testRenderShort() {\n+        assertEquals(\"10\", OnNextValue.renderValue((short) 10));\n+    }\n+    \n+    @Test\n+    public void testRenderLong() {\n+        assertEquals(\"10\", OnNextValue.renderValue(10L));\n+    }\n+    \n+    @Test\n+    public void testRenderCharacter() {\n+        assertEquals(\"10\", OnNextValue.renderValue(10L));\n+    }\n+    \n+    @Test\n+    public void testRenderFloat() {\n+        assertEquals(\"10.0\", OnNextValue.renderValue(10.0f));\n+    }\n+    \n+    @Test\n+    public void testRenderDouble() {\n+        assertEquals(\"10.0\", OnNextValue.renderValue(10.0));\n+    }\n+    \n+    @Test\n+    public void testRenderVoid() {\n+        assertEquals(\"null\", OnNextValue.renderValue((Void) null));\n+    }\n }",
    "output": "Fix render value in error last cause for primitive types"
  },
  {
    "input": "diff --git a/src/main/java/rx/Subscriber.java b/src/main/java/rx/Subscriber.java\n--- a/src/main/java/rx/Subscriber.java\n+++ b/src/main/java/rx/Subscriber.java\n@@ -31,20 +31,23 @@\n  *          the type of items the Subscriber expects to observe\n  */\n public abstract class Subscriber<T> implements Observer<T>, Subscription {\n+    \n+    // represents requested not set yet\n+    private static final Long NOT_SET = Long.MIN_VALUE;\n \n-    private final SubscriptionList cs;\n-    private final Subscriber<?> op;\n+    private final SubscriptionList subscriptions;\n+    private final Subscriber<?> subscriber;\n     /* protected by `this` */\n-    private Producer p;\n+    private Producer producer;\n     /* protected by `this` */\n-    private long requested = Long.MIN_VALUE; // default to not set\n+    private long requested = NOT_SET; // default to not set\n \n     protected Subscriber() {\n         this(null, false);\n     }\n \n-    protected Subscriber(Subscriber<?> op) {\n-        this(op, true);\n+    protected Subscriber(Subscriber<?> subscriber) {\n+        this(subscriber, true);\n     }\n \n     /**\n@@ -53,15 +56,15 @@ protected Subscriber(Subscriber<?> op) {\n      * <p>\n      * To retain the chaining of subscribers, add the created instance to {@code op} via {@link #add}.\n      * \n-     * @param op\n+     * @param subscriber\n      *            the other Subscriber\n      * @param shareSubscriptions\n      *            {@code true} to share the subscription list in {@code op} with this instance\n      * @since 1.0.6\n      */\n-    protected Subscriber(Subscriber<?> op, boolean shareSubscriptions) {\n-        this.op = op;\n-        this.cs = shareSubscriptions && op != null ? op.cs : new SubscriptionList();\n+    protected Subscriber(Subscriber<?> subscriber, boolean shareSubscriptions) {\n+        this.subscriber = subscriber;\n+        this.subscriptions = shareSubscriptions && subscriber != null ? subscriber.subscriptions : new SubscriptionList();\n     }\n \n     /**\n@@ -73,12 +76,12 @@ protected Subscriber(Subscriber<?> op, boolean shareSubscriptions) {\n      *            the {@code Subscription} to add\n      */\n     public final void add(Subscription s) {\n-        cs.add(s);\n+        subscriptions.add(s);\n     }\n \n     @Override\n     public final void unsubscribe() {\n-        cs.unsubscribe();\n+        subscriptions.unsubscribe();\n     }\n \n     /**\n@@ -88,7 +91,7 @@ public final void unsubscribe() {\n      */\n     @Override\n     public final boolean isUnsubscribed() {\n-        return cs.isUnsubscribed();\n+        return subscriptions.isUnsubscribed();\n     }\n \n     /**\n@@ -124,57 +127,64 @@ protected final void request(long n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"number requested cannot be negative: \" + n);\n         } \n-        Producer shouldRequest = null;\n+        \n+        // if producer is set then we will request from it\n+        // otherwise we increase the requested count by n\n+        Producer producerToRequestFrom = null;\n         synchronized (this) {\n-            if (p != null) {\n-                shouldRequest = p;\n-            } else if (requested == Long.MIN_VALUE) {\n-                requested = n;\n-            } else { \n-                final long total = requested + n;\n-                // check if overflow occurred\n-                if (total < 0) {\n-                    requested = Long.MAX_VALUE;\n-                } else {\n-                    requested = total;\n-                }\n+            if (producer != null) {\n+                producerToRequestFrom = producer;\n+            } else {\n+                addToRequested(n);\n+                return;\n             }\n         }\n-        // after releasing lock\n-        if (shouldRequest != null) {\n-            shouldRequest.request(n);\n-        }\n+        // after releasing lock (we should not make requests holding a lock)\n+        producerToRequestFrom.request(n);\n     }\n \n+    private void addToRequested(long n) {\n+        if (requested == NOT_SET) {\n+            requested = n;\n+        } else { \n+            final long total = requested + n;\n+            // check if overflow occurred\n+            if (total < 0) {\n+                requested = Long.MAX_VALUE;\n+            } else {\n+                requested = total;\n+            }\n+        }\n+    }\n+    \n     /**\n      * @warn javadoc description missing\n      * @warn param producer not described\n-     * @param producer\n+     * @param p\n      */\n-    public void setProducer(Producer producer) {\n+    public void setProducer(Producer p) {\n         long toRequest;\n-        boolean setProducer = false;\n+        boolean passToSubscriber = false;\n         synchronized (this) {\n             toRequest = requested;\n-            p = producer;\n-            if (op != null) {\n+            producer = p;\n+            if (subscriber != null) {\n                 // middle operator ... we pass thru unless a request has been made\n-                if (toRequest == Long.MIN_VALUE) {\n+                if (toRequest == NOT_SET) {\n                     // we pass-thru to the next producer as nothing has been requested\n-                    setProducer = true;\n+                    passToSubscriber = true;\n                 }\n-\n             }\n         }\n         // do after releasing lock\n-        if (setProducer) {\n-            op.setProducer(p);\n+        if (passToSubscriber) {\n+            subscriber.setProducer(producer);\n         } else {\n             // we execute the request with whatever has been requested (or Long.MAX_VALUE)\n-            if (toRequest == Long.MIN_VALUE) {\n-                p.request(Long.MAX_VALUE);\n+            if (toRequest == NOT_SET) {\n+                producer.request(Long.MAX_VALUE);\n             } else {\n-                p.request(toRequest);\n+                producer.request(toRequest);\n             }\n         }\n     }",
    "output": "Improve Subscriber readability and don't perform unnecessary test in request method"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorAny.java b/src/main/java/rx/internal/operators/OperatorAny.java\n--- a/src/main/java/rx/internal/operators/OperatorAny.java\n+++ b/src/main/java/rx/internal/operators/OperatorAny.java\n@@ -19,7 +19,10 @@\n import rx.Observable;\n import rx.Observable.Operator;\n import rx.Subscriber;\n+import rx.exceptions.Exceptions;\n+import rx.exceptions.OnErrorThrowable;\n import rx.functions.Func1;\n+import rx.internal.producers.SingleDelayedProducer;\n \n /**\n  * Returns an {@link Observable} that emits <code>true</code> if any element of\n@@ -36,23 +39,29 @@ public OperatorAny(Func1<? super T, Boolean> predicate, boolean returnOnEmpty) {\n \n     @Override\n     public Subscriber<? super T> call(final Subscriber<? super Boolean> child) {\n+        final SingleDelayedProducer<Boolean> producer = new SingleDelayedProducer<Boolean>(child);\n         Subscriber<T> s = new Subscriber<T>() {\n             boolean hasElements;\n             boolean done;\n \n             @Override\n             public void onNext(T t) {\n                 hasElements = true;\n-                boolean result = predicate.call(t);\n+                boolean result;\n+                try {\n+                    result = predicate.call(t);\n+                } catch (Throwable e) {\n+                    Exceptions.throwIfFatal(e);\n+                    onError(OnErrorThrowable.addValueAsLastCause(e, t));\n+                    return;\n+                }\n                 if (result && !done) {\n                     done = true;\n-                    child.onNext(!returnOnEmpty);\n-                    child.onCompleted();\n+                    producer.setValue(!returnOnEmpty);\n                     unsubscribe();\n-                } else {\n-                    // if we drop values we must replace them upstream as downstream won't receive and request more\n-                    request(1);\n-                }\n+                } \n+                // note that don't need to request more of upstream because this subscriber \n+                // defaults to requesting Long.MAX_VALUE\n             }\n \n             @Override\n@@ -65,16 +74,16 @@ public void onCompleted() {\n                 if (!done) {\n                     done = true;\n                     if (hasElements) {\n-                        child.onNext(false);\n+                        producer.setValue(false);\n                     } else {\n-                        child.onNext(returnOnEmpty);\n+                        producer.setValue(returnOnEmpty);\n                     }\n-                    child.onCompleted();\n                 }\n             }\n \n         };\n         child.add(s);\n+        child.setProducer(producer);\n         return s;\n     }\n }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorAnyTest.java b/src/test/java/rx/internal/operators/OperatorAnyTest.java\n--- a/src/test/java/rx/internal/operators/OperatorAnyTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorAnyTest.java\n@@ -19,13 +19,15 @@\n import static org.mockito.Mockito.*;\n \n import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.TimeUnit;\n \n import org.junit.Test;\n \n import rx.*;\n import rx.functions.Func1;\n import rx.internal.util.UtilityFunctions;\n+import rx.observers.TestSubscriber;\n \n public class OperatorAnyTest {\n \n@@ -220,4 +222,52 @@ public Observable<Integer> call(Boolean t1) {\n         });\n         assertEquals((Object)2, source.toBlocking().first());\n     }\n+    \n+    @Test\n+    public void testBackpressureIfNoneRequestedNoneShouldBeDelivered() {\n+        TestSubscriber<Boolean> ts = new TestSubscriber<Boolean>(0);\n+        Observable.just(1).exists(new Func1<Object, Boolean>() {\n+            @Override\n+            public Boolean call(Object t1) {\n+                return true;\n+            }\n+        }).subscribe(ts);\n+        ts.assertNoValues();\n+        ts.assertNoErrors();\n+        ts.assertNotCompleted();\n+    }\n+    \n+    @Test\n+    public void testBackpressureIfOneRequestedOneShouldBeDelivered() {\n+        TestSubscriber<Boolean> ts = new TestSubscriber<Boolean>(1);\n+        Observable.just(1).exists(new Func1<Object, Boolean>() {\n+            @Override\n+            public Boolean call(Object object) {\n+                return true;\n+            }\n+        }).subscribe(ts);\n+        ts.assertTerminalEvent();\n+        ts.assertNoErrors();\n+        ts.assertCompleted();\n+        ts.assertValue(true);\n+    }\n+    \n+    @Test\n+    public void testPredicateThrowsExceptionAndValueInCauseMessage() {\n+        TestSubscriber<Boolean> ts = new TestSubscriber<Boolean>(0);\n+        final IllegalArgumentException ex = new IllegalArgumentException();\n+        Observable.just(\"Boo!\").exists(new Func1<Object, Boolean>() {\n+            @Override\n+            public Boolean call(Object object) {\n+                throw ex;\n+            }\n+        }).subscribe(ts);\n+        ts.assertTerminalEvent();\n+        ts.assertNoValues();\n+        ts.assertNotCompleted();\n+        List<Throwable> errors = ts.getOnErrorEvents();\n+        assertEquals(1, errors.size());\n+        assertEquals(ex, errors.get(0));\n+        assertTrue(ex.getCause().getMessage().contains(\"Boo!\"));\n+    }\n }",
    "output": "Add backpressure support for OperatorAny and include last value in exception cause"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorSkip.java b/src/main/java/rx/internal/operators/OperatorSkip.java\n--- a/src/main/java/rx/internal/operators/OperatorSkip.java\n+++ b/src/main/java/rx/internal/operators/OperatorSkip.java\n@@ -15,6 +15,8 @@\n  */\n package rx.internal.operators;\n \n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import rx.Observable;\n import rx.Producer;\n import rx.Subscriber;\n@@ -63,19 +65,8 @@ public void onNext(T t) {\n \n             @Override\n             public void setProducer(final Producer producer) {\n-                child.setProducer(new Producer() {\n-\n-                    @Override\n-                    public void request(long n) {\n-                        if (n == Long.MAX_VALUE) {\n-                            // infinite so leave it alone\n-                            producer.request(n);\n-                        } else if (n > 0) {\n-                            // add the skip num to the requested amount, since we'll skip everything and then emit to the buffer downstream\n-                            producer.request(n + (toSkip - skipped));\n-                        }\n-                    }\n-                });\n+                child.setProducer(producer);\n+                producer.request(toSkip);\n             }\n \n         };\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorSkipTest.java b/src/test/java/rx/internal/operators/OperatorSkipTest.java\n--- a/src/test/java/rx/internal/operators/OperatorSkipTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorSkipTest.java\n@@ -15,17 +15,23 @@\n  */\n package rx.internal.operators;\n \n+import static org.junit.Assert.assertEquals;\n import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n \n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n import org.junit.Test;\n \n import rx.Observable;\n import rx.Observer;\n-import rx.internal.operators.OperatorSkip;\n+import rx.functions.Action1;\n+import rx.observers.TestSubscriber;\n \n public class OperatorSkipTest {\n \n@@ -144,4 +150,36 @@ public void testSkipError() {\n         verify(observer, never()).onCompleted();\n \n     }\n+    \n+    @Test\n+    public void testBackpressureMultipleSmallAsyncRequests() throws InterruptedException {\n+        final AtomicLong requests = new AtomicLong(0);\n+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0);\n+        Observable.interval(100, TimeUnit.MILLISECONDS)\n+                .doOnRequest(new Action1<Long>() {\n+                    @Override\n+                    public void call(Long n) {\n+                        requests.addAndGet(n);\n+                    }\n+                }).skip(4).subscribe(ts);\n+        Thread.sleep(100);\n+        ts.requestMore(1);\n+        ts.requestMore(1);\n+        Thread.sleep(100);\n+        ts.unsubscribe();\n+        ts.assertUnsubscribed();\n+        ts.assertNoErrors();\n+        assertEquals(6, requests.get());\n+    }\n+    \n+    @Test\n+    public void testRequestOverflowDoesNotOccur() {\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(Long.MAX_VALUE-1);\n+        Observable.range(1, 10).skip(5).subscribe(ts);\n+        ts.assertTerminalEvent();\n+        ts.assertCompleted();\n+        ts.assertNoErrors();\n+        assertEquals(Arrays.asList(6,7,8,9,10), ts.getOnNextEvents());\n+    }\n+    \n }",
    "output": "Fix skip race conditions and request overflow"
  },
  {
    "input": "diff --git a/src/test/java/rx/internal/operators/OperatorSerializeTest.java b/src/test/java/rx/internal/operators/OperatorSerializeTest.java\n--- a/src/test/java/rx/internal/operators/OperatorSerializeTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorSerializeTest.java\n@@ -120,31 +120,38 @@ public void testMultiThreadedWithNPE() {\n \n     @Test\n     public void testMultiThreadedWithNPEinMiddle() {\n-        TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(\"one\", \"two\", \"three\", null, \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\");\n-        Observable<String> w = Observable.create(onSubscribe);\n-\n-        BusyObserver busyobserver = new BusyObserver();\n-\n-        w.serialize().subscribe(busyobserver);\n-        onSubscribe.waitToFinish();\n-\n-        System.out.println(\"maxConcurrentThreads: \" + onSubscribe.maxConcurrentThreads.get());\n-        // this should not be the full number of items since the error should stop it before it completes all 9\n-        System.out.println(\"onNext count: \" + busyobserver.onNextCount.get());\n-        assertTrue(busyobserver.onNextCount.get() < 9);\n-        assertTrue(busyobserver.onError);\n-        // no onCompleted because onError was invoked\n-        assertFalse(busyobserver.onCompleted);\n-        // non-deterministic because unsubscribe happens after 'waitToFinish' releases\n-        // so commenting out for now as this is not a critical thing to test here\n-        // verify(s, times(1)).unsubscribe();\n-\n-        // we can have concurrency ...\n-        assertTrue(onSubscribe.maxConcurrentThreads.get() > 1);\n-        // ... but the onNext execution should be single threaded\n-        assertEquals(1, busyobserver.maxConcurrentThreads.get());\n+        boolean lessThan9 = false;\n+        for (int i = 0; i < 3; i++) {\n+            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(\"one\", \"two\", \"three\", null, \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\");\n+            Observable<String> w = Observable.create(onSubscribe);\n+    \n+            BusyObserver busyobserver = new BusyObserver();\n+    \n+            w.serialize().subscribe(busyobserver);\n+            onSubscribe.waitToFinish();\n+    \n+            System.out.println(\"maxConcurrentThreads: \" + onSubscribe.maxConcurrentThreads.get());\n+            // this should not always be the full number of items since the error should (very often) \n+            // stop it before it completes all 9\n+            System.out.println(\"onNext count: \" + busyobserver.onNextCount.get());\n+            if (busyobserver.onNextCount.get() < 9) {\n+                lessThan9 = true;\n+            }\n+            assertTrue(busyobserver.onError);\n+            // no onCompleted because onError was invoked\n+            assertFalse(busyobserver.onCompleted);\n+            // non-deterministic because unsubscribe happens after 'waitToFinish' releases\n+            // so commenting out for now as this is not a critical thing to test here\n+            // verify(s, times(1)).unsubscribe();\n+    \n+            // we can have concurrency ...\n+            assertTrue(onSubscribe.maxConcurrentThreads.get() > 1);\n+            // ... but the onNext execution should be single threaded\n+            assertEquals(1, busyobserver.maxConcurrentThreads.get());\n+        }\n+        assertTrue(lessThan9);\n     }\n-\n+    \n     /**\n      * A thread that will pass data to onNext\n      */\n@@ -276,6 +283,7 @@ public TestMultiThreadedObservable(String... values) {\n         @Override\n         public void call(final Subscriber<? super String> observer) {\n             System.out.println(\"TestMultiThreadedObservable subscribed to ...\");\n+            final NullPointerException npe = new NullPointerException();\n             t = new Thread(new Runnable() {\n \n                 @Override\n@@ -290,11 +298,12 @@ public void run() {\n                                     threadsRunning.incrementAndGet();\n                                     try {\n                                         // perform onNext call\n-                                        System.out.println(\"TestMultiThreadedObservable onNext: \" + s);\n                                         if (s == null) {\n+                                            System.out.println(\"TestMultiThreadedObservable onNext: null\");\n                                             // force an error\n-                                            throw new NullPointerException();\n-                                        }\n+                                            throw npe;\n+                                        } else \n+                                            System.out.println(\"TestMultiThreadedObservable onNext: \" + s);\n                                         observer.onNext(s);\n                                         // capture 'maxThreads'\n                                         int concurrentThreads = threadsRunning.get();",
    "output": "Make OperatorSerializeTest.testMultiThreadedWithNPEinMiddle fail less often"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorConcat.java b/src/main/java/rx/internal/operators/OperatorConcat.java\n--- a/src/main/java/rx/internal/operators/OperatorConcat.java\n+++ b/src/main/java/rx/internal/operators/OperatorConcat.java\n@@ -24,6 +24,7 @@\n import rx.Producer;\n import rx.Subscriber;\n import rx.functions.Action0;\n+import rx.internal.producers.ProducerArbiter;\n import rx.observers.SerializedSubscriber;\n import rx.subscriptions.SerialSubscription;\n import rx.subscriptions.Subscriptions;\n@@ -85,17 +86,19 @@ static final class ConcatSubscriber<T> extends Subscriber<Observable<? extends T\n \n         volatile int wip;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, \"wip\");\n+        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, \"wip\");\n \n-        // accessed by REQUESTED_UPDATER\n+        // accessed by REQUESTED\n         private volatile long requested;\n         @SuppressWarnings(\"rawtypes\")\n-        private static final AtomicLongFieldUpdater<ConcatSubscriber> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(ConcatSubscriber.class, \"requested\");\n+        private static final AtomicLongFieldUpdater<ConcatSubscriber> REQUESTED = AtomicLongFieldUpdater.newUpdater(ConcatSubscriber.class, \"requested\");\n+        private final ProducerArbiter arbiter;\n \n         public ConcatSubscriber(Subscriber<T> s, SerialSubscription current) {\n             super(s);\n             this.child = s;\n             this.current = current;\n+            this.arbiter = new ProducerArbiter();\n             this.queue = new ConcurrentLinkedQueue<Object>();\n             add(Subscriptions.create(new Action0() {\n                 @Override\n@@ -113,32 +116,27 @@ public void onStart() {\n         }\n \n         private void requestFromChild(long n) {\n+            if (n <=0) return;\n             // we track 'requested' so we know whether we should subscribe the next or not\n-            ConcatInnerSubscriber<T> actualSubscriber = currentSubscriber;\n-            if (n > 0 && BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n) == 0) {\n-                if (actualSubscriber == null && wip > 0) {\n+            long previous = BackpressureUtils.getAndAddRequest(REQUESTED, this, n);\n+            arbiter.request(n);\n+            if (previous == 0) {\n+                if (currentSubscriber == null && wip > 0) {\n                     // this means we may be moving from one subscriber to another after having stopped processing\n                     // so need to kick off the subscribe via this request notification\n                     subscribeNext();\n-                    // return here as we don't want to do the requestMore logic below (which would double request)\n-                    return;\n                 }\n             } \n-                \n-            if (actualSubscriber != null) {\n-                // otherwise we are just passing it through to the currentSubscriber\n-                actualSubscriber.requestMore(n);\n-            }\n         }\n \n         private void decrementRequested() {\n-            REQUESTED_UPDATER.decrementAndGet(this);\n+            REQUESTED.decrementAndGet(this);\n         }\n \n         @Override\n         public void onNext(Observable<? extends T> t) {\n             queue.add(nl.next(t));\n-            if (WIP_UPDATER.getAndIncrement(this) == 0) {\n+            if (WIP.getAndIncrement(this) == 0) {\n                 subscribeNext();\n             }\n         }\n@@ -152,14 +150,15 @@ public void onError(Throwable e) {\n         @Override\n         public void onCompleted() {\n             queue.add(nl.completed());\n-            if (WIP_UPDATER.getAndIncrement(this) == 0) {\n+            if (WIP.getAndIncrement(this) == 0) {\n                 subscribeNext();\n             }\n         }\n+        \n \n         void completeInner() {\n             currentSubscriber = null;\n-            if (WIP_UPDATER.decrementAndGet(this) > 0) {\n+            if (WIP.decrementAndGet(this) > 0) {\n                 subscribeNext();\n             }\n             request(1);\n@@ -172,7 +171,7 @@ void subscribeNext() {\n                     child.onCompleted();\n                 } else if (o != null) {\n                     Observable<? extends T> obs = nl.getValue(o);\n-                    currentSubscriber = new ConcatInnerSubscriber<T>(this, child, requested);\n+                    currentSubscriber = new ConcatInnerSubscriber<T>(this, child, arbiter);\n                     current.set(currentSubscriber);\n                     obs.unsafeSubscribe(currentSubscriber);\n                 }\n@@ -193,39 +192,42 @@ static class ConcatInnerSubscriber<T> extends Subscriber<T> {\n         @SuppressWarnings(\"unused\")\n         private volatile int once = 0;\n         @SuppressWarnings(\"rawtypes\")\n-        private final static AtomicIntegerFieldUpdater<ConcatInnerSubscriber> ONCE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatInnerSubscriber.class, \"once\");\n+        private final static AtomicIntegerFieldUpdater<ConcatInnerSubscriber> ONCE = AtomicIntegerFieldUpdater.newUpdater(ConcatInnerSubscriber.class, \"once\");\n+        private final ProducerArbiter arbiter;\n \n-        public ConcatInnerSubscriber(ConcatSubscriber<T> parent, Subscriber<T> child, long initialRequest) {\n+        public ConcatInnerSubscriber(ConcatSubscriber<T> parent, Subscriber<T> child, ProducerArbiter arbiter) {\n             this.parent = parent;\n             this.child = child;\n-            request(initialRequest);\n-        }\n-\n-        void requestMore(long n) {\n-            request(n);\n+            this.arbiter = arbiter;\n         }\n-\n+        \n         @Override\n         public void onNext(T t) {\n-            parent.decrementRequested();\n             child.onNext(t);\n+            parent.decrementRequested();\n+            arbiter.produced(1);\n         }\n \n         @Override\n         public void onError(Throwable e) {\n-            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {\n+            if (ONCE.compareAndSet(this, 0, 1)) {\n                 // terminal error through parent so everything gets cleaned up, including this inner\n                 parent.onError(e);\n             }\n         }\n \n         @Override\n         public void onCompleted() {\n-            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {\n+            if (ONCE.compareAndSet(this, 0, 1)) {\n                 // terminal completion to parent so it continues to the next\n                 parent.completeInner();\n             }\n         }\n+        \n+        @Override\n+        public void setProducer(Producer producer) {\n+            arbiter.setProducer(producer);\n+        }\n \n     };\n }\n\ndiff --git a/src/main/java/rx/internal/producers/ProducerArbiter.java b/src/main/java/rx/internal/producers/ProducerArbiter.java\n--- a/src/main/java/rx/internal/producers/ProducerArbiter.java\n+++ b/src/main/java/rx/internal/producers/ProducerArbiter.java\n@@ -95,7 +95,7 @@ public void produced(long n) {\n             if (r != Long.MAX_VALUE) {\n                 long u = r - n;\n                 if (u < 0) {\n-                    throw new IllegalStateException();\n+                    throw new IllegalStateException(\"more items arrived than were requested\");\n                 }\n                 requested = u;\n             }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorConcatTest.java b/src/test/java/rx/internal/operators/OperatorConcatTest.java\n--- a/src/test/java/rx/internal/operators/OperatorConcatTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorConcatTest.java\n@@ -36,9 +36,7 @@\n import org.mockito.InOrder;\n \n import rx.Observable.OnSubscribe;\n-import rx.Scheduler.Worker;\n import rx.*;\n-import rx.functions.Action0;\n import rx.functions.Func1;\n import rx.internal.util.RxRingBuffer;\n import rx.observers.TestSubscriber;\n@@ -795,4 +793,33 @@ public void onNext(Integer t) {\n         assertTrue(completed.get());\n     }\n     \n+    @Test//(timeout = 100000)\n+    public void concatMapRangeAsyncLoopIssue2876() {\n+        final long durationSeconds = 2;\n+        final long startTime = System.currentTimeMillis();\n+        for (int i = 0;; i++) {\n+            //only run this for a max of ten seconds\n+            if (System.currentTimeMillis()-startTime > TimeUnit.SECONDS.toMillis(durationSeconds))\n+                return;\n+            if (i % 1000 == 0) {\n+                System.out.println(\"concatMapRangeAsyncLoop > \" + i);\n+            }\n+            TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+            Observable.range(0, 1000)\n+            .concatMap(new Func1<Integer, Observable<Integer>>() {\n+                @Override\n+                public Observable<Integer> call(Integer t) {\n+                    return Observable.from(Arrays.asList(t));\n+                }\n+            })\n+            .observeOn(Schedulers.computation()).subscribe(ts);\n+\n+            ts.awaitTerminalEvent(2500, TimeUnit.MILLISECONDS);\n+            ts.assertTerminalEvent();\n+            ts.assertNoErrors();\n+            assertEquals(1000, ts.getOnNextEvents().size());\n+            assertEquals((Integer)999, ts.getOnNextEvents().get(999));\n+        }\n+    }\n+    \n }",
    "output": "Fix OperatorConcat request race conditions with ProducerArbiter"
  },
  {
    "input": "diff --git a/src/main/java/rx/observers/TestSubscriber.java b/src/main/java/rx/observers/TestSubscriber.java\n--- a/src/main/java/rx/observers/TestSubscriber.java\n+++ b/src/main/java/rx/observers/TestSubscriber.java\n@@ -95,6 +95,31 @@ public TestSubscriber() {\n         this(-1);\n     }\n     \n+    @Experimental\n+    public static <T> TestSubscriber<T> create() {\n+        return new TestSubscriber<T>();\n+    }\n+    \n+    @Experimental\n+    public static <T> TestSubscriber<T> create(long initialRequest) {\n+        return new TestSubscriber<T>(initialRequest);\n+    }\n+    \n+    @Experimental\n+    public static <T> TestSubscriber<T> create(Observer<T> delegate, long initialRequest) {\n+        return new TestSubscriber<T>(delegate, initialRequest);\n+    }\n+    \n+    @Experimental\n+    public static <T> TestSubscriber<T> create(Subscriber<T> delegate) {\n+        return new TestSubscriber<T>(delegate);\n+    }\n+    \n+    @Experimental\n+    public static <T> TestSubscriber<T> create(Observer<T> delegate) {\n+        return new TestSubscriber<T>(delegate);\n+    }\n+    \n     @Override\n     public void onStart() {\n         if  (initialRequest >= 0) {\n\ndiff --git a/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java b/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java\n--- a/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java\n+++ b/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java\n@@ -106,7 +106,7 @@ public void testRangeWithOverflow5() {\n     @Test\n     public void testBackpressureViaRequest() {\n         OnSubscribeRange o = new OnSubscribeRange(1, RxRingBuffer.SIZE);\n-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        TestSubscriber<Integer> ts = TestSubscriber.create();\n         ts.assertReceivedOnNext(Collections.<Integer> emptyList());\n         ts.requestMore(1);\n         o.call(ts);\n@@ -127,7 +127,7 @@ public void testNoBackpressure() {\n         }\n \n         OnSubscribeRange o = new OnSubscribeRange(1, list.size());\n-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        TestSubscriber<Integer> ts = TestSubscriber.create();\n         ts.assertReceivedOnNext(Collections.<Integer> emptyList());\n         ts.requestMore(Long.MAX_VALUE); // infinite\n         o.call(ts);\n@@ -137,7 +137,7 @@ public void testNoBackpressure() {\n     void testWithBackpressureOneByOne(int start) {\n         Observable<Integer> source = Observable.range(start, 100);\n         \n-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        TestSubscriber<Integer> ts = TestSubscriber.create();\n         ts.requestMore(1);\n         source.subscribe(ts);\n         \n@@ -152,7 +152,7 @@ void testWithBackpressureOneByOne(int start) {\n     void testWithBackpressureAllAtOnce(int start) {\n         Observable<Integer> source = Observable.range(start, 100);\n         \n-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        TestSubscriber<Integer> ts = TestSubscriber.create();\n         ts.requestMore(100);\n         source.subscribe(ts);\n         \n@@ -179,7 +179,7 @@ public void testWithBackpressureAllAtOnce() {\n     public void testWithBackpressureRequestWayMore() {\n         Observable<Integer> source = Observable.range(50, 100);\n         \n-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        TestSubscriber<Integer> ts = TestSubscriber.create();\n         ts.requestMore(150);\n         source.subscribe(ts);\n         ",
    "output": "Add factory methods to TestSubscriber"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorGroupBy.java b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n--- a/src/main/java/rx/internal/operators/OperatorGroupBy.java\n+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n@@ -194,7 +194,7 @@ public void onError(Throwable e) {\n         // If we already have items queued when a request comes in we vend those and decrement the outstanding request count\n \n         void requestFromGroupedObservable(long n, GroupState<K, T> group) {\n-            group.requested.getAndAdd(n);\n+            BackpressureUtils.getAndAddRequest(group.requested, n);\n             if (group.count.getAndIncrement() == 0) {\n                 pollQueue(group);\n             }\n@@ -330,13 +330,19 @@ private void cleanupGroup(Object key) {\n         private void emitItem(GroupState<K, T> groupState, Object item) {\n             Queue<Object> q = groupState.buffer;\n             AtomicLong keyRequested = groupState.requested;\n+            //don't need to check for requested being Long.MAX_VALUE because this\n+            //field is capped at MAX_QUEUE_SIZE\n             REQUESTED.decrementAndGet(this);\n             // short circuit buffering\n             if (keyRequested != null && keyRequested.get() > 0 && (q == null || q.isEmpty())) {\n                 @SuppressWarnings(\"unchecked\")\n                 Observer<Object> obs = (Observer<Object>)groupState.getObserver();\n                 nl.accept(obs, item);\n-                keyRequested.decrementAndGet();\n+                if (keyRequested.get() != Long.MAX_VALUE) {\n+                    // best endeavours check (no CAS loop here) because we mainly care about \n+                    // the initial request being Long.MAX_VALUE and that value being conserved.\n+                    keyRequested.decrementAndGet();\n+                }\n             } else {\n                 q.add(item);\n                 BUFFERED_COUNT.incrementAndGet(this);\n@@ -381,7 +387,11 @@ private void drainIfPossible(GroupState<K, T> groupState) {\n                     @SuppressWarnings(\"unchecked\")\n                     Observer<Object> obs = (Observer<Object>)groupState.getObserver();\n                     nl.accept(obs, t);\n-                    groupState.requested.decrementAndGet();\n+                    if (groupState.requested.get()!=Long.MAX_VALUE) {\n+                        // best endeavours check (no CAS loop here) because we mainly care about \n+                        // the initial request being Long.MAX_VALUE and that value being conserved.\n+                        groupState.requested.decrementAndGet();\n+                    }\n                     BUFFERED_COUNT.decrementAndGet(this);\n \n                     // if we have used up all the events we requested from upstream then figure out what to ask for this time based on the empty space in the buffer\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorGroupByTest.java b/src/test/java/rx/internal/operators/OperatorGroupByTest.java\n--- a/src/test/java/rx/internal/operators/OperatorGroupByTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorGroupByTest.java\n@@ -34,6 +34,7 @@\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n \n@@ -1454,4 +1455,50 @@ public Integer call(Integer i) {\n         assertEquals(Arrays.asList(e), inner1.getOnErrorEvents());\n         assertEquals(Arrays.asList(e), inner2.getOnErrorEvents());\n     }\n+    \n+    @Test\n+    public void testRequestOverflow() {\n+        final AtomicBoolean completed = new AtomicBoolean(false);\n+        Observable\n+                .just(1, 2, 3)\n+                // group into one group\n+                .groupBy(new Func1<Integer, Integer>() {\n+                    @Override\n+                    public Integer call(Integer t) {\n+                        return 1;\n+                    }\n+                })\n+                // flatten\n+                .concatMap(new Func1<GroupedObservable<Integer, Integer>, Observable<Integer>>() {\n+                    @Override\n+                    public Observable<Integer> call(GroupedObservable<Integer, Integer> g) {\n+                        return g;\n+                    }\n+                })\n+                .subscribe(new Subscriber<Integer>() {\n+                    \n+                    @Override\n+                    public void onStart() {\n+                        request(2);\n+                    }\n+\n+                    @Override\n+                    public void onCompleted() {\n+                        completed.set(true);\n+                        \n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable e) {\n+                        \n+                    }\n+\n+                    @Override\n+                    public void onNext(Integer t) {\n+                        System.out.println(t);\n+                        //provoke possible request overflow\n+                        request(Long.MAX_VALUE-1);\n+                    }});\n+        assertTrue(completed.get());\n+    }\n }",
    "output": "Add request overflow checks and prevent Long.MAX_VALUE requests being decremented in OperatorGroupBy, added unit test that failed with previous code"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorObserveOn.java b/src/main/java/rx/internal/operators/OperatorObserveOn.java\n--- a/src/main/java/rx/internal/operators/OperatorObserveOn.java\n+++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java\n@@ -182,62 +182,42 @@ protected void schedule() {\n         void pollQueue() {\n             int emitted = 0;\n             do {\n-                /*\n-                 * Set to 1 otherwise it could have grown very large while in the last poll loop\n-                 * and then we can end up looping all those times again here before exiting even once we've drained\n-                 */\n                 counter = 1;\n-\n-                while (!scheduledUnsubscribe.isUnsubscribed()) {\n+                long produced = 0;\n+                long r = requested;\n+                while (!child.isUnsubscribed()) {\n+                    Throwable error;\n                     if (finished) {\n-                        // only read volatile error once\n-                        Throwable err = error;\n-                        if (err != null) {\n-                            // clear the queue to enable gc \n+                        if ((error = this.error) != null) {\n+                            // errors shortcut the queue so \n+                            // release the elements in the queue for gc\n                             queue.clear();\n-                            // even if there are onNext in the queue we eagerly notify of error\n-                            child.onError(err);\n+                            child.onError(error);\n                             return;\n-                        } else if (queue.isEmpty()) {\n+                        } else\n+                        if (queue.isEmpty()) {\n                             child.onCompleted();\n                             return;\n                         }\n                     }\n-                    if (REQUESTED.getAndDecrement(this) != 0) {\n+                    if (r > 0) {\n                         Object o = queue.poll();\n-                        if (o == null) {\n-                            // nothing in queue (but be careful, something could be added concurrently right now)\n-                            if (finished) {\n-                                // only read volatile error once\n-                                Throwable err = error;\n-                                if (err != null) {\n-                                    // clear the queue to enable gc \n-                                    queue.clear();\n-                                    // even if there are onNext in the queue we eagerly notify of error\n-                                    child.onError(err);\n-                                    return;\n-                                } else if (queue.isEmpty()) {\n-                                    child.onCompleted();\n-                                    return;\n-                                }\n-                            }\n-                            BackpressureUtils.getAndAddRequest(REQUESTED, this, 1);\n-                            break;\n+                        if (o != null) {\n+                            child.onNext(on.getValue(o));\n+                            r--;\n+                            emitted++;\n+                            produced++;\n                         } else {\n-                            if (!on.accept(child, o)) {\n-                                // non-terminal event so let's increment count\n-                                emitted++;\n-                            }\n+                            break;\n                         }\n                     } else {\n-                        // we hit the end ... so increment back to 0 again\n-                        BackpressureUtils.getAndAddRequest(REQUESTED, this, 1);\n                         break;\n                     }\n                 }\n+                if (produced > 0) {\n+                    REQUESTED.addAndGet(this, -produced);\n+                }\n             } while (COUNTER_UPDATER.decrementAndGet(this) > 0);\n-\n-            // request the number of items that we emitted in this poll loop\n             if (emitted > 0) {\n                 request(emitted);\n             }",
    "output": "Use new pollQueue from @akarnokd"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorObserveOn.java b/src/main/java/rx/internal/operators/OperatorObserveOn.java\n--- a/src/main/java/rx/internal/operators/OperatorObserveOn.java\n+++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java\n@@ -75,15 +75,19 @@ private static final class ObserveOnSubscriber<T> extends Subscriber<T> {\n         final NotificationLite<T> on = NotificationLite.instance();\n \n         final Queue<Object> queue;\n-        volatile boolean completed = false;\n-        volatile boolean failure = false;\n+        \n+        // the status of the current stream\n+        volatile boolean finished = false;\n \n+        @SuppressWarnings(\"unused\")\n         volatile long requested = 0;\n+        \n         @SuppressWarnings(\"rawtypes\")\n         static final AtomicLongFieldUpdater<ObserveOnSubscriber> REQUESTED = AtomicLongFieldUpdater.newUpdater(ObserveOnSubscriber.class, \"requested\");\n \n         @SuppressWarnings(\"unused\")\n         volatile long counter;\n+        \n         @SuppressWarnings(\"rawtypes\")\n         static final AtomicLongFieldUpdater<ObserveOnSubscriber> COUNTER_UPDATER = AtomicLongFieldUpdater.newUpdater(ObserveOnSubscriber.class, \"counter\");\n \n@@ -127,7 +131,7 @@ public void onStart() {\n \n         @Override\n         public void onNext(final T t) {\n-            if (isUnsubscribed() || completed) {\n+            if (isUnsubscribed()) {\n                 return;\n             }\n             if (!queue.offer(on.next(t))) {\n@@ -139,30 +143,23 @@ public void onNext(final T t) {\n \n         @Override\n         public void onCompleted() {\n-            if (isUnsubscribed() || completed) {\n+            if (isUnsubscribed() || finished) {\n                 return;\n             }\n-            if (error != null) {\n-                return;\n-            }\n-            completed = true;\n+            finished = true;\n             schedule();\n         }\n \n         @Override\n         public void onError(final Throwable e) {\n-            if (isUnsubscribed() || completed) {\n-                return;\n-            }\n-            if (error != null) {\n+            if (isUnsubscribed() || finished) {\n                 return;\n             }\n             error = e;\n             // unsubscribe eagerly since time will pass before the scheduled onError results in an unsubscribe event\n             unsubscribe();\n-            // mark failure so the polling thread will skip onNext still in the queue\n-            completed = true;\n-            failure = true;\n+            finished = true;\n+            // polling thread should skip any onNext still in the queue\n             schedule();\n         }\n \n@@ -191,41 +188,51 @@ void pollQueue() {\n                  */\n                 counter = 1;\n \n-//                middle:\n                 while (!scheduledUnsubscribe.isUnsubscribed()) {\n-                    if (failure) {\n-                        child.onError(error);\n-                        return;\n-                    } else {\n-                        if (requested == 0 && completed && queue.isEmpty()) {\n+                    if (finished) {\n+                        // only read volatile error once\n+                        Throwable err = error;\n+                        if (err != null) {\n+                            // clear the queue to enable gc \n+                            queue.clear();\n+                            // even if there are onNext in the queue we eagerly notify of error\n+                            child.onError(err);\n+                            return;\n+                        } else if (queue.isEmpty()) {\n                             child.onCompleted();\n                             return;\n                         }\n-                        if (REQUESTED.getAndDecrement(this) != 0) {\n-                            Object o = queue.poll();\n-                            if (o == null) {\n-                                if (completed) {\n-                                    if (failure) {\n-                                        child.onError(error);\n-                                    } else {\n-                                        child.onCompleted();\n-                                    }\n+                    }\n+                    if (REQUESTED.getAndDecrement(this) != 0) {\n+                        Object o = queue.poll();\n+                        if (o == null) {\n+                            // nothing in queue (but be careful, something could be added concurrently right now)\n+                            if (finished) {\n+                                // only read volatile error once\n+                                Throwable err = error;\n+                                if (err != null) {\n+                                    // clear the queue to enable gc \n+                                    queue.clear();\n+                                    // even if there are onNext in the queue we eagerly notify of error\n+                                    child.onError(err);\n+                                    return;\n+                                } else if (queue.isEmpty()) {\n+                                    child.onCompleted();\n                                     return;\n-                                }\n-                                // nothing in queue\n-                                REQUESTED.incrementAndGet(this);\n-                                break;\n-                            } else {\n-                                if (!on.accept(child, o)) {\n-                                    // non-terminal event so let's increment count\n-                                    emitted++;\n                                 }\n                             }\n-                        } else {\n-                            // we hit the end ... so increment back to 0 again\n-                            REQUESTED.incrementAndGet(this);\n+                            BackpressureUtils.getAndAddRequest(REQUESTED, this, 1);\n                             break;\n+                        } else {\n+                            if (!on.accept(child, o)) {\n+                                // non-terminal event so let's increment count\n+                                emitted++;\n+                            }\n                         }\n+                    } else {\n+                        // we hit the end ... so increment back to 0 again\n+                        BackpressureUtils.getAndAddRequest(REQUESTED, this, 1);\n+                        break;\n                     }\n                 }\n             } while (COUNTER_UPDATER.decrementAndGet(this) > 0);\n\ndiff --git a/src/perf/java/rx/operators/OperatorObserveOnPerf.java b/src/perf/java/rx/operators/OperatorObserveOnPerf.java\n--- a/src/perf/java/rx/operators/OperatorObserveOnPerf.java\n+++ b/src/perf/java/rx/operators/OperatorObserveOnPerf.java\n@@ -66,5 +66,26 @@ public void observeOnImmediate(Input input) throws InterruptedException {\n         input.observable.observeOn(Schedulers.immediate()).subscribe(o);\n         o.latch.await();\n     }\n+    \n+    @Benchmark\n+    public void observeOnComputationSubscribedOnComputation(Input input) throws InterruptedException {\n+        LatchedObserver<Integer> o = input.newLatchedObserver();\n+        input.observable.subscribeOn(Schedulers.computation()).observeOn(Schedulers.computation()).subscribe(o);\n+        o.latch.await();\n+    }\n+\n+    @Benchmark\n+    public void observeOnNewThreadSubscribedOnComputation(Input input) throws InterruptedException {\n+        LatchedObserver<Integer> o = input.newLatchedObserver();\n+        input.observable.subscribeOn(Schedulers.computation()).observeOn(Schedulers.newThread()).subscribe(o);\n+        o.latch.await();\n+    }\n+\n+    @Benchmark\n+    public void observeOnImmediateSubscribedOnComputation(Input input) throws InterruptedException {\n+        LatchedObserver<Integer> o = input.newLatchedObserver();\n+        input.observable.subscribeOn(Schedulers.computation()).observeOn(Schedulers.immediate()).subscribe(o);\n+        o.latch.await();\n+    }\n \n }",
    "output": "Fix OperatorObserveOn race condition where onComplete could be emitted despite onError being called"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java b/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java\n--- a/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java\n+++ b/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java\n@@ -116,26 +116,22 @@ public synchronized int next(T value) {\n         }\n         public void emit(int index, Subscriber<T> onNextAndComplete, Subscriber<?> onError) {\n             T localValue;\n-            boolean localHasValue;\n             synchronized (this) {\n                 if (emitting || !hasValue || index != this.index) {\n                     return;\n                 }\n                 localValue = value;\n-                localHasValue = hasValue;\n                 \n                 value = null;\n                 hasValue = false;\n                 emitting = true;\n             }\n \n-            if  (localHasValue) {\n-                try {\n-                    onNextAndComplete.onNext(localValue);\n-                } catch (Throwable e) {\n-                    onError.onError(e);\n-                    return;\n-                }\n+            try {\n+                onNextAndComplete.onNext(localValue);\n+            } catch (Throwable e) {\n+                onError.onError(e);\n+                return;\n             }\n \n             // Check if a termination was requested in the meantime.",
    "output": "Remove unnecessary localHasValue check\n\nDue to !hasValue check localHasValue field is always true"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorPublish.java b/src/main/java/rx/internal/operators/OperatorPublish.java\n--- a/src/main/java/rx/internal/operators/OperatorPublish.java\n+++ b/src/main/java/rx/internal/operators/OperatorPublish.java\n@@ -535,10 +535,11 @@ void dispatch() {\n                         // may contain less than requested\n                         int d = 0;\n                         while (d < maxRequested) {\n+                            term = terminalEvent;\n                             Object v = queue.poll();\n                             empty = v == null;\n                             // let's check if there is a terminal event and the queue became empty just now\n-                            if (checkTerminated(terminalEvent, empty)) {\n+                            if (checkTerminated(term, empty)) {\n                                 skipFinal = true;\n                                 return;\n                             }",
    "output": "Fix another race between terminalEvent and the queue being empty"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java\n@@ -49,10 +49,10 @@ public final class OnSubscribeCombineLatest<T, R> implements OnSubscribe<R> {\n     public OnSubscribeCombineLatest(List<? extends Observable<? extends T>> sources, FuncN<? extends R> combinator) {\n         this.sources = sources;\n         this.combinator = combinator;\n-        if (sources.size() > 128) {\n-            // For design simplicity this is limited to 128. If more are really needed we'll need to adjust \n-            // the design of how RxRingBuffer is used in the implementation below.\n-            throw new IllegalArgumentException(\"More than 128 sources to combineLatest is not supported.\");\n+        if (sources.size() > RxRingBuffer.SIZE) {\n+            // For design simplicity this is limited to RxRingBuffer.SIZE. If more are really needed we'll need to\n+            // adjust the design of how RxRingBuffer is used in the implementation below.\n+            throw new IllegalArgumentException(\"More than RxRingBuffer.SIZE sources to combineLatest is not supported.\");\n         }\n     }\n ",
    "output": "Fix Observable.combineLatest overflow bug on Android RxRingBuffer size is not a constant and on Android is less then 128 (16). So it causing silent issues when there were given 16 < Observers < 128"
  },
  {
    "input": "diff --git a/src/main/java/rx/subjects/TestSubject.java b/src/main/java/rx/subjects/TestSubject.java\n--- a/src/main/java/rx/subjects/TestSubject.java\n+++ b/src/main/java/rx/subjects/TestSubject.java\n@@ -68,11 +68,11 @@ protected TestSubject(OnSubscribe<T> onSubscribe, SubjectSubscriptionManager<T>\n     }\n \n     /**\n-     * Schedule a call to {@code onCompleted} at relative time of \"now()\" on TestScheduler.\n+     * Schedule a call to {@code onCompleted} on TestScheduler.\n      */\n     @Override\n     public void onCompleted() {\n-        onCompleted(innerScheduler.now());\n+        onCompleted(0);\n     }\n \n     private void _onCompleted() {\n@@ -86,26 +86,26 @@ private void _onCompleted() {\n     /**\n      * Schedule a call to {@code onCompleted} relative to \"now()\" +n milliseconds in the future.\n      *\n-     * @param timeInMilliseconds\n+     * @param delayTime\n      *         the number of milliseconds in the future relative to \"now()\" at which to call {@code onCompleted}\n      */\n-    public void onCompleted(long timeInMilliseconds) {\n+    public void onCompleted(long delayTime) {\n         innerScheduler.schedule(new Action0() {\n \n             @Override\n             public void call() {\n                 _onCompleted();\n             }\n \n-        }, timeInMilliseconds, TimeUnit.MILLISECONDS);\n+        }, delayTime, TimeUnit.MILLISECONDS);\n     }\n \n     /**\n-     * Schedule a call to {@code onError} at relative time of \"now()\" on TestScheduler.\n+     * Schedule a call to {@code onError} on TestScheduler.\n      */\n     @Override\n     public void onError(final Throwable e) {\n-        onError(e, innerScheduler.now());\n+        onError(e, 0);\n     }\n \n     private void _onError(final Throwable e) {\n@@ -121,18 +121,18 @@ private void _onError(final Throwable e) {\n      *\n      * @param e\n      *         the {@code Throwable} to pass to the {@code onError} method\n-     * @param timeInMilliseconds\n+     * @param dalayTime\n      *         the number of milliseconds in the future relative to \"now()\" at which to call {@code onError}\n      */\n-    public void onError(final Throwable e, long timeInMilliseconds) {\n+    public void onError(final Throwable e, long dalayTime) {\n         innerScheduler.schedule(new Action0() {\n \n             @Override\n             public void call() {\n                 _onError(e);\n             }\n \n-        }, timeInMilliseconds, TimeUnit.MILLISECONDS);\n+        }, dalayTime, TimeUnit.MILLISECONDS);\n     }\n \n     /**\n\ndiff --git a/src/test/java/rx/subjects/TestSubjectTest.java b/src/test/java/rx/subjects/TestSubjectTest.java\n--- a/src/test/java/rx/subjects/TestSubjectTest.java\n+++ b/src/test/java/rx/subjects/TestSubjectTest.java\n@@ -19,6 +19,7 @@\n import rx.Observer;\n import rx.schedulers.TestScheduler;\n \n+import java.io.IOException;\n import java.util.concurrent.TimeUnit;\n \n import static org.mockito.Mockito.*;\n@@ -55,4 +56,72 @@ public void testObserverPropagateValueInFutureTimeAfterTriggeringActions() {\n \n         verify(observer, times(1)).onNext(1);\n     }\n+\n+\n+\n+    @Test\n+    public void testObserverPropagateErrorAfterTriggeringActions() {\n+        final IOException e = new IOException();\n+        final TestScheduler scheduler = new TestScheduler();\n+\n+        final TestSubject<Integer> subject = TestSubject.create(scheduler);\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Integer> observer = mock(Observer.class);\n+        subject.subscribe(observer);\n+\n+        subject.onError(e);\n+        scheduler.triggerActions();\n+\n+        verify(observer, times(1)).onError(e);\n+    }\n+\n+    @Test\n+    public void testObserverPropagateErrorInFutureTimeAfterTriggeringActions() {\n+        final IOException e = new IOException();\n+        final TestScheduler scheduler = new TestScheduler();\n+        scheduler.advanceTimeTo(100, TimeUnit.SECONDS);\n+\n+        final TestSubject<Integer> subject = TestSubject.create(scheduler);\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Integer> observer = mock(Observer.class);\n+        subject.subscribe(observer);\n+\n+        subject.onError(e);\n+        scheduler.triggerActions();\n+\n+        verify(observer, times(1)).onError(e);\n+    }\n+\n+\n+\n+    @Test\n+    public void testObserverPropagateCompletedAfterTriggeringActions() {\n+        final TestScheduler scheduler = new TestScheduler();\n+\n+        final TestSubject<Integer> subject = TestSubject.create(scheduler);\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Integer> observer = mock(Observer.class);\n+        subject.subscribe(observer);\n+\n+        subject.onCompleted();\n+        scheduler.triggerActions();\n+\n+        verify(observer, times(1)).onCompleted();\n+    }\n+\n+    @Test\n+    public void testObserverPropagateCompletedInFutureTimeAfterTriggeringActions() {\n+        final TestScheduler scheduler = new TestScheduler();\n+        scheduler.advanceTimeTo(100, TimeUnit.SECONDS);\n+\n+        final TestSubject<Integer> subject = TestSubject.create(scheduler);\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Integer> observer = mock(Observer.class);\n+        subject.subscribe(observer);\n+\n+        subject.onCompleted();\n+        scheduler.triggerActions();\n+\n+        verify(observer, times(1)).onCompleted();\n+    }\n }",
    "output": "Fix TestSubject bug in onError and onCompleted"
  },
  {
    "input": "diff --git a/src/main/java/rx/subjects/TestSubject.java b/src/main/java/rx/subjects/TestSubject.java\n--- a/src/main/java/rx/subjects/TestSubject.java\n+++ b/src/main/java/rx/subjects/TestSubject.java\n@@ -15,8 +15,6 @@\n  */\n package rx.subjects;\n \n-import java.util.concurrent.TimeUnit;\n-\n import rx.Observer;\n import rx.Scheduler;\n import rx.functions.Action0;\n@@ -25,6 +23,8 @@\n import rx.schedulers.TestScheduler;\n import rx.subjects.SubjectSubscriptionManager.SubjectObserver;\n \n+import java.util.concurrent.TimeUnit;\n+\n /**\n  * A variety of Subject that is useful for testing purposes. It operates on a {@link TestScheduler} and allows\n  * you to precisely time emissions and notifications to the Subject's subscribers using relative virtual time\n@@ -136,11 +136,11 @@ public void call() {\n     }\n \n     /**\n-     * Schedule a call to {@code onNext} at relative time of \"now()\" on TestScheduler.\n+     * Schedule a call to {@code onNext} on TestScheduler.\n      */\n     @Override\n     public void onNext(T v) {\n-        onNext(v, innerScheduler.now());\n+        onNext(v, 0);\n     }\n \n     private void _onNext(T v) {\n@@ -154,18 +154,18 @@ private void _onNext(T v) {\n      *\n      * @param v\n      *         the item to emit\n-     * @param timeInMilliseconds\n+     * @param delayTime\n      *         the number of milliseconds in the future relative to \"now()\" at which to call {@code onNext}\n      */\n-    public void onNext(final T v, long timeInMilliseconds) {\n+    public void onNext(final T v, long delayTime) {\n         innerScheduler.schedule(new Action0() {\n \n             @Override\n             public void call() {\n                 _onNext(v);\n             }\n \n-        }, timeInMilliseconds, TimeUnit.MILLISECONDS);\n+        }, delayTime, TimeUnit.MILLISECONDS);\n     }\n \n     @Override",
    "output": "Fix TestSubject bug in onNext"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorPublish.java b/src/main/java/rx/internal/operators/OperatorPublish.java\n--- a/src/main/java/rx/internal/operators/OperatorPublish.java\n+++ b/src/main/java/rx/internal/operators/OperatorPublish.java\n@@ -458,6 +458,15 @@ void dispatch() {\n             boolean skipFinal = false;\n             try {\n                 for (;;) {\n+                    /*\n+                     * We need to read terminalEvent before checking the queue for emptyness because\n+                     * all enqueue happens before setting the terminal event.\n+                     * If it were the other way around, when the emission is paused between\n+                     * checking isEmpty and checking terminalEvent, some other thread might\n+                     * have produced elements and set the terminalEvent and we'd quit emitting\n+                     * prematurely.\n+                     */\n+                    Object term = terminalEvent;\n                     /*\n                      * See if the queue is empty; since we need this information multiple\n                      * times later on, we read it one.\n@@ -468,7 +477,7 @@ void dispatch() {\n                     // if the queue is empty and the terminal event was received, quit\n                     // and don't bother restoring emitting to false: no further activity is\n                     // possible at this point\n-                    if (checkTerminated(terminalEvent, empty)) {\n+                    if (checkTerminated(term, empty)) {\n                         skipFinal = true;\n                         return;\n                     }\n@@ -508,10 +517,11 @@ void dispatch() {\n                         // it may happen everyone has unsubscribed between here and producers.get()\n                         // or we have no subscribers at all to begin with\n                         if (len == unsubscribed) {\n+                            term = terminalEvent;\n                             // so let's consume a value from the queue\n                             Object v = queue.poll();\n                             // or terminate if there was a terminal event and the queue is empty\n-                            if (checkTerminated(terminalEvent, v == null)) {\n+                            if (checkTerminated(term, v == null)) {\n                                 skipFinal = true;\n                                 return;\n                             }\n@@ -748,4 +758,4 @@ public void unsubscribe() {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file",
    "output": "Fix termination race condition in OperatorPublish.dispatch"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -4941,7 +4941,7 @@ public final <T2, D1, D2, R> Observable<R> groupJoin(Observable<T2> right, Func1\n      * @see <a href=\"http://reactivex.io/documentation/operators/ignoreelements.html\">ReactiveX operators documentation: IgnoreElements</a>\n      */\n     public final Observable<T> ignoreElements() {\n-        return filter(UtilityFunctions.alwaysFalse());\n+        return lift(OperatorIgnoreElements.<T> instance());\n     }\n \n     /**\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorIgnoreElements.java b/src/main/java/rx/internal/operators/OperatorIgnoreElements.java\n--- a/src/main/java/rx/internal/operators/OperatorIgnoreElements.java\n+++ b/src/main/java/rx/internal/operators/OperatorIgnoreElements.java\n@@ -0,0 +1,60 @@\n+/**\n+ * Copyright 2014 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.internal.operators;\n+\n+import rx.Observable.Operator;\n+import rx.Subscriber;\n+\n+public class OperatorIgnoreElements<T> implements Operator<T, T> {\n+\n+    private static class Holder {\n+        static final OperatorIgnoreElements<?> INSTANCE = new OperatorIgnoreElements<Object>();\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> OperatorIgnoreElements<T> instance() {\n+        return (OperatorIgnoreElements<T>) Holder.INSTANCE;\n+    }\n+\n+    private OperatorIgnoreElements() {\n+\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> call(final Subscriber<? super T> child) {\n+        Subscriber<T> parent = new Subscriber<T>() {\n+\n+            @Override\n+            public void onCompleted() {\n+                child.onCompleted();\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                child.onError(e);\n+            }\n+\n+            @Override\n+            public void onNext(T t) {\n+                // ignore element\n+            }\n+\n+        };\n+        child.add(parent);\n+        return parent;\n+    }\n+\n+}\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorIgnoreElementsTest.java b/src/test/java/rx/internal/operators/OperatorIgnoreElementsTest.java\n--- a/src/test/java/rx/internal/operators/OperatorIgnoreElementsTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorIgnoreElementsTest.java\n@@ -0,0 +1,130 @@\n+package rx.internal.operators;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.Test;\n+\n+import rx.Observable;\n+import rx.Subscriber;\n+import rx.functions.Action0;\n+import rx.functions.Action1;\n+import rx.observers.TestSubscriber;\n+\n+public class OperatorIgnoreElementsTest {\n+\n+    @Test\n+    public void testWithEmpty() {\n+        assertTrue(Observable.empty().ignoreElements().isEmpty().toBlocking().single());\n+    }\n+\n+    @Test\n+    public void testWithNonEmpty() {\n+        assertTrue(Observable.just(1, 2, 3).ignoreElements().isEmpty().toBlocking().single());\n+    }\n+\n+    @Test\n+    public void testUpstreamIsProcessedButIgnored() {\n+        final int num = 10;\n+        final AtomicInteger upstreamCount = new AtomicInteger();\n+        int count = Observable.range(1, num)\n+                .doOnNext(new Action1<Integer>() {\n+                    @Override\n+                    public void call(Integer t) {\n+                        upstreamCount.incrementAndGet();\n+                    }\n+                })\n+                .ignoreElements()\n+                .count().toBlocking().single();\n+        assertEquals(num, upstreamCount.get());\n+        assertEquals(0, count);\n+    }\n+    \n+    @Test\n+    public void testCompletedOk() {\n+        TestSubscriber<Object> ts = new TestSubscriber<Object>();\n+        Observable.range(1, 10).ignoreElements().subscribe(ts);\n+        ts.assertNoErrors();\n+        ts.assertReceivedOnNext(Arrays.asList());\n+        ts.assertTerminalEvent();\n+        ts.assertUnsubscribed();\n+    }\n+    \n+    @Test\n+    public void testErrorReceived() {\n+        TestSubscriber<Object> ts = new TestSubscriber<Object>();\n+        RuntimeException ex = new RuntimeException(\"boo\");\n+        Observable.error(ex).ignoreElements().subscribe(ts);\n+        ts.assertReceivedOnNext(Arrays.asList());\n+        ts.assertTerminalEvent();\n+        ts.assertUnsubscribed();\n+        assertEquals(1, ts.getOnErrorEvents().size());\n+        assertEquals(\"boo\", ts.getOnErrorEvents().get(0).getMessage());\n+    }\n+    \n+    @Test\n+    public void testUnsubscribesFromUpstream() {\n+        final AtomicBoolean unsub = new AtomicBoolean();\n+        Observable.range(1, 10).doOnUnsubscribe(new Action0() {\n+            @Override\n+            public void call() {\n+                unsub.set(true);\n+            }})\n+            .subscribe();\n+        assertTrue(unsub.get());\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void testDoesNotHangAndProcessesAllUsingBackpressure() {\n+        final AtomicInteger upstreamCount = new AtomicInteger();\n+        final AtomicInteger count = new AtomicInteger(0);\n+        int num = 10;\n+        Observable.range(1, num)\n+        //\n+                .doOnNext(new Action1<Integer>() {\n+                    @Override\n+                    public void call(Integer t) {\n+                        upstreamCount.incrementAndGet();\n+                    }\n+                })\n+                //\n+                .ignoreElements()\n+                //\n+                .doOnNext(new Action1<Integer>() {\n+\n+                    @Override\n+                    public void call(Integer t) {\n+                        upstreamCount.incrementAndGet();\n+                    }\n+                })\n+                //\n+                .subscribe(new Subscriber<Integer>() {\n+\n+                    @Override\n+                    public void onStart() {\n+                        request(1);\n+                    }\n+\n+                    @Override\n+                    public void onCompleted() {\n+\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable e) {\n+                    }\n+\n+                    @Override\n+                    public void onNext(Integer t) {\n+                        count.incrementAndGet();\n+                    }\n+                });\n+        assertEquals(num, upstreamCount.get());\n+        assertEquals(0, count.get());\n+    }\n+    \n+}\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorTakeLastOneTest.java b/src/test/java/rx/internal/operators/OperatorTakeLastOneTest.java\n--- a/src/test/java/rx/internal/operators/OperatorTakeLastOneTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorTakeLastOneTest.java\n@@ -14,7 +14,6 @@\n \n import rx.Observable;\n import rx.Subscriber;\n-import rx.Subscription;\n import rx.functions.Action0;\n import rx.functions.Action1;\n import rx.observers.TestSubscriber;",
    "output": "Improve perf of OperatorIgnoreElements"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/schedulers/EventLoopsScheduler.java b/src/main/java/rx/internal/schedulers/EventLoopsScheduler.java\n--- a/src/main/java/rx/internal/schedulers/EventLoopsScheduler.java\n+++ b/src/main/java/rx/internal/schedulers/EventLoopsScheduler.java\n@@ -117,10 +117,7 @@ public Subscription schedule(Action0 action) {\n             if (isUnsubscribed()) {\n                 return Subscriptions.unsubscribed();\n             }\n-            ScheduledAction s = poolWorker.scheduleActual(action, 0, null);\n-            \n-            serial.add(s);\n-            s.addParent(serial);\n+            ScheduledAction s = poolWorker.scheduleActual(action, 0, null, serial);\n             \n             return s;\n         }\n\ndiff --git a/src/main/java/rx/internal/util/SubscriptionList.java b/src/main/java/rx/internal/util/SubscriptionList.java\n--- a/src/main/java/rx/internal/util/SubscriptionList.java\n+++ b/src/main/java/rx/internal/util/SubscriptionList.java\n@@ -15,12 +15,7 @@\n  */\n package rx.internal.util;\n \n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.concurrent.locks.ReentrantLock;\n+import java.util.*;\n \n import rx.Subscription;\n import rx.exceptions.Exceptions;\n@@ -34,7 +29,6 @@ public final class SubscriptionList implements Subscription {\n \n     private LinkedList<Subscription> subscriptions;\n     private volatile boolean unsubscribed;\n-    private final ReentrantLock lock = new ReentrantLock();\n \n     public SubscriptionList() {\n     }\n@@ -66,8 +60,7 @@ public void add(final Subscription s) {\n             return;\n         }\n         if (!unsubscribed) {\n-            lock.lock();\n-            try {\n+            synchronized (this) {\n                 if (!unsubscribed) {\n                     LinkedList<Subscription> subs = subscriptions;\n                     if (subs == null) {\n@@ -77,8 +70,6 @@ public void add(final Subscription s) {\n                     subs.add(s);\n                     return;\n                 }\n-            } finally {\n-                lock.unlock();\n             }\n         }\n         // call after leaving the synchronized block so we're not holding a lock while executing this\n@@ -88,15 +79,12 @@ public void add(final Subscription s) {\n     public void remove(final Subscription s) {\n         if (!unsubscribed) {\n             boolean unsubscribe = false;\n-            lock.lock();\n-            try {\n+            synchronized (this) {\n                 LinkedList<Subscription> subs = subscriptions;\n                 if (unsubscribed || subs == null) {\n                     return;\n                 }\n                 unsubscribe = subs.remove(s);\n-            } finally {\n-                lock.unlock();\n             }\n             if (unsubscribe) {\n                 // if we removed successfully we then need to call unsubscribe on it (outside of the lock)\n@@ -113,16 +101,13 @@ public void remove(final Subscription s) {\n     public void unsubscribe() {\n         if (!unsubscribed) {\n             List<Subscription> list;\n-            lock.lock();\n-            try {\n+            synchronized (this) {\n                 if (unsubscribed) {\n                     return;\n                 }\n                 unsubscribed = true;\n                 list = subscriptions;\n                 subscriptions = null;\n-            } finally {\n-                lock.unlock();\n             }\n             // we will only get here once\n             unsubscribeFromAll(list);\n@@ -150,12 +135,9 @@ private static void unsubscribeFromAll(Collection<Subscription> subscriptions) {\n     public void clear() {\n         if (!unsubscribed) {\n             List<Subscription> list;\n-            lock.lock();\n-            try {\n+            synchronized (this) {\n                 list = subscriptions;\n                 subscriptions = null;\n-            } finally {\n-                lock.unlock();\n             }\n             unsubscribeFromAll(list);\n         }\n@@ -166,11 +148,8 @@ public void clear() {\n      */\n     public boolean hasSubscriptions() {\n         if (!unsubscribed) {\n-            lock.lock();\n-            try {\n+            synchronized (this) {\n                 return !unsubscribed && subscriptions != null && !subscriptions.isEmpty();\n-            } finally {\n-                lock.unlock();\n             }\n         }\n         return false;",
    "output": "Fix the performance degradation due to different schedule execution and\nSubscriptionList.add() and thread unparking"
  },
  {
    "input": "diff --git a/src/test/java/rx/internal/util/RxRingBufferWithoutUnsafeTest.java b/src/test/java/rx/internal/util/RxRingBufferWithoutUnsafeTest.java\n--- a/src/test/java/rx/internal/util/RxRingBufferWithoutUnsafeTest.java\n+++ b/src/test/java/rx/internal/util/RxRingBufferWithoutUnsafeTest.java\n@@ -17,13 +17,13 @@\n \n import static org.junit.Assert.assertEquals;\n \n+import java.util.*;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Test;\n \n-import rx.Producer;\n-import rx.Scheduler;\n+import rx.*;\n import rx.exceptions.MissingBackpressureException;\n import rx.functions.Action0;\n import rx.observers.TestSubscriber;\n@@ -36,18 +36,25 @@ protected RxRingBuffer createRingBuffer() {\n         return new RxRingBuffer();\n     }\n \n+    @Test(timeout = 20000)\n+    public void testConcurrencyLoop() throws InterruptedException {\n+        for (int i = 0; i < 50; i++) {\n+            testConcurrency();\n+        }\n+    }\n+    \n     /**\n      * Single producer, 2 consumers. The request() ensures it gets scheduled back on the same Producer thread.\n      */\n-    @Test\n+    @Test(timeout = 10000)\n     public void testConcurrency() throws InterruptedException {\n         final RxRingBuffer b = createRingBuffer();\n-        final CountDownLatch emitLatch = new CountDownLatch(255);\n-        final CountDownLatch drainLatch = new CountDownLatch(2);\n+        final CountDownLatch emitLatch = new CountDownLatch(127);\n+        int drainers = 3;\n+        final CountDownLatch drainLatch = new CountDownLatch(drainers);\n \n         final Scheduler.Worker w1 = Schedulers.newThread().createWorker();\n-        Scheduler.Worker w2 = Schedulers.newThread().createWorker();\n-        Scheduler.Worker w3 = Schedulers.newThread().createWorker();\n+        List<Scheduler.Worker> drainerWorkers = new ArrayList<Scheduler.Worker>();\n \n         final AtomicInteger emit = new AtomicInteger();\n         final AtomicInteger poll = new AtomicInteger();\n@@ -110,7 +117,12 @@ public void call() {\n                             ts.requestMore(emitted);\n                             emitted = 0;\n                         } else {\n-                            if (emitLatch.getCount() == 0) {\n+                            try {\n+                                Thread.sleep(1);\n+                            } catch (InterruptedException ex) {\n+                                // ignored\n+                            }\n+                            if (emitLatch.getCount() == 0 && b.isEmpty()) {\n                                 // this works with SynchronizedQueue, if changing to a non-blocking Queue\n                                 // then this will likely need to change like the SpmcTest version\n                                 drainLatch.countDown();\n@@ -124,14 +136,18 @@ public void call() {\n \n         };\n \n-        w2.schedule(drainer);\n-        w3.schedule(drainer);\n+        for (int i = 0; i < drainers; i++) {\n+            Scheduler.Worker w = Schedulers.newThread().createWorker();\n+            w.schedule(drainer);\n+            drainerWorkers.add(w);\n+        }\n \n         emitLatch.await();\n         drainLatch.await();\n \n-        w2.unsubscribe();\n-        w3.unsubscribe();\n+        for (Scheduler.Worker w : drainerWorkers) {\n+            w.unsubscribe();\n+        }\n         w1.unsubscribe(); // put this one last as unsubscribing from it can cause Exceptions to be throw in w2/w3\n \n         System.out.println(\"emit: \" + emit.get() + \" poll: \" + poll.get());",
    "output": "Fix the drainer to check if the queue is empty before quitting"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java b/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java\n--- a/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java\n+++ b/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java\n@@ -119,7 +119,7 @@ public void onNext(T t) {\n                 do {\n                     drain(localQueue);\n                     if (once) {\n-                        once = true;\n+                        once = false;\n                         emitValue(t);\n                     }\n                     \n\ndiff --git a/src/test/java/rx/internal/operators/OperatorWindowWithObservableTest.java b/src/test/java/rx/internal/operators/OperatorWindowWithObservableTest.java\n--- a/src/test/java/rx/internal/operators/OperatorWindowWithObservableTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorWindowWithObservableTest.java\n@@ -22,13 +22,16 @@\n import static org.mockito.Mockito.verify;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n \n import org.junit.Test;\n \n import rx.Observable;\n import rx.Observer;\n import rx.exceptions.TestException;\n+import rx.functions.Func0;\n+import rx.observers.TestSubscriber;\n import rx.subjects.PublishSubject;\n \n public class OperatorWindowWithObservableTest {\n@@ -252,4 +255,39 @@ public void onCompleted() {\n         verify(o, never()).onCompleted();\n         verify(o).onError(any(TestException.class));\n     }\n+\n+    @Test\n+    public void testWindowNoDuplication() {\n+        final PublishSubject<Integer> source = PublishSubject.create();\n+        final TestSubscriber<Integer> tsw = new TestSubscriber<Integer>() {\n+            boolean once;\n+            @Override\n+            public void onNext(Integer t) {\n+                if (!once) {\n+                    once = true;\n+                    source.onNext(2);\n+                }\n+                super.onNext(t);\n+            }\n+        };\n+        TestSubscriber<Observable<Integer>> ts = new TestSubscriber<Observable<Integer>>() {\n+            @Override\n+            public void onNext(Observable<Integer> t) {\n+                t.subscribe(tsw);\n+                super.onNext(t);\n+            }\n+        };\n+        source.window(new Func0<Observable<Object>>() {\n+            @Override\n+            public Observable<Object> call() {\n+                return Observable.never();\n+            }\n+        }).subscribe(ts);\n+\n+        source.onNext(1);\n+        source.onCompleted();\n+\n+        assertEquals(1, ts.getOnNextEvents().size());\n+        assertEquals(Arrays.asList(1, 2), tsw.getOnNextEvents());\n+    }\n }\n\\ No newline at end of file",
    "output": "Fix for #2896 overlapping windows. Source was emitting t multiple times while holding queue"
  },
  {
    "input": "diff --git a/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java b/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java\n--- a/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java\n+++ b/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java\n@@ -17,6 +17,7 @@\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n@@ -26,6 +27,7 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Test;\n@@ -77,7 +79,7 @@ public void call(Integer t1) {\n     }\n \n     @Test\n-    public void testRangeWithOverflow() {\n+    public void testRangeWithZero() {\n         Observable.range(1, 0);\n     }\n \n@@ -220,4 +222,31 @@ public void onNext(Integer t) {\n             }});\n         assertEquals(n, count.get());\n     }\n+    \n+    @Test\n+    public void testEmptyRangeSendsOnCompleteEagerlyWithRequestZero() {\n+        final AtomicBoolean completed = new AtomicBoolean(false);\n+        Observable.range(1, 0).subscribe(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(0);\n+            }\n+            \n+            @Override\n+            public void onCompleted() {\n+                completed.set(true);\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                \n+            }\n+\n+            @Override\n+            public void onNext(Integer t) {\n+                \n+            }});\n+        assertTrue(completed.get());\n+    }\n }",
    "output": "Add unit test to ensure that range with count of 0 sends onComplete even when initial request is 0"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n@@ -62,12 +62,11 @@ private IterableProducer(Subscriber<? super T> o, Iterator<? extends T> it) {\n \n         @Override\n         public void request(long n) {\n-            if (REQUESTED_UPDATER.get(this) == Long.MAX_VALUE) {\n+            if (requested == Long.MAX_VALUE) {\n                 // already started with fast-path\n                 return;\n             }\n-            if (n == Long.MAX_VALUE) {\n-                REQUESTED_UPDATER.set(this, n);\n+            if (n == Long.MAX_VALUE && REQUESTED_UPDATER.compareAndSet(this, 0, Long.MAX_VALUE)) {\n                 // fast-path without backpressure\n                 while (it.hasNext()) {\n                     if (o.isUnsubscribed()) {\n@@ -78,7 +77,7 @@ public void request(long n) {\n                 if (!o.isUnsubscribed()) {\n                     o.onCompleted();\n                 }\n-            } else if(n > 0) {\n+            } else if (n > 0) {\n                 // backpressure is requested\n                 long _c = BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n);\n                 if (_c == 0) {",
    "output": "Fix race condition for Observable.from(Iterable) where two concurrent calls to the Producer.request with Long.MAX_VALUE could start the fast path twice"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeRange.java b/src/main/java/rx/internal/operators/OnSubscribeRange.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeRange.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeRange.java\n@@ -55,12 +55,11 @@ private RangeProducer(Subscriber<? super Integer> o, int start, int end) {\n \n         @Override\n         public void request(long n) {\n-            if (REQUESTED_UPDATER.get(this) == Long.MAX_VALUE) {\n+            if (requested == Long.MAX_VALUE) {\n                 // already started with fast-path\n                 return;\n             }\n-            if (n == Long.MAX_VALUE) {\n-                REQUESTED_UPDATER.set(this, n);\n+            if (n == Long.MAX_VALUE && REQUESTED_UPDATER.compareAndSet(this, 0, Long.MAX_VALUE)) {\n                 // fast-path without backpressure\n                 for (long i = index; i <= end; i++) {\n                     if (o.isUnsubscribed()) {",
    "output": "Fix race condition for range where two threads concurrently request Long.MAX_VALUE and both start the fast path thus possibly some items more than once"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -3630,12 +3630,16 @@ public final Boolean call(T t1) {\n      * @see #countLong()\n      */\n     public final Observable<Integer> count() {\n-        return reduce(0, new Func2<Integer, T, Integer>() {\n+        return reduce(0, CountHolder.INSTANCE);\n+    }\n+    \n+    private static final class CountHolder {\n+        static final Func2<Integer, Object, Integer> INSTANCE = new Func2<Integer, Object, Integer>() {\n             @Override\n-            public final Integer call(Integer t1, T t2) {\n-                return t1 + 1;\n+            public final Integer call(Integer count, Object o) {\n+                return count + 1;\n             }\n-        });\n+        };\n     }\n     \n     /**\n@@ -3657,14 +3661,18 @@ public final Integer call(Integer t1, T t2) {\n      * @see #count()\n      */\n     public final Observable<Long> countLong() {\n-        return reduce(0L, new Func2<Long, T, Long>() {\n+        return reduce(0L, CountLongHolder.INSTANCE);\n+    }\n+\n+    private static final class CountLongHolder {\n+        static final Func2<Long, Object, Long> INSTANCE = new Func2<Long, Object, Long>() {\n             @Override\n-            public final Long call(Long t1, T t2) {\n-                return t1 + 1;\n+            public final Long call(Long count, Object o) {\n+                return count + 1;\n             }\n-        });\n+        };\n     }\n-\n+    \n     /**\n      * Returns an Observable that mirrors the source Observable, except that it drops items emitted by the\n      * source Observable that are followed by another item within a computed debounce duration.",
    "output": "Use singleton reduction functions in count and countLong"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorConcat.java b/src/main/java/rx/internal/operators/OperatorConcat.java\n--- a/src/main/java/rx/internal/operators/OperatorConcat.java\n+++ b/src/main/java/rx/internal/operators/OperatorConcat.java\n@@ -114,8 +114,9 @@ public void onStart() {\n \n         private void requestFromChild(long n) {\n             // we track 'requested' so we know whether we should subscribe the next or not\n+            ConcatInnerSubscriber<T> actualSubscriber = currentSubscriber;\n             if (REQUESTED_UPDATER.getAndAdd(this, n) == 0) {\n-                if (currentSubscriber == null && wip > 0) {\n+                if (actualSubscriber == null && wip > 0) {\n                     // this means we may be moving from one subscriber to another after having stopped processing\n                     // so need to kick off the subscribe via this request notification\n                     subscribeNext();\n@@ -124,9 +125,9 @@ private void requestFromChild(long n) {\n                 }\n             } \n                 \n-            if (currentSubscriber != null) {\n+            if (actualSubscriber != null) {\n                 // otherwise we are just passing it through to the currentSubscriber\n-                currentSubscriber.requestMore(n);\n+                actualSubscriber.requestMore(n);\n             }\n         }\n ",
    "output": "Fix NPE in requestFromChild method"
  },
  {
    "input": "diff --git a/src/test/java/rx/internal/operators/OperatorRetryTest.java b/src/test/java/rx/internal/operators/OperatorRetryTest.java\n--- a/src/test/java/rx/internal/operators/OperatorRetryTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorRetryTest.java\n@@ -399,8 +399,9 @@ public void call(final Subscriber<? super String> o) {\n                 public void request(long n) {\n                     if (n == Long.MAX_VALUE) {\n                         o.onNext(\"beginningEveryTime\");\n-                        if (count.getAndIncrement() < numFailures) {\n-                            o.onError(new RuntimeException(\"forced failure: \" + count.get()));\n+                        int i = count.getAndIncrement();\n+                        if (i < numFailures) {\n+                            o.onError(new RuntimeException(\"forced failure: \" + (i + 1)));\n                         } else {\n                             o.onNext(\"onSuccessOnly\");\n                             o.onCompleted();\n@@ -411,8 +412,7 @@ public void request(long n) {\n                         int i = count.getAndIncrement();\n                         if (i < numFailures) {\n                             o.onNext(\"beginningEveryTime\");\n-                            o.onError(new RuntimeException(\"forced failure: \" + count.get()));\n-                            req.decrementAndGet();\n+                            o.onError(new RuntimeException(\"forced failure: \" + (i + 1)));\n                         } else {\n                             do {\n                                 if (i == numFailures) {\n@@ -705,17 +705,18 @@ public void testRetryWithBackpressure() throws InterruptedException {\n             inOrder.verifyNoMoreInteractions();\n         }\n     }\n+    \n     @Test(timeout = 15000)\n     public void testRetryWithBackpressureParallel() throws InterruptedException {\n         final int NUM_RETRIES = RxRingBuffer.SIZE * 2;\n         int ncpu = Runtime.getRuntime().availableProcessors();\n-        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 1));\n+        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n         final AtomicInteger timeouts = new AtomicInteger();\n         final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();\n         final Map<Integer, List<Throwable>> exceptions = new ConcurrentHashMap<Integer, List<Throwable>>();\n         final Map<Integer, Integer> completions = new ConcurrentHashMap<Integer, Integer>();\n         \n-        int m = 2000;\n+        int m = 5000;\n         final CountDownLatch cdl = new CountDownLatch(m);\n         for (int i = 0; i < m; i++) {\n             final int j = i;\n@@ -726,16 +727,17 @@ public void run() {\n                     try {\n                         Observable<String> origin = Observable.create(new FuncWithErrors(NUM_RETRIES));\n                         TestSubscriber<String> ts = new TestSubscriber<String>();\n-                        origin.retry().observeOn(Schedulers.computation()).unsafeSubscribe(ts);\n-                        ts.awaitTerminalEvent(2, TimeUnit.SECONDS);\n-                        if (ts.getOnNextEvents().size() != NUM_RETRIES + 2) {\n-                            data.put(j, ts.getOnNextEvents());\n+                        origin.retry()\n+                        .observeOn(Schedulers.computation()).unsafeSubscribe(ts);\n+                        ts.awaitTerminalEvent(2500, TimeUnit.MILLISECONDS);\n+                        if (ts.getOnCompletedEvents().size() != 1) {\n+                            completions.put(j, ts.getOnCompletedEvents().size());\n                         }\n                         if (ts.getOnErrorEvents().size() != 0) {\n                             exceptions.put(j, ts.getOnErrorEvents());\n                         }\n-                        if (ts.getOnCompletedEvents().size() != 1) {\n-                            completions.put(j, ts.getOnCompletedEvents().size());\n+                        if (ts.getOnNextEvents().size() != NUM_RETRIES + 2) {\n+                            data.put(j, ts.getOnNextEvents());\n                         }\n                     } catch (Throwable t) {\n                         timeouts.incrementAndGet();\n@@ -749,7 +751,16 @@ public void run() {\n         cdl.await();\n         assertEquals(0, timeouts.get());\n         if (data.size() > 0) {\n-            fail(\"Data content mismatch: \" + data);\n+            System.out.println(allSequenceFrequency(data));\n+        }\n+        if (exceptions.size() > 0) {\n+            System.out.println(exceptions);\n+        }\n+        if (completions.size() > 0) {\n+            System.out.println(completions);\n+        }\n+        if (data.size() > 0) {\n+            fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n         }\n         if (exceptions.size() > 0) {\n             fail(\"Exceptions received: \" + exceptions);\n@@ -758,6 +769,45 @@ public void run() {\n             fail(\"Multiple completions received: \" + completions);\n         }\n     }\n+    static <T> StringBuilder allSequenceFrequency(Map<Integer, List<T>> its) {\n+        StringBuilder b = new StringBuilder();\n+        for (Map.Entry<Integer, List<T>> e : its.entrySet()) {\n+            if (b.length() > 0) {\n+                b.append(\", \");\n+            }\n+            b.append(e.getKey()).append(\"={\");\n+            b.append(sequenceFrequency(e.getValue()));\n+            b.append(\"}\");\n+        }\n+        return b;\n+    }\n+    static <T> StringBuilder sequenceFrequency(Iterable<T> it) {\n+        StringBuilder sb = new StringBuilder();\n+        \n+        Object prev = null;\n+        int cnt = 0;\n+        \n+        for (Object curr : it) {\n+            if (sb.length() > 0) {\n+                if (!curr.equals(prev)) {\n+                    if (cnt > 1) {\n+                        sb.append(\" x \").append(cnt);\n+                        cnt = 1;\n+                    }\n+                    sb.append(\", \");\n+                    sb.append(curr);\n+                } else {\n+                    cnt++;\n+                }\n+            } else {\n+                sb.append(curr);\n+                cnt++;\n+            }\n+            prev = curr;\n+        }\n+        \n+        return sb;\n+    }\n     @Test(timeout = 3000)\n     public void testIssue1900() throws InterruptedException {\n         @SuppressWarnings(\"unchecked\")",
    "output": "Fix reentrancy issue with the error producer"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/util/SubscriptionIndexedRingBuffer.java b/src/main/java/rx/internal/util/SubscriptionIndexedRingBuffer.java\n--- a/src/main/java/rx/internal/util/SubscriptionIndexedRingBuffer.java\n+++ b/src/main/java/rx/internal/util/SubscriptionIndexedRingBuffer.java\n@@ -35,12 +35,6 @@ public final class SubscriptionIndexedRingBuffer<T extends Subscription> impleme\n     public SubscriptionIndexedRingBuffer() {\n     }\n \n-    public SubscriptionIndexedRingBuffer(final T... subscriptions) {\n-        for (T t : subscriptions) {\n-            this.subscriptions.add(t);\n-        }\n-    }\n-\n     @Override\n     public boolean isUnsubscribed() {\n         return unsubscribed == 1;\n\ndiff --git a/src/main/java/rx/internal/util/SubscriptionRandomList.java b/src/main/java/rx/internal/util/SubscriptionRandomList.java\n--- a/src/main/java/rx/internal/util/SubscriptionRandomList.java\n+++ b/src/main/java/rx/internal/util/SubscriptionRandomList.java\n@@ -16,14 +16,13 @@\n package rx.internal.util;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n \n import rx.Subscription;\n-import rx.exceptions.*;\n+import rx.exceptions.Exceptions;\n import rx.functions.Action1;\n \n /**\n@@ -39,10 +38,6 @@ public final class SubscriptionRandomList<T extends Subscription> implements Sub\n     public SubscriptionRandomList() {\n     }\n \n-    public SubscriptionRandomList(final T... subscriptions) {\n-        this.subscriptions = new HashSet<T>(Arrays.asList(subscriptions));\n-    }\n-\n     @Override\n     public synchronized boolean isUnsubscribed() {\n         return unsubscribed;\n\ndiff --git a/src/main/java/rx/plugins/RxJavaErrorHandler.java b/src/main/java/rx/plugins/RxJavaErrorHandler.java\n--- a/src/main/java/rx/plugins/RxJavaErrorHandler.java\n+++ b/src/main/java/rx/plugins/RxJavaErrorHandler.java\n@@ -19,7 +19,6 @@\n import rx.Subscriber;\n import rx.annotations.Experimental;\n import rx.exceptions.Exceptions;\n-import rx.exceptions.OnErrorThrowable;\n \n /**\n  * Abstract class for defining error handling logic in addition to the normal",
    "output": "Remove unused code that was the subject of varargs warnings, remove unused import"
  },
  {
    "input": "diff --git a/src/main/java/rx/functions/Action1.java b/src/main/java/rx/functions/Action1.java\n--- a/src/main/java/rx/functions/Action1.java\n+++ b/src/main/java/rx/functions/Action1.java\n@@ -18,6 +18,6 @@\n /**\n  * A one-argument action.\n  */\n-public interface Action1<T1> extends Action {\n-    void call(T1 t1);\n+public interface Action1<T> extends Action {\n+    void call(T t);\n }\n\ndiff --git a/src/main/java/rx/functions/Func1.java b/src/main/java/rx/functions/Func1.java\n--- a/src/main/java/rx/functions/Func1.java\n+++ b/src/main/java/rx/functions/Func1.java\n@@ -18,6 +18,6 @@\n /**\n  * Represents a function with one argument.\n  */\n-public interface Func1<T1, R> extends Function {\n-    R call(T1 t1);\n+public interface Func1<T, R> extends Function {\n+    R call(T t);\n }",
    "output": "Use simpler naming in Action1, Func1 because is used as a default for IDEs when generating implementing methods"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/util/IndexedRingBuffer.java b/src/main/java/rx/internal/util/IndexedRingBuffer.java\n--- a/src/main/java/rx/internal/util/IndexedRingBuffer.java\n+++ b/src/main/java/rx/internal/util/IndexedRingBuffer.java\n@@ -48,17 +48,18 @@\n  */\n public final class IndexedRingBuffer<E> implements Subscription {\n \n-    private static final ObjectPool<IndexedRingBuffer> POOL = new ObjectPool<IndexedRingBuffer>() {\n+    private static final ObjectPool<IndexedRingBuffer<?>> POOL = new ObjectPool<IndexedRingBuffer<?>>() {\n \n         @Override\n-        protected IndexedRingBuffer createObject() {\n-            return new IndexedRingBuffer();\n+        protected IndexedRingBuffer<?> createObject() {\n+            return new IndexedRingBuffer<Object>();\n         }\n \n     };\n \n-    public final static IndexedRingBuffer getInstance() {\n-        return POOL.borrowObject();\n+    @SuppressWarnings(\"unchecked\")\n+    public final static <T> IndexedRingBuffer<T> getInstance() {\n+        return (IndexedRingBuffer<T>) POOL.borrowObject();\n     }\n \n     private final ElementSection<E> elements = new ElementSection<E>();\n\ndiff --git a/src/main/java/rx/internal/util/SubscriptionIndexedRingBuffer.java b/src/main/java/rx/internal/util/SubscriptionIndexedRingBuffer.java\n--- a/src/main/java/rx/internal/util/SubscriptionIndexedRingBuffer.java\n+++ b/src/main/java/rx/internal/util/SubscriptionIndexedRingBuffer.java\n@@ -27,7 +27,6 @@\n  */\n public final class SubscriptionIndexedRingBuffer<T extends Subscription> implements Subscription {\n \n-    @SuppressWarnings(\"unchecked\")\n     private volatile IndexedRingBuffer<T> subscriptions = IndexedRingBuffer.getInstance();\n     private volatile int unsubscribed = 0;\n     @SuppressWarnings(\"rawtypes\")\n\ndiff --git a/src/perf/java/rx/internal/IndexedRingBufferPerf.java b/src/perf/java/rx/internal/IndexedRingBufferPerf.java\n--- a/src/perf/java/rx/internal/IndexedRingBufferPerf.java\n+++ b/src/perf/java/rx/internal/IndexedRingBufferPerf.java\n@@ -29,7 +29,6 @@ public class IndexedRingBufferPerf {\n \n     @Benchmark\n     public void indexedRingBufferAdd(IndexedRingBufferInput input) throws InterruptedException, MissingBackpressureException {\n-        @SuppressWarnings(\"unchecked\")\n         IndexedRingBuffer<Integer> list = IndexedRingBuffer.getInstance();\n         for (int i = 0; i < input.size; i++) {\n             list.add(i);\n@@ -40,7 +39,6 @@ public void indexedRingBufferAdd(IndexedRingBufferInput input) throws Interrupte\n \n     @Benchmark\n     public void indexedRingBufferAddRemove(IndexedRingBufferInput input) throws InterruptedException, MissingBackpressureException {\n-        @SuppressWarnings(\"unchecked\")\n         IndexedRingBuffer<Integer> list = IndexedRingBuffer.getInstance();\n         for (int i = 0; i < input.size; i++) {\n             list.add(i);\n\ndiff --git a/src/test/java/rx/internal/util/IndexedRingBufferTest.java b/src/test/java/rx/internal/util/IndexedRingBufferTest.java\n--- a/src/test/java/rx/internal/util/IndexedRingBufferTest.java\n+++ b/src/test/java/rx/internal/util/IndexedRingBufferTest.java\n@@ -37,7 +37,6 @@ public class IndexedRingBufferTest {\n \n     @Test\n     public void add() {\n-        @SuppressWarnings(\"unchecked\")\n         IndexedRingBuffer<LSubscription> list = IndexedRingBuffer.getInstance();\n         list.add(new LSubscription(1));\n         list.add(new LSubscription(2));\n@@ -49,7 +48,6 @@ public void add() {\n \n     @Test\n     public void removeEnd() {\n-        @SuppressWarnings(\"unchecked\")\n         IndexedRingBuffer<LSubscription> list = IndexedRingBuffer.getInstance();\n         list.add(new LSubscription(1));\n         int n2 = list.add(new LSubscription(2));\n@@ -67,7 +65,6 @@ public void removeEnd() {\n \n     @Test\n     public void removeMiddle() {\n-        @SuppressWarnings(\"unchecked\")\n         IndexedRingBuffer<LSubscription> list = IndexedRingBuffer.getInstance();\n         list.add(new LSubscription(1));\n         int n2 = list.add(new LSubscription(2));\n@@ -82,7 +79,6 @@ public void removeMiddle() {\n \n     @Test\n     public void addRemoveAdd() {\n-        @SuppressWarnings(\"unchecked\")\n         IndexedRingBuffer<String> list = IndexedRingBuffer.getInstance();\n         list.add(\"one\");\n         list.add(\"two\");\n@@ -119,7 +115,6 @@ public void addRemoveAdd() {\n     @Test\n     public void addThousands() {\n         String s = \"s\";\n-        @SuppressWarnings(\"unchecked\")\n         IndexedRingBuffer<String> list = IndexedRingBuffer.getInstance();\n         for (int i = 0; i < 10000; i++) {\n             list.add(s);\n@@ -145,7 +140,6 @@ public void addThousands() {\n \n     @Test\n     public void testForEachWithIndex() {\n-        @SuppressWarnings(\"unchecked\")\n         IndexedRingBuffer<String> buffer = IndexedRingBuffer.getInstance();\n         buffer.add(\"zero\");\n         buffer.add(\"one\");\n@@ -212,7 +206,6 @@ public Boolean call(String t1) {\n \n     @Test\n     public void testForEachAcrossSections() {\n-        @SuppressWarnings(\"unchecked\")\n         IndexedRingBuffer<Integer> buffer = IndexedRingBuffer.getInstance();\n         for (int i = 0; i < 10000; i++) {\n             buffer.add(i);\n@@ -231,7 +224,6 @@ public void testForEachAcrossSections() {\n     @Test\n     public void longRunningAddRemoveAddDoesntLeakMemory() {\n         String s = \"s\";\n-        @SuppressWarnings(\"unchecked\")\n         IndexedRingBuffer<String> list = IndexedRingBuffer.getInstance();\n         for (int i = 0; i < 20000; i++) {\n             int index = list.add(s);\n@@ -242,14 +234,13 @@ public void longRunningAddRemoveAddDoesntLeakMemory() {\n         list.forEach(newCounterAction(c));\n         assertEquals(0, c.get());\n         //        System.out.println(\"Index is: \" + list.index.get() + \" when it should be no bigger than \" + list.SIZE);\n-        assertTrue(list.index.get() < list.SIZE);\n+        assertTrue(list.index.get() < IndexedRingBuffer.SIZE);\n         // it should actually be 1 since we only did add/remove sequentially\n         assertEquals(1, list.index.get());\n     }\n \n     @Test\n     public void testConcurrentAdds() throws InterruptedException {\n-        @SuppressWarnings(\"unchecked\")\n         final IndexedRingBuffer<Integer> list = IndexedRingBuffer.getInstance();\n \n         Scheduler.Worker w1 = Schedulers.computation().createWorker();\n@@ -300,7 +291,6 @@ public void call() {\n \n     @Test\n     public void testConcurrentAddAndRemoves() throws InterruptedException {\n-        @SuppressWarnings(\"unchecked\")\n         final IndexedRingBuffer<Integer> list = IndexedRingBuffer.getInstance();\n \n         final List<Exception> exceptions = Collections.synchronizedList(new ArrayList<Exception>());",
    "output": "Add generic type to IndexedRingBuffer.POOL and modifiy IndexedRingBuffer.getInstance so that infers type"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/BackpressureUtils.java b/src/main/java/rx/internal/operators/BackpressureUtils.java\n--- a/src/main/java/rx/internal/operators/BackpressureUtils.java\n+++ b/src/main/java/rx/internal/operators/BackpressureUtils.java\n@@ -22,8 +22,11 @@\n  * Utility functions for use with backpressure.\n  *\n  */\n-final class BackpressureUtils {\n-\n+public final class BackpressureUtils {\n+    /** Utility class, no instances. */\n+    private BackpressureUtils() {\n+        throw new IllegalStateException(\"No instances!\");\n+    }\n     /**\n      * Adds {@code n} to {@code requested} field and returns the value prior to\n      * addition once the addition is successful (uses CAS semantics). If\n@@ -37,16 +40,18 @@ final class BackpressureUtils {\n      *            the number of requests to add to the requested count\n      * @return requested value just prior to successful addition\n      */\n-    static <T> long getAndAddRequest(AtomicLongFieldUpdater<T> requested, T object, long n) {\n+    public static <T> long getAndAddRequest(AtomicLongFieldUpdater<T> requested, T object, long n) {\n         // add n to field but check for overflow\n         while (true) {\n             long current = requested.get(object);\n             long next = current + n;\n             // check for overflow\n-            if (next < 0)\n+            if (next < 0) {\n                 next = Long.MAX_VALUE;\n-            if (requested.compareAndSet(object, current, next))\n+            }\n+            if (requested.compareAndSet(object, current, next)) {\n                 return current;\n+            }\n         }\n     }\n \n@@ -63,16 +68,18 @@ static <T> long getAndAddRequest(AtomicLongFieldUpdater<T> requested, T object,\n      *            the number of requests to add to the requested count\n      * @return requested value just prior to successful addition\n      */\n-    static <T> long getAndAddRequest(AtomicLong requested, long n) {\n+    public static long getAndAddRequest(AtomicLong requested, long n) {\n         // add n to field but check for overflow\n         while (true) {\n             long current = requested.get();\n             long next = current + n;\n             // check for overflow\n-            if (next < 0)\n+            if (next < 0) {\n                 next = Long.MAX_VALUE;\n-            if (requested.compareAndSet(current, next))\n+            }\n+            if (requested.compareAndSet(current, next)) {\n                 return current;\n+            }\n         }\n     }\n }\n\ndiff --git a/src/main/java/rx/observables/AbstractOnSubscribe.java b/src/main/java/rx/observables/AbstractOnSubscribe.java\n--- a/src/main/java/rx/observables/AbstractOnSubscribe.java\n+++ b/src/main/java/rx/observables/AbstractOnSubscribe.java\n@@ -24,6 +24,7 @@\n import rx.annotations.Experimental;\n import rx.exceptions.CompositeException;\n import rx.functions.*;\n+import rx.internal.operators.BackpressureUtils;\n \n /**\n  * Abstract base class for the {@link OnSubscribe} interface that helps you build Observable sources one\n@@ -332,14 +333,15 @@ private SubscriptionProducer(SubscriptionState<T, S> state) {\n         }\n         @Override\n         public void request(long n) {\n-            if (n == Long.MAX_VALUE) {\n-                for (; !state.subscriber.isUnsubscribed(); ) {\n-                    if (!doNext()) {\n-                        break;\n+            if (n > 0 && BackpressureUtils.getAndAddRequest(state.requestCount, n) == 0) {\n+                if (n == Long.MAX_VALUE) {\n+                    // fast-path\n+                    for (; !state.subscriber.isUnsubscribed(); ) {\n+                        if (!doNext()) {\n+                            break;\n+                        }\n                     }\n-                }\n-            } else \n-            if (n > 0 && state.requestCount.getAndAdd(n) == 0) {\n+                } else \n                 if (!state.subscriber.isUnsubscribed()) {\n                     do {\n                         if (!doNext()) {\n\ndiff --git a/src/test/java/rx/observables/AbstractOnSubscribeTest.java b/src/test/java/rx/observables/AbstractOnSubscribeTest.java\n--- a/src/test/java/rx/observables/AbstractOnSubscribeTest.java\n+++ b/src/test/java/rx/observables/AbstractOnSubscribeTest.java\n@@ -16,12 +16,13 @@\n \n package rx.observables;\n \n-import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.*;\n import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.*;\n \n import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.Test;\n import org.mockito.InOrder;\n@@ -503,4 +504,37 @@ public void testMissingEmission() {\n         verify(o, never()).onNext(any(Object.class));\n         verify(o).onError(any(IllegalStateException.class));\n     }\n+    \n+    @Test\n+    public void testCanRequestInOnNext() {\n+        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {\n+            @Override\n+            protected void next(SubscriptionState<Integer, Void> state) {\n+                state.onNext(1);\n+                state.onCompleted();\n+            }\n+        };\n+        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();\n+        aos.toObservable().subscribe(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onCompleted() {\n+\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                exception.set(e);\n+            }\n+\n+            @Override\n+            public void onNext(Integer t) {\n+                request(1);\n+            }\n+        });\n+        if (exception.get()!=null) {\n+            exception.get().printStackTrace();\n+        }\n+        assertNull(exception.get());\n+    }\n }",
    "output": "Fix request accounting, increased visibility of BackpressureUtils"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorDoOnRequest.java b/src/main/java/rx/internal/operators/OperatorDoOnRequest.java\n--- a/src/main/java/rx/internal/operators/OperatorDoOnRequest.java\n+++ b/src/main/java/rx/internal/operators/OperatorDoOnRequest.java\n@@ -48,7 +48,7 @@ public void request(long n) {\n             }\n \n         });\n-\n+        child.add(parent);\n         return parent;\n     }\n \n\ndiff --git a/src/test/java/rx/internal/operators/OperatorDoOnRequestTest.java b/src/test/java/rx/internal/operators/OperatorDoOnRequestTest.java\n--- a/src/test/java/rx/internal/operators/OperatorDoOnRequestTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorDoOnRequestTest.java\n@@ -0,0 +1,80 @@\n+package rx.internal.operators;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.junit.Test;\n+\n+import rx.Observable;\n+import rx.Subscriber;\n+import rx.functions.Action0;\n+import rx.functions.Action1;\n+\n+public class OperatorDoOnRequestTest {\n+\n+    @Test\n+    public void testUnsubscribeHappensAgainstParent() {\n+        final AtomicBoolean unsubscribed = new AtomicBoolean(false);\n+        Observable.just(1)\n+        //\n+                .doOnUnsubscribe(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        unsubscribed.set(true);\n+                    }\n+                })\n+                //\n+                .doOnRequest(new Action1<Long>() {\n+                    @Override\n+                    public void call(Long n) {\n+                        // do nothing\n+                    }\n+                })\n+                //\n+                .subscribe();\n+        assertTrue(unsubscribed.get());\n+    }\n+\n+    @Test\n+    public void testDoRequest() {\n+        final List<Long> requests = new ArrayList<Long>();\n+        Observable.range(1, 5)\n+        //\n+                .doOnRequest(new Action1<Long>() {\n+                    @Override\n+                    public void call(Long n) {\n+                        requests.add(n);\n+                    }\n+                })\n+                //\n+                .subscribe(new Subscriber<Integer>() {\n+\n+                    @Override\n+                    public void onStart() {\n+                        request(3);\n+                    }\n+\n+                    @Override\n+                    public void onCompleted() {\n+\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable e) {\n+\n+                    }\n+\n+                    @Override\n+                    public void onNext(Integer t) {\n+                        request(t);\n+                    }\n+                });\n+        assertEquals(Arrays.asList(3L,1L,2L,3L,4L,5L), requests);\n+    }\n+\n+}",
    "output": "Fix unsub of OperatorDoOnRequest and add more unit tests"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeRedo.java b/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n@@ -211,26 +211,35 @@ public void call() {\n                 }\n \n                 Subscriber<T> terminalDelegatingSubscriber = new Subscriber<T>() {\n+                    boolean done;\n                     @Override\n                     public void onCompleted() {\n-                        currentProducer.set(null);\n-                        unsubscribe();\n-                        terminals.onNext(Notification.createOnCompleted());\n+                        if (!done) {\n+                            done = true;\n+                            currentProducer.set(null);\n+                            unsubscribe();\n+                            terminals.onNext(Notification.createOnCompleted());\n+                        }\n                     }\n \n                     @Override\n                     public void onError(Throwable e) {\n-                        currentProducer.set(null);\n-                        unsubscribe();\n-                        terminals.onNext(Notification.createOnError(e));\n+                        if (!done) {\n+                            done = true;\n+                            currentProducer.set(null);\n+                            unsubscribe();\n+                            terminals.onNext(Notification.createOnError(e));\n+                        }\n                     }\n \n                     @Override\n                     public void onNext(T v) {\n-                        if (consumerCapacity.get() != Long.MAX_VALUE) {\n-                            consumerCapacity.decrementAndGet();\n+                        if (!done) {\n+                            if (consumerCapacity.get() != Long.MAX_VALUE) {\n+                                consumerCapacity.decrementAndGet();\n+                            }\n+                            child.onNext(v);\n                         }\n-                        child.onNext(v);\n                     }\n \n                     @Override\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorRetryWithPredicate.java b/src/main/java/rx/internal/operators/OperatorRetryWithPredicate.java\n--- a/src/main/java/rx/internal/operators/OperatorRetryWithPredicate.java\n+++ b/src/main/java/rx/internal/operators/OperatorRetryWithPredicate.java\n@@ -84,26 +84,34 @@ public void call() {\n                         // new subscription each time so if it unsubscribes itself it does not prevent retries\n                         // by unsubscribing the child subscription\n                         Subscriber<T> subscriber = new Subscriber<T>() {\n-\n+                            boolean done;\n                             @Override\n                             public void onCompleted() {\n-                                child.onCompleted();\n+                                if (!done) {\n+                                    done = true;\n+                                    child.onCompleted();\n+                                }\n                             }\n \n                             @Override\n                             public void onError(Throwable e) {\n-                                if (predicate.call(attempts, e) && !inner.isUnsubscribed()) {\n-                                    // retry again\n-                                    inner.schedule(_self);\n-                                } else {\n-                                    // give up and pass the failure\n-                                    child.onError(e);\n+                                if (!done) {\n+                                    done = true;\n+                                    if (predicate.call(attempts, e) && !inner.isUnsubscribed()) {\n+                                        // retry again\n+                                        inner.schedule(_self);\n+                                    } else {\n+                                        // give up and pass the failure\n+                                        child.onError(e);\n+                                    }\n                                 }\n                             }\n \n                             @Override\n                             public void onNext(T v) {\n-                                child.onNext(v);\n+                                if (!done) {\n+                                    child.onNext(v);\n+                                }\n                             }\n \n                         };\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorRetryWithPredicateTest.java b/src/test/java/rx/internal/operators/OperatorRetryWithPredicateTest.java\n--- a/src/test/java/rx/internal/operators/OperatorRetryWithPredicateTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorRetryWithPredicateTest.java\n@@ -15,21 +15,23 @@\n  */\n package rx.internal.operators;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.*;\n+\n import java.io.IOException;\n+import java.util.Collections;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import static org.junit.Assert.assertEquals;\n+import java.util.concurrent.atomic.*;\n+\n import org.junit.Test;\n import org.mockito.InOrder;\n-import static org.mockito.Mockito.*;\n-import rx.Observable;\n+\n+import rx.*;\n import rx.Observable.OnSubscribe;\n-import rx.Observer;\n-import rx.Subscriber;\n-import rx.Subscription;\n import rx.exceptions.TestException;\n-import rx.functions.Action1;\n-import rx.functions.Func2;\n+import rx.functions.*;\n+import rx.observers.TestSubscriber;\n import rx.subjects.PublishSubject;\n \n public class OperatorRetryWithPredicateTest {\n@@ -270,4 +272,37 @@ public void testTimeoutWithRetry() {\n \n         assertEquals(\"Start 6 threads, retry 5 then fail on 6\", 6, so.efforts.get());\n     }\n+    \n+    @Test\n+    public void testIssue2826() {\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        final RuntimeException e = new RuntimeException(\"You shall not pass\");\n+        final AtomicInteger c = new AtomicInteger();\n+        Observable.just(1).map(new Func1<Integer, Integer>() {\n+            @Override\n+            public Integer call(Integer t1) {\n+                c.incrementAndGet();\n+                throw e;\n+            }\n+        }).retry(retry5).subscribe(ts);\n+\n+        ts.assertTerminalEvent();\n+        assertEquals(6, c.get());\n+        assertEquals(Collections.singletonList(e), ts.getOnErrorEvents());\n+    }\n+    @Test\n+    public void testJustAndRetry() throws Exception {\n+        final AtomicBoolean throwException = new AtomicBoolean(true);\n+        int value = Observable.just(1).map(new Func1<Integer, Integer>() {\n+            @Override\n+            public Integer call(Integer t1) {\n+                if (throwException.compareAndSet(true, false)) {\n+                    throw new TestException();\n+                }\n+                return t1;\n+            }\n+        }).retry(1).toBlocking().single();\n+\n+        assertEquals(1, value);\n+    }\n }",
    "output": "Change retryWhen to eagerly ignore an error'd source's subsequent events"
  },
  {
    "input": "diff --git a/src/test/java/rx/internal/operators/OperatorDebounceTest.java b/src/test/java/rx/internal/operators/OperatorDebounceTest.java\n--- a/src/test/java/rx/internal/operators/OperatorDebounceTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorDebounceTest.java\n@@ -23,6 +23,7 @@\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n \n+import java.util.Arrays;\n import java.util.concurrent.TimeUnit;\n \n import org.junit.Before;\n@@ -36,6 +37,7 @@\n import rx.exceptions.TestException;\n import rx.functions.Action0;\n import rx.functions.Func1;\n+import rx.observers.TestSubscriber;\n import rx.schedulers.TestScheduler;\n import rx.subjects.PublishSubject;\n \n@@ -287,4 +289,20 @@ public Observable<Integer> call(Integer t1) {\n         verify(o).onCompleted();\n         verify(o, never()).onError(any(Throwable.class));\n     }\n+\n+    @Test\n+    public void debounceWithTimeBackpressure() throws InterruptedException {\n+        TestScheduler scheduler = new TestScheduler();\n+        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();\n+        Observable.merge(\n+                Observable.just(1),\n+                Observable.just(2).delay(10, TimeUnit.MILLISECONDS, scheduler)\n+        ).debounce(20, TimeUnit.MILLISECONDS, scheduler).take(1).subscribe(subscriber);\n+\n+        scheduler.advanceTimeBy(30, TimeUnit.MILLISECONDS);\n+\n+        subscriber.assertReceivedOnNext(Arrays.asList(2));\n+        subscriber.assertTerminalEvent();\n+        subscriber.assertNoErrors();\n+    }\n }\n\\ No newline at end of file",
    "output": "Add a unit test for debounce's backpressure issue"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java b/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java\n--- a/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java\n+++ b/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java\n@@ -62,6 +62,12 @@ public Subscriber<? super T> call(final Subscriber<? super T> child) {\n         return new Subscriber<T>(child) {\n             final DebounceState<T> state = new DebounceState<T>();\n             final Subscriber<?> self = this;\n+\n+            @Override\n+            public void onStart() {\n+                request(Long.MAX_VALUE);\n+            }\n+\n             @Override\n             public void onNext(final T t) {\n                 ",
    "output": "Add 'request(Long.MAX_VALUE)' in 'onStart' to fix the backpressure issue of debounce"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeRedo.java b/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n@@ -213,12 +213,14 @@ public void call() {\n                 Subscriber<T> terminalDelegatingSubscriber = new Subscriber<T>() {\n                     @Override\n                     public void onCompleted() {\n+                        currentProducer.set(null);\n                         unsubscribe();\n                         terminals.onNext(Notification.createOnCompleted());\n                     }\n \n                     @Override\n                     public void onError(Throwable e) {\n+                        currentProducer.set(null);\n                         unsubscribe();\n                         terminals.onNext(Notification.createOnError(e));\n                     }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorRepeatTest.java b/src/test/java/rx/internal/operators/OperatorRepeatTest.java\n--- a/src/test/java/rx/internal/operators/OperatorRepeatTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorRepeatTest.java\n@@ -20,7 +20,8 @@\n import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.*;\n \n-import java.util.Arrays;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Test;\n@@ -174,4 +175,28 @@ public void testRepeatAndDistinctUnbounded() {\n         ts.assertTerminalEvent();\n         ts.assertReceivedOnNext(Arrays.asList(1, 2, 3));\n     }\n+    /** Issue #2844: wrong target of request. */\n+    @Test(timeout = 3000)\n+    public void testRepeatRetarget() {\n+        final List<Integer> concatBase = new ArrayList<Integer>();\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        Observable.just(1, 2)\n+        .repeat(5)\n+        .concatMap(new Func1<Integer, Observable<Integer>>() {\n+            @Override\n+            public Observable<Integer> call(Integer x) {\n+                System.out.println(\"testRepeatRetarget -> \" + x);\n+                concatBase.add(x);\n+                return Observable.<Integer>empty()\n+                        .delay(200, TimeUnit.MILLISECONDS);\n+            }\n+        })\n+        .subscribe(ts);\n+\n+        ts.awaitTerminalEvent();\n+        ts.assertNoErrors();\n+        ts.assertReceivedOnNext(Collections.<Integer>emptyList());\n+        \n+        assertEquals(Arrays.asList(1, 2, 1, 2, 1, 2, 1, 2, 1, 2), concatBase);\n+    }\n }",
    "output": "Fix for issue 2844: wrong target of request on repeat"
  },
  {
    "input": "diff --git a/src/test/java/rx/BackpressureTests.java b/src/test/java/rx/BackpressureTests.java\n--- a/src/test/java/rx/BackpressureTests.java\n+++ b/src/test/java/rx/BackpressureTests.java\n@@ -446,7 +446,7 @@ public void testOnBackpressureDropWithAction() {\n             final AtomicInteger emitCount = new AtomicInteger();\n             final AtomicInteger dropCount = new AtomicInteger();\n             final AtomicInteger passCount = new AtomicInteger();\n-            final int NUM = (int) (RxRingBuffer.SIZE * 1.5); // > 1 so that take doesn't prevent buffer overflow\n+            final int NUM = RxRingBuffer.SIZE * 3; // > 1 so that take doesn't prevent buffer overflow\n             TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n             firehose(emitCount).onBackpressureDrop(new Action1<Integer>() {\n                 @Override",
    "output": "Add more to take to decrease the likelyhood that nothing is dropped"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorTakeUntil.java b/src/main/java/rx/internal/operators/OperatorTakeUntil.java\n--- a/src/main/java/rx/internal/operators/OperatorTakeUntil.java\n+++ b/src/main/java/rx/internal/operators/OperatorTakeUntil.java\n@@ -36,28 +36,62 @@ public OperatorTakeUntil(final Observable<? extends E> other) {\n \n     @Override\n     public Subscriber<? super T> call(final Subscriber<? super T> child) {\n-        final Subscriber<T> parent = new SerializedSubscriber<T>(child);\n-\n-        other.unsafeSubscribe(new Subscriber<E>(child) {\n-\n+        final Subscriber<T> serial = new SerializedSubscriber<T>(child, false);\n+        \n+        final Subscriber<T> main = new Subscriber<T>(serial, false) {\n+            @Override\n+            public void onNext(T t) {\n+                serial.onNext(t);\n+            }\n+            @Override\n+            public void onError(Throwable e) {\n+                try {\n+                    serial.onError(e);\n+                } finally {\n+                    serial.unsubscribe();\n+                }\n+            }\n             @Override\n             public void onCompleted() {\n-                parent.onCompleted();\n+                try {\n+                    serial.onCompleted();\n+                } finally {\n+                    serial.unsubscribe();\n+                }\n+            }\n+        };\n+        \n+        final Subscriber<E> so = new Subscriber<E>() {\n+            @Override\n+            public void onStart() {\n+                request(Long.MAX_VALUE);\n+            }\n+            \n+            @Override\n+            public void onCompleted() {\n+                main.onCompleted();\n             }\n \n             @Override\n             public void onError(Throwable e) {\n-                parent.onError(e);\n+                main.onError(e);\n             }\n \n             @Override\n             public void onNext(E t) {\n-                parent.onCompleted();\n+                onCompleted();\n             }\n \n-        });\n+        };\n+\n+        serial.add(main);\n+        serial.add(so);\n+        \n+        child.add(serial);\n+        \n+        other.unsafeSubscribe(so);\n \n-        return parent;\n+        return main;\n     }\n \n }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorTakeUntilTest.java b/src/test/java/rx/internal/operators/OperatorTakeUntilTest.java\n--- a/src/test/java/rx/internal/operators/OperatorTakeUntilTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorTakeUntilTest.java\n@@ -15,16 +15,20 @@\n  */\n package rx.internal.operators;\n \n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.Arrays;\n \n import org.junit.Test;\n \n import rx.Observable;\n import rx.Observer;\n import rx.Subscriber;\n import rx.Subscription;\n+import rx.observers.TestSubscriber;\n+import rx.subjects.PublishSubject;\n \n public class OperatorTakeUntilTest {\n \n@@ -188,4 +192,98 @@ public void call(Subscriber<? super String> observer) {\n             observer.add(s);\n         }\n     }\n+    \n+    @Test\n+    public void testUntilFires() {\n+        PublishSubject<Integer> source = PublishSubject.create();\n+        PublishSubject<Integer> until = PublishSubject.create();\n+        \n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        \n+        source.takeUntil(until).unsafeSubscribe(ts);\n+\n+        assertTrue(source.hasObservers());\n+        assertTrue(until.hasObservers());\n+\n+        source.onNext(1);\n+        \n+        ts.assertReceivedOnNext(Arrays.asList(1));\n+        until.onNext(1);\n+        \n+        ts.assertReceivedOnNext(Arrays.asList(1));\n+        ts.assertNoErrors();\n+        ts.assertTerminalEvent();\n+        \n+        assertFalse(\"Source still has observers\", source.hasObservers());\n+        assertFalse(\"Until still has observers\", until.hasObservers());\n+        assertFalse(\"TestSubscriber is unsubscribed\", ts.isUnsubscribed());\n+    }\n+    @Test\n+    public void testMainCompletes() {\n+        PublishSubject<Integer> source = PublishSubject.create();\n+        PublishSubject<Integer> until = PublishSubject.create();\n+        \n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        \n+        source.takeUntil(until).unsafeSubscribe(ts);\n+\n+        assertTrue(source.hasObservers());\n+        assertTrue(until.hasObservers());\n+\n+        source.onNext(1);\n+        source.onCompleted();\n+        \n+        ts.assertReceivedOnNext(Arrays.asList(1));\n+        ts.assertNoErrors();\n+        ts.assertTerminalEvent();\n+        \n+        assertFalse(\"Source still has observers\", source.hasObservers());\n+        assertFalse(\"Until still has observers\", until.hasObservers());\n+        assertFalse(\"TestSubscriber is unsubscribed\", ts.isUnsubscribed());\n+    }\n+    @Test\n+    public void testDownstreamUnsubscribes() {\n+        PublishSubject<Integer> source = PublishSubject.create();\n+        PublishSubject<Integer> until = PublishSubject.create();\n+        \n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        \n+        source.takeUntil(until).take(1).unsafeSubscribe(ts);\n+\n+        assertTrue(source.hasObservers());\n+        assertTrue(until.hasObservers());\n+\n+        source.onNext(1);\n+        \n+        ts.assertReceivedOnNext(Arrays.asList(1));\n+        ts.assertNoErrors();\n+        ts.assertTerminalEvent();\n+        \n+        assertFalse(\"Source still has observers\", source.hasObservers());\n+        assertFalse(\"Until still has observers\", until.hasObservers());\n+        assertFalse(\"TestSubscriber is unsubscribed\", ts.isUnsubscribed());\n+    }\n+    public void testBackpressure() {\n+        PublishSubject<Integer> until = PublishSubject.create();\n+        \n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {\n+            @Override\n+            public void onStart() {\n+                requestMore(0);\n+            }\n+        };\n+        \n+        Observable.range(1, 10).takeUntil(until).unsafeSubscribe(ts);\n+\n+        assertTrue(until.hasObservers());\n+\n+        ts.requestMore(1);\n+        \n+        ts.assertReceivedOnNext(Arrays.asList(1));\n+        ts.assertNoErrors();\n+        assertTrue(\"TestSubscriber completed\", ts.getOnCompletedEvents().isEmpty());\n+        \n+        assertFalse(\"Until still has observers\", until.hasObservers());\n+        assertFalse(\"TestSubscriber is unsubscribed\", ts.isUnsubscribed());\n+    }\n }",
    "output": "Fix takeUntil not unsubscribing from either of the observables in case of a terminal condition"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -5279,7 +5279,10 @@ public final Observable<T> onBackpressureBuffer(long capacity, Action0 onOverflo\n      * @param onDrop the action to invoke for each item dropped. onDrop action should be fast and should never block.\n      * @return the source Observable modified to drop {@code onNext} notifications on overflow\n      * @see <a href=\"http://reactivex.io/documentation/operators/backpressure.html\">ReactiveX operators documentation: backpressure operators</a>\n+     * @Experimental The behavior of this can change at any time. \n+     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)\n      */\n+    @Experimental\n     public final Observable<T> onBackpressureDrop(Action1<? super T> onDrop) {\n         return lift(new OperatorOnBackpressureDrop<T>(onDrop));\n     }",
    "output": "Add Experimental to onBackpressureDrop(Action1)"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorPublish.java b/src/main/java/rx/internal/operators/OperatorPublish.java\n--- a/src/main/java/rx/internal/operators/OperatorPublish.java\n+++ b/src/main/java/rx/internal/operators/OperatorPublish.java\n@@ -213,6 +213,10 @@ public synchronized boolean canEmitWithDecrement() {\n             return false;\n         }\n \n+        public synchronized boolean hasNoSubscriber() {\n+            return subscribers.length == 0;\n+        }\n+\n         public synchronized void incrementOutstandingAfterFailedEmit() {\n             outstandingRequests++;\n         }\n@@ -308,11 +312,13 @@ public void emit(Object t) throws MissingBackpressureException {\n         }\n \n         private void requestMoreAfterEmission(int emitted) {\n-            OriginSubscriber<T> origin = state.getOrigin();\n-            if (emitted > 0 && origin != null) {\n-                long r = origin.originOutstanding.addAndGet(-emitted);\n-                if (r <= origin.THRESHOLD) {\n-                    origin.requestMore(RxRingBuffer.SIZE - origin.THRESHOLD);\n+            if (emitted > 0) {\n+                OriginSubscriber<T> origin = state.getOrigin();\n+                if (origin != null) {\n+                    long r = origin.originOutstanding.addAndGet(-emitted);\n+                    if (r <= origin.THRESHOLD) {\n+                        origin.requestMore(RxRingBuffer.SIZE - origin.THRESHOLD);\n+                    }\n                 }\n             }\n         }\n@@ -336,8 +342,18 @@ public void drainQueue(OriginSubscriber<T> originSubscriber) {\n                      * If we want to batch this then we need to account for new subscribers arriving with a lower request count\n                      * concurrently while iterating the batch ... or accept that they won't\n                      */\n-                    \n                     while (true) {\n+                        if (localState.hasNoSubscriber()) {\n+                            // Drop items due to no subscriber\n+                            if (localBuffer.poll() == null) {\n+                                // Exit due to no more item\n+                                break;\n+                            } else {\n+                                // Keep dropping cached items.\n+                                continue;\n+                            }\n+                        }\n+\n                         boolean shouldEmit = localState.canEmitWithDecrement();\n                         if (!shouldEmit) {\n                             break;\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorPublishTest.java b/src/test/java/rx/internal/operators/OperatorPublishTest.java\n--- a/src/test/java/rx/internal/operators/OperatorPublishTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorPublishTest.java\n@@ -30,6 +30,7 @@\n import rx.observables.ConnectableObservable;\n import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n+import rx.schedulers.TestScheduler;\n \n public class OperatorPublishTest {\n \n@@ -242,4 +243,20 @@ public void call() {\n         \n         assertEquals(8, sourceEmission.get());\n     }\n+\n+    @Test\n+    public void testConnectWithNoSubscriber() {\n+        TestScheduler scheduler = new TestScheduler();\n+        ConnectableObservable<Long> co = Observable.timer(10, 10, TimeUnit.MILLISECONDS, scheduler).take(3).publish();\n+        co.connect();\n+        // Emit 0\n+        scheduler.advanceTimeBy(15, TimeUnit.MILLISECONDS);\n+        TestSubscriber subscriber = new TestSubscriber<Long>();\n+        co.subscribe(subscriber);\n+        // Emit 1 and 2\n+        scheduler.advanceTimeBy(50, TimeUnit.MILLISECONDS);\n+        subscriber.assertReceivedOnNext(Arrays.asList(1L, 2L));\n+        subscriber.assertNoErrors();\n+        subscriber.assertTerminalEvent();\n+    }\n }",
    "output": "Fix the bug that 'publish' will cache items when no subscriber"
  },
  {
    "input": "diff --git a/src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java b/src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java\n--- a/src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java\n@@ -93,7 +93,7 @@ public void testFixBackpressureBufferNegativeCapacity() throws InterruptedExcept\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testFixBackpressureBufferZeroCapacity() throws InterruptedException {\n-        Observable.empty().onBackpressureBuffer(-1);\n+        Observable.empty().onBackpressureBuffer(0);\n     }\n \n     @Test\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorOnBackpressureDropTest.java b/src/test/java/rx/internal/operators/OperatorOnBackpressureDropTest.java\n--- a/src/test/java/rx/internal/operators/OperatorOnBackpressureDropTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorOnBackpressureDropTest.java\n@@ -46,7 +46,7 @@ public void testNoBackpressureSupport() {\n     @Test(timeout = 500)\n     public void testWithObserveOn() throws InterruptedException {\n         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n-        Observable.range(0, RxRingBuffer.SIZE * 10).onBackpressureDrop().onBackpressureDrop().observeOn(Schedulers.io()).subscribe(ts);\n+        Observable.range(0, RxRingBuffer.SIZE * 10).onBackpressureDrop().observeOn(Schedulers.io()).subscribe(ts);\n         ts.awaitTerminalEvent();\n     }\n ",
    "output": "Fix several typos"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeRange.java b/src/main/java/rx/internal/operators/OnSubscribeRange.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeRange.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeRange.java\n@@ -73,7 +73,7 @@ public void request(long n) {\n                 }\n             } else if (n > 0) {\n                 // backpressure is requested\n-                long _c = REQUESTED_UPDATER.getAndAdd(this, n);\n+                long _c = BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER,this, n);\n                 if (_c == 0) {\n                     while (true) {\n                         /*\n\ndiff --git a/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java b/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java\n--- a/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java\n+++ b/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java\n@@ -32,6 +32,7 @@\n \n import rx.Observable;\n import rx.Observer;\n+import rx.Subscriber;\n import rx.functions.Action1;\n import rx.internal.util.RxRingBuffer;\n import rx.observers.TestSubscriber;\n@@ -190,4 +191,33 @@ public void testWithBackpressureRequestWayMore() {\n         ts.assertReceivedOnNext(list);\n         ts.assertTerminalEvent();\n     }\n+    \n+    @Test\n+    public void testRequestOverflow() {\n+        final AtomicInteger count = new AtomicInteger();\n+        int n = 10;\n+        Observable.range(1, n).subscribe(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(2);\n+            }\n+            \n+            @Override\n+            public void onCompleted() {\n+                //do nothing\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            @Override\n+            public void onNext(Integer t) {\n+                count.incrementAndGet();\n+                request(Long.MAX_VALUE - 1);\n+            }});\n+        assertEquals(n, count.get());\n+    }\n }",
    "output": "Add request overflow check to OnSubscribeRange"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorOnBackpressureDrop.java b/src/main/java/rx/internal/operators/OperatorOnBackpressureDrop.java\n--- a/src/main/java/rx/internal/operators/OperatorOnBackpressureDrop.java\n+++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureDrop.java\n@@ -43,7 +43,7 @@ public Subscriber<? super T> call(final Subscriber<? super T> child) {\n \n             @Override\n             public void request(long n) {\n-                requested.getAndAdd(n);\n+                BackpressureUtils.getAndAddRequest(requested, n);\n             }\n \n         });\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorOnBackpressureDropTest.java b/src/test/java/rx/internal/operators/OperatorOnBackpressureDropTest.java\n--- a/src/test/java/rx/internal/operators/OperatorOnBackpressureDropTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorOnBackpressureDropTest.java\n@@ -17,6 +17,9 @@\n \n import static org.junit.Assert.assertEquals;\n \n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n import org.junit.Test;\n \n import rx.Observable;\n@@ -27,8 +30,6 @@\n import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n \n-import java.util.concurrent.CountDownLatch;\n-\n public class OperatorOnBackpressureDropTest {\n \n     @Test\n@@ -87,6 +88,35 @@ public void onNext(Long t) {\n         ts.assertNoErrors();\n         assertEquals(0, ts.getOnNextEvents().get(0).intValue());\n     }\n+    \n+    @Test\n+    public void testRequestOverflow() throws InterruptedException {\n+        final AtomicInteger count = new AtomicInteger();\n+        int n = 10;\n+        range(n).onBackpressureDrop().subscribe(new Subscriber<Long>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(10);\n+            }\n+            \n+            @Override\n+            public void onCompleted() {\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            @Override\n+            public void onNext(Long t) {\n+                count.incrementAndGet();\n+                //cause overflow of requested if not handled properly in onBackpressureDrop operator\n+                request(Long.MAX_VALUE-1);\n+            }});\n+        assertEquals(n, count.get());\n+    }\n \n     static final Observable<Long> infinite = Observable.create(new OnSubscribe<Long>() {\n \n@@ -99,4 +129,22 @@ public void call(Subscriber<? super Long> s) {\n         }\n \n     });\n+    \n+    private static final Observable<Long> range(final long n) {\n+        return Observable.create(new OnSubscribe<Long>() {\n+\n+            @Override\n+            public void call(Subscriber<? super Long> s) {\n+                for (long i=0;i < n;i++) {\n+                    if (s.isUnsubscribed()) {\n+                        break;\n+                    }\n+                    s.onNext(i);\n+                }\n+                s.onCompleted();\n+            }\n+    \n+        });\n+    }\n+    \n }",
    "output": "Add request overflow check to OperatorOnBackpressureDrop"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java\n@@ -110,7 +110,7 @@ public MultiSourceProducer(final Subscriber<? super R> child, final List<? exten\n \n         @Override\n         public void request(long n) {\n-            requested.getAndAdd(n);\n+            BackpressureUtils.getAndAddRequest(requested, n);\n             if (!started.get() && started.compareAndSet(false, true)) {\n                 /*\n                  * NOTE: this logic will ONLY work if we don't have more sources than the size of the buffer.\n\ndiff --git a/src/test/java/rx/internal/operators/OnSubscribeCombineLatestTest.java b/src/test/java/rx/internal/operators/OnSubscribeCombineLatestTest.java\n--- a/src/test/java/rx/internal/operators/OnSubscribeCombineLatestTest.java\n+++ b/src/test/java/rx/internal/operators/OnSubscribeCombineLatestTest.java\n@@ -851,5 +851,40 @@ public Long call(Long t1, Integer t2) {\n \n         assertEquals(SIZE, count.get());\n     }\n+    \n+    @Test(timeout=10000)\n+    public void testCombineLatestRequestOverflow() throws InterruptedException {\n+        List<Observable<Integer>> sources = Arrays.asList(Observable.from(Arrays.asList(1,2,3,4)), Observable.from(Arrays.asList(5,6,7,8)));\n+        Observable<Integer> o = Observable.combineLatest(sources,new FuncN<Integer>() {\n+            @Override\n+            public Integer call(Object... args) {\n+               return (Integer) args[0];\n+            }});\n+        //should get at least 4\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        o.subscribeOn(Schedulers.computation()).subscribe(new Subscriber<Integer>() {\n+            \n+            @Override\n+            public void onStart() {\n+                request(2);\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+                //ignore\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            @Override\n+            public void onNext(Integer t) {\n+                latch.countDown();\n+                request(Long.MAX_VALUE-1);\n+            }});\n+        assertTrue(latch.await(10, TimeUnit.SECONDS));\n+    }\n \n }",
    "output": "Add request overflow check for combineLatest"
  },
  {
    "input": "diff --git a/src/main/java/rx/Scheduler.java b/src/main/java/rx/Scheduler.java\n--- a/src/main/java/rx/Scheduler.java\n+++ b/src/main/java/rx/Scheduler.java\n@@ -20,7 +20,6 @@\n import rx.functions.Action0;\n import rx.schedulers.Schedulers;\n import rx.subscriptions.MultipleAssignmentSubscription;\n-import rx.subscriptions.SerialSubscription;\n \n /**\n  * A {@code Scheduler} is an object that schedules units of work. You can find common implementations of this\n@@ -124,7 +123,7 @@ public void call() {\n                     }\n                 }\n             };\n-            SerialSubscription s = new SerialSubscription();\n+            MultipleAssignmentSubscription s = new MultipleAssignmentSubscription();\n             // Should call `mas.set` before `schedule`, or the new Subscription may replace the old one.\n             mas.set(s);\n             s.set(schedule(recursiveAction, initialDelay, unit));",
    "output": "Use MultipleAssignmentSubscription to save an import"
  },
  {
    "input": "diff --git a/src/main/java/rx/Scheduler.java b/src/main/java/rx/Scheduler.java\n--- a/src/main/java/rx/Scheduler.java\n+++ b/src/main/java/rx/Scheduler.java\n@@ -20,6 +20,7 @@\n import rx.functions.Action0;\n import rx.schedulers.Schedulers;\n import rx.subscriptions.MultipleAssignmentSubscription;\n+import rx.subscriptions.SerialSubscription;\n \n /**\n  * A {@code Scheduler} is an object that schedules units of work. You can find common implementations of this\n@@ -119,11 +120,17 @@ public void call() {\n                     if (!mas.isUnsubscribed()) {\n                         action.call();\n                         long nextTick = startInNanos + (++count * periodInNanos);\n-                        mas.set(schedule(this, nextTick - TimeUnit.MILLISECONDS.toNanos(now()), TimeUnit.NANOSECONDS));\n+                        SerialSubscription s = new SerialSubscription();\n+                        // Should call `mas.set` before `schedule`, or the new Subscription may replace the old one.\n+                        mas.set(s);\n+                        s.set(schedule(this, nextTick - TimeUnit.MILLISECONDS.toNanos(now()), TimeUnit.NANOSECONDS));\n                     }\n                 }\n             };\n-            mas.set(schedule(recursiveAction, initialDelay, unit));\n+            SerialSubscription s = new SerialSubscription();\n+            // Should call `mas.set` before `schedule`, or the new Subscription may replace the old one.\n+            mas.set(s);\n+            s.set(schedule(recursiveAction, initialDelay, unit));\n             return mas;\n         }\n ",
    "output": "Fix a potential memory leak in schedulePeriodically"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -15,13 +15,11 @@\n import java.util.*;\n import java.util.concurrent.*;\n \n-import rx.annotations.Beta;\n-import rx.annotations.Experimental;\n+import rx.annotations.*;\n import rx.exceptions.*;\n import rx.functions.*;\n import rx.internal.operators.*;\n-import rx.internal.util.ScalarSynchronousObservable;\n-import rx.internal.util.UtilityFunctions;\n+import rx.internal.util.*;\n import rx.observables.*;\n import rx.observers.SafeSubscriber;\n import rx.plugins.*;\n@@ -1031,6 +1029,14 @@ public final static <T> Observable<T> defer(Func0<Observable<T>> observableFacto\n         return create(new OnSubscribeDefer<T>(observableFactory));\n     }\n \n+    /** An empty observable which just emits onCompleted to any subscriber. */\n+    private static final Observable<Object> EMPTY = create(new OnSubscribe<Object>() {\n+        @Override\n+        public void call(Subscriber<? super Object> t1) {\n+            t1.onCompleted();\n+        }\n+    });\n+    \n     /**\n      * Returns an Observable that emits no items to the {@link Observer} and immediately invokes its\n      * {@link Observer#onCompleted onCompleted} method.\n@@ -1047,8 +1053,9 @@ public final static <T> Observable<T> defer(Func0<Observable<T>> observableFacto\n      *         {@link Observer}'s {@link Observer#onCompleted() onCompleted} method\n      * @see <a href=\"http://reactivex.io/documentation/operators/empty-never-throw.html\">ReactiveX operators documentation: Empty</a>\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public final static <T> Observable<T> empty() {\n-        return from(Collections.<T>emptyList());\n+        return (Observable<T>)EMPTY;\n     }\n \n     /**\n\ndiff --git a/src/test/java/rx/ObservableTests.java b/src/test/java/rx/ObservableTests.java\n--- a/src/test/java/rx/ObservableTests.java\n+++ b/src/test/java/rx/ObservableTests.java\n@@ -1116,4 +1116,17 @@ public void testErrorThrownIssue1685() {\n         System.out.println(\"Done\");\n     }\n \n+    @Test\n+    public void testEmptyIdentity() {\n+        assertEquals(Observable.empty(), Observable.empty());\n+    }\n+    \n+    @Test\n+    public void testEmptyIsEmpty() {\n+        Observable.<Integer>empty().subscribe(w);\n+        \n+        verify(w).onCompleted();\n+        verify(w, never()).onNext(any(Integer.class));\n+        verify(w, never()).onError(any(Throwable.class));\n+    }\n }",
    "output": "Change empty into a stateless constant observable"
  },
  {
    "input": "diff --git a/src/main/java/rx/exceptions/Exceptions.java b/src/main/java/rx/exceptions/Exceptions.java\n--- a/src/main/java/rx/exceptions/Exceptions.java\n+++ b/src/main/java/rx/exceptions/Exceptions.java\n@@ -15,7 +15,11 @@\n  */\n package rx.exceptions;\n \n-import java.util.*;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import rx.annotations.Experimental;\n \n /**\n  * @warn javadoc class description missing\n@@ -26,11 +30,26 @@ private Exceptions() {\n     }\n \n     /**\n-     * @warn javadoc missing\n+     * Convenience method to throw a {@code RuntimeException} and {@code Error} directly\n+     * or wrap any other exception type into a {@code RuntimeException}.\n+     * @param t the exception to throw directly or wrapped\n      * @return because {@code propagate} itself throws an exception or error, this is a sort of phantom return\n      *         value; {@code propagate} does not actually return anything\n      */\n     public static RuntimeException propagate(Throwable t) {\n+        return propagate(t, null);\n+    }\n+    /**\n+     * Convenience method to throw a {@code RuntimeException} and {@code Error} directly\n+     * or wrap any other exception type into a {@code RuntimeException} with an optional custom message.\n+     * @param t the exception to throw directly or wrapped\n+     * @param message the optional custom message to set up the RuntimeException thrown\n+     * in case {@code t} is a checked exception.\n+     * @return because {@code propagate} itself throws an exception or error, this is a sort of phantom return\n+     *         value; {@code propagate} does not actually return anything\n+     */\n+    @Experimental\n+    public static RuntimeException propagate(Throwable t, String message) {\n         /*\n          * The return type of RuntimeException is a trick for code to be like this:\n          * \n@@ -44,7 +63,7 @@ public static RuntimeException propagate(Throwable t) {\n         } else if (t instanceof Error) {\n             throw (Error) t;\n         } else {\n-            throw new RuntimeException(t);\n+            throw new RuntimeException(message, t);\n         }\n     }\n \n@@ -156,19 +175,12 @@ public static Throwable getFinalCause(Throwable e) {\n      * @param whileText the circumstance string to be appended to the thrown CompositeException, inserted after\n      * the sentences \"Exception\" and \"Multiple exceptions\".\n      */\n+    @Experimental\n     public static void throwIfAny(Collection<? extends Throwable> exceptions, String whileText) {\n         if (exceptions != null && !exceptions.isEmpty()) {\n             if (exceptions.size() == 1) {\n                 Throwable t = exceptions.iterator().next();\n-                if (t instanceof RuntimeException) {\n-                    throw (RuntimeException) t;\n-                } else\n-                if (t instanceof Error) {\n-                    throw (Error) t;\n-                } else {\n-                    throw new CompositeException(\n-                            \"Exception\" + whileText, exceptions);\n-                }\n+                throw propagate(t, \"Exception\" + whileText);\n             } else {\n                 throw new CompositeException(\n                         \"Multiple exceptions\" + whileText, exceptions);",
    "output": "Add experimental annotation, using propagate"
  },
  {
    "input": "diff --git a/src/main/java/rx/schedulers/EventLoopsScheduler.java b/src/main/java/rx/schedulers/EventLoopsScheduler.java\n--- a/src/main/java/rx/schedulers/EventLoopsScheduler.java\n+++ b/src/main/java/rx/schedulers/EventLoopsScheduler.java\n@@ -35,7 +35,7 @@\n      * Key to setting the maximum number of computation scheduler threads.\n      * Zero or less is interpreted as use available. Capped by available.\n      */\n-    static final String KEY_MAX_THREADS = \"io.reactivex.rxjava.scheduler.max-computation-threads\";\n+    static final String KEY_MAX_THREADS = \"rx.scheduler.max-computation-threads\";\n     /** The maximum number of computation scheduler threads. */\n     static final int MAX_THREADS;\n     static {",
    "output": "Change system-parameter naming"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/schedulers/NewThreadWorker.java b/src/main/java/rx/internal/schedulers/NewThreadWorker.java\n--- a/src/main/java/rx/internal/schedulers/NewThreadWorker.java\n+++ b/src/main/java/rx/internal/schedulers/NewThreadWorker.java\n@@ -35,9 +35,9 @@ public class NewThreadWorker extends Scheduler.Worker implements Subscription {\n     private final RxJavaSchedulersHook schedulersHook;\n     volatile boolean isUnsubscribed;\n     /** The purge frequency in milliseconds. */\n-    private static final String FREQUENCY_KEY = \"io.reactivex.rxjava.scheduler.jdk6.purge-frequency-millis\";\n+    private static final String FREQUENCY_KEY = \"rx.scheduler.jdk6.purge-frequency-millis\";\n     /** Force the use of purge (true/false). */\n-    private static final String PURGE_FORCE_KEY = \"io.reactivex.rxjava.scheduler.jdk6.purge-force\";\n+    private static final String PURGE_FORCE_KEY = \"rx.scheduler.jdk6.purge-force\";\n     private static final String PURGE_THREAD_PREFIX = \"RxSchedulerPurge-\";\n     /** Forces the use of purge even if setRemoveOnCancelPolicy is available. */\n     private static final boolean PURGE_FORCE;",
    "output": "Change the naming of the NewThreadWorker's system parameters"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java b/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n--- a/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n+++ b/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n@@ -15,12 +15,11 @@\n  */\n package rx.internal.operators;\n \n-import rx.Observable;\n-import rx.Producer;\n-import rx.Subscriber;\n-\n import java.util.concurrent.atomic.AtomicLong;\n \n+import rx.*;\n+import rx.subscriptions.SerialSubscription;\n+\n /**\n  * If the Observable completes without emitting any items, subscribe to an alternate Observable. Allows for similar\n  * functionality to {@link rx.internal.operators.OperatorDefaultIfEmpty} except instead of one item being emitted when\n@@ -35,8 +34,10 @@ public OperatorSwitchIfEmpty(Observable<T> alternate) {\n \n     @Override\n     public Subscriber<? super T> call(Subscriber<? super T> child) {\n-        final SwitchIfEmptySubscriber parent = new SwitchIfEmptySubscriber(child);\n-        child.add(parent);\n+        final SerialSubscription ssub = new SerialSubscription();\n+        final SwitchIfEmptySubscriber parent = new SwitchIfEmptySubscriber(child, ssub);\n+        ssub.set(parent);\n+        child.add(ssub);\n         return parent;\n     }\n \n@@ -46,9 +47,11 @@ private class SwitchIfEmptySubscriber extends Subscriber<T> {\n         final AtomicLong consumerCapacity = new AtomicLong(0l);\n \n         private final Subscriber<? super T> child;\n+        final SerialSubscription ssub;\n \n-        public SwitchIfEmptySubscriber(Subscriber<? super T> child) {\n+        public SwitchIfEmptySubscriber(Subscriber<? super T> child, final SerialSubscription ssub) {\n             this.child = child;\n+            this.ssub = ssub;\n         }\n \n         @Override\n@@ -69,13 +72,12 @@ public void onCompleted() {\n             if (!empty) {\n                 child.onCompleted();\n             } else if (!child.isUnsubscribed()) {\n-                unsubscribe();\n                 subscribeToAlternate();\n             }\n         }\n \n         private void subscribeToAlternate() {\n-            child.add(alternate.unsafeSubscribe(new Subscriber<T>() {\n+            ssub.set(alternate.unsafeSubscribe(new Subscriber<T>() {\n \n                 @Override\n                 public void setProducer(final Producer producer) {\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java b/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n--- a/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n@@ -15,23 +15,19 @@\n  */\n package rx.internal.operators;\n \n+import static org.junit.Assert.*;\n+\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import org.junit.Test;\n+\n+import rx.*;\n import rx.Observable;\n-import rx.Producer;\n-import rx.Subscriber;\n-import rx.Subscription;\n import rx.functions.Action0;\n+import rx.observers.TestSubscriber;\n import rx.subscriptions.Subscriptions;\n \n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n-\n public class OperatorSwitchIfEmptyTest {\n \n     @Test\n@@ -134,30 +130,31 @@ public void call(final Subscriber<? super Long> subscriber) {\n \n     @Test\n     public void testSwitchRequestAlternativeObservableWithBackpressure() {\n-        final List<Integer> items = new ArrayList<Integer>();\n \n-        Observable.<Integer>empty().switchIfEmpty(Observable.just(1, 2, 3)).subscribe(new Subscriber<Integer>() {\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {\n \n             @Override\n             public void onStart() {\n                 request(1);\n             }\n+        };\n+        Observable.<Integer>empty().switchIfEmpty(Observable.just(1, 2, 3)).subscribe(ts);\n+        \n+        assertEquals(Arrays.asList(1), ts.getOnNextEvents());\n+        ts.assertNoErrors();\n+    }\n+    @Test\n+    public void testBackpressureNoRequest() {\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {\n \n             @Override\n-            public void onCompleted() {\n-\n-            }\n-\n-            @Override\n-            public void onError(Throwable e) {\n-\n-            }\n-\n-            @Override\n-            public void onNext(Integer integer) {\n-                items.add(integer);\n+            public void onStart() {\n+                request(0);\n             }\n-        });\n-        assertEquals(Arrays.asList(1), items);\n+        };\n+        Observable.<Integer>empty().switchIfEmpty(Observable.just(1, 2, 3)).subscribe(ts);\n+        \n+        assertTrue(ts.getOnNextEvents().isEmpty());\n+        ts.assertNoErrors();\n     }\n }\n\\ No newline at end of file",
    "output": "Fix some concerns with the operator"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -7827,21 +7827,21 @@ public final Observable<T> takeWhile(final Func1<? super T, Boolean> predicate)\n     /**\n      * Returns an Observable that first emits items emitted by the source Observable, \n      * checks the specified condition after each item, and\n-     * then completes as soon as this condition is not satisfied.\n+     * then completes if the condition is satisfied.\n      * <p>\n      * The difference between this operator and {@link #takeWhile(Func1)} is that here, the condition is evaluated <b>after</b>\n      * the item was emitted.\n      * \n-     * @param predicate \n+     * @param stopPredicate \n      *            a function that evaluates an item emitted by the source Observable and returns a Boolean\n      * @return an Observable that first emits items emitted by the source Observable, \n      *         checks the specified condition after each item, and\n-     *         then completes as soon as this condition is not satisfied.\n+     *         then completes if the condition is satisfied.\n      * @see Observable#takeWhile(Func1)\n      */\n     @Experimental\n-    public final Observable<T> takeUntil(final Func1<? super T, Boolean> predicate) {\n-        return lift(new OperatorTakeUntilPredicate<T>(predicate));\n+    public final Observable<T> takeUntil(final Func1<? super T, Boolean> stopPredicate) {\n+        return lift(new OperatorTakeUntilPredicate<T>(stopPredicate));\n     }\n     \n     /**\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorTakeUntilPredicate.java b/src/main/java/rx/internal/operators/OperatorTakeUntilPredicate.java\n--- a/src/main/java/rx/internal/operators/OperatorTakeUntilPredicate.java\n+++ b/src/main/java/rx/internal/operators/OperatorTakeUntilPredicate.java\n@@ -40,16 +40,16 @@ private ParentSubscriber(Subscriber<? super T> child) {\n         public void onNext(T args) {\n             child.onNext(args);\n             \n-            boolean doContinue = false;\n+            boolean stop = false;\n             try {\n-                doContinue = predicate.call(args);\n+                stop = stopPredicate.call(args);\n             } catch (Throwable e) {\n                 done = true;\n                 child.onError(e);\n                 unsubscribe();\n                 return;\n             }\n-            if (!doContinue) {\n+            if (stop) {\n                 done = true;\n                 child.onCompleted();\n                 unsubscribe();\n@@ -74,10 +74,10 @@ void downstreamRequest(long n) {\n         }\n     }\n \n-    private final Func1<? super T, Boolean> predicate;\n+    private final Func1<? super T, Boolean> stopPredicate;\n \n-    public OperatorTakeUntilPredicate(final Func1<? super T, Boolean> predicate) {\n-        this.predicate = predicate;\n+    public OperatorTakeUntilPredicate(final Func1<? super T, Boolean> stopPredicate) {\n+        this.stopPredicate = stopPredicate;\n     }\n \n     @Override\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorTakeUntilPredicateTest.java b/src/test/java/rx/internal/operators/OperatorTakeUntilPredicateTest.java\n--- a/src/test/java/rx/internal/operators/OperatorTakeUntilPredicateTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorTakeUntilPredicateTest.java\n@@ -47,7 +47,7 @@ public void takeAll() {\n         @SuppressWarnings(\"unchecked\")\n         Observer<Object> o = mock(Observer.class);\n         \n-        Observable.just(1, 2).takeUntil(UtilityFunctions.alwaysTrue()).subscribe(o);\n+        Observable.just(1, 2).takeUntil(UtilityFunctions.alwaysFalse()).subscribe(o);\n         \n         verify(o).onNext(1);\n         verify(o).onNext(2);\n@@ -59,7 +59,7 @@ public void takeFirst() {\n         @SuppressWarnings(\"unchecked\")\n         Observer<Object> o = mock(Observer.class);\n         \n-        Observable.just(1, 2).takeUntil(UtilityFunctions.alwaysFalse()).subscribe(o);\n+        Observable.just(1, 2).takeUntil(UtilityFunctions.alwaysTrue()).subscribe(o);\n         \n         verify(o).onNext(1);\n         verify(o, never()).onNext(2);\n@@ -74,7 +74,7 @@ public void takeSome() {\n         Observable.just(1, 2, 3).takeUntil(new Func1<Integer, Boolean>() {\n             @Override\n             public Boolean call(Integer t1) {\n-                return t1 < 2;\n+                return t1 == 2;\n             }\n         }).subscribe(o);\n         \n@@ -110,7 +110,7 @@ public void sourceThrows() {\n         Observable.just(1)\n         .concatWith(Observable.<Integer>error(new TestException()))\n         .concatWith(Observable.just(2))\n-        .takeUntil(UtilityFunctions.alwaysTrue()).subscribe(o);\n+        .takeUntil(UtilityFunctions.alwaysFalse()).subscribe(o);\n         \n         verify(o).onNext(1);\n         verify(o, never()).onNext(2);\n@@ -126,7 +126,7 @@ public void onStart() {\n             }\n         };\n         \n-        Observable.range(1, 1000).takeUntil(UtilityFunctions.alwaysTrue()).subscribe(ts);\n+        Observable.range(1, 1000).takeUntil(UtilityFunctions.alwaysFalse()).subscribe(ts);\n         \n         ts.assertNoErrors();\n         ts.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5));",
    "output": "Change predicate to stopPredicate: stops on becoming true"
  },
  {
    "input": "diff --git a/src/perf/java/rx/subscriptions/CompositeSubscriptionPerf.java b/src/perf/java/rx/subscriptions/CompositeSubscriptionPerf.java\n--- a/src/perf/java/rx/subscriptions/CompositeSubscriptionPerf.java\n+++ b/src/perf/java/rx/subscriptions/CompositeSubscriptionPerf.java\n@@ -18,14 +18,8 @@\n \n import java.util.concurrent.TimeUnit;\n \n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n \n import rx.Subscription;\n \n@@ -73,26 +67,28 @@ public void addRemove(TheState state) {\n         \n         for (int i = state.loop; i > 0; i--) {\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.add(state.values[j]);\n+                csub.add(values[j]);\n             }\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.remove(state.values[j]);\n+                csub.remove(values[j]);\n             }\n         }\n     }\n     @Benchmark\n-    public void addRemoveLocal(TheState state) {\n+    public void addRemoveLocal(TheState state, Blackhole bh) {\n         CompositeSubscription csub = new CompositeSubscription();\n         Subscription[] values = state.values;\n         \n         for (int i = state.loop; i > 0; i--) {\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.add(state.values[j]);\n+                csub.add(values[j]);\n             }\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.remove(state.values[j]);\n+                csub.remove(values[j]);\n             }\n         }\n+        \n+        bh.consume(csub);\n     }\n     @Benchmark\n     public void addClear(TheState state) {\n@@ -101,21 +97,22 @@ public void addClear(TheState state) {\n         \n         for (int i = state.loop; i > 0; i--) {\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.add(state.values[j]);\n+                csub.add(values[j]);\n             }\n             csub.clear();\n         }\n     }\n     @Benchmark\n-    public void addClearLocal(TheState state) {\n+    public void addClearLocal(TheState state, Blackhole bh) {\n         CompositeSubscription csub = new CompositeSubscription();\n         Subscription[] values = state.values;\n         \n         for (int i = state.loop; i > 0; i--) {\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.add(state.values[j]);\n+                csub.add(values[j]);\n             }\n             csub.clear();\n         }\n+        bh.consume(csub);\n     }\n }\n\ndiff --git a/src/perf/java/rx/subscriptions/MultipleAssignmentSubscriptionPerf.java b/src/perf/java/rx/subscriptions/MultipleAssignmentSubscriptionPerf.java\n--- a/src/perf/java/rx/subscriptions/MultipleAssignmentSubscriptionPerf.java\n+++ b/src/perf/java/rx/subscriptions/MultipleAssignmentSubscriptionPerf.java\n@@ -18,14 +18,8 @@\n \n import java.util.concurrent.TimeUnit;\n \n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n \n import rx.Subscription;\n \n@@ -73,19 +67,20 @@ public void add(TheState state) {\n         \n         for (int i = state.loop; i > 0; i--) {\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.set(state.values[j]);\n+                csub.set(values[j]);\n             }\n         }\n     }\n     @Benchmark\n-    public void addLocal(TheState state) {\n+    public void addLocal(TheState state, Blackhole bh) {\n         MultipleAssignmentSubscription csub = new MultipleAssignmentSubscription();\n         Subscription[] values = state.values;\n         \n         for (int i = state.loop; i > 0; i--) {\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.set(state.values[j]);\n+                csub.set(values[j]);\n             }\n         }\n+        bh.consume(csub);\n     }\n }\n\ndiff --git a/src/perf/java/rx/subscriptions/SerialSubscriptionPerf.java b/src/perf/java/rx/subscriptions/SerialSubscriptionPerf.java\n--- a/src/perf/java/rx/subscriptions/SerialSubscriptionPerf.java\n+++ b/src/perf/java/rx/subscriptions/SerialSubscriptionPerf.java\n@@ -18,14 +18,8 @@\n \n import java.util.concurrent.TimeUnit;\n \n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n \n import rx.Subscription;\n \n@@ -73,19 +67,20 @@ public void add(TheState state) {\n         \n         for (int i = state.loop; i > 0; i--) {\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.set(state.values[j]);\n+                csub.set(values[j]);\n             }\n         }\n     }\n     @Benchmark\n-    public void addLocal(TheState state) {\n+    public void addLocal(TheState state, Blackhole bh) {\n         SerialSubscription csub = new SerialSubscription();\n         Subscription[] values = state.values;\n         \n         for (int i = state.loop; i > 0; i--) {\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.set(state.values[j]);\n+                csub.set(values[j]);\n             }\n         }\n+        bh.consume(csub);\n     }\n }\n\ndiff --git a/src/perf/java/rx/subscriptions/SubscriptionListPerf.java b/src/perf/java/rx/subscriptions/SubscriptionListPerf.java\n--- a/src/perf/java/rx/subscriptions/SubscriptionListPerf.java\n+++ b/src/perf/java/rx/subscriptions/SubscriptionListPerf.java\n@@ -18,14 +18,8 @@\n \n import java.util.concurrent.TimeUnit;\n \n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n \n import rx.Subscription;\n import rx.internal.util.SubscriptionList;\n@@ -74,21 +68,22 @@ public void addClear(TheState state) {\n         \n         for (int i = state.loop; i > 0; i--) {\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.add(state.values[j]);\n+                csub.add(values[j]);\n             }\n             csub.clear();\n         }\n     }\n     @Benchmark\n-    public void addClearLocal(TheState state) {\n+    public void addClearLocal(TheState state, Blackhole bh) {\n         SubscriptionList csub = new SubscriptionList();\n         Subscription[] values = state.values;\n         \n         for (int i = state.loop; i > 0; i--) {\n             for (int j = values.length - 1; j >= 0; j--) {\n-                csub.add(state.values[j]);\n+                csub.add(values[j]);\n             }\n             csub.clear();\n         }\n+        bh.consume(csub);\n     }\n }",
    "output": "Fix local variables, added blackhole to *Local benchmarks"
  },
  {
    "input": "diff --git a/src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java b/src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java\n--- a/src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java\n+++ b/src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java\n@@ -270,6 +270,13 @@ public void call() {\n         s.assertNoErrors();\n     }\n \n+    @Test\n+    public void testConnectUnsubscribeRaceConditionLoop() throws InterruptedException {\n+        for (int i = 0; i < 1000; i++) {\n+            testConnectUnsubscribeRaceCondition();\n+        }\n+    }\n+    \n     @Test\n     public void testConnectUnsubscribeRaceCondition() throws InterruptedException {\n         final AtomicInteger subUnsubCount = new AtomicInteger();\n@@ -295,12 +302,14 @@ public void call() {\n                 });\n \n         TestSubscriber<Long> s = new TestSubscriber<Long>();\n-        o.publish().refCount().subscribeOn(Schedulers.newThread()).subscribe(s);\n+        \n+        o.publish().refCount().subscribeOn(Schedulers.computation()).subscribe(s);\n         System.out.println(\"send unsubscribe\");\n         // now immediately unsubscribe while subscribeOn is racing to subscribe\n         s.unsubscribe();\n         // this generally will mean it won't even subscribe as it is already unsubscribed by the time connect() gets scheduled\n-\n+        // give time to the counter to update\n+        Thread.sleep(1);\n         // either we subscribed and then unsubscribed, or we didn't ever even subscribe\n         assertEquals(0, subUnsubCount.get());\n ",
    "output": "Fix race in testConnectUnsubscribeRaceCondition()"
  },
  {
    "input": "diff --git a/src/main/java/rx/schedulers/EventLoopsScheduler.java b/src/main/java/rx/schedulers/EventLoopsScheduler.java\n--- a/src/main/java/rx/schedulers/EventLoopsScheduler.java\n+++ b/src/main/java/rx/schedulers/EventLoopsScheduler.java\n@@ -45,7 +45,7 @@\n         if (maxThreads <= 0 || maxThreads > ncpu) {\n             max = ncpu;\n         } else {\n-            max =maxThreads;\n+            max = maxThreads;\n         }\n         MAX_THREADS = max;\n     }",
    "output": "Fix typo"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/util/unsafe/SpscArrayQueue.java b/src/main/java/rx/internal/util/unsafe/SpscArrayQueue.java\n--- a/src/main/java/rx/internal/util/unsafe/SpscArrayQueue.java\n+++ b/src/main/java/rx/internal/util/unsafe/SpscArrayQueue.java\n@@ -118,20 +118,9 @@ public SpscArrayQueue(final int capacity) {\n      */\n     @Override\n     public boolean offer(final E e) {\n-//        if (null == e) {\n-//            throw new NullPointerException(\"Null is not a valid element\");\n-//        }\n         // local load of field to avoid repeated loads after volatile reads\n         final E[] lElementBuffer = buffer;\n         final long offset = calcElementOffset(producerIndex);\n-//        if (producerIndex >= producerLookAhead) {\n-//            if (null == lvElement(lElementBuffer, calcElementOffset(producerIndex + lookAheadStep))) {// LoadLoad\n-//                producerLookAhead = producerIndex + lookAheadStep;\n-//            }\n-//            else if (null != lvElement(lElementBuffer, offset)){\n-//                return false;\n-//            }\n-//        }\n         if (null != lvElement(lElementBuffer, offset)){\n             return false;\n         }",
    "output": "Remove commented-out code"
  },
  {
    "input": "diff --git a/src/main/java/rx/exceptions/OnErrorThrowable.java b/src/main/java/rx/exceptions/OnErrorThrowable.java\n--- a/src/main/java/rx/exceptions/OnErrorThrowable.java\n+++ b/src/main/java/rx/exceptions/OnErrorThrowable.java\n@@ -148,7 +148,7 @@ private static String renderValue(Object value){\n                 return (String) value;\n             }\n             if (value instanceof Enum) {\n-                return ((Enum) value).name();\n+                return ((Enum<?>) value).name();\n             }\n             return value.getClass().getName() + \".class\";\n         }\n\ndiff --git a/src/main/java/rx/functions/Actions.java b/src/main/java/rx/functions/Actions.java\n--- a/src/main/java/rx/functions/Actions.java\n+++ b/src/main/java/rx/functions/Actions.java\n@@ -15,8 +15,6 @@\n  */\n package rx.functions;\n \n-import rx.Observer;\n-\n /**\n  * Utility class for the Action interfaces.\n  */\n\ndiff --git a/src/main/java/rx/internal/operators/BlockingOperatorNext.java b/src/main/java/rx/internal/operators/BlockingOperatorNext.java\n--- a/src/main/java/rx/internal/operators/BlockingOperatorNext.java\n+++ b/src/main/java/rx/internal/operators/BlockingOperatorNext.java\n@@ -147,6 +147,7 @@ public void remove() {\n \n     private static class NextObserver<T> extends Subscriber<Notification<? extends T>> {\n         private final BlockingQueue<Notification<? extends T>> buf = new ArrayBlockingQueue<Notification<? extends T>>(1);\n+        @SuppressWarnings(\"unused\")\n         volatile int waiting;\n         @SuppressWarnings(\"rawtypes\")\n         static final AtomicIntegerFieldUpdater<NextObserver> WAITING_UPDATER\n\ndiff --git a/src/main/java/rx/internal/operators/OnSubscribeCache.java b/src/main/java/rx/internal/operators/OnSubscribeCache.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeCache.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeCache.java\n@@ -20,7 +20,6 @@\n import rx.Observable;\n import rx.Observable.OnSubscribe;\n import rx.Subscriber;\n-import rx.observers.Subscribers;\n import rx.subjects.ReplaySubject;\n import rx.subjects.Subject;\n \n\ndiff --git a/src/main/java/rx/internal/operators/OperatorGroupBy.java b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n--- a/src/main/java/rx/internal/operators/OperatorGroupBy.java\n+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n@@ -15,12 +15,10 @@\n  */\n package rx.internal.operators;\n \n-import java.util.Map;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n@@ -206,6 +204,7 @@ private Object groupedKey(K key) {\n             return key == null ? NULL_KEY : key;\n         }\n \n+        @SuppressWarnings(\"unchecked\")\n         private K getKey(Object groupedKey) {\n             return groupedKey == NULL_KEY ? null : (K) groupedKey;\n         }\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorObserveOn.java b/src/main/java/rx/internal/operators/OperatorObserveOn.java\n--- a/src/main/java/rx/internal/operators/OperatorObserveOn.java\n+++ b/src/main/java/rx/internal/operators/OperatorObserveOn.java\n@@ -72,10 +72,12 @@ private static final class ObserveOnSubscriber<T> extends Subscriber<T> {\n         private boolean completed = false;\n         private boolean failure = false;\n \n+        @SuppressWarnings(\"unused\")\n         private volatile long requested = 0;\n         @SuppressWarnings(\"rawtypes\")\n         static final AtomicLongFieldUpdater<ObserveOnSubscriber> REQUESTED = AtomicLongFieldUpdater.newUpdater(ObserveOnSubscriber.class, \"requested\");\n \n+        @SuppressWarnings(\"unused\")\n         volatile long counter;\n         @SuppressWarnings(\"rawtypes\")\n         static final AtomicLongFieldUpdater<ObserveOnSubscriber> COUNTER_UPDATER = AtomicLongFieldUpdater.newUpdater(ObserveOnSubscriber.class, \"counter\");\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorPublish.java b/src/main/java/rx/internal/operators/OperatorPublish.java\n--- a/src/main/java/rx/internal/operators/OperatorPublish.java\n+++ b/src/main/java/rx/internal/operators/OperatorPublish.java\n@@ -16,7 +16,6 @@\n package rx.internal.operators;\n \n import java.util.ArrayList;\n-import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -266,6 +265,7 @@ public synchronized void removeSubscriber(Subscriber<? super T> subscriber) {\n             resetAfterSubscriberUpdate();\n         }\n \n+        @SuppressWarnings(\"unchecked\")\n         private long resetAfterSubscriberUpdate() {\n             subscribers = new Subscriber[ss.size()];\n             int i = 0;\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorScan.java b/src/main/java/rx/internal/operators/OperatorScan.java\n--- a/src/main/java/rx/internal/operators/OperatorScan.java\n+++ b/src/main/java/rx/internal/operators/OperatorScan.java\n@@ -23,7 +23,6 @@\n import rx.exceptions.OnErrorThrowable;\n import rx.functions.Func0;\n import rx.functions.Func2;\n-import rx.internal.util.UtilityFunctions;\n \n /**\n  * Returns an Observable that applies a function to the first item emitted by a source Observable, then feeds\n\ndiff --git a/src/main/java/rx/observables/BlockingObservable.java b/src/main/java/rx/observables/BlockingObservable.java\n--- a/src/main/java/rx/observables/BlockingObservable.java\n+++ b/src/main/java/rx/observables/BlockingObservable.java\n@@ -26,7 +26,6 @@\n import rx.Subscription;\n import rx.functions.Action1;\n import rx.functions.Func1;\n-import rx.functions.Functions;\n import rx.internal.operators.BlockingOperatorLatest;\n import rx.internal.operators.BlockingOperatorMostRecent;\n import rx.internal.operators.BlockingOperatorNext;\n\ndiff --git a/src/main/java/rx/schedulers/CachedThreadScheduler.java b/src/main/java/rx/schedulers/CachedThreadScheduler.java\n--- a/src/main/java/rx/schedulers/CachedThreadScheduler.java\n+++ b/src/main/java/rx/schedulers/CachedThreadScheduler.java\n@@ -110,6 +110,7 @@ public Worker createWorker() {\n     private static final class EventLoopWorker extends Scheduler.Worker {\n         private final CompositeSubscription innerSubscription = new CompositeSubscription();\n         private final ThreadWorker threadWorker;\n+        @SuppressWarnings(\"unused\")\n         volatile int once;\n         static final AtomicIntegerFieldUpdater<EventLoopWorker> ONCE_UPDATER\n                 = AtomicIntegerFieldUpdater.newUpdater(EventLoopWorker.class, \"once\");\n\ndiff --git a/src/main/java/rx/schedulers/TrampolineScheduler.java b/src/main/java/rx/schedulers/TrampolineScheduler.java\n--- a/src/main/java/rx/schedulers/TrampolineScheduler.java\n+++ b/src/main/java/rx/schedulers/TrampolineScheduler.java\n@@ -47,7 +47,8 @@ public Worker createWorker() {\n \n     private static class InnerCurrentThreadScheduler extends Scheduler.Worker implements Subscription {\n \n-        private static final AtomicIntegerFieldUpdater COUNTER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(InnerCurrentThreadScheduler.class, \"counter\");\n+        private static final AtomicIntegerFieldUpdater<InnerCurrentThreadScheduler> COUNTER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(InnerCurrentThreadScheduler.class, \"counter\");\n+        @SuppressWarnings(\"unused\")\n         volatile int counter;\n         private final PriorityBlockingQueue<TimedAction> queue = new PriorityBlockingQueue<TimedAction>();\n         private final BooleanSubscription innerSubscription = new BooleanSubscription();\n\ndiff --git a/src/main/java/rx/subjects/TestSubject.java b/src/main/java/rx/subjects/TestSubject.java\n--- a/src/main/java/rx/subjects/TestSubject.java\n+++ b/src/main/java/rx/subjects/TestSubject.java\n@@ -17,7 +17,6 @@\n \n import java.util.concurrent.TimeUnit;\n \n-import rx.Observable;\n import rx.Observer;\n import rx.Scheduler;\n import rx.functions.Action0;\n\ndiff --git a/src/main/java/rx/subscriptions/Subscriptions.java b/src/main/java/rx/subscriptions/Subscriptions.java\n--- a/src/main/java/rx/subscriptions/Subscriptions.java\n+++ b/src/main/java/rx/subscriptions/Subscriptions.java\n@@ -16,12 +16,10 @@\n package rx.subscriptions;\n \n import java.util.concurrent.Future;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n import rx.Subscription;\n import rx.annotations.Experimental;\n import rx.functions.Action0;\n-import rx.functions.Actions;\n \n /**\n  * Helper methods and utilities for creating and working with {@link Subscription} objects",
    "output": "Remove unnecessary imports, add missing generic types, add SuppressWarnings(unchecked)"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java b/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java\n--- a/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java\n+++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java\n@@ -126,7 +126,7 @@ public Object peek() {\n         @Override\n         public Object poll() {\n             Object value = queue.poll();\n-            if (capacity != null) {\n+            if (capacity != null && value != null) {\n                 capacity.incrementAndGet();\n             }\n             return value;",
    "output": "Add value null check"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java b/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java\n--- a/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java\n+++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java\n@@ -125,7 +125,11 @@ public Object peek() {\n         }\n         @Override\n         public Object poll() {\n-            return queue.poll();\n+            Object value = queue.poll();\n+            if (capacity != null) {\n+                capacity.incrementAndGet();\n+            }\n+            return value;\n         }\n         \n         private boolean assertCapacity() {",
    "output": "Add capacity increase on poll"
  },
  {
    "input": "diff --git a/src/main/java/rx/schedulers/TrampolineScheduler.java b/src/main/java/rx/schedulers/TrampolineScheduler.java\n--- a/src/main/java/rx/schedulers/TrampolineScheduler.java\n+++ b/src/main/java/rx/schedulers/TrampolineScheduler.java\n@@ -75,7 +75,7 @@ private Subscription enqueue(Action0 action, long execTime) {\n                 do {\n                     final TimedAction polled = queue.poll();\n                     if (polled != null) {\n-                      polled.action.call();\n+                        polled.action.call();\n                     }\n                 } while (wip.decrementAndGet() > 0);\n                 return Subscriptions.unsubscribed();",
    "output": "Fix indent"
  },
  {
    "input": "diff --git a/src/main/java/rx/schedulers/TrampolineScheduler.java b/src/main/java/rx/schedulers/TrampolineScheduler.java\n--- a/src/main/java/rx/schedulers/TrampolineScheduler.java\n+++ b/src/main/java/rx/schedulers/TrampolineScheduler.java\n@@ -15,7 +15,7 @@\n  */\n package rx.schedulers;\n \n-import java.util.PriorityQueue;\n+import java.util.concurrent.PriorityBlockingQueue;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n@@ -45,14 +45,12 @@ public Worker createWorker() {\n     /* package accessible for unit tests */TrampolineScheduler() {\n     }\n \n-    volatile int counter;\n-    static final AtomicIntegerFieldUpdater<TrampolineScheduler> COUNTER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(TrampolineScheduler.class, \"counter\");\n-\n     private class InnerCurrentThreadScheduler extends Scheduler.Worker implements Subscription {\n \n-        final PriorityQueue<TimedAction> queue = new PriorityQueue<TimedAction>();\n+        private final PriorityBlockingQueue<TimedAction> queue = new PriorityBlockingQueue<TimedAction>();\n         private final BooleanSubscription innerSubscription = new BooleanSubscription();\n         private final AtomicInteger wip = new AtomicInteger();\n+        private final AtomicInteger counter = new AtomicInteger();\n \n         @Override\n         public Subscription schedule(Action0 action) {\n@@ -70,18 +68,15 @@ private Subscription enqueue(Action0 action, long execTime) {\n             if (innerSubscription.isUnsubscribed()) {\n                 return Subscriptions.unsubscribed();\n             }\n-            final TimedAction timedAction = new TimedAction(action, execTime, COUNTER_UPDATER.incrementAndGet(TrampolineScheduler.this));\n-            synchronized (queue) {\n-                queue.add(timedAction);\n-            }\n+            final TimedAction timedAction = new TimedAction(action, execTime, counter.incrementAndGet());\n+            queue.add(timedAction);\n \n             if (wip.getAndIncrement() == 0) {\n                 do {\n-                    TimedAction polled;\n-                    synchronized (queue) {\n-                        polled = queue.poll();\n+                    final TimedAction polled = queue.poll();\n+                    if (polled != null) {\n+                      polled.action.call();\n                     }\n-                    polled.action.call();\n                 } while (wip.decrementAndGet() > 0);\n                 return Subscriptions.unsubscribed();\n             } else {\n@@ -90,9 +85,7 @@ private Subscription enqueue(Action0 action, long execTime) {\n \n                     @Override\n                     public void call() {\n-                        synchronized (queue) {\n-                            queue.remove(timedAction);\n-                        }\n+                        queue.remove(timedAction);\n                     }\n \n                 });",
    "output": "Use a PBQ instead of a PQ on the trampoline. Moves counter inside to worker class and ditches the separate field updater"
  },
  {
    "input": "diff --git a/src/test/java/rx/BackpressureTests.java b/src/test/java/rx/BackpressureTests.java\n--- a/src/test/java/rx/BackpressureTests.java\n+++ b/src/test/java/rx/BackpressureTests.java\n@@ -549,14 +549,16 @@ public void call(final Subscriber<? super Integer> s) {\n     }\n \n     final static Func1<Integer, Integer> SLOW_PASS_THRU = new Func1<Integer, Integer>() {\n-\n+        volatile int sink;\n         @Override\n         public Integer call(Integer t1) {\n             // be slow ... but faster than Thread.sleep(1)\n             String t = \"\";\n+            int s = sink;\n             for (int i = 1000; i >= 0; i--) {\n-                t = String.valueOf(i + t.hashCode());\n+                t = String.valueOf(i + t.hashCode() + s);\n             }\n+            sink = t.hashCode();\n             return t1;\n         }\n ",
    "output": "Fix SLOW_PASS_THRU to prevent JIT optimizing it away"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorWindowWithTime.java b/src/main/java/rx/internal/operators/OperatorWindowWithTime.java\n--- a/src/main/java/rx/internal/operators/OperatorWindowWithTime.java\n+++ b/src/main/java/rx/internal/operators/OperatorWindowWithTime.java\n@@ -33,8 +33,8 @@\n \n /**\n  * Creates windows of values into the source sequence with timed window creation, length and size bounds.\n- * If timespan == timeshift, windows are non-overlapping but may not be continuous if size number of items were already\n- * emitted. If more items arrive after the window has reached its size bound, those items are dropped.\n+ * If timespan == timeshift, windows are non-overlapping but always continuous, i.e., when the size bound is reached, a new\n+ * window is opened.\n  *\n  * <p>Note that this conforms the Rx.NET behavior, but does not match former RxJava\n  * behavior, which operated as a regular buffer and mapped its lists to Observables.</p>\n@@ -205,17 +205,17 @@ void replaceSubject() {\n         }\n         void emitValue(T t) {\n             State<T> s = state;\n-            \n-            if (s.consumer != null) {\n-                s.consumer.onNext(t);\n-                if (s.count == size) {\n-                    s.consumer.onCompleted();\n-                    s = s.clear();\n-                } else {\n-                    s = s.next();\n-                }\n+            if (s.consumer == null) {\n+                replaceSubject();\n+                s = state;\n+            }\n+            s.consumer.onNext(t);\n+            if (s.count == size - 1) {\n+                s.consumer.onCompleted();\n+                s = s.clear();\n+            } else {\n+                s = s.next();\n             }\n-            \n             state = s;\n         }\n         \n\ndiff --git a/src/test/java/rx/internal/operators/OperatorWindowWithTimeTest.java b/src/test/java/rx/internal/operators/OperatorWindowWithTimeTest.java\n--- a/src/test/java/rx/internal/operators/OperatorWindowWithTimeTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorWindowWithTimeTest.java\n@@ -15,22 +15,17 @@\n  */\n package rx.internal.operators;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.*;\n import java.util.concurrent.TimeUnit;\n \n-import org.junit.Before;\n-import org.junit.Test;\n+import org.junit.*;\n \n+import rx.*;\n import rx.Observable;\n import rx.Observer;\n-import rx.Scheduler;\n-import rx.Subscriber;\n-import rx.functions.Action0;\n-import rx.functions.Action1;\n+import rx.functions.*;\n import rx.schedulers.TestScheduler;\n \n public class OperatorWindowWithTimeTest {\n@@ -132,14 +127,14 @@ public void call() {\n         }, delay, TimeUnit.MILLISECONDS);\n     }\n \n-    private Action1<Observable<String>> observeWindow(final List<String> list, final List<List<String>> lists) {\n-        return new Action1<Observable<String>>() {\n+    private <T> Action1<Observable<T>> observeWindow(final List<T> list, final List<List<T>> lists) {\n+        return new Action1<Observable<T>>() {\n             @Override\n-            public void call(Observable<String> stringObservable) {\n-                stringObservable.subscribe(new Observer<String>() {\n+            public void call(Observable<T> stringObservable) {\n+                stringObservable.subscribe(new Observer<T>() {\n                     @Override\n                     public void onCompleted() {\n-                        lists.add(new ArrayList<String>(list));\n+                        lists.add(new ArrayList<T>(list));\n                         list.clear();\n                     }\n \n@@ -149,11 +144,31 @@ public void onError(Throwable e) {\n                     }\n \n                     @Override\n-                    public void onNext(String args) {\n+                    public void onNext(T args) {\n                         list.add(args);\n                     }\n                 });\n             }\n         };\n     }\n-}\n\\ No newline at end of file\n+    @Test\n+    public void testExactWindowSize() {\n+        Observable<Observable<Integer>> source = Observable.range(1, 10).window(1, TimeUnit.MINUTES, 3, scheduler);\n+        \n+        final List<Integer> list = new ArrayList<Integer>();\n+        final List<List<Integer>> lists = new ArrayList<List<Integer>>();\n+        \n+        source.subscribe(observeWindow(list, lists));\n+        \n+        assertEquals(4, lists.size());\n+        assertEquals(3, lists.get(0).size());\n+        assertEquals(Arrays.asList(1, 2, 3), lists.get(0));\n+        assertEquals(3, lists.get(1).size());\n+        assertEquals(Arrays.asList(4, 5, 6), lists.get(1));\n+        assertEquals(3, lists.get(2).size());\n+        assertEquals(Arrays.asList(7, 8, 9), lists.get(2));\n+        assertEquals(1, lists.get(3).size());\n+        assertEquals(Arrays.asList(10), lists.get(3));\n+    }\n+    \n+}",
    "output": "Fix off-by-one error and value-drop in the window operator"
  },
  {
    "input": "diff --git a/src/main/java/rx/subjects/AsyncSubject.java b/src/main/java/rx/subjects/AsyncSubject.java\n--- a/src/main/java/rx/subjects/AsyncSubject.java\n+++ b/src/main/java/rx/subjects/AsyncSubject.java\n@@ -19,6 +19,7 @@\n import java.util.List;\n \n import rx.Observer;\n+import rx.annotations.Experimental;\n import rx.exceptions.CompositeException;\n import rx.exceptions.Exceptions;\n import rx.functions.Action1;\n@@ -147,6 +148,7 @@ public boolean hasObservers() {\n      * retrieved by {@code getValue()} may get outdated.\n      * @return true if and only if the subject has some value but not an error\n      */\n+    @Experimental\n     public boolean hasValue() {\n         Object v = lastValue;\n         Object o = state.get();\n@@ -156,6 +158,7 @@ public boolean hasValue() {\n      * Check if the Subject has terminated with an exception.\n      * @return true if the subject has received a throwable through {@code onError}.\n      */\n+    @Experimental\n     public boolean hasThrowable() {\n         Object o = state.get();\n         return nl.isError(o);\n@@ -164,6 +167,7 @@ public boolean hasThrowable() {\n      * Check if the Subject has terminated normally.\n      * @return true if the subject completed normally via {@code onCompleted()}\n      */\n+    @Experimental\n     public boolean hasCompleted() {\n         Object o = state.get();\n         return o != null && !nl.isError(o);\n@@ -177,6 +181,7 @@ public boolean hasCompleted() {\n      * @return the current value or {@code null} if the Subject doesn't have a value,\n      * has terminated with an exception or has an actual {@code null} as a value.\n      */\n+    @Experimental\n     public T getValue() {\n         Object v = lastValue;\n         Object o = state.get();\n@@ -190,6 +195,7 @@ public T getValue() {\n      * @return the Throwable that terminated the Subject or {@code null} if the\n      * subject hasn't terminated yet or it terminated normally.\n      */\n+    @Experimental\n     public Throwable getThrowable() {\n         Object o = state.get();\n         if (nl.isError(o)) {\n\ndiff --git a/src/main/java/rx/subjects/BehaviorSubject.java b/src/main/java/rx/subjects/BehaviorSubject.java\n--- a/src/main/java/rx/subjects/BehaviorSubject.java\n+++ b/src/main/java/rx/subjects/BehaviorSubject.java\n@@ -20,6 +20,7 @@\n import java.util.List;\n \n import rx.Observer;\n+import rx.annotations.Experimental;\n import rx.exceptions.CompositeException;\n import rx.exceptions.Exceptions;\n import rx.functions.Action1;\n@@ -183,6 +184,7 @@ public boolean hasObservers() {\n      * retrieved by {@code getValue()} may get outdated.\n      * @return true if and only if the subject has some value and hasn't terminated yet.\n      */\n+    @Experimental\n     public boolean hasValue() {\n         Object o = state.get();\n         return nl.isNext(o);\n@@ -191,6 +193,7 @@ public boolean hasValue() {\n      * Check if the Subject has terminated with an exception.\n      * @return true if the subject has received a throwable through {@code onError}.\n      */\n+    @Experimental\n     public boolean hasThrowable() {\n         Object o = state.get();\n         return nl.isError(o);\n@@ -199,6 +202,7 @@ public boolean hasThrowable() {\n      * Check if the Subject has terminated normally.\n      * @return true if the subject completed normally via {@code onCompleted()}\n      */\n+    @Experimental\n     public boolean hasCompleted() {\n         Object o = state.get();\n         return nl.isCompleted(o);\n@@ -212,6 +216,7 @@ public boolean hasCompleted() {\n      * @return the current value or {@code null} if the Subject doesn't have a value,\n      * has terminated or has an actual {@code null} as a valid value.\n      */\n+    @Experimental\n     public T getValue() {\n         Object o = state.get();\n         if (nl.isNext(o)) {\n@@ -224,6 +229,7 @@ public T getValue() {\n      * @return the Throwable that terminated the Subject or {@code null} if the\n      * subject hasn't terminated yet or it terminated normally.\n      */\n+    @Experimental\n     public Throwable getThrowable() {\n         Object o = state.get();\n         if (nl.isError(o)) {\n\ndiff --git a/src/main/java/rx/subjects/PublishSubject.java b/src/main/java/rx/subjects/PublishSubject.java\n--- a/src/main/java/rx/subjects/PublishSubject.java\n+++ b/src/main/java/rx/subjects/PublishSubject.java\n@@ -19,6 +19,7 @@\n import java.util.List;\n \n import rx.Observer;\n+import rx.annotations.Experimental;\n import rx.exceptions.CompositeException;\n import rx.exceptions.Exceptions;\n import rx.functions.Action1;\n@@ -131,6 +132,7 @@ public boolean hasObservers() {\n      * Check if the Subject has terminated with an exception.\n      * @return true if the subject has received a throwable through {@code onError}.\n      */\n+    @Experimental\n     public boolean hasThrowable() {\n         Object o = state.get();\n         return nl.isError(o);\n@@ -139,6 +141,7 @@ public boolean hasThrowable() {\n      * Check if the Subject has terminated normally.\n      * @return true if the subject completed normally via {@code onCompleted}\n      */\n+    @Experimental\n     public boolean hasCompleted() {\n         Object o = state.get();\n         return o != null && !nl.isError(o);\n@@ -148,6 +151,7 @@ public boolean hasCompleted() {\n      * @return the Throwable that terminated the Subject or {@code null} if the\n      * subject hasn't terminated yet or it terminated normally.\n      */\n+    @Experimental\n     public Throwable getThrowable() {\n         Object o = state.get();\n         if (nl.isError(o)) {\n\ndiff --git a/src/main/java/rx/subjects/ReplaySubject.java b/src/main/java/rx/subjects/ReplaySubject.java\n--- a/src/main/java/rx/subjects/ReplaySubject.java\n+++ b/src/main/java/rx/subjects/ReplaySubject.java\n@@ -23,6 +23,7 @@\n \n import rx.Observer;\n import rx.Scheduler;\n+import rx.annotations.Experimental;\n import rx.exceptions.CompositeException;\n import rx.exceptions.Exceptions;\n import rx.functions.Action1;\n@@ -1061,6 +1062,7 @@ public void evictFinal(NodeList<Object> list) {\n      * Check if the Subject has terminated with an exception.\n      * @return true if the subject has received a throwable through {@code onError}.\n      */\n+    @Experimental\n     public boolean hasThrowable() {\n         NotificationLite<T> nl = ssm.nl;\n         Object o = ssm.get();\n@@ -1070,6 +1072,7 @@ public boolean hasThrowable() {\n      * Check if the Subject has terminated normally.\n      * @return true if the subject completed normally via {@code onCompleted}\n      */\n+    @Experimental\n     public boolean hasCompleted() {\n         NotificationLite<T> nl = ssm.nl;\n         Object o = ssm.get();\n@@ -1080,6 +1083,7 @@ public boolean hasCompleted() {\n      * @return the Throwable that terminated the Subject or {@code null} if the\n      * subject hasn't terminated yet or it terminated normally.\n      */\n+    @Experimental\n     public Throwable getThrowable() {\n         NotificationLite<T> nl = ssm.nl;\n         Object o = ssm.get();\n@@ -1092,12 +1096,14 @@ public Throwable getThrowable() {\n      * Returns the current number of items (non-terminal events) available for replay.\n      * @return the number of items available\n      */\n+    @Experimental\n     public int size() {\n         return state.size();\n     }\n     /**\n      * @return true if the Subject holds at least one non-terminal event available for replay\n      */\n+    @Experimental\n     public boolean hasAnyValue() {\n         return !state.isEmpty();\n     }\n@@ -1107,6 +1113,7 @@ public boolean hasAnyValue() {\n      * @return returns a snapshot of the currently buffered non-terminal events.\n      */\n     @SuppressWarnings(\"unchecked\")\n+    @Experimental\n     public Object[] getValues() {\n         return state.toArray((T[])EMPTY_ARRAY);\n     }\n@@ -1116,6 +1123,7 @@ public Object[] getValues() {\n      * @param a the array to fill in\n      * @return the array {@code a} if it had enough capacity or a new array containing the available values \n      */\n+    @Experimental\n     public T[] getValues(T[] a) {\n         return state.toArray(a);\n     }",
    "output": "Add experimental annotations"
  },
  {
    "input": "diff --git a/src/main/java/rx/schedulers/TrampolineScheduler.java b/src/main/java/rx/schedulers/TrampolineScheduler.java\n--- a/src/main/java/rx/schedulers/TrampolineScheduler.java\n+++ b/src/main/java/rx/schedulers/TrampolineScheduler.java\n@@ -1,12 +1,12 @@\n /**\n  * Copyright 2014 Netflix, Inc.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -71,14 +71,18 @@ private Subscription enqueue(Action0 action, long execTime) {\n                 return Subscriptions.unsubscribed();\n             }\n             final TimedAction timedAction = new TimedAction(action, execTime, COUNTER_UPDATER.incrementAndGet(TrampolineScheduler.this));\n-            queue.add(timedAction);\n+            synchronized (queue) {\n+                queue.add(timedAction);\n+            }\n \n             if (wip.getAndIncrement() == 0) {\n                 do {\n-                    TimedAction polled = queue.poll();\n-                    // check for null as it could have been unsubscribed and removed\n+                    TimedAction polled;\n+                    synchronized (queue) {\n+                        polled = queue.poll();\n+                    }\n                     if (polled != null) {\n-                        polled.action.call();\n+                      polled.action.call();\n                     }\n                 } while (wip.decrementAndGet() > 0);\n                 return Subscriptions.unsubscribed();\n@@ -88,9 +92,8 @@ private Subscription enqueue(Action0 action, long execTime) {\n \n                     @Override\n                     public void call() {\n-                        PriorityQueue<TimedAction> _q = queue;\n-                        if (_q != null) {\n-                            _q.remove(timedAction);\n+                        synchronized (queue) {\n+                            queue.remove(timedAction);\n                         }\n                     }\n \n@@ -130,7 +133,7 @@ public int compareTo(TimedAction that) {\n             return result;\n         }\n     }\n-    \n+\n     // because I can't use Integer.compare from Java 7\n     private static int compare(int x, int y) {\n         return (x < y) ? -1 : ((x == y) ? 0 : 1);\n\ndiff --git a/src/test/java/rx/schedulers/TrampolineSchedulerTest.java b/src/test/java/rx/schedulers/TrampolineSchedulerTest.java\n--- a/src/test/java/rx/schedulers/TrampolineSchedulerTest.java\n+++ b/src/test/java/rx/schedulers/TrampolineSchedulerTest.java\n@@ -18,13 +18,17 @@\n import static org.junit.Assert.*;\n \n import java.util.*;\n+import java.util.concurrent.TimeUnit;\n \n import org.junit.Test;\n \n import rx.*;\n+import rx.Observer;\n import rx.Scheduler.Worker;\n import rx.Observable;\n import rx.functions.*;\n+import rx.observers.Observers;\n+import rx.observers.TestSubscriber;\n import rx.subscriptions.CompositeSubscription;\n \n public class TrampolineSchedulerTest extends AbstractSchedulerTests {\n@@ -95,6 +99,47 @@ public void call() {\n         }\n     }\n \n+    /**\n+     * This is a regression test for #1702. Concurrent work scheduling that is improperly synchronized can cause an\n+     * action to be added or removed onto the priority queue during a poll, which can result in NPEs during queue\n+     * sifting. While it is difficult to isolate the issue directly, we can easily trigger the behavior by spamming the\n+     * trampoline with enqueue requests from multiple threads concurrently.\n+     */\n+    @Test\n+    public void testTrampolineWorkerHandlesConcurrentScheduling() {\n+        final Worker trampolineWorker = Schedulers.trampoline().createWorker();\n+        final Observer<Subscription> observer = Observers.empty();\n+        final TestSubscriber<Subscription> ts = new TestSubscriber<Subscription>(observer);\n+\n+        // Spam the trampoline with actions.\n+        Observable.range(0, 50)\n+                .flatMap(new Func1<Integer, Observable<Subscription>>() {\n+\n+                    @Override\n+                    public Observable<Subscription> call(Integer count) {\n+                        return Observable.interval(1, TimeUnit.MICROSECONDS).map(\n+                                new Func1<Long, Subscription>() {\n+\n+                                     @Override\n+                                     public Subscription call(Long count) {\n+                                         return trampolineWorker.schedule(new Action0() {\n+\n+                                             @Override\n+                                             public void call() {}\n+\n+                                         });\n+                                     }\n+\n+                                }).limit(100);\n+                    }\n+\n+                })\n+                .subscribeOn(Schedulers.computation())\n+                .subscribe(ts);\n+        ts.awaitTerminalEvent();\n+        ts.assertNoErrors();\n+    }\n+\n     private static Worker doWorkOnNewTrampoline(final String key, final ArrayList<String> workDone) {\n         Worker worker = Schedulers.trampoline().createWorker();\n         worker.schedule(new Action0() {",
    "output": "Fix NPEs reported in ReactiveX#1702 by synchronizing queue. Adds unit test for regression"
  },
  {
    "input": "diff --git a/src/main/java/rx/subscriptions/CompositeSubscription.java b/src/main/java/rx/subscriptions/CompositeSubscription.java\n--- a/src/main/java/rx/subscriptions/CompositeSubscription.java\n+++ b/src/main/java/rx/subscriptions/CompositeSubscription.java\n@@ -1,12 +1,12 @@\n /**\n  * Copyright 2014 Netflix, Inc.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -55,8 +55,8 @@ public synchronized boolean isUnsubscribed() {\n      *          the {@link Subscription} to add\n      */\n     public void add(final Subscription s) {\n-        if (s == null) {\n-            throw new NullPointerException(\"Added Subscription cannot be null.\");\n+        if (s.isUnsubscribed()) {\n+            return;\n         }\n         Subscription unsubscribe = null;\n         synchronized (this) {",
    "output": "Use unsubscribed check instead of a null check"
  },
  {
    "input": "diff --git a/src/main/java/rx/schedulers/TrampolineScheduler.java b/src/main/java/rx/schedulers/TrampolineScheduler.java\n--- a/src/main/java/rx/schedulers/TrampolineScheduler.java\n+++ b/src/main/java/rx/schedulers/TrampolineScheduler.java\n@@ -71,14 +71,17 @@ private Subscription enqueue(Action0 action, long execTime) {\n                 return Subscriptions.unsubscribed();\n             }\n             final TimedAction timedAction = new TimedAction(action, execTime, COUNTER_UPDATER.incrementAndGet(TrampolineScheduler.this));\n-            queue.add(timedAction);\n+            synchronized (queue) {\n+                queue.add(timedAction);\n+            }\n \n             if (wip.getAndIncrement() == 0) {\n                 do {\n-                    TimedAction polled = queue.poll();\n-                    // check for null as it could have been unsubscribed and removed\n-                    if (polled != null) {\n-                        polled.action.call();\n+                    synchronized (queue) {\n+                        if (!queue.isEmpty()) {\n+                            TimedAction polled = queue.poll();\n+                            polled.action.call();\n+                        }\n                     }\n                 } while (wip.decrementAndGet() > 0);\n                 return Subscriptions.unsubscribed();\n@@ -88,9 +91,8 @@ private Subscription enqueue(Action0 action, long execTime) {\n \n                     @Override\n                     public void call() {\n-                        PriorityQueue<TimedAction> _q = queue;\n-                        if (_q != null) {\n-                            _q.remove(timedAction);\n+                        synchronized (queue) {\n+                            queue.remove(timedAction);\n                         }\n                     }\n \n\ndiff --git a/src/test/java/rx/schedulers/TrampolineSchedulerTest.java b/src/test/java/rx/schedulers/TrampolineSchedulerTest.java\n--- a/src/test/java/rx/schedulers/TrampolineSchedulerTest.java\n+++ b/src/test/java/rx/schedulers/TrampolineSchedulerTest.java\n@@ -18,13 +18,17 @@\n import static org.junit.Assert.*;\n \n import java.util.*;\n+import java.util.concurrent.TimeUnit;\n \n import org.junit.Test;\n \n import rx.*;\n+import rx.Observer;\n import rx.Scheduler.Worker;\n import rx.Observable;\n import rx.functions.*;\n+import rx.observers.Observers;\n+import rx.observers.TestSubscriber;\n import rx.subscriptions.CompositeSubscription;\n \n public class TrampolineSchedulerTest extends AbstractSchedulerTests {\n@@ -95,6 +99,47 @@ public void call() {\n         }\n     }\n \n+    /**\n+     * This is a regression test for #1702. Concurrent work scheduling that is improperly synchronized can cause an\n+     * action to be added or removed onto the priority queue during a poll, which can result in NPEs during queue\n+     * sifting. While it is difficult to isolate the issue directly, we can easily trigger the behavior by spamming the\n+     * trampoline with enqueue requests from multiple threads concurrently.\n+     */\n+    @Test\n+    public void testTrampolineWorkerHandlesConcurrentScheduling() {\n+        final Worker trampolineWorker = Schedulers.trampoline().createWorker();\n+        final Observer<Subscription> observer = Observers.empty();\n+        final TestSubscriber<Subscription> ts = new TestSubscriber<Subscription>(observer);\n+\n+        // Spam the trampoline with actions.\n+        Observable.range(0, 50)\n+                .flatMap(new Func1<Integer, Observable<Subscription>>() {\n+\n+                    @Override\n+                    public Observable<Subscription> call(Integer count) {\n+                        return Observable.interval(1, TimeUnit.MICROSECONDS).map(\n+                                new Func1<Long, Subscription>() {\n+\n+                                     @Override\n+                                     public Subscription call(Long count) {\n+                                         return trampolineWorker.schedule(new Action0() {\n+\n+                                             @Override\n+                                             public void call() {}\n+\n+                                         });\n+                                     }\n+\n+                                }).limit(100);\n+                    }\n+\n+                })\n+                .subscribeOn(Schedulers.computation())\n+                .subscribe(ts);\n+        ts.awaitTerminalEvent();\n+        ts.assertNoErrors();\n+    }\n+\n     private static Worker doWorkOnNewTrampoline(final String key, final ArrayList<String> workDone) {\n         Worker worker = Schedulers.trampoline().createWorker();\n         worker.schedule(new Action0() {",
    "output": "Fix NPEs reported in ReactiveX#1702 by synchronizing queue. Adds unit test for regression"
  },
  {
    "input": "diff --git a/src/test/java/rx/subscriptions/CompositeSubscriptionTest.java b/src/test/java/rx/subscriptions/CompositeSubscriptionTest.java\n--- a/src/test/java/rx/subscriptions/CompositeSubscriptionTest.java\n+++ b/src/test/java/rx/subscriptions/CompositeSubscriptionTest.java\n@@ -340,8 +340,8 @@ public void testTryRemoveIfNotIn() {\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testAddingNullSubscriptionIllegal() {\n-      CompositeSubscription csub = new CompositeSubscription();\n-      csub.add(null);\n+        CompositeSubscription csub = new CompositeSubscription();\n+        csub.add(null);\n     }\n \n }",
    "output": "Fix indentation"
  },
  {
    "input": "diff --git a/src/test/java/rx/internal/operators/OperatorRetryTest.java b/src/test/java/rx/internal/operators/OperatorRetryTest.java\n--- a/src/test/java/rx/internal/operators/OperatorRetryTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorRetryTest.java\n@@ -418,7 +418,7 @@ public void request(long n) {\n                         }\n                         return;\n                     }\n-                    if (n > 0 && req.getAndAdd(1) == 0) {\n+                    if (n > 0 && req.getAndAdd(n) == 0) {\n                         int i = count.getAndIncrement();\n                         if (i < numFailures) {\n                             o.onNext(\"beginningEveryTime\");\n@@ -722,20 +722,31 @@ public void testRetryWithBackpressureParallel() throws InterruptedException {\n         int ncpu = Runtime.getRuntime().availableProcessors();\n         ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 1));\n         final AtomicInteger timeouts = new AtomicInteger();\n-        int m = 300;\n+        final AtomicInteger data = new AtomicInteger();\n+        int m = 2000;\n         final CountDownLatch cdl = new CountDownLatch(m);\n         for (int i = 0; i < m; i++) {\n             final int j = i;\n             exec.execute(new Runnable() {\n                 @Override\n                 public void run() {\n                     try {\n+                        final AtomicInteger nexts = new AtomicInteger();\n                         Observable<String> origin = Observable.create(new FuncWithErrors(NUM_RETRIES));\n                         TestSubscriber<String> ts = new TestSubscriber<String>();\n                         origin.retry().observeOn(Schedulers.computation()).unsafeSubscribe(ts);\n-                        if (!ts.awaitTerminalEvent(10, TimeUnit.SECONDS)) {\n+                        if (!ts.awaitTerminalEvent(2, TimeUnit.SECONDS)) {\n                             timeouts.incrementAndGet();\n-                            System.out.println(j + \" | \" + cdl.getCount() + \" !!!\");\n+                            System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n+                        } \n+                        if (ts.getOnNextEvents().size() != NUM_RETRIES + 2) {\n+                            data.incrementAndGet();\n+                        }\n+                        if (ts.getOnErrorEvents().size() != 0) {\n+                            data.incrementAndGet();\n+                        }\n+                        if (ts.getOnCompletedEvents().size() != 1) {\n+                            data.incrementAndGet();\n                         }\n                     } catch (Throwable t) {\n                         timeouts.incrementAndGet();\n@@ -747,6 +758,7 @@ public void run() {\n         exec.shutdown();\n         cdl.await();\n         assertEquals(0, timeouts.get());\n+        assertEquals(0, data.get());\n \n     }\n     @Test(timeout = 3000)",
    "output": "Fix the error function"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/TakeLastQueueProducer.java b/src/main/java/rx/internal/operators/TakeLastQueueProducer.java\n--- a/src/main/java/rx/internal/operators/TakeLastQueueProducer.java\n+++ b/src/main/java/rx/internal/operators/TakeLastQueueProducer.java\n@@ -70,6 +70,8 @@ void emit(long previousRequested) {\n             if (previousRequested == 0) {\n                 try {\n                     for (Object value : deque) {\n+                        if (subscriber.isUnsubscribed())\n+                            return;\n                         notification.accept(subscriber, value);\n                     }\n                 } catch (Throwable e) {\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorTakeLastTest.java b/src/test/java/rx/internal/operators/OperatorTakeLastTest.java\n--- a/src/test/java/rx/internal/operators/OperatorTakeLastTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorTakeLastTest.java\n@@ -24,6 +24,7 @@\n import static org.mockito.Mockito.verify;\n \n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Test;\n import org.mockito.InOrder;\n@@ -264,4 +265,32 @@ public void onNext(Integer integer) {\n             }\n         });\n     }\n+    \n+    @Test\n+    public void testUnsubscribeTakesEffectEarlyOnFastPath() {\n+        final AtomicInteger count = new AtomicInteger();\n+        Observable.range(0, 100000).takeLast(100000).subscribe(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(Long.MAX_VALUE);\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+            }\n+\n+            @Override\n+            public void onNext(Integer integer) {\n+                count.incrementAndGet();\n+                unsubscribe();\n+            }\n+        });\n+        assertEquals(1,count.get());\n+    }\n }",
    "output": "Add check for isUnsubscribed to OperatorTakeLast fast path"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeCache.java b/src/main/java/rx/internal/operators/OnSubscribeCache.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeCache.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeCache.java\n@@ -64,9 +64,10 @@ public OnSubscribeCache(Observable<? extends T> source, int capacity) {\n     @Override\n     public void call(Subscriber<? super T> s) {\n         if (SRC_SUBSCRIBED_UPDATER.compareAndSet(this, 0, 1)) {\n-            source.unsafeSubscribe(Subscribers.from(cache));\n+            source.subscribe(cache);\n             /*\n-             * Note that we will never unsubscribe from 'source' as we want to receive and cache all of its values.\n+             * Note that we will never unsubscribe from 'source' unless we receive `onCompleted` or `onError`,\n+             * as we want to receive and cache all of its values.\n              * \n              * This means this should never be used on an infinite or very large sequence, similar to toList().\n              */\n\ndiff --git a/src/test/java/rx/internal/operators/OnSubscribeCacheTest.java b/src/test/java/rx/internal/operators/OnSubscribeCacheTest.java\n--- a/src/test/java/rx/internal/operators/OnSubscribeCacheTest.java\n+++ b/src/test/java/rx/internal/operators/OnSubscribeCacheTest.java\n@@ -17,6 +17,9 @@\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n import java.util.Arrays;\n import java.util.concurrent.CountDownLatch;\n@@ -27,10 +30,10 @@\n \n import rx.Observable;\n import rx.Subscriber;\n+import rx.functions.Action0;\n import rx.functions.Action1;\n import rx.functions.Func1;\n import rx.functions.Func2;\n-import rx.internal.operators.OnSubscribeCache;\n import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n import rx.subjects.AsyncSubject;\n@@ -148,4 +151,14 @@ public void testWithPublishSubjectAndRepeat() {\n     public void testWithReplaySubjectAndRepeat() {\n         testWithCustomSubjectAndRepeat(ReplaySubject.<Integer> create(), 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3);\n     }\n+\n+    @Test\n+    public void testUnsubscribeSource() {\n+        Action0 unsubscribe = mock(Action0.class);\n+        Observable<Integer> o = Observable.just(1).doOnUnsubscribe(unsubscribe).cache();\n+        o.subscribe();\n+        o.subscribe();\n+        o.subscribe();\n+        verify(unsubscribe, times(1)).call();\n+    }\n }",
    "output": "Fix the bug that cache doesn't unsubscribe the source Observable when the source is terminated"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorPublish.java b/src/main/java/rx/internal/operators/OperatorPublish.java\n--- a/src/main/java/rx/internal/operators/OperatorPublish.java\n+++ b/src/main/java/rx/internal/operators/OperatorPublish.java\n@@ -99,7 +99,7 @@ public void call() {\n     public void connect(Action1<? super Subscription> connection) {\n         // each time we connect we create a new Subscription\n         boolean shouldSubscribe = false;\n-\n+        \n         // subscription is the state of whether we are connected or not\n         OriginSubscriber<T> origin = requestHandler.state.getOrigin();\n         if (origin == null) {\n@@ -113,7 +113,7 @@ public void connect(Action1<? super Subscription> connection) {\n             connection.call(Subscriptions.create(new Action0() {\n                 @Override\n                 public void call() {\n-                    Subscription s = requestHandler.state.getOrigin();\n+                    OriginSubscriber<T> s = requestHandler.state.getOrigin();\n                     requestHandler.state.setOrigin(null);\n                     if (s != null) {\n                         s.unsubscribe();\n@@ -135,9 +135,11 @@ private static class OriginSubscriber<T> extends Subscriber<T> {\n         private final RequestHandler<T> requestHandler;\n         private final AtomicLong originOutstanding = new AtomicLong();\n         private final long THRESHOLD = RxRingBuffer.SIZE / 4;\n+        private final RxRingBuffer buffer = RxRingBuffer.getSpmcInstance();\n \n         OriginSubscriber(RequestHandler<T> requestHandler) {\n             this.requestHandler = requestHandler;\n+            add(buffer);\n         }\n \n         @Override\n@@ -199,6 +201,8 @@ public void onNext(T t) {\n      * with a complicated state machine so I'm sticking with mutex locks and just trying to make sure the work done while holding the\n      * lock is small (such as never emitting data).\n      * \n+     * This does however mean we can't rely on a reference to State being consistent. For example, it can end up with a null OriginSubscriber. \n+     * \n      * @param <T>\n      */\n     private static class State<T> {\n@@ -288,7 +292,7 @@ private long resetAfterSubscriberUpdate() {\n \n     private static class RequestHandler<T> {\n         private final NotificationLite<T> notifier = NotificationLite.instance();\n-        private final RxRingBuffer buffer = RxRingBuffer.getSpmcInstance();\n+        \n         private final State<T> state = new State<T>();\n         @SuppressWarnings(\"unused\")\n         volatile long wip;\n@@ -297,16 +301,24 @@ private static class RequestHandler<T> {\n \n         public void requestFromChildSubscriber(Subscriber<? super T> subscriber, Long request) {\n             state.requestFromSubscriber(subscriber, request);\n-            drainQueue();\n+            OriginSubscriber<T> originSubscriber = state.getOrigin();\n+            if(originSubscriber != null) {\n+                drainQueue(originSubscriber);\n+            }\n         }\n \n         public void emit(Object t) throws MissingBackpressureException {\n+            OriginSubscriber<T> originSubscriber = state.getOrigin();\n+            if(originSubscriber == null) {\n+                // unsubscribed so break ... we are done\n+                return;\n+            }\n             if (notifier.isCompleted(t)) {\n-                buffer.onCompleted();\n+                originSubscriber.buffer.onCompleted();\n             } else {\n-                buffer.onNext(notifier.getValue(t));\n+                originSubscriber.buffer.onNext(notifier.getValue(t));\n             }\n-            drainQueue();\n+            drainQueue(originSubscriber);\n         }\n \n         private void requestMoreAfterEmission(int emitted) {\n@@ -319,7 +331,7 @@ private void requestMoreAfterEmission(int emitted) {\n             }\n         }\n \n-        public void drainQueue() {\n+        public void drainQueue(OriginSubscriber<T> originSubscriber) {\n             if (WIP.getAndIncrement(this) == 0) {\n                 int emitted = 0;\n                 do {\n@@ -338,7 +350,7 @@ public void drainQueue() {\n                         if (!shouldEmit) {\n                             break;\n                         }\n-                        Object o = buffer.poll();\n+                        Object o = originSubscriber.buffer.poll();\n                         if (o == null) {\n                             // nothing in buffer so increment outstanding back again\n                             state.incrementOutstandingAfterFailedEmit();\n\ndiff --git a/src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java b/src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java\n--- a/src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java\n+++ b/src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java\n@@ -154,7 +154,7 @@ public void call(Integer l) {\n         s2.unsubscribe(); // unsubscribe s2 first as we're counting in 1 and there can be a race between unsubscribe and one subscriber getting a value but not the other\n         s1.unsubscribe();\n \n-        System.out.println(\"onNext: \" + nextCount.get());\n+        System.out.println(\"onNext Count: \" + nextCount.get());\n \n         // it will emit twice because it is synchronous\n         assertEquals(nextCount.get(), receivedCount.get() * 2);",
    "output": "Make Publish Operator Release RingBuffer\n\n- it was retaining the RxRingBuffer reference between subscribes which meant it was never released to the object pool"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorMap.java b/src/main/java/rx/internal/operators/OperatorMap.java\n--- a/src/main/java/rx/internal/operators/OperatorMap.java\n+++ b/src/main/java/rx/internal/operators/OperatorMap.java\n@@ -17,6 +17,7 @@\n \n import rx.Observable.Operator;\n import rx.Subscriber;\n+import rx.exceptions.Exceptions;\n import rx.exceptions.OnErrorThrowable;\n import rx.functions.Func1;\n \n@@ -53,6 +54,7 @@ public void onNext(T t) {\n                 try {\n                     o.onNext(transformer.call(t));\n                 } catch (Throwable e) {\n+                    Exceptions.throwIfFatal(e);\n                     onError(OnErrorThrowable.addValueAsLastCause(e, t));\n                 }\n             }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorMapTest.java b/src/test/java/rx/internal/operators/OperatorMapTest.java\n--- a/src/test/java/rx/internal/operators/OperatorMapTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorMapTest.java\n@@ -319,4 +319,24 @@ private static Map<String, String> getMap(String prefix) {\n         m.put(\"lastName\", prefix + \"Last\");\n         return m;\n     }\n+\n+    @Test(expected = OnErrorNotImplementedException.class)\n+    public void testShouldNotSwallowOnErrorNotImplementedException() {\n+        Observable.just(\"a\", \"b\").flatMap(new Func1<String, Observable<String>>() {\n+            @Override\n+            public Observable<String> call(String s) {\n+                return Observable.just(s + \"1\", s + \"2\");\n+            }\n+        }).flatMap(new Func1<String, Observable<String>>() {\n+            @Override\n+            public Observable<String> call(String s) {\n+                return Observable.error(new Exception(\"test\"));\n+            }\n+        }).forEach(new Action1<String>() {\n+            @Override\n+            public void call(String s) {\n+                System.out.println(s);\n+            }\n+        });\n+    }\n }",
    "output": "Fix the issue that map may swallow fatal exceptions"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java b/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n--- a/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n+++ b/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n@@ -76,6 +76,17 @@ public void onCompleted() {\n \n         private void subscribeToAlternate() {\n             child.add(alternate.unsafeSubscribe(new Subscriber<T>() {\n+\n+                @Override\n+                public void setProducer(final Producer producer) {\n+                    child.setProducer(new Producer() {\n+                        @Override\n+                        public void request(long n) {\n+                            producer.request(n);\n+                        }\n+                    });\n+                }\n+\n                 @Override\n                 public void onStart() {\n                     final long capacity = consumerCapacity.get();\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java b/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n--- a/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n@@ -23,7 +23,9 @@\n import rx.functions.Action0;\n import rx.subscriptions.Subscriptions;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import static org.junit.Assert.assertEquals;\n@@ -56,13 +58,15 @@ public void testSwitchWhenEmpty() throws Exception {\n \n     @Test\n     public void testSwitchWithProducer() throws Exception {\n+        final AtomicBoolean emitted = new AtomicBoolean(false);\n         Observable<Long> withProducer = Observable.create(new Observable.OnSubscribe<Long>() {\n             @Override\n             public void call(final Subscriber<? super Long> subscriber) {\n                 subscriber.setProducer(new Producer() {\n                     @Override\n                     public void request(long n) {\n-                        if (n > 0) {\n+                        if (n > 0 && !emitted.get()) {\n+                            emitted.set(true);\n                             subscriber.onNext(42L);\n                             subscriber.onCompleted();\n                         }\n@@ -127,4 +131,33 @@ public void call(final Subscriber<? super Long> subscriber) {\n         }).switchIfEmpty(Observable.<Long>never()).subscribe();\n         assertTrue(s.isUnsubscribed());\n     }\n+\n+    @Test\n+    public void testSwitchRequestAlternativeObservableWithBackpressure() {\n+        final List<Integer> items = new ArrayList<Integer>();\n+\n+        Observable.<Integer>empty().switchIfEmpty(Observable.just(1, 2, 3)).subscribe(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(1);\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+\n+            }\n+\n+            @Override\n+            public void onNext(Integer integer) {\n+                items.add(integer);\n+            }\n+        });\n+        assertEquals(Arrays.asList(1), items);\n+    }\n }\n\\ No newline at end of file",
    "output": "Fix for back pressure on the alternate subscription"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -3736,6 +3736,24 @@ public final Observable<T> defaultIfEmpty(T defaultValue) {\n         return lift(new OperatorDefaultIfEmpty<T>(defaultValue));\n     }\n \n+    /**\n+     * Returns an Observable that emits the items emitted by the source Observable or the items of an alternate Observable if the source Observable\n+     * is empty.\n+     * <p>\n+     * <dl>\n+     *  <dt><b>Scheduler:</b></dt>\n+     *  <dd>{@code switchIfEmpty} does not operate by default on a particular {@link Scheduler}.</dd>\n+     * </dl>\n+     *\n+     * @param alternate\n+     *              the alternate Observable to subscribe to if the source does not emit any items\n+     * @return  an Observable that emits the items emitted by the source Observable or the items of an alternate Observable if the source Observable\n+     *          is empty.\n+     */\n+    public final Observable<T> switchIfEmpty(Observable<T> alternate) {\n+        return lift(new OperatorSwitchIfEmpty<T>(alternate));\n+    }\n+\n     /**\n      * Returns an Observable that delays the subscription to and emissions from the souce Observable via another\n      * Observable on a per-item basis.\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java b/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n--- a/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n+++ b/src/main/java/rx/internal/operators/OperatorSwitchIfEmpty.java\n@@ -0,0 +1,114 @@\n+/**\n+ * Copyright 2014 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.internal.operators;\n+\n+import rx.Observable;\n+import rx.Producer;\n+import rx.Subscriber;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * If the Observable completes without emitting any items, subscribe to an alternate Observable. Allows for similar\n+ * functionality to {@link rx.internal.operators.OperatorDefaultIfEmpty} except instead of one item being emitted when\n+ * empty, the results of the given Observable will be emitted.\n+ */\n+public class OperatorSwitchIfEmpty<T> implements Observable.Operator<T, T> {\n+    private final Observable<T> alternate;\n+\n+    public OperatorSwitchIfEmpty(Observable<T> alternate) {\n+        this.alternate = alternate;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> call(Subscriber<? super T> child) {\n+        return new SwitchIfEmptySubscriber(child);\n+    }\n+\n+    private class SwitchIfEmptySubscriber extends Subscriber<T> {\n+\n+        boolean empty = true;\n+        final AtomicLong consumerCapacity = new AtomicLong(0l);\n+\n+        private final Subscriber<? super T> child;\n+\n+        public SwitchIfEmptySubscriber(Subscriber<? super T> child) {\n+            super(child);\n+\n+            this.child = child;\n+        }\n+\n+        @Override\n+        public void setProducer(final Producer producer) {\n+            super.setProducer(new Producer() {\n+                @Override\n+                public void request(long n) {\n+                    if (empty) {\n+                        consumerCapacity.set(n);\n+                    }\n+                    producer.request(n);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void onCompleted() {\n+            if (!empty) {\n+                child.onCompleted();\n+            } else if (!child.isUnsubscribed()) {\n+                subscribeToAlternate();\n+            }\n+        }\n+\n+        private void subscribeToAlternate() {\n+            add(alternate.unsafeSubscribe(new Subscriber<T>() {\n+                @Override\n+                public void onStart() {\n+                    final long capacity = consumerCapacity.get();\n+                    if (capacity > 0) {\n+                        request(capacity);\n+                    }\n+                }\n+\n+                @Override\n+                public void onCompleted() {\n+                    child.onCompleted();\n+                }\n+\n+                @Override\n+                public void onError(Throwable e) {\n+                    child.onError(e);\n+                }\n+\n+                @Override\n+                public void onNext(T t) {\n+                    child.onNext(t);\n+                }\n+            }));\n+        }\n+\n+        @Override\n+        public void onError(Throwable e) {\n+            child.onError(e);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            empty = false;\n+            child.onNext(t);\n+        }\n+    }\n+}\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java b/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n--- a/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java\n@@ -0,0 +1,118 @@\n+/**\n+ * Copyright 2014 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.internal.operators;\n+\n+import org.junit.Test;\n+import rx.Observable;\n+import rx.Producer;\n+import rx.Subscriber;\n+import rx.Subscription;\n+import rx.functions.Action0;\n+import rx.functions.Action1;\n+import rx.schedulers.Schedulers;\n+import rx.subscriptions.Subscriptions;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class OperatorSwitchIfEmptyTest {\n+\n+    @Test\n+    public void testSwitchWhenNotEmpty() throws Exception {\n+        final AtomicBoolean subscribed = new AtomicBoolean(false);\n+        final Observable<Integer> observable = Observable.just(4).switchIfEmpty(Observable.just(2)\n+                .doOnSubscribe(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        subscribed.set(true);\n+                    }\n+                }));\n+\n+        assertEquals(4, observable.toBlocking().single().intValue());\n+        assertFalse(subscribed.get());\n+    }\n+\n+    @Test\n+    public void testSwitchWhenEmpty() throws Exception {\n+        final Observable<Integer> observable = Observable.<Integer>empty().switchIfEmpty(Observable.from(Arrays.asList(42)));\n+\n+        assertEquals(42, observable.toBlocking().single().intValue());\n+    }\n+\n+    @Test\n+    public void testSwitchWithProducer() throws Exception {\n+        Observable<Long> withProducer = Observable.create(new Observable.OnSubscribe<Long>() {\n+            @Override\n+            public void call(final Subscriber<? super Long> subscriber) {\n+                subscriber.setProducer(new Producer() {\n+                    @Override\n+                    public void request(long n) {\n+                        if (n > 0) {\n+                            subscriber.onNext(42L);\n+                            subscriber.onCompleted();\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+\n+        final Observable<Long> observable = Observable.<Long>empty().switchIfEmpty(withProducer);\n+        assertEquals(42, observable.toBlocking().single().intValue());\n+    }\n+\n+    @Test\n+    public void testSwitchTriggerUnsubscribe() throws Exception {\n+        final Subscription empty = Subscriptions.empty();\n+\n+        Observable<Long> withProducer = Observable.create(new Observable.OnSubscribe<Long>() {\n+            @Override\n+            public void call(final Subscriber<? super Long> subscriber) {\n+                subscriber.add(empty);\n+                subscriber.onNext(42L);\n+            }\n+        });\n+\n+        final Subscription sub = Observable.<Long>empty().switchIfEmpty(withProducer).lift(new Observable.Operator<Long, Long>() {\n+            @Override\n+            public Subscriber<? super Long> call(final Subscriber<? super Long> child) {\n+                return new Subscriber<Long>(child) {\n+                    @Override\n+                    public void onCompleted() {\n+\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable e) {\n+\n+                    }\n+\n+                    @Override\n+                    public void onNext(Long aLong) {\n+                        unsubscribe();\n+                    }\n+                };\n+            }\n+        }).subscribe();\n+\n+\n+        assertTrue(empty.isUnsubscribed());\n+        assertTrue(sub.isUnsubscribed());\n+    }\n+}\n\\ No newline at end of file",
    "output": "Add Operator switchIfEmpty, like defaultIfEmpty but subscribes to and emits the items in an Observable if the source is empty"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/util/BackpressureDrainManager.java b/src/main/java/rx/internal/util/BackpressureDrainManager.java\n--- a/src/main/java/rx/internal/util/BackpressureDrainManager.java\n+++ b/src/main/java/rx/internal/util/BackpressureDrainManager.java\n@@ -142,14 +142,17 @@ public final void request(long n) {\n             r = requestedCount;\r\n             mayDrain = r == 0;\r\n             if (r == Long.MAX_VALUE) {\r\n-                mayDrain = true;\r\n                 break;\r\n             }\r\n             if (n == Long.MAX_VALUE) {\r\n                 u = n;\r\n                 mayDrain = true;\r\n             } else {\r\n-                u = r + n;\r\n+                if (r > Long.MAX_VALUE - n) {\r\n+                    u = Long.MAX_VALUE;\r\n+                } else {\r\n+                    u = r + n;\r\n+                }\r\n             }\r\n         } while (!REQUESTED_COUNT.compareAndSet(this, r, u));\r\n         // since we implement producer, we have to call drain\r",
    "output": "Fix potential request value overflow"
  },
  {
    "input": "diff --git a/src/test/java/rx/subjects/ReplaySubjectBoundedConcurrencyTest.java b/src/test/java/rx/subjects/ReplaySubjectBoundedConcurrencyTest.java\n--- a/src/test/java/rx/subjects/ReplaySubjectBoundedConcurrencyTest.java\n+++ b/src/test/java/rx/subjects/ReplaySubjectBoundedConcurrencyTest.java\n@@ -396,7 +396,12 @@ public void onNext(Object t) {\n                 break;\n             } else {\n                 Assert.assertEquals(1, o.get());\n-                rs.onCompleted();\n+                worker.schedule(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        rs.onCompleted();\n+                    }\n+                });\n             }\n         }\n     }",
    "output": "Fix wrong subject use in test"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorGroupBy.java b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n--- a/src/main/java/rx/internal/operators/OperatorGroupBy.java\n+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n@@ -399,14 +399,11 @@ private void completeInner() {\n             if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) {\n                 // It means `groups.isEmpty() && child.isUnsubscribed()` is true\n                 unsubscribe();\n-            }\n-            // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer\n-            if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) {\n+            } else if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) {\n+                // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer\n                 // completionEmitted ensures we only emit onCompleted once\n                 if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) {\n-                    if (!child.isUnsubscribed()) {\n-                        child.onCompleted();\n-                    }\n+                    child.onCompleted();\n                 }\n             }\n         }",
    "output": "Upgrade as per review"
  },
  {
    "input": "diff --git a/src/test/java/rx/subjects/ReplaySubjectConcurrencyTest.java b/src/test/java/rx/subjects/ReplaySubjectConcurrencyTest.java\n--- a/src/test/java/rx/subjects/ReplaySubjectConcurrencyTest.java\n+++ b/src/test/java/rx/subjects/ReplaySubjectConcurrencyTest.java\n@@ -338,63 +338,73 @@ public void run() {\n     public void testReplaySubjectEmissionSubscriptionRace() throws Exception {\n         Scheduler s = Schedulers.io();\n         Scheduler.Worker worker = Schedulers.io().createWorker();\n-        for (int i = 0; i < 50000; i++) {\n-            if (i % 1000 == 0) {\n-                System.out.println(i);\n-            }\n-            final ReplaySubject<Object> rs = ReplaySubject.create();\n-            \n-            final CountDownLatch finish = new CountDownLatch(1); \n-            final CountDownLatch start = new CountDownLatch(1); \n-            \n-            worker.schedule(new Action0() {\n-                @Override\n-                public void call() {\n-                    try {\n-                        start.await();\n-                    } catch (Exception e1) {\n-                        e1.printStackTrace();\n-                    }\n-                    rs.onNext(1);\n-                }\n-            });\n-            \n-            final AtomicReference<Object> o = new AtomicReference<Object>();\n-            \n-            rs.subscribeOn(s).observeOn(Schedulers.io())\n-            .subscribe(new Observer<Object>() {\n-\n-                @Override\n-                public void onCompleted() {\n-                    o.set(-1);\n-                    finish.countDown();\n-                }\n-\n-                @Override\n-                public void onError(Throwable e) {\n-                    o.set(e);\n-                    finish.countDown();\n-                }\n-\n-                @Override\n-                public void onNext(Object t) {\n-                    o.set(t);\n-                    finish.countDown();\n+        try {\n+            for (int i = 0; i < 50000; i++) {\n+                if (i % 1000 == 0) {\n+                    System.out.println(i);\n                 }\n+                final ReplaySubject<Object> rs = ReplaySubject.create();\n                 \n-            });\n-            start.countDown();\n-            \n-            if (!finish.await(5, TimeUnit.SECONDS)) {\n-                System.out.println(o.get());\n-                System.out.println(rs.hasObservers());\n-                rs.onCompleted();\n-                Assert.fail(\"Timeout @ \" + i);\n-                break;\n-            } else {\n-                Assert.assertEquals(1, o.get());\n-                rs.onCompleted();\n+                final CountDownLatch finish = new CountDownLatch(1); \n+                final CountDownLatch start = new CountDownLatch(1); \n+                \n+                worker.schedule(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        try {\n+                            start.await();\n+                        } catch (Exception e1) {\n+                            e1.printStackTrace();\n+                        }\n+                        rs.onNext(1);\n+                    }\n+                });\n+                \n+                final AtomicReference<Object> o = new AtomicReference<Object>();\n+                \n+                rs.subscribeOn(s).observeOn(Schedulers.io())\n+                .subscribe(new Observer<Object>() {\n+    \n+                    @Override\n+                    public void onCompleted() {\n+                        o.set(-1);\n+                        finish.countDown();\n+                    }\n+    \n+                    @Override\n+                    public void onError(Throwable e) {\n+                        o.set(e);\n+                        finish.countDown();\n+                    }\n+    \n+                    @Override\n+                    public void onNext(Object t) {\n+                        o.set(t);\n+                        finish.countDown();\n+                    }\n+                    \n+                });\n+                start.countDown();\n+                \n+                if (!finish.await(5, TimeUnit.SECONDS)) {\n+                    System.out.println(o.get());\n+                    System.out.println(rs.hasObservers());\n+                    rs.onCompleted();\n+                    Assert.fail(\"Timeout @ \" + i);\n+                    break;\n+                } else {\n+                    Assert.assertEquals(1, o.get());\n+                    worker.schedule(new Action0() {\n+                        @Override\n+                        public void call() {\n+                            rs.onCompleted();\n+                        }\n+                    });\n+                    \n+                }\n             }\n+        } finally {\n+            worker.unsubscribe();\n         }\n     }\n }",
    "output": "Fix test issuing non-serialized messages to the subject"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorGroupBy.java b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n--- a/src/main/java/rx/internal/operators/OperatorGroupBy.java\n+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n@@ -79,6 +79,9 @@ static final class GroupBySubscriber<K, T, R> extends Subscriber<T> {\n         final Func1<? super T, ? extends R> elementSelector;\n         final Subscriber<? super GroupedObservable<K, R>> child;\n \n+        // We should not call `unsubscribe()` until `groups.isEmpty() && child.isUnsubscribed()` is true.\n+        // Use `WIP_FOR_UNSUBSCRIBE_UPDATER` to monitor these statuses and call `unsubscribe()` properly.\n+        // Should check both when `child.unsubscribe` is called and any group is removed.\n         @SuppressWarnings(\"rawtypes\")\n         static final AtomicIntegerFieldUpdater<GroupBySubscriber> WIP_FOR_UNSUBSCRIBE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, \"wipForUnsubscribe\");\n         volatile int wipForUnsubscribe = 1;\n@@ -124,7 +127,13 @@ public Observer<T> getObserver() {\n         private static final NotificationLite<Object> nl = NotificationLite.instance();\n \n         volatile int completionEmitted;\n-        volatile int terminated;\n+\n+        private static final int UNTERMINATED = 0;\n+        private static final int TERMINATED_WITH_COMPLETED = 1;\n+        private static final int TERMINATED_WITH_ERROR = 2;\n+\n+        // Must be one of `UNTERMINATED`, `TERMINATED_WITH_COMPLETED`, `TERMINATED_WITH_ERROR`\n+        volatile int terminated = UNTERMINATED;\n \n         @SuppressWarnings(\"rawtypes\")\n         static final AtomicIntegerFieldUpdater<GroupBySubscriber> COMPLETION_EMITTED_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, \"completionEmitted\");\n@@ -139,8 +148,6 @@ public Observer<T> getObserver() {\n         @SuppressWarnings(\"rawtypes\")\n         static final AtomicLongFieldUpdater<GroupBySubscriber> BUFFERED_COUNT = AtomicLongFieldUpdater.newUpdater(GroupBySubscriber.class, \"bufferedCount\");\n \n-        volatile boolean errorEmitted = false;\n-\n         @Override\n         public void onStart() {\n             REQUESTED.set(this, MAX_QUEUE_SIZE);\n@@ -149,7 +156,7 @@ public void onStart() {\n \n         @Override\n         public void onCompleted() {\n-            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {\n+            if (TERMINATED_UPDATER.compareAndSet(this, UNTERMINATED, TERMINATED_WITH_COMPLETED)) {\n                 // if we receive onCompleted from our parent we onComplete children\n                 // for each group check if it is ready to accept more events if so pass the oncomplete through else buffer it.\n                 for (GroupState<K, T> group : groups.values()) {\n@@ -168,9 +175,7 @@ public void onCompleted() {\n \n         @Override\n         public void onError(Throwable e) {\n-            if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {\n-                errorEmitted = true;\n-\n+            if (TERMINATED_UPDATER.compareAndSet(this, UNTERMINATED, TERMINATED_WITH_ERROR)) {\n                 // It's safe to access all groups and emit the error.\n                 // onNext and onError are in sequence so no group will be created in the loop.\n                 for (GroupState<K, T> group : groups.values()) {\n@@ -390,18 +395,16 @@ private void drainIfPossible(GroupState<K, T> groupState) {\n         }\n \n         private void completeInner() {\n+            // A group is removed, so check if we need to call `unsubscribe`\n             if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) {\n+                // It means `groups.isEmpty() && child.isUnsubscribed()` is true\n                 unsubscribe();\n             }\n-            // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer\n-            if (groups.isEmpty() && (terminated == 1 || child.isUnsubscribed())) {\n+            // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer\n+            if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) {\n                 // completionEmitted ensures we only emit onCompleted once\n                 if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) {\n-\n-                    if (child.isUnsubscribed()) {\n-                        // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up.\n-                        unsubscribe();\n-                    } else if (!errorEmitted) {\n+                    if (!child.isUnsubscribed()) {\n                         child.onCompleted();\n                     }\n                 }",
    "output": "Add a new state of `terminated` to fix the race condition of `errorEmitted`; Add more comments"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorGroupBy.java b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n--- a/src/main/java/rx/internal/operators/OperatorGroupBy.java\n+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n@@ -19,6 +19,7 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n@@ -34,6 +35,7 @@\n import rx.functions.Func1;\n import rx.observables.GroupedObservable;\n import rx.subjects.Subject;\n+import rx.subscriptions.Subscriptions;\n \n /**\n  * Groups the items emitted by an Observable according to a specified criterion, and emits these\n@@ -76,6 +78,10 @@ static final class GroupBySubscriber<K, T, R> extends Subscriber<T> {\n         final Func1<? super T, ? extends R> elementSelector;\n         final Subscriber<? super GroupedObservable<K, R>> child;\n \n+        @SuppressWarnings(\"rawtypes\")\n+        static final AtomicIntegerFieldUpdater<GroupBySubscriber> WIP_FOR_UNSUBSCRIBE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, \"wipForUnsubscribe\");\n+        volatile int wipForUnsubscribe = 1;\n+\n         public GroupBySubscriber(\n                 Func1<? super T, ? extends K> keySelector,\n                 Func1<? super T, ? extends R> elementSelector,\n@@ -84,6 +90,16 @@ public GroupBySubscriber(\n             this.keySelector = keySelector;\n             this.elementSelector = elementSelector;\n             this.child = child;\n+            child.add(Subscriptions.create(new Action0() {\n+\n+                @Override\n+                public void call() {\n+                    if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(self) == 0) {\n+                        self.unsubscribe();\n+                    }\n+                }\n+\n+            }));\n         }\n \n         private static class GroupState<K, T> {\n@@ -138,7 +154,7 @@ public void onCompleted() {\n                 }\n \n                 // special case (no groups emitted ... or all unsubscribed)\n-                if (groups.size() == 0) {\n+                if (groups.isEmpty()) {\n                     // we must track 'completionEmitted' seperately from 'completed' since `completeInner` can result in childObserver.onCompleted() being emitted\n                     if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) {\n                         child.onCompleted();\n@@ -150,8 +166,13 @@ public void onCompleted() {\n         @Override\n         public void onError(Throwable e) {\n             if (TERMINATED_UPDATER.compareAndSet(this, 0, 1)) {\n-                // we immediately tear everything down if we receive an error\n-                child.onError(e);\n+                try {\n+                    // we immediately tear everything down if we receive an error\n+                    child.onError(e);\n+                } finally {\n+                    // We have not chained the subscribers, so need to call it explicitly.\n+                    unsubscribe();\n+                }\n             }\n         }\n \n@@ -187,7 +208,9 @@ public void onNext(T t) {\n                     }\n                     group = createNewGroup(key);\n                 }\n-                emitItem(group, nl.next(t));\n+                if (group != null) {\n+                    emitItem(group, nl.next(t));\n+                }\n             } catch (Throwable e) {\n                 onError(OnErrorThrowable.addValueAsLastCause(e, t));\n             }\n@@ -250,7 +273,17 @@ public void onNext(T t) {\n                 }\n             });\n \n-            GroupState<K, T> putIfAbsent = groups.putIfAbsent(key, groupState);\n+            GroupState<K, T> putIfAbsent;\n+            for (;;) {\n+                int wip = wipForUnsubscribe;\n+                if (wip <= 0) {\n+                    return null;\n+                }\n+                if (WIP_FOR_UNSUBSCRIBE_UPDATER.compareAndSet(this, wip, wip + 1)) {\n+                    putIfAbsent = groups.putIfAbsent(key, groupState);\n+                    break;\n+                }\n+            }\n             if (putIfAbsent != null) {\n                 // this shouldn't happen (because we receive onNext sequentially) and would mean we have a bug\n                 throw new IllegalStateException(\"Group already existed while creating a new one\");\n@@ -264,7 +297,7 @@ private void cleanupGroup(Object key) {\n             GroupState<K, T> removed;\n             removed = groups.remove(key);\n             if (removed != null) {\n-                if (removed.buffer.size() > 0) {\n+                if (!removed.buffer.isEmpty()) {\n                     BUFFERED_COUNT.addAndGet(self, -removed.buffer.size());\n                 }\n                 completeInner();\n@@ -342,16 +375,20 @@ private void drainIfPossible(GroupState<K, T> groupState) {\n         }\n \n         private void completeInner() {\n+            if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) {\n+                unsubscribe();\n+            }\n             // if we have no outstanding groups (all completed or unsubscribe) and terminated/unsubscribed on outer\n-            if (groups.size() == 0 && (terminated == 1 || child.isUnsubscribed())) {\n+            if (groups.isEmpty() && (terminated == 1 || child.isUnsubscribed())) {\n                 // completionEmitted ensures we only emit onCompleted once\n                 if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) {\n \n                     if (child.isUnsubscribed()) {\n                         // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up.\n                         unsubscribe();\n+                    } else {\n+                        child.onCompleted();\n                     }\n-                    child.onCompleted();\n                 }\n             }\n         }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorGroupByTest.java b/src/test/java/rx/internal/operators/OperatorGroupByTest.java\n--- a/src/test/java/rx/internal/operators/OperatorGroupByTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorGroupByTest.java\n@@ -47,6 +47,7 @@\n import rx.Observable.OnSubscribe;\n import rx.Observer;\n import rx.Subscriber;\n+import rx.Subscription;\n import rx.exceptions.TestException;\n import rx.functions.Action0;\n import rx.functions.Action1;\n@@ -1385,4 +1386,25 @@ public void call(String s) {\n         assertEquals(null, key[0]);\n         assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), values);\n     }\n+\n+    @Test\n+    public void testGroupByUnsubscribe() {\n+        final Subscription s = mock(Subscription.class);\n+        Observable<Integer> o = Observable.create(\n+                new OnSubscribe<Integer>() {\n+                    @Override\n+                    public void call(Subscriber<? super Integer> subscriber) {\n+                        subscriber.add(s);\n+                    }\n+                }\n+        );\n+        o.groupBy(new Func1<Integer, Integer>() {\n+\n+            @Override\n+            public Integer call(Integer integer) {\n+                return null;\n+            }\n+        }).subscribe().unsubscribe();\n+        verify(s).unsubscribe();\n+    }\n }",
    "output": "Fix the issue that GroupBy may not call 'unsubscribe'"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorSampleWithTime.java b/src/main/java/rx/internal/operators/OperatorSampleWithTime.java\n--- a/src/main/java/rx/internal/operators/OperatorSampleWithTime.java\n+++ b/src/main/java/rx/internal/operators/OperatorSampleWithTime.java\n@@ -50,6 +50,7 @@ public Subscriber<? super T> call(Subscriber<? super T> child) {\n         child.add(worker);\n         \n         SamplerSubscriber<T> sampler = new SamplerSubscriber<T>(s);\n+        child.add(sampler);\n         worker.schedulePeriodically(sampler, time, time, unit);\n \n         return sampler;\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorSampleTest.java b/src/test/java/rx/internal/operators/OperatorSampleTest.java\n--- a/src/test/java/rx/internal/operators/OperatorSampleTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorSampleTest.java\n@@ -28,14 +28,12 @@\n import org.junit.Test;\n import org.mockito.InOrder;\n \n-import rx.Observable;\n+import rx.*;\n import rx.Observable.OnSubscribe;\n-import rx.Observer;\n-import rx.Scheduler;\n-import rx.Subscriber;\n import rx.functions.Action0;\n import rx.schedulers.TestScheduler;\n import rx.subjects.PublishSubject;\n+import rx.subscriptions.Subscriptions;\n \n public class OperatorSampleTest {\n     private TestScheduler scheduler;\n@@ -271,4 +269,19 @@ public void sampleWithSamplerThrows() {\n         inOrder.verify(observer2, times(1)).onError(any(RuntimeException.class));\n         verify(observer, never()).onCompleted();\n     }\n+\n+    @Test\n+    public void testSampleUnsubscribe() {\n+        final Subscription s = mock(Subscription.class);\n+        Observable<Integer> o = Observable.create(\n+                new OnSubscribe<Integer>() {\n+                    @Override\n+                    public void call(Subscriber<? super Integer> subscriber) {\n+                        subscriber.add(s);\n+                    }\n+                }\n+        );\n+        o.throttleLast(1, TimeUnit.MILLISECONDS).subscribe().unsubscribe();\n+        verify(s).unsubscribe();\n+    }\n }",
    "output": "Fix the issue that Sample doesn't call 'unsubscribe'"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorGroupBy.java b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n--- a/src/main/java/rx/internal/operators/OperatorGroupBy.java\n+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n@@ -102,7 +102,7 @@ public Observer<T> getObserver() {\n \n         }\n \n-        private final ConcurrentHashMap<K, GroupState<K, T>> groups = new ConcurrentHashMap<K, GroupState<K, T>>();\n+        private final ConcurrentHashMap<Object, GroupState<K, T>> groups = new ConcurrentHashMap<Object, GroupState<K, T>>();\n \n         private static final NotificationLite<Object> nl = NotificationLite.instance();\n \n@@ -166,10 +166,18 @@ void requestFromGroupedObservable(long n, GroupState<K, T> group) {\n             }\n         }\n \n+        private Object groupedKey(K key) {\n+            return key == null ? NULL_KEY : key;\n+        }\n+\n+        private K getKey(Object groupedKey) {\n+            return groupedKey == NULL_KEY ? null : (K) groupedKey;\n+        }\n+\n         @Override\n         public void onNext(T t) {\n             try {\n-                final K key = keySelector.call(t);\n+                final Object key = groupedKey(keySelector.call(t));\n                 GroupState<K, T> group = groups.get(key);\n                 if (group == null) {\n                     // this group doesn't exist\n@@ -185,10 +193,10 @@ public void onNext(T t) {\n             }\n         }\n \n-        private GroupState<K, T> createNewGroup(final K key) {\n+        private GroupState<K, T> createNewGroup(final Object key) {\n             final GroupState<K, T> groupState = new GroupState<K, T>();\n \n-            GroupedObservable<K, R> go = GroupedObservable.create(key, new OnSubscribe<R>() {\n+            GroupedObservable<K, R> go = GroupedObservable.create(getKey(key), new OnSubscribe<R>() {\n \n                 @Override\n                 public void call(final Subscriber<? super R> o) {\n@@ -252,7 +260,7 @@ public void onNext(T t) {\n             return groupState;\n         }\n \n-        private void cleanupGroup(K key) {\n+        private void cleanupGroup(Object key) {\n             GroupState<K, T> removed;\n             removed = groups.remove(key);\n             if (removed != null) {\n@@ -357,4 +365,5 @@ public Object call(Object t) {\n         }\n     };\n \n+    private static final Object NULL_KEY = new Object();\n }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorGroupByTest.java b/src/test/java/rx/internal/operators/OperatorGroupByTest.java\n--- a/src/test/java/rx/internal/operators/OperatorGroupByTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorGroupByTest.java\n@@ -28,6 +28,7 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentLinkedQueue;\n@@ -1357,4 +1358,31 @@ public Observable<Integer> call(GroupedObservable<Integer, Integer> t) {\n \n     };\n \n-}\n\\ No newline at end of file\n+    @Test\n+    public void testGroupByWithNullKey() {\n+        final String[] key = new String[]{\"uninitialized\"};\n+        final List<String> values = new ArrayList<String>();\n+        Observable.just(\"a\", \"b\", \"c\").groupBy(new Func1<String, String>() {\n+\n+            @Override\n+            public String call(String value) {\n+                return null;\n+            }\n+        }).subscribe(new Action1<GroupedObservable<String, String>>() {\n+\n+            @Override\n+            public void call(GroupedObservable<String, String> groupedObservable) {\n+                key[0] = groupedObservable.getKey();\n+                groupedObservable.subscribe(new Action1<String>() {\n+\n+                    @Override\n+                    public void call(String s) {\n+                        values.add(s);\n+                    }\n+                });\n+            }\n+        });\n+        assertEquals(null, key[0]);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), values);\n+    }\n+}",
    "output": "Fix NPE when the key is null in GroupBy"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorMerge.java b/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -186,8 +186,9 @@ private void handleNewSource(Observable<? extends T> t) {\n             InnerSubscriber<T> i = new InnerSubscriber<T>(this, producerIfNeeded);\n             i.sindex = childrenSubscribers.add(i);\n             t.unsafeSubscribe(i);\n-            if (!isUnsubscribed())\n+            if (!isUnsubscribed()) {\n                 request(1);\n+            }\n         }\n \n         private void handleScalarSynchronousObservable(ScalarSynchronousObservable<? extends T> t) {\n@@ -382,19 +383,8 @@ private int drainScalarValueQueue() {\n             public Boolean call(InnerSubscriber<T> s) {\n                 if (s.q != null) {\n                     long r = mergeProducer.requested;\n-                    int emitted = 0;\n-                    emitted += s.drainQueue();\n+                    int emitted = s.drainQueue();\n                     if (emitted > 0) {\n-                        /*\n-                         * `s.emitted` is not volatile (because of performance impact of making it so shown by JMH tests)\n-                         * but `emitted` can ONLY be touched by the thread holding the `emitLock` which we're currently inside.\n-                         * \n-                         * Entering and leaving the emitLock flushes all values so this is visible to us.\n-                         */\n-                        emitted += s.emitted;\n-                        // TODO we may want to store this in s.emitted and only request if above batch\n-                        // reset this since we have requested them all\n-                        s.emitted = 0;\n                         s.requestMore(emitted);\n                     }\n                     if (emitted == r) {\n@@ -542,9 +532,6 @@ private static final class InnerSubscriber<T> extends Subscriber<T> {\n         static final AtomicIntegerFieldUpdater<InnerSubscriber> ONCE_TERMINATED = AtomicIntegerFieldUpdater.newUpdater(InnerSubscriber.class, \"terminated\");\n \n         private final RxRingBuffer q = RxRingBuffer.getSpmcInstance();\n-        /* protected by emitLock */\n-        int emitted = 0;\n-        final int THRESHOLD = (int) (q.capacity() * 0.7);\n \n         public InnerSubscriber(MergeSubscriber<T> parent, MergeProducer<T> producer) {\n             this.parentSubscriber = parent;\n@@ -618,6 +605,7 @@ private void emit(T t, boolean complete) {\n              * putting in the queue, it attempts to get the lock. We are optimizing for the non-contended case.\n              */\n             if (parentSubscriber.getEmitLock()) {\n+                long emitted = 0;\n                 enqueue = false;\n                 try {\n                     // drain the queue if there is anything in it before emitting the current value\n@@ -660,30 +648,9 @@ private void emit(T t, boolean complete) {\n                 } finally {\n                     drain = parentSubscriber.releaseEmitLock();\n                 }\n-                if (emitted > THRESHOLD) {\n-                    // this is for batching requests when we're in a use case that isn't queueing, always fast-pathing the onNext\n-                    /**\n-                     * <pre> {@code\n-                     * Without this batching:\n-                     * \n-                     * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units\n-                     * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5060743.715   100445.513    ops/s\n-                     * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    36606.582     1610.582    ops/s\n-                     * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       38.476        0.973    ops/s\n-                     * \n-                     * With this batching:\n-                     * \n-                     * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units\n-                     * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5367945.738   262740.137    ops/s\n-                     * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    62703.930     8496.036    ops/s\n-                     * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       72.711        3.746    ops/s\n-                     *} </pre>\n-                     */\n+                // request upstream what we just emitted\n+                if(emitted > 0) {\n                     request(emitted);\n-                    // we are modifying this outside of the emit lock ... but this can be considered a \"lazySet\"\n-                    // and it will be flushed before anything else touches it because the emitLock will be obtained\n-                    // before any other usage of it\n-                    emitted = 0;\n                 }\n             }\n             if (enqueue) {\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorMergeTest.java b/src/test/java/rx/internal/operators/OperatorMergeTest.java\n--- a/src/test/java/rx/internal/operators/OperatorMergeTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorMergeTest.java\n@@ -30,6 +30,7 @@\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -40,9 +41,14 @@\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n \n-import rx.*;\n+import rx.Notification;\n+import rx.Observable;\n import rx.Observable.OnSubscribe;\n+import rx.Observer;\n+import rx.Scheduler;\n import rx.Scheduler.Worker;\n+import rx.Subscriber;\n+import rx.Subscription;\n import rx.functions.Action0;\n import rx.functions.Action1;\n import rx.functions.Func1;\n@@ -1105,4 +1111,88 @@ public void shouldNotReceivedDelayedErrorWhileThereAreStillNormalEmissionsInTheQ\n         subscriber.assertReceivedOnNext(asList(1, 2, 3, 4));\n         assertEquals(asList(exception), subscriber.getOnErrorEvents());\n     }\n+    \n+    @Test\n+    public void testMergeKeepsRequesting() throws InterruptedException {\n+        //for (int i = 0; i < 5000; i++) {\n+            //System.out.println(i + \".......................................................................\");\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            final ConcurrentLinkedQueue<String> messages = new ConcurrentLinkedQueue<String>();\n+\n+            Observable.range(1, 2)\n+                    // produce many integers per second\n+                    .flatMap(new Func1<Integer, Observable<Integer>>() {\n+                        @Override\n+                        public Observable<Integer> call(final Integer number) {\n+                            return Observable.range(1, Integer.MAX_VALUE)\n+                                    .doOnRequest(new Action1<Long>() {\n+\n+                                        @Override\n+                                        public void call(Long n) {\n+                                            messages.add(\">>>>>>>> A requested[\" + number + \"]: \" + n);\n+                                        }\n+\n+                                    })\n+                                    // pause a bit\n+                                    .doOnNext(pauseForMs(3))\n+                                    // buffer on backpressure\n+                                    .onBackpressureBuffer()\n+                                    // do in parallel\n+                                    .subscribeOn(Schedulers.computation())\n+                                    .doOnRequest(new Action1<Long>() {\n+\n+                                        @Override\n+                                        public void call(Long n) {\n+                                            messages.add(\">>>>>>>> B requested[\" + number + \"]: \" + n);\n+                                        }\n+\n+                                    });\n+                        }\n+\n+                    })\n+                    // take a number bigger than 2* RxRingBuffer.SIZE (used by OperatorMerge)\n+                    .take(RxRingBuffer.SIZE * 2 + 1)\n+                    // log count\n+                    .doOnNext(printCount())\n+                    // release latch\n+                    .doOnCompleted(new Action0() {\n+                        @Override\n+                        public void call() {\n+                            latch.countDown();\n+                        }\n+                    }).subscribe();\n+            boolean a = latch.await(2, TimeUnit.SECONDS);\n+            if (!a) {\n+                for (String s : messages) {\n+                    System.out.println(\"DEBUG => \" + s);\n+                }\n+            }\n+            assertTrue(a);\n+        //}\n+    }\n+\n+    private static Action1<Integer> printCount() {\n+        return new Action1<Integer>() {\n+            long count;\n+\n+            @Override\n+            public void call(Integer t1) {\n+                count++;\n+                System.out.println(\"count=\" + count);\n+            }\n+        };\n+    }\n+\n+    private static Action1<Integer> pauseForMs(final long time) {\n+        return new Action1<Integer>() {\n+            @Override\n+            public void call(Integer s) {\n+                try {\n+                    Thread.sleep(time);\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+    }\n }",
    "output": "Remove Request Batching in Merge\n\nRemoving the batching until we can find a correct way to do it.\n\nThe performance impact of this change is seen here:\n\nBenchmark                                          (size)   Mode   Samples          1.x    No Request Batching\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4585554.607    4666745.314 102%\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    51273.033      39922.246 78%\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       47.515         37.634 79%\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    90901.735      93454.726 103%\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        5.407          4.910 91%\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4181618.767    4173322.551 100%\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   422193.599     408972.130 97%\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    36886.812      36448.978 99%\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  4815945.720    4887943.643 101%\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       43.926         39.027 89%\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    72578.046      70412.656 97%\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3260.024       3064.403 94%\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  4678858.201    4808504.588 103%\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    34407.547      36364.476 106%\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       31.312         32.261 103%"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorScan.java b/src/main/java/rx/internal/operators/OperatorScan.java\n--- a/src/main/java/rx/internal/operators/OperatorScan.java\n+++ b/src/main/java/rx/internal/operators/OperatorScan.java\n@@ -147,19 +147,17 @@ public void request(long n) {\n                         if (once.compareAndSet(false, true)) {\n                             if (initialValue == NO_INITIAL_VALUE || n == Long.MAX_VALUE) {\n                                 producer.request(n);\n+                            } else if (n == 1) {\n+                                excessive.set(true);\n+                                producer.request(1); // request at least 1\n                             } else {\n-                                if (n == Long.MAX_VALUE) {\n-                                    producer.request(Long.MAX_VALUE);\n-                                } else if (n == 1) {\n-                                    excessive.set(true);\n-                                    producer.request(1); // request at least 1\n-                                } else {\n-                                    producer.request(n - 1);\n-                                }\n+                                // n != Long.MAX_VALUE && n != 1\n+                                producer.request(n - 1);\n                             }\n                         } else {\n                             // pass-thru after first time\n-                            if (excessive.compareAndSet(true, false) && n != Long.MAX_VALUE) {\n+                            if (n > 1 // avoid to request 0\n+                                    && excessive.compareAndSet(true, false) && n != Long.MAX_VALUE) {\n                                 producer.request(n - 1);\n                             } else {\n                                 producer.request(n);\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorScanTest.java b/src/test/java/rx/internal/operators/OperatorScanTest.java\n--- a/src/test/java/rx/internal/operators/OperatorScanTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorScanTest.java\n@@ -20,22 +20,22 @@\n import static org.mockito.Matchers.any;\n import static org.mockito.Matchers.anyInt;\n import static org.mockito.Matchers.anyString;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.*;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.MockitoAnnotations;\n \n import rx.Observable;\n import rx.Observer;\n+import rx.Producer;\n import rx.Subscriber;\n import rx.functions.Action2;\n import rx.functions.Func0;\n@@ -312,4 +312,52 @@ public Integer call(Integer t1, Integer t2) {\n         subscriber.assertTerminalEvent();\n         subscriber.assertNoErrors();\n     }\n+\n+    @Test\n+    public void testScanShouldNotRequestZero() {\n+        final AtomicReference<Producer> producer = new AtomicReference<Producer>();\n+        Observable<Integer> o = Observable.create(new Observable.OnSubscribe<Integer>() {\n+            @Override\n+            public void call(final Subscriber subscriber) {\n+                Producer p = spy(new Producer() {\n+\n+                    private AtomicBoolean requested = new AtomicBoolean(false);\n+\n+                    @Override\n+                    public void request(long n) {\n+                        if (requested.compareAndSet(false, true)) {\n+                            subscriber.onNext(1);\n+                        } else {\n+                            subscriber.onCompleted();\n+                        }\n+                    }\n+                });\n+                producer.set(p);\n+                subscriber.setProducer(p);\n+            }\n+        }).scan(100, new Func2<Integer, Integer, Integer>() {\n+\n+            @Override\n+            public Integer call(Integer t1, Integer t2) {\n+                return t1 + t2;\n+            }\n+\n+        });\n+\n+        o.subscribe(new TestSubscriber<Integer>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(1);\n+            }\n+\n+            @Override\n+            public void onNext(Integer integer) {\n+                request(1);\n+            }\n+        });\n+\n+        verify(producer.get(), never()).request(0);\n+        verify(producer.get(), times(2)).request(1);\n+    }\n }",
    "output": "Fix 'request(0)' issue in Scan"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorOnBackpressureBlock.java b/src/main/java/rx/internal/operators/OperatorOnBackpressureBlock.java\n--- a/src/main/java/rx/internal/operators/OperatorOnBackpressureBlock.java\n+++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureBlock.java\n@@ -58,6 +58,9 @@ void init() {\n             child.setProducer(new Producer() {\n                 @Override\n                 public void request(long n) {\n+                    if (n == 0) {\n+                        return;\n+                    }\n                     synchronized (BlockingSubscriber.this) {\n                         if (n == Long.MAX_VALUE || requestedCount == Long.MAX_VALUE) {\n                             requestedCount = Long.MAX_VALUE;\n@@ -95,28 +98,41 @@ public void onCompleted() {\n         }\n         void drain() {\n             long n;\n+            boolean term;\n             synchronized (this) {\n                 if (emitting) {\n                     return;\n                 }\n                 emitting = true;\n                 n = requestedCount;\n+                term = terminated;\n             }\n             boolean skipFinal = false;\n             try {\n+                Subscriber<? super T> child = this.child;\n+                BlockingQueue<Object> queue = this.queue;\n                 while (true) {\n                     int emitted = 0;\n-                    while (n > 0) {\n-                        Object o = queue.poll();\n-                        if (o == null) {\n-                            if (terminated) {\n-                                if (exception != null) {\n-                                    child.onError(exception);\n+                    while (n > 0 || term) {\n+                        Object o;\n+                        if (term) {\n+                            o = queue.peek();\n+                            if (o == null) {\n+                                Throwable e = exception;\n+                                if (e != null) {\n+                                    child.onError(e);\n                                 } else {\n                                     child.onCompleted();\n                                 }\n+                                skipFinal = true;\n                                 return;\n                             }\n+                            if (n == 0) {\n+                                break;\n+                            }\n+                        }\n+                        o = queue.poll();\n+                        if (o == null) {\n                             break;\n                         } else {\n                             child.onNext(nl.getValue(o));\n@@ -125,23 +141,25 @@ void drain() {\n                         }\n                     }\n                     synchronized (this) {\n+                        term = terminated;\n+                        boolean more = queue.peek() != null;\n                         // if no backpressure below\n                         if (requestedCount == Long.MAX_VALUE) {\n                             // no new data arrived since the last poll\n-                            if (queue.peek() == null) {\n+                            if (!more && !term) {\n                                 skipFinal = true;\n                                 emitting = false;\n                                 return;\n                             }\n                             n = Long.MAX_VALUE;\n                         } else {\n-                            if (emitted == 0) {\n+                            requestedCount -= emitted;\n+                            n = requestedCount;\n+                            if ((n == 0 || !more) && (!term || more)) {\n                                 skipFinal = true;\n                                 emitting = false;\n                                 return;\n                             }\n-                            requestedCount -= emitted;\n-                            n = requestedCount;\n                         }\n                     }\n                 }\n\ndiff --git a/src/test/java/rx/internal/operators/OnBackpressureBlockTest.java b/src/test/java/rx/internal/operators/OnBackpressureBlockTest.java\n--- a/src/test/java/rx/internal/operators/OnBackpressureBlockTest.java\n+++ b/src/test/java/rx/internal/operators/OnBackpressureBlockTest.java\n@@ -16,11 +16,13 @@\n \n package rx.internal.operators;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.*;\n \n import java.util.Arrays;\n-\n-import static org.junit.Assert.*;\n+import java.util.Collections;\n \n import org.junit.Test;\n \n@@ -34,6 +36,7 @@\n import rx.observers.TestObserver;\n import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n+import rx.subjects.PublishSubject;\n \n /**\n  * Test the onBackpressureBlock() behavior.\n@@ -161,13 +164,15 @@ public void onStart() {\n         Thread.sleep(WAIT);\n \n         o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n-        o.assertNoErrors();\n-        assertTrue(o.getOnCompletedEvents().isEmpty());\n+        o.assertTerminalEvent();\n+        assertEquals(1, o.getOnErrorEvents().size());\n+        assertTrue(o.getOnErrorEvents().get(0) instanceof TestException);\n \n         o.requestMore(10);\n         \n         Thread.sleep(WAIT);\n         \n+        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n         o.assertTerminalEvent();\n         assertEquals(1, o.getOnErrorEvents().size());\n         assertTrue(o.getOnErrorEvents().get(0) instanceof TestException);\n@@ -259,4 +264,84 @@ public void testTakeWorksSubscriberRequestUnlimitedBufferedException() {\n         o.assertNoErrors();\n         o.assertTerminalEvent();\n     }\n+    @Test(timeout = 10000)\n+    public void testOnCompletedDoesntWaitIfNoEvents() {\n+        \n+        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {\n+            @Override\n+            public void onStart() {\n+                request(0); // make sure it doesn't start in unlimited mode\n+            }\n+        };\n+        Observable.<Integer>empty().onBackpressureBlock(2).subscribe(o);\n+        \n+        o.assertNoErrors();\n+        o.assertTerminalEvent();\n+        o.assertReceivedOnNext(Collections.<Integer>emptyList());\n+    }\n+    @Test(timeout = 10000)\n+    public void testOnCompletedDoesWaitIfEvents() {\n+        \n+        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {\n+            @Override\n+            public void onStart() {\n+                request(0); // make sure it doesn't start in unlimited mode\n+            }\n+        };\n+        Observable.just(1).onBackpressureBlock(2).subscribe(o);\n+        \n+        o.assertReceivedOnNext(Collections.<Integer>emptyList());\n+        assertTrue(o.getOnErrorEvents().isEmpty());\n+        assertTrue(o.getOnCompletedEvents().isEmpty());\n+    }\n+    @Test(timeout = 10000)\n+    public void testOnCompletedDoesntWaitIfNoEvents2() {\n+        final PublishSubject<Integer> ps = PublishSubject.create();\n+        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {\n+            @Override\n+            public void onStart() {\n+                request(0); // make sure it doesn't start in unlimited mode\n+            }\n+            @Override\n+            public void onNext(Integer t) {\n+                super.onNext(t);\n+                ps.onCompleted(); // as if an async completion arrived while in the loop\n+            }\n+        };\n+        ps.onBackpressureBlock(2).unsafeSubscribe(o);\n+        ps.onNext(1);\n+        o.requestMore(1);\n+        \n+        o.assertNoErrors();\n+        o.assertTerminalEvent();\n+        o.assertReceivedOnNext(Arrays.asList(1));\n+    }\n+    @Test(timeout = 10000)\n+    public void testOnCompletedDoesntWaitIfNoEvents3() {\n+        final PublishSubject<Integer> ps = PublishSubject.create();\n+        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {\n+            boolean once = true;\n+            @Override\n+            public void onStart() {\n+                request(0); // make sure it doesn't start in unlimited mode\n+            }\n+            @Override\n+            public void onNext(Integer t) {\n+                super.onNext(t);\n+                if (once) {\n+                    once = false;\n+                    ps.onNext(2);\n+                    ps.onCompleted(); // as if an async completion arrived while in the loop\n+                    requestMore(1);\n+                }\n+            }\n+        };\n+        ps.onBackpressureBlock(3).unsafeSubscribe(o);\n+        ps.onNext(1);\n+        o.requestMore(1);\n+        \n+        o.assertNoErrors();\n+        o.assertTerminalEvent();\n+        o.assertReceivedOnNext(Arrays.asList(1, 2));\n+    }\n }",
    "output": "Fix race & late termination condition"
  },
  {
    "input": "diff --git a/src/perf/java/rx/operators/OperatorSerializePerf.java b/src/perf/java/rx/operators/OperatorSerializePerf.java\n--- a/src/perf/java/rx/operators/OperatorSerializePerf.java\n+++ b/src/perf/java/rx/operators/OperatorSerializePerf.java\n@@ -17,20 +17,13 @@\n \n import java.util.concurrent.TimeUnit;\n \n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.*;\n import org.openjdk.jmh.infra.Blackhole;\n \n-import rx.Observable;\n+import rx.*;\n import rx.Observable.OnSubscribe;\n-import rx.Subscriber;\n-import rx.jmh.InputWithIncrementingInteger;\n-import rx.jmh.LatchedObserver;\n+import rx.functions.Func1;\n+import rx.jmh.*;\n import rx.schedulers.Schedulers;\n \n @BenchmarkMode(Mode.Throughput)\n@@ -81,7 +74,7 @@ public void call(Subscriber<? super Integer> s) {\n     }\n \n     @State(Scope.Thread)\n-    public static class InputWithInterval extends InputWithIncrementingInteger {\n+    public static class InputWithInterval extends InputWithIncrementingInteger implements Func1<Long, Integer> {\n \n         @Param({ \"1\", \"1000\" })\n         public int size;\n@@ -97,7 +90,11 @@ public int getSize() {\n         public void setup(Blackhole bh) {\n             super.setup(bh);\n \n-            interval = Observable.timer(0, 1, TimeUnit.MILLISECONDS).take(size).cast(Integer.class);\n+            interval = Observable.timer(0, 1, TimeUnit.MILLISECONDS).take(size).map(this);\n+        }\n+        @Override\n+        public Integer call(Long t1) {\n+            return t1.intValue();\n         }\n     }\n ",
    "output": "Fix timer cast-to-int crash causing incorrect benchmark"
  },
  {
    "input": "diff --git a/src/main/java/rx/subscriptions/Subscriptions.java b/src/main/java/rx/subscriptions/Subscriptions.java\n--- a/src/main/java/rx/subscriptions/Subscriptions.java\n+++ b/src/main/java/rx/subscriptions/Subscriptions.java\n@@ -46,38 +46,8 @@ public static Subscription empty() {\n      * @return {@link Subscription}\n      */\n     public static Subscription create(final Action0 unsubscribe) {\n-        return new ActionSubscription(unsubscribe);\n+        return BooleanSubscription.create(unsubscribe);\n     }\n-    /**\n-     * Subscription that delegates the unsubscription action to an Action0 instance\n-     */\n-    private static final class ActionSubscription implements Subscription {\n-        volatile Action0 actual;\n-        static final AtomicReferenceFieldUpdater<ActionSubscription, Action0> ACTUAL_UPDATER\n-                = AtomicReferenceFieldUpdater.newUpdater(ActionSubscription.class, Action0.class, \"actual\");\n-        public ActionSubscription(Action0 action) {\n-            this.actual = action != null ? action : Actions.empty();\n-        }\n-        @Override\n-        public boolean isUnsubscribed() {\n-            return actual == UNSUBSCRIBED_ACTION;\n-        }\n-        @Override\n-        public void unsubscribe() {\n-            Action0 a = ACTUAL_UPDATER.getAndSet(this, UNSUBSCRIBED_ACTION);\n-            a.call();\n-        }\n-        /** The no-op unique action indicating an unsubscribed state. */\n-        private static final Unsubscribed UNSUBSCRIBED_ACTION = new Unsubscribed();\n-        /** Naming classes helps with debugging. */\n-        private static final class Unsubscribed implements Action0 {\n-            @Override\n-            public void call() {\n-\n-            }\n-        }\n-    }\n-    \n \n     /**\n      * Converts a {@link Future} into a {@link Subscription} and cancels it when unsubscribed.",
    "output": "Remove ActionSubscription"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n@@ -98,7 +98,9 @@ public void request(long n) {\n                         }\n \n                         if (!it.hasNext()) {\n-                            o.onCompleted();\n+                            if (!o.isUnsubscribed()) {\n+                                o.onCompleted();\n+                            }\n                             return;\n                         }\n                         if (REQUESTED_UPDATER.addAndGet(this, -r) == 0) {\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorMerge.java b/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -186,7 +186,8 @@ private void handleNewSource(Observable<? extends T> t) {\n             InnerSubscriber<T> i = new InnerSubscriber<T>(this, producerIfNeeded);\n             i.sindex = childrenSubscribers.add(i);\n             t.unsafeSubscribe(i);\n-            request(1);\n+            if (!isUnsubscribed())\n+                request(1);\n         }\n \n         private void handleScalarSynchronousObservable(ScalarSynchronousObservable<? extends T> t) {",
    "output": "Remove extraneous request(n) and onCompleted() calls when unsubscribed"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorAll.java b/src/main/java/rx/internal/operators/OperatorAll.java\n--- a/src/main/java/rx/internal/operators/OperatorAll.java\n+++ b/src/main/java/rx/internal/operators/OperatorAll.java\n@@ -34,7 +34,7 @@ public OperatorAll(Func1<? super T, Boolean> predicate) {\n \n     @Override\n     public Subscriber<? super T> call(final Subscriber<? super Boolean> child) {\n-        return new Subscriber<T>(child) {\n+        Subscriber<T> s = new Subscriber<T>() {\n             boolean done;\n \n             @Override\n@@ -65,5 +65,7 @@ public void onCompleted() {\n                 }\n             }\n         };\n+        child.add(s);\n+        return s;\n     }\n }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorAllTest.java b/src/test/java/rx/internal/operators/OperatorAllTest.java\n--- a/src/test/java/rx/internal/operators/OperatorAllTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorAllTest.java\n@@ -15,19 +15,17 @@\n  */\n package rx.internal.operators;\n \n-import static org.junit.Assert.assertFalse;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n \n import org.junit.Test;\n \n-import rx.Observable;\n-import rx.Observer;\n+import rx.*;\n import rx.functions.Func1;\n \n-import java.util.Arrays;\n-\n public class OperatorAllTest {\n \n     @Test\n@@ -113,4 +111,21 @@ public Boolean call(Integer i) {\n         });\n         assertFalse(allOdd.toBlocking().first());\n     }\n+    @Test(timeout = 5000)\n+    public void testIssue1935NoUnsubscribeDownstream() {\n+        Observable<Integer> source = Observable.just(1)\n+            .all(new Func1<Object, Boolean>() {\n+                @Override\n+                public Boolean call(Object t1) {\n+                    return false;\n+                }\n+            })\n+            .flatMap(new Func1<Boolean, Observable<Integer>>() {\n+                @Override\n+                public Observable<Integer> call(Boolean t1) {\n+                    return Observable.just(2).delay(500, TimeUnit.MILLISECONDS);\n+                }\n+        });\n+        assertEquals((Object)2, source.toBlocking().first());\n+    }\n }",
    "output": "Fix OperatorAll unsubscribing downstream"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/schedulers/NewThreadWorker.java b/src/main/java/rx/internal/schedulers/NewThreadWorker.java\n--- a/src/main/java/rx/internal/schedulers/NewThreadWorker.java\n+++ b/src/main/java/rx/internal/schedulers/NewThreadWorker.java\n@@ -37,8 +37,8 @@ public NewThreadWorker(ThreadFactory threadFactory) {\n         // Java 7+: cancelled future tasks can be removed from the executor thus avoiding memory leak\n         for (Method m : executor.getClass().getMethods()) {\n             if (m.getName().equals(\"setRemoveOnCancelPolicy\")\n-                    && m.getParameterCount() == 1\n-                    && m.getParameters()[0].getType() == Boolean.TYPE) {\n+                    && m.getParameterTypes().length == 1\n+                    && m.getParameterTypes()[0] == Boolean.TYPE) {\n                 try {\n                     m.invoke(executor, true);\n                 } catch (Exception ex) {",
    "output": "Fix wrong Java 8 reflection API call"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java b/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java\n--- a/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java\n+++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java\n@@ -24,14 +24,14 @@\n import rx.Observable.Operator;\n import rx.Producer;\n import rx.Subscriber;\n-import rx.functions.Func0;\n+import rx.functions.Action0;\n \n public class OperatorOnBackpressureBuffer<T> implements Operator<T, T> {\n \n     private final NotificationLite<T> on = NotificationLite.instance();\n \n     private final Long capacity;\n-    private final Func0 onOverflow;\n+    private final Action0 onOverflow;\n \n     public OperatorOnBackpressureBuffer() {\n         this.capacity = null;\n@@ -42,7 +42,7 @@ public OperatorOnBackpressureBuffer(long capacity) {\n         this(capacity, null);\n     }\n \n-    public OperatorOnBackpressureBuffer(long capacity, Func0<Void> onOverflow) {\n+    public OperatorOnBackpressureBuffer(long capacity, Action0 onOverflow) {\n         if (capacity <= 0) {\n             throw new IllegalArgumentException(\"Buffer capacity must be > 0\");\n         }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java b/src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java\n--- a/src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java\n@@ -15,6 +15,9 @@\n  */\n package rx.internal.operators;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n import java.nio.BufferOverflowException;\n import java.util.concurrent.CountDownLatch;\n \n@@ -25,14 +28,11 @@\n import rx.Observer;\n import rx.Subscriber;\n import rx.Subscription;\n-import rx.functions.Func0;\n+import rx.functions.Action0;\n import rx.observables.ConnectableObservable;\n import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n public class OperatorOnBackpressureBufferTest {\n \n     @Test\n@@ -126,11 +126,10 @@ public void onNext(Long t) {\n                     .publish();\n         final ConnectableObservable<Long> batch =\n             infinite.subscribeOn(Schedulers.computation())\n-                    .onBackpressureBuffer(100, new Func0<Void>() {\n+                    .onBackpressureBuffer(100, new Action0() {\n                         @Override\n-                        public Void call() {\n+                        public void call() {\n                             l3.countDown();\n-                            return null;\n                         }\n                     }).publish();\n         Subscription s = batch.subscribe(ts);",
    "output": "Use Action instead of Func0<Void>\n\nAs per https://github.com/ReactiveX/RxJava/pull/1899#discussion_r20863956"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeRedo.java b/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n@@ -225,14 +225,19 @@ public void onError(Throwable e) {\n \n                     @Override\n                     public void onNext(T v) {\n-                        consumerCapacity.decrementAndGet();\n+                        if (consumerCapacity.get() != Long.MAX_VALUE) {\n+                            consumerCapacity.decrementAndGet();\n+                        }\n                         child.onNext(v);\n                     }\n \n                     @Override\n                     public void setProducer(Producer producer) {\n                         currentProducer.set(producer);\n-                        producer.request(consumerCapacity.get());\n+                        long c = consumerCapacity.get();\n+                        if (c > 0) {\n+                            producer.request(c);\n+                        }\n                     }\n                 };\n                 // new subscription each time so if it unsubscribes itself it does not prevent retries\n@@ -321,7 +326,7 @@ public void request(final long n) {\n                 long c = consumerCapacity.getAndAdd(n);\n                 Producer producer = currentProducer.get();\n                 if (producer != null) {\n-                    producer.request(c + n);\n+                    producer.request(n);\n                 } else\n                 if (c == 0 && resumeBoundary.compareAndSet(true, false)) {\n                     worker.schedule(subscribeToSource);\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorRetryTest.java b/src/test/java/rx/internal/operators/OperatorRetryTest.java\n--- a/src/test/java/rx/internal/operators/OperatorRetryTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorRetryTest.java\n@@ -15,40 +15,26 @@\n  */\n package rx.internal.operators;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n import static org.mockito.Matchers.any;\n-import static org.mockito.Mockito.doThrow;\n-import static org.mockito.Mockito.inOrder;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.*;\n \n import org.junit.Test;\n-import org.mockito.InOrder;\n-import org.mockito.Mockito;\n+import org.mockito.*;\n \n-import rx.Observable;\n+import rx.*;\n import rx.Observable.OnSubscribe;\n-import rx.Observer;\n-import rx.Subscriber;\n-import rx.Subscription;\n-import rx.functions.Action0;\n-import rx.functions.Action1;\n-import rx.functions.Func1;\n-import rx.functions.Func2;\n+import rx.functions.*;\n import rx.internal.util.RxRingBuffer;\n import rx.observables.GroupedObservable;\n import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n import rx.subjects.PublishSubject;\n import rx.subscriptions.Subscriptions;\n \n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n public class OperatorRetryTest {\n \n     @Test\n@@ -403,18 +389,38 @@ public static class FuncWithErrors implements Observable.OnSubscribe<String> {\n         }\n \n         @Override\n-        public void call(Subscriber<? super String> o) {\n-            o.onNext(\"beginningEveryTime\");\n-            if (count.getAndIncrement() < numFailures) {\n-                System.out.println(\"FuncWithErrors @ \" + count.get()); \n-                o.onError(new RuntimeException(\"forced failure: \" + count.get()));\n-            } else {\n-                System.out.println(\"FuncWithErrors @ onSuccessOnly\"); \n-                o.onNext(\"onSuccessOnly\");\n-                System.out.println(\"FuncWithErrors @ onCompleted\"); \n-                o.onCompleted();\n-                System.out.println(\"FuncWithErrors !\"); \n-            }\n+        public void call(final Subscriber<? super String> o) {\n+            o.setProducer(new Producer() {\n+                final AtomicLong req = new AtomicLong();\n+                @Override\n+                public void request(long n) {\n+                    if (n == Long.MAX_VALUE) {\n+                        o.onNext(\"beginningEveryTime\");\n+                        if (count.getAndIncrement() < numFailures) {\n+                            o.onError(new RuntimeException(\"forced failure: \" + count.get()));\n+                        } else {\n+                            o.onNext(\"onSuccessOnly\");\n+                            o.onCompleted();\n+                        }\n+                        return;\n+                    }\n+                    if (n > 0 && req.getAndAdd(1) == 0) {\n+                        int i = count.getAndIncrement();\n+                        if (i < numFailures) {\n+                            o.onNext(\"beginningEveryTime\");\n+                            o.onError(new RuntimeException(\"forced failure: \" + count.get()));\n+                        } else\n+                        if (i == numFailures) {\n+                            o.onNext(\"beginningEveryTime\");\n+                        } else\n+                        if (i > numFailures) {\n+                            o.onNext(\"onSuccessOnly\");\n+                            o.onCompleted();\n+                        }\n+                        req.decrementAndGet();\n+                    }\n+                }\n+            });\n         }\n     }\n \n@@ -668,26 +674,28 @@ public void testTimeoutWithRetry() {\n         assertEquals(\"Start 6 threads, retry 5 then fail on 6\", 6, so.efforts.get());\n     }\n     \n-    @Test(timeout = 3000)\n+    @Test(timeout = 10000)\n     public void testRetryWithBackpressure() {\n-        @SuppressWarnings(\"unchecked\")\n-        Observer<String> observer = mock(Observer.class);\n-        int NUM_RETRIES = RxRingBuffer.SIZE * 2;\n-        Observable<String> origin = Observable.create(new FuncWithErrors(NUM_RETRIES));\n-        TestSubscriber<String> ts = new TestSubscriber<String>(observer);\n-        origin.retry().observeOn(Schedulers.computation()).unsafeSubscribe(ts);\n-        ts.awaitTerminalEvent();\n-        \n-        InOrder inOrder = inOrder(observer);\n-        // should show 3 attempts\n-        inOrder.verify(observer, times(NUM_RETRIES + 1)).onNext(\"beginningEveryTime\");\n-        // should have no errors\n-        inOrder.verify(observer, never()).onError(any(Throwable.class));\n-        // should have a single success\n-        inOrder.verify(observer, times(1)).onNext(\"onSuccessOnly\");\n-        // should have a single successful onCompleted\n-        inOrder.verify(observer, times(1)).onCompleted();\n-        inOrder.verifyNoMoreInteractions();\n+        for (int i = 0; i < 200; i++) {\n+            @SuppressWarnings(\"unchecked\")\n+            Observer<String> observer = mock(Observer.class);\n+            int NUM_RETRIES = RxRingBuffer.SIZE * 2;\n+            Observable<String> origin = Observable.create(new FuncWithErrors(NUM_RETRIES));\n+            TestSubscriber<String> ts = new TestSubscriber<String>(observer);\n+            origin.retry().observeOn(Schedulers.computation()).unsafeSubscribe(ts);\n+            ts.awaitTerminalEvent();\n+            \n+            InOrder inOrder = inOrder(observer);\n+            // should have no errors\n+            verify(observer, never()).onError(any(Throwable.class));\n+            // should show NUM_RETRIES attempts\n+            inOrder.verify(observer, times(NUM_RETRIES + 1)).onNext(\"beginningEveryTime\");\n+            // should have a single success\n+            inOrder.verify(observer, times(1)).onNext(\"onSuccessOnly\");\n+            // should have a single successful onCompleted\n+            inOrder.verify(observer, times(1)).onCompleted();\n+            inOrder.verifyNoMoreInteractions();\n+        }\n     }\n     @Test(timeout = 3000)\n     public void testIssue1900() throws InterruptedException {",
    "output": "Fix retry without backpressure & test function to support bp"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorScan.java b/src/main/java/rx/internal/operators/OperatorScan.java\n--- a/src/main/java/rx/internal/operators/OperatorScan.java\n+++ b/src/main/java/rx/internal/operators/OperatorScan.java\n@@ -140,17 +140,30 @@ public void setProducer(final Producer producer) {\n \n                     final AtomicBoolean once = new AtomicBoolean();\n \n+                    final AtomicBoolean excessive = new AtomicBoolean();\n+\n                     @Override\n                     public void request(long n) {\n                         if (once.compareAndSet(false, true)) {\n                             if (initialValue == NO_INITIAL_VALUE || n == Long.MAX_VALUE) {\n                                 producer.request(n);\n                             } else {\n-                                producer.request(n - 1);\n+                                if (n == Long.MAX_VALUE) {\n+                                    producer.request(Long.MAX_VALUE);\n+                                } else if (n == 1) {\n+                                    excessive.set(true);\n+                                    producer.request(1); // request at least 1\n+                                } else {\n+                                    producer.request(n - 1);\n+                                }\n                             }\n                         } else {\n                             // pass-thru after first time\n-                            producer.request(n);\n+                            if (excessive.compareAndSet(true, false) && n != Long.MAX_VALUE) {\n+                                producer.request(n - 1);\n+                            } else {\n+                                producer.request(n);\n+                            }\n                         }\n                     }\n                 });\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorScanTest.java b/src/test/java/rx/internal/operators/OperatorScanTest.java\n--- a/src/test/java/rx/internal/operators/OperatorScanTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorScanTest.java\n@@ -295,4 +295,21 @@ public void call(List<Integer> list, Integer t2) {\n         assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), o.toBlocking().single());\n         assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), o.toBlocking().single());\n     }\n+\n+    @Test\n+    public void testScanWithRequestOne() {\n+        Observable<Integer> o = Observable.just(1, 2).scan(0, new Func2<Integer, Integer, Integer>() {\n+\n+            @Override\n+            public Integer call(Integer t1, Integer t2) {\n+                return t1 + t2;\n+            }\n+\n+        }).take(1);\n+        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();\n+        o.subscribe(subscriber);\n+        subscriber.assertReceivedOnNext(Arrays.asList(0));\n+        subscriber.assertTerminalEvent();\n+        subscriber.assertNoErrors();\n+    }\n }",
    "output": "Fix the bug that Scan may request 0 when n is 1"
  },
  {
    "input": "diff --git a/src/main/java/rx/schedulers/TestScheduler.java b/src/main/java/rx/schedulers/TestScheduler.java\n--- a/src/main/java/rx/schedulers/TestScheduler.java\n+++ b/src/main/java/rx/schedulers/TestScheduler.java\n@@ -111,7 +111,8 @@ private void triggerActions(long targetTimeInNanos) {\n             if (current.time > targetTimeInNanos) {\n                 break;\n             }\n-            time = current.time;\n+            // if scheduled time is 0 (immediate) use current virtual time\n+            time = current.time == 0 ? time : current.time;\n             queue.remove();\n \n             // Only execute if not unsubscribed\n@@ -129,7 +130,7 @@ public Worker createWorker() {\n \n     private final class InnerTestScheduler extends Worker {\n \n-        private BooleanSubscription s = new BooleanSubscription();\n+        private final BooleanSubscription s = new BooleanSubscription();\n \n         @Override\n         public void unsubscribe() {\n\ndiff --git a/src/test/java/rx/schedulers/TestSchedulerTest.java b/src/test/java/rx/schedulers/TestSchedulerTest.java\n--- a/src/test/java/rx/schedulers/TestSchedulerTest.java\n+++ b/src/test/java/rx/schedulers/TestSchedulerTest.java\n@@ -29,7 +29,10 @@\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n \n+import rx.Observable;\n+import rx.Observable.OnSubscribe;\n import rx.Scheduler;\n+import rx.Subscriber;\n import rx.Subscription;\n import rx.functions.Action0;\n import rx.functions.Func1;\n@@ -160,4 +163,42 @@ public void call() {\n         assertEquals(0, counter.get());\n     }\n \n+    @Test\n+    public final void testNestedSchedule() {\n+        final TestScheduler scheduler = new TestScheduler();\n+        final Scheduler.Worker inner = scheduler.createWorker();\n+        final Action0 calledOp = mock(Action0.class);\n+\n+        Observable<Object> poller;\n+        poller = Observable.create(new OnSubscribe<Object>() {\n+            @Override\n+            public void call(final Subscriber<? super Object> aSubscriber) {\n+                inner.schedule(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        if (!aSubscriber.isUnsubscribed()) {\n+                            calledOp.call();\n+                            inner.schedule(this, 5, TimeUnit.SECONDS);\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+\n+        InOrder inOrder = Mockito.inOrder(calledOp);\n+\n+        Subscription sub;\n+        sub = poller.subscribe();\n+\n+        scheduler.advanceTimeTo(6, TimeUnit.SECONDS);\n+        inOrder.verify(calledOp, times(2)).call();\n+\n+        sub.unsubscribe();\n+        scheduler.advanceTimeTo(11, TimeUnit.SECONDS);\n+        inOrder.verify(calledOp, never()).call();\n+\n+        sub = poller.subscribe();\n+        scheduler.advanceTimeTo(12, TimeUnit.SECONDS);\n+        inOrder.verify(calledOp, times(1)).call();\n+    }\n }",
    "output": "Fix TestScheduler Handling of Immediate vs Virtual Time"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -12,142 +12,20 @@\n  */\n package rx;\n \n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-\n-import rx.exceptions.Exceptions;\n-import rx.exceptions.OnErrorNotImplementedException;\n-import rx.functions.Action0;\n-import rx.functions.Action1;\n-import rx.functions.Action2;\n-import rx.functions.Func0;\n-import rx.functions.Func1;\n-import rx.functions.Func2;\n-import rx.functions.Func3;\n-import rx.functions.Func4;\n-import rx.functions.Func5;\n-import rx.functions.Func6;\n-import rx.functions.Func7;\n-import rx.functions.Func8;\n-import rx.functions.Func9;\n-import rx.functions.FuncN;\n-import rx.functions.Functions;\n-import rx.internal.operators.OnSubscribeAmb;\n-import rx.internal.operators.OnSubscribeCache;\n-import rx.internal.operators.OnSubscribeCombineLatest;\n-import rx.internal.operators.OnSubscribeDefer;\n-import rx.internal.operators.OnSubscribeDelaySubscription;\n-import rx.internal.operators.OnSubscribeDelaySubscriptionWithSelector;\n-import rx.internal.operators.OnSubscribeFromIterable;\n-import rx.internal.operators.OnSubscribeGroupJoin;\n-import rx.internal.operators.OnSubscribeJoin;\n-import rx.internal.operators.OnSubscribeMulticastSelector;\n-import rx.internal.operators.OnSubscribeRange;\n-import rx.internal.operators.OnSubscribeRedo;\n-import rx.internal.operators.OnSubscribeTimerOnce;\n-import rx.internal.operators.OnSubscribeTimerPeriodically;\n-import rx.internal.operators.OnSubscribeToObservableFuture;\n-import rx.internal.operators.OnSubscribeUsing;\n-import rx.internal.operators.OperatorAll;\n-import rx.internal.operators.OperatorAny;\n-import rx.internal.operators.OperatorAsObservable;\n-import rx.internal.operators.OperatorBufferWithSingleObservable;\n-import rx.internal.operators.OperatorBufferWithSize;\n-import rx.internal.operators.OperatorBufferWithStartEndObservable;\n-import rx.internal.operators.OperatorBufferWithTime;\n-import rx.internal.operators.OperatorCast;\n-import rx.internal.operators.OperatorConcat;\n-import rx.internal.operators.OperatorDebounceWithSelector;\n-import rx.internal.operators.OperatorDebounceWithTime;\n-import rx.internal.operators.OperatorDefaultIfEmpty;\n-import rx.internal.operators.OperatorDelay;\n-import rx.internal.operators.OperatorDelayWithSelector;\n-import rx.internal.operators.OperatorDematerialize;\n-import rx.internal.operators.OperatorDistinct;\n-import rx.internal.operators.OperatorDistinctUntilChanged;\n-import rx.internal.operators.OperatorDoOnEach;\n-import rx.internal.operators.OperatorDoOnSubscribe;\n-import rx.internal.operators.OperatorDoOnUnsubscribe;\n-import rx.internal.operators.OperatorElementAt;\n-import rx.internal.operators.OperatorFilter;\n-import rx.internal.operators.OperatorFinally;\n-import rx.internal.operators.OperatorGroupBy;\n-import rx.internal.operators.OperatorMap;\n-import rx.internal.operators.OperatorMapNotification;\n-import rx.internal.operators.OperatorMapPair;\n-import rx.internal.operators.OperatorMaterialize;\n-import rx.internal.operators.OperatorMerge;\n-import rx.internal.operators.OperatorMergeDelayError;\n-import rx.internal.operators.OperatorMergeMaxConcurrent;\n-import rx.internal.operators.OperatorMulticast;\n-import rx.internal.operators.OperatorObserveOn;\n-import rx.internal.operators.OperatorOnBackpressureBlock;\n-import rx.internal.operators.OperatorOnBackpressureBuffer;\n-import rx.internal.operators.OperatorOnBackpressureDrop;\n-import rx.internal.operators.OperatorOnErrorResumeNextViaFunction;\n-import rx.internal.operators.OperatorOnErrorResumeNextViaObservable;\n-import rx.internal.operators.OperatorOnErrorReturn;\n-import rx.internal.operators.OperatorOnExceptionResumeNextViaObservable;\n-import rx.internal.operators.OperatorPublish;\n-import rx.internal.operators.OperatorReplay;\n-import rx.internal.operators.OperatorRetryWithPredicate;\n-import rx.internal.operators.OperatorSampleWithObservable;\n-import rx.internal.operators.OperatorSampleWithTime;\n-import rx.internal.operators.OperatorScan;\n-import rx.internal.operators.OperatorSequenceEqual;\n-import rx.internal.operators.OperatorSerialize;\n-import rx.internal.operators.OperatorSingle;\n-import rx.internal.operators.OperatorSkip;\n-import rx.internal.operators.OperatorSkipLast;\n-import rx.internal.operators.OperatorSkipLastTimed;\n-import rx.internal.operators.OperatorSkipTimed;\n-import rx.internal.operators.OperatorSkipUntil;\n-import rx.internal.operators.OperatorSkipWhile;\n-import rx.internal.operators.OperatorSubscribeOn;\n-import rx.internal.operators.OperatorSwitch;\n-import rx.internal.operators.OperatorTake;\n-import rx.internal.operators.OperatorTakeLast;\n-import rx.internal.operators.OperatorTakeLastTimed;\n-import rx.internal.operators.OperatorTakeTimed;\n-import rx.internal.operators.OperatorTakeUntil;\n-import rx.internal.operators.OperatorTakeWhile;\n-import rx.internal.operators.OperatorThrottleFirst;\n-import rx.internal.operators.OperatorTimeInterval;\n-import rx.internal.operators.OperatorTimeout;\n-import rx.internal.operators.OperatorTimeoutWithSelector;\n-import rx.internal.operators.OperatorTimestamp;\n-import rx.internal.operators.OperatorToMap;\n-import rx.internal.operators.OperatorToMultimap;\n-import rx.internal.operators.OperatorToObservableList;\n-import rx.internal.operators.OperatorToObservableSortedList;\n-import rx.internal.operators.OperatorUnsubscribeOn;\n-import rx.internal.operators.OperatorWindowWithObservable;\n-import rx.internal.operators.OperatorWindowWithSize;\n-import rx.internal.operators.OperatorWindowWithStartEndObservable;\n-import rx.internal.operators.OperatorWindowWithTime;\n-import rx.internal.operators.OperatorZip;\n-import rx.internal.operators.OperatorZipIterable;\n-import rx.internal.util.RxRingBuffer;\n+import java.util.*;\n+import java.util.concurrent.*;\n+\n+import rx.exceptions.*;\n+import rx.functions.*;\n+import rx.internal.operators.*;\n import rx.internal.util.ScalarSynchronousObservable;\n import rx.internal.util.UtilityFunctions;\n-import rx.observables.BlockingObservable;\n-import rx.observables.ConnectableObservable;\n-import rx.observables.GroupedObservable;\n+\n+import rx.observables.*;\n import rx.observers.SafeSubscriber;\n-import rx.plugins.RxJavaObservableExecutionHook;\n-import rx.plugins.RxJavaPlugins;\n-import rx.schedulers.Schedulers;\n-import rx.schedulers.TimeInterval;\n-import rx.schedulers.Timestamped;\n-import rx.subjects.ReplaySubject;\n-import rx.subjects.Subject;\n+import rx.plugins.*;\n+import rx.schedulers.*;\n+import rx.subjects.*;\n import rx.subscriptions.Subscriptions;\n \n /**\n@@ -5211,7 +5089,7 @@ public final Observable<T> onBackpressureBlock(int maxQueueLength) {\n      * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Backpressure\">RxJava wiki: Backpressure</a>\n      */\n     public final Observable<T> onBackpressureBlock() {\n-        return onBackpressureBlock(RxRingBuffer.SIZE);\n+        return onBackpressureBlock(rx.internal.util.RxRingBuffer.SIZE);\n     }\n     \n     /**",
    "output": "Fix accidental import * expansion"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeRedo.java b/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n@@ -190,7 +190,7 @@ private OnSubscribeRedo(Observable<T> source, Func1<? super Observable<? extends\n     @Override\n     public void call(final Subscriber<? super T> child) {\n         final AtomicBoolean isLocked = new AtomicBoolean(true);\n-        final AtomicBoolean isStarted = new AtomicBoolean(false);\n+        final AtomicBoolean resumeBoundary = new AtomicBoolean(true);\n         // incremented when requests are made, decremented when requests are fulfilled\n         final AtomicLong consumerCapacity = new AtomicLong(0l);\n         final AtomicReference<Producer> currentProducer = new AtomicReference<Producer>();\n@@ -300,6 +300,8 @@ public void onNext(Object t) {\n                         if (!isLocked.get() && !child.isUnsubscribed()) {\n                             if (consumerCapacity.get() > 0) {\n                                 worker.schedule(subscribeToSource);\n+                            } else {\n+                                resumeBoundary.compareAndSet(false, true);\n                             }\n                         }\n                     }\n@@ -315,22 +317,17 @@ public void setProducer(Producer producer) {\n         child.setProducer(new Producer() {\n \n             @Override\n-            public void request(long n) {\n-                if (isStarted.compareAndSet(false, true)) {\n-                    consumerCapacity.set(n);\n+            public void request(final long n) {\n+                long c = consumerCapacity.getAndAdd(n);\n+                Producer producer = currentProducer.get();\n+                if (producer != null) {\n+                    producer.request(c + n);\n+                } else\n+                if (c == 0 && resumeBoundary.compareAndSet(true, false)) {\n                     worker.schedule(subscribeToSource);\n-                } else {\n-                    if (consumerCapacity.getAndAdd(n) == 0) {\n-                        // restart\n-                        worker.schedule(subscribeToSource);\n-                    } else {\n-                        if (currentProducer.get() != null) {\n-                            currentProducer.get().request(n);\n-                        }\n-                    }\n                 }\n             }\n         });\n-\n+        \n     }\n }\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorGroupBy.java b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n--- a/src/main/java/rx/internal/operators/OperatorGroupBy.java\n+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java\n@@ -306,7 +306,7 @@ private void pollQueue(GroupState<K, T> groupState) {\n         }\n \n         private void requestMoreIfNecessary() {\n-            if (REQUESTED.get(this) == 0) {\n+            if (REQUESTED.get(this) == 0 && terminated == 0) {\n                 long toRequest = MAX_QUEUE_SIZE - BUFFERED_COUNT.get(this);\n                 if (toRequest > 0 && REQUESTED.compareAndSet(this, 0, toRequest)) {\n                     request(toRequest);\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorRetryTest.java b/src/test/java/rx/internal/operators/OperatorRetryTest.java\n--- a/src/test/java/rx/internal/operators/OperatorRetryTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorRetryTest.java\n@@ -38,6 +38,7 @@\n import rx.functions.Func1;\n import rx.functions.Func2;\n import rx.internal.util.RxRingBuffer;\n+import rx.observables.GroupedObservable;\n import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n import rx.subjects.PublishSubject;\n@@ -405,10 +406,14 @@ public static class FuncWithErrors implements Observable.OnSubscribe<String> {\n         public void call(Subscriber<? super String> o) {\n             o.onNext(\"beginningEveryTime\");\n             if (count.getAndIncrement() < numFailures) {\n+                System.out.println(\"FuncWithErrors @ \" + count.get()); \n                 o.onError(new RuntimeException(\"forced failure: \" + count.get()));\n             } else {\n+                System.out.println(\"FuncWithErrors @ onSuccessOnly\"); \n                 o.onNext(\"onSuccessOnly\");\n+                System.out.println(\"FuncWithErrors @ onCompleted\"); \n                 o.onCompleted();\n+                System.out.println(\"FuncWithErrors !\"); \n             }\n         }\n     }\n@@ -663,7 +668,7 @@ public void testTimeoutWithRetry() {\n         assertEquals(\"Start 6 threads, retry 5 then fail on 6\", 6, so.efforts.get());\n     }\n     \n-    @Test\n+    @Test(timeout = 3000)\n     public void testRetryWithBackpressure() {\n         @SuppressWarnings(\"unchecked\")\n         Observer<String> observer = mock(Observer.class);\n@@ -684,5 +689,90 @@ public void testRetryWithBackpressure() {\n         inOrder.verify(observer, times(1)).onCompleted();\n         inOrder.verifyNoMoreInteractions();\n     }\n+    @Test(timeout = 3000)\n+    public void testIssue1900() throws InterruptedException {\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer = mock(Observer.class);\n+        final int NUM_MSG = 1034;\n+        final AtomicInteger count = new AtomicInteger();\n+\n+        Observable<String> origin = Observable.range(0, NUM_MSG)\n+                .map(new Func1<Integer, String>() {\n+                    @Override\n+                    public String call(Integer t1) {\n+                        return \"msg: \" + count.incrementAndGet();\n+                    }\n+                });\n+        \n+        origin.retry()\n+        .groupBy(new Func1<String, String>() {\n+            @Override\n+            public String call(String t1) {\n+                return t1;\n+            }\n+        })\n+        .flatMap(new Func1<GroupedObservable<String,String>, Observable<String>>() {\n+            @Override\n+            public Observable<String> call(GroupedObservable<String, String> t1) {\n+                return t1.take(1);\n+            }\n+        })\n+        .unsafeSubscribe(new TestSubscriber<String>(observer));\n+        \n+        InOrder inOrder = inOrder(observer);\n+        // should show 3 attempts\n+        inOrder.verify(observer, times(NUM_MSG)).onNext(any(java.lang.String.class));\n+        //        // should have no errors\n+        inOrder.verify(observer, never()).onError(any(Throwable.class));\n+        // should have a single success\n+        //inOrder.verify(observer, times(1)).onNext(\"onSuccessOnly\");\n+        // should have a single successful onCompleted\n+        inOrder.verify(observer, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n+    }\n+    @Test/*(timeout = 3000)*/\n+    public void testIssue1900SourceNotSupportingBackpressure() {\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer = mock(Observer.class);\n+        final int NUM_MSG = 1034;\n+        final AtomicInteger count = new AtomicInteger();\n+\n+        Observable<String> origin = Observable.create(new Observable.OnSubscribe<String>() {\n+\n+            @Override\n+            public void call(Subscriber<? super String> o) {\n+                for(int i=0; i<NUM_MSG; i++) {\n+                    o.onNext(\"msg:\" + count.incrementAndGet());\n+                }   \n+                o.onCompleted();\n+            }\n+        });\n+        \n+        origin.retry()\n+        .groupBy(new Func1<String, String>() {\n+            @Override\n+            public String call(String t1) {\n+                return t1;\n+            }\n+        })\n+        .flatMap(new Func1<GroupedObservable<String,String>, Observable<String>>() {\n+            @Override\n+            public Observable<String> call(GroupedObservable<String, String> t1) {\n+                return t1.take(1);\n+            }\n+        })\n+        .unsafeSubscribe(new TestSubscriber<String>(observer));\n+        \n+        InOrder inOrder = inOrder(observer);\n+        // should show 3 attempts\n+        inOrder.verify(observer, times(NUM_MSG)).onNext(any(java.lang.String.class));\n+        //        // should have no errors\n+        inOrder.verify(observer, never()).onError(any(Throwable.class));\n+        // should have a single success\n+        //inOrder.verify(observer, times(1)).onNext(\"onSuccessOnly\");\n+        // should have a single successful onCompleted\n+        inOrder.verify(observer, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n+    }\n \n }",
    "output": "Fix redo & groupBy backpressure management"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorMerge.java b/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -397,11 +397,13 @@ public Boolean call(InnerSubscriber<T> s) {\n \n         @Override\n         public void onError(Throwable e) {\n-            completed = true;\n-            innerError(e);\n+            if (!completed) {\n+                completed = true;\n+                innerError(e, true);\n+            }\n         }\n         \n-        private void innerError(Throwable e) {\n+        private void innerError(Throwable e, boolean parent) {\n             if (delayErrors) {\n                 synchronized (this) {\n                     if (exceptions == null) {\n@@ -411,7 +413,9 @@ private void innerError(Throwable e) {\n                 exceptions.add(e);\n                 boolean sendOnComplete = false;\n                 synchronized (this) {\n-                    wip--;\n+                    if (!parent) {\n+                        wip--;\n+                    }\n                     if ((wip == 0 && completed) || (wip < 0)) {\n                         sendOnComplete = true;\n                     }\n@@ -545,7 +549,7 @@ public void onNext(T t) {\n         public void onError(Throwable e) {\n             // it doesn't go through queues, it immediately onErrors and tears everything down\n             if (ONCE_TERMINATED.compareAndSet(this, 0, 1)) {\n-                parentSubscriber.innerError(e);\n+                parentSubscriber.innerError(e, false);\n             }\n         }\n \n\ndiff --git a/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java b/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n--- a/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n@@ -496,26 +496,32 @@ public void testErrorInParentObservable() {\n \n     @Test\n     public void testErrorInParentObservableDelayed() throws Exception {\n-        final TestASynchronous1sDelayedObservable o1 = new TestASynchronous1sDelayedObservable();\n-        final TestASynchronous1sDelayedObservable o2 = new TestASynchronous1sDelayedObservable();\n-        Observable<Observable<String>> parentObservable = Observable.create(new Observable.OnSubscribe<Observable<String>>() {\n-            @Override\n-            public void call(Subscriber<? super Observable<String>> op) {\n-                op.onNext(Observable.create(o1));\n-                op.onNext(Observable.create(o2));\n-                op.onError(new NullPointerException(\"throwing exception in parent\"));\n-            }\n-        });\n-\n-        TestSubscriber<String> ts = new TestSubscriber<String>(stringObserver);\n-        Observable<String> m = Observable.mergeDelayError(parentObservable);\n-        m.subscribe(ts);\n-        ts.awaitTerminalEvent(2000, TimeUnit.MILLISECONDS);\n-        ts.assertTerminalEvent();\n-\n-        verify(stringObserver, times(2)).onNext(\"hello\");\n-        verify(stringObserver, times(1)).onError(any(NullPointerException.class));\n-        verify(stringObserver, never()).onCompleted();\n+        for (int i = 0; i < 50; i++) {\n+            final TestASynchronous1sDelayedObservable o1 = new TestASynchronous1sDelayedObservable();\n+            final TestASynchronous1sDelayedObservable o2 = new TestASynchronous1sDelayedObservable();\n+            Observable<Observable<String>> parentObservable = Observable.create(new Observable.OnSubscribe<Observable<String>>() {\n+                @Override\n+                public void call(Subscriber<? super Observable<String>> op) {\n+                    op.onNext(Observable.create(o1));\n+                    op.onNext(Observable.create(o2));\n+                    op.onError(new NullPointerException(\"throwing exception in parent\"));\n+                }\n+            });\n+    \n+            @SuppressWarnings(\"unchecked\")\n+            Observer<String> stringObserver = mock(Observer.class);\n+            \n+            TestSubscriber<String> ts = new TestSubscriber<String>(stringObserver);\n+            Observable<String> m = Observable.mergeDelayError(parentObservable);\n+            m.subscribe(ts);\n+            System.out.println(\"testErrorInParentObservableDelayed | \" + i);\n+            ts.awaitTerminalEvent(2000, TimeUnit.MILLISECONDS);\n+            ts.assertTerminalEvent();\n+    \n+            verify(stringObserver, times(2)).onNext(\"hello\");\n+            verify(stringObserver, times(1)).onError(any(NullPointerException.class));\n+            verify(stringObserver, never()).onCompleted();\n+        }\n     }\n \n     private static class TestASynchronous1sDelayedObservable implements Observable.OnSubscribe<String> {",
    "output": "Fix incorrect error merging"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorBufferWithTime.java b/src/main/java/rx/internal/operators/OperatorBufferWithTime.java\n--- a/src/main/java/rx/internal/operators/OperatorBufferWithTime.java\n+++ b/src/main/java/rx/internal/operators/OperatorBufferWithTime.java\n@@ -72,15 +72,19 @@ public OperatorBufferWithTime(long timespan, long timeshift, TimeUnit unit, int\n     @Override\n     public Subscriber<? super T> call(final Subscriber<? super List<T>> child) {\n         final Worker inner = scheduler.createWorker();\n-        child.add(inner);\n+        SerializedSubscriber<List<T>> serialized = new SerializedSubscriber<List<T>>(child);\n         \n         if (timespan == timeshift) {\n-            ExactSubscriber bsub = new ExactSubscriber(new SerializedSubscriber<List<T>>(child), inner);\n+\t\t\tExactSubscriber bsub = new ExactSubscriber(serialized, inner);\n+            bsub.add(inner);\n+            child.add(bsub);\n             bsub.scheduleExact();\n             return bsub;\n         }\n         \n-        InexactSubscriber bsub = new InexactSubscriber(new SerializedSubscriber<List<T>>(child), inner);\n+        InexactSubscriber bsub = new InexactSubscriber(serialized, inner);\n+        bsub.add(inner);\n+        child.add(bsub);\n         bsub.startNewChunk();\n         bsub.scheduleChunk();\n         return bsub;\n@@ -94,7 +98,6 @@ final class InexactSubscriber extends Subscriber<T> {\n         /** Guarded by this. */\n         boolean done;\n         public InexactSubscriber(Subscriber<? super List<T>> child, Worker inner) {\n-            super(child);\n             this.child = child;\n             this.inner = inner;\n             this.chunks = new LinkedList<List<T>>();\n@@ -219,7 +222,6 @@ final class ExactSubscriber extends Subscriber<T> {\n         /** Guarded by this. */\n         boolean done;\n         public ExactSubscriber(Subscriber<? super List<T>> child, Worker inner) {\n-            super(child);\n             this.child = child;\n             this.inner = inner;\n             this.chunk = new ArrayList<T>();\n\ndiff --git a/src/main/java/rx/internal/operators/OperatorMerge.java b/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -501,7 +501,7 @@ public void request(long n) {\n                 REQUESTED.getAndAdd(this, n);\n                 if (ms.drainQueuesIfNeeded()) {\n                     boolean sendComplete = false;\n-                    synchronized (this) {\n+                    synchronized (ms) {\n                         if (ms.wip == 0 && ms.scalarValueQueue != null && ms.scalarValueQueue.isEmpty()) {\n                             sendComplete = true;\n                         }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorBufferTest.java b/src/test/java/rx/internal/operators/OperatorBufferTest.java\n--- a/src/test/java/rx/internal/operators/OperatorBufferTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorBufferTest.java\n@@ -981,4 +981,38 @@ public void onNext(List<Integer> t) {\n         });\n         assertEquals(Long.MAX_VALUE, requested.get());\n     }\n+    @Test(timeout = 3000)\n+    public void testBufferWithTimeDoesntUnsubscribeDownstream() throws InterruptedException {\n+    \t@SuppressWarnings(\"unchecked\")\n+    \tfinal Observer<Object> o = mock(Observer.class);\n+    \t\n+    \t\n+    \tfinal CountDownLatch cdl = new CountDownLatch(1);\n+    \tSubscriber<Object> s = new Subscriber<Object>() {\n+    \t\t@Override\n+    \t\tpublic void onNext(Object t) {\n+    \t\t\to.onNext(t);\n+    \t\t}\n+    \t\t@Override\n+    \t\tpublic void onError(Throwable e) {\n+    \t\t\to.onError(e);\n+    \t\t\tcdl.countDown();\n+    \t\t}\n+    \t\t@Override\n+    \t\tpublic void onCompleted() {\n+    \t\t\to.onCompleted();\n+    \t\t\tcdl.countDown();\n+    \t\t}\n+    \t};\n+    \t\n+    \tObservable.range(1, 1).delay(1, TimeUnit.SECONDS).buffer(2, TimeUnit.SECONDS).unsafeSubscribe(s);\n+    \t\n+    \tcdl.await();\n+    \t\n+    \tverify(o).onNext(Arrays.asList(1));\n+    \tverify(o).onCompleted();\n+    \tverify(o, never()).onError(any(Throwable.class));\n+    \t\n+    \tassertFalse(s.isUnsubscribed());\n+    }\n }",
    "output": "Fix unsubscription issue in buffer with time and a potential concurrency issue in merge"
  },
  {
    "input": "diff --git a/src/main/java/rx/Scheduler.java b/src/main/java/rx/Scheduler.java\n--- a/src/main/java/rx/Scheduler.java\n+++ b/src/main/java/rx/Scheduler.java\n@@ -135,18 +135,6 @@ public long now() {\n         }\n     }\n \n-    /**\n-     * Indicates the parallelism available to this Scheduler.\n-     * <p>\n-     * This defaults to {@code Runtime.getRuntime().availableProcessors()} but can be overridden for use cases\n-     * such as scheduling work on a computer cluster.\n-     * \n-     * @return the scheduler's available degree of parallelism\n-     */\n-    public int parallelism() {\n-        return Runtime.getRuntime().availableProcessors();\n-    }\n-\n     /**\n      * Gets the current time, in milliseconds, according to this Scheduler.\n      *",
    "output": "Remove Unused Scheduler.parallelism\n\nBefore hitting 1.0 removing this API as it is not used"
  },
  {
    "input": "diff --git a/src/main/java/rx/subjects/ReplaySubject.java b/src/main/java/rx/subjects/ReplaySubject.java\n--- a/src/main/java/rx/subjects/ReplaySubject.java\n+++ b/src/main/java/rx/subjects/ReplaySubject.java\n@@ -26,7 +26,6 @@\n import rx.exceptions.Exceptions;\n import rx.functions.Action1;\n import rx.functions.Func1;\n-import rx.functions.Functions;\n import rx.internal.operators.NotificationLite;\n import rx.internal.util.UtilityFunctions;\n import rx.schedulers.Timestamped;\n@@ -358,6 +357,7 @@ private boolean caughtUp(SubjectObserver<? super T> o) {\n         if (!o.caughtUp) {\n             o.caughtUp = true;\n             state.replayObserver(o);\n+            o.index(null); // once caught up, no need for the index anymore\n             return false;\n         } else {\n             // it was caught up so proceed the \"raw route\"",
    "output": "Fix memory leak in bounded ReplaySubject due to retaining the node index\nindefinitely once the Subscriber caught up"
  },
  {
    "input": "diff --git a/src/main/java/rx/functions/Action0.java b/src/main/java/rx/functions/Action0.java\n--- a/src/main/java/rx/functions/Action0.java\n+++ b/src/main/java/rx/functions/Action0.java\n@@ -15,6 +15,9 @@\n  */\n package rx.functions;\n \n+/**\n+ * A zero-argument action.\n+ */\n public interface Action0 extends Action {\n     public void call();\n-}\n\\ No newline at end of file\n+}\n\ndiff --git a/src/main/java/rx/functions/Action1.java b/src/main/java/rx/functions/Action1.java\n--- a/src/main/java/rx/functions/Action1.java\n+++ b/src/main/java/rx/functions/Action1.java\n@@ -15,6 +15,9 @@\n  */\n package rx.functions;\n \n+/**\n+ * A one-argument action.\n+ */\n public interface Action1<T1> extends Action {\n     public void call(T1 t1);\n-}\n\\ No newline at end of file\n+}\n\ndiff --git a/src/main/java/rx/functions/Action2.java b/src/main/java/rx/functions/Action2.java\n--- a/src/main/java/rx/functions/Action2.java\n+++ b/src/main/java/rx/functions/Action2.java\n@@ -15,6 +15,9 @@\n  */\n package rx.functions;\n \n+/**\n+ * A two-argument action.\n+ */\n public interface Action2<T1, T2> extends Action {\n     public void call(T1 t1, T2 t2);\n-}\n\\ No newline at end of file\n+}\n\ndiff --git a/src/main/java/rx/functions/Action3.java b/src/main/java/rx/functions/Action3.java\n--- a/src/main/java/rx/functions/Action3.java\n+++ b/src/main/java/rx/functions/Action3.java\n@@ -15,6 +15,9 @@\n  */\n package rx.functions;\n \n+/**\n+ * A three-argument action.\n+ */\n public interface Action3<T1, T2, T3> extends Action {\n     public void call(T1 t1, T2 t2, T3 t3);\n-}\n\\ No newline at end of file\n+}",
    "output": "Add missing javadoc interface descriptions for some ActionN variants"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorWindowWithSize.java b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java\n--- a/src/main/java/rx/internal/operators/OperatorWindowWithSize.java\n+++ b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java\n@@ -61,7 +61,8 @@ final class ExactSubscriber extends Subscriber<T> {\n         final Subscriber<? super Observable<T>> child;\n         int count;\n         BufferUntilSubscriber<T> window;\n-        Subscription parentSubscription = this;\n+        volatile boolean noWindow = true;\n+        final Subscription parentSubscription = this;\n         public ExactSubscriber(Subscriber<? super Observable<T>> child) {\n             /**\n              * See https://github.com/ReactiveX/RxJava/issues/1546\n@@ -77,7 +78,7 @@ public ExactSubscriber(Subscriber<? super Observable<T>> child) {\n                 @Override\n                 public void call() {\n                     // if no window we unsubscribe up otherwise wait until window ends\n-                    if(window == null) {\n+                    if(noWindow) {\n                         parentSubscription.unsubscribe();\n                     }\n                 }\n@@ -94,13 +95,15 @@ public void onStart() {\n         @Override\n         public void onNext(T t) {\n             if (window == null) {\n+                noWindow = false;\n                 window = BufferUntilSubscriber.create();\n                 child.onNext(window);                \n             }\n             window.onNext(t);\n             if (++count % size == 0) {\n                 window.onCompleted();\n                 window = null;\n+                noWindow = true;\n                 if (child.isUnsubscribed()) {\n                     parentSubscription.unsubscribe();\n                     return;\n@@ -130,7 +133,7 @@ final class InexactSubscriber extends Subscriber<T> {\n         final Subscriber<? super Observable<T>> child;\n         int count;\n         final List<CountedSubject<T>> chunks = new LinkedList<CountedSubject<T>>();\n-        Subscription parentSubscription = this;\n+        final Subscription parentSubscription = this;\n \n         public InexactSubscriber(Subscriber<? super Observable<T>> child) {\n             /**",
    "output": "Fix Thread Safety for Unsubscribe\n\nI'm using a separate variable so the volatile is only touching during window start/end and unsubscribe rather than every onNext"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorTake.java b/src/main/java/rx/internal/operators/OperatorTake.java\n--- a/src/main/java/rx/internal/operators/OperatorTake.java\n+++ b/src/main/java/rx/internal/operators/OperatorTake.java\n@@ -63,13 +63,11 @@ public void onNext(T i) {\n                 if (!isUnsubscribed()) {\n                     if (++count >= limit) {\n                         completed = true;\n-                        // unsubscribe before emitting onNext so shutdown happens before possible effects\n-                        // of onNext such as product.request(n) calls be sent upstream. \n-                        unsubscribe();\n                     }\n                     child.onNext(i);\n                     if (completed) {\n                         child.onCompleted();\n+                        unsubscribe();\n                     }\n                 }\n             }\n@@ -83,11 +81,13 @@ public void setProducer(final Producer producer) {\n \n                     @Override\n                     public void request(long n) {\n-                        long c = limit - count;\n-                        if (n < c) {\n-                            producer.request(n);\n-                        } else {\n-                            producer.request(c);\n+                        if (!completed) {\n+                            long c = limit - count;\n+                            if (n < c) {\n+                                producer.request(n);\n+                            } else {\n+                                producer.request(c);\n+                            }\n                         }\n                     }\n                 });\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorTakeTest.java b/src/test/java/rx/internal/operators/OperatorTakeTest.java\n--- a/src/test/java/rx/internal/operators/OperatorTakeTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorTakeTest.java\n@@ -15,9 +15,7 @@\n  */\n package rx.internal.operators;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n import static org.mockito.Matchers.any;\n import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.inOrder;\n@@ -28,9 +26,11 @@\n import static org.mockito.Mockito.verifyNoMoreInteractions;\n \n import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.Test;\n import org.mockito.InOrder;\n@@ -43,7 +43,6 @@\n import rx.Subscription;\n import rx.functions.Action1;\n import rx.functions.Func1;\n-import rx.internal.operators.OperatorTake;\n import rx.observers.Subscribers;\n import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n@@ -365,4 +364,28 @@ public void request(long n) {\n         }).take(1).subscribe(ts);\n         assertEquals(1, requested.get());\n     }\n+    \n+    @Test\n+    public void testInterrupt() throws InterruptedException {\n+        final AtomicReference<Object> exception = new AtomicReference<Object>();\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        Observable.just(1).subscribeOn(Schedulers.computation()).take(1).subscribe(new Action1<Integer>() {\n+\n+            @Override\n+            public void call(Integer t1) {\n+                try {\n+                    Thread.sleep(100);\n+                } catch (Exception e) {\n+                    exception.set(e);\n+                    e.printStackTrace();\n+                } finally {\n+                    latch.countDown();\n+                }\n+            }\n+\n+        });\n+\n+        latch.await();\n+        assertNull(exception.get());\n+    }\n }",
    "output": "Fix Take Early Unsubscription Causing Interrupts\n\nFixes https://github.com/ReactiveX/RxJava/issues/1804"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorMerge.java b/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -397,6 +397,11 @@ public Boolean call(InnerSubscriber<T> s) {\n \n         @Override\n         public void onError(Throwable e) {\n+            completed = true;\n+            innerError(e);\n+        }\n+        \n+        private void innerError(Throwable e) {\n             if (delayErrors) {\n                 synchronized (this) {\n                     if (exceptions == null) {\n@@ -540,7 +545,7 @@ public void onNext(T t) {\n         public void onError(Throwable e) {\n             // it doesn't go through queues, it immediately onErrors and tears everything down\n             if (ONCE_TERMINATED.compareAndSet(this, 0, 1)) {\n-                parentSubscriber.onError(e);\n+                parentSubscriber.innerError(e);\n             }\n         }\n \n@@ -753,4 +758,4 @@ private int drainQueue() {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java b/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n--- a/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n@@ -30,6 +30,7 @@\n import rx.observers.TestSubscriber;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n@@ -479,6 +480,20 @@ public void onCompleted() {\n         verify(o, never()).onCompleted();\n     }\n \n+    @Test\n+    public void testErrorInParentObservable() {\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        Observable.mergeDelayError(\n+                Observable.just(Observable.just(1), Observable.just(2))\n+                        .startWith(Observable.<Integer> error(new RuntimeException()))\n+                ).subscribe(ts);\n+        ts.awaitTerminalEvent();\n+        ts.assertTerminalEvent();\n+        ts.assertReceivedOnNext(Arrays.asList(1, 2));\n+        assertEquals(1, ts.getOnErrorEvents().size());\n+\n+    }\n+\n     @Test\n     public void testErrorInParentObservableDelayed() throws Exception {\n         final TestASynchronous1sDelayedObservable o1 = new TestASynchronous1sDelayedObservable();",
    "output": "Fix mergeDelayError Handling of Error in Parent Observable\n\nFixes https://github.com/ReactiveX/RxJava/issues/313"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorWindowWithSize.java b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java\n--- a/src/main/java/rx/internal/operators/OperatorWindowWithSize.java\n+++ b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java\n@@ -124,14 +124,35 @@ public void onCompleted() {\n             child.onCompleted();\n         }\n     }\n+\n     /** Subscriber with inexact, possibly overlapping or skipping windows. */\n     final class InexactSubscriber extends Subscriber<T> {\n         final Subscriber<? super Observable<T>> child;\n         int count;\n-        final List<CountedSubject<T>> chunks;\n+        final List<CountedSubject<T>> chunks = new LinkedList<CountedSubject<T>>();\n+        Subscription parentSubscription = this;\n+\n         public InexactSubscriber(Subscriber<? super Observable<T>> child) {\n+            /**\n+             * See https://github.com/ReactiveX/RxJava/issues/1546\n+             * We cannot compose through a Subscription because unsubscribing\n+             * applies to the outer, not the inner.\n+             */\n             this.child = child;\n-            this.chunks = new LinkedList<CountedSubject<T>>();\n+            /*\n+             * Add unsubscribe hook to child to get unsubscribe on outer (unsubscribing on next window, not on the inner window itself)\n+             */\n+            child.add(Subscriptions.create(new Action0() {\n+\n+                @Override\n+                public void call() {\n+                    // if no window we unsubscribe up otherwise wait until window ends\n+                    if (chunks == null || chunks.size() == 0) {\n+                        parentSubscription.unsubscribe();\n+                    }\n+                }\n+\n+            }));\n         }\n \n         @Override\n@@ -143,10 +164,13 @@ public void onStart() {\n         @Override\n         public void onNext(T t) {\n             if (count++ % skip == 0) {\n-                CountedSubject<T> cs = createCountedSubject();\n-                chunks.add(cs);\n-                child.onNext(cs.producer);\n+                if (!child.isUnsubscribed()) {\n+                    CountedSubject<T> cs = createCountedSubject();\n+                    chunks.add(cs);\n+                    child.onNext(cs.producer);\n+                }\n             }\n+\n             Iterator<CountedSubject<T>> it = chunks.iterator();\n             while (it.hasNext()) {\n                 CountedSubject<T> cs = it.next();\n@@ -156,6 +180,10 @@ public void onNext(T t) {\n                     cs.consumer.onCompleted();\n                 }\n             }\n+            if (chunks.size() == 0 && child.isUnsubscribed()) {\n+                parentSubscription.unsubscribe();\n+                return;\n+            }\n         }\n \n         @Override\n@@ -177,6 +205,7 @@ public void onCompleted() {\n             }\n             child.onCompleted();\n         }\n+\n         CountedSubject<T> createCountedSubject() {\n             final BufferUntilSubscriber<T> bus = BufferUntilSubscriber.create();\n             return new CountedSubject<T>(bus, bus);\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorWindowWithSizeTest.java b/src/test/java/rx/internal/operators/OperatorWindowWithSizeTest.java\n--- a/src/test/java/rx/internal/operators/OperatorWindowWithSizeTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorWindowWithSizeTest.java\n@@ -148,6 +148,49 @@ public void call(Integer t1) {\n         assertTrue(count.get() < 100000);\n     }\n \n+    @Test\n+    public void testWindowUnsubscribeOverlapping() {\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        final AtomicInteger count = new AtomicInteger();\n+        Observable.merge(Observable.range(1, 10000).doOnNext(new Action1<Integer>() {\n+\n+            @Override\n+            public void call(Integer t1) {\n+                count.incrementAndGet();\n+            }\n+\n+        }).window(5, 4).take(2)).subscribe(ts);\n+        ts.awaitTerminalEvent(500, TimeUnit.MILLISECONDS);\n+        ts.assertTerminalEvent();\n+        //        System.out.println(ts.getOnNextEvents());\n+        ts.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 5, 6, 7, 8, 9));\n+        assertEquals(9, count.get());\n+    }\n+\n+    @Test\n+    public void testWindowUnsubscribeOverlappingAsyncSource() {\n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        final AtomicInteger count = new AtomicInteger();\n+        Observable.merge(Observable.range(1, 100000)\n+                .doOnNext(new Action1<Integer>() {\n+\n+                    @Override\n+                    public void call(Integer t1) {\n+                        count.incrementAndGet();\n+                    }\n+\n+                })\n+                .observeOn(Schedulers.computation())\n+                .window(5, 4)\n+                .take(2))\n+                .subscribe(ts);\n+        ts.awaitTerminalEvent(500, TimeUnit.MILLISECONDS);\n+        ts.assertTerminalEvent();\n+        ts.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 5, 6, 7, 8, 9));\n+        // make sure we don't emit all values ... the unsubscribe should propagate\n+        assertTrue(count.get() < 100000);\n+    }\n+\n     private List<String> list(String... args) {\n         List<String> list = new ArrayList<String>();\n         for (String arg : args) {",
    "output": "Fix Early Unsubscribe for Overlapping Window - https://github.com/ReactiveX/RxJava/issues/1546 - This also fixes the fact that the overlapping window overload was not propagating unsubscribe before. A new unit test caught that"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorWindowWithSize.java b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java\n--- a/src/main/java/rx/internal/operators/OperatorWindowWithSize.java\n+++ b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java\n@@ -19,8 +19,12 @@\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n+\n import rx.Observable;\n import rx.Observable.Operator;\n+import rx.Subscription;\n+import rx.functions.Action0;\n+import rx.subscriptions.Subscriptions;\n import rx.Observer;\n import rx.Subscriber;\n \n@@ -56,11 +60,29 @@ public Subscriber<? super T> call(Subscriber<? super Observable<T>> child) {\n     final class ExactSubscriber extends Subscriber<T> {\n         final Subscriber<? super Observable<T>> child;\n         int count;\n-        Observer<T> consumer;\n-        Observable<T> producer;\n+        BufferUntilSubscriber<T> window;\n+        Subscription parentSubscription = this;\n         public ExactSubscriber(Subscriber<? super Observable<T>> child) {\n-            super(child);\n+            /**\n+             * See https://github.com/ReactiveX/RxJava/issues/1546\n+             * We cannot compose through a Subscription because unsubscribing\n+             * applies to the outer, not the inner.\n+             */\n             this.child = child;\n+            /*\n+             * Add unsubscribe hook to child to get unsubscribe on outer (unsubscribing on next window, not on the inner window itself)\n+             */\n+            child.add(Subscriptions.create(new Action0() {\n+\n+                @Override\n+                public void call() {\n+                    // if no window we unsubscribe up otherwise wait until window ends\n+                    if(window == null) {\n+                        parentSubscription.unsubscribe();\n+                    }\n+                }\n+                \n+            }));\n         }\n \n         @Override\n@@ -71,36 +93,36 @@ public void onStart() {\n         \n         @Override\n         public void onNext(T t) {\n-            if (count++ % size == 0) {\n-                if (consumer != null) {\n-                    consumer.onCompleted();\n+            if (window == null) {\n+                window = BufferUntilSubscriber.create();\n+                child.onNext(window);                \n+            }\n+            window.onNext(t);\n+            if (++count % size == 0) {\n+                window.onCompleted();\n+                window = null;\n+                if (child.isUnsubscribed()) {\n+                    parentSubscription.unsubscribe();\n+                    return;\n                 }\n-                createNewWindow();\n-                child.onNext(producer);\n             }\n-            consumer.onNext(t);\n         }\n \n         @Override\n         public void onError(Throwable e) {\n-            if (consumer != null) {\n-                consumer.onError(e);\n+            if (window != null) {\n+                window.onError(e);\n             }\n             child.onError(e);\n         }\n \n         @Override\n         public void onCompleted() {\n-            if (consumer != null) {\n-                consumer.onCompleted();\n+            if (window != null) {\n+                window.onCompleted();\n             }\n             child.onCompleted();\n         }\n-        void createNewWindow() {\n-            final BufferUntilSubscriber<T> bus = BufferUntilSubscriber.create();\n-            consumer = bus;\n-            producer = bus;\n-        }\n     }\n     /** Subscriber with inexact, possibly overlapping or skipping windows. */\n     final class InexactSubscriber extends Subscriber<T> {",
    "output": "Fix Early Unsubscribe for Non-Overlapping Window https://github.com/ReactiveX/RxJava/issues/1546"
  },
  {
    "input": "diff --git a/src/main/java/rx/schedulers/CachedThreadScheduler.java b/src/main/java/rx/schedulers/CachedThreadScheduler.java\n--- a/src/main/java/rx/schedulers/CachedThreadScheduler.java\n+++ b/src/main/java/rx/schedulers/CachedThreadScheduler.java\n@@ -24,7 +24,6 @@\n import rx.subscriptions.CompositeSubscription;\n import rx.subscriptions.Subscriptions;\n \n-import java.util.Iterator;\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n@@ -84,12 +83,11 @@ void evictExpiredWorkers() {\n             if (!expiringWorkerQueue.isEmpty()) {\n                 long currentTimestamp = now();\n \n-                Iterator<ThreadWorker> threadWorkerIterator = expiringWorkerQueue.iterator();\n-                while (threadWorkerIterator.hasNext()) {\n-                    ThreadWorker threadWorker = threadWorkerIterator.next();\n+                for (ThreadWorker threadWorker : expiringWorkerQueue) {\n                     if (threadWorker.getExpirationTime() <= currentTimestamp) {\n-                        threadWorkerIterator.remove();\n-                        threadWorker.unsubscribe();\n+                        if (expiringWorkerQueue.remove(threadWorker)) {\n+                            threadWorker.unsubscribe();\n+                        }\n                     } else {\n                         // Queue is ordered with the worker that will expire first in the beginning, so when we\n                         // find a non-expired worker we can stop evicting.",
    "output": "Add check to ensure that the worker was removed from the queue, before unsubscribing that worker"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorConcat.java b/src/main/java/rx/internal/operators/OperatorConcat.java\n--- a/src/main/java/rx/internal/operators/OperatorConcat.java\n+++ b/src/main/java/rx/internal/operators/OperatorConcat.java\n@@ -176,6 +176,10 @@ static class ConcatInnerSubscriber<T> extends Subscriber<T> {\n \n         private final Subscriber<T> child;\n         private final ConcatSubscriber<T> parent;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int once = 0;\n+        @SuppressWarnings(\"rawtypes\")\n+        private final static AtomicIntegerFieldUpdater<ConcatInnerSubscriber> ONCE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatInnerSubscriber.class, \"once\");\n \n         public ConcatInnerSubscriber(ConcatSubscriber<T> parent, Subscriber<T> child, long initialRequest) {\n             this.parent = parent;\n@@ -195,14 +199,18 @@ public void onNext(T t) {\n \n         @Override\n         public void onError(Throwable e) {\n-            // terminal error through parent so everything gets cleaned up, including this inner\n-            parent.onError(e);\n+            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {\n+                // terminal error through parent so everything gets cleaned up, including this inner\n+                parent.onError(e);\n+            }\n         }\n \n         @Override\n         public void onCompleted() {\n-            // terminal completion to parent so it continues to the next\n-            parent.completeInner();\n+            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {\n+                // terminal completion to parent so it continues to the next\n+                parent.completeInner();\n+            }\n         }\n \n     };\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorConcatTest.java b/src/test/java/rx/internal/operators/OperatorConcatTest.java\n--- a/src/test/java/rx/internal/operators/OperatorConcatTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorConcatTest.java\n@@ -695,5 +695,27 @@ public void testInnerBackpressureWithoutAlignedBoundaries() {\n         ts.assertNoErrors();\n         assertEquals((RxRingBuffer.SIZE * 4) + 20, ts.getOnNextEvents().size());\n     }\n+    \n+    // https://github.com/ReactiveX/RxJava/issues/1818\n+    @Test\n+    public void testConcatWithNonCompliantSourceDoubleOnComplete() {\n+        Observable<String> o = Observable.create(new OnSubscribe<String>() {\n+\n+            @Override\n+            public void call(Subscriber<? super String> s) {\n+                s.onNext(\"hello\");\n+                s.onCompleted();\n+                s.onCompleted();\n+            }\n+            \n+        });\n+        \n+        TestSubscriber<String> ts = new TestSubscriber<String>();\n+        Observable.concat(o, o).subscribe(ts);\n+        ts.awaitTerminalEvent(500, TimeUnit.MILLISECONDS);\n+        ts.assertTerminalEvent();\n+        ts.assertNoErrors();\n+        ts.assertReceivedOnNext(Arrays.asList(\"hello\", \"hello\"));\n+    }\n \n }",
    "output": "Fix Concat Breaks with Double onCompleted\n\nFixes https://github.com/ReactiveX/RxJava/issues/1818"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -139,16 +139,25 @@ public final <R> Observable<R> lift(final Operator<? extends R, ? super T> lift)\n             public void call(Subscriber<? super R> o) {\n                 try {\n                     Subscriber<? super T> st = hook.onLift(lift).call(o);\n-                    // new Subscriber created and being subscribed with so 'onStart' it\n-                    st.onStart();\n-                    onSubscribe.call(st);\n+                    try {\n+                        // new Subscriber created and being subscribed with so 'onStart' it\n+                        st.onStart();\n+                        onSubscribe.call(st);\n+                    } catch (Throwable e) {\n+                        // localized capture of errors rather than it skipping all operators \n+                        // and ending up in the try/catch of the subscribe method which then\n+                        // prevents onErrorResumeNext and other similar approaches to error handling\n+                        if (e instanceof OnErrorNotImplementedException) {\n+                            throw (OnErrorNotImplementedException) e;\n+                        }\n+                        st.onError(e);\n+                    }\n                 } catch (Throwable e) {\n-                    // localized capture of errors rather than it skipping all operators \n-                    // and ending up in the try/catch of the subscribe method which then\n-                    // prevents onErrorResumeNext and other similar approaches to error handling\n                     if (e instanceof OnErrorNotImplementedException) {\n                         throw (OnErrorNotImplementedException) e;\n                     }\n+                    // if the lift function failed all we can do is pass the error to the final Subscriber\n+                    // as we don't have the operator available to us\n                     o.onError(e);\n                 }\n             }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorOnErrorResumeNextViaObservableTest.java b/src/test/java/rx/internal/operators/OperatorOnErrorResumeNextViaObservableTest.java\n--- a/src/test/java/rx/internal/operators/OperatorOnErrorResumeNextViaObservableTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorOnErrorResumeNextViaObservableTest.java\n@@ -27,6 +27,7 @@\n import org.mockito.Mockito;\n \n import rx.Observable;\n+import rx.Observable.OnSubscribe;\n import rx.Observer;\n import rx.Subscriber;\n import rx.Subscription;\n@@ -105,6 +106,55 @@ public String call(String s) {\n         verify(observer, times(1)).onNext(\"twoResume\");\n         verify(observer, times(1)).onNext(\"threeResume\");\n     }\n+    \n+    @Test\n+    public void testResumeNextWithFailedOnSubscribe() {\n+        Subscription s = mock(Subscription.class);\n+        Observable<String> testObservable = Observable.create(new OnSubscribe<String>() {\n+\n+            @Override\n+            public void call(Subscriber<? super String> t1) {\n+                throw new RuntimeException(\"force failure\");\n+            }\n+            \n+        });\n+        Observable<String> resume = Observable.just(\"resume\");\n+        Observable<String> observable = testObservable.onErrorResumeNext(resume);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer = mock(Observer.class);\n+        observable.subscribe(observer);\n+\n+        verify(observer, Mockito.never()).onError(any(Throwable.class));\n+        verify(observer, times(1)).onCompleted();\n+        verify(observer, times(1)).onNext(\"resume\");\n+    }\n+    \n+    @Test\n+    public void testResumeNextWithFailedOnSubscribeAsync() {\n+        Subscription s = mock(Subscription.class);\n+        Observable<String> testObservable = Observable.create(new OnSubscribe<String>() {\n+\n+            @Override\n+            public void call(Subscriber<? super String> t1) {\n+                throw new RuntimeException(\"force failure\");\n+            }\n+            \n+        });\n+        Observable<String> resume = Observable.just(\"resume\");\n+        Observable<String> observable = testObservable.subscribeOn(Schedulers.io()).onErrorResumeNext(resume);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer = mock(Observer.class);\n+        TestSubscriber<String> ts = new TestSubscriber<String>(observer);\n+        observable.subscribe(ts);\n+\n+        ts.awaitTerminalEvent();\n+        \n+        verify(observer, Mockito.never()).onError(any(Throwable.class));\n+        verify(observer, times(1)).onCompleted();\n+        verify(observer, times(1)).onNext(\"resume\");\n+    }\n \n     private static class TestObservable implements Observable.OnSubscribe<String> {\n ",
    "output": "Fix Synchronous OnSubscribe Exception Skips Operators\n\nFixes https://github.com/ReactiveX/RxJava/issues/1816"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorZip.java b/src/main/java/rx/internal/operators/OperatorZip.java\n--- a/src/main/java/rx/internal/operators/OperatorZip.java\n+++ b/src/main/java/rx/internal/operators/OperatorZip.java\n@@ -227,7 +227,7 @@ void tick() {\n             if (COUNTER_UPDATER.getAndIncrement(this) == 0) {\n                 do {\n                     // we only emit if requested > 0\n-                    if (requested.get() > 0) {\n+                    while (requested.get() > 0) {\n                         final Object[] vs = new Object[observers.length];\n                         boolean allHaveValues = true;\n                         for (int i = 0; i < observers.length; i++) {\n@@ -279,6 +279,8 @@ void tick() {\n                                 }\n                                 emitted = 0;\n                             }\n+                        } else {\n+                            break;\n                         }\n                     }\n                 } while (COUNTER_UPDATER.decrementAndGet(this) > 0);\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorZipTest.java b/src/test/java/rx/internal/operators/OperatorZipTest.java\n--- a/src/test/java/rx/internal/operators/OperatorZipTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorZipTest.java\n@@ -1217,4 +1217,30 @@ public void run() {\n \n         });\n     }\n+\n+    @Test(timeout = 30000)\n+    public void testIssue1812() {\n+        // https://github.com/ReactiveX/RxJava/issues/1812\n+        Observable<Integer> zip1 = Observable.zip(Observable.range(0, 1026), Observable.range(0, 1026),\n+                new Func2<Integer, Integer, Integer>() {\n+\n+                    @Override\n+                    public Integer call(Integer i1, Integer i2) {\n+                        return i1 + i2;\n+                    }\n+                });\n+        Observable<Integer> zip2 = Observable.zip(zip1, Observable.range(0, 1026),\n+                new Func2<Integer, Integer, Integer>() {\n+\n+                    @Override\n+                    public Integer call(Integer i1, Integer i2) {\n+                        return i1 + i2;\n+                    }\n+                });\n+        List<Integer> expected = new ArrayList<Integer>();\n+        for (int i = 0; i < 1026; i++) {\n+            expected.add(i * 3);\n+        }\n+        assertEquals(expected, zip2.toList().toBlocking().single());\n+    }\n }",
    "output": "Fix issue #1812 that zip may swallow requests"
  },
  {
    "input": "diff --git a/src/main/java/rx/functions/Functions.java b/src/main/java/rx/functions/Functions.java\n--- a/src/main/java/rx/functions/Functions.java\n+++ b/src/main/java/rx/functions/Functions.java\n@@ -344,19 +344,6 @@ public Void call(Object... args) {\n         };\n     }\n \n-    /**\n-     * Constructs a predicate that returns true for each input for which the source predicate returns false, and\n-     * vice versa.\n-     * \n-     * @param predicate\n-     *            the source predicate to negate\n-     * @return a function that returns a Boolean that represents an inversion of the logical effect of\n-     *         {@code predicate}\n-     */\n-    public static <T> Func1<T, Boolean> not(Func1<? super T, Boolean> predicate) {\n-        return new Not<T>(predicate);\n-    }\n-\n     /**\n      * Returns a function that always returns {@code true}.\n      *\n\ndiff --git a/src/main/java/rx/functions/Not.java b/src/main/java/rx/functions/Not.java\n--- a/src/main/java/rx/functions/Not.java\n+++ b/src/main/java/rx/functions/Not.java\n@@ -1,42 +0,0 @@\n-/**\n- * Copyright 2014 Netflix, Inc.\n- * \n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * \n- * http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package rx.functions;\n-\n-/**\n- * Implements the negation of a predicate.\n- * \n- * @param <T>\n- *            The type of the single input parameter.\n- */\n-public class Not<T> implements Func1<T, Boolean> {\n-    private final Func1<? super T, Boolean> predicate;\n-\n-    /**\n-     * Constructs a predicate that returns true for each input that the source\n-     * predicate returns false for and vice versa.\n-     * \n-     * @param predicate\n-     *            The source predicate to negate.\n-     */\n-    public Not(Func1<? super T, Boolean> predicate) {\n-        this.predicate = predicate;\n-    }\n-\n-    @Override\n-    public Boolean call(T param) {\n-        return !predicate.call(param);\n-    }\n-}",
    "output": "Remove `Not` Class\n\nAs per https://github.com/ReactiveX/RxJava/issues/1798"
  },
  {
    "input": "diff --git a/src/main/java/rx/functions/Actions.java b/src/main/java/rx/functions/Actions.java\n--- a/src/main/java/rx/functions/Actions.java\n+++ b/src/main/java/rx/functions/Actions.java\n@@ -90,60 +90,6 @@ public void call(Object... args) {\n         }\n     }\n     \n-    /**\n-     * Extracts a method reference to the Observer's {@link Observer#onNext onNext} method in the form of an\n-     * {@link Action1}.\n-     * <p>Java 8: observer::onNext</p>\n-     * \n-     * @param observer\n-     *            the {@link Observer} to use\n-     * @return an action which calls observer's {@code onNext} method.\n-     */\n-    public static <T> Action1<T> onNextFrom(final Observer<T> observer) {\n-        return new Action1<T>() {\n-            @Override\n-            public void call(T t1) {\n-                observer.onNext(t1);\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Extracts a method reference to the Observer's {@link Observer#onError(java.lang.Throwable) onError}\n-     * method in the form of an {@link Action1}.\n-     * <p>Java 8: observer::onError</p>\n-     * \n-     * @param observer\n-     *            the {@link Observer} to use\n-     * @return an action which calls observer's {@code onError} method.\n-     */\n-    public static <T> Action1<Throwable> onErrorFrom(final Observer<T> observer) {\n-        return new Action1<Throwable>() {\n-            @Override\n-            public void call(Throwable t1) {\n-                observer.onError(t1);\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Extracts a method reference to the Observer's {@link Observer#onCompleted() onCompleted} method in the\n-     * form of an {@link Action0}.\n-     * <p>Java 8: observer::onCompleted</p>\n-     * \n-     * @param observer\n-     *            the {@link Observer} to use\n-     * @return an action which calls observer's {@code onCompleted} method.\n-     */\n-    public static <T> Action0 onCompletedFrom(final Observer<T> observer) {\n-        return new Action0() {\n-            @Override\n-            public void call() {\n-                observer.onCompleted();\n-            }\n-        };\n-    }\n-\n     /**\n      * Converts an {@link Action0} to a function that calls the action and returns {@code null}.\n      * ",
    "output": "Remove Actions Utility Methods\n\nAs per https://github.com/ReactiveX/RxJava/issues/1799"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/BufferUntilSubscriber.java b/src/main/java/rx/internal/operators/BufferUntilSubscriber.java\n--- a/src/main/java/rx/internal/operators/BufferUntilSubscriber.java\n+++ b/src/main/java/rx/internal/operators/BufferUntilSubscriber.java\n@@ -184,7 +184,14 @@ public void onNext(T t) {\n             emit(state.nl.next(t));\n         }\n     }\n-    \n+\n+    @Override\n+    public boolean hasObservers() {\n+        synchronized (state.guard) {\n+            return state.observerRef != null;\n+        }\n+    }\n+\n     @SuppressWarnings(\"rawtypes\")\n     private final static Observer EMPTY_OBSERVER = new Observer() {\n \n\ndiff --git a/src/main/java/rx/internal/operators/OperatorReplay.java b/src/main/java/rx/internal/operators/OperatorReplay.java\n--- a/src/main/java/rx/internal/operators/OperatorReplay.java\n+++ b/src/main/java/rx/internal/operators/OperatorReplay.java\n@@ -99,5 +99,9 @@ public void onCompleted() {\n             subject.onCompleted();\n         }\n \n+        @Override\n+        public boolean hasObservers() {\n+            return this.subject.hasObservers();\n+        }\n     }\n }\n\\ No newline at end of file\n\ndiff --git a/src/main/java/rx/subjects/AsyncSubject.java b/src/main/java/rx/subjects/AsyncSubject.java\n--- a/src/main/java/rx/subjects/AsyncSubject.java\n+++ b/src/main/java/rx/subjects/AsyncSubject.java\n@@ -136,4 +136,8 @@ public void onNext(T v) {\n         lastValue = nl.next(v);\n     }\n \n+    @Override\n+    public boolean hasObservers() {\n+        return state.observers().length > 0;\n+    }\n }\n\ndiff --git a/src/main/java/rx/subjects/BehaviorSubject.java b/src/main/java/rx/subjects/BehaviorSubject.java\n--- a/src/main/java/rx/subjects/BehaviorSubject.java\n+++ b/src/main/java/rx/subjects/BehaviorSubject.java\n@@ -167,8 +167,13 @@ public void onNext(T v) {\n             }\n         }\n     }\n-    \n+\n     /* test support */ int subscriberCount() {\n         return state.observers().length;\n     }\n+\n+    @Override\n+    public boolean hasObservers() {\n+        return state.observers().length > 0;\n+    }\n }\n\ndiff --git a/src/main/java/rx/subjects/PublishSubject.java b/src/main/java/rx/subjects/PublishSubject.java\n--- a/src/main/java/rx/subjects/PublishSubject.java\n+++ b/src/main/java/rx/subjects/PublishSubject.java\n@@ -121,4 +121,9 @@ public void onNext(T v) {\n             bo.onNext(v);\n         }\n     }\n+\n+    @Override\n+    public boolean hasObservers() {\n+        return state.observers().length > 0;\n+    }\n }\n\ndiff --git a/src/main/java/rx/subjects/ReplaySubject.java b/src/main/java/rx/subjects/ReplaySubject.java\n--- a/src/main/java/rx/subjects/ReplaySubject.java\n+++ b/src/main/java/rx/subjects/ReplaySubject.java\n@@ -347,7 +347,12 @@ public void onCompleted() {\n     /* Support test. */int subscriberCount() {\n         return ssm.state.observers.length;\n     }\n-    \n+\n+    @Override\n+    public boolean hasObservers() {\n+        return ssm.observers().length > 0;\n+    }\n+\n     private boolean caughtUp(SubjectObserver<? super T> o) {\n         if (!o.caughtUp) {\n             o.caughtUp = true;\n\ndiff --git a/src/main/java/rx/subjects/SerializedSubject.java b/src/main/java/rx/subjects/SerializedSubject.java\n--- a/src/main/java/rx/subjects/SerializedSubject.java\n+++ b/src/main/java/rx/subjects/SerializedSubject.java\n@@ -34,6 +34,7 @@\n  */\n public class SerializedSubject<T, R> extends Subject<T, R> {\n     private final SerializedObserver<T> observer;\n+    private final Subject<T, R> actual;\n \n     public SerializedSubject(final Subject<T, R> actual) {\n         super(new OnSubscribe<R>() {\n@@ -44,6 +45,7 @@ public void call(Subscriber<? super R> child) {\n             }\n \n         });\n+        this.actual = actual;\n         this.observer = new SerializedObserver<T>(actual);\n     }\n \n@@ -62,4 +64,8 @@ public void onNext(T t) {\n         observer.onNext(t);\n     }\n \n+    @Override\n+    public boolean hasObservers() {\n+        return actual.hasObservers();\n+    }\n }\n\ndiff --git a/src/main/java/rx/subjects/Subject.java b/src/main/java/rx/subjects/Subject.java\n--- a/src/main/java/rx/subjects/Subject.java\n+++ b/src/main/java/rx/subjects/Subject.java\n@@ -25,4 +25,10 @@ public abstract class Subject<T, R> extends Observable<R> implements Observer<T>\n     protected Subject(OnSubscribe<R> onSubscribe) {\n         super(onSubscribe);\n     }\n+\n+    /**\n+     * Indicates whether the {@link Subject} has {@link Observer Observers} subscribed to it.\n+     * @return true if there is at least one Observer subscribed to this Subject, false otherwise\n+     */\n+    public abstract boolean hasObservers();\n }\n\ndiff --git a/src/main/java/rx/subjects/TestSubject.java b/src/main/java/rx/subjects/TestSubject.java\n--- a/src/main/java/rx/subjects/TestSubject.java\n+++ b/src/main/java/rx/subjects/TestSubject.java\n@@ -86,7 +86,7 @@ private void _onCompleted() {\n \n     /**\n      * Schedule a call to {@code onCompleted} relative to \"now()\" +n milliseconds in the future.\n-     * \n+     *\n      * @param timeInMilliseconds\n      *         the number of milliseconds in the future relative to \"now()\" at which to call {@code onCompleted}\n      */\n@@ -119,7 +119,7 @@ private void _onError(final Throwable e) {\n \n     /**\n      * Schedule a call to {@code onError} relative to \"now()\" +n milliseconds in the future.\n-     * \n+     *\n      * @param e\n      *         the {@code Throwable} to pass to the {@code onError} method\n      * @param timeInMilliseconds\n@@ -152,7 +152,7 @@ private void _onNext(T v) {\n \n     /**\n      * Schedule a call to {@code onNext} relative to \"now()\" +n milliseconds in the future.\n-     * \n+     *\n      * @param v\n      *         the item to emit\n      * @param timeInMilliseconds\n@@ -168,4 +168,9 @@ public void call() {\n \n         }, timeInMilliseconds, TimeUnit.MILLISECONDS);\n     }\n+\n+    @Override\n+    public boolean hasObservers() {\n+        return state.observers().length > 0;\n+    }\n }\n\ndiff --git a/src/test/java/rx/subjects/BehaviorSubjectTest.java b/src/test/java/rx/subjects/BehaviorSubjectTest.java\n--- a/src/test/java/rx/subjects/BehaviorSubjectTest.java\n+++ b/src/test/java/rx/subjects/BehaviorSubjectTest.java\n@@ -16,6 +16,7 @@\n package rx.subjects;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.fail;\n import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.inOrder;\n@@ -370,6 +371,7 @@ public void testTakeOneSubscriber() {\n         verify(o, never()).onError(any(Throwable.class));\n         \n         assertEquals(0, source.subscriberCount());\n+        assertFalse(source.hasObservers());\n     }\n     \n     @Test",
    "output": "Add hasObservers method to Subjects as per https://github.com/ReactiveX/RxJava/issues/1772 SerializedSubject now keeps track of the actual Subject. BufferUntilSubscriber synchronizes on the state guard"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeRedo.java b/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n@@ -206,6 +206,10 @@ public void call(final Subscriber<? super T> child) {\n         final Action0 subscribeToSource = new Action0() {\n             @Override\n             public void call() {\n+                if (child.isUnsubscribed()) {\n+                    return;\n+                }\n+\n                 Subscriber<T> terminalDelegatingSubscriber = new Subscriber<T>() {\n                     @Override\n                     public void onCompleted() {\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorRetryTest.java b/src/test/java/rx/internal/operators/OperatorRetryTest.java\n--- a/src/test/java/rx/internal/operators/OperatorRetryTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorRetryTest.java\n@@ -244,6 +244,37 @@ public Observable<?> call(Observable<? extends Throwable> t1) {\n         inOrder.verifyNoMoreInteractions();\n     }\n \n+    @Test\n+    public void testSingleSubscriptionOnFirst() throws Exception {\n+        final AtomicInteger inc = new AtomicInteger(0);\n+        Observable.OnSubscribe<Integer> onSubscribe = new OnSubscribe<Integer>() {\n+            @Override\n+            public void call(Subscriber<? super Integer> subscriber) {\n+                final int emit = inc.incrementAndGet();\n+                subscriber.onNext(emit);\n+                subscriber.onCompleted();\n+            }\n+        };\n+\n+        int first = Observable.create(onSubscribe)\n+                .retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\n+                    @Override\n+                    public Observable<?> call(Observable<? extends Throwable> attempt) {\n+                        return attempt.zipWith(Observable.just(1), new Func2<Throwable, Integer, Void>() {\n+                            @Override\n+                            public Void call(Throwable o, Integer integer) {\n+                                return null;\n+                            }\n+                        });\n+                    }\n+                })\n+                .toBlocking()\n+                .first();\n+\n+        assertEquals(\"Observer did not receive the expected output\", 1, first);\n+        assertEquals(\"Subscribe was not called once\", 1, inc.get());\n+    }\n+\n     @Test\n     public void testOriginFails() {\n         @SuppressWarnings(\"unchecked\")",
    "output": "Fix for #1791 - don't retry (subscribe) to source if child has unsubscribed"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -5347,105 +5347,6 @@ public final <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Ob\n         return OperatorPublish.create(this, selector);\n     }\n \n-    /**\n-     * Returns an Observable that emits {@code initialValue} followed by the results of invoking a specified\n-     * selector on items emitted by a {@link ConnectableObservable} that shares a single subscription to the\n-     * source Observable.\n-     * <p>\n-     * <img width=\"640\" height=\"510\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.if.png\" alt=\"\">\n-     * <dl>\n-     *  <dt><b>Scheduler:</b></dt>\n-     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.</dd>\n-     * </dl>\n-     * \n-     * @param <R>\n-     *            the type of items emitted by the resulting Observable\n-     * @param selector\n-     *            a function that can use the multicasted source sequence as many times as needed, without\n-     *            causing multiple subscriptions to the source Observable. Subscribers to the source will\n-     *            receive all notifications of the source from the time of the subscription forward\n-     * @param initialValue\n-     *            the initial value of the underlying {@link BehaviorSubject}\n-     * @return an Observable that emits {@code initialValue} followed by the results of invoking the selector\n-     *         on a {@link ConnectableObservable} that shares a single subscription to the underlying Observable\n-     * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Connectable-Observable-Operators#observablepublish-and-observablemulticast\">RxJava wiki: publish</a>\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.publish.aspx\">MSDN: Observable.Publish</a>\n-     */\n-    public final <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector, final T initialValue) {\n-        return concatWith(just(initialValue)).publish(selector);\n-    }\n-\n-    /**\n-     * Returns a {@link ConnectableObservable} that emits {@code initialValue} followed by the items emitted by\n-     * the source Observable. A Connectable Observable resembles an ordinary Observable, except that it does not\n-     * begin emitting items when it is subscribed to, but only when its {@code connect} method is called.\n-     * <p>\n-     * <img width=\"640\" height=\"510\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.i.png\" alt=\"\">\n-     * <dl>\n-     *  <dt><b>Scheduler:</b></dt>\n-     *  <dd>{@code publish} does not operate by default on a particular {@link Scheduler}.</dd>\n-     * </dl>\n-     * \n-     * @param initialValue\n-     *            the initial value to be emitted by the resulting Observable\n-     * @return a {@link ConnectableObservable} that shares a single subscription to the underlying Observable\n-     *         and starts with {@code initialValue}\n-     * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Connectable-Observable-Operators#observablepublish-and-observablemulticast\">RxJava wiki: publish</a>\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.publish.aspx\">MSDN: Observable.Publish</a>\n-     */\n-    public final ConnectableObservable<T> publish(final T initialValue) {\n-        return concatWith(just(initialValue)).publish();\n-    }\n-\n-    /**\n-     * Returns a {@link ConnectableObservable} that emits only the last item emitted by the source Observable.\n-     * A Connectable Observable resembles an ordinary Observable, except that it does not begin emitting items\n-     * when it is subscribed to, but only when its {@code connect} method is called. \n-     * <p>\n-     * <img width=\"640\" height=\"310\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishLast.png\" alt=\"\">\n-     * <dl>\n-     *  <dt><b>Backpressure Support:</b></dt>\n-     *  <dd>This operator does not support backpressure because by intent it is skipping all values except the\n-     *      last.</dd>\n-     *  <dt><b>Scheduler:</b></dt>\n-     *  <dd>{@code publishLast} does not operate by default on a particular {@link Scheduler}.</dd>\n-     * </dl>\n-     * \n-     * @return a {@link ConnectableObservable} that emits only the last item emitted by the source Observable\n-     * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Connectable-Observable-Operators#observablepublishlast\">RxJava wiki: publishLast</a>\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.publishlast.aspx\">MSDN: Observable.PublishLast</a>\n-     */\n-    public final ConnectableObservable<T> publishLast() {\n-        return takeLast(1).publish();\n-    }\n-\n-    /**\n-     * Returns an Observable that emits an item that results from invoking a specified selector on the last item\n-     * emitted by a {@link ConnectableObservable} that shares a single subscription to the source Observable.\n-     * <p>\n-     * <img width=\"640\" height=\"310\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishLast.f.png\" alt=\"\">\n-     * <dl>\n-     *  <dt><b>Backpressure Support:</b></dt>\n-     *  <dd>This operator does not support backpressure because by intent it is skipping all values except the\n-     *      last.</dd>\n-     *  <dt><b>Scheduler:</b></dt>\n-     *  <dd>{@code publishLast} does not operate by default on a particular {@link Scheduler}.</dd>\n-     * </dl>\n-     * \n-     * @param <R>\n-     *            the type of items emitted by the resulting Observable\n-     * @param selector\n-     *            a function that can use the multicasted source sequence as many times as needed, without\n-     *            causing multiple subscriptions to the source Observable. Subscribers to the source will only\n-     *            receive the last item emitted by the source.\n-     * @return an Observable that emits an item that is the result of invoking the selector on a {@link ConnectableObservable} that shares a single subscription to the source Observable\n-     * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Connectable-Observable-Operators#observablepublishlast\">RxJava wiki: publishLast</a>\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.publishlast.aspx\">MSDN: Observable.PublishLast</a>\n-     */\n-    public final <R> Observable<R> publishLast(Func1<? super Observable<T>, ? extends Observable<R>> selector) {\n-        return takeLast(1).publish(selector);\n-    }\n-\n     /**\n      * Returns an Observable that applies a function of your choosing to the first item emitted by a source\n      * Observable, then feeds the result of that function along with the second item emitted by the source\n\ndiff --git a/src/test/java/rx/ObservableTests.java b/src/test/java/rx/ObservableTests.java\n--- a/src/test/java/rx/ObservableTests.java\n+++ b/src/test/java/rx/ObservableTests.java\n@@ -517,7 +517,7 @@ public void run() {\n                     }\n                 }).start();\n             }\n-        }).publishLast();\n+        }).takeLast(1).publish();\n \n         // subscribe once\n         final CountDownLatch latch = new CountDownLatch(1);",
    "output": "Remove PublishLast/InitialValue\n\nSee https://github.com/ReactiveX/RxJava/issues/1785"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -6924,28 +6924,6 @@ public final Observable<T> skipWhile(Func1<? super T, Boolean> predicate) {\n         return lift(new OperatorSkipWhile<T>(OperatorSkipWhile.toPredicate2(predicate)));\n     }\n \n-    /**\n-     * Returns an Observable that skips all items emitted by the source Observable as long as a specified\n-     * condition holds true, but emits all further source items as soon as the condition becomes false.\n-     * <p>\n-     * <img width=\"640\" height=\"305\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipWhileWithIndex.png\" alt=\"\">\n-     * <dl>\n-     *  <dt><b>Scheduler:</b></dt>\n-     *  <dd>{@code skipWhileWithIndex} does not operate by default on a particular {@link Scheduler}.</dd>\n-     * </dl>\n-     * \n-     * @param predicate\n-     *            a function to test each item emitted from the source Observable. It takes the emitted item as\n-     *            the first parameter and the sequential index of the emitted item as a second parameter.\n-     * @return an Observable that begins emitting items emitted by the source Observable when the specified\n-     *         predicate becomes false\n-     * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators#skipwhile-and-skipwhilewithindex\">RxJava wiki: skipWhileWithIndex</a>\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211631.aspx\">MSDN: Observable.SkipWhile</a>\n-     */\n-    public final Observable<T> skipWhileWithIndex(Func2<? super T, Integer, Boolean> predicate) {\n-        return lift(new OperatorSkipWhile<T>(predicate));\n-    }\n-\n     /**\n      * Returns an Observable that emits the items in a specified {@link Observable} before it begins to emit\n      * items emitted by the source Observable.\n@@ -8022,30 +8000,6 @@ public final Observable<T> takeWhile(final Func1<? super T, Boolean> predicate)\n         return lift(new OperatorTakeWhile<T>(predicate));\n     }\n \n-    /**\n-     * Returns an Observable that emits the items emitted by a source Observable so long as a given predicate\n-     * remains true, where the predicate operates on both the item and its index relative to the complete\n-     * sequence of emitted items.\n-     * <p>\n-     * <img width=\"640\" height=\"305\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeWhileWithIndex.png\" alt=\"\">\n-     * <dl>\n-     *  <dt><b>Scheduler:</b></dt>\n-     *  <dd>{@code takeWhile} does not operate by default on a particular {@link Scheduler}.</dd>\n-     * </dl>\n-     * \n-     * @param predicate\n-     *            a function to test each item emitted by the source Observable for a condition; the second\n-     *            parameter of the function represents the sequential index of the source item; it returns a\n-     *            Boolean\n-     * @return an Observable that emits items from the source Observable so long as the predicate continues to\n-     *         return {@code true} for each item, then completes\n-     * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators#takewhile-and-takewhilewithindex\">RxJava wiki: takeWhileWithIndex</a>\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229131.aspx\">MSDN: Observable.TakeWhile</a>\n-     */\n-    public final Observable<T> takeWhileWithIndex(final Func2<? super T, ? super Integer, Boolean> predicate) {\n-        return lift(new OperatorTakeWhile<T>(predicate));\n-    }\n-\n     /**\n      * Returns an Observable that emits only the first item emitted by the source Observable during sequential\n      * time windows of a specified duration.\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorSkipWhileTest.java b/src/test/java/rx/internal/operators/OperatorSkipWhileTest.java\n--- a/src/test/java/rx/internal/operators/OperatorSkipWhileTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorSkipWhileTest.java\n@@ -45,17 +45,18 @@ public Boolean call(Integer v) {\n         }\n     };\n \n-    private static final Func2<Integer, Integer, Boolean> INDEX_LESS_THAN_THREE = new Func2<Integer, Integer, Boolean>() {\n+    private static final Func1<Integer, Boolean> INDEX_LESS_THAN_THREE = new Func1<Integer, Boolean>() {\n+        int index = 0;\n         @Override\n-        public Boolean call(Integer value, Integer index) {\n-            return index < 3;\n+        public Boolean call(Integer value) {\n+            return index++ < 3;\n         }\n     };\n \n     @Test\n     public void testSkipWithIndex() {\n         Observable<Integer> src = Observable.just(1, 2, 3, 4, 5);\n-        src.skipWhileWithIndex(INDEX_LESS_THAN_THREE).subscribe(w);\n+        src.skipWhile(INDEX_LESS_THAN_THREE).subscribe(w);\n \n         InOrder inOrder = inOrder(w);\n         inOrder.verify(w, times(1)).onNext(4);\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorTakeWhileTest.java b/src/test/java/rx/internal/operators/OperatorTakeWhileTest.java\n--- a/src/test/java/rx/internal/operators/OperatorTakeWhileTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorTakeWhileTest.java\n@@ -89,10 +89,12 @@ public Boolean call(Integer input) {\n     @Test\n     public void testTakeWhile2() {\n         Observable<String> w = Observable.just(\"one\", \"two\", \"three\");\n-        Observable<String> take = w.takeWhileWithIndex(new Func2<String, Integer, Boolean>() {\n+        Observable<String> take = w.takeWhile(new Func1<String, Boolean>() {\n+            int index = 0;\n+\n             @Override\n-            public Boolean call(String input, Integer index) {\n-                return index < 2;\n+            public Boolean call(String input) {\n+                return index++ < 2;\n             }\n         });\n \n@@ -158,10 +160,12 @@ public void testUnsubscribeAfterTake() {\n \n         @SuppressWarnings(\"unchecked\")\n         Observer<String> observer = mock(Observer.class);\n-        Observable<String> take = Observable.create(w).takeWhileWithIndex(new Func2<String, Integer, Boolean>() {\n+        Observable<String> take = Observable.create(w).takeWhile(new Func1<String, Boolean>() {\n+            int index = 0;\n+\n             @Override\n-            public Boolean call(String s, Integer index) {\n-                return index < 1;\n+            public Boolean call(String s) {\n+                return index++ < 1;\n             }\n         });\n         take.subscribe(observer);",
    "output": "Remove *withIndex Operators\n\nSee https://github.com/ReactiveX/RxJava/issues/1782 -> Remove takeWhileWithIndex & skipWhileWithIndex"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -174,17 +174,15 @@ public void call(Subscriber<? super R> o) {\n      * @return the source Observable, transformed by the transformer function\n      * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators</a>\n      */\n-    @SuppressWarnings(\"unchecked\")\n     public <R> Observable<R> compose(Transformer<? super T, ? extends R> transformer) {\n-        // Casting to Observable<R> is type-safe because we know Observable is covariant.\n-        return (Observable<R>) ((Transformer<T, ? extends R>) transformer).call(this);\n+        return ((Transformer<T, R>) transformer).call(this);\n     }\n \n     /**\n      * Transformer function used by {@link #compose}.\n      * @warn more complete description needed\n      */\n-    public static interface Transformer<T, R> extends Func1<Observable<T>, Observable<? extends R>> {\n+    public static interface Transformer<T, R> extends Func1<Observable<T>, Observable<R>> {\n         // cover for generics insanity\n     }\n     \n\ndiff --git a/src/test/java/rx/CovarianceTest.java b/src/test/java/rx/CovarianceTest.java\n--- a/src/test/java/rx/CovarianceTest.java\n+++ b/src/test/java/rx/CovarianceTest.java\n@@ -85,7 +85,7 @@ public Observable<String> call(GroupedObservable<Class<? extends Movie>, Movie>\n                 return g.compose(new Transformer<Movie, Movie>() {\n \n                     @Override\n-                    public Observable<? extends Movie> call(Observable<Movie> m) {\n+                    public Observable<Movie> call(Observable<Movie> m) {\n                         return m.concatWith(Observable.just(new ActionMovie()));\n                     }\n \n@@ -112,7 +112,7 @@ public void testCovarianceOfCompose() {\n         Observable<Movie> movie2 = movie.compose(new Transformer<Movie, Movie>() {\n \n             @Override\n-            public Observable<? extends Movie> call(Observable<Movie> t1) {\n+            public Observable<Movie> call(Observable<Movie> t1) {\n                 return Observable.just(new Movie());\n             }\n             \n@@ -124,7 +124,7 @@ public void testCovarianceOfCompose2() {\n         Observable<Movie> movie = Observable.<Movie> just(new HorrorMovie());\n         Observable<HorrorMovie> movie2 = movie.compose(new Transformer<Movie, HorrorMovie>() {\n             @Override\n-            public Observable<? extends HorrorMovie> call(Observable<Movie> t1) {\n+            public Observable<HorrorMovie> call(Observable<Movie> t1) {\n                 return Observable.just(new HorrorMovie());\n             }\n         });\n@@ -135,7 +135,7 @@ public void testCovarianceOfCompose3() {\n         Observable<Movie> movie = Observable.<Movie>just(new HorrorMovie());\n         Observable<HorrorMovie> movie2 = movie.compose(new Transformer<Movie, HorrorMovie>() {\n             @Override\n-            public Observable<? extends HorrorMovie> call(Observable<Movie> t1) {\n+            public Observable<HorrorMovie> call(Observable<Movie> t1) {\n                 return Observable.just(new HorrorMovie()).map(new Func1<HorrorMovie, HorrorMovie>() {\n \n                     @Override\n@@ -152,7 +152,7 @@ public void testCovarianceOfCompose4() {\n         Observable<HorrorMovie> movie = Observable.just(new HorrorMovie());\n         Observable<HorrorMovie> movie2 = movie.compose(new Transformer<HorrorMovie, HorrorMovie>() {\n             @Override\n-            public Observable<? extends HorrorMovie> call(Observable<HorrorMovie> t1) {\n+            public Observable<HorrorMovie> call(Observable<HorrorMovie> t1) {\n                 return t1.map(new Func1<HorrorMovie, HorrorMovie>() {\n \n                     @Override",
    "output": "Change Transformer to Func1<Observable<T>, Observable<R>>"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n--- a/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n+++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n@@ -35,14 +35,14 @@ public final class OnSubscribeFromIterable<T> implements OnSubscribe<T> {\n     final Iterable<? extends T> is;\n \n     public OnSubscribeFromIterable(Iterable<? extends T> iterable) {\n+        if (iterable == null) {\n+            throw new NullPointerException(\"iterable must not be null\");\n+        }\n         this.is = iterable;\n     }\n \n     @Override\n     public void call(final Subscriber<? super T> o) {\n-        if (is == null) {\n-            o.onCompleted();\n-        }\n         final Iterator<? extends T> it = is.iterator();\n         o.setProducer(new IterableProducer<T>(o, it));\n     }\n\ndiff --git a/src/test/java/rx/internal/operators/OnSubscribeFromIterableTest.java b/src/test/java/rx/internal/operators/OnSubscribeFromIterableTest.java\n--- a/src/test/java/rx/internal/operators/OnSubscribeFromIterableTest.java\n+++ b/src/test/java/rx/internal/operators/OnSubscribeFromIterableTest.java\n@@ -35,16 +35,9 @@\n \n public class OnSubscribeFromIterableTest {\n \n-    @Test\n+    @Test(expected = NullPointerException.class)\n     public void testNull() {\n-        Observable<String> observable = Observable.create(new OnSubscribeFromIterable<String>(null));\n-\n-        @SuppressWarnings(\"unchecked\")\n-        Observer<String> observer = mock(Observer.class);\n-        observable.subscribe(observer);\n-        verify(observer, Mockito.never()).onNext(any(String.class));\n-        verify(observer, Mockito.never()).onError(any(Throwable.class));\n-        verify(observer, times(1)).onCompleted();\n+        Observable.create(new OnSubscribeFromIterable<String>(null));\n     }\n     \n     @Test",
    "output": "Fix NPE when iterable is null"
  },
  {
    "input": "diff --git a/src/test/java/rx/internal/operators/OperatorObserveOnTest.java b/src/test/java/rx/internal/operators/OperatorObserveOnTest.java\n--- a/src/test/java/rx/internal/operators/OperatorObserveOnTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorObserveOnTest.java\n@@ -687,7 +687,7 @@ public void testErrorPropagatesWhenNoOutstandingRequests() {\n \n                     @Override\n                     public void call(Notification<? super Long> n) {\n-                        //                        System.out.println(\"BEFORE \" + n);\n+                        //                                                System.out.println(\"BEFORE \" + n);\n                     }\n \n                 })\n@@ -696,7 +696,11 @@ public void call(Notification<? super Long> n) {\n \n                     @Override\n                     public void call(Notification<? super Long> n) {\n-                        //                        System.out.println(\"AFTER \" + n);\n+                        try {\n+                            Thread.sleep(100);\n+                        } catch (InterruptedException e) {\n+                        }\n+                        //                                                System.out.println(\"AFTER \" + n);\n                     }\n \n                 });",
    "output": "Fix Slow Non-deterministic Test\n\nSomehow I missed the Thread.sleep to force the scenario so most of the time this test would run very slow (or forever).\nI'm surprised the unit tests passed before... just random luck on thread scheduling"
  },
  {
    "input": "diff --git a/src/main/java/rx/schedulers/TrampolineScheduler.java b/src/main/java/rx/schedulers/TrampolineScheduler.java\n--- a/src/main/java/rx/schedulers/TrampolineScheduler.java\n+++ b/src/main/java/rx/schedulers/TrampolineScheduler.java\n@@ -45,18 +45,12 @@ public Worker createWorker() {\n     /* package accessible for unit tests */TrampolineScheduler() {\n     }\n \n-    private static final ThreadLocal<PriorityQueue<TimedAction>> QUEUE = new ThreadLocal<PriorityQueue<TimedAction>>() {\n-        @Override\n-        protected PriorityQueue<TimedAction> initialValue() {\n-            return new PriorityQueue<TimedAction>();\n-        }\n-    };\n-\n     volatile int counter;\n     static final AtomicIntegerFieldUpdater<TrampolineScheduler> COUNTER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(TrampolineScheduler.class, \"counter\");\n \n     private class InnerCurrentThreadScheduler extends Scheduler.Worker implements Subscription {\n \n+        final PriorityQueue<TimedAction> queue = new PriorityQueue<TimedAction>();\n         private final BooleanSubscription innerSubscription = new BooleanSubscription();\n         private final AtomicInteger wip = new AtomicInteger();\n \n@@ -76,7 +70,6 @@ private Subscription enqueue(Action0 action, long execTime) {\n             if (innerSubscription.isUnsubscribed()) {\n                 return Subscriptions.empty();\n             }\n-            PriorityQueue<TimedAction> queue = QUEUE.get();\n             final TimedAction timedAction = new TimedAction(action, execTime, COUNTER_UPDATER.incrementAndGet(TrampolineScheduler.this));\n             queue.add(timedAction);\n \n@@ -95,7 +88,7 @@ private Subscription enqueue(Action0 action, long execTime) {\n \n                     @Override\n                     public void call() {\n-                        PriorityQueue<TimedAction> _q = QUEUE.get();\n+                        PriorityQueue<TimedAction> _q = queue;\n                         if (_q != null) {\n                             _q.remove(timedAction);\n                         }",
    "output": "Remove use of ThreadLocal\n\nThis was an awkward leftover from early version of RxJava (pre v0.17)"
  },
  {
    "input": "diff --git a/src/main/java/rx/schedulers/TrampolineScheduler.java b/src/main/java/rx/schedulers/TrampolineScheduler.java\n--- a/src/main/java/rx/schedulers/TrampolineScheduler.java\n+++ b/src/main/java/rx/schedulers/TrampolineScheduler.java\n@@ -82,7 +82,11 @@ private Subscription enqueue(Action0 action, long execTime) {\n \n             if (wip.getAndIncrement() == 0) {\n                 do {\n-                    queue.poll().action.call();\n+                    TimedAction polled = queue.poll();\n+                    // check for null as it could have been unsubscribed and removed\n+                    if (polled != null) {\n+                        polled.action.call();\n+                    }\n                 } while (wip.decrementAndGet() > 0);\n                 return Subscriptions.empty();\n             } else {",
    "output": "Fix TrampolineScheduler NullPointerException\n\nI tried for about 30 minutes to replicate the NPE reported in https://github.com/ReactiveX/RxJava/issues/1702 but couldn't.\nIt makes sense reading the code that an unsubscribe could trigger an NPE though so I'm fixing it as per recommendation of @DylanSale even though I can't replicate.\nI confirmed that the items are being put in the queue BEFORE the wip variable is incremented, so that concurrency seems okay"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/util/MpscPaddedQueue.java b/src/main/java/rx/internal/util/MpscPaddedQueue.java\n--- a/src/main/java/rx/internal/util/MpscPaddedQueue.java\n+++ b/src/main/java/rx/internal/util/MpscPaddedQueue.java\n@@ -1,162 +0,0 @@\n-/**\n- * Copyright 2014 Netflix, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n- * use this file except in compliance with the License. You may obtain a copy of\n- * the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package rx.internal.util;\n-\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n-\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import rx.internal.util.MpscPaddedQueue.Node;\n-\n-abstract class MpscLinkedQueuePad0<E> {\n-    long p00, p01, p02, p03, p04, p05, p06, p07;\n-    long p30, p31, p32, p33, p34, p35, p36, p37;\n-}\n-\n-abstract class MpscLinkedQueueHeadRef<E> extends MpscLinkedQueuePad0<E> {\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<MpscLinkedQueueHeadRef, Node> UPDATER =\n-        newUpdater(MpscLinkedQueueHeadRef.class, Node.class, \"headRef\");\n-    private volatile Node<E> headRef;\n-\n-    protected final Node<E> headRef() {\n-        return headRef;\n-    }\n-    protected final void headRef(Node<E> val) {\n-        headRef = val;\n-    }\n-    protected final void lazySetHeadRef(Node<E> newVal) {\n-        UPDATER.lazySet(this, newVal);\n-    }\n-}\n-\n-abstract class MpscLinkedQueuePad1<E> extends MpscLinkedQueueHeadRef<E> {\n-    long p00, p01, p02, p03, p04, p05, p06, p07;\n-    long p30, p31, p32, p33, p34, p35, p36, p37;\n-}\n-\n-abstract class MpscLinkedQueueTailRef<E> extends MpscLinkedQueuePad1<E> {\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<MpscLinkedQueueTailRef, Node> UPDATER =\n-        newUpdater(MpscLinkedQueueTailRef.class, Node.class, \"tailRef\");\n-    private volatile Node<E> tailRef;\n-    protected final Node<E> tailRef() {\n-        return tailRef;\n-    }\n-    protected final void tailRef(Node<E> val) {\n-        tailRef = val;\n-    }\n-    @SuppressWarnings(\"unchecked\")\n-    protected final Node<E> getAndSetTailRef(Node<E> newVal) {\n-        return (Node<E>) UPDATER.getAndSet(this, newVal);\n-    }\n-}\n-/**\n- * A multiple-producer single consumer queue implementation with padded reference to tail to avoid cache-line\n- * thrashing. Based on Netty's <a href='https://github.com/netty/netty/blob/master/common/src/main/java/io/netty/util/internal/MpscLinkedQueue.java'>MpscQueue implementation</a>\n- * but using {@code AtomicReferenceFieldUpdater} instead of {@code Unsafe}.<br>\n- * Original algorithm presented <a\n- * href=\"http://www.1024cores.net/home/lock-free-algorithms/queues/non-intrusive-mpsc-node-based-queue\"> on 1024\n- * Cores</a> by D. Vyukov.<br>\n- * Data structure modified to avoid false sharing between head and tail references as per implementation of\n- * MpscLinkedQueue on <a href=\"https://github.com/JCTools/JCTools\">JCTools project</a>.\n- * \n- * @param <E> the element type\n- */\n-public final class MpscPaddedQueue<E> extends MpscLinkedQueueTailRef<E> {\n-    long p00, p01, p02, p03, p04, p05, p06, p07;\n-    long p30, p31, p32, p33, p34, p35, p36, p37;\n-    /**\n-     * Initializes the empty queue.\n-     */\n-    public MpscPaddedQueue() {\n-        Node<E> stub = new Node<E>(null);\n-        headRef(stub);\n-        tailRef(stub);\n-    }\n-\n-    /**\n-     * Offer a new value.\n-     *\n-     * @param v the value to offer\n-     */\n-    public void offer(E v) {\n-        Node<E> n = new Node<E>(v);\n-        getAndSetTailRef(n).next(n);\n-    }\n-\n-    /**\n-     * @warn method description missing\n-     * @return Poll a value from the head of the queue or return null if the queue is empty.\n-     */\n-    public E poll() {\n-        Node<E> n = peekNode();\n-        if (n == null) {\n-            return null;\n-        }\n-        E v = n.value;\n-        n.value = null; // do not retain this value as the node still stays in the queue\n-        lazySetHeadRef(n);\n-        return v;\n-    }\n-    \n-    /**\n-     * Check if there is a node available without changing anything.\n-     * @return\n-     */\n-    private Node<E> peekNode() {\n-        for (;;) {\n-            Node<E> t = headRef();\n-            Node<E> n = t.next();\n-            if (n != null || headRef() == t) {\n-                return n;\n-            }\n-        }\n-    }\n-    /**\n-     * Clears the queue.\n-     */\n-    public void clear() {\n-        for (;;) {\n-            if (poll() == null) {\n-                break;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Regular node with value and reference to the next node.\n-     */\n-    static final class Node<E> {\n-        E value;\n-        @SuppressWarnings(value = \"rawtypes\")\n-        static final AtomicReferenceFieldUpdater<Node, Node> TAIL_UPDATER = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, \"next\");\n-        private volatile Node<E> next;\n-\n-        Node(E value) {\n-            this.value = value;\n-        }\n-\n-        void next(Node<E> newNext) {\n-            TAIL_UPDATER.lazySet(this, newNext);\n-        }\n-\n-        Node<E> next() {\n-            return next;\n-        }\n-    }\n-    \n-}",
    "output": "Remove Unused Code"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorMerge.java b/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -72,9 +72,6 @@ public class OperatorMerge<T> implements Operator<T, Observable<? extends T>> {\n      * I'd love to have contributions that improve this class, but keep in mind the performance and GC pressure.\n      * The benchmarks I use are in the JMH OperatorMergePerf class. GC memory pressure is tested using Java Flight Recorder\n      * to track object allocation.\n-     * \n-     * TODO There is still a known concurrency bug somewhere either in this class, in SubscriptionIndexedRingBuffer or their relationship.\n-     * See https://github.com/ReactiveX/RxJava/issues/1420 for more information on this.\n      */\n \n     public OperatorMerge() {",
    "output": "Remove Comment\n\nThis comment is no longer correct. 1420 was resolved"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorMerge.java b/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -426,7 +426,7 @@ public void onCompleted() {\n             boolean c = false;\n             synchronized (this) {\n                 completed = true;\n-                if (wip == 0) {\n+                if (wip == 0 && (scalarValueQueue == null || scalarValueQueue.isEmpty())) {\n                     c = true;\n                 }\n             }\n@@ -496,7 +496,11 @@ public void request(long n) {\n                 requested = Long.MAX_VALUE;\n             } else {\n                 REQUESTED.getAndAdd(this, n);\n-                ms.drainQueuesIfNeeded();\n+                if (ms.drainQueuesIfNeeded()) {\n+                    if (ms.wip == 0 && ms.scalarValueQueue != null && ms.scalarValueQueue.isEmpty()) {\n+                        ms.drainAndComplete();\n+                    }\n+                }\n             }\n         }\n \n\ndiff --git a/src/test/java/rx/internal/operators/OperatorMergeTest.java b/src/test/java/rx/internal/operators/OperatorMergeTest.java\n--- a/src/test/java/rx/internal/operators/OperatorMergeTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorMergeTest.java\n@@ -15,6 +15,7 @@\n  */\n package rx.internal.operators;\n \n+import static java.util.Arrays.asList;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n@@ -39,13 +40,9 @@\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n \n-import rx.Observable;\n+import rx.*;\n import rx.Observable.OnSubscribe;\n-import rx.Observer;\n-import rx.Scheduler;\n import rx.Scheduler.Worker;\n-import rx.Subscriber;\n-import rx.Subscription;\n import rx.functions.Action0;\n import rx.functions.Action1;\n import rx.functions.Func1;\n@@ -1005,4 +1002,107 @@ public void call(Subscriber<? super Integer> s) {\n         assertEquals(10000, ts.getOnNextEvents().size());\n     }\n \n+    @Test\n+    public void shouldCompleteAfterApplyingBackpressure_NormalPath() {\n+        Observable<Integer> source = Observable.mergeDelayError(Observable.just(Observable.range(1, 2)));\n+        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();\n+        subscriber.requestMore(0);\n+        source.subscribe(subscriber);\n+        subscriber.requestMore(3); // 1, 2, <complete> - with requestMore(2) we get the 1 and 2 but not the <complete>\n+        subscriber.assertReceivedOnNext(asList(1, 2));\n+        subscriber.assertTerminalEvent();\n+    }\n+\n+    @Test\n+    public void shouldCompleteAfterApplyingBackpressure_FastPath() {\n+        Observable<Integer> source = Observable.mergeDelayError(Observable.just(Observable.just(1)));\n+        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();\n+        subscriber.requestMore(0);\n+        source.subscribe(subscriber);\n+        subscriber.requestMore(2); // 1, <complete> - should work as per .._NormalPath above\n+        subscriber.assertReceivedOnNext(asList(1));\n+        subscriber.assertTerminalEvent();\n+    }\n+\n+    @Test\n+    public void shouldNotCompleteIfThereArePendingScalarSynchronousEmissionsWhenTheLastInnerSubscriberCompletes() {\n+        TestScheduler scheduler = Schedulers.test();\n+        Observable<Long> source = Observable.mergeDelayError(Observable.just(1L), Observable.timer(1, TimeUnit.SECONDS, scheduler).skip(1));\n+        TestSubscriber<Long> subscriber = new TestSubscriber<Long>();\n+        subscriber.requestMore(0);\n+        source.subscribe(subscriber);\n+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);\n+        subscriber.assertReceivedOnNext(Collections.<Long>emptyList());\n+        assertEquals(Collections.<Notification<Long>>emptyList(), subscriber.getOnCompletedEvents());\n+        subscriber.requestMore(1);\n+        subscriber.assertReceivedOnNext(asList(1L));\n+        assertEquals(Collections.<Notification<Long>>emptyList(), subscriber.getOnCompletedEvents());\n+        subscriber.requestMore(1);\n+        subscriber.assertTerminalEvent();\n+    }\n+\n+    @Test\n+    public void delayedErrorsShouldBeEmittedWhenCompleteAfterApplyingBackpressure_NormalPath() {\n+        Throwable exception = new Throwable();\n+        Observable<Integer> source = Observable.mergeDelayError(Observable.range(1, 2), Observable.<Integer>error(exception));\n+        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();\n+        subscriber.requestMore(0);\n+        source.subscribe(subscriber);\n+        subscriber.requestMore(3); // 1, 2, <error>\n+        subscriber.assertReceivedOnNext(asList(1, 2));\n+        subscriber.assertTerminalEvent();\n+        assertEquals(asList(exception), subscriber.getOnErrorEvents());\n+    }\n+\n+    @Test\n+    public void delayedErrorsShouldBeEmittedWhenCompleteAfterApplyingBackpressure_FastPath() {\n+        Throwable exception = new Throwable();\n+        Observable<Integer> source = Observable.mergeDelayError(Observable.just(1), Observable.<Integer>error(exception));\n+        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();\n+        subscriber.requestMore(0);\n+        source.subscribe(subscriber);\n+        subscriber.requestMore(2); // 1, <error>\n+        subscriber.assertReceivedOnNext(asList(1));\n+        subscriber.assertTerminalEvent();\n+        assertEquals(asList(exception), subscriber.getOnErrorEvents());\n+    }\n+\n+    @Test\n+    public void shouldNotCompleteWhileThereAreStillScalarSynchronousEmissionsInTheQueue() {\n+        Observable<Integer> source = Observable.merge(Observable.just(1), Observable.just(2));\n+        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();\n+        subscriber.requestMore(1);\n+        source.subscribe(subscriber);\n+        subscriber.assertReceivedOnNext(asList(1));\n+        subscriber.requestMore(1);\n+        subscriber.assertReceivedOnNext(asList(1, 2));\n+    }\n+\n+    @Test\n+    public void shouldNotReceivedDelayedErrorWhileThereAreStillScalarSynchronousEmissionsInTheQueue() {\n+        Throwable exception = new Throwable();\n+        Observable<Integer> source = Observable.mergeDelayError(Observable.just(1), Observable.just(2), Observable.<Integer>error(exception));\n+        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();\n+        subscriber.requestMore(1);\n+        source.subscribe(subscriber);\n+        subscriber.assertReceivedOnNext(asList(1));\n+        assertEquals(Collections.<Throwable>emptyList(), subscriber.getOnErrorEvents());\n+        subscriber.requestMore(1);\n+        subscriber.assertReceivedOnNext(asList(1, 2));\n+        assertEquals(asList(exception), subscriber.getOnErrorEvents());\n+    }\n+\n+    @Test\n+    public void shouldNotReceivedDelayedErrorWhileThereAreStillNormalEmissionsInTheQueue() {\n+        Throwable exception = new Throwable();\n+        Observable<Integer> source = Observable.mergeDelayError(Observable.range(1, 2), Observable.range(3, 2), Observable.<Integer>error(exception));\n+        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();\n+        subscriber.requestMore(3);\n+        source.subscribe(subscriber);\n+        subscriber.assertReceivedOnNext(asList(1, 2, 3));\n+        assertEquals(Collections.<Throwable>emptyList(), subscriber.getOnErrorEvents());\n+        subscriber.requestMore(2);\n+        subscriber.assertReceivedOnNext(asList(1, 2, 3, 4));\n+        assertEquals(asList(exception), subscriber.getOnErrorEvents());\n+    }\n }",
    "output": "Fix for merge dropping values from scalarValueQueue and not completing during request(..) when the last value emitted was from scalarValueQueue"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -5801,8 +5801,19 @@ public final Observable<T> repeat(final long count, Scheduler scheduler) {\n      * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Creating-Observables#repeatwhen\">RxJava Wiki: repeatWhen()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229428.aspx\">MSDN: Observable.Repeat</a>\n      */\n-    public final Observable<T> repeatWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> notificationHandler, Scheduler scheduler) {\n-        return OnSubscribeRedo.repeat(this, notificationHandler, scheduler);\n+    public final Observable<T> repeatWhen(final Func1<? super Observable<? extends Void>, ? extends Observable<?>> notificationHandler, Scheduler scheduler) {\n+        Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> dematerializedNotificationHandler = new Func1<Observable<? extends Notification<?>>, Observable<?>>() {\n+            @Override\n+            public Observable<?> call(Observable<? extends Notification<?>> notifications) {\n+                return notificationHandler.call(notifications.map(new Func1<Notification<?>, Void>() {\n+                    @Override\n+                    public Void call(Notification<?> notification) {\n+                        return null;\n+                    }\n+                }));\n+            }\n+        };\n+        return OnSubscribeRedo.repeat(this, dematerializedNotificationHandler, scheduler);\n     }\n \n     /**\n@@ -5825,8 +5836,19 @@ public final Observable<T> repeatWhen(Func1<? super Observable<? extends Notific\n      * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Creating-Observables#repeatwhen\">RxJava Wiki: repeatWhen()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229428.aspx\">MSDN: Observable.Repeat</a>\n      */\n-    public final Observable<T> repeatWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> notificationHandler) {\n-        return OnSubscribeRedo.repeat(this, notificationHandler);\n+    public final Observable<T> repeatWhen(final Func1<? super Observable<? extends Void>, ? extends Observable<?>> notificationHandler) {\n+        Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> dematerializedNotificationHandler = new Func1<Observable<? extends Notification<?>>, Observable<?>>() {\n+            @Override\n+            public Observable<?> call(Observable<? extends Notification<?>> notifications) {\n+                return notificationHandler.call(notifications.map(new Func1<Notification<?>, Void>() {\n+                    @Override\n+                    public Void call(Notification<?> notification) {\n+                        return null;\n+                    }\n+                }));\n+            }\n+        };\n+        return OnSubscribeRedo.repeat(this, dematerializedNotificationHandler);\n     }\n \n     /**\n@@ -6541,8 +6563,19 @@ public final Observable<T> retry(Func2<Integer, Throwable, Boolean> predicate) {\n      * @return the source Observable modified with retry logic\n      * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators#retrywhen\">RxJava Wiki: retryWhen()</a>\n      */\n-    public final Observable<T> retryWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> notificationHandler) {\n-        return OnSubscribeRedo.<T> retry(this, notificationHandler);\n+    public final Observable<T> retryWhen(final Func1<? super Observable<? extends Throwable>, ? extends Observable<?>> notificationHandler) {\n+        Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> dematerializedNotificationHandler = new Func1<Observable<? extends Notification<?>>, Observable<?>>() {\n+            @Override\n+            public Observable<?> call(Observable<? extends Notification<?>> notifications) {\n+                return notificationHandler.call(notifications.map(new Func1<Notification<?>, Throwable>() {\n+                    @Override\n+                    public Throwable call(Notification<?> notification) {\n+                        return notification.getThrowable();\n+                    }\n+                }));\n+            }\n+        };\n+        return OnSubscribeRedo.<T> retry(this, dematerializedNotificationHandler);\n     }\n \n     /**\n@@ -6566,8 +6599,19 @@ public final Observable<T> retryWhen(Func1<? super Observable<? extends Notifica\n      * @return the source Observable modified with retry logic\n      * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators#retrywhen\">RxJava Wiki: retryWhen()</a>\n      */\n-    public final Observable<T> retryWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> notificationHandler, Scheduler scheduler) {\n-        return OnSubscribeRedo.<T> retry(this, notificationHandler, scheduler);\n+    public final Observable<T> retryWhen(final Func1<? super Observable<? extends Throwable>, ? extends Observable<?>> notificationHandler, Scheduler scheduler) {\n+        Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> dematerializedNotificationHandler = new Func1<Observable<? extends Notification<?>>, Observable<?>>() {\n+            @Override\n+            public Observable<?> call(Observable<? extends Notification<?>> notifications) {\n+                return notificationHandler.call(notifications.map(new Func1<Notification<?>, Throwable>() {\n+                    @Override\n+                    public Throwable call(Notification<?> notification) {\n+                        return notification.getThrowable();\n+                    }\n+                }));\n+            }\n+        };\n+        return OnSubscribeRedo.<T> retry(this, dematerializedNotificationHandler, scheduler);\n     }\n \n     /**",
    "output": "Add a shim to make it so the public api for repeatWhen and retryWhen don't expose Notification<?>"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/BufferUntilSubscriber.java b/src/main/java/rx/internal/operators/BufferUntilSubscriber.java\n--- a/src/main/java/rx/internal/operators/BufferUntilSubscriber.java\n+++ b/src/main/java/rx/internal/operators/BufferUntilSubscriber.java\n@@ -21,6 +21,7 @@\n import rx.Observer;\n import rx.Subscriber;\n import rx.functions.Action0;\n+import rx.observers.EmptyObserver;\n import rx.observers.Subscribers;\n import rx.subjects.Subject;\n import rx.subscriptions.Subscriptions;\n@@ -50,6 +51,9 @@\n  */\n public class BufferUntilSubscriber<T> extends Subject<T, T> {\n \n+    @SuppressWarnings(\"rawtypes\")\n+    private final static Observer EMPTY_OBSERVER = new EmptyObserver();\n+\n     /**\n      * @warn create() undescribed\n      * @return\n@@ -92,7 +96,7 @@ public void call(final Subscriber<? super T> s) {\n                 s.add(Subscriptions.create(new Action0() {\n                     @Override\n                     public void call() {\n-                        state.observerRef = Subscribers.empty();\n+                        state.observerRef = EMPTY_OBSERVER;\n                     }\n                 }));\n                 boolean win = false;",
    "output": "Use EmptyObserver instead of Subscribers.empty()\n\nonError should be ignored after unsubscribe is called"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorTakeUntil.java b/src/main/java/rx/internal/operators/OperatorTakeUntil.java\n--- a/src/main/java/rx/internal/operators/OperatorTakeUntil.java\n+++ b/src/main/java/rx/internal/operators/OperatorTakeUntil.java\n@@ -36,24 +36,7 @@ public OperatorTakeUntil(final Observable<? extends E> other) {\n \n     @Override\n     public Subscriber<? super T> call(final Subscriber<? super T> child) {\n-        final Subscriber<T> parent = new SerializedSubscriber<T>(child) {\n-\n-            @Override\n-            public void onCompleted() {\n-                child.onCompleted();\n-            }\n-\n-            @Override\n-            public void onError(Throwable e) {\n-                child.onError(e);\n-            }\n-\n-            @Override\n-            public void onNext(T t) {\n-                child.onNext(t);\n-            }\n-\n-        };\n+        final Subscriber<T> parent = new SerializedSubscriber<T>(child);\n \n         other.unsafeSubscribe(new Subscriber<E>(child) {\n ",
    "output": "Fix Rx serialization bug in takeUntil again"
  },
  {
    "input": "diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java\n--- a/src/main/java/rx/Observable.java\n+++ b/src/main/java/rx/Observable.java\n@@ -174,15 +174,17 @@ public void call(Subscriber<? super R> o) {\n      * @return the source Observable, transformed by the transformer function\n      * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators</a>\n      */\n-    public <R> Observable<R> compose(Transformer<? super T, R> transformer) {\n-        return transformer.call(this);\n+    @SuppressWarnings(\"unchecked\")\n+    public <R> Observable<R> compose(Transformer<? super T, ? extends R> transformer) {\n+        // Casting to Observable<R> is type-safe because we know Observable is covariant.\n+        return (Observable<R>) transformer.call(this);\n     }\n     \n     /**\n      * Transformer function used by {@link #compose}.\n      * @warn more complete description needed\n      */\n-    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<R>> {\n+    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<? extends R>> {\n         // cover for generics insanity\n     }\n     \n\ndiff --git a/src/test/java/rx/CovarianceTest.java b/src/test/java/rx/CovarianceTest.java\n--- a/src/test/java/rx/CovarianceTest.java\n+++ b/src/test/java/rx/CovarianceTest.java\n@@ -20,12 +20,13 @@\n import org.junit.Test;\n \n import rx.Observable.Transformer;\n+import rx.functions.Func1;\n import rx.functions.Func2;\n \n /**\n  * Test super/extends of generics.\n  * \n- * See https://github.com/ReactiveX/RxJava/pull/331\n+ * See https://github.com/Netflix/RxJava/pull/331\n  */\n public class CovarianceTest {\n \n@@ -61,11 +62,11 @@ public Integer call(Media t1, Media t2) {\n     \n     @Test\n     public void testCovarianceOfCompose() {\n-        Observable<HorrorMovie> movie = Observable.<HorrorMovie> just(new HorrorMovie());\n+        Observable<HorrorMovie> movie = Observable.just(new HorrorMovie());\n         Observable<Movie> movie2 = movie.compose(new Transformer<Movie, Movie>() {\n \n             @Override\n-            public Observable<Movie> call(Observable<? extends Movie> t1) {\n+            public Observable<? extends Movie> call(Observable<? extends Movie> t1) {\n                 return Observable.just(new Movie());\n             }\n             \n@@ -77,12 +78,45 @@ public void testCovarianceOfCompose2() {\n         Observable<Movie> movie = Observable.<Movie> just(new HorrorMovie());\n         Observable<HorrorMovie> movie2 = movie.compose(new Transformer<Movie, HorrorMovie>() {\n             @Override\n-            public Observable<HorrorMovie> call(Observable<? extends Movie> t1) {\n+            public Observable<? extends HorrorMovie> call(Observable<? extends Movie> t1) {\n                 return Observable.just(new HorrorMovie());\n             }\n         });\n     }\n-    \n+\n+    @Test\n+    public void testCovarianceOfCompose3() {\n+        Observable<Movie> movie = Observable.<Movie>just(new HorrorMovie());\n+        Observable<HorrorMovie> movie2 = movie.compose(new Transformer<Movie, HorrorMovie>() {\n+            @Override\n+            public Observable<? extends HorrorMovie> call(Observable<? extends Movie> t1) {\n+                return Observable.just(new HorrorMovie()).map(new Func1<HorrorMovie, HorrorMovie>() {\n+\n+                    @Override\n+                    public HorrorMovie call(HorrorMovie horrorMovie) {\n+                        return horrorMovie;\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testCovarianceOfCompose4() {\n+        Observable<HorrorMovie> movie = Observable.just(new HorrorMovie());\n+        Observable<HorrorMovie> movie2 = movie.compose(new Transformer<HorrorMovie, HorrorMovie>() {\n+            @Override\n+            public Observable<? extends HorrorMovie> call(Observable<? extends HorrorMovie> t1) {\n+                return t1.map(new Func1<HorrorMovie, HorrorMovie>() {\n+\n+                    @Override\n+                    public HorrorMovie call(HorrorMovie horrorMovie) {\n+                        return horrorMovie;\n+                    }\n+                });\n+            }\n+        });\n+    }\n     \n     /*\n      * Most tests are moved into their applicable classes such as [Operator]Tests.java",
    "output": "Fix compose generics"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorMerge.java b/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -409,7 +409,7 @@ public void onError(Throwable e) {\n                 boolean sendOnComplete = false;\n                 synchronized (this) {\n                     wip--;\n-                    if (wip == 0 && completed) {\n+                    if ((wip == 0 && completed) || (wip < 0)) {\n                         sendOnComplete = true;\n                     }\n                 }\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java b/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n--- a/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n@@ -46,36 +46,6 @@ public void before() {\n         MockitoAnnotations.initMocks(this);\n     }\n \n-    @Test(timeout=1000L)\n-    public void testSynchronousError() {\n-        final Observable<Observable<String>> o1 = Observable.error(new RuntimeException(\"unit test\"));\n-\n-        final CountDownLatch latch = new CountDownLatch(1);\n-        Observable.mergeDelayError(o1).subscribe(new Subscriber<String>() {\n-            @Override\n-            public void onCompleted() {\n-                fail(\"Expected onError path\");\n-            }\n-\n-            @Override\n-            public void onError(Throwable e) {\n-                latch.countDown();\n-            }\n-\n-            @Override\n-            public void onNext(String s) {\n-                fail(\"Expected onError path\");\n-            }\n-        });\n-\n-        try {\n-            latch.await();\n-        } catch (InterruptedException ex) {\n-            fail(\"interrupted\");\n-        }\n-    }\n-\n-\n     @Test\n     public void testErrorDelayed1() {\n         final Observable<String> o1 = Observable.create(new TestErrorObservable(\"four\", null, \"six\")); // we expect to lose \"six\" from the source (and it should never be sent by the source since onError was called\n@@ -313,6 +283,35 @@ public void testMergeArrayWithThreading() {\n         verify(stringObserver, times(1)).onCompleted();\n     }\n \n+    @Test(timeout=1000L)\n+    public void testSynchronousError() {\n+        final Observable<Observable<String>> o1 = Observable.error(new RuntimeException(\"unit test\"));\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        Observable.mergeDelayError(o1).subscribe(new Subscriber<String>() {\n+            @Override\n+            public void onCompleted() {\n+                fail(\"Expected onError path\");\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                latch.countDown();\n+            }\n+\n+            @Override\n+            public void onNext(String s) {\n+                fail(\"Expected onError path\");\n+            }\n+        });\n+\n+        try {\n+            latch.await();\n+        } catch (InterruptedException ex) {\n+            fail(\"interrupted\");\n+        }\n+    }\n+\n     private static class TestSynchronousObservable implements Observable.OnSubscribe<String> {\n \n         @Override",
    "output": "Fix the failing Observable.mergeDelayError synchronous error unit test"
  },
  {
    "input": "diff --git a/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java b/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n--- a/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorMergeDelayErrorTest.java\n@@ -15,33 +15,27 @@\n  */\n package rx.internal.operators;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Matchers.any;\n-import static org.mockito.Matchers.anyInt;\n-import static org.mockito.Mockito.inOrder;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n-\n import rx.Observable;\n import rx.Observable.OnSubscribe;\n import rx.Observer;\n import rx.Subscriber;\n import rx.exceptions.CompositeException;\n import rx.exceptions.TestException;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Mockito.*;\n+\n public class OperatorMergeDelayErrorTest {\n \n     @Mock\n@@ -52,6 +46,36 @@ public void before() {\n         MockitoAnnotations.initMocks(this);\n     }\n \n+    @Test(timeout=1000L)\n+    public void testSynchronousError() {\n+        final Observable<Observable<String>> o1 = Observable.error(new RuntimeException(\"unit test\"));\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        Observable.mergeDelayError(o1).subscribe(new Subscriber<String>() {\n+            @Override\n+            public void onCompleted() {\n+                fail(\"Expected onError path\");\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                latch.countDown();\n+            }\n+\n+            @Override\n+            public void onNext(String s) {\n+                fail(\"Expected onError path\");\n+            }\n+        });\n+\n+        try {\n+            latch.await();\n+        } catch (InterruptedException ex) {\n+            fail(\"interrupted\");\n+        }\n+    }\n+\n+\n     @Test\n     public void testErrorDelayed1() {\n         final Observable<String> o1 = Observable.create(new TestErrorObservable(\"four\", null, \"six\")); // we expect to lose \"six\" from the source (and it should never be sent by the source since onError was called",
    "output": "Add a unit test to demonstrate regression in Observable.mergeDelayError"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorTakeUntil.java b/src/main/java/rx/internal/operators/OperatorTakeUntil.java\n--- a/src/main/java/rx/internal/operators/OperatorTakeUntil.java\n+++ b/src/main/java/rx/internal/operators/OperatorTakeUntil.java\n@@ -18,6 +18,7 @@\n import rx.Observable;\n import rx.Observable.Operator;\n import rx.Subscriber;\n+import rx.observers.SerializedSubscriber;\n \n /**\n  * Returns an Observable that emits the items from the source Observable until another Observable\n@@ -35,7 +36,7 @@ public OperatorTakeUntil(final Observable<? extends E> other) {\n \n     @Override\n     public Subscriber<? super T> call(final Subscriber<? super T> child) {\n-        final Subscriber<T> parent = new Subscriber<T>(child) {\n+        final Subscriber<T> parent = new SerializedSubscriber<T>(child) {\n \n             @Override\n             public void onCompleted() {",
    "output": "Make TakeUntil obey Rx contract"
  },
  {
    "input": "diff --git a/src/main/java/rx/internal/operators/OperatorSwitch.java b/src/main/java/rx/internal/operators/OperatorSwitch.java\n--- a/src/main/java/rx/internal/operators/OperatorSwitch.java\n+++ b/src/main/java/rx/internal/operators/OperatorSwitch.java\n@@ -62,6 +62,7 @@ private static final class SwitchSubscriber<T> extends Subscriber<Observable<? e\n         volatile boolean infinite = false;\n \n         public SwitchSubscriber(Subscriber<? super T> child) {\n+            super(child);\n             s = new SerializedSubscriber<T>(child);\n             ssub = new SerialSubscription();\n             child.add(ssub);\n\ndiff --git a/src/test/java/rx/internal/operators/OperatorSwitchTest.java b/src/test/java/rx/internal/operators/OperatorSwitchTest.java\n--- a/src/test/java/rx/internal/operators/OperatorSwitchTest.java\n+++ b/src/test/java/rx/internal/operators/OperatorSwitchTest.java\n@@ -15,6 +15,7 @@\n  */\n package rx.internal.operators;\n \n+import static org.junit.Assert.assertTrue;\n import static org.mockito.Matchers.any;\n import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.inOrder;\n@@ -25,6 +26,7 @@\n \n import java.util.Arrays;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.junit.Before;\n import org.junit.Test;\n@@ -513,4 +515,19 @@ public void onNext(String s) {\n         testSubscriber.assertNoErrors();\n         testSubscriber.assertTerminalEvent();\n     }\n+\n+    @Test\n+    public void testUnsubscribe() {\n+        final AtomicBoolean isUnsubscribed = new AtomicBoolean();\n+        Observable.switchOnNext(\n+                Observable.create(new Observable.OnSubscribe<Observable<Integer>>() {\n+                    @Override\n+                    public void call(final Subscriber<? super Observable<Integer>> subscriber) {\n+                        subscriber.onNext(Observable.just(1));\n+                        isUnsubscribed.set(subscriber.isUnsubscribed());\n+                    }\n+                })\n+        ).take(1).subscribe();\n+        assertTrue(\"Switch doesn't propagate 'unsubscribe'\", isUnsubscribed.get());\n+    }\n }",
    "output": "Fix the bug that Switch doesn't propagate 'unsubscribe'"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -6667,7 +6667,7 @@ public final Observable<T> repeat(final long count, Scheduler scheduler) {\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229428.aspx\">MSDN: Observable.Repeat</a>\n      * @since 0.20\n      */\n-    public final Observable<T> repeatWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<? extends Notification<?>>> notificationHandler, Scheduler scheduler) {\n+    public final Observable<T> repeatWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> notificationHandler, Scheduler scheduler) {\n         return OnSubscribeRedo.repeat(this, notificationHandler, scheduler);\n     }\n \n@@ -6692,7 +6692,7 @@ public final Observable<T> repeatWhen(Func1<? super Observable<? extends Notific\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229428.aspx\">MSDN: Observable.Repeat</a>\n      * @since 0.20\n      */\n-    public final Observable<T> repeatWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<? extends Notification<?>>> notificationHandler) {\n+    public final Observable<T> repeatWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> notificationHandler) {\n         return OnSubscribeRedo.repeat(this, notificationHandler);\n     }\n ",
    "output": "Remove the unnecessary ` extends Notification<?>` from repeatWhen too"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -7435,7 +7435,7 @@ public final Observable<T> retryWhen(Func1<? super Observable<? extends Notifica\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#retrywhen\">RxJava Wiki: retryWhen()</a>\n      * @since 0.20\n      */\n-    public final Observable<T> retryWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<? extends Notification<?>>> notificationHandler, Scheduler scheduler) {\n+    public final Observable<T> retryWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> notificationHandler, Scheduler scheduler) {\n         return OnSubscribeRedo.<T> retry(this, notificationHandler, scheduler);\n     }\n ",
    "output": "Make retryWhen the same with the Scheduler as the retryWhen without the Scheduler"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -10357,4 +10357,19 @@ public void call(Subscriber<? super T> observer) {\n             });\n         }\n     }\n+\n+    /**\n+     * Modifies the source {@code Observable} so that it invokes the given action when it is unsubscribed from\n+     * its subscribers. Each un-subscription will result in an invocation of the given action except when the\n+     * source {@code Observable} is reference counted, in which case the source {@code Observable} will invoke\n+     * the given action for the very last un-subscription.\n+     *\n+     *\n+     * @param unsubscribe The action that gets called when this {@code Observable} is unsubscribed.\n+     *\n+     * @return That modified {@code Observable}\n+     */\n+    public final Observable<T> doOnUnsubscribe(final Action0 unsubscribe) {\n+        return lift(new OperatorDoOnUnsubscribe<T>(unsubscribe));\n+    }\n }\n\ndiff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnUnsubscribe.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnUnsubscribe.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnUnsubscribe.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnUnsubscribe.java\n@@ -0,0 +1,47 @@\n+/**\n+ * Copyright 2014 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.internal.operators;\n+\n+import rx.Observable;\n+import rx.Observable.Operator;\n+import rx.Subscriber;\n+import rx.functions.Action0;\n+import rx.subscriptions.Subscriptions;\n+\n+/**\n+ * This operator modifies an {@link rx.Observable} so a given action is invoked when the {@link rx.Observable} is unsubscribed.\n+ * @param <T> The type of the elements in the {@link rx.Observable} that this operator modifies\n+ */\n+public class OperatorDoOnUnsubscribe<T> implements Operator<T, T> {\n+    private final Action0 unsubscribe;\n+\n+    /**\n+     * Constructs an instance of the operator with the callback that gets invoked when the modified Observable is unsubscribed\n+     * @param unsubscribe The action that gets invoked when the modified {@link rx.Observable} is unsubscribed\n+     */\n+    public OperatorDoOnUnsubscribe(Action0 unsubscribe) {\n+        this.unsubscribe = unsubscribe;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> call(final Subscriber<? super T> child) {\n+        child.add(Subscriptions.create(unsubscribe));\n+\n+        // Pass through since this operator is for notification only, there is\n+        // no change to the stream whatsoever.\n+        return child;\n+    }\n+}\n\ndiff --git a/rxjava-core/src/test/java/rx/ObservableTests.java b/rxjava-core/src/test/java/rx/ObservableTests.java\n--- a/rxjava-core/src/test/java/rx/ObservableTests.java\n+++ b/rxjava-core/src/test/java/rx/ObservableTests.java\n@@ -48,6 +48,7 @@\n import rx.Observable.OnSubscribe;\n import rx.Observable.Transformer;\n import rx.exceptions.OnErrorNotImplementedException;\n+import rx.functions.Action0;\n import rx.functions.Action1;\n import rx.functions.Action2;\n import rx.functions.Func1;\n@@ -1124,4 +1125,126 @@ public String call(Integer t1) {\n         ts.assertNoErrors();\n         ts.assertReceivedOnNext(Arrays.asList(\"1\", \"2\", \"3\"));\n     }\n+\n+    @Test\n+    public void testDoOnUnsubscribe() throws Exception {\n+        int subCount = 3;\n+        final CountDownLatch upperLatch = new CountDownLatch(subCount);\n+        final CountDownLatch lowerLatch = new CountDownLatch(subCount);\n+        final CountDownLatch onNextLatch = new CountDownLatch(subCount);\n+\n+        final AtomicInteger upperCount = new AtomicInteger();\n+        final AtomicInteger lowerCount = new AtomicInteger();\n+        Observable<Long> longs = Observable\n+            // The stream needs to be infinite to ensure the stream does not terminate\n+            // before it is unsubscribed\n+            .interval(50, TimeUnit.MILLISECONDS)\n+            .doOnUnsubscribe(new Action0() {\n+                // Test that upper stream will be notified for un-subscription\n+                // from a child subscriber\n+                @Override\n+                public void call() {\n+                    upperLatch.countDown();\n+                    upperCount.incrementAndGet();\n+                }\n+            })\n+            .doOnNext(new Action1<Long>() {\n+                @Override\n+                public void call(Long aLong) {\n+                    // Ensure there is at least some onNext events before un-subscription happens\n+                    onNextLatch.countDown();\n+                }\n+            })\n+            .doOnUnsubscribe(new Action0() {\n+                // Test that lower stream will be notified for a direct un-subscription\n+                @Override\n+                public void call() {\n+                    lowerLatch.countDown();\n+                    lowerCount.incrementAndGet();\n+                }\n+            });\n+\n+        List<Subscription> subscriptions = new ArrayList<Subscription>();\n+        List<TestSubscriber> subscribers = new ArrayList<TestSubscriber>();\n+\n+        for(int i = 0; i < subCount; ++i) {\n+            TestSubscriber<Long> subscriber = new TestSubscriber<Long>();\n+            subscriptions.add(longs.subscribe(subscriber));\n+            subscribers.add(subscriber);\n+        }\n+\n+        onNextLatch.await();\n+        for(int i = 0; i < subCount; ++i) {\n+            subscriptions.get(i).unsubscribe();\n+            // Test that unsubscribe() method is not affected in any way\n+            subscribers.get(i).assertUnsubscribed();\n+        }\n+\n+        upperLatch.await();\n+        lowerLatch.await();\n+        assertEquals(String.format(\"There should exactly %d un-subscription events for upper stream\", subCount), subCount, upperCount.get());\n+        assertEquals(String.format(\"There should exactly %d un-subscription events for lower stream\", subCount), subCount, lowerCount.get());\n+    }\n+\n+    @Test\n+    public void testDoOnUnSubscribeWorksWithRefCount() throws Exception {\n+        int subCount = 3;\n+        final CountDownLatch upperLatch = new CountDownLatch(1);\n+        final CountDownLatch lowerLatch = new CountDownLatch(1);\n+        final CountDownLatch onNextLatch = new CountDownLatch(subCount);\n+\n+        final AtomicInteger upperCount = new AtomicInteger();\n+        final AtomicInteger lowerCount = new AtomicInteger();\n+        Observable<Long> longs = Observable\n+            // The stream needs to be infinite to ensure the stream does not terminate\n+            // before it is unsubscribed\n+            .interval(50, TimeUnit.MILLISECONDS)\n+            .doOnUnsubscribe(new Action0() {\n+                // Test that upper stream will be notified for un-subscription\n+                @Override\n+                public void call() {\n+                    upperLatch.countDown();\n+                    upperCount.incrementAndGet();\n+                }\n+            })\n+            .doOnNext(new Action1<Long>() {\n+                @Override\n+                public void call(Long aLong) {\n+                    // Ensure there is at least some onNext events before un-subscription happens\n+                    onNextLatch.countDown();\n+                }\n+            })\n+            .doOnUnsubscribe(new Action0() {\n+                // Test that lower stream will be notified for un-subscription\n+                @Override\n+                public void call() {\n+                    lowerLatch.countDown();\n+                    lowerCount.incrementAndGet();\n+                }\n+            })\n+            .publish()\n+            .refCount();\n+\n+        List<Subscription> subscriptions = new ArrayList<Subscription>();\n+        List<TestSubscriber> subscribers = new ArrayList<TestSubscriber>();\n+\n+        for(int i = 0; i < subCount; ++i) {\n+            TestSubscriber<Long> subscriber = new TestSubscriber<Long>();\n+            subscriptions.add(longs.subscribe(subscriber));\n+            subscribers.add(subscriber);\n+        }\n+\n+        onNextLatch.await();\n+        for(int i = 0; i < subCount; ++i) {\n+            subscriptions.get(i).unsubscribe();\n+            // Test that unsubscribe() method is not affected in any way\n+            subscribers.get(i).assertUnsubscribed();\n+        }\n+\n+        upperLatch.await();\n+        lowerLatch.await();\n+        assertEquals(\"There should exactly 1 un-subscription events for upper stream\", 1, upperCount.get());\n+        assertEquals(\"There should exactly 1 un-subscription events for lower stream\", 1, lowerCount.get());\n+\n+    }\n }",
    "output": "Add doOnSubscribe() to Observable"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/ObservableTests.java b/rxjava-core/src/test/java/rx/ObservableTests.java\n--- a/rxjava-core/src/test/java/rx/ObservableTests.java\n+++ b/rxjava-core/src/test/java/rx/ObservableTests.java\n@@ -1108,7 +1108,7 @@ public void testCompose() {\n         Observable.from(1, 2, 3).compose(new Transformer<Integer, String>() {\n \n             @Override\n-            public Observable<? extends String> call(Observable<? extends Integer> t1) {\n+            public Observable<String> call(Observable<? extends Integer> t1) {\n                 return t1.map(new Func1<Integer, String>() {\n                     \n                     @Override",
    "output": "Fix the 'compose' unit test"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -204,7 +204,7 @@ public void call(Subscriber<? super R> o) {\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators</a>\n      * @since 0.20\n      */\n-    public <R> Observable<? extends R> compose(Transformer<? super T, ? extends R> transformer) {\n+    public <R> Observable<R> compose(Transformer<? super T, R> transformer) {\n         return transformer.call(this);\n     }\n     \n@@ -213,7 +213,7 @@ public <R> Observable<? extends R> compose(Transformer<? super T, ? extends R> t\n      * @warn more complete description needed\n      * @since 0.20\n      */\n-    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<? extends R>> {\n+    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<R>> {\n         // cover for generics insanity\n     }\n     \n\ndiff --git a/rxjava-core/src/test/java/rx/CovarianceTest.java b/rxjava-core/src/test/java/rx/CovarianceTest.java\n--- a/rxjava-core/src/test/java/rx/CovarianceTest.java\n+++ b/rxjava-core/src/test/java/rx/CovarianceTest.java\n@@ -62,10 +62,10 @@ public Integer call(Media t1, Media t2) {\n     @Test\n     public void testCovarianceOfCompose() {\n         Observable<HorrorMovie> movie = Observable.<HorrorMovie> from(new HorrorMovie());\n-        movie.compose(new Transformer<Movie, Movie>() {\n+        Observable<Movie> movie2 = movie.compose(new Transformer<Movie, Movie>() {\n \n             @Override\n-            public Observable<? extends Movie> call(Observable<? extends Movie> t1) {\n+            public Observable<Movie> call(Observable<? extends Movie> t1) {\n                 return Observable.from(new Movie());\n             }\n             \n@@ -75,9 +75,9 @@ public Observable<? extends Movie> call(Observable<? extends Movie> t1) {\n     @Test\n     public void testCovarianceOfCompose2() {\n         Observable<Movie> movie = Observable.<Movie> from(new HorrorMovie());\n-        movie.compose(new Transformer<Movie, Movie>() {\n+        Observable<HorrorMovie> movie2 = movie.compose(new Transformer<Movie, HorrorMovie>() {\n             @Override\n-            public Observable<? extends Movie> call(Observable<? extends Movie> t1) {\n+            public Observable<HorrorMovie> call(Observable<? extends Movie> t1) {\n                 return Observable.from(new HorrorMovie());\n             }\n         });",
    "output": "Fix the compose covariance"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/schedulers/ExecutorSchedulerTest.java b/rxjava-core/src/test/java/rx/schedulers/ExecutorSchedulerTest.java\n--- a/rxjava-core/src/test/java/rx/schedulers/ExecutorSchedulerTest.java\n+++ b/rxjava-core/src/test/java/rx/schedulers/ExecutorSchedulerTest.java\n@@ -18,13 +18,16 @@\n import rx.Scheduler;\n import rx.internal.util.RxThreadFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.Executors;\n \n public class ExecutorSchedulerTest extends AbstractSchedulerConcurrencyTests {\n \n+    final static Executor executor = Executors.newFixedThreadPool(2, new RxThreadFactory(\"TestCustomPool-\"));\n+    \n     @Override\n     protected Scheduler getScheduler() {\n-        return Schedulers.from(Executors.newFixedThreadPool(2, new RxThreadFactory(\"TestCustomPool-\")));\n+        return Schedulers.from(executor);\n     }\n     \n }",
    "output": "Use single Executor for all tests\n\n... so it doesn't leak for every test"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java\n@@ -89,7 +89,11 @@ public T next() {\n             }\n \n             private Notification<? extends T> take() {\n-                return notifications.poll();\n+                try {\n+                    return notifications.take();\n+                } catch (InterruptedException e) {\n+                    throw Exceptions.propagate(e);\n+                }\n             }\n \n             @Override",
    "output": "Remove Temporary Timeout in take\n\nFix it properly this time :-)"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java\n@@ -89,18 +89,7 @@ public T next() {\n             }\n \n             private Notification<? extends T> take() {\n-                try {\n-                    // TODO remove this timeout and logging before final release of 0.20\n-                    Notification<? extends T> n = notifications.poll(10000, TimeUnit.MILLISECONDS);\n-                    if(n == null) {\n-                        System.err.println(\"Timed out waiting for value. File a bug at github.com/Netflix/RxJava\");\n-                        throw new RuntimeException(\"Timed out waiting for value. File a bug at github.com/Netflix/RxJava\");\n-                    } else {\n-                        return n;\n-                    }\n-                } catch (InterruptedException e) {\n-                    throw Exceptions.propagate(e);\n-                }\n+                return notifications.poll();\n             }\n \n             @Override",
    "output": "Remove Timeout in Blocking Iterator\n\nThis was a temporary timeout to track down bugs"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -1027,7 +1027,7 @@ public final static <T> Observable<T> concat(Observable<? extends T> t1, Observa\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Creating-Observables#defer\">RxJava wiki: defer</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229160.aspx\">MSDN: Observable.Defer</a>\n      */\n-    public final static <T> Observable<T> defer(Func0<? extends Observable<? extends T>> observableFactory) {\n+    public final static <T> Observable<T> defer(Func0<Observable<T>> observableFactory) {\n         return create(new OnSubscribeDefer<T>(observableFactory));\n     }\n ",
    "output": "Remove Variance on Defer\n\nSee https://github.com/Netflix/RxJava/issues/1157 for painful background"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java\n@@ -16,6 +16,7 @@\n package rx.internal.operators;\n \n import java.util.Iterator;\n+import java.util.NoSuchElementException;\n \n import rx.Observable;\n import rx.Subscriber;\n@@ -41,54 +42,24 @@ public final class BlockingOperatorMostRecent {\n      *         {@code initialValue} if {@code source} has not yet emitted any items\n      */\n     public static <T> Iterable<T> mostRecent(final Observable<? extends T> source, final T initialValue) {\n-\n         return new Iterable<T>() {\n             @Override\n             public Iterator<T> iterator() {\n                 MostRecentObserver<T> mostRecentObserver = new MostRecentObserver<T>(initialValue);\n-                final MostRecentIterator<T> nextIterator = new MostRecentIterator<T>(mostRecentObserver);\n \n                 /**\n                  * Subscribe instead of unsafeSubscribe since this is the final subscribe in the chain\n                  * since it is for BlockingObservable.\n                  */\n                 source.subscribe(mostRecentObserver);\n \n-                return nextIterator;\n+                return mostRecentObserver.getIterable();\n             }\n         };\n-\n-    }\n-\n-    private static class MostRecentIterator<T> implements Iterator<T> {\n-\n-        private final MostRecentObserver<T> observer;\n-\n-        private MostRecentIterator(MostRecentObserver<T> observer) {\n-            this.observer = observer;\n-        }\n-\n-        @Override\n-        public boolean hasNext() {\n-            return !observer.isCompleted();\n-        }\n-\n-        @Override\n-        public T next() {\n-            if (observer.getThrowable() != null) {\n-                throw Exceptions.propagate(observer.getThrowable());\n-            }\n-            return observer.getRecentValue();\n-        }\n-\n-        @Override\n-        public void remove() {\n-            throw new UnsupportedOperationException(\"Read only iterator\");\n-        }\n     }\n \n     private static class MostRecentObserver<T> extends Subscriber<T> {\n-        static final NotificationLite<Object> nl = NotificationLite.instance();\n+        final NotificationLite<T> nl = NotificationLite.instance();\n         volatile Object value;\n         \n         private MostRecentObserver(T value) {\n@@ -110,19 +81,47 @@ public void onNext(T args) {\n             value = nl.next(args);\n         }\n \n-        private boolean isCompleted() {\n-            return nl.isCompleted(value);\n-        }\n-\n-        private Throwable getThrowable() {\n-            Object v = value;\n-            return nl.isError(v) ? nl.getError(v) : null;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        private T getRecentValue() {\n-            return (T)value;\n+        /**\n+         * The {@link Iterator} return is not thread safe. In other words don't call {@link Iterator#hasNext()} in one\n+         * thread expect {@link Iterator#next()} called from a different thread to work.\n+         * @return\n+         */\n+        public Iterator<T> getIterable() {\n+            return new Iterator<T>() {\n+                /**\n+                 * buffer to make sure that the state of the iterator doesn't change between calling hasNext() and next().\n+                 */\n+                private Object buf = null;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    buf = value;\n+                    return !nl.isCompleted(buf);\n+                }\n+\n+                @Override\n+                public T next() {\n+                    try {\n+                        // if hasNext wasn't called before calling next.\n+                        if (buf == null)\n+                            buf = value;\n+                        if (nl.isCompleted(buf))\n+                            throw new NoSuchElementException();\n+                        if (nl.isError(buf)) {\n+                            throw Exceptions.propagate(nl.getError(buf));\n+                        }\n+                        return nl.getValue(buf);\n+                    }\n+                    finally {\n+                        buf = null;\n+                    }\n+                }\n+\n+                @Override\n+                public void remove() {\n+                    throw new UnsupportedOperationException(\"Read only iterator\");\n+                }\n+            };\n         }\n-\n     }\n }\n\ndiff --git a/rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorMostRecentTest.java b/rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorMostRecentTest.java\n--- a/rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorMostRecentTest.java\n+++ b/rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorMostRecentTest.java\n@@ -34,6 +34,10 @@\n import rx.subjects.Subject;\n \n public class BlockingOperatorMostRecentTest {\n+    @Test\n+    public void testMostRecentNull() {\n+        assertEquals(null, Observable.<Void>never().toBlocking().mostRecent(null).iterator().next());\n+    }\n \n     @Test\n     public void testMostRecent() {",
    "output": "Fix a bug and a potential for other concurrency issues"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRedo.java b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRedo.java\n@@ -34,11 +34,15 @@\n import static rx.Observable.create;\n \n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import rx.Notification;\n import rx.Observable;\n import rx.Observable.OnSubscribe;\n import rx.Observable.Operator;\n+import rx.Producer;\n import rx.Scheduler;\n import rx.Subscriber;\n import rx.functions.Action0;\n@@ -154,32 +158,40 @@ public static <T> Observable<T> redo(Observable<T> source, Func1<? super Observa\n     }\n \n     private Observable<T> source;\n-    private final Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> f;\n+    private final Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> controlHandlerFunction;\n     private boolean stopOnComplete;\n     private boolean stopOnError;\n     private final Scheduler scheduler;\n     private final AtomicBoolean isLocked = new AtomicBoolean(true);\n+    private final AtomicBoolean isStarted = new AtomicBoolean(false);\n+    // incremented when requests are made, decremented when requests are fulfilled\n+    private final AtomicLong consumerCapacity = new AtomicLong(0l);\n+    private final AtomicReference<Producer> currentProducer = new AtomicReference<Producer>();\n \n     private OnSubscribeRedo(Observable<T> source, Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> f, boolean stopOnComplete, boolean stopOnError,\n             Scheduler scheduler) {\n         this.source = source;\n-        this.f = f;\n+        this.controlHandlerFunction = f;\n         this.stopOnComplete = stopOnComplete;\n         this.stopOnError = stopOnError;\n         this.scheduler = scheduler;\n     }\n \n     @Override\n     public void call(final Subscriber<? super T> child) {\n+        isStarted.set(false);\n+        isLocked.set(true);\n+        consumerCapacity.set(0l);\n+        currentProducer.set(null);\n+\n         final Scheduler.Worker inner = scheduler.createWorker();\n         child.add(inner);\n \n         final CompositeSubscription sourceSubscriptions = new CompositeSubscription();\n         child.add(sourceSubscriptions);\n-\n+        \n         final PublishSubject<Notification<?>> terminals = PublishSubject.create();\n \n-\n         final Action0 subscribeToSource = new Action0() {\n             @Override\n             public void call() {\n@@ -198,8 +210,15 @@ public void onError(Throwable e) {\n \n                     @Override\n                     public void onNext(T v) {\n+                        consumerCapacity.decrementAndGet();\n                         child.onNext(v);\n                     }\n+\n+                    @Override\n+                    public void setProducer(Producer producer) {\n+                        currentProducer.set(producer);\n+                        producer.request(consumerCapacity.get());\n+                    }\n                 };\n                 // new subscription each time so if it unsubscribes itself it does not prevent retries\n                 // by unsubscribing the child subscription\n@@ -208,8 +227,10 @@ public void onNext(T v) {\n             }\n         };\n \n-        final Observable<?> restarts = f.call(\n-        // lifting in a custom operator to kind of do a merge/map/filter thing.\n+        // the observable received by the control handler function will receive notifications of onCompleted in the case of 'repeat' \n+        // type operators or notifications of onError for 'retry' this is done by lifting in a custom operator to selectively divert \n+        // the retry/repeat relevant values to the control handler\n+        final Observable<?> restarts = controlHandlerFunction.call(\n                 terminals.lift(new Operator<Notification<?>, Notification<?>>() {\n                     @Override\n                     public Subscriber<? super Notification<?>> call(final Subscriber<? super Notification<?>> filteredTerminals) {\n@@ -233,6 +254,11 @@ public void onNext(Notification<?> t) {\n                                     filteredTerminals.onNext(t);\n                                 }\n                             }\n+\n+                            @Override\n+                            public void setProducer(Producer producer) {\n+                                producer.request(Long.MAX_VALUE);\n+                            }\n                         };\n                     }\n                 }));\n@@ -255,15 +281,31 @@ public void onError(Throwable e) {\n                     @Override\n                     public void onNext(Object t) {\n                         if (!isLocked.get() && !child.isUnsubscribed()) {\n-                            // if (!child.isUnsubscribed()) {\n                             child.add(inner.schedule(subscribeToSource));\n                         }\n                     }\n+\n+                    @Override\n+                    public void setProducer(Producer producer) {\n+                        producer.request(Long.MAX_VALUE);\n+                    }\n                 });\n             }\n         }));\n-        if (!child.isUnsubscribed()) {\n-            child.add(inner.schedule(subscribeToSource));\n-        }\n+\n+        child.setProducer(new Producer() {\n+\n+            @Override\n+            public void request(long n) {\n+                if (isStarted.compareAndSet(false, true)) {\n+                    consumerCapacity.set(n);\n+                    if (!child.isUnsubscribed()) child.add(inner.schedule(subscribeToSource));\n+                } else if (currentProducer.get() != null) {\n+                    consumerCapacity.getAndAdd(n);\n+                    currentProducer.get().request(n);\n+                }\n+            }\n+        });\n+\n     }\n }\n\ndiff --git a/rxjava-core/src/test/java/rx/internal/operators/OperatorRetryTest.java b/rxjava-core/src/test/java/rx/internal/operators/OperatorRetryTest.java\n--- a/rxjava-core/src/test/java/rx/internal/operators/OperatorRetryTest.java\n+++ b/rxjava-core/src/test/java/rx/internal/operators/OperatorRetryTest.java\n@@ -37,7 +37,6 @@\n import rx.Observable.OnSubscribe;\n import rx.Notification;\n import rx.Observer;\n-import rx.Scheduler.Worker;\n import rx.Subscriber;\n import rx.Subscription;\n import rx.functions.Action0;",
    "output": "Add backpressure to OnSubscribeRedo"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java\n@@ -60,6 +60,9 @@ public void onNext(T value) {\n                 } else {\n                     this.value = value;\n                     isNonEmpty = true;\n+                    // Issue: https://github.com/Netflix/RxJava/pull/1527\n+                    // Because we cache a value and don't emit now, we need to request another one.\n+                    request(1);\n                 }\n             }\n \n\ndiff --git a/rxjava-core/src/test/java/rx/internal/operators/OperatorSingleTest.java b/rxjava-core/src/test/java/rx/internal/operators/OperatorSingleTest.java\n--- a/rxjava-core/src/test/java/rx/internal/operators/OperatorSingleTest.java\n+++ b/rxjava-core/src/test/java/rx/internal/operators/OperatorSingleTest.java\n@@ -15,10 +15,9 @@\n  */\n package rx.internal.operators;\n \n+import static org.junit.Assert.assertEquals;\n import static org.mockito.Matchers.isA;\n-import static org.mockito.Mockito.inOrder;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.*;\n \n import java.util.NoSuchElementException;\n \n@@ -27,7 +26,9 @@\n \n import rx.Observable;\n import rx.Observer;\n+import rx.Subscriber;\n import rx.functions.Func1;\n+import rx.functions.Func2;\n \n public class OperatorSingleTest {\n \n@@ -241,4 +242,52 @@ public Boolean call(Integer t1) {\n         inOrder.verify(observer, times(1)).onCompleted();\n         inOrder.verifyNoMoreInteractions();\n     }\n+\n+    @Test\n+    public void testSingleWithBackpressure() {\n+        Observable<Integer> observable = Observable.from(1, 2).single();\n+\n+        Subscriber<Integer> subscriber = spy(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(1);\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+\n+            }\n+\n+            @Override\n+            public void onNext(Integer integer) {\n+                request(1);\n+            }\n+        });\n+        observable.subscribe(subscriber);\n+\n+        InOrder inOrder = inOrder(subscriber);\n+        inOrder.verify(subscriber, times(1)).onError(isA(IllegalArgumentException.class));\n+        inOrder.verifyNoMoreInteractions();\n+    }\n+\n+    @Test(timeout = 30000)\n+    public void testIssue1527() throws InterruptedException {\n+        //https://github.com/Netflix/RxJava/pull/1527\n+        Observable<Integer> source = Observable.from(1, 2, 3, 4, 5, 6);\n+        Observable<Integer> reduced = source.reduce(new Func2<Integer, Integer, Integer>() {\n+            @Override\n+            public Integer call(Integer i1, Integer i2) {\n+                return i1 + i2;\n+            }\n+        });\n+\n+        Integer r = reduced.toBlocking().first();\n+        assertEquals(21, r.intValue());\n+    }\n }",
    "output": "Make \"single\" support backpressure\n\nSigned-off-by: zsxwing <zsxwing@gmail.com>"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -210,7 +210,7 @@ private void handleScalarSynchronousObservable(ScalarSynchronousObservable<? ext\n              * } </pre>\n              * \n              */\n-            if (mergeProducer.requested < 0) {\n+            if (mergeProducer.requested == Long.MAX_VALUE) {\n                 handleScalarSynchronousObservableWithoutRequestLimits(t);\n             } else {\n                 handleScalarSynchronousObservableWithRequestLimits(t);\n@@ -489,6 +489,9 @@ public MergeProducer(MergeSubscriber<T> ms) {\n \n         @Override\n         public void request(long n) {\n+            if (requested == Long.MAX_VALUE) {\n+                return;\n+            }\n             if (n == Long.MAX_VALUE) {\n                 requested = Long.MAX_VALUE;\n             } else {",
    "output": "Fix the unbounded check for merge"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorBroadcastRegister.java b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorBroadcastRegister.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorBroadcastRegister.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorBroadcastRegister.java\n@@ -58,10 +58,7 @@ public void call() {\n         });\n \n         subscriber.add(subscription);\n-        Intent stickyIntent = context.registerReceiver(broadcastReceiver, intentFilter, broadcastPermission, schedulerHandler);\n-        if (stickyIntent != null) {\n-            subscriber.onNext(stickyIntent);\n-        }\n+        context.registerReceiver(broadcastReceiver, intentFilter, broadcastPermission, schedulerHandler);\n \n     }\n }\n\ndiff --git a/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperatorBroadcastRegisterTest.java b/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperatorBroadcastRegisterTest.java\n--- a/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperatorBroadcastRegisterTest.java\n+++ b/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperatorBroadcastRegisterTest.java\n@@ -0,0 +1,127 @@\n+/**\n+ * Copyright 2014 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.android.operators;\n+\n+import android.app.Application;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InOrder;\n+import org.robolectric.Robolectric;\n+import org.robolectric.RobolectricTestRunner;\n+\n+import rx.Observable;\n+import rx.Observer;\n+import rx.Subscription;\n+import rx.android.observables.AndroidObservable;\n+import rx.observers.TestObserver;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public class OperatorBroadcastRegisterTest {\n+\n+    @Test\n+    public void testBroadcast() {\n+        String action = \"TEST_ACTION\";\n+        IntentFilter intentFilter = new IntentFilter(action);\n+        Application application = Robolectric.application;\n+        Observable<Intent> observable = AndroidObservable.fromBroadcast(application, intentFilter);\n+        final Observer<Intent> observer = mock(Observer.class);\n+        final Subscription subscription = observable.subscribe(new TestObserver<Intent>(observer));\n+\n+        final InOrder inOrder = inOrder(observer);\n+\n+        inOrder.verify(observer, never()).onNext(any(Intent.class));\n+\n+        Intent intent = new Intent(action);\n+        application.sendBroadcast(intent);\n+        inOrder.verify(observer, times(1)).onNext(intent);\n+\n+        application.sendBroadcast(intent);\n+        inOrder.verify(observer, times(1)).onNext(intent);\n+\n+        subscription.unsubscribe();\n+        application.sendBroadcast(intent);\n+        inOrder.verify(observer, never()).onNext(any(Intent.class));\n+\n+        inOrder.verify(observer, never()).onError(any(Throwable.class));\n+        inOrder.verify(observer, never()).onCompleted();\n+    }\n+\n+    @Test\n+    public void testStickyBroadcast() {\n+        String action = \"TEST_STICKY_ACTION\";\n+        IntentFilter intentFilter = new IntentFilter(action);\n+        Application application = Robolectric.application;\n+        Intent intent = new Intent(action);\n+        application.sendStickyBroadcast(intent);\n+        Observable<Intent> observable = AndroidObservable.fromBroadcast(application, intentFilter);\n+        final Observer<Intent> observer = mock(Observer.class);\n+        final Subscription subscription = observable.subscribe(new TestObserver<Intent>(observer));\n+\n+        final InOrder inOrder = inOrder(observer);\n+\n+        inOrder.verify(observer, times(1)).onNext(intent);\n+\n+        application.sendBroadcast(intent);\n+        inOrder.verify(observer, times(1)).onNext(intent);\n+\n+        subscription.unsubscribe();\n+        application.sendBroadcast(intent);\n+        inOrder.verify(observer, never()).onNext(any(Intent.class));\n+\n+        inOrder.verify(observer, never()).onError(any(Throwable.class));\n+        inOrder.verify(observer, never()).onCompleted();\n+    }\n+\n+    @Test\n+    public void testPermissionBroadcast() {\n+        String action = \"TEST_ACTION\";\n+        String permission = \"test_permission\";\n+        IntentFilter intentFilter = new IntentFilter(action);\n+        Application application = Robolectric.application;\n+        Observable<Intent> observable = AndroidObservable.fromBroadcast(application, intentFilter, permission, null);\n+        final Observer<Intent> observer = mock(Observer.class);\n+        final Subscription subscription = observable.subscribe(new TestObserver<Intent>(observer));\n+\n+        final InOrder inOrder = inOrder(observer);\n+\n+        inOrder.verify(observer, never()).onNext(any(Intent.class));\n+\n+        Intent intent = new Intent(action);\n+        application.sendBroadcast(intent);\n+        inOrder.verify(observer, never()).onNext(intent);\n+\n+        application.sendBroadcast(intent, permission);\n+        inOrder.verify(observer, times(1)).onNext(intent);\n+\n+        subscription.unsubscribe();\n+        application.sendBroadcast(intent);\n+        application.sendBroadcast(intent, permission);\n+        inOrder.verify(observer, never()).onNext(any(Intent.class));\n+\n+        inOrder.verify(observer, never()).onError(any(Throwable.class));\n+        inOrder.verify(observer, never()).onCompleted();\n+    }\n+\n+}",
    "output": "Fix sticky intent duplication, add tests for OperatorBroadcast"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorBroadcastRegister.java b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorBroadcastRegister.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorBroadcastRegister.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorBroadcastRegister.java\n@@ -24,8 +24,8 @@\n import rx.Observable;\n import rx.Subscriber;\n import rx.Subscription;\n-import rx.android.subscriptions.AndroidSubscriptions;\n import rx.functions.Action0;\n+import rx.subscriptions.Subscriptions;\n \n public class OperatorBroadcastRegister implements Observable.OnSubscribe<Intent> {\n \n@@ -50,7 +50,7 @@ public void onReceive(Context context, Intent intent) {\n             }\n         };\n \n-        final Subscription subscription = AndroidSubscriptions.unsubscribeInUiThread(new Action0() {\n+        final Subscription subscription = Subscriptions.create(new Action0() {\n             @Override\n             public void call() {\n                 context.unregisterReceiver(broadcastReceiver);\n\ndiff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorLocalBroadcastRegister.java b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorLocalBroadcastRegister.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorLocalBroadcastRegister.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorLocalBroadcastRegister.java\n@@ -26,6 +26,7 @@\n import rx.Subscription;\n import rx.android.subscriptions.AndroidSubscriptions;\n import rx.functions.Action0;\n+import rx.subscriptions.Subscriptions;\n \n public class OperatorLocalBroadcastRegister implements Observable.OnSubscribe<Intent> {\n \n@@ -47,7 +48,7 @@ public void onReceive(Context context, Intent intent) {\n             }\n         };\n \n-        final Subscription subscription = AndroidSubscriptions.unsubscribeInUiThread(new Action0() {\n+        final Subscription subscription = Subscriptions.create(new Action0() {\n             @Override\n             public void call() {\n                 localBroadcastManager.unregisterReceiver(broadcastReceiver);\n\ndiff --git a/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperatorLocalBroadcastRegisterTest.java b/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperatorLocalBroadcastRegisterTest.java\n--- a/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperatorLocalBroadcastRegisterTest.java\n+++ b/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperatorLocalBroadcastRegisterTest.java\n@@ -42,7 +42,6 @@\n public class OperatorLocalBroadcastRegisterTest {\n \n     @Test\n-    @SuppressWarnings(\"unchecked\")\n     public void testLocalBroadcast() {\n         String action = \"TEST_ACTION\";\n         IntentFilter intentFilter = new IntentFilter(action);\n@@ -64,6 +63,7 @@ public void testLocalBroadcast() {\n         inOrder.verify(observer, times(1)).onNext(intent);\n \n         subscription.unsubscribe();\n+        localBroadcastManager.sendBroadcast(intent);\n         inOrder.verify(observer, never()).onNext(any(Intent.class));\n \n         inOrder.verify(observer, never()).onError(any(Throwable.class));",
    "output": "Remove main thread unsubscribe, fix LocalBroadcastOperatorTest"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/internal/operators/OperatorReduceTest.java b/rxjava-core/src/test/java/rx/internal/operators/OperatorReduceTest.java\n--- a/rxjava-core/src/test/java/rx/internal/operators/OperatorReduceTest.java\n+++ b/rxjava-core/src/test/java/rx/internal/operators/OperatorReduceTest.java\n@@ -115,18 +115,24 @@ public Integer call(Integer t1) {\n         verify(observer, times(1)).onError(any(TestException.class));\n     }\n \n-    @Test(timeout = 13000)\n-    public void testBackpressure() throws InterruptedException {\n+    @Test\n+    public void testBackpressureWithNoInitialValue() throws InterruptedException {\n         Observable<Integer> source = Observable.from(1, 2, 3, 4, 5, 6);\n-        Observable<Integer> reduced = source.reduce(new Func2<Integer, Integer, Integer>() {\n-            @Override\n-            public Integer call(Integer i1, Integer i2) {\n-                return i1 + i2;\n-            }\n-        });\n+        Observable<Integer> reduced = source.reduce(sum);\n+\n+        Integer r = reduced.toBlocking().first();\n+        assertEquals(21, r.intValue());\n+    }\n+\n+    @Test\n+    public void testBackpressureWithInitialValue() throws InterruptedException {\n+        Observable<Integer> source = Observable.from(1, 2, 3, 4, 5, 6);\n+        Observable<Integer> reduced = source.reduce(0, sum);\n \n         Integer r = reduced.toBlocking().first();\n         assertEquals(21, r.intValue());\n     }\n \n+\n+\n }",
    "output": "Add another unit test to OperatorReduce/backpressure"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java\n@@ -108,11 +108,21 @@ void startEmitting() {\n \n         @Override\n         public void request(long n) {\n-            long _c = 0;\n+            long _c;\n             if (n == Long.MAX_VALUE) {\n-                requested = Long.MAX_VALUE;\n+                _c = REQUESTED_UPDATER.getAndSet(this, Long.MAX_VALUE);\n             } else {\n-                _c = REQUESTED_UPDATER.getAndAdd(this, n);\n+                for (;;) {\n+                    _c = requested;\n+                    if (_c == Long.MAX_VALUE) {\n+                        // If `requested` is Long.MAX_VALUE, `c+n` will be overflow.\n+                        // Therefore, always check before setting to `c+n`\n+                        return;\n+                    }\n+                    if (REQUESTED_UPDATER.compareAndSet(this, _c, _c + n)) {\n+                        break;\n+                    }\n+                }\n             }\n             if (!emittingStarted) {\n                 // we haven't started yet, so record what was requested and return\n@@ -122,16 +132,20 @@ public void request(long n) {\n         }\n \n         void emit(long previousRequested) {\n-            if (requested < 0) {\n+            if (requested == Long.MAX_VALUE) {\n                 // fast-path without backpressure\n-                try {\n-                    for (Object value : deque) {\n-                        notification.accept(subscriber, value);\n+                if (previousRequested == 0) {\n+                    try {\n+                        for (Object value : deque) {\n+                            notification.accept(subscriber, value);\n+                        }\n+                    } catch (Throwable e) {\n+                        subscriber.onError(e);\n+                    } finally {\n+                        deque.clear();\n                     }\n-                } catch (Throwable e) {\n-                    subscriber.onError(e);\n-                } finally {\n-                    deque.clear();\n+                } else {\n+                    // backpressure path will handle Long.MAX_VALUE and emit the rest events.\n                 }\n             } else {\n                 // backpressure is requested\n@@ -160,7 +174,6 @@ void emit(long previousRequested) {\n                             // we're done emitting the number requested so return\n                             return;\n                         }\n-\n                     }\n                 }\n             }\n\ndiff --git a/rxjava-core/src/test/java/rx/internal/operators/OperatorTakeLastTest.java b/rxjava-core/src/test/java/rx/internal/operators/OperatorTakeLastTest.java\n--- a/rxjava-core/src/test/java/rx/internal/operators/OperatorTakeLastTest.java\n+++ b/rxjava-core/src/test/java/rx/internal/operators/OperatorTakeLastTest.java\n@@ -30,7 +30,9 @@\n \n import rx.Observable;\n import rx.Observer;\n+import rx.Subscriber;\n import rx.functions.Func1;\n+import rx.functions.Functions;\n import rx.internal.util.RxRingBuffer;\n import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n@@ -148,4 +150,118 @@ public Integer call(Integer i) {\n         };\n     }\n \n+    @Test\n+    public void testIssue1522() {\n+        // https://github.com/Netflix/RxJava/issues/1522\n+        assertEquals(0, Observable\n+                .empty()\n+                .count()\n+                .filter(Functions.alwaysFalse())\n+                .toList()\n+                .toBlocking().single().size());\n+    }\n+\n+    @Test\n+    public void testIgnoreRequest1() {\n+        // If `takeLast` does not ignore `request` properly, StackOverflowError will be thrown.\n+        Observable.range(0, 100000).takeLast(100000).subscribe(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(Long.MAX_VALUE);\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+            }\n+\n+            @Override\n+            public void onNext(Integer integer) {\n+                request(Long.MAX_VALUE);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testIgnoreRequest2() {\n+        // If `takeLast` does not ignore `request` properly, StackOverflowError will be thrown.\n+        Observable.range(0, 100000).takeLast(100000).subscribe(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(1);\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+            }\n+\n+            @Override\n+            public void onNext(Integer integer) {\n+                request(1);\n+            }\n+        });\n+    }\n+\n+    @Test(timeout = 30000)\n+    public void testIgnoreRequest3() {\n+        // If `takeLast` does not ignore `request` properly, it will enter an infinite loop.\n+        Observable.range(0, 100000).takeLast(100000).subscribe(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(1);\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+            }\n+\n+            @Override\n+            public void onNext(Integer integer) {\n+                request(Long.MAX_VALUE);\n+            }\n+        });\n+    }\n+\n+\n+    @Test\n+    public void testIgnoreRequest4() {\n+        // If `takeLast` does not ignore `request` properly, StackOverflowError will be thrown.\n+        Observable.range(0, 100000).takeLast(100000).subscribe(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(Long.MAX_VALUE);\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+            }\n+\n+            @Override\n+            public void onNext(Integer integer) {\n+                request(1);\n+            }\n+        });\n+    }\n }",
    "output": "Fix issue #1522"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java\n@@ -55,7 +55,7 @@ public void onCompleted() {\n \n             @Override\n             public void onError(Throwable e) {\n-                // ignore\n+                notifications.offer(Notification.<T>createOnError(e));\n             }\n \n             @Override\n\ndiff --git a/rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorToIteratorTest.java b/rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorToIteratorTest.java\n--- a/rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorToIteratorTest.java\n+++ b/rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorToIteratorTest.java\n@@ -67,4 +67,18 @@ public void call(Subscriber<? super String> observer) {\n         assertEquals(true, it.hasNext());\n         it.next();\n     }\n+\n+    @Test(expected = TestException.class)\n+    public void testExceptionThrownFromOnSubscribe() {\n+        Iterable<String> strings = Observable.create(new Observable.OnSubscribe<String>() {\n+            @Override\n+            public void call(Subscriber<? super String> subscriber) {\n+                throw new TestException(\"intentional\");\n+            }\n+        }).toBlocking().toIterable();\n+        for (String string : strings) {\n+            // never reaches here\n+            System.out.println(string);\n+        }\n+    }\n }",
    "output": "Fix toIterator Exception Handling"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/internal/util/RxRingBufferWithoutUnsafeTest.java b/rxjava-core/src/test/java/rx/internal/util/RxRingBufferWithoutUnsafeTest.java\n--- a/rxjava-core/src/test/java/rx/internal/util/RxRingBufferWithoutUnsafeTest.java\n+++ b/rxjava-core/src/test/java/rx/internal/util/RxRingBufferWithoutUnsafeTest.java\n@@ -39,10 +39,11 @@ protected RxRingBuffer createRingBuffer() {\n     /**\n      * Single producer, 2 consumers. The request() ensures it gets scheduled back on the same Producer thread.\n      */\n-    @Test(timeout = 2000)\n+    @Test\n     public void testConcurrency() throws InterruptedException {\n         final RxRingBuffer b = createRingBuffer();\n-        final CountDownLatch latch = new CountDownLatch(255);\n+        final CountDownLatch emitLatch = new CountDownLatch(255);\n+        final CountDownLatch drainLatch = new CountDownLatch(2);\n \n         final Scheduler.Worker w1 = Schedulers.newThread().createWorker();\n         Scheduler.Worker w2 = Schedulers.newThread().createWorker();\n@@ -58,33 +59,32 @@ public void testConcurrency() throws InterruptedException {\n \n             @Override\n             public void request(final long n) {\n-                System.out.println(\"request[\" + c.incrementAndGet() + \"]: \" + n + \"  Thread: \" + Thread.currentThread());\n+                //                System.out.println(\"request[\" + c.incrementAndGet() + \"]: \" + n + \"  Thread: \" + Thread.currentThread());\n                 w1.schedule(new Action0() {\n \n                     @Override\n                     public void call() {\n-                        if (latch.getCount() == 0) {\n+                        if (emitLatch.getCount() == 0) {\n                             return;\n                         }\n                         for (int i = 0; i < n; i++) {\n                             try {\n-                                emit.incrementAndGet();\n                                 b.onNext(\"one\");\n+                                emit.incrementAndGet();\n                             } catch (MissingBackpressureException e) {\n                                 System.out.println(\"BackpressureException => item: \" + i + \"  requested: \" + n + \" emit: \" + emit.get() + \"  poll: \" + poll.get());\n                                 backpressureExceptions.incrementAndGet();\n                             }\n                         }\n                         // we'll release after n batches\n-                        latch.countDown();\n+                        emitLatch.countDown();\n                     }\n \n                 });\n             }\n \n         };\n         final TestSubscriber<String> ts = new TestSubscriber<String>();\n-\n         w1.schedule(new Action0() {\n \n             @Override\n@@ -95,7 +95,7 @@ public void call() {\n \n         });\n \n-        w2.schedule(new Action0() {\n+        Action0 drainer = new Action0() {\n \n             @Override\n             public void call() {\n@@ -109,39 +109,30 @@ public void call() {\n                         if (emitted > 0) {\n                             ts.requestMore(emitted);\n                             emitted = 0;\n+                        } else {\n+                            if (emitLatch.getCount() == 0) {\n+                                // this works with SynchronizedQueue, if changing to a non-blocking Queue\n+                                // then this will likely need to change like the SpmcTest version\n+                                drainLatch.countDown();\n+                                return;\n+                            }\n                         }\n                     }\n                 }\n \n             }\n \n-        });\n-\n-        w3.schedule(new Action0() {\n+        };\n \n-            @Override\n-            public void call() {\n-                int emitted = 0;\n-                while (true) {\n-                    Object o = b.poll();\n-                    if (o != null) {\n-                        emitted++;\n-                        poll.incrementAndGet();\n-                    } else {\n-                        if (emitted > 0) {\n-                            ts.requestMore(emitted);\n-                            emitted = 0;\n-                        }\n-                    }\n-                }\n-            }\n+        w2.schedule(drainer);\n+        w3.schedule(drainer);\n \n-        });\n+        emitLatch.await();\n+        drainLatch.await();\n \n-        latch.await();\n-        w1.unsubscribe();\n         w2.unsubscribe();\n         w3.unsubscribe();\n+        w1.unsubscribe(); // put this one last as unsubscribing from it can cause Exceptions to be throw in w2/w3\n \n         System.out.println(\"emit: \" + emit.get() + \" poll: \" + poll.get());\n         assertEquals(0, backpressureExceptions.get());",
    "output": "Fix non-deterministic test"
  },
  {
    "input": "diff --git a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java\n--- a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java\n+++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java\n@@ -29,11 +29,6 @@\n \n /**\n  * Concrete wrapper that accepts a {@link RubyProc} and produces any needed Rx {@link Action}.\n- *\n- * @param <T1>\n- * @param <T2>\n- * @param <T3>\n- * @param <T4>\n  */\n public class JRubyActionWrapper<T1, T2, T3, T4> implements Action, Action0, Action1<T1>, Action2<T1, T2>, Action3<T1, T2, T3> {\n \n\ndiff --git a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java\n--- a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java\n+++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java\n@@ -36,17 +36,6 @@\n \n /**\n  * Concrete wrapper that accepts a {@link RubyProc} and produces any needed Rx {@link Function}.\n- *\n- * @param <T1>\n- * @param <T2>\n- * @param <T3>\n- * @param <T4>\n- * @param <T5>\n- * @param <T6>\n- * @param <T7>\n- * @param <T8>\n- * @param <T9>\n- * @param <R>\n  */\n public class JRubyFunctionWrapper<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> implements\n         Func0<R>,",
    "output": "Remove unused param comments"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/util/unsafe/SpscArrayQueue.java b/rxjava-core/src/main/java/rx/internal/util/unsafe/SpscArrayQueue.java\n--- a/rxjava-core/src/main/java/rx/internal/util/unsafe/SpscArrayQueue.java\n+++ b/rxjava-core/src/main/java/rx/internal/util/unsafe/SpscArrayQueue.java\n@@ -100,7 +100,7 @@ public SpscArrayQueueL3Pad(int capacity) {\n  * variation on Fast Flow).<br>\n  * For convenience the relevant papers are available in the resources folder:</br>\n  * <i>2010 - Pisa - SPSC Queues on Shared Cache Multi-Core Systems.pdf</br>\n- * 2012 - Junchang- BQueue- Efﬁcient and Practical Queuing.pdf </br></i>\n+ * 2012 - Junchang- BQueue- Efficient and Practical Queuing.pdf </br></i>\n  * This implementation is wait free.\n  * \n  * @author nitsanw\n@@ -183,4 +183,4 @@ public int size() {\n             }\n         }\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Remove unicode ligature that breaks build"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java b/rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java\n--- a/rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java\n+++ b/rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java\n@@ -66,7 +66,7 @@ public <T> OnSubscribe<T> onCreate(OnSubscribe<T> f) {\n      * @return {@link OnSubscribe}<{@code T}> function that can be modified, decorated, replaced or just\n      *         returned as a pass-thru\n      */\n-    public <T> OnSubscribe<T> onSubscribeStart(Observable<? extends T> observableInsance, final OnSubscribe<T> onSubscribe) {\n+    public <T> OnSubscribe<T> onSubscribeStart(Observable<? extends T> observableInstance, final OnSubscribe<T> onSubscribe) {\n         // pass-thru by default\n         return onSubscribe;\n     }",
    "output": "Fix typo\n\nas per https://github.com/Netflix/RxJava/issues/1266"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java\n--- a/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java\n+++ b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java\n@@ -178,17 +178,16 @@ public static <T> T get(final Observable<T> o, long timeout, TimeUnit unit) thro\n         return new AsyncObservable<T>(o).run(timeout, unit);\n     }\n \n-    private static class AsyncObservable<T> extends FiberAsync<T, Void, ExecutionException> implements Observer<T> {\n+    private static class AsyncObservable<T> extends FiberAsync<T, ExecutionException> implements Observer<T> {\n         private final Observable<T> o;\n \n         public AsyncObservable(Observable<T> o) {\n             this.o = o;\n         }\n \n         @Override\n-        protected Void requestAsync() {\n+        protected void requestAsync() {\n             o.subscribe(this);\n-            return null;\n         }\n \n         @Override",
    "output": "Upgrade to Quasar 0.6.0"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/internal/operators/OperatorAllTest.java b/rxjava-core/src/test/java/rx/internal/operators/OperatorAllTest.java\n--- a/rxjava-core/src/test/java/rx/internal/operators/OperatorAllTest.java\n+++ b/rxjava-core/src/test/java/rx/internal/operators/OperatorAllTest.java\n@@ -15,6 +15,7 @@\n  */\n package rx.internal.operators;\n \n+import static org.junit.Assert.assertFalse;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyNoMoreInteractions;\n@@ -25,6 +26,8 @@\n import rx.Observer;\n import rx.functions.Func1;\n \n+import java.util.Arrays;\n+\n public class OperatorAllTest {\n \n     @Test\n@@ -98,4 +101,16 @@ public Boolean call(String s) {\n         verify(observer).onError(error);\n         verifyNoMoreInteractions(observer);\n     }\n+\n+    @Test\n+    public void testFollowingFirst() {\n+        Observable<Integer> o = Observable.from(Arrays.asList(1, 3, 5, 6));\n+        Observable<Boolean> allOdd = o.all(new Func1<Integer, Boolean>() {\n+            @Override\n+            public Boolean call(Integer i) {\n+                return i % 2 == 1;\n+            }\n+        });\n+        assertFalse(allOdd.toBlocking().first());\n+    }\n }",
    "output": "Add test of backpressure to OperatorAll"
  },
  {
    "input": "diff --git a/rxjava-core/src/perf/java/rx/subjects/ReplaySubjectPerf.java b/rxjava-core/src/perf/java/rx/subjects/ReplaySubjectPerf.java\n--- a/rxjava-core/src/perf/java/rx/subjects/ReplaySubjectPerf.java\n+++ b/rxjava-core/src/perf/java/rx/subjects/ReplaySubjectPerf.java\n@@ -19,8 +19,8 @@\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n \n-import org.openjdk.jmh.annotations.BenchmarkMode;\n import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n import org.openjdk.jmh.annotations.Mode;\n import org.openjdk.jmh.annotations.OutputTimeUnit;\n import org.openjdk.jmh.annotations.Param;\n@@ -42,8 +42,16 @@ public static class Input {\n     }\n \n     @Benchmark\n-    public void subscribeBeforeEvents(final Input input, final Blackhole bh) throws Exception {\n-        ReplaySubject<Object> subject = ReplaySubject.create();\n+    public void subscribeBeforeEventsUnbounded(final Input input, final Blackhole bh) throws Exception {\n+        subscribeBeforeEvents(ReplaySubject.create(), input, bh);\n+    }\n+\n+    @Benchmark\n+    public void subscribeBeforeEventsCount1(final Input input, final Blackhole bh) throws Exception {\n+        subscribeBeforeEvents(ReplaySubject.create(1), input, bh);\n+    }\n+\n+    private void subscribeBeforeEvents(ReplaySubject<Object> subject, final Input input, final Blackhole bh) throws Exception {\n         final CountDownLatch latch = new CountDownLatch(1);\n         final AtomicLong sum = new AtomicLong();\n \n@@ -71,8 +79,16 @@ public void onNext(Object o) {\n     }\n \n     @Benchmark\n-    public void subscribeAfterEvents(final Input input, final Blackhole bh) throws Exception {\n-        ReplaySubject<Object> subject = ReplaySubject.create();\n+    public void subscribeAfterEventsUnbounded(final Input input, final Blackhole bh) throws Exception {\n+        subscribeAfterEvents(ReplaySubject.create(), input, bh);\n+    }\n+\n+    @Benchmark\n+    public void subscribeAfterEventsCount1(final Input input, final Blackhole bh) throws Exception {\n+        subscribeAfterEvents(ReplaySubject.create(1), input, bh);\n+    }\n+\n+    private void subscribeAfterEvents(ReplaySubject<Object> subject, final Input input, final Blackhole bh) throws Exception {\n         final CountDownLatch latch = new CountDownLatch(1);\n         final AtomicLong sum = new AtomicLong();\n ",
    "output": "Add perf tests for cache(1) variant"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java\n@@ -70,7 +70,9 @@ public void request(long n) {\n                     }\n                     o.onNext(it.next());\n                 }\n-                o.onCompleted();\n+                if (!o.isUnsubscribed()) {\n+                    o.onCompleted();\n+                }\n             } else if(n > 0) {\n                 // backpressure is requested\n                 long _c = REQUESTED_UPDATER.getAndAdd(this, n);\n\ndiff --git a/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRange.java b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRange.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRange.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRange.java\n@@ -64,7 +64,9 @@ public void request(long n) {\n                     }\n                     o.onNext((int) i);\n                 }\n-                o.onCompleted();\n+                if (!o.isUnsubscribed()) {\n+                    o.onCompleted();\n+                }\n             } else if (n > 0) {\n                 // backpressure is requested\n                 long _c = REQUESTED_UPDATER.getAndAdd(this, n);\n\ndiff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnEach.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnEach.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnEach.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnEach.java\n@@ -47,24 +47,24 @@ public void onCompleted() {\n                     onError(e);\n                     return;\n                 }\n-                observer.onCompleted();\n                 // Set `done` here so that the error in `doOnEachObserver.onCompleted()` can be noticed by observer\n                 done = true;\n+                observer.onCompleted();\n             }\n \n             @Override\n             public void onError(Throwable e) {\n                 if (done) {\n                     return;\n                 }\n+                done = true;\n                 try {\n                     doOnEachObserver.onError(e);\n                 } catch (Throwable e2) {\n                     observer.onError(e2);\n                     return;\n                 }\n                 observer.onError(e);\n-                done = true;\n             }\n \n             @Override\n\ndiff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeWhile.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeWhile.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeWhile.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorTakeWhile.java\n@@ -49,32 +49,40 @@ public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {\n \n             private int counter = 0;\n \n+            private boolean done = false;\n+\n             @Override\n             public void onNext(T args) {\n                 boolean isSelected;\n                 try {\n                     isSelected = predicate.call(args, counter++);\n                 } catch (Throwable e) {\n+                    done = true;\n                     subscriber.onError(e);\n                     unsubscribe();\n                     return;\n                 }\n                 if (isSelected) {\n                     subscriber.onNext(args);\n                 } else {\n+                    done = true;\n                     subscriber.onCompleted();\n                     unsubscribe();\n                 }\n             }\n \n             @Override\n             public void onCompleted() {\n-                subscriber.onCompleted();\n+                if (!done) {\n+                    subscriber.onCompleted();\n+                }\n             }\n \n             @Override\n             public void onError(Throwable e) {\n-                subscriber.onError(e);\n+                if (!done) {\n+                    subscriber.onError(e);\n+                }\n             }\n \n         };",
    "output": "Fix related classes for issue #1451"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnEach.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnEach.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnEach.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnEach.java\n@@ -33,30 +33,45 @@ public OperatorDoOnEach(Observer<? super T> doOnEachObserver) {\n     @Override\n     public Subscriber<? super T> call(final Subscriber<? super T> observer) {\n         return new Subscriber<T>(observer) {\n+\n+            private boolean done = false;\n+\n             @Override\n             public void onCompleted() {\n+                if (done) {\n+                    return;\n+                }\n                 try {\n                     doOnEachObserver.onCompleted();\n                 } catch (Throwable e) {\n                     onError(e);\n                     return;\n                 }\n                 observer.onCompleted();\n+                // Set `done` here so that the error in `doOnEachObserver.onCompleted()` can be noticed by observer\n+                done = true;\n             }\n \n             @Override\n             public void onError(Throwable e) {\n+                if (done) {\n+                    return;\n+                }\n                 try {\n                     doOnEachObserver.onError(e);\n                 } catch (Throwable e2) {\n                     observer.onError(e2);\n                     return;\n                 }\n                 observer.onError(e);\n+                done = true;\n             }\n \n             @Override\n             public void onNext(T value) {\n+                if (done) {\n+                    return;\n+                }\n                 try {\n                     doOnEachObserver.onNext(value);\n                 } catch (Throwable e) {\n\ndiff --git a/rxjava-core/src/test/java/rx/internal/operators/OperatorDoOnEachTest.java b/rxjava-core/src/test/java/rx/internal/operators/OperatorDoOnEachTest.java\n--- a/rxjava-core/src/test/java/rx/internal/operators/OperatorDoOnEachTest.java\n+++ b/rxjava-core/src/test/java/rx/internal/operators/OperatorDoOnEachTest.java\n@@ -15,6 +15,7 @@\n  */\n package rx.internal.operators;\n \n+import static org.junit.Assert.assertEquals;\n import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n@@ -30,6 +31,9 @@\n import rx.functions.Action1;\n import rx.functions.Func1;\n \n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n public class OperatorDoOnEachTest {\n \n     @Mock\n@@ -114,4 +118,55 @@ public void call(String s) {\n \n     }\n \n+    @Test\n+    public void testIssue1451Case1() {\n+        // https://github.com/Netflix/RxJava/issues/1451\n+        int[] nums = {1, 2, 3};\n+        final AtomicInteger count = new AtomicInteger();\n+        for (final int n : nums) {\n+            Observable\n+                    .from(Boolean.TRUE, Boolean.FALSE)\n+                    .takeWhile(new Func1<Boolean, Boolean>() {\n+                        @Override\n+                        public Boolean call(Boolean value) {\n+                            return value;\n+                        }\n+                    })\n+                    .toList()\n+                    .doOnNext(new Action1<List<Boolean>>() {\n+                        @Override\n+                        public void call(List<Boolean> booleans) {\n+                            count.incrementAndGet();\n+                        }\n+                    })\n+                    .subscribe();\n+        }\n+        assertEquals(nums.length, count.get());\n+    }\n+\n+    @Test\n+    public void testIssue1451Case2() {\n+        // https://github.com/Netflix/RxJava/issues/1451\n+        int[] nums = {1, 2, 3};\n+        final AtomicInteger count = new AtomicInteger();\n+        for (final int n : nums) {\n+            Observable\n+                    .from(Boolean.TRUE, Boolean.FALSE, Boolean.FALSE)\n+                    .takeWhile(new Func1<Boolean, Boolean>() {\n+                        @Override\n+                        public Boolean call(Boolean value) {\n+                            return value;\n+                        }\n+                    })\n+                    .toList()\n+                    .doOnNext(new Action1<List<Boolean>>() {\n+                        @Override\n+                        public void call(List<Boolean> booleans) {\n+                            count.incrementAndGet();\n+                        }\n+                    })\n+                    .subscribe();\n+        }\n+        assertEquals(nums.length, count.get());\n+    }\n }",
    "output": "Fix issue #1451"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -53,7 +53,7 @@ private static final class MergeSubscriber<T> extends Subscriber<Observable<? ex\n         private int wip;\n         private boolean completed;\n \n-        private SubscriptionIndexedRingBuffer<InnerSubscriber<T>> childrenSubscribers;\n+        private volatile SubscriptionIndexedRingBuffer<InnerSubscriber<T>> childrenSubscribers;\n \n         private RxRingBuffer scalarValueQueue = null;\n \n@@ -244,11 +244,12 @@ private boolean drainQueuesIfNeeded() {\n                         emitted = drainScalarValueQueue();\n                         drainChildrenQueues();\n                     } finally {\n-                        if (!releaseEmitLock()) {\n-                            return true;\n-                        }\n+                        boolean moreToDrain = releaseEmitLock();\n                         // request outside of lock\n                         request(emitted);\n+                        if (!moreToDrain) {\n+                            return true;\n+                        }\n                         // otherwise we'll loop and get whatever was added \n                     }\n                 } else {\n@@ -350,27 +351,29 @@ public void onCompleted() {\n             }\n             if (c) {\n                 // complete outside of lock\n-                actual.onCompleted();\n+                drainAndComplete();\n             }\n         }\n \n         void completeInner(InnerSubscriber<T> s) {\n-            try {\n-                boolean sendOnComplete = false;\n-                synchronized (this) {\n-                    wip--;\n-                    if (wip == 0 && completed) {\n-                        sendOnComplete = true;\n-                    }\n-                }\n-                if (sendOnComplete) {\n-                    actual.onCompleted();\n+            boolean sendOnComplete = false;\n+            synchronized (this) {\n+                wip--;\n+                if (wip == 0 && completed) {\n+                    sendOnComplete = true;\n                 }\n-            } finally {\n-                childrenSubscribers.remove(s.sindex);\n+            }\n+            childrenSubscribers.remove(s.sindex);\n+            if (sendOnComplete) {\n+                drainAndComplete();\n             }\n         }\n \n+        private void drainAndComplete() {\n+            drainQueuesIfNeeded(); // TODO need to confirm whether this is needed or not\n+            actual.onCompleted();\n+        }\n+\n     }\n \n     private static final class MergeProducer<T> implements Producer {\n@@ -402,9 +405,10 @@ private static final class InnerSubscriber<T> extends Subscriber<T> {\n         final MergeSubscriber<T> parentSubscriber;\n         final MergeProducer<T> producer;\n         /** Make sure the inner termination events are delivered only once. */\n-        volatile int once;\n+        volatile int terminated;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<InnerSubscriber> ONCE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(InnerSubscriber.class, \"once\");\n+        static final AtomicIntegerFieldUpdater<InnerSubscriber> ONCE_TERMINATED = AtomicIntegerFieldUpdater.newUpdater(InnerSubscriber.class, \"terminated\");\n+\n         private final RxRingBuffer q = RxRingBuffer.getSpmcInstance();\n         /* protected by emitLock */\n         int emitted = 0;\n@@ -425,14 +429,14 @@ public void onNext(T t) {\n         @Override\n         public void onError(Throwable e) {\n             // it doesn't go through queues, it immediately onErrors and tears everything down\n-            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {\n+            if (ONCE_TERMINATED.compareAndSet(this, 0, 1)) {\n                 parentSubscriber.onError(e);\n             }\n         }\n \n         @Override\n         public void onCompleted() {\n-            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {\n+            if (ONCE_TERMINATED.compareAndSet(this, 0, 1)) {\n                 emit(null, true);\n             }\n         }\n\ndiff --git a/rxjava-core/src/main/java/rx/internal/util/IndexedRingBuffer.java b/rxjava-core/src/main/java/rx/internal/util/IndexedRingBuffer.java\n--- a/rxjava-core/src/main/java/rx/internal/util/IndexedRingBuffer.java\n+++ b/rxjava-core/src/main/java/rx/internal/util/IndexedRingBuffer.java\n@@ -122,21 +122,16 @@ public int add(E e) {\n     }\n \n     public E remove(int index) {\n-        try {\n-            E e;\n-            if (index < SIZE) {\n-                // fast-path when we are in the first section\n-                e = elements.array.getAndSet(index, null);\n-            } else {\n-                int sectionIndex = index % SIZE;\n-                e = getElementSection(index).array.getAndSet(sectionIndex, null);\n-            }\n-            pushRemovedIndex(index);\n-            return e;\n-        } catch (NullPointerException ne) {\n-            ne.printStackTrace();\n-            throw ne;\n+        E e;\n+        if (index < SIZE) {\n+            // fast-path when we are in the first section\n+            e = elements.array.getAndSet(index, null);\n+        } else {\n+            int sectionIndex = index % SIZE;\n+            e = getElementSection(index).array.getAndSet(sectionIndex, null);\n         }\n+        pushRemovedIndex(index);\n+        return e;\n     }\n \n     private IndexSection getIndexSection(int index) {\n\ndiff --git a/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java b/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java\n--- a/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java\n+++ b/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java\n@@ -260,6 +260,13 @@ public int count() {\n         }\n         return queue.size();\n     }\n+    \n+    public boolean isEmpty() {\n+        if (queue == null) {\n+            return true;\n+        }\n+        return queue.isEmpty();\n+    }\n \n     public Object poll() {\n         if (queue == null) {\n\ndiff --git a/rxjava-core/src/main/java/rx/internal/util/SubscriptionList.java b/rxjava-core/src/main/java/rx/internal/util/SubscriptionList.java\n--- a/rxjava-core/src/main/java/rx/internal/util/SubscriptionList.java\n+++ b/rxjava-core/src/main/java/rx/internal/util/SubscriptionList.java\n@@ -86,6 +86,7 @@ public void unsubscribe() {\n         }\n         // we will only get here once\n         unsubscribeFromAll(subscriptions);\n+        subscriptions = null;\n     }\n \n     private static void unsubscribeFromAll(Collection<Subscription> subscriptions) {",
    "output": "Fix Merge Bug\n\nWorking on https://github.com/Netflix/RxJava/issues/1420"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/internal/util/IndexedRingBufferTest.java b/rxjava-core/src/test/java/rx/internal/util/IndexedRingBufferTest.java\n--- a/rxjava-core/src/test/java/rx/internal/util/IndexedRingBufferTest.java\n+++ b/rxjava-core/src/test/java/rx/internal/util/IndexedRingBufferTest.java\n@@ -211,13 +211,13 @@ public void testForEachAcrossSections() {\n             buffer.add(i);\n         }\n \n-        final ArrayList<String> list = new ArrayList<String>();\n+        final ArrayList<Integer> list = new ArrayList<Integer>();\n         int nextIndex = buffer.forEach(accumulate(list), 5000);\n         assertEquals(10000, list.size());\n-        assertEquals(5000, list.get(0));\n-        assertEquals(9999, list.get(4999));\n-        assertEquals(0, list.get(5000));\n-        assertEquals(4999, list.get(9999));\n+        assertEquals(Integer.valueOf(5000), list.get(0));\n+        assertEquals(Integer.valueOf(9999), list.get(4999));\n+        assertEquals(Integer.valueOf(0), list.get(5000));\n+        assertEquals(Integer.valueOf(4999), list.get(9999));\n         assertEquals(5000, nextIndex);\n     }\n \n@@ -364,11 +364,11 @@ public void call() {\n         assertEquals(0, exceptions.size());\n     }\n \n-    private Func1<Object, Boolean> accumulate(final ArrayList list) {\n-        return new Func1<Object, Boolean>() {\n+    private <T> Func1<T, Boolean> accumulate(final ArrayList<T> list) {\n+        return new Func1<T, Boolean>() {\n \n             @Override\n-            public Boolean call(Object t1) {\n+            public Boolean call(T t1) {\n                 list.add(t1);\n                 return true;\n             }",
    "output": "Add generics"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java b/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java\n--- a/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java\n+++ b/rxjava-core/src/main/java/rx/internal/util/RxRingBuffer.java\n@@ -173,7 +173,7 @@ public static RxRingBuffer getSpmcInstance() {\n \n         @Override\n         protected SpscArrayQueue<Object> createObject() {\n-            return new SpscArrayQueue(SIZE);\n+            return new SpscArrayQueue<Object>(SIZE);\n         }\n \n     };\n@@ -182,12 +182,12 @@ protected SpscArrayQueue<Object> createObject() {\n \n         @Override\n         protected SpmcArrayQueue<Object> createObject() {\n-            return new SpmcArrayQueue(SIZE);\n+            return new SpmcArrayQueue<Object>(SIZE);\n         }\n \n     };\n \n-    private RxRingBuffer(Queue queue, int size) {\n+    private RxRingBuffer(Queue<Object> queue, int size) {\n         this.queue = queue;\n         this.pool = null;\n         this.size = size;\n@@ -201,7 +201,7 @@ private RxRingBuffer(ObjectPool<Queue<Object>> pool, int size) {\n \n     public void release() {\n         if (pool != null) {\n-            Queue q = queue;\n+            Queue<Object> q = queue;\n             q.clear();\n             queue = null;\n             pool.returnObject(q);\n@@ -214,7 +214,7 @@ public void unsubscribe() {\n     }\n \n     /* for unit tests */RxRingBuffer() {\n-        this(new SynchronizedQueue<Queue>(SIZE), SIZE);\n+        this(new SynchronizedQueue<Object>(SIZE), SIZE);\n     }\n \n     /**",
    "output": "Add generics"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/internal/util/RxRingBufferBase.java b/rxjava-core/src/test/java/rx/internal/util/RxRingBufferBase.java\n--- a/rxjava-core/src/test/java/rx/internal/util/RxRingBufferBase.java\n+++ b/rxjava-core/src/test/java/rx/internal/util/RxRingBufferBase.java\n@@ -15,23 +15,15 @@\n  */\n package rx.internal.util;\n \n-import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n import java.util.Arrays;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Test;\n \n-import rx.Producer;\n-import rx.Scheduler;\n-import rx.Subscriber;\n import rx.exceptions.MissingBackpressureException;\n-import rx.functions.Action0;\n import rx.observers.TestSubscriber;\n-import rx.schedulers.Schedulers;\n \n public abstract class RxRingBufferBase {\n \n@@ -59,7 +51,6 @@ public void addAndPollFailBackpressure() throws MissingBackpressureException {\n \n         RxRingBuffer b = createRingBuffer();\n \n-        TestSubscriber<Object> s = new TestSubscriber<Object>();\n         try {\n             for (int i = 0; i < RxRingBuffer.SIZE; i++) {\n                 //                System.out.println(\"Add: \" + i);\n@@ -82,7 +73,6 @@ public void addAndPollFailBackpressure() throws MissingBackpressureException {\n     @Test\n     public void addAndPoll() throws MissingBackpressureException {\n         RxRingBuffer b = createRingBuffer();\n-        TestSubscriber<Object> s = new TestSubscriber<Object>();\n         b.onNext(\"o\");\n         b.onNext(\"o\");\n         b.poll();",
    "output": "Remove unused imports/locals"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/util/SubscriptionRandomList.java b/rxjava-core/src/main/java/rx/internal/util/SubscriptionRandomList.java\n--- a/rxjava-core/src/main/java/rx/internal/util/SubscriptionRandomList.java\n+++ b/rxjava-core/src/main/java/rx/internal/util/SubscriptionRandomList.java\n@@ -113,15 +113,15 @@ public void clear() {\n     }\n \n     public void forEach(Action1<T> action) {\n-        Object[] ss;\n+        T[] ss=null;\n         synchronized (this) {\n             if (unsubscribed || subscriptions == null) {\n                 return;\n             }\n-            ss = subscriptions.toArray();\n+            ss = subscriptions.toArray(ss);\n         }\n-        for (Object t : ss) {\n-            action.call((T) t);\n+        for (T t : ss) {\n+            action.call(t);\n         }\n     }\n ",
    "output": "Remove cast"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/exceptions/CompositeException.java b/rxjava-core/src/main/java/rx/exceptions/CompositeException.java\n--- a/rxjava-core/src/main/java/rx/exceptions/CompositeException.java\n+++ b/rxjava-core/src/main/java/rx/exceptions/CompositeException.java\n@@ -38,9 +38,9 @@ public final class CompositeException extends RuntimeException {\n     public CompositeException(String messagePrefix, Collection<Throwable> errors) {\n         List<Throwable> _exceptions = new ArrayList<Throwable>();\n         CompositeExceptionCausalChain _cause = new CompositeExceptionCausalChain();\n-        int count = 0;\n+        int count = errors.size();\n+        errors = removeDuplicatedCauses(errors);\n         for (Throwable e : errors) {\n-            count++;\n             attachCallingThreadStack(_cause, e);\n             _exceptions.add(e);\n         }\n@@ -73,6 +73,29 @@ public synchronized Throwable getCause() {\n         return cause;\n     }\n \n+    private Collection<Throwable> removeDuplicatedCauses(Collection<Throwable> errors) {\n+        Set<Throwable> duplicated = new HashSet<Throwable>();\n+        for (Throwable cause : errors) {\n+            for (Throwable error : errors) {\n+                if(cause == error || duplicated.contains(error)) {\n+                    continue;\n+                }\n+                while (error.getCause() != null) {\n+                    error = error.getCause();\n+                    if (error == cause) {\n+                        duplicated.add(cause);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        if (!duplicated.isEmpty()) {\n+            errors = new ArrayList<Throwable>(errors);\n+            errors.removeAll(duplicated);\n+        }\n+        return errors;\n+    }\n+\n     @SuppressWarnings(\"unused\")\n     // useful when debugging but don't want to make part of publicly supported API\n     private static String getStackTraceAsString(StackTraceElement[] stack) {\n\ndiff --git a/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java b/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java\n--- a/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java\n+++ b/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java\n@@ -53,6 +53,16 @@ public void testMultipleWithSameCause() {\n         \n     }\n \n+    @Test(timeout = 1000)\n+    public void testOneIsCauseOfAnother() {\n+        Throwable rootCause = new Throwable(\"RootCause\");\n+        Throwable throwable = new Throwable(\"1\", rootCause);\n+        CompositeException ce = new CompositeException(\"One is the cause of another\",\n+                Arrays.asList(rootCause, throwable));\n+\n+        assertEquals(1, ce.getExceptions().size());\n+    }\n+\n     @Test(timeout = 1000)\n     public void testAttachCallingThreadStackParentThenChild() {\n         CompositeException.attachCallingThreadStack(ex1, ex2);",
    "output": "Remove cycles in CompositeException"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java\n--- a/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java\n+++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java\n@@ -15,49 +15,19 @@\n  */\n package rx.util.async;\n \n-import java.util.concurrent.Callable;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.FutureTask;\n-\n-import rx.Observable;\n-import rx.Observer;\n-import rx.Scheduler;\n+import rx.*;\n import rx.Scheduler.Worker;\n-import rx.Subscriber;\n-import rx.Subscription;\n-import rx.functions.Action0;\n-import rx.functions.Action1;\n-import rx.functions.Action2;\n-import rx.functions.Action3;\n-import rx.functions.Action4;\n-import rx.functions.Action5;\n-import rx.functions.Action6;\n-import rx.functions.Action7;\n-import rx.functions.Action8;\n-import rx.functions.Action9;\n-import rx.functions.ActionN;\n-import rx.functions.Actions;\n-import rx.functions.Func0;\n-import rx.functions.Func1;\n-import rx.functions.Func2;\n-import rx.functions.Func3;\n-import rx.functions.Func4;\n-import rx.functions.Func5;\n-import rx.functions.Func6;\n-import rx.functions.Func7;\n-import rx.functions.Func8;\n-import rx.functions.Func9;\n-import rx.functions.FuncN;\n+import rx.functions.*;\n import rx.schedulers.Schedulers;\n import rx.subjects.AsyncSubject;\n import rx.subjects.PublishSubject;\n import rx.subjects.Subject;\n import rx.subscriptions.SerialSubscription;\n-import rx.util.async.operators.Functionals;\n-import rx.util.async.operators.OperatorDeferFuture;\n-import rx.util.async.operators.OperatorForEachFuture;\n-import rx.util.async.operators.OperatorFromFunctionals;\n-import rx.util.async.operators.OperatorStartFuture;\n+import rx.util.async.operators.*;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n \n /**\n  * Utility methods to convert functions and actions into asynchronous operations through the Observable/Observer\n@@ -95,7 +65,7 @@ public static <T> Observable<T> start(Func0<T> func) {\n      * Observable. Multiple subscriptions to this Observable observe the same return value.\n      * <p>\n      * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/start.s.png\">\n-     *\n+     * <p>\n      * @param <T> the result value type\n      * @param func function to run asynchronously\n      * @param scheduler Scheduler to run the function on\n@@ -111,7 +81,7 @@ public static <T> Observable<T> start(Func0<T> func, Scheduler scheduler) {\n      * Convert a synchronous action call into an asynchronous function call through an Observable.\n      * <p>\n      * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toAsync.an.png\">\n-     *\n+     * <p>\n      * @param action the action to convert\n      * @return a function that returns an Observable that executes the {@code action} and emits {@code null}\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Async-Operators#wiki-toasync-or-asyncaction-or-asyncfunc\">RxJava Wiki: toAsync()</a>",
    "output": "Remove deprecated OnSubscribeFunc"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -535,7 +535,9 @@ private void emit(T t, boolean complete) {\n                             emitted++;\n                         }\n                     } else {\n-                        if (producer.requested > 0) {\n+                        // this needs to check q.count() as draining above may not have drained the full queue\n+                        // perf tests show this to be okay, though different queue implementations could perform poorly with this\n+                        if (producer.requested > 0 && q.count() == 0) {\n                             if (complete) {\n                                 parentSubscriber.completeInner(this);\n                             } else {",
    "output": "Fix Merge Bug\n\nIf the queue being drained did not complete due to the backpressure request being fulfilled, it could onComplete before draining the queue and miss values"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/exceptions/OnErrorThrowable.java b/rxjava-core/src/main/java/rx/exceptions/OnErrorThrowable.java\n--- a/rxjava-core/src/main/java/rx/exceptions/OnErrorThrowable.java\n+++ b/rxjava-core/src/main/java/rx/exceptions/OnErrorThrowable.java\n@@ -116,7 +116,7 @@ public static class OnNextValue extends RuntimeException {\n          *         the item that the Observable was trying to emit at the time of the exception\n          */\n         public OnNextValue(Object value) {\n-            super(\"OnError while emitting onNext.\");\n+            super(\"OnError while emitting onNext value: \" + renderValue(value));\n             this.value = value;\n         }\n \n@@ -129,5 +129,25 @@ public Object getValue() {\n             return value;\n         }\n \n+        /**\n+         * Render the object if it is a basic type. This avoids the library making potentially expensive\n+         * or calls to toString() which may throw exceptions. See PR #1401 for details.\n+         *\n+         * @param value\n+         *        the item that the Observable was trying to emit at the time of the exception\n+         * @return a string version of the object if primitive, otherwise the classname of the object\n+         */\n+        private static String renderValue(Object value){\n+            if(value == null){\n+                return \"null\";\n+            }\n+            if(value.getClass().isPrimitive()){\n+                return value.toString();\n+            }\n+            if(value instanceof String){\n+                return (String)value;\n+            }\n+            return value.getClass().getSimpleName() + \".class\";\n+        }\n     }\n }",
    "output": "Add a renderValue function to create a string from unknown client objects without calling toString (PR #1401)"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/exceptions/OnErrorThrowable.java b/rxjava-core/src/main/java/rx/exceptions/OnErrorThrowable.java\n--- a/rxjava-core/src/main/java/rx/exceptions/OnErrorThrowable.java\n+++ b/rxjava-core/src/main/java/rx/exceptions/OnErrorThrowable.java\n@@ -116,7 +116,7 @@ public static class OnNextValue extends RuntimeException {\n          *         the item that the Observable was trying to emit at the time of the exception\n          */\n         public OnNextValue(Object value) {\n-            super(\"OnError while emitting onNext value: \" + value);\n+            super(\"OnError while emitting onNext.\");\n             this.value = value;\n         }\n ",
    "output": "Fix OnNextValue to not call toString on the failing value"
  },
  {
    "input": "diff --git a/rxjava-core/src/perf/java/rx/PerfBaseline.java b/rxjava-core/src/perf/java/rx/PerfBaseline.java\n--- a/rxjava-core/src/perf/java/rx/PerfBaseline.java\n+++ b/rxjava-core/src/perf/java/rx/PerfBaseline.java\n@@ -39,6 +39,16 @@ public void observableConsumption(Input input) throws InterruptedException {\n     public void observableViaRange(Input input) throws InterruptedException {\n         input.observable.subscribe(input.observer);\n     }\n+    \n+    @Benchmark\n+    public void observableConsumptionUnsafe(Input input) throws InterruptedException {\n+        input.firehose.unsafeSubscribe(input.newSubscriber());\n+    }\n+\n+    @Benchmark\n+    public void observableViaRangeUnsafe(Input input) throws InterruptedException {\n+        input.observable.unsafeSubscribe(input.newSubscriber());\n+    }\n \n     @Benchmark\n     public void iterableViaForLoopConsumption(Input input) throws InterruptedException {\n\ndiff --git a/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java b/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java\n--- a/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java\n+++ b/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java\n@@ -32,11 +32,11 @@ public abstract class InputWithIncrementingInteger {\n     public Iterable<Integer> iterable;\n     public Observable<Integer> observable;\n     public Observable<Integer> firehose;\n-    private Blackhole bh;\n+    public Blackhole bh;\n     public Observer<Integer> observer;\n \n     public abstract int getSize();\n-    \n+\n     @Setup\n     public void setup(final Blackhole bh) {\n         this.bh = bh;\n@@ -106,4 +106,25 @@ public LatchedObserver<Integer> newLatchedObserver() {\n         return new LatchedObserver<Integer>(bh);\n     }\n \n+    public Subscriber<Integer> newSubscriber() {\n+        return new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onCompleted() {\n+\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+\n+            }\n+\n+            @Override\n+            public void onNext(Integer t) {\n+                bh.consume(t);\n+            }\n+\n+        };\n+    }\n+\n }\n\ndiff --git a/rxjava-core/src/perf/java/rx/operators/OperatorMergePerf.java b/rxjava-core/src/perf/java/rx/operators/OperatorMergePerf.java\n--- a/rxjava-core/src/perf/java/rx/operators/OperatorMergePerf.java\n+++ b/rxjava-core/src/perf/java/rx/operators/OperatorMergePerf.java\n@@ -19,8 +19,8 @@\n import java.util.List;\n import java.util.concurrent.TimeUnit;\n \n-import org.openjdk.jmh.annotations.BenchmarkMode;\n import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n import org.openjdk.jmh.annotations.Mode;\n import org.openjdk.jmh.annotations.OutputTimeUnit;\n import org.openjdk.jmh.annotations.Param;\n@@ -39,21 +39,25 @@\n @OutputTimeUnit(TimeUnit.SECONDS)\n public class OperatorMergePerf {\n \n-    @State(Scope.Thread)\n-    public static class Input extends InputWithIncrementingInteger {\n-\n-        @Param({ \"1\", \"1000\" })\n-        public int size;\n+    // flatMap\n+    @Benchmark\n+    public void oneStreamOfNthatMergesIn1(final InputMillion input) throws InterruptedException {\n+        Observable<Observable<Integer>> os = Observable.range(1, input.size).map(new Func1<Integer, Observable<Integer>>() {\n \n-        @Override\n-        public int getSize() {\n-            return size;\n-        }\n+            @Override\n+            public Observable<Integer> call(Integer i) {\n+                return Observable.just(i);\n+            }\n \n+        });\n+        LatchedObserver<Integer> o = input.newLatchedObserver();\n+        Observable.merge(os).subscribe(o);\n+        o.latch.await();\n     }\n \n+    // flatMap\n     @Benchmark\n-    public void merge1SyncStreamOfN(final Input input) throws InterruptedException {\n+    public void merge1SyncStreamOfN(final InputMillion input) throws InterruptedException {\n         Observable<Observable<Integer>> os = Observable.just(1).map(new Func1<Integer, Observable<Integer>>() {\n \n             @Override\n@@ -66,9 +70,9 @@ public Observable<Integer> call(Integer i) {\n         Observable.merge(os).subscribe(o);\n         o.latch.await();\n     }\n-    \n+\n     @Benchmark\n-    public void mergeNSyncStreamsOfN(final Input input) throws InterruptedException {\n+    public void mergeNSyncStreamsOfN(final InputThousand input) throws InterruptedException {\n         Observable<Observable<Integer>> os = input.observable.map(new Func1<Integer, Observable<Integer>>() {\n \n             @Override\n@@ -83,7 +87,7 @@ public Observable<Integer> call(Integer i) {\n     }\n \n     @Benchmark\n-    public void mergeNAsyncStreamsOfN(final Input input) throws InterruptedException {\n+    public void mergeNAsyncStreamsOfN(final InputThousand input) throws InterruptedException {\n         Observable<Observable<Integer>> os = input.observable.map(new Func1<Integer, Observable<Integer>>() {\n \n             @Override\n@@ -98,7 +102,7 @@ public Observable<Integer> call(Integer i) {\n     }\n \n     @Benchmark\n-    public void mergeTwoAsyncStreamsOfN(final Input input) throws InterruptedException {\n+    public void mergeTwoAsyncStreamsOfN(final InputThousand input) throws InterruptedException {\n         LatchedObserver<Integer> o = input.newLatchedObserver();\n         Observable<Integer> ob = Observable.range(0, input.size).subscribeOn(Schedulers.computation());\n         Observable.merge(ob, ob).subscribe(o);\n@@ -115,6 +119,7 @@ public void mergeNSyncStreamsOf1(final InputForMergeN input) throws InterruptedE\n     @State(Scope.Thread)\n     public static class InputForMergeN {\n         @Param({ \"1\", \"100\", \"1000\" })\n+        //        @Param({ \"1000\" })\n         public int size;\n \n         private Blackhole bh;\n@@ -134,4 +139,31 @@ public LatchedObserver<Integer> newLatchedObserver() {\n         }\n     }\n \n+    @State(Scope.Thread)\n+    public static class InputMillion extends InputWithIncrementingInteger {\n+\n+        @Param({ \"1\", \"1000\", \"1000000\" })\n+        //        @Param({ \"1000\" })\n+        public int size;\n+\n+        @Override\n+        public int getSize() {\n+            return size;\n+        }\n+\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class InputThousand extends InputWithIncrementingInteger {\n+\n+        @Param({ \"1\", \"1000\" })\n+        //        @Param({ \"1000\" })\n+        public int size;\n+\n+        @Override\n+        public int getSize() {\n+            return size;\n+        }\n+\n+    }\n }",
    "output": "Upgrade Perf Tests matching with work being done for 0.20 to allow comparisons"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -6834,15 +6834,29 @@ public void onNext(T t) {\n      */\n     public final Subscription unsafeSubscribe(Subscriber<? super T> subscriber) {\n         try {\n-            onSubscribe.call(subscriber);\n+            // allow the hook to intercept and/or decorate\n+            hook.onSubscribeStart(this, onSubscribe).call(subscriber);\n+            return hook.onSubscribeReturn(subscriber);\n         } catch (Throwable e) {\n-            if (e instanceof OnErrorNotImplementedException) {\n-                throw (OnErrorNotImplementedException) e;\n+            // special handling for certain Throwable/Error/Exception types\n+            Exceptions.throwIfFatal(e);\n+            // if an unhandled error occurs executing the onSubscribe we will propagate it\n+            try {\n+                subscriber.onError(hook.onSubscribeError(e));\n+            } catch (OnErrorNotImplementedException e2) {\n+                // special handling when onError is not implemented ... we just rethrow\n+                throw e2;\n+            } catch (Throwable e2) {\n+                // if this happens it means the onError itself failed (perhaps an invalid function implementation)\n+                // so we are unable to propagate the error correctly and will just throw\n+                RuntimeException r = new RuntimeException(\"Error occurred attempting to subscribe [\" + e.getMessage() + \"] and then again while trying to pass to onError.\", e2);\n+                // TODO could the hook be the cause of the error in the on error handling.\n+                hook.onSubscribeError(r);\n+                // TODO why aren't we throwing the hook's return value.\n+                throw r;\n             }\n-            // handle broken contracts: https://github.com/Netflix/RxJava/issues/1090\n-            subscriber.onError(e);\n+            return Subscriptions.empty();\n         }\n-        return subscriber;\n     }\n \n     /**\n@@ -6880,30 +6894,31 @@ public final Subscription unsafeSubscribe(Subscriber<? super T> subscriber) {\n      *             if the {@link Subscriber}'s {@code onError} method itself threw a {@code Throwable}\n      */\n     public final Subscription subscribe(Subscriber<? super T> subscriber) {\n-        // allow the hook to intercept and/or decorate\n-        OnSubscribe<T> onSubscribeFunction = hook.onSubscribeStart(this, onSubscribe);\n         // validate and proceed\n         if (subscriber == null) {\n             throw new IllegalArgumentException(\"observer can not be null\");\n         }\n-        if (onSubscribeFunction == null) {\n+        if (onSubscribe == null) {\n             throw new IllegalStateException(\"onSubscribe function can not be null.\");\n             /*\n              * the subscribe function can also be overridden but generally that's not the appropriate approach\n              * so I won't mention that in the exception\n              */\n         }\n+        /*\n+         * See https://github.com/Netflix/RxJava/issues/216 for discussion on \"Guideline 6.4: Protect calls\n+         * to user code from within an Observer\"\n+         */\n+        // if not already wrapped\n+        if (!(subscriber instanceof SafeSubscriber)) {\n+            // assign to `observer` so we return the protected version\n+            subscriber = new SafeSubscriber<T>(subscriber);\n+        }\n+\n+        // The code below is exactly the same an unsafeSubscribe but not used because it would add a sigificent depth to alreay huge call stacks.\n         try {\n-            /*\n-             * See https://github.com/Netflix/RxJava/issues/216 for discussion on \"Guideline 6.4: Protect calls\n-             * to user code from within an Observer\"\n-             */\n-            // if not already wrapped\n-            if (!(subscriber instanceof SafeSubscriber)) {\n-                // assign to `observer` so we return the protected version\n-                subscriber = new SafeSubscriber<T>(subscriber);\n-            }\n-            onSubscribeFunction.call(subscriber);\n+            // allow the hook to intercept and/or decorate\n+            hook.onSubscribeStart(this, onSubscribe).call(subscriber);\n             return hook.onSubscribeReturn(subscriber);\n         } catch (Throwable e) {\n             // special handling for certain Throwable/Error/Exception types",
    "output": "Add the hooks unsafeSubscribe by making the execution same as safe version without the safety checks"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -3425,6 +3425,19 @@ public final Observable<T> cache() {\n         return create(new OnSubscribeCache<T>(this));\n     }\n \n+    /**\n+     * {@code cache} with initial capacity.\n+     *\n+     * @param capacity\n+     *            initial cache size\n+     * @return an Observable that, when first subscribed to, caches all of its items and notifications for the\n+     *         benefit of subsequent subscribers\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#cache\">RxJava Wiki: cache()</a>\n+     */\n+    public final Observable<T> cache(int capacity) {\n+        return create(new OnSubscribeCache<T>(this, capacity));\n+    }\n+\n     /**\n      * Returns an Observable that emits the items emitted by the source Observable, converted to the specified\n      * type.\n\ndiff --git a/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeCache.java b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeCache.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeCache.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeCache.java\n@@ -52,6 +52,10 @@ public OnSubscribeCache(Observable<? extends T> source) {\n         this(source, ReplaySubject.<T> create());\n     }\n \n+    public OnSubscribeCache(Observable<? extends T> source, int capacity) {\n+        this(source, ReplaySubject.<T> create(capacity));\n+    }\n+\n     /* accessible to tests */OnSubscribeCache(Observable<? extends T> source, Subject<? super T, ? extends T> cache) {\n         this.source = source;\n         this.cache = cache;\n\ndiff --git a/rxjava-core/src/test/java/rx/ObservableTests.java b/rxjava-core/src/test/java/rx/ObservableTests.java\n--- a/rxjava-core/src/test/java/rx/ObservableTests.java\n+++ b/rxjava-core/src/test/java/rx/ObservableTests.java\n@@ -694,6 +694,54 @@ public void call(String v) {\n         assertEquals(1, counter.get());\n     }\n \n+    @Test\n+    public void testCacheWithCapacity() throws InterruptedException {\n+        final AtomicInteger counter = new AtomicInteger();\n+        Observable<String> o = Observable.create(new OnSubscribe<String>() {\n+\n+            @Override\n+            public void call(final Subscriber<? super String> observer) {\n+                new Thread(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        counter.incrementAndGet();\n+                        observer.onNext(\"one\");\n+                        observer.onCompleted();\n+                    }\n+                }).start();\n+            }\n+        }).cache(1);\n+\n+        // we then expect the following 2 subscriptions to get that same value\n+        final CountDownLatch latch = new CountDownLatch(2);\n+\n+        // subscribe once\n+        o.subscribe(new Action1<String>() {\n+\n+            @Override\n+            public void call(String v) {\n+                assertEquals(\"one\", v);\n+                latch.countDown();\n+            }\n+        });\n+\n+        // subscribe again\n+        o.subscribe(new Action1<String>() {\n+\n+            @Override\n+            public void call(String v) {\n+                assertEquals(\"one\", v);\n+                latch.countDown();\n+            }\n+        });\n+\n+        if (!latch.await(1000, TimeUnit.MILLISECONDS)) {\n+            fail(\"subscriptions did not receive values\");\n+        }\n+        assertEquals(1, counter.get());\n+    }\n+\n     /**\n      * https://github.com/Netflix/RxJava/issues/198\n      * ",
    "output": "Add cache(int capacity) to Observable"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/observers/SafeObserverTest.java b/rxjava-core/src/test/java/rx/observers/SafeObserverTest.java\n--- a/rxjava-core/src/test/java/rx/observers/SafeObserverTest.java\n+++ b/rxjava-core/src/test/java/rx/observers/SafeObserverTest.java\n@@ -21,6 +21,7 @@\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n+import java.util.List;\n import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.Test;\n@@ -109,15 +110,16 @@ public void onErrorFailureSafe() {\n \n             Throwable e2 = e.getCause();\n             assertTrue(e2 instanceof CompositeException);\n-            assertEquals(\"Chain of Causes for CompositeException In Order Received =>\", e2.getCause().getMessage());\n+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();\n+            assertEquals(2, innerExceptions.size());\n \n-            Throwable e3 = e2.getCause();\n-            assertTrue(e3.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"error!\", e3.getCause().getMessage());\n+            Throwable e3 = innerExceptions.get(0);\n+            assertTrue(e3 instanceof SafeObserverTestException);\n+            assertEquals(\"error!\", e3.getMessage());\n \n-            Throwable e4 = e3.getCause();\n-            assertTrue(e4.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"onErrorFail\", e4.getCause().getMessage());\n+            Throwable e4 = innerExceptions.get(1);\n+            assertTrue(e4 instanceof SafeObserverTestException);\n+            assertEquals(\"onErrorFail\", e4.getMessage());\n         }\n     }\n \n@@ -157,15 +159,16 @@ public void onNextOnErrorFailureSafe() {\n \n             Throwable e2 = e.getCause();\n             assertTrue(e2 instanceof CompositeException);\n-            assertEquals(\"Chain of Causes for CompositeException In Order Received =>\", e2.getCause().getMessage());\n+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();\n+            assertEquals(2, innerExceptions.size());\n \n-            Throwable e3 = e2.getCause();\n-            assertTrue(e3.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"onNextFail\", e3.getCause().getMessage());\n+            Throwable e3 = innerExceptions.get(0);\n+            assertTrue(e3 instanceof SafeObserverTestException);\n+            assertEquals(\"onNextFail\", e3.getMessage());\n \n-            Throwable e4 = e3.getCause();\n-            assertTrue(e4.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"onErrorFail\", e4.getCause().getMessage());\n+            Throwable e4 = innerExceptions.get(1);\n+            assertTrue(e4 instanceof SafeObserverTestException);\n+            assertEquals(\"onErrorFail\", e4.getMessage());\n         }\n     }\n \n@@ -251,19 +254,20 @@ public void call() {\n \n             Throwable e2 = e.getCause();\n             assertTrue(e2 instanceof CompositeException);\n-            assertEquals(\"Chain of Causes for CompositeException In Order Received =>\", e2.getCause().getMessage());\n+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();\n+            assertEquals(3, innerExceptions.size());\n \n-            Throwable e3 = e2.getCause();\n-            assertTrue(e3.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"onError failure\", e3.getCause().getMessage());\n+            Throwable e3 = innerExceptions.get(0);\n+            assertTrue(e3 instanceof SafeObserverTestException);\n+            assertEquals(\"onError failure\", e3.getMessage());\n \n-            Throwable e4 = e3.getCause();\n-            assertTrue(e4.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"onErrorFail\", e4.getCause().getMessage());\n+            Throwable e4 = innerExceptions.get(1);\n+            assertTrue(e4 instanceof SafeObserverTestException);\n+            assertEquals(\"onErrorFail\", e4.getMessage());\n \n-            Throwable e5 = e4.getCause();\n-            assertTrue(e5.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"failure from unsubscribe\", e5.getCause().getMessage());\n+            Throwable e5 = innerExceptions.get(2);\n+            assertTrue(e5 instanceof SafeObserverTestException);\n+            assertEquals(\"failure from unsubscribe\", e5.getMessage());\n         }\n     }\n \n@@ -292,15 +296,16 @@ public void call() {\n \n             Throwable e2 = e.getCause();\n             assertTrue(e2 instanceof CompositeException);\n-            assertEquals(\"Chain of Causes for CompositeException In Order Received =>\", e2.getCause().getMessage());\n+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();\n+            assertEquals(2, innerExceptions.size());\n \n-            Throwable e3 = e2.getCause();\n-            assertTrue(e3.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"error!\", e3.getCause().getMessage());\n+            Throwable e3 = innerExceptions.get(0);\n+            assertTrue(e3 instanceof SafeObserverTestException);\n+            assertEquals(\"error!\", e3.getMessage());\n \n-            Throwable e4 = e3.getCause();\n-            assertTrue(e4.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"failure from unsubscribe\", e4.getCause().getMessage());\n+            Throwable e4 = innerExceptions.get(1);\n+            assertTrue(e4 instanceof SafeObserverTestException);\n+            assertEquals(\"failure from unsubscribe\", e4.getMessage());\n         }\n     }\n ",
    "output": "Fix up SafeObserverTest w.r.t. CompositeException changes"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java b/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java\n--- a/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java\n+++ b/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java\n@@ -16,7 +16,6 @@\n package rx.exceptions;\n \n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n \n import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;",
    "output": "Remove unused import"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/BufferUntilSubscriber.java b/rxjava-core/src/main/java/rx/internal/operators/BufferUntilSubscriber.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/BufferUntilSubscriber.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/BufferUntilSubscriber.java\n@@ -81,9 +81,6 @@ boolean casFirst(int expected, int next) {\n         void setObserverRef(Observer<? super T> o) {\n             observerRef = o;\n         }\n-        boolean casObserverRef(Observer<? super T> expected, Observer<? super T> next) {\n-            return OBSERVER_UPDATER.compareAndSet(this, expected, next);\n-        }\n     }\n     \n     static final class OnSubscribeAction<T> implements OnSubscribe<T> {\n@@ -188,7 +185,7 @@ private void drainIfNeededAndSwitchToActual() {\n             }\n             // now we can safely change over to the actual and get rid of the pass-thru\n             // but only if not unsubscribed\n-            state.casObserverRef(this, actual);\n+            state.setObserverRef(actual);\n         }\n \n     }",
    "output": "Remove unnecessary code"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/util/MpscPaddedQueue.java b/rxjava-core/src/main/java/rx/internal/util/MpscPaddedQueue.java\n--- a/rxjava-core/src/main/java/rx/internal/util/MpscPaddedQueue.java\n+++ b/rxjava-core/src/main/java/rx/internal/util/MpscPaddedQueue.java\n@@ -15,31 +15,77 @@\n  */\n package rx.internal.util;\n \n-import java.io.Serializable;\n-import java.util.concurrent.atomic.AtomicReference;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import rx.internal.util.MpscPaddedQueue.Node;\n+\n+abstract class MpscLinkedQueuePad0<E> {\n+    long p00, p01, p02, p03, p04, p05, p06, p07;\n+    long p30, p31, p32, p33, p34, p35, p36, p37;\n+}\n+\n+abstract class MpscLinkedQueueHeadRef<E> extends MpscLinkedQueuePad0<E> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<MpscLinkedQueueHeadRef, Node> UPDATER =\n+        newUpdater(MpscLinkedQueueHeadRef.class, Node.class, \"headRef\");\n+    private volatile Node<E> headRef;\n+\n+    protected final Node<E> headRef() {\n+        return headRef;\n+    }\n+    protected final void headRef(Node<E> val) {\n+        headRef = val;\n+    }\n+    protected final void lazySetHeadRef(Node<E> newVal) {\n+        UPDATER.lazySet(this, newVal);\n+    }\n+}\n+\n+abstract class MpscLinkedQueuePad1<E> extends MpscLinkedQueueHeadRef<E> {\n+    long p00, p01, p02, p03, p04, p05, p06, p07;\n+    long p30, p31, p32, p33, p34, p35, p36, p37;\n+}\n+\n+abstract class MpscLinkedQueueTailRef<E> extends MpscLinkedQueuePad1<E> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<MpscLinkedQueueTailRef, Node> UPDATER =\n+        newUpdater(MpscLinkedQueueTailRef.class, Node.class, \"tailRef\");\n+    private volatile Node<E> tailRef;\n+    protected final Node<E> tailRef() {\n+        return tailRef;\n+    }\n+    protected final void tailRef(Node<E> val) {\n+        tailRef = val;\n+    }\n+    @SuppressWarnings(\"unchecked\")\n+    protected final Node<E> getAndSetTailRef(Node<E> newVal) {\n+        return (Node<E>) UPDATER.getAndSet(this, newVal);\n+    }\n+}\n /**\n  * A multiple-producer single consumer queue implementation with padded reference to tail to avoid cache-line\n  * thrashing. Based on Netty's <a href='https://github.com/netty/netty/blob/master/common/src/main/java/io/netty/util/internal/MpscLinkedQueue.java'>MpscQueue implementation</a>\n- * but using {@code AtomicReferenceFieldUpdater} instead of {@code Unsafe}.\n- *\n+ * but using {@code AtomicReferenceFieldUpdater} instead of {@code Unsafe}.<br>\n+ * Original algorithm presented <a\n+ * href=\"http://www.1024cores.net/home/lock-free-algorithms/queues/non-intrusive-mpsc-node-based-queue\"> on 1024\n+ * Cores</a> by D. Vyukov.<br>\n+ * Data structure modified to avoid false sharing between head and tail references as per implementation of\n+ * MpscLinkedQueue on <a href=\"https://github.com/JCTools/JCTools\">JCTools project</a>.\n+ * \n  * @param <E> the element type\n  */\n-public final class MpscPaddedQueue<E> extends AtomicReference<MpscPaddedQueue.Node<E>> {\n-    /** */\n-    private static final long serialVersionUID = 1L;\n-    /** The padded tail reference. */\n-    final PaddedNode<E> tail;\n-\n+public final class MpscPaddedQueue<E> extends MpscLinkedQueueTailRef<E> {\n+    long p00, p01, p02, p03, p04, p05, p06, p07;\n+    long p30, p31, p32, p33, p34, p35, p36, p37;\n     /**\n      * Initializes the empty queue.\n      */\n     public MpscPaddedQueue() {\n-        Node<E> first = new Node<E>(null);\n-        tail = new PaddedNode<E>();\n-        tail.node = first;\n-        set(first);\n+        Node<E> stub = new Node<E>(null);\n+        headRef(stub);\n+        tailRef(stub);\n     }\n \n     /**\n@@ -49,7 +95,7 @@ public MpscPaddedQueue() {\n      */\n     public void offer(E v) {\n         Node<E> n = new Node<E>(v);\n-        getAndSet(n).set(n);\n+        getAndSetTailRef(n).next(n);\n     }\n \n     /**\n@@ -63,25 +109,23 @@ public E poll() {\n         }\n         E v = n.value;\n         n.value = null; // do not retain this value as the node still stays in the queue\n-        tail.lazySet(n);\n+        lazySetHeadRef(n);\n         return v;\n     }\n-\n+    \n     /**\n      * Check if there is a node available without changing anything.\n      * @return\n      */\n     private Node<E> peekNode() {\n         for (;;) {\n-            @SuppressWarnings(value = \"unchecked\")\n-            Node<E> t = tail.node;\n-            Node<E> n = t.get();\n-            if (n != null || get() == t) {\n+            Node<E> t = headRef();\n+            Node<E> n = t.next();\n+            if (n != null || headRef() == t) {\n                 return n;\n             }\n         }\n     }\n-\n     /**\n      * Clears the queue.\n      */\n@@ -92,46 +136,26 @@ public void clear() {\n             }\n         }\n     }\n-    /** The front-padded node class housing the actual value. */\n-    static abstract class PaddedNodeBase<E> extends FrontPadding {\n-        private static final long serialVersionUID = 2L;\n-        volatile Node<E> node;\n-        @SuppressWarnings(value = \"rawtypes\")\n-        static final AtomicReferenceFieldUpdater<PaddedNodeBase, Node> NODE_UPDATER = AtomicReferenceFieldUpdater.newUpdater(PaddedNodeBase.class, Node.class, \"node\");\n-        public void lazySet(Node<E> newValue) {\n-            NODE_UPDATER.lazySet(this, newValue);\n-        }\n-    }\n-    /** Post-padding of the padded node base class.  */\n-    static final class PaddedNode<E> extends PaddedNodeBase<E> {\n-        private static final long serialVersionUID = 3L;\n-        /** Padding. */\n-        public transient long p16, p17, p18, p19, p20, p21, p22;      // 56 bytes (the remaining 8 is in the base)\n-        /** Padding. */\n-        public transient long p24, p25, p26, p27, p28, p29, p30, p31; // 64 bytes\n-    }\n \n     /**\n      * Regular node with value and reference to the next node.\n      */\n-    static final class Node<E> implements Serializable {\n-        private static final long serialVersionUID = 4L;\n+    static final class Node<E> {\n         E value;\n         @SuppressWarnings(value = \"rawtypes\")\n         static final AtomicReferenceFieldUpdater<Node, Node> TAIL_UPDATER = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, \"tail\");\n-        volatile Node<E> tail;\n+        private volatile Node<E> next;\n \n-        public Node(E value) {\n+        Node(E value) {\n             this.value = value;\n         }\n \n-        public void set(Node<E> newTail) {\n-            TAIL_UPDATER.lazySet(this, newTail);\n+        void next(Node<E> newNext) {\n+            TAIL_UPDATER.lazySet(this, newNext);\n         }\n \n-        @SuppressWarnings(value = \"unchecked\")\n-        public Node<E> get() {\n-            return TAIL_UPDATER.get(this);\n+        Node<E> next() {\n+            return next;\n         }\n     }\n     ",
    "output": "Fix head/tail false sharing issues"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java\n@@ -20,6 +20,7 @@\n import rx.Observable;\n import rx.Observable.Operator;\n import rx.Subscriber;\n+import rx.exceptions.Exceptions;\n import rx.observers.SerializedSubscriber;\n import rx.subscriptions.CompositeSubscription;\n \n@@ -111,6 +112,7 @@ public void onNext(T t) {\n \n         @Override\n         public void onError(Throwable e) {\n+            Exceptions.throwIfFatal(e);\n             if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {\n                 parent.onError(e);\n             }\n\ndiff --git a/rxjava-core/src/main/java/rx/observers/SerializedObserver.java b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java\n--- a/rxjava-core/src/main/java/rx/observers/SerializedObserver.java\n+++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java\n@@ -16,6 +16,7 @@\n package rx.observers;\n \n import rx.Observer;\n+import rx.exceptions.Exceptions;\n \n /**\n  * Enforces single-threaded, serialized, ordered execution of {@link #onNext}, {@link #onCompleted}, and\n@@ -100,6 +101,7 @@ public void onCompleted() {\n \n     @Override\n     public void onError(final Throwable e) {\n+        Exceptions.throwIfFatal(e);\n         FastList list;\n         synchronized (this) {\n             if (terminated) {\n\ndiff --git a/rxjava-core/src/test/java/rx/ObservableTests.java b/rxjava-core/src/test/java/rx/ObservableTests.java\n--- a/rxjava-core/src/test/java/rx/ObservableTests.java\n+++ b/rxjava-core/src/test/java/rx/ObservableTests.java\n@@ -46,6 +46,7 @@\n import org.mockito.MockitoAnnotations;\n \n import rx.Observable.OnSubscribe;\n+import rx.exceptions.OnErrorNotImplementedException;\n import rx.functions.Action1;\n import rx.functions.Action2;\n import rx.functions.Func1;\n@@ -1016,4 +1017,14 @@ public void testAmbWith() {\n         ts.assertReceivedOnNext(Arrays.asList(1));\n     }\n \n+    @Test(expected = OnErrorNotImplementedException.class)\n+    public void testSubscribeWithoutOnError() {\n+        Observable<String> o = Observable.from(\"a\", \"b\").flatMap(new Func1<String, Observable<String>>() {\n+            @Override\n+            public Observable<String> call(String s) {\n+                return Observable.error(new Exception(\"test\"));\n+            }\n+        });\n+        o.subscribe();\n+    }\n }",
    "output": "Fix the bug that 'flatMap' swallows OnErrorNotImplementedException"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorObserveOn.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorObserveOn.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorObserveOn.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorObserveOn.java\n@@ -138,7 +138,7 @@ private void pollQueue() {\n                     }\n                     on.accept(observer, v);\n                 }\n-                if (COUNTER_UPDATER.addAndGet(this, -vs.size) == 0) {\n+                if (COUNTER_UPDATER.addAndGet(this, -vs.size) <= 0) {\n                     break;\n                 }\n             } while (true);",
    "output": "Fix a race condition if queued actions have been handled already"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java b/rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java\n@@ -72,13 +72,14 @@ public boolean isUnsubscribed() {\n         @Override\n         public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {\n             final ScheduledAction scheduledAction = new ScheduledAction(action);\n-            scheduledAction.addParent(mCompositeSubscription);\n             scheduledAction.add(Subscriptions.create(new Action0() {\n                 @Override\n                 public void call() {\n                     handler.removeCallbacks(scheduledAction);\n                 }\n             }));\n+            scheduledAction.addParent(mCompositeSubscription);\n+            mCompositeSubscription.add(scheduledAction);\n \n             handler.postDelayed(scheduledAction, unit.toMillis(delayTime));\n \n@@ -91,5 +92,4 @@ public Subscription schedule(final Action0 action) {\n         }\n \n     }\n-\n }",
    "output": "Add ScheduledSubscription to parent in order to properly chain unsubscribe. Signed-off-by: David Marques <dpsmarques@gmail.com>"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorMergeDelayError.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorMergeDelayError.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorMergeDelayError.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorMergeDelayError.java\n@@ -22,7 +22,6 @@\n import rx.Subscriber;\n import rx.exceptions.CompositeException;\n import rx.observers.SerializedSubscriber;\n-import rx.plugins.RxJavaPlugins;\n import rx.subscriptions.CompositeSubscription;\n \n /**\n@@ -128,7 +127,6 @@ public void onCompleted() {\n         }\n \n         void error(Throwable e) {\n-            RxJavaPlugins.getInstance().getErrorHandler().handleError(e);\n             exceptions.add(e);\n             complete();\n         }",
    "output": "Remove call to RxJavaPlugins ErrorHander in mergeDelayError operator - CompositeException is already visible"
  },
  {
    "input": "diff --git a/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java b/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java\n--- a/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java\n+++ b/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java\n@@ -90,17 +90,4 @@ public Boolean call(Integer t1) {\n         input.awaitCompletion();\n     }\n \n-    @GenerateMicroBenchmark\n-    public void flatMapAsyncNested(final UseCaseInput input) throws InterruptedException {\n-        input.observable.flatMap(new Func1<Integer, Observable<Integer>>() {\n-\n-            @Override\n-            public Observable<Integer> call(Integer i) {\n-                return input.observable.subscribeOn(Schedulers.computation());\n-            }\n-\n-        }).subscribe(input.observer);\n-        input.awaitCompletion();\n-    }\n-\n }",
    "output": "Remove Bad Perf Test\n\n- this just stresses scheduling and at this throughput creates massive garbage and tests the wrong thing"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/internal/operators/NotificationLite.java b/rxjava-core/src/main/java/rx/internal/operators/NotificationLite.java\n--- a/rxjava-core/src/main/java/rx/internal/operators/NotificationLite.java\n+++ b/rxjava-core/src/main/java/rx/internal/operators/NotificationLite.java\n@@ -31,8 +31,6 @@\n  * It's implemented as a singleton to maintain some semblance of type safety that is completely\n  * non-existent.\n  * \n- * @author gscampbell\n- * \n  * @param <T>\n  */\n public final class NotificationLite<T> {\n@@ -89,8 +87,7 @@ public Object completed() {\n     }\n \n     /**\n-     * Create a lite onError notification. This call does new up an object to wrap the\n-     * {@link Throwable} but since there should only be one of these the performance impact should\n+     * Create a lite onError notification. This call does new up an object to wrap the {@link Throwable} but since there should only be one of these the performance impact should\n      * be small. Can be unwrapped and sent with the {@link #accept} method.\n      * \n      * @param e\n@@ -106,25 +103,27 @@ public Object error(Throwable e) {\n      * @param o\n      *            the {@link Observer} to call onNext, onCompleted or onError.\n      * @param n\n+     * @return true if the n was a termination event\n      * @throws IllegalArgumentException\n      *             if the notification is null.\n      * @throws NullPointerException\n      *             if the {@link Observer} is null.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public void accept(Observer<? super T> o, Object n) {\n+    public boolean accept(Observer<? super T> o, Object n) {\n         if (n == ON_COMPLETED_SENTINEL) {\n             o.onCompleted();\n-        } else\n-        if (n == ON_NEXT_NULL_SENTINEL) {\n+            return true;\n+        } else if (n == ON_NEXT_NULL_SENTINEL) {\n             o.onNext(null);\n-        } else\n-        if (n != null) {\n+            return false;\n+        } else if (n != null) {\n             if (n.getClass() == OnErrorSentinel.class) {\n-                o.onError(((OnErrorSentinel)n).e);\n-            } else {\n-                o.onNext((T)n);\n+                o.onError(((OnErrorSentinel) n).e);\n+                return true;\n             }\n+            o.onNext((T) n);\n+            return false;\n         } else {\n             throw new IllegalArgumentException(\"The lite notification can not be null\");\n         }\n@@ -139,8 +138,7 @@ public boolean isError(Object n) {\n     }\n \n     /**\n-     * If there is custom logic that isn't as simple as call the right method on an {@link Observer}\n-     * then this method can be used to get the {@link rx.Notification.Kind}\n+     * If there is custom logic that isn't as simple as call the right method on an {@link Observer} then this method can be used to get the {@link rx.Notification.Kind}\n      * \n      * @param n\n      * @return the kind of the raw object",
    "output": "Change `void accept` to `boolean accept`\n\nAs per a change @akarnokd did elsewhere with `accept2` method"
  },
  {
    "input": "diff --git a/rxjava-core/src/perf/java/rx/archive/operators/OperatorSerializePerformance.java b/rxjava-core/src/perf/java/rx/archive/operators/OperatorSerializePerformance.java\n--- a/rxjava-core/src/perf/java/rx/archive/operators/OperatorSerializePerformance.java\n+++ b/rxjava-core/src/perf/java/rx/archive/operators/OperatorSerializePerformance.java\n@@ -3,6 +3,7 @@\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n+import org.openjdk.jmh.annotations.Setup;\n import org.openjdk.jmh.logic.BlackHole;\n \n import rx.Observable;\n@@ -27,30 +28,6 @@ public class OperatorSerializePerformance extends AbstractPerformanceTester {\n         super(reps);\n     }\n \n-    public static void main(String args[]) {\n-\n-        final OperatorSerializePerformance spt = new OperatorSerializePerformance();\n-        final Input input = new Input();\n-        input.setup();\n-        try {\n-            spt.runTest(new Action0() {\n-\n-                @Override\n-                public void call() {\n-                    //                    spt.noSerializationSingleThreaded(input);\n-                    spt.serializedSingleStream(input);\n-                    //                    spt.synchronizedSingleStream(input);\n-                    //                    spt.timeTwoStreams();\n-                    //                    spt.timeSingleStream();\n-                    //                    spt.timeTwoStreamsIntervals();\n-                }\n-            });\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-\n-    }\n-\n     /**\n      * Run: 10 - 12,186,982 ops/sec\n      * Run: 11 - 10,236,722 ops/sec\n@@ -379,7 +356,8 @@ public static class Input {\n \n         private CountDownLatch latch;\n \n-        public void setup() {\n+        @Setup\n+        public void setup(final BlackHole bh) {\n             observable = Observable.create(new OnSubscribe<Integer>() {\n                 @Override\n                 public void call(Subscriber<? super Integer> o) {\n@@ -392,7 +370,6 @@ public void call(Subscriber<? super Integer> o) {\n                 }\n             });\n \n-            final BlackHole bh = new BlackHole();\n             latch = new CountDownLatch(1);\n \n             subscriber = new TestSubscriber<Integer>(new Observer<Integer>() {\n\ndiff --git a/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java b/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java\n--- a/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java\n+++ b/rxjava-core/src/perf/java/rx/jmh/InputWithIncrementingInteger.java\n@@ -42,7 +42,7 @@ public class InputWithIncrementingInteger {\n     private CountDownLatch latch;\n \n     @Setup\n-    public void setup() {\n+    public void setup(final BlackHole bh) {\n         observable = Observable.create(new OnSubscribe<Integer>() {\n             @Override\n             public void call(Subscriber<? super Integer> o) {\n@@ -55,7 +55,6 @@ public void call(Subscriber<? super Integer> o) {\n             }\n         });\n \n-        final BlackHole bh = new BlackHole();\n         latch = new CountDownLatch(1);\n \n         observer = new Observer<Integer>() {\n\ndiff --git a/rxjava-core/src/perf/java/rx/operators/OperatorSerializePerf.java b/rxjava-core/src/perf/java/rx/operators/OperatorSerializePerf.java\n--- a/rxjava-core/src/perf/java/rx/operators/OperatorSerializePerf.java\n+++ b/rxjava-core/src/perf/java/rx/operators/OperatorSerializePerf.java\n@@ -54,7 +54,7 @@ public static class Input {\n         private CountDownLatch latch;\n \n         @Setup\n-        public void setup() {\n+        public void setup(final BlackHole bh) {\n             observable = Observable.create(new OnSubscribe<Integer>() {\n                 @Override\n                 public void call(Subscriber<? super Integer> o) {\n@@ -67,7 +67,6 @@ public void call(Subscriber<? super Integer> o) {\n                 }\n             });\n \n-            final BlackHole bh = new BlackHole();\n             latch = new CountDownLatch(1);\n \n             subscriber = new TestSubscriber<Integer>(new Observer<Integer>() {\n\ndiff --git a/rxjava-core/src/perf/java/rx/usecases/UseCaseInput.java b/rxjava-core/src/perf/java/rx/usecases/UseCaseInput.java\n--- a/rxjava-core/src/perf/java/rx/usecases/UseCaseInput.java\n+++ b/rxjava-core/src/perf/java/rx/usecases/UseCaseInput.java\n@@ -42,7 +42,7 @@ public class UseCaseInput {\n     private CountDownLatch latch;\n \n     @Setup\n-    public void setup() {\n+    public void setup(final BlackHole bh) {\n         observable = Observable.create(new OnSubscribe<Integer>() {\n             @Override\n             public void call(Subscriber<? super Integer> o) {\n@@ -53,7 +53,6 @@ public void call(Subscriber<? super Integer> o) {\n             }\n         });\n \n-        final BlackHole bh = new BlackHole();\n         latch = new CountDownLatch(1);\n \n         observer = new Observer<Integer>() {",
    "output": "Upgrade to JMH 0.7.3"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n@@ -63,8 +63,8 @@ public static <T> AsyncSubject<T> create() {\n             @Override\n             public void call(SubjectObserver<T> o) {\n                 Object v = state.get();\n-                o.accept(v, state.nl);\n-                NotificationLite<T> nl = NotificationLite.instance();\n+                NotificationLite<T> nl = state.nl;\n+                o.accept(v, nl);\n                 if (v == null || (!nl.isCompleted(v) && !nl.isError(v))) {\n                     o.onCompleted();\n                 }",
    "output": "Remove duplicate NotificationLite"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -4053,7 +4053,7 @@ public final void forEach(final Action1<? super T> onNext, final Action1<Throwab\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Transforming-Observables#wiki-groupby-and-groupbyuntil\">RxJava Wiki: groupBy</a>\n      */\n     public final <K> Observable<GroupedObservable<K, T>> groupBy(final Func1<? super T, ? extends K> keySelector) {\n-        return lift(new OnSubscribeGroupBy<K, T>(keySelector));\n+        return lift(new OperatorGroupBy<K, T>(keySelector));\n     }\n \n     /**\n@@ -4106,7 +4106,7 @@ public final <TKey, TDuration> Observable<GroupedObservable<TKey, T>> groupByUnt\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229433.aspx\">MSDN: Observable.GroupByUntil</a>\n      */\n     public final <TKey, TValue, TDuration> Observable<GroupedObservable<TKey, TValue>> groupByUntil(Func1<? super T, ? extends TKey> keySelector, Func1<? super T, ? extends TValue> valueSelector, Func1<? super GroupedObservable<TKey, TValue>, ? extends Observable<? extends TDuration>> durationSelector) {\n-        return lift(new OnSubscribeGroupByUntil<T, TKey, TValue, TDuration>(keySelector, valueSelector, durationSelector));\n+        return lift(new OperatorGroupByUntil<T, TKey, TValue, TDuration>(keySelector, valueSelector, durationSelector));\n     }\n \n     /**\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java b/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java\n@@ -37,11 +37,11 @@\n  * @param <K> the key type\n  * @param <T> the source and group value type\n  */\n-public final class OnSubscribeGroupBy<K, T> implements Operator<GroupedObservable<K, T>, T> {\n+public final class OperatorGroupBy<K, T> implements Operator<GroupedObservable<K, T>, T> {\n     \n     final Func1<? super T, ? extends K> keySelector;\n     \n-    public OnSubscribeGroupBy(final Func1<? super T, ? extends K> keySelector) {\n+    public OperatorGroupBy(final Func1<? super T, ? extends K> keySelector) {\n         this.keySelector = keySelector;\n     }\n     \n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperatorGroupByUntil.java b/rxjava-core/src/main/java/rx/operators/OperatorGroupByUntil.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorGroupByUntil.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorGroupByUntil.java\n@@ -44,12 +44,12 @@\n  * @param <R> the value type of the groups\n  * @param <D> the type of the duration\n  */\n-public class OnSubscribeGroupByUntil<T, K, R, D> implements Operator<GroupedObservable<K, R>, T> {\n+public class OperatorGroupByUntil<T, K, R, D> implements Operator<GroupedObservable<K, R>, T> {\n     final Func1<? super T, ? extends K> keySelector;\n     final Func1<? super T, ? extends R> valueSelector;\n     final Func1<? super GroupedObservable<K, R>, ? extends Observable<? extends D>> durationSelector;\n \n-    public OnSubscribeGroupByUntil(\n+    public OperatorGroupByUntil(\n             Func1<? super T, ? extends K> keySelector,\n             Func1<? super T, ? extends R> valueSelector,\n             Func1<? super GroupedObservable<K, R>, ? extends Observable<? extends D>> durationSelector) {\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperatorParallel.java b/rxjava-core/src/main/java/rx/operators/OperatorParallel.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorParallel.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorParallel.java\n@@ -41,7 +41,7 @@ public OperatorParallel(Func1<Observable<T>, Observable<R>> f, Scheduler schedul\n     public Subscriber<? super T> call(Subscriber<? super R> op) {\n \n         Func1<Subscriber<? super GroupedObservable<Long, T>>, Subscriber<? super T>> groupBy =\n-                new OnSubscribeGroupBy<Long, T>(new Func1<T, Long>() {\n+                new OperatorGroupBy<Long, T>(new Func1<T, Long>() {\n \n                     long i = 0;\n \n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java b/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java\n@@ -50,7 +50,7 @@\n import rx.observables.GroupedObservable;\n import rx.schedulers.Schedulers;\n \n-public class OnSubscribeGroupByTest {\n+public class OperatorGroupByTest {\n \n     final Func1<String, Integer> length = new Func1<String, Integer>() {\n         @Override\n@@ -62,7 +62,7 @@ public Integer call(String s) {\n     @Test\n     public void testGroupBy() {\n         Observable<String> source = Observable.from(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\");\n-        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OnSubscribeGroupBy<Integer, String>(length));\n+        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OperatorGroupBy<Integer, String>(length));\n \n         Map<Integer, Collection<String>> map = toMap(grouped);\n \n@@ -75,7 +75,7 @@ public void testGroupBy() {\n     @Test\n     public void testEmpty() {\n         Observable<String> source = Observable.empty();\n-        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OnSubscribeGroupBy<Integer, String>(length));\n+        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OperatorGroupBy<Integer, String>(length));\n \n         Map<Integer, Collection<String>> map = toMap(grouped);\n \n@@ -88,7 +88,7 @@ public void testError() {\n         Observable<String> errorSource = Observable.error(new RuntimeException(\"forced failure\"));\n         Observable<String> source = Observable.concat(sourceStrings, errorSource);\n \n-        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OnSubscribeGroupBy<Integer, String>(length));\n+        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OperatorGroupBy<Integer, String>(length));\n \n         final AtomicInteger groupCounter = new AtomicInteger();\n         final AtomicInteger eventCounter = new AtomicInteger();\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperatorGroupByUntilTest.java b/rxjava-core/src/test/java/rx/operators/OperatorGroupByUntilTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorGroupByUntilTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorGroupByUntilTest.java\n@@ -45,7 +45,7 @@\n import rx.functions.Functions;\n import rx.observables.GroupedObservable;\n \n-public class OnSubscribeGroupByUntilTest {\n+public class OperatorGroupByUntilTest {\n     @Mock\n     Observer<Object> observer;\n ",
    "output": "Fix GroupBy and GroupByUntil which are actually Operators"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -2301,15 +2301,18 @@ public static final <K1, K2, T> Observable<GroupedObservable<K2, GroupedObservab\n      *            the number of sequential Integers to generate\n      * @return an Observable that emits a range of sequential Integers\n      * @throws IllegalArgumentException\n-     *             if {@code count} is less than zero\n+     *             if {@code count} is less than zero, or if {@code start} + {@code count} - 1 exceeds {@code Integer.MAX_VALUE}\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Creating-Observables#wiki-range\">RxJava Wiki: range()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229460.aspx\">MSDN: Observable.Range</a>\n      */\n     public final static Observable<Integer> range(int start, int count) {\n         if (count < 0) {\n             throw new IllegalArgumentException(\"Count can not be negative\");\n         }\n-        if ((start + count) > Integer.MAX_VALUE) {\n+        if (count == 0) {\n+            return Observable.empty();\n+        }\n+        if (start > Integer.MAX_VALUE - count + 1) {\n             throw new IllegalArgumentException(\"start + count can not exceed Integer.MAX_VALUE\");\n         }\n         return Observable.create(new OnSubscribeRange(start, start + (count - 1)));\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OnSubscribeRangeTest.java b/rxjava-core/src/test/java/rx/operators/OnSubscribeRangeTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OnSubscribeRangeTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OnSubscribeRangeTest.java\n@@ -16,6 +16,7 @@\n package rx.operators;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n@@ -67,4 +68,29 @@ public void call(Integer t1) {\n         verify(observer, times(1)).onCompleted();\n         assertEquals(3, count.get());\n     }\n+\n+    @Test\n+    public void testRangeWithOverflow() {\n+        Observable.range(1, 0);\n+    }\n+\n+    @Test\n+    public void testRangeWithOverflow2() {\n+        Observable.range(Integer.MAX_VALUE, 0);\n+    }\n+\n+    @Test\n+    public void testRangeWithOverflow3() {\n+        Observable.range(1, Integer.MAX_VALUE);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testRangeWithOverflow4() {\n+        Observable.range(2, Integer.MAX_VALUE);\n+    }\n+\n+    @Test\n+    public void testRangeWithOverflow5() {\n+        assertFalse(Observable.range(Integer.MIN_VALUE, 0).toBlocking().getIterator().hasNext());\n+    }\n }",
    "output": "Fix the bug that int overflow can bypass the range check"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observables/BlockingObservable.java b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java\n--- a/rxjava-core/src/main/java/rx/observables/BlockingObservable.java\n+++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java\n@@ -25,6 +25,7 @@\n import rx.Subscriber;\n import rx.functions.Action1;\n import rx.functions.Func1;\n+import rx.functions.Functions;\n import rx.operators.BlockingOperatorLatest;\n import rx.operators.BlockingOperatorMostRecent;\n import rx.operators.BlockingOperatorNext;\n@@ -381,17 +382,7 @@ public T single(Func1<? super T, Boolean> predicate) {\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.singleordefault.aspx\">MSDN: Observable.SingleOrDefault</a>\n      */\n     public T singleOrDefault(T defaultValue) {\n-        Iterator<? extends T> it = this.toIterable().iterator();\n-\n-        if (!it.hasNext()) {\n-            return defaultValue;\n-        }\n-\n-        T result = it.next();\n-        if (it.hasNext()) {\n-            throw new IllegalArgumentException(\"Sequence contains too many elements\");\n-        }\n-        return result;\n+        return from(o.map(Functions.<T>identity()).singleOrDefault(defaultValue)).single();\n     }\n \n     /**\n\ndiff --git a/rxjava-core/src/test/java/rx/observables/BlockingObservableTest.java b/rxjava-core/src/test/java/rx/observables/BlockingObservableTest.java\n--- a/rxjava-core/src/test/java/rx/observables/BlockingObservableTest.java\n+++ b/rxjava-core/src/test/java/rx/observables/BlockingObservableTest.java\n@@ -16,10 +16,13 @@\n package rx.observables;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n import java.util.Iterator;\n import java.util.NoSuchElementException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import org.junit.Assert;\n import org.junit.Before;\n@@ -28,10 +31,14 @@\n import org.mockito.MockitoAnnotations;\n \n import rx.Observable;\n+import rx.Observable.OnSubscribe;\n import rx.Subscriber;\n import rx.exceptions.TestException;\n+import rx.functions.Action0;\n import rx.functions.Action1;\n import rx.functions.Func1;\n+import rx.schedulers.Schedulers;\n+import rx.subscriptions.Subscriptions;\n \n public class BlockingObservableTest {\n \n@@ -377,4 +384,30 @@ public Boolean call(String args) {\n         });\n         assertEquals(\"default\", first);\n     }\n+\n+    @Test\n+    public void testSingleOrDefaultUnsubscribe() throws InterruptedException {\n+        final CountDownLatch unsubscribe = new CountDownLatch(1);\n+        Observable<Integer> o = Observable.create(new OnSubscribe<Integer>() {\n+            @Override\n+            public void call(Subscriber<? super Integer> subscriber) {\n+                subscriber.add(Subscriptions.create(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        unsubscribe.countDown();\n+                    }\n+                }));\n+                subscriber.onNext(1);\n+                subscriber.onNext(2);\n+                // Don't call `onCompleted` to emulate an infinite stream\n+            }\n+        }).subscribeOn(Schedulers.newThread());\n+        try {\n+            o.toBlocking().singleOrDefault(-1);\n+            fail(\"Expected IllegalArgumentException because there are 2 elements\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+        assertTrue(\"Timeout means `unsubscribe` is not called\", unsubscribe.await(30, TimeUnit.SECONDS));\n+    }\n }",
    "output": "Fix the bug that BlockingObservable.singleOrDefault doesn't call unsubscribe"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorMerge.java b/rxjava-core/src/main/java/rx/operators/OperatorMerge.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorMerge.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorMerge.java\n@@ -49,6 +49,7 @@ static final class MergeSubscriber<T> extends Subscriber<Observable<? extends T>\n         final Subscriber<T> actual;\n         final CompositeSubscription childrenSubscriptions;\n         volatile int wip;\n+        volatile boolean completed;\n         @SuppressWarnings(\"rawtypes\")\n         static final AtomicIntegerFieldUpdater<MergeSubscriber> WIP_UPDATER\n                 = AtomicIntegerFieldUpdater.newUpdater(MergeSubscriber.class, \"wip\");\n@@ -57,7 +58,6 @@ public MergeSubscriber(Subscriber<T> actual, CompositeSubscription childrenSubsc\n             super(actual);\n             this.actual = actual;\n             this.childrenSubscriptions = childrenSubscriptions;\n-            this.wip = 1;\n         }\n \n         @Override\n@@ -76,11 +76,20 @@ public void onError(Throwable e) {\n \n         @Override\n         public void onCompleted() {\n-            if (WIP_UPDATER.decrementAndGet(this) == 0) {\n+            completed = true;\n+            if (wip == 0) {\n                 actual.onCompleted();\n             }\n         }\n-        \n+        void completeInner(InnerSubscriber<T> s) {\n+            try {\n+                if (WIP_UPDATER.decrementAndGet(this) == 0 && completed) {\n+                    actual.onCompleted();\n+                }\n+            } finally {\n+                childrenSubscriptions.remove(s);\n+            }\n+        }\n     }\n     static final class InnerSubscriber<T> extends Subscriber<T> {\n         final Subscriber<? super T> actual;\n@@ -110,11 +119,7 @@ public void onError(Throwable e) {\n         @Override\n         public void onCompleted() {\n             if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {\n-                try {\n-                    parent.onCompleted();\n-                } finally {\n-                    parent.childrenSubscriptions.remove(this);\n-                }\n+                parent.completeInner(this);\n             }\n         }\n         ",
    "output": "Make the chunk_test.clj work again for now"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java b/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java\n--- a/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java\n+++ b/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java\n@@ -453,8 +453,8 @@ public void onCompleted() {\n \n         @Override\n         public void onError(Throwable e) {\n-            completed.countDown();\n             error.set(e);\n+            completed.countDown();\n         }\n \n         @Override",
    "output": "Fix testConcurrentOnNextFailsValidation"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -6255,16 +6255,7 @@ public final Subscription subscribe(Subscriber<? super T> subscriber) {\n                 subscriber = new SafeSubscriber<T>(subscriber);\n             }\n             onSubscribeFunction.call(subscriber);\n-            final Subscription returnSubscription = hook.onSubscribeReturn(subscriber);\n-            // we return it inside a Subscription so it can't be cast back to Subscriber\n-            return Subscriptions.create(new Action0() {\n-\n-                @Override\n-                public void call() {\n-                    returnSubscription.unsubscribe();\n-                }\n-\n-            });\n+            return hook.onSubscribeReturn(subscriber);\n         } catch (Throwable e) {\n             // special handling for certain Throwable/Error/Exception types\n             Exceptions.throwIfFatal(e);",
    "output": "Remove Subscription Wrapper from Observable.subscribe\n\nPerformance increase from 7.7m to 8.8m ops/second\n\nBefore:\n\nBenchmark                              (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.mapTransformation        1  thrpt         5  7714453.187   362218.633    ops/s\nr.u.PerfTransforms.mapTransformation        1  thrpt         5  7527144.767   497816.471    ops/s\n\nAfter:\n\nBenchmark                              (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.mapTransformation        1  thrpt         5  8853534.333   183494.242    ops/s\nr.u.PerfTransforms.mapTransformation        1  thrpt         5  8806958.403   452595.219    ops/s"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observers/SafeSubscriber.java b/rxjava-core/src/main/java/rx/observers/SafeSubscriber.java\n--- a/rxjava-core/src/main/java/rx/observers/SafeSubscriber.java\n+++ b/rxjava-core/src/main/java/rx/observers/SafeSubscriber.java\n@@ -16,7 +16,7 @@\n package rx.observers;\n \n import java.util.Arrays;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n import rx.Subscriber;\n import rx.exceptions.CompositeException;\n@@ -60,7 +60,11 @@\n public class SafeSubscriber<T> extends Subscriber<T> {\n \n     private final Subscriber<? super T> actual;\n-    private final AtomicBoolean isFinished = new AtomicBoolean(false);\n+    /** Terminal state indication if not zero. */\n+    volatile int done;\n+    @SuppressWarnings(\"rawtypes\")\n+    static final AtomicIntegerFieldUpdater<SafeSubscriber> DONE_UPDATER\n+            = AtomicIntegerFieldUpdater.newUpdater(SafeSubscriber.class, \"done\");\n \n     public SafeSubscriber(Subscriber<? super T> actual) {\n         super(actual);\n@@ -69,7 +73,7 @@ public SafeSubscriber(Subscriber<? super T> actual) {\n \n     @Override\n     public void onCompleted() {\n-        if (isFinished.compareAndSet(false, true)) {\n+        if (DONE_UPDATER.getAndSet(this, 1) == 0) {\n             try {\n                 actual.onCompleted();\n             } catch (Throwable e) {\n@@ -90,15 +94,15 @@ public void onError(Throwable e) {\n         // we handle here instead of another method so we don't add stacks to the frame\n         // which can prevent it from being able to handle StackOverflow\n         Exceptions.throwIfFatal(e);\n-        if (isFinished.compareAndSet(false, true)) {\n+        if (DONE_UPDATER.getAndSet(this, 1) == 0) {\n             _onError(e);\n         }\n     }\n \n     @Override\n     public void onNext(T args) {\n         try {\n-            if (!isFinished.get()) {\n+            if (done == 0) {\n                 actual.onNext(args);\n             }\n         } catch (Throwable e) {",
    "output": "Change to field updater"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -6026,76 +6026,6 @@ public final void onNext(T args) {\n         });\n     }\n \n-    /**\n-     * An {@link Observer} must call an Observable's {@code subscribe} method in order to receive items and\n-     * notifications from the Observable.\n-     * \n-     * @param onNext\n-     *            FIXME FIXME FIXME\n-     * @param onError\n-     *            FIXME FIXME FIXME\n-     * @param onComplete\n-     *            FIXME FIXME FIXME\n-     * @param scheduler\n-     *            FIXME FIXME FIXME\n-     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving items before\n-     *         the Observable has finished sending them\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable#wiki-onnext-oncompleted-and-onerror\">RxJava Wiki: onNext, onCompleted, and onError</a>\n-     */\n-    public final Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onComplete, Scheduler scheduler) {\n-        return subscribeOn(scheduler).subscribe(onNext, onError, onComplete);\n-    }\n-\n-    /**\n-     * An {@link Observer} must call an Observable's {@code subscribe} method in order to receive items and\n-     * notifications from the Observable.\n-     * \n-     * @param onNext\n-     *            FIXME FIXME FIXME\n-     * @param onError\n-     *            FIXME FIXME FIXME\n-     * @param scheduler\n-     *            FIXME FIXME FIXME\n-     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving items before\n-     *         the Observable has finished sending them\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable#wiki-onnext-oncompleted-and-onerror\">RxJava Wiki: onNext, onCompleted, and onError</a>\n-     */\n-    public final Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, Scheduler scheduler) {\n-        return subscribeOn(scheduler).subscribe(onNext, onError);\n-    }\n-\n-    /**\n-     * An {@link Observer} must call an Observable's {@code subscribe} method in order to receive items and\n-     * notifications from the Observable.\n-     * \n-     * @param onNext\n-     *            FIXME FIXME FIXME\n-     * @param scheduler\n-     *            FIXME FIXME FIXME\n-     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving items before\n-     *         the Observable has finished sending them\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable#wiki-onnext-oncompleted-and-onerror\">RxJava Wiki: onNext, onCompleted, and onError</a>\n-     */\n-    public final Subscription subscribe(final Action1<? super T> onNext, Scheduler scheduler) {\n-        return subscribeOn(scheduler).subscribe(onNext);\n-    }\n-\n-    /**\n-     * An {@link Observer} must subscribe to an Observable in order to receive items and notifications from the\n-     * Observable.\n-     *\n-     * @param observer\n-     *            FIXME FIXME FIXME\n-     * @param scheduler\n-     *            FIXME FIXME FIXME\n-     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving items before\n-     *         the Observable has finished sending them\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable#wiki-onnext-oncompleted-and-onerror\">RxJava Wiki: onNext, onCompleted, and onError</a>\n-     */\n-    public final Subscription subscribe(final Observer<? super T> observer, Scheduler scheduler) {\n-        return subscribeOn(scheduler).subscribe(observer);\n-    }\n-\n     /**\n      * An {@link Observer} must subscribe to an Observable in order to receive items and notifications from the\n      * Observable.\n@@ -6241,38 +6171,6 @@ public void call() {\n         }\n     }\n \n-    /**\n-     * A {@link Subscriber} must call an Observable's {@code subscribe} method in order to receive items and\n-     * notifications from the Observable.\n-     * <p>\n-     * A typical implementation of {@code subscribe} does the following:\n-     * <ol>\n-     * <li>It stores a reference to the Subscriber in a collection object, such as a {@code List<T>} object.</li>\n-     * <li>It returns a reference to the {@link Subscription} interface. This enables Observers to unsubscribe,\n-     * that is, to stop receiving items and notifications before the Observable stops sending them, which also\n-     * invokes the Observer's {@link Observer#onCompleted onCompleted} method.</li>\n-     * </ol><p>\n-     * An {@code Observable<T>} instance is responsible for accepting all subscriptions and notifying all\n-     * Subscribers. Unless the documentation for a particular {@code Observable<T>} implementation indicates\n-     * otherwise, Subscribers should make no assumptions about the order in which multiple Subscribers will\n-     * receive their notifications.\n-     * <p>\n-     * For more information see the\n-     * <a href=\"https://github.com/Netflix/RxJava/wiki/Observable\">RxJava Wiki</a>\n-     * \n-     * @param observer\n-     *            the {@link Subscriber}\n-     * @param scheduler\n-     *            the {@link Scheduler} on which Subscribers subscribe to the Observable\n-     * @return a {@link Subscription} reference with which Subscribers that are {@link Observer}s can\n-     *         unsubscribe from the Observable\n-     * @throws IllegalArgumentException\n-     *             if an argument to {@code subscribe()} is {@code null}\n-     */\n-    public final Subscription subscribe(Subscriber<? super T> observer, Scheduler scheduler) {\n-        return subscribeOn(scheduler).subscribe(observer);\n-    }\n-\n     /**\n      * Asynchronously subscribes Observers to this Observable on the specified {@link Scheduler}.\n      * <p>\n\ndiff --git a/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerConcurrencyTests.java b/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerConcurrencyTests.java\n--- a/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerConcurrencyTests.java\n+++ b/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerConcurrencyTests.java\n@@ -371,7 +371,7 @@ public void call(Integer t) {\n         final CountDownLatch latch = new CountDownLatch(5);\n         final CountDownLatch first = new CountDownLatch(1);\n \n-        o1.subscribe(new Action1<Integer>() {\n+        o1.subscribeOn(scheduler).subscribe(new Action1<Integer>() {\n \n             @Override\n             public void call(Integer t) {\n@@ -388,7 +388,7 @@ public void call(Integer t) {\n                 count.incrementAndGet();\n                 latch.countDown();\n             }\n-        }, scheduler);\n+        });\n \n         // assert we are async\n         assertEquals(0, count.get());",
    "output": "Remove Ambiguous Subscribe Overloads with Scheduler\n\n- Fixes https://github.com/Netflix/RxJava/issues/1116\n- These should never have been added, the subscribeOn operator already provides this functionality"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorToObservableList.java b/rxjava-core/src/main/java/rx/operators/OperatorToObservableList.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorToObservableList.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorToObservableList.java\n@@ -15,12 +15,13 @@\n  */\n package rx.operators;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n import rx.Observable.Operator;\n import rx.Subscriber;\n \n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n /**\n  * Returns an Observable that emits a single item, a list composed of all the items emitted by the\n  * source Observable.\n@@ -41,7 +42,7 @@ public final class OperatorToObservableList<T> implements Operator<List<T>, T> {\n     public Subscriber<? super T> call(final Subscriber<? super List<T>> o) {\n         return new Subscriber<T>(o) {\n \n-            final List<T> list = new ArrayList<T>();\n+            final List<T> list = new LinkedList<T>();\n \n             @Override\n             public void onCompleted() {",
    "output": "Use LinkedList to buffer the sequence’s items LinkedList has guaranteed constant insertion time when appending to the end of the list, whereas ArrayList takes O(1) amortized, since a reallocation might be necessary to insert further items. Since no capacity was specified for the buffer, on Hotspot this would cause the array to reallocate after the first 10 insertions, on Android after the first insertion (since Android’s ArrayList uses a default capacity of zero.) Since the buffer is copied to an ArrayList before emission, subscriber performance when working with the list should remain unaffected. Refs #1141"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperatorPivotTest.java b/rxjava-core/src/test/java/rx/operators/OperatorPivotTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorPivotTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorPivotTest.java\n@@ -16,6 +16,7 @@\n \n package rx.operators;\n \n+import java.util.Random;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n@@ -239,12 +240,16 @@ public void testConcurrencyAndSerialization() throws InterruptedException {\n             @Override\n             public Observable<String> call(final GroupedObservable<Boolean, GroupedObservable<String, Integer>> outerGroup) {\n                 return outerGroup.flatMap(new Func1<GroupedObservable<String, Integer>, Observable<String>>() {\n-\n                     @Override\n                     public Observable<String> call(final GroupedObservable<String, Integer> innerGroup) {\n                         final AtomicInteger threadsPerGroup = new AtomicInteger();\n                         return innerGroup.take(100).map(new Func1<Integer, String>() {\n-\n+                            final ThreadLocal<Random> tlr = new ThreadLocal<Random>() {\n+                                @Override\n+                                protected Random initialValue() {\n+                                    return new Random();\n+                                }\n+                            };\n                             @Override\n                             public String call(Integer i) {\n                                 int outerThreadCount = outerThreads.incrementAndGet();\n@@ -256,7 +261,11 @@ public String call(Integer i) {\n                                     throw new RuntimeException(\"more than 1 thread for this group [\" + innerGroup.getKey() + \"]: \" + innerThreadCount + \" (before)\");\n                                 }\n                                 try {\n+                                    // give the other threads a shot.\n+                                    Thread.sleep(tlr.get().nextInt(10) + 1);\n                                     return (outerGroup.getKey() ? \"Even\" : \"Odd \") + \" => from source: \" + innerGroup.getKey() + \" Value: \" + i;\n+                                } catch (InterruptedException ex) {\n+                                    throw new RuntimeException(\"Interrupted [\" + innerGroup.getKey() + \"]: \" + i);\n                                 } finally {\n                                     int outerThreadCountAfter = outerThreads.decrementAndGet();\n                                     setMaxConcurrency(maxOuterConcurrency, outerThreadCountAfter);",
    "output": "Fix attempt #1"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java b/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java\n--- a/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java\n+++ b/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java\n@@ -18,6 +18,7 @@\n import rx.Observable;\n import rx.Subscriber;\n import rx.Subscription;\n+import rx.functions.Action1;\n import rx.operators.OperatorRefCount;\n \n /**\n@@ -44,10 +45,28 @@ protected ConnectableObservable(OnSubscribe<T> onSubscribe) {\n     /**\n      * Call a ConnectableObservable's connect() method to instruct it to begin emitting the\n      * items from its underlying {@link Observable} to its {@link Subscriber}s.\n+     * <p>To disconnect from a synchronous source, use the {@link #connect(rx.functions.Action1)}\n+     * method.\n      * @return the subscription representing the connection\n      */\n-    public abstract Subscription connect();\n-\n+    public final Subscription connect() {\n+        final Subscription[] out = new Subscription[1];\n+        connect(new Action1<Subscription>() {\n+            @Override\n+            public void call(Subscription t1) {\n+                out[0] = t1;\n+            }\n+        });\n+        return out[0];\n+    }\n+    /**\n+     * Call a ConnectableObservable's connect() method to instruct it to begin emitting the\n+     * items from its underlying {@link Observable} to its {@link Subscriber}s.\n+     * @param connection the action that receives the connection subscription\n+     * before the subscription to source happens allowing the caller\n+     * to synchronously disconnect a synchronous source.\n+     */\n+    public abstract void connect(Action1<? super Subscription> connection);\n     /**\n      * Returns an observable sequence that stays connected to the source as long\n      * as there is at least one subscription to the observable sequence.\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java b/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java\n@@ -19,6 +19,7 @@\n import rx.Subscriber;\n import rx.Subscription;\n import rx.functions.Action0;\n+import rx.functions.Action1;\n import rx.observables.ConnectableObservable;\n import rx.subjects.Subject;\n import rx.subscriptions.Subscriptions;\n@@ -48,7 +49,20 @@ public void call(Subscriber<? super R> subscriber) {\n     }\n \n     @Override\n-    public Subscription connect() {\n+    public void connect(Action1<? super Subscription> connection) {\n+        connection.call(Subscriptions.create(new Action0() {\n+            @Override\n+            public void call() {\n+                Subscription s;\n+                synchronized (guard) {\n+                    s = subscription;\n+                    subscription = null;\n+                }\n+                if (s != null) {\n+                    s.unsubscribe();\n+                }\n+            }\n+        }));\n         Subscriber<T> s = null;\n         synchronized (guard) {\n             if (subscription == null) {\n@@ -74,20 +88,5 @@ public void onNext(T args) {\n         if (s != null) {\n             source.unsafeSubscribe(s);\n         }\n-\n-        return Subscriptions.create(new Action0() {\n-            @Override\n-            public void call() {\n-                Subscription s;\n-                synchronized (guard) {\n-                    s = subscription;\n-                    subscription = null;\n-                }\n-                if (s != null) {\n-                    s.unsubscribe();\n-                }\n-            }\n-        });\n     }\n-    \n }\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperatorMulticastSelector.java b/rxjava-core/src/main/java/rx/operators/OperatorMulticastSelector.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorMulticastSelector.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorMulticastSelector.java\n@@ -18,12 +18,13 @@\n import rx.Observable;\n import rx.Observable.OnSubscribe;\n import rx.Subscriber;\n+import rx.Subscription;\n+import rx.functions.Action1;\n import rx.functions.Func0;\n import rx.functions.Func1;\n import rx.observables.ConnectableObservable;\n import rx.observers.SafeSubscriber;\n import rx.subjects.Subject;\n-import rx.subscriptions.CompositeSubscription;\n \n /**\n  * Returns an observable sequence that contains the elements of a sequence\n@@ -63,14 +64,16 @@ public void call(Subscriber<? super TResult> child) {\n             return;\n         }\n         \n-        CompositeSubscription csub = new CompositeSubscription();\n-        child.add(csub);\n-        \n-        SafeSubscriber<TResult> s = new SafeSubscriber<TResult>(child);\n+        final SafeSubscriber<TResult> s = new SafeSubscriber<TResult>(child);\n         \n         observable.unsafeSubscribe(s);\n         \n-        csub.add(connectable.connect());\n+        connectable.connect(new Action1<Subscription>() {\n+            @Override\n+            public void call(Subscription t1) {\n+                s.add(t1);\n+            }\n+        });\n     }\n     \n }\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperatorReplayTest.java b/rxjava-core/src/test/java/rx/operators/OperatorReplayTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorReplayTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorReplayTest.java\n@@ -24,13 +24,17 @@\n \n import java.util.Arrays;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Assert;\n+import static org.junit.Assert.assertEquals;\n import org.junit.Test;\n import org.mockito.InOrder;\n \n import rx.Observable;\n import rx.Observer;\n+import rx.functions.Action0;\n+import rx.functions.Action1;\n import rx.functions.Func1;\n import rx.observables.ConnectableObservable;\n import rx.operators.OperatorReplay.VirtualBoundedList;\n@@ -470,4 +474,50 @@ public void testWindowedReplayError() {\n             verify(observer1, never()).onCompleted();\n         }\n     }\n+    @Test\n+    public void testSynchronousDisconnect() {\n+        final AtomicInteger effectCounter = new AtomicInteger();\n+        Observable<Integer> source = Observable.from(1, 2, 3, 4)\n+        .doOnNext(new Action1<Integer>() {\n+            @Override\n+            public void call(Integer v) {\n+                effectCounter.incrementAndGet();\n+                System.out.println(\"Sideeffect #\" + v);\n+            }\n+        });\n+        \n+        Observable<Integer> result = source.replay(\n+        new Func1<Observable<Integer>, Observable<Integer>>() {\n+            @Override\n+            public Observable<Integer> call(Observable<Integer> o) {\n+                return o.take(2);\n+            }\n+        });\n+        \n+        for (int i = 1; i < 3; i++) {\n+            effectCounter.set(0);\n+            System.out.printf(\"- %d -%n\", i);\n+            result.subscribe(new Action1<Integer>() {\n+\n+                @Override\n+                public void call(Integer t1) {\n+                    System.out.println(t1);\n+                }\n+                \n+            }, new Action1<Throwable>() {\n+\n+                @Override\n+                public void call(Throwable t1) {\n+                    t1.printStackTrace();\n+                }\n+            }, \n+            new Action0() {\n+                @Override\n+                public void call() {\n+                    System.out.println(\"Done\");\n+                }\n+            });\n+            assertEquals(2, effectCounter.get());\n+        }\n+    }\n }",
    "output": "Fix synchronous ConnectableObservable.connect problem"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java b/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java\n@@ -15,7 +15,8 @@\n  */\n package rx.operators;\n \n-import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n \n import rx.Observable.Operator;\n@@ -60,7 +61,7 @@ private static class ObserveOnSubscriber<T> extends Subscriber<T> {\n         final Subscriber<? super T> observer;\n         private final Scheduler.Worker recursiveScheduler;\n \n-        private final ConcurrentLinkedQueue<Object> queue = new ConcurrentLinkedQueue<Object>();\n+        private FastList queue = new FastList();\n         final AtomicLong counter = new AtomicLong(0);\n \n         public ObserveOnSubscriber(Scheduler scheduler, Subscriber<? super T> subscriber) {\n@@ -72,19 +73,25 @@ public ObserveOnSubscriber(Scheduler scheduler, Subscriber<? super T> subscriber\n \n         @Override\n         public void onNext(final T t) {\n-            queue.offer(on.next(t));\n+            synchronized (this) {\n+                queue.add(on.next(t));\n+            }\n             schedule();\n         }\n \n         @Override\n         public void onCompleted() {\n-            queue.offer(on.completed());\n+            synchronized (this) {\n+                queue.add(on.completed());\n+            }\n             schedule();\n         }\n \n         @Override\n         public void onError(final Throwable e) {\n-            queue.offer(on.error(e));\n+            synchronized (this) {\n+                queue.add(on.error(e));\n+            }\n             schedule();\n         }\n \n@@ -103,11 +110,43 @@ public void call() {\n \n         private void pollQueue() {\n             do {\n-                Object v = queue.poll();\n-                on.accept(observer, v);\n-            } while (counter.decrementAndGet() > 0);\n+                FastList vs;\n+                synchronized (this) {\n+                    vs = queue;\n+                    queue = new FastList();\n+                }\n+                for (Object v : vs.array) {\n+                    if (v == null) {\n+                        break;\n+                    }\n+                    on.accept(observer, v);\n+                }\n+                if (counter.addAndGet(-vs.size) == 0) {\n+                    break;\n+                }\n+            } while (true);\n         }\n \n     }\n \n+    static final class FastList {\n+        Object[] array;\n+        int size;\n+\n+        public void add(Object o) {\n+            int s = size;\n+            Object[] a = array;\n+            if (a == null) {\n+                a = new Object[16];\n+                array = a;\n+            } else if (s == a.length) {\n+                Object[] array2 = new Object[s + (s >> 2)];\n+                System.arraycopy(a, 0, array2, 0, s);\n+                a = array2;\n+                array = a;\n+            }\n+            a[s] = o;\n+            size = s + 1;\n+        }\n+    }\n }\n\\ No newline at end of file",
    "output": "Change to batch dequeue"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -884,7 +884,7 @@ public final static <T> Observable<T> concat(Observable<? extends T> t1, Observa\n      *         Observable factory function\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Creating-Observables#wiki-defer\">RxJava Wiki: defer()</a>\n      */\n-    public final static <T> Observable<T> defer(Func0<? extends Observable<? extends T>> observableFactory) {\n+    public final static <T> Observable<T> defer(Func0<Observable<? extends T>> observableFactory) {\n         return create(new OperatorDefer<T>(observableFactory));\n     }\n ",
    "output": "Fix defer for Java 8 type-inference\n\nFixes https://github.com/Netflix/RxJava/issues/1157"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Scheduler.java b/rxjava-core/src/main/java/rx/Scheduler.java\n--- a/rxjava-core/src/main/java/rx/Scheduler.java\n+++ b/rxjava-core/src/main/java/rx/Scheduler.java\n@@ -99,15 +99,16 @@ public abstract static class Worker implements Subscription {\n          */\n         public Subscription schedulePeriodically(final Action0 action, long initialDelay, long period, TimeUnit unit) {\n             final long periodInNanos = unit.toNanos(period);\n+            final long startInNanos = TimeUnit.MILLISECONDS.toNanos(now()) + unit.toNanos(initialDelay);\n \n             final Action0 recursiveAction = new Action0() {\n+                long count = 0;\n                 @Override\n                 public void call() {\n                     if (!isUnsubscribed()) {\n-                        long startedAt = now();\n                         action.call();\n-                        long timeTakenByActionInNanos = TimeUnit.MILLISECONDS.toNanos(now() - startedAt);\n-                        schedule(this, periodInNanos - timeTakenByActionInNanos, TimeUnit.NANOSECONDS);\n+                        long nextTick = startInNanos + (++count * periodInNanos);\n+                        schedule(this, nextTick - TimeUnit.MILLISECONDS.toNanos(now()), TimeUnit.NANOSECONDS);\n                     }\n                 }\n             };",
    "output": "Fix to remove drift from schedulePeriodic"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java b/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n@@ -25,6 +25,7 @@\n import rx.Observer;\n import rx.functions.Action0;\n import rx.functions.Action1;\n+import rx.operators.NotificationLite;\n import rx.subjects.SubjectSubscriptionManager.SubjectObserver;\n \n /**\n@@ -127,7 +128,7 @@ public void onCompleted() {\n \n             @Override\n             public void call() {\n-                state.history.complete(Notification.<T> createOnCompleted());\n+                state.history.complete();\n             }\n         });\n         if (observers != null) {\n@@ -145,7 +146,7 @@ public void onError(final Throwable e) {\n \n             @Override\n             public void call() {\n-                state.history.complete(Notification.<T> createOnError(e));\n+                state.history.complete(e);\n             }\n         });\n         if (observers != null) {\n@@ -159,7 +160,7 @@ public void call() {\n \n     @Override\n     public void onNext(T v) {\n-        if (state.history.terminalValue.get() != null) {\n+        if (state.history.terminated) {\n             return;\n         }\n         state.history.next(v);\n@@ -200,12 +201,9 @@ private void replayObserver(SubjectObserver<? super T> observer) {\n \n     private static <T> int replayObserverFromIndex(History<T> history, Integer l, SubjectObserver<? super T> observer) {\n         while (l < history.index.get()) {\n-            observer.onNext(history.list.get(l));\n+            history.accept(observer, l);\n             l++;\n         }\n-        if (history.terminalValue.get() != null) {\n-            history.terminalValue.get().accept(observer);\n-        }\n \n         return l;\n     }\n@@ -217,28 +215,43 @@ private static <T> int replayObserverFromIndex(History<T> history, Integer l, Su\n      * @param <T>\n      */\n     private static class History<T> {\n+        private final NotificationLite<T> nl = NotificationLite.instance();\n         private final AtomicInteger index;\n-        private final ArrayList<T> list;\n-        private final AtomicReference<Notification<T>> terminalValue;\n+        private final ArrayList<Object> list;\n+        private boolean terminated;\n \n         public History(int initialCapacity) {\n             index = new AtomicInteger(0);\n-            list = new ArrayList<T>(initialCapacity);\n-            terminalValue = new AtomicReference<Notification<T>>();\n+            list = new ArrayList<Object>(initialCapacity);\n         }\n \n         public boolean next(T n) {\n-            if (terminalValue.get() == null) {\n-                list.add(n);\n+            if (!terminated) {\n+                list.add(nl.next(n));\n                 index.getAndIncrement();\n                 return true;\n             } else {\n                 return false;\n             }\n         }\n \n-        public void complete(Notification<T> n) {\n-            terminalValue.set(n);\n+        public void accept(Observer<? super T> o, int idx) {\n+            nl.accept(o, list.get(idx));\n+        }\n+        \n+        public void complete() {\n+            if (!terminated) {\n+                terminated = true;\n+                list.add(nl.completed());\n+                index.getAndIncrement();\n+            }\n+        }\n+        public void complete(Throwable e) {\n+            if (!terminated) {\n+                terminated = true;\n+                list.add(nl.error(e));\n+                index.getAndIncrement();\n+            }\n         }\n     }\n ",
    "output": "Fix ReplaySubject termination race"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/schedulers/Schedulers.java b/rxjava-core/src/main/java/rx/schedulers/Schedulers.java\n--- a/rxjava-core/src/main/java/rx/schedulers/Schedulers.java\n+++ b/rxjava-core/src/main/java/rx/schedulers/Schedulers.java\n@@ -23,7 +23,7 @@\n /**\n  * Static factory methods for creating Schedulers.\n  */\n-public class Schedulers {\n+public final class Schedulers {\n \n     private final Scheduler computationScheduler;\n     private final Scheduler ioScheduler;",
    "output": "Make final"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -3213,7 +3213,7 @@ public final <R> Observable<R> concatMap(Func1<? super T, ? extends Observable<?\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#wiki-contains\">RxJava Wiki: contains()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh228965.aspx\">MSDN: Observable.Contains</a>\n      */\n-    public final Observable<Boolean> contains(final T element) {\n+    public final Observable<Boolean> contains(final Object element) {\n         return exists(new Func1<T, Boolean>() {\n             public final Boolean call(T t1) {\n                 return element == null ? t1 == null : element.equals(t1);",
    "output": "Upgrade 'contains' signature to 'contains(Object)'"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorTakeUntil.java b/rxjava-core/src/main/java/rx/operators/OperatorTakeUntil.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorTakeUntil.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorTakeUntil.java\n@@ -43,84 +43,71 @@ public final class OperatorTakeUntil {\n      * @return An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.\n      */\n     public static <T, E> Observable<T> takeUntil(final Observable<? extends T> source, final Observable<? extends E> other) {\n-        Observable<Notification<T>> s = source.lift(new SourceObservable<T>());\n-        Observable<Notification<T>> o = other.lift(new OtherObservable<T, E>());\n+        Observable<Object> s = source.lift(new SourceObservable<T>());\n+        Observable<Object> o = other.lift(new OtherObservable<E>());\n \n-        Observable<Notification<T>> result = Observable.merge(s, o);\n+        Observable<Object> result = Observable.merge(s, o);\n \n-        return result.takeWhile(new Func1<Notification<T>, Boolean>() {\n+        final NotificationLite<T> notification = NotificationLite.instance();\n+\n+        return result.takeWhile(new Func1<Object, Boolean>() {\n             @Override\n-            public Boolean call(Notification<T> notification) {\n-                return !notification.halt;\n+            public Boolean call(Object args) {\n+                return !notification.isCompleted(args);\n             }\n-        }).map(new Func1<Notification<T>, T>() {\n+        }).map(new Func1<Object, T>() {\n             @Override\n-            public T call(Notification<T> notification) {\n-                return notification.value;\n+            public T call(Object args) {\n+                return notification.getValue(args);\n             }\n         });\n     }\n \n-    private static class Notification<T> {\n-        private final boolean halt;\n-        private final T value;\n-\n-        public static <T> Notification<T> value(T value) {\n-            return new Notification<T>(false, value);\n-        }\n-\n-        public static <T> Notification<T> halt() {\n-            return new Notification<T>(true, null);\n-        }\n-\n-        private Notification(boolean halt, T value) {\n-            this.halt = halt;\n-            this.value = value;\n-        }\n+    private final static class SourceObservable<T> implements Operator<Object, T> {\n \n-    }\n-\n-    private static class SourceObservable<T> implements Operator<Notification<T>, T> {\n+        private final NotificationLite<T> notification = NotificationLite.instance();\n \n         @Override\n-        public Subscriber<? super T> call(final Subscriber<? super Notification<T>> notificationObserver) {\n-            return new Subscriber<T>(notificationObserver) {\n+        public Subscriber<? super T> call(final Subscriber<? super Object> subscriber) {\n+            return new Subscriber<T>(subscriber) {\n                 @Override\n                 public void onCompleted() {\n-                    notificationObserver.onNext(Notification.<T>halt());\n+                    subscriber.onNext(notification.completed());\n                 }\n \n                 @Override\n                 public void onError(Throwable e) {\n-                    notificationObserver.onError(e);\n+                    subscriber.onError(e);\n                 }\n \n                 @Override\n                 public void onNext(T args) {\n-                    notificationObserver.onNext(Notification.value(args));\n+                    subscriber.onNext(notification.next(args));\n                 }\n             };\n         }\n     }\n \n-    private static class OtherObservable<T, E> implements Operator<Notification<T>, E> {\n+    private final static class OtherObservable<E> implements Operator<Object, E> {\n+\n+        private final NotificationLite<E> notification = NotificationLite.instance();\n \n         @Override\n-        public Subscriber<? super E> call(final Subscriber<? super Notification<T>> notificationObserver) {\n-            return new Subscriber<E>(notificationObserver) {\n+        public Subscriber<? super E> call(final Subscriber<? super Object> subscriber) {\n+            return new Subscriber<E>(subscriber) {\n                 @Override\n                 public void onCompleted() {\n-                    notificationObserver.onNext(Notification.<T>halt());\n+                    subscriber.onNext(notification.completed());\n                 }\n \n                 @Override\n                 public void onError(Throwable e) {\n-                    notificationObserver.onError(e);\n+                    subscriber.onError(e);\n                 }\n \n                 @Override\n                 public void onNext(E args) {\n-                    notificationObserver.onNext(Notification.<T>halt());\n+                    subscriber.onNext(notification.completed());\n                 }\n             };\n         }",
    "output": "Use NotificationLite"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorTakeWhile.java b/rxjava-core/src/main/java/rx/operators/OperatorTakeWhile.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorTakeWhile.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorTakeWhile.java\n@@ -56,12 +56,14 @@ public void onNext(T args) {\n                     isSelected = predicate.call(args, counter++);\n                 } catch (Throwable e) {\n                     subscriber.onError(e);\n+                    unsubscribe();\n                     return;\n                 }\n                 if (isSelected) {\n                     subscriber.onNext(args);\n                 } else {\n                     subscriber.onCompleted();\n+                    unsubscribe();\n                 }\n             }\n ",
    "output": "Add unsubscribe"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n--- a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n+++ b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n@@ -235,19 +235,25 @@ protected static class SubjectObserver<T> implements Observer<T> {\n \n         private final Observer<? super T> actual;\n         protected volatile boolean caughtUp = false;\n-\n+        boolean once = true;\n         SubjectObserver(Observer<? super T> actual) {\n             this.actual = actual;\n         }\n \n         @Override\n         public void onCompleted() {\n-            this.actual.onCompleted();\n+            if (once) {\n+                once = false;\n+                this.actual.onCompleted();\n+            }\n         }\n \n         @Override\n         public void onError(Throwable e) {\n-            this.actual.onError(e);\n+            if (once) {\n+                once = false;\n+                this.actual.onError(e);\n+            }\n         }\n \n         @Override\n\ndiff --git a/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java b/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java\n--- a/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java\n+++ b/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java\n@@ -403,4 +403,38 @@ public void onCompleted() {\n             inOrder.verify(o).onCompleted();\n             verify(o, never()).onError(any(Throwable.class));\n         }\n-    }}\n+    }\n+    @Test\n+    public void testTerminateOnce() {\n+        ReplaySubject<Integer> source = ReplaySubject.create();\n+        source.onNext(1);\n+        source.onNext(2);\n+        source.onCompleted();\n+        \n+        @SuppressWarnings(\"unchecked\")\n+        final Observer<Integer> o = mock(Observer.class);\n+        \n+        source.unsafeSubscribe(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onNext(Integer t) {\n+                o.onNext(t);\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                o.onError(e);\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+                o.onCompleted();\n+            }\n+        });\n+        \n+        verify(o).onNext(1);\n+        verify(o).onNext(2);\n+        verify(o).onCompleted();\n+        verify(o, never()).onError(any(Throwable.class));\n+    }\n+}",
    "output": "Fix ReplaySubject's double termination problem"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperatorMergeDelayErrorTest.java b/rxjava-core/src/test/java/rx/operators/OperatorMergeDelayErrorTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorMergeDelayErrorTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorMergeDelayErrorTest.java\n@@ -457,10 +457,10 @@ public void testMergeSourceWhichDoesntPropagateExceptionBack() {\n             public void call(Subscriber<? super Integer> t1) {\n                 try {\n                     t1.onNext(0);\n-                    t1.onNext(1);\n                 } catch (Throwable swallow) {\n                     \n                 }\n+                t1.onNext(1);\n                 t1.onCompleted();\n             }\n         });",
    "output": "Fix last test case"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java\n--- a/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java\n+++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java\n@@ -1617,30 +1617,6 @@ public static <R> Observable<R> fromAction(Action0 action, R result) {\n         return fromAction(action, result, Schedulers.computation());\n     }\n     \n-    /**\n-     * Return an Observable that calls the given function and emits its\n-     * result when an Observer subscribes.\n-     * <p>\n-     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/fromFunc0.png\">\n-     * <p>\n-     * The function is called on the default thread pool for computation.\n-     * \n-     * @param <R> the return type\n-     * @param function the function to call on each subscription\n-     * @return an Observable that calls the given function and emits its\n-     *         result when an Observer subscribes\n-     * @see #start(rx.functions.Func0) \n-     * @see #fromCallable(java.util.concurrent.Callable) \n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Async-Operators#fromfunc0\">RxJava Wiki: fromFunc0()</a>\n-     *\n-     * @deprecated  Unnecessary now that Func0 extends Callable. Just call\n-     *              {@link #fromCallable(Callable)} instead.\n-     */\n-    @Deprecated\n-    public static <R> Observable<R> fromFunc0(Func0<? extends R> function) {\n-        return fromCallable(function);\n-    }\n-\n     /**\n      * Return an Observable that calls the given Callable and emits its\n      * result or Exception when an Observer subscribes.\n@@ -1654,7 +1630,6 @@ public static <R> Observable<R> fromFunc0(Func0<? extends R> function) {\n      * @return an Observable that calls the given Callable and emits its\n      *         result or Exception when an Observer subscribes\n      * @see #start(rx.functions.Func0) \n-     * @see #fromFunc0(rx.functions.Func0) \n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Async-Operators#fromcallable\">RxJava Wiki: fromCallable()</a>\n      */\n     public static <R> Observable<R> fromCallable(Callable<? extends R> callable) {\n@@ -1699,30 +1674,6 @@ public static <R> Observable<R> fromAction(Action0 action, R result, Scheduler s\n         return Observable.create(OperatorFromFunctionals.fromAction(action, result)).subscribeOn(scheduler);\n     }\n     \n-    /**\n-     * Return an Observable that calls the given function and emits its\n-     * result when an Observer subscribes.\n-     * <p>\n-     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/fromFunc0.s.png\">\n-     * \n-     * @param <R> the return type\n-     * @param function the function to call on each subscription\n-     * @param scheduler the scheduler where the function is called and the\n-     *                  result is emitted\n-     * @return an Observable that calls the given function and emits its\n-     *         result when an Observer subscribes\n-     * @see #start(rx.functions.Func0) \n-     * @see #fromCallable(java.util.concurrent.Callable) \n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Async-Operators#fromfunc0\">RxJava Wiki: fromFunc0()</a>\n-     *\n-     * @deprecated  Unnecessary now that Func0 extends Callable. Just call\n-     *              {@link #fromCallable(Callable, Scheduler)} instead.\n-     */\n-    @Deprecated\n-    public static <R> Observable<R> fromFunc0(Func0<? extends R> function, Scheduler scheduler) {\n-        return fromCallable(function, scheduler);\n-    }\n-\n     /**\n      * Return an Observable that calls the given Callable and emits its\n      * result or Exception when an Observer subscribes.\n@@ -1736,7 +1687,6 @@ public static <R> Observable<R> fromFunc0(Func0<? extends R> function, Scheduler\n      * @return an Observable that calls the given Callable and emits its\n      *         result or Exception when an Observer subscribes\n      * @see #start(rx.functions.Func0) \n-     * @see #fromFunc0(rx.functions.Func0) \n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Async-Operators#fromcallable\">RxJava Wiki: fromCallable()</a>\n      */\n     public static <R> Observable<R> fromCallable(Callable<? extends R> callable, Scheduler scheduler) {",
    "output": "Remove deprecated API"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperatorRetryTest.java b/rxjava-core/src/test/java/rx/operators/OperatorRetryTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorRetryTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorRetryTest.java\n@@ -18,6 +18,7 @@\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.fail;\n import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doThrow;\n import static org.mockito.Mockito.inOrder;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n@@ -30,6 +31,7 @@\n \n import org.junit.Test;\n import org.mockito.InOrder;\n+import org.mockito.Mockito;\n \n import rx.Observable;\n import rx.Observable.OnSubscribe;\n@@ -118,6 +120,50 @@ public void testInfiniteRetry() {\n         inOrder.verify(observer, times(1)).onCompleted();\n         inOrder.verifyNoMoreInteractions();\n     }\n+    \n+    /**\n+     * Checks in a simple and synchronous way that retry resubscribes\n+     * after error. This test fails against 0.16.1-0.17.4, hangs on 0.17.5 and\n+     * passes in 0.17.6 thanks to fix for issue #1027.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void testRetrySubscribesAgainAfterError() {\n+\n+        // record emitted values with this action\n+        Action1<Integer> record = mock(Action1.class);\n+        InOrder inOrder = inOrder(record);\n+\n+        // always throw an exception with this action\n+        Action1<Integer> throwException = mock(Action1.class);\n+        doThrow(new RuntimeException()).when(throwException).call(Mockito.anyInt());\n+        \n+        // create a retrying observable based on a PublishSubject\n+        PublishSubject<Integer> subject = PublishSubject.create();\n+        subject\n+        // record item\n+        .doOnNext(record)\n+        // throw a RuntimeException\n+                .doOnNext(throwException)\n+                // retry on error\n+                .retry()\n+                // subscribe and ignore\n+                .subscribe();\n+\n+        inOrder.verifyNoMoreInteractions();\n+\n+        subject.onNext(1);\n+        inOrder.verify(record).call(1);\n+\n+        subject.onNext(2);\n+        inOrder.verify(record).call(2);\n+\n+        subject.onNext(3);\n+        inOrder.verify(record).call(3);\n+\n+        inOrder.verifyNoMoreInteractions();\n+    }\n+\n \n     public static class FuncWithErrors implements Observable.OnSubscribe<String> {\n \n@@ -356,4 +402,5 @@ public void testTimeoutWithRetry() {\n \n         assertEquals(\"Start 6 threads, retry 5 then fail on 6\", 6, so.efforts.get());\n     }\n+    \n }",
    "output": "Add synchronous test of resubscribe after error"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/schedulers/Timestamped.java b/rxjava-core/src/main/java/rx/schedulers/Timestamped.java\n--- a/rxjava-core/src/main/java/rx/schedulers/Timestamped.java\n+++ b/rxjava-core/src/main/java/rx/schedulers/Timestamped.java\n@@ -50,6 +50,9 @@ public boolean equals(Object obj) {\n         if (this == obj) {\n             return true;\n         }\n+        if (obj == null) {\n+            return false;\n+        }\n         if (!(obj instanceof Timestamped)) {\n             return false;\n         }\n@@ -71,7 +74,7 @@ public boolean equals(Object obj) {\n     public int hashCode() {\n         final int prime = 31;\n         int result = 1;\n-        result = prime * result + (int) (timestampMillis ^ (timestampMillis));\n+        result = prime * result + (int) (timestampMillis ^ (timestampMillis >>> 32));\n         result = prime * result + ((value == null) ? 0 : value.hashCode());\n         return result;\n     }",
    "output": "Fix bugs in equals and hashCode"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n--- a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n+++ b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n@@ -94,7 +94,7 @@ public void call() {\n                         }));\n                         if (subscription.isUnsubscribed()) {\n                             addedObserver = false;\n-                            break;\n+                            return;\n                         }\n                         // on subscribe add it to the map of outbound observers to notify\n                         newState = current.addObserver(subscription, observer);",
    "output": "Fix NPE in SubjectSubscriptionManager"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -5367,17 +5367,6 @@ public final <R> Observable<R> parallel(final Func1<Observable<T>, Observable<R>\n         return lift(new OperatorParallel<T, R>(f, s));\n     }\n \n-    /**\n-     * Protects against errors being thrown from Observer implementations and ensures\n-     * onNext/onError/onCompleted contract compliance.\n-     * <p>\n-     * See https://github.com/Netflix/RxJava/issues/216 for a discussion on \"Guideline 6.4: Protect calls to\n-     * user code from within an Observer\"\n-     */\n-    private Subscription protectivelyWrapAndSubscribe(Subscriber<? super T> o) {\n-        return subscribe(new SafeSubscriber<T>(o));\n-    }\n-\n     /**\n      * Returns a {@link ConnectableObservable}, which waits until its {@link ConnectableObservable#connect connect} method is called before it begins emitting items to those {@link Observer}s that\n      * have subscribed to it.\n@@ -6704,7 +6693,7 @@ public final Observable<T> startWith(T[] values, Scheduler scheduler) {\n      *             if the Observable tries to call {@code onError}\n      */\n     public final Subscription subscribe() {\n-        return protectivelyWrapAndSubscribe(new Subscriber<T>() {\n+        return subscribe(new Subscriber<T>() {\n \n             @Override\n             public final void onCompleted() {\n@@ -6743,13 +6732,7 @@ public final Subscription subscribe(final Action1<? super T> onNext) {\n             throw new IllegalArgumentException(\"onNext can not be null\");\n         }\n \n-        /**\n-         * Wrapping since raw functions provided by the user are being invoked.\n-         * \n-         * See https://github.com/Netflix/RxJava/issues/216 for discussion on \"Guideline 6.4: Protect calls to\n-         * user code from within an Observer\"\n-         */\n-        return protectivelyWrapAndSubscribe(new Subscriber<T>() {\n+        return subscribe(new Subscriber<T>() {\n \n             @Override\n             public final void onCompleted() {\n@@ -6793,13 +6776,7 @@ public final Subscription subscribe(final Action1<? super T> onNext, final Actio\n             throw new IllegalArgumentException(\"onError can not be null\");\n         }\n \n-        /**\n-         * Wrapping since raw functions provided by the user are being invoked.\n-         * \n-         * See https://github.com/Netflix/RxJava/issues/216 for discussion on\n-         * \"Guideline 6.4: Protect calls to user code from within an Observer\"\n-         */\n-        return protectivelyWrapAndSubscribe(new Subscriber<T>() {\n+        return subscribe(new Subscriber<T>() {\n \n             @Override\n             public final void onCompleted() {\n@@ -6850,12 +6827,7 @@ public final Subscription subscribe(final Action1<? super T> onNext, final Actio\n             throw new IllegalArgumentException(\"onComplete can not be null\");\n         }\n \n-        /**\n-         * Wrapping since raw functions provided by the user are being invoked.\n-         * \n-         * See https://github.com/Netflix/RxJava/issues/216 for discussion on \"Guideline 6.4: Protect calls to user code from within an Observer\"\n-         */\n-        return protectivelyWrapAndSubscribe(new Subscriber<T>() {\n+        return subscribe(new Subscriber<T>() {\n \n             @Override\n             public final void onCompleted() {\n@@ -7011,7 +6983,7 @@ public final Subscription unsafeSubscribe(Subscriber<? super T> subscriber) {\n      * For more information see the\n      * <a href=\"https://github.com/Netflix/RxJava/wiki/Observable\">RxJava Wiki</a>\n      * \n-     * @param observer\n+     * @param subscriber\n      *            the {@link Subscriber}\n      * @return a {@link Subscription} reference with which Subscribers that are {@link Observer}s can\n      *         unsubscribe from the Observable\n@@ -7024,11 +6996,11 @@ public final Subscription unsafeSubscribe(Subscriber<? super T> subscriber) {\n      * @throws RuntimeException\n      *             if the {@link Subscriber}'s {@code onError} method itself threw a {@code Throwable}\n      */\n-    public final Subscription subscribe(Subscriber<? super T> observer) {\n+    public final Subscription subscribe(Subscriber<? super T> subscriber) {\n         // allow the hook to intercept and/or decorate\n         OnSubscribe<T> onSubscribeFunction = hook.onSubscribeStart(this, onSubscribe);\n         // validate and proceed\n-        if (observer == null) {\n+        if (subscriber == null) {\n             throw new IllegalArgumentException(\"observer can not be null\");\n         }\n         if (onSubscribeFunction == null) {\n@@ -7044,12 +7016,12 @@ public final Subscription subscribe(Subscriber<? super T> observer) {\n              * to user code from within an Observer\"\n              */\n             // if not already wrapped\n-            if (!(observer instanceof SafeSubscriber)) {\n+            if (!(subscriber instanceof SafeSubscriber)) {\n                 // assign to `observer` so we return the protected version\n-                observer = new SafeSubscriber<T>(observer);\n+                subscriber = new SafeSubscriber<T>(subscriber);\n             }\n-            onSubscribeFunction.call(observer);\n-            final Subscription returnSubscription = hook.onSubscribeReturn(observer);\n+            onSubscribeFunction.call(subscriber);\n+            final Subscription returnSubscription = hook.onSubscribeReturn(subscriber);\n             // we return it inside a Subscription so it can't be cast back to Subscriber\n             return Subscriptions.create(new Action0() {\n \n@@ -7064,7 +7036,7 @@ public void call() {\n             Exceptions.throwIfFatal(e);\n             // if an unhandled error occurs executing the onSubscribe we will propagate it\n             try {\n-                observer.onError(hook.onSubscribeError(e));\n+                subscriber.onError(hook.onSubscribeError(e));\n             } catch (OnErrorNotImplementedException e2) {\n                 // special handling when onError is not implemented ... we just rethrow\n                 throw e2;",
    "output": "Remove Redundant protectivelyWrap Method"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observers/SerializedObserver.java b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java\n--- a/rxjava-core/src/main/java/rx/observers/SerializedObserver.java\n+++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java\n@@ -128,6 +128,7 @@ public void onNext(T t) {\n         }\n \n         // we only get here if we won the right to emit, otherwise we returned in the if(emitting) block above\n+        boolean skipFinal = false;\n         try {\n             int iter = MAX_DRAIN_ITERATION;\n             do {\n@@ -141,27 +142,32 @@ public void onNext(T t) {\n                     synchronized (this) {\n                         list = queue;\n                         queue = null;\n-                    }\n-                    if (list == null) {\n-                        break;\n+                        if (list == null) {\n+                            emitting = false;\n+                            skipFinal = true;\n+                            return;\n+                        }\n                     }\n                 }\n             } while (iter > 0);\n         } finally {\n-            synchronized (this) {\n-                if (terminated) {\n-                    list = queue;\n-                    queue = null;\n-                } else {\n-                    emitting = false;\n-                    list = null;\n+            if (!skipFinal) {\n+                synchronized (this) {\n+                    if (terminated) {\n+                        list = queue;\n+                        queue = null;\n+                    } else {\n+                        emitting = false;\n+                        list = null;\n+                    }\n                 }\n             }\n-            // this will only drain if terminated (done here outside of synchronized block)\n-            drainQueue(list);\n         }\n+        \n+        // this will only drain if terminated (done here outside of synchronized block)\n+        drainQueue(list);\n     }\n-\n+    \n     void drainQueue(FastList list) {\n         if (list == null || list.size == 0) {\n             return;",
    "output": "Remove window between the two synchronized blocks"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java b/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java\n--- a/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java\n+++ b/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java\n@@ -284,7 +284,8 @@ public void runConcurrencyTest() {\n     public void testNotificationDelay() throws InterruptedException {\n         ExecutorService tp = Executors.newFixedThreadPool(2);\n \n-        final CountDownLatch onNextCount = new CountDownLatch(1);\n+        final CountDownLatch firstOnNext = new CountDownLatch(1);\n+        final CountDownLatch onNextCount = new CountDownLatch(2);\n         final CountDownLatch latch = new CountDownLatch(1);\n \n         TestSubscriber<String> to = new TestSubscriber<String>(new Observer<String>() {\n@@ -301,8 +302,7 @@ public void onError(Throwable e) {\n \n             @Override\n             public void onNext(String t) {\n-                // know when the first thread gets in\n-                onNextCount.countDown();\n+                firstOnNext.countDown();\n                 // force it to take time when delivering so the second one is enqueued\n                 try {\n                     latch.await();\n@@ -313,10 +313,10 @@ public void onNext(String t) {\n         });\n         Observer<String> o = serializedObserver(to);\n \n-        Future<?> f1 = tp.submit(new OnNextThread(o, 1));\n-        Future<?> f2 = tp.submit(new OnNextThread(o, 1));\n+        Future<?> f1 = tp.submit(new OnNextThread(o, 1, onNextCount));\n+        Future<?> f2 = tp.submit(new OnNextThread(o, 1, onNextCount));\n \n-        onNextCount.await();\n+        firstOnNext.await();\n \n         Thread t1 = to.getLastSeenThread();\n         System.out.println(\"first onNext on thread: \" + t1);\n@@ -431,14 +431,24 @@ public void call(Subscriber<? super String> s) {\n      */\n     public static class OnNextThread implements Runnable {\n \n+        private final CountDownLatch latch;\n         private final Observer<String> observer;\n         private final int numStringsToSend;\n         final AtomicInteger produced;\n \n+        OnNextThread(Observer<String> observer, int numStringsToSend, CountDownLatch latch) {\n+            this(observer, numStringsToSend, new AtomicInteger(), latch);\n+        }\n+\n         OnNextThread(Observer<String> observer, int numStringsToSend, AtomicInteger produced) {\n+            this(observer, numStringsToSend, produced, null);\n+        }\n+\n+        OnNextThread(Observer<String> observer, int numStringsToSend, AtomicInteger produced, CountDownLatch latch) {\n             this.observer = observer;\n             this.numStringsToSend = numStringsToSend;\n             this.produced = produced;\n+            this.latch = latch;\n         }\n \n         OnNextThread(Observer<String> observer, int numStringsToSend) {\n@@ -449,6 +459,9 @@ public static class OnNextThread implements Runnable {\n         public void run() {\n             for (int i = 0; i < numStringsToSend; i++) {\n                 observer.onNext(Thread.currentThread().getId() + \"-\" + i);\n+                if (latch != null) {\n+                    latch.countDown();\n+                }\n                 produced.incrementAndGet();\n             }\n         }",
    "output": "Fix unit test determinism"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragmentActivityV2.java b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragmentActivityV2.java\n--- a/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragmentActivityV2.java\n+++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragmentActivityV2.java\n@@ -0,0 +1,142 @@\n+package com.netflix.rxjava.android.samples;\n+\n+import android.app.Activity;\n+import android.app.Fragment;\n+import android.os.Bundle;\n+import android.view.LayoutInflater;\n+import android.view.View;\n+import android.view.ViewGroup;\n+import android.view.Window;\n+import android.widget.Button;\n+import android.widget.TextView;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import rx.Observable;\n+import rx.Subscription;\n+import rx.android.schedulers.AndroidSchedulers;\n+import rx.functions.Action1;\n+import rx.functions.Func1;\n+import rx.subscriptions.Subscriptions;\n+\n+/**\n+ * A retained fragment whose goals are below\n+ *\n+ * 1) gracefully handle rotation - not losing any data\n+ * 2) gracefully handle the user moving in and out of the app\n+ * 3) use a button or trigger of some sort to start the observable, something more in line with typical use\n+ * 4) ensure that the callbacks are not called if the user moves away from the fragment\n+ *\n+ * @author zsiegel (zsiegel87@gmail.com)\n+ */\n+public class RetainedFragmentActivityV2 extends Activity {\n+\n+    @Override\n+    protected void onCreate(Bundle savedInstanceState) {\n+        super.onCreate(savedInstanceState);\n+        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n+        setTitle(\"Fake API call V2\");\n+        setContentView(R.layout.retained_fragment_activity_v2);\n+    }\n+\n+    @SuppressWarnings(\"ConstantConditions\")\n+    public static class RetainedFragmentV2 extends Fragment {\n+\n+        private Observable<String> observable;\n+        private Subscription subscription = Subscriptions.empty();\n+        private Button startButton;\n+        private boolean progressVisiblity;\n+\n+        // in a production app, you don't want to have JSON parser code in your fragment,\n+        // but we'll simplify a little here\n+        private static final Func1<String, String> PARSE_JSON = new Func1<String, String>() {\n+            @Override\n+            public String call(String json) {\n+                try {\n+                    JSONObject jsonObject = new JSONObject(json);\n+                    return String.valueOf(jsonObject.getInt(\"result\"));\n+                } catch (JSONException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+\n+        public RetainedFragmentV2() {\n+            setRetainInstance(true);\n+        }\n+\n+        /**\n+         * We un-subscribe whenever we are paused\n+         */\n+        @Override\n+        public void onPause() {\n+            subscription.unsubscribe();\n+            super.onPause();\n+        }\n+\n+        /**\n+         * We re-subscribe whenever we are resumed\n+         */\n+        @Override\n+        public void onResume() {\n+            super.onResume();\n+            subscribe();\n+        }\n+\n+        @Override\n+        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n+            return inflater.inflate(R.layout.retained_fragment_v2, container, false);\n+        }\n+\n+        @Override\n+        public void onViewCreated(final View view, Bundle savedInstanceState) {\n+            super.onViewCreated(view, savedInstanceState);\n+\n+            final TextView textView = (TextView)getView().findViewById(android.R.id.text1);\n+\n+            startButton = (Button) view.findViewById(R.id.button);\n+            startButton.setOnClickListener(new View.OnClickListener() {\n+                @Override\n+                public void onClick(View v) {\n+                    textView.setText(\"\");\n+                    start();\n+                    startButton.setEnabled(false);\n+                }\n+            });\n+        }\n+\n+        private void start() {\n+\n+            progressVisiblity = true;\n+\n+            observable = SampleObservables\n+                    .fakeApiCall(5000)\n+                    .map(PARSE_JSON)\n+                    .observeOn(AndroidSchedulers.mainThread())\n+                    .cache();\n+\n+            subscribe();\n+        }\n+\n+        /**\n+         * We subscribe/re-subscribe here\n+         */\n+        private void subscribe() {\n+            if (observable != null) {\n+\n+                getActivity().setProgressBarIndeterminateVisibility(progressVisiblity);\n+\n+                final TextView textView = (TextView)getView().findViewById(android.R.id.text1);\n+\n+                subscription = observable.subscribe(new Action1<String>() {\n+                    @Override\n+                    public void call(String result) {\n+                        textView.setText(result);\n+                        progressVisiblity = false;\n+                        getActivity().setProgressBarIndeterminateVisibility(progressVisiblity);\n+                        startButton.setEnabled(true);\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}",
    "output": "Add a new RetainedFragment example"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java b/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java\n--- a/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java\n+++ b/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java\n@@ -17,6 +17,7 @@\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n import static org.mockito.Matchers.any;\n@@ -274,10 +275,18 @@ public void runConcurrencyTest() {\n         }\n     }\n \n+    /**\n+     * Test that a notification does not get delayed in the queue waiting for the next event to push it through.\n+     * \n+     * @throws InterruptedException\n+     */\n     @Test\n-    public void testNotificationDelay() {\n+    public void testNotificationDelay() throws InterruptedException {\n         ExecutorService tp = Executors.newFixedThreadPool(2);\n \n+        final CountDownLatch onNextCount = new CountDownLatch(1);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+\n         TestSubscriber<String> to = new TestSubscriber<String>(new Observer<String>() {\n \n             @Override\n@@ -292,12 +301,12 @@ public void onError(Throwable e) {\n \n             @Override\n             public void onNext(String t) {\n-                // force it to take time when delivering\n-                // so the second thread will asynchronously enqueue\n+                // know when the first thread gets in\n+                onNextCount.countDown();\n+                // force it to take time when delivering so the second one is enqueued\n                 try {\n-                    Thread.sleep(50);\n+                    latch.await();\n                 } catch (InterruptedException e) {\n-                    e.printStackTrace();\n                 }\n             }\n \n@@ -307,10 +316,23 @@ public void onNext(String t) {\n         Future<?> f1 = tp.submit(new OnNextThread(o, 1));\n         Future<?> f2 = tp.submit(new OnNextThread(o, 1));\n \n+        onNextCount.await();\n+\n+        Thread t1 = to.getLastSeenThread();\n+        System.out.println(\"first onNext on thread: \" + t1);\n+\n+        latch.countDown();\n+\n         waitOnThreads(f1, f2);\n         // not completed yet\n \n         assertEquals(2, to.getOnNextEvents().size());\n+\n+        Thread t2 = to.getLastSeenThread();\n+        System.out.println(\"second onNext on thread: \" + t2);\n+\n+        assertSame(t1, t2);\n+\n         System.out.println(to.getOnNextEvents());\n         o.onCompleted();\n         System.out.println(to.getOnNextEvents());",
    "output": "Use latches instead of sleep for unit test\n\nAs per suggestion at https://github.com/benjchristensen/RxJava/commit/5b317ad827f624bed6cbf5f2e04df050ebbe01d0#commitcomment-5839773"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observers/SerializedObserver.java b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java\n--- a/rxjava-core/src/main/java/rx/observers/SerializedObserver.java\n+++ b/rxjava-core/src/main/java/rx/observers/SerializedObserver.java\n@@ -21,7 +21,7 @@ public class SerializedObserver<T> implements Observer<T> {\n     private boolean terminated = false;\n     private FastList queue;\n \n-    private static final int MAX_DRAIN_ITERATION = 1;\n+    private static final int MAX_DRAIN_ITERATION = Integer.MAX_VALUE;\n     private static final Object NULL_SENTINEL = new Object();\n     private static final Object COMPLETE_SENTINEL = new Object();\n \n\ndiff --git a/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java b/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java\n--- a/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java\n+++ b/rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java\n@@ -15,9 +15,15 @@\n  */\n package rx.observers;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutorService;\n@@ -28,14 +34,17 @@\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Before;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n \n import rx.Observable;\n+import rx.Observable.OnSubscribe;\n import rx.Observer;\n import rx.Subscriber;\n import rx.Subscription;\n+import rx.schedulers.Schedulers;\n \n public class SerializedObserverTest {\n \n@@ -265,6 +274,111 @@ public void runConcurrencyTest() {\n         }\n     }\n \n+    @Test\n+    public void testNotificationDelay() {\n+        ExecutorService tp = Executors.newFixedThreadPool(2);\n+\n+        TestSubscriber<String> to = new TestSubscriber<String>(new Observer<String>() {\n+\n+            @Override\n+            public void onCompleted() {\n+\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+\n+            }\n+\n+            @Override\n+            public void onNext(String t) {\n+                // force it to take time when delivering\n+                // so the second thread will asynchronously enqueue\n+                try {\n+                    Thread.sleep(50);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+\n+        });\n+        Observer<String> o = serializedObserver(to);\n+\n+        Future<?> f1 = tp.submit(new OnNextThread(o, 1));\n+        Future<?> f2 = tp.submit(new OnNextThread(o, 1));\n+\n+        waitOnThreads(f1, f2);\n+        // not completed yet\n+\n+        assertEquals(2, to.getOnNextEvents().size());\n+        System.out.println(to.getOnNextEvents());\n+        o.onCompleted();\n+        System.out.println(to.getOnNextEvents());\n+    }\n+\n+    /**\n+     * Demonstrates thread starvation problem.\n+     * \n+     * No solution on this for now. Trade-off in this direction as per https://github.com/Netflix/RxJava/issues/998#issuecomment-38959474\n+     * Probably need backpressure for this to work\n+     * \n+     * When using SynchronizedObserver we get this output:\n+     * \n+     * p1: 18 p2: 68 => should be close to each other unless we have thread starvation\n+     * \n+     * When using SerializedObserver we get:\n+     * \n+     * p1: 1 p2: 2445261 => should be close to each other unless we have thread starvation\n+     * \n+     * This demonstrates how SynchronizedObserver balances back and forth better, and blocks emission.\n+     * The real issue in this example is the async buffer-bloat, so we need backpressure.\n+     * \n+     * \n+     * @throws InterruptedException\n+     */\n+    @Ignore\n+    @Test\n+    public void testThreadStarvation() throws InterruptedException {\n+\n+        TestSubscriber<String> to = new TestSubscriber<String>(new Observer<String>() {\n+\n+            @Override\n+            public void onCompleted() {\n+\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+\n+            }\n+\n+            @Override\n+            public void onNext(String t) {\n+                // force it to take time when delivering\n+                try {\n+                    Thread.sleep(1);\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+\n+        });\n+        Observer<String> o = serializedObserver(to);\n+\n+        AtomicInteger p1 = new AtomicInteger();\n+        AtomicInteger p2 = new AtomicInteger();\n+\n+        Subscription s1 = infinite(p1).subscribe(o);\n+        Subscription s2 = infinite(p2).subscribe(o);\n+\n+        Thread.sleep(100);\n+\n+        System.out.println(\"p1: \" + p1.get() + \" p2: \" + p2.get() + \" => should be close to each other unless we have thread starvation\");\n+        assertEquals(p1.get(), p2.get(), 10000); // fairly distributed within 10000 of each other\n+\n+        s1.unsubscribe();\n+        s2.unsubscribe();\n+    }\n+\n     private static void waitOnThreads(Future<?>... futures) {\n         for (Future<?> f : futures) {\n             try {\n@@ -276,23 +390,44 @@ private static void waitOnThreads(Future<?>... futures) {\n         }\n     }\n \n+    private static Observable<String> infinite(final AtomicInteger produced) {\n+        return Observable.create(new OnSubscribe<String>() {\n+\n+            @Override\n+            public void call(Subscriber<? super String> s) {\n+                while (!s.isUnsubscribed()) {\n+                    s.onNext(\"onNext\");\n+                    produced.incrementAndGet();\n+                }\n+            }\n+\n+        }).subscribeOn(Schedulers.newThread());\n+    }\n+\n     /**\n      * A thread that will pass data to onNext\n      */\n     public static class OnNextThread implements Runnable {\n \n-        private final Observer<String> Observer;\n+        private final Observer<String> observer;\n         private final int numStringsToSend;\n+        final AtomicInteger produced;\n \n-        OnNextThread(Observer<String> Observer, int numStringsToSend) {\n-            this.Observer = Observer;\n+        OnNextThread(Observer<String> observer, int numStringsToSend, AtomicInteger produced) {\n+            this.observer = observer;\n             this.numStringsToSend = numStringsToSend;\n+            this.produced = produced;\n+        }\n+\n+        OnNextThread(Observer<String> observer, int numStringsToSend) {\n+            this(observer, numStringsToSend, new AtomicInteger());\n         }\n \n         @Override\n         public void run() {\n             for (int i = 0; i < numStringsToSend; i++) {\n-                Observer.onNext(Thread.currentThread().getId() + \"-\" + i);\n+                observer.onNext(Thread.currentThread().getId() + \"-\" + i);\n+                produced.incrementAndGet();\n             }\n         }\n     }",
    "output": "Upgrade SerializedObserver to Not Allow Notification Delay Unit test showing delays. Fails when MAX_DRAIN_ITERATION set to 1, passes as currently configured. Added a thread starvation unit test and marked as ignored for now. Doesn't pass even with MAX_DRAIN_ITERATION set to 1. Probably needs backpressure solution"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperatorPivotTest.java b/rxjava-core/src/test/java/rx/operators/OperatorPivotTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorPivotTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorPivotTest.java\n@@ -287,8 +287,10 @@ private void setMaxConcurrency(final AtomicInteger maxOuterConcurrency, int oute\n         ts.awaitTerminalEvent();\n \n         System.out.println(\"onNext [\" + ts.getOnNextEvents().size() + \"]: \" + ts.getOnNextEvents());\n-        System.out.println(\"max outer concurrency: \" + maxOuterConcurrency.get());\n-        assertTrue(maxOuterConcurrency.get() > 2); // should be 4 since we have 4 threads running but setting at 3 as this is somewhat non-deterministic\n+        if (Runtime.getRuntime().availableProcessors() >= 4) {\n+            System.out.println(\"max outer concurrency: \" + maxOuterConcurrency.get());\n+            assertTrue(maxOuterConcurrency.get() > 1); // should be 4 since we have 4 threads and cores running but setting at just > 1 as this is non-deterministic\n+        }\n         System.out.println(\"max group concurrency: \" + maxGroupConcurrency.get());\n         assertTrue(maxGroupConcurrency.get() == 1); // should always be 1\n ",
    "output": "Fix Non-Deterministic Pivot Test\n\nThis failed on build servers (small, slow, single or dual-core machines)"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/observers/SynchronizedObserverTest.java b/rxjava-core/src/test/java/rx/observers/SynchronizedObserverTest.java\n--- a/rxjava-core/src/test/java/rx/observers/SynchronizedObserverTest.java\n+++ b/rxjava-core/src/test/java/rx/observers/SynchronizedObserverTest.java\n@@ -361,14 +361,14 @@ public void runConcurrencyTest() {\n \n             // 12000 + 5000 + 75000 + 13500 + 22000 + 15000 + 7500 + 23500 = 173500\n \n-            Future<?> f10 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onCompleted, f1, f2, f3, f4));\n+            Future<?> f10 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onCompleted, f1, f2, f3, f4, f5, f6, f7, f8));\n             try {\n                 Thread.sleep(1);\n             } catch (InterruptedException e) {\n                 // ignore\n             }\n \n-            waitOnThreads(f1, f2, f3, f4, f5, f6, f7, f8, f10);\n+            waitOnThreads(f10);\n             @SuppressWarnings(\"unused\")\n             int numNextEvents = tw.assertEvents(null); // no check of type since we don't want to test barging results here, just interleaving behavior\n             assertEquals(173500, numNextEvents);",
    "output": "Fix SynchronizedObserver.runConcurrencyTest\n\nIt wasn't waiting on all threads before emitting onCompleted"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorSingle.java b/rxjava-core/src/main/java/rx/operators/OperatorSingle.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorSingle.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorSingle.java\n@@ -49,12 +49,12 @@ public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {\n \n             private T value;\n             private boolean isNonEmpty = false;\n-            private boolean hasTooManyElemenets = false;\n+            private boolean hasTooManyElements = false;\n \n             @Override\n             public void onNext(T value) {\n                 if (isNonEmpty) {\n-                    hasTooManyElemenets = true;\n+                    hasTooManyElements = true;\n                     subscriber.onError(new IllegalArgumentException(\"Sequence contains too many elements\"));\n                 } else {\n                     this.value = value;\n@@ -64,8 +64,8 @@ public void onNext(T value) {\n \n             @Override\n             public void onCompleted() {\n-                if (hasTooManyElemenets) {\n-                    // We has already sent an onError message\n+                if (hasTooManyElements) {\n+                    // We have already sent an onError message\n                 } else {\n                     if (isNonEmpty) {\n                         subscriber.onNext(value);",
    "output": "Fix typos"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/observers/TestSubscriberTest.java b/rxjava-core/src/test/java/rx/observers/TestSubscriberTest.java\n--- a/rxjava-core/src/test/java/rx/observers/TestSubscriberTest.java\n+++ b/rxjava-core/src/test/java/rx/observers/TestSubscriberTest.java\n@@ -66,7 +66,8 @@ public void testAssertNotMatchValue() {\n         oi.subscribe(o);\n \n         thrown.expect(AssertionError.class);\n-        thrown.expectMessage(\"Value at index: 1 expected to be [3] but was: [2]\");\n+        thrown.expectMessage(\"Value at index: 1 expected to be [3] (Integer) but was: [2] (Integer)\");\n+\n \n         o.assertReceivedOnNext(Arrays.asList(1, 3));\n         assertEquals(2, o.getOnNextEvents().size());",
    "output": "Fix Unit Test Assertion"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-math/src/test/java/rx/math/operators/OperationMinMaxTest.java b/rxjava-contrib/rxjava-math/src/test/java/rx/math/operators/OperationMinMaxTest.java\n--- a/rxjava-contrib/rxjava-math/src/test/java/rx/math/operators/OperationMinMaxTest.java\n+++ b/rxjava-contrib/rxjava-math/src/test/java/rx/math/operators/OperationMinMaxTest.java\n@@ -23,6 +23,7 @@\n import java.util.Arrays;\n import java.util.Comparator;\n import java.util.List;\n+import java.util.NoSuchElementException;\n \n import org.junit.Test;\n import org.mockito.InOrder;\n@@ -56,7 +57,7 @@ public void testMinWithEmpty() {\n         observable.subscribe(observer);\n         InOrder inOrder = inOrder(observer);\n         inOrder.verify(observer, times(1)).onError(\n-                isA(IllegalArgumentException.class));\n+                isA(NoSuchElementException.class));\n         inOrder.verifyNoMoreInteractions();\n     }\n \n@@ -96,7 +97,7 @@ public int compare(Integer o1, Integer o2) {\n         observable.subscribe(observer);\n         InOrder inOrder = inOrder(observer);\n         inOrder.verify(observer, times(1)).onError(\n-                isA(IllegalArgumentException.class));\n+                isA(NoSuchElementException.class));\n         inOrder.verifyNoMoreInteractions();\n     }\n \n@@ -216,7 +217,7 @@ public void testMaxWithEmpty() {\n         observable.subscribe(observer);\n         InOrder inOrder = inOrder(observer);\n         inOrder.verify(observer, times(1)).onError(\n-                isA(IllegalArgumentException.class));\n+                isA(NoSuchElementException.class));\n         inOrder.verifyNoMoreInteractions();\n     }\n \n@@ -256,7 +257,7 @@ public int compare(Integer o1, Integer o2) {\n         observable.subscribe(observer);\n         InOrder inOrder = inOrder(observer);\n         inOrder.verify(observer, times(1)).onError(\n-                isA(IllegalArgumentException.class));\n+                isA(NoSuchElementException.class));\n         inOrder.verifyNoMoreInteractions();\n     }\n ",
    "output": "Fix tests in rxjava-math"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListFragmentActivity.java b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListFragmentActivity.java\n--- a/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListFragmentActivity.java\n+++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListFragmentActivity.java\n@@ -0,0 +1,75 @@\n+package com.netflix.rxjava.android.samples;\n+\n+import android.app.Activity;\n+import android.app.ListFragment;\n+import android.os.Bundle;\n+import android.widget.ArrayAdapter;\n+\n+import rx.Observable;\n+import rx.Subscriber;\n+\n+import static rx.android.schedulers.AndroidSchedulers.mainThread;\n+\n+/**\n+ * Problem:\n+ * You have an asynchronous sequence that emits items to be displayed in a list. You want the data\n+ * to survive rotation changes.\n+ * <p/>\n+ * Solution:\n+ * Combine {@link android.app.Fragment#setRetainInstance(boolean)} in a ListFragment with\n+ * {@link rx.android.schedulers.AndroidSchedulers#mainThread()} and an {@link rx.Observable.Operator}\n+ * that binds to the list adapter.\n+ */\n+public class ListFragmentActivity extends Activity {\n+\n+    @Override\n+    protected void onCreate(Bundle savedInstanceState) {\n+        super.onCreate(savedInstanceState);\n+        setTitle(\"Lists\");\n+        setContentView(R.layout.list_fragment_activity);\n+    }\n+\n+    @SuppressWarnings(\"ConstantConditions\")\n+    public static class RetainedListFragment extends ListFragment {\n+\n+        private ArrayAdapter<String> adapter;\n+\n+        public RetainedListFragment() {\n+            setRetainInstance(true);\n+        }\n+\n+        @Override\n+        public void onCreate(Bundle savedInstanceState) {\n+            super.onCreate(savedInstanceState);\n+\n+            adapter = new ArrayAdapter<String>(getActivity(), android.R.layout.simple_list_item_1);\n+            setListAdapter(adapter);\n+            SampleObservables.numberStrings(1, 20, 250)\n+                    .observeOn(mainThread())\n+                    .lift(new BindAdapter())\n+                    .subscribe();\n+        }\n+\n+        private final class BindAdapter implements Observable.Operator<String, String> {\n+            @Override\n+            public Subscriber<? super String> call(Subscriber<? super String> subscriber) {\n+                return new Subscriber<String>() {\n+                    @Override\n+                    public void onCompleted() {\n+                        adapter.notifyDataSetChanged();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable throwable) {\n+\n+                    }\n+\n+                    @Override\n+                    public void onNext(String strings) {\n+                        adapter.add(strings);\n+                    }\n+                };\n+            }\n+        }\n+    }\n+}",
    "output": "Add sample for binding to list adapters in ListFragment"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java\n--- a/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java\n+++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java\n@@ -0,0 +1,96 @@\n+package com.netflix.rxjava.android.samples;\n+\n+import android.app.Activity;\n+import android.app.Fragment;\n+import android.os.Bundle;\n+import android.view.LayoutInflater;\n+import android.view.View;\n+import android.view.ViewGroup;\n+import android.widget.TextView;\n+import android.widget.Toast;\n+\n+import rx.Subscriber;\n+import rx.Subscription;\n+import rx.observables.ConnectableObservable;\n+import rx.subscriptions.Subscriptions;\n+\n+import static rx.android.schedulers.AndroidSchedulers.mainThread;\n+\n+/**\n+ * Problem:\n+ * You have a background sequence which keeps emitting items (either a limited or unlimited number)\n+ * and your UI component should be able to \"listen in\" to the sequence, i.e. it's okay to miss\n+ * in-flight items when going e.g. through a screen rotation or being otherwise detached from the\n+ * screen for a limited period of time. (Another example is a \"page out\" in a fragment ViewPager.)\n+ * <p/>\n+ * This is useful if you need behavior that mimics event buses. Think of a publishing\n+ * Observable as a channel or queue on an event bus.\n+ * <p/>\n+ * Solution:\n+ * Combine {@link android.app.Fragment#setRetainInstance(boolean)} with\n+ * {@link rx.android.schedulers.AndroidSchedulers#mainThread()} and {@link rx.Observable#publish()}\n+ */\n+public class ListeningFragmentActivity extends Activity {\n+\n+    @Override\n+    protected void onCreate(Bundle savedInstanceState) {\n+        super.onCreate(savedInstanceState);\n+        setContentView(R.layout.listening_fragment_activity);\n+    }\n+\n+    @SuppressWarnings(\"ConstantConditions\")\n+    public static class ListeningFragment extends Fragment {\n+\n+        private ConnectableObservable<String> strings;\n+        private Subscription subscription = Subscriptions.empty();\n+\n+        public ListeningFragment() {\n+            setRetainInstance(true);\n+        }\n+\n+        @Override\n+        public void onCreate(Bundle savedInstanceState) {\n+            super.onCreate(savedInstanceState);\n+\n+            strings = SampleObservables.numberStrings(1, 50, 250).observeOn(mainThread()).publish();\n+            strings.connect(); // trigger the sequence\n+        }\n+\n+        @Override\n+        public void onDestroyView() {\n+            subscription.unsubscribe(); // stop listening\n+            super.onDestroyView();\n+        }\n+\n+        @Override\n+        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n+            return inflater.inflate(R.layout.retained_fragment, container, false);\n+        }\n+\n+        @Override\n+        public void onViewCreated(final View view, Bundle savedInstanceState) {\n+            super.onViewCreated(view, savedInstanceState);\n+\n+            final TextView textView = (TextView) view.findViewById(android.R.id.text1);\n+\n+            // re-connect to sequence\n+            subscription = strings.subscribe(new Subscriber<String>() {\n+\n+                @Override\n+                public void onCompleted() {\n+                    Toast.makeText(getActivity(), \"Done!\", Toast.LENGTH_SHORT).show();\n+                }\n+\n+                @Override\n+                public void onError(Throwable throwable) {\n+\n+                }\n+\n+                @Override\n+                public void onNext(String s) {\n+                    textView.setText(s);\n+                }\n+            });\n+        }\n+    }\n+}",
    "output": "Add sample for fragments and connectable observables"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java b/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java\n--- a/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java\n+++ b/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java\n@@ -247,7 +247,9 @@ public void testFromReader() {\n \n     @Test\n     public void testByLine() {\n-        List<Line> lines = StringObservable.byLine(Observable.from(Arrays.asList(\"qwer\", \"\\nasdf\\n\", \"zx\", \"cv\"))).toList().toBlockingObservable().single();\n+        String newLine = System.getProperty(\"line.separator\");\n+        \n+        List<Line> lines = StringObservable.byLine(Observable.from(Arrays.asList(\"qwer\", newLine + \"asdf\" + newLine, \"zx\", \"cv\"))).toList().toBlockingObservable().single();\n \n         assertEquals(Arrays.asList(new Line(0, \"qwer\"), new Line(1, \"asdf\"), new Line(2, \"zxcv\")), lines);\n     }",
    "output": "Fix byLine test to use line.separator system property instead of \\n"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n@@ -82,7 +82,7 @@ public void call(SubjectObserver<? super T> o) {\n                         // to send onCompleted if the last value is an onNext\n                         emitValueToObserver(lastNotification.get(), o);\n                     }\n-                });\n+                }, null);\n \n         return new AsyncSubject<T>(onSubscribe, subscriptionManager, lastNotification);\n     }\n\ndiff --git a/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java\n@@ -128,7 +128,7 @@ public void call(SubjectObserver<? super T> o) {\n                          */\n                         lastNotification.get().accept(o);\n                     }\n-                });\n+                }, null);\n \n         return new BehaviorSubject<T>(onSubscribe, subscriptionManager, lastNotification);\n     }\n\ndiff --git a/rxjava-core/src/main/java/rx/subjects/PublishSubject.java b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n@@ -79,7 +79,7 @@ public void call(SubjectObserver<? super T> o) {\n                          */\n                         lastNotification.get().accept(o);\n                     }\n-                });\n+                }, null);\n \n         return new PublishSubject<T>(onSubscribe, subscriptionManager, lastNotification);\n     }\n\ndiff --git a/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java b/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n@@ -84,8 +84,15 @@ public void call(SubjectObserver<? super T> o) {\n \n                     @Override\n                     public void call(SubjectObserver<? super T> o) {\n+                        Integer idx = state.replayState.remove(o);\n                         // we will finish replaying if there is anything left\n-                        replayObserverFromIndex(state.history, state.replayState.get(o), o);\n+                        replayObserverFromIndex(state.history, idx, o);\n+                    }\n+                }, \n+                new Action1<SubjectObserver<? super T>>() {\n+                    @Override\n+                    public void call(SubjectObserver<? super T> o) {\n+                        state.replayState.remove(o);\n                     }\n                 });\n \n@@ -229,5 +236,10 @@ public void complete(Notification<T> n) {\n             terminalValue.set(n);\n         }\n     }\n-\n+    /**\n+     * @return Returns the number of subscribers.\n+     */\n+    /* Support test.*/ int subscriberCount() {\n+        return state.replayState.size();\n+    }\n }\n\\ No newline at end of file\n\ndiff --git a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n--- a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n+++ b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n@@ -39,13 +39,16 @@\n      *            Always runs at the beginning of 'subscribe' regardless of terminal state.\n      * @param onTerminated\n      *            Only runs if Subject is in terminal state and the Observer ends up not being registered.\n+     * @param onUnsubscribe called after the child subscription is removed from the state\n      * @return\n      */\n-    public OnSubscribe<T> getOnSubscribeFunc(final Action1<SubjectObserver<? super T>> onSubscribe, final Action1<SubjectObserver<? super T>> onTerminated) {\n+    public OnSubscribe<T> getOnSubscribeFunc(final Action1<SubjectObserver<? super T>> onSubscribe, \n+            final Action1<SubjectObserver<? super T>> onTerminated,\n+            final Action1<SubjectObserver<? super T>> onUnsubscribe) {\n         return new OnSubscribe<T>() {\n             @Override\n             public void call(Subscriber<? super T> actualOperator) {\n-                SubjectObserver<T> observer = new SubjectObserver<T>(actualOperator);\n+                final SubjectObserver<T> observer = new SubjectObserver<T>(actualOperator);\n                 // invoke onSubscribe logic \n                 if (onSubscribe != null) {\n                     onSubscribe.call(observer);\n@@ -84,6 +87,9 @@ public void call() {\n                                     // on unsubscribe remove it from the map of outbound observers to notify\n                                     newState = current.removeObserver(subscription);\n                                 } while (!state.compareAndSet(current, newState));\n+                                if (onUnsubscribe != null) {\n+                                    onUnsubscribe.call(observer);\n+                                }\n                             }\n                         }));\n \n\ndiff --git a/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java b/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java\n--- a/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java\n+++ b/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java\n@@ -344,5 +344,16 @@ public void onNext(String v) {\n         assertEquals(\"three\", lastValueForObserver2.get());\n \n     }\n+    @Test\n+    public void testSubscriptionLeak() {\n+        ReplaySubject<Object> replaySubject = ReplaySubject.create();\n+        \n+        Subscription s = replaySubject.subscribe();\n+\n+        assertEquals(1, replaySubject.subscriberCount());\n \n+        s.unsubscribe();\n+        \n+        assertEquals(0, replaySubject.subscriberCount());\n+    }\n }",
    "output": "Fix ReplaySubject leak"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperatorObserveOnTest.java b/rxjava-core/src/test/java/rx/operators/OperatorObserveOnTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorObserveOnTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorObserveOnTest.java\n@@ -309,16 +309,17 @@ public void call(Integer t1) {\n     @Test\n     public void testNonBlockingOuterWhileBlockingOnNext() throws InterruptedException {\n \n-        final CountDownLatch latch = new CountDownLatch(1);\n+        final CountDownLatch completedLatch = new CountDownLatch(1);\n+        final CountDownLatch nextLatch = new CountDownLatch(1);\n         final AtomicLong completeTime = new AtomicLong();\n         // use subscribeOn to make async, observeOn to move\n-        Observable.range(1, 1000).subscribeOn(Schedulers.newThread()).observeOn(Schedulers.newThread()).subscribe(new Observer<Integer>() {\n+        Observable.range(1, 2).subscribeOn(Schedulers.newThread()).observeOn(Schedulers.newThread()).subscribe(new Observer<Integer>() {\n \n             @Override\n             public void onCompleted() {\n                 System.out.println(\"onCompleted\");\n                 completeTime.set(System.nanoTime());\n-                latch.countDown();\n+                completedLatch.countDown();\n             }\n \n             @Override\n@@ -328,20 +329,27 @@ public void onError(Throwable e) {\n \n             @Override\n             public void onNext(Integer t) {\n-\n+                // don't let this thing finish yet\n+                try {\n+                    if (!nextLatch.await(1000, TimeUnit.MILLISECONDS)) {\n+                        throw new RuntimeException(\"it shouldn't have timed out\");\n+                    }\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(\"it shouldn't have failed\");\n+                }\n             }\n \n         });\n \n         long afterSubscribeTime = System.nanoTime();\n-        System.out.println(\"After subscribe: \" + latch.getCount());\n-        assertEquals(1, latch.getCount());\n-        latch.await();\n+        System.out.println(\"After subscribe: \" + completedLatch.getCount());\n+        assertEquals(1, completedLatch.getCount());\n+        nextLatch.countDown();\n+        completedLatch.await(1000, TimeUnit.MILLISECONDS);\n         assertTrue(completeTime.get() > afterSubscribeTime);\n         System.out.println(\"onComplete nanos after subscribe: \" + (completeTime.get() - afterSubscribeTime));\n     }\n \n-\n     private static int randomIntFrom0to100() {\n         // XORShift instead of Math.random http://javamex.com/tutorials/random_numbers/xorshift.shtml\n         long x = System.nanoTime();",
    "output": "Make OperatorObserveOnTest.testNonBlockingOuterWhileBlockingOnNext deterministic\n\nreported at https://twitter.com/jaceklaskowski/status/443153927069249536"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorAmb.java b/rxjava-core/src/main/java/rx/operators/OperatorAmb.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorAmb.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorAmb.java\n@@ -158,10 +158,11 @@ public void onError(Throwable e) {\n         }\n \n         private boolean isSelected() {\n-            if (choice.get() == NONE) {\n+            int ch = choice.get();\n+            if (ch == NONE) {\n                 return choice.compareAndSet(NONE, index);\n             }\n-            return choice.get() == index;\n+            return ch == index;\n         }\n     }\n ",
    "output": "Change to a single 'get' call"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java b/rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java\n--- a/rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java\n+++ b/rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java\n@@ -35,7 +35,7 @@ public static <T, C> DebugNotification<T> createSubscribe(Observer<? super T> o,\n             o = ds.getActual();\n         }\n         if (sourceFunc instanceof DebugHook.DebugOnSubscribe) {\n-            sourceFunc = ((DebugHook<C>.DebugOnSubscribe<T>) sourceFunc).getActual();\n+            sourceFunc = (OnSubscribe<T>) ((SafeSubscriber) sourceFunc).getActual();\n         }\n         return new DebugNotification<T>(o, from, Kind.Subscribe, null, null, to, source, sourceFunc);\n     }",
    "output": "Change line 38 to try and fix build Odd Jenkins build failures even though command-line build works fine: ``` :rxjava:rxjava-contrib:rxjava-debug:compileJava/mnt/builds/slave/workspace/OSS-RxJava-release/rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java:38: ')' expected sourceFunc = ((DebugHook<C>.DebugOnSubscribe<T>) sourceFunc).getActual(); ^ /mnt/builds/slave/workspace/OSS-RxJava-release/rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java:38: ')' expected sourceFunc = ((DebugHook<C>.DebugOnSubscribe<T>) sourceFunc).getActual(); ^ /mnt/builds/slave/workspace/OSS-RxJava-release/rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java:38: illegal start of expression sourceFunc = ((DebugHook<C>.DebugOnSubscribe<T>) sourceFunc).getActual(); ^ /mnt/builds/slave/workspace/OSS-RxJava-release/rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java:38: not a statement sourceFunc = ((DebugHook<C>.DebugOnSubscribe<T>) sourceFunc).getActual(); ^ /mnt/builds/slave/workspace/OSS-RxJava-release/rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java:38: ';' expected sourceFunc = ((DebugHook<C>.DebugOnSubscribe<T>) sourceFunc).getActual(); ^ 5 errors FAILED ```"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorSkip.java b/rxjava-core/src/main/java/rx/operators/OperatorSkip.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorSkip.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorSkip.java\n@@ -14,7 +14,7 @@\n  */\n public final class OperatorSkip<T> implements Observable.Operator<T, T> {\n \n-    int n;\n+    final int n;\n \n     public OperatorSkip(int n) {\n         this.n = n;\n@@ -24,6 +24,8 @@ public OperatorSkip(int n) {\n     public Subscriber<? super T> call(final Subscriber<? super T> child) {\n         return new Subscriber<T>(child) {\n \n+           int skipped = 0;\n+\n             @Override\n             public void onCompleted() {\n                 child.onCompleted();\n@@ -36,10 +38,10 @@ public void onError(Throwable e) {\n \n             @Override\n             public void onNext(T t) {\n-                if(n <= 0) {\n+                if(skipped >= n) {\n                     child.onNext(t);\n                 } else {\n-                    n -= 1;\n+                    skipped += 1;\n                 }\n             }\n \n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperatorSkipTest.java b/rxjava-core/src/test/java/rx/operators/OperatorSkipTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorSkipTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorSkipTest.java\n@@ -9,24 +9,39 @@\n public class OperatorSkipTest {\n \n     @Test\n-    public void testSkip1() {\n-        Observable<String> w = Observable.from(\"one\", \"two\", \"three\");\n-        Observable<String> skip = w.lift(new OperatorSkip<String>(2));\n+    public void testSkipNegativeElements() {\n+\n+        Observable<String> skip = Observable.from(\"one\", \"two\", \"three\").lift(new OperatorSkip<String>(-99));\n \n         @SuppressWarnings(\"unchecked\")\n         Observer<String> observer = mock(Observer.class);\n         skip.subscribe(observer);\n-        verify(observer, never()).onNext(\"one\");\n-        verify(observer, never()).onNext(\"two\");\n+        verify(observer, times(1)).onNext(\"one\");\n+        verify(observer, times(1)).onNext(\"two\");\n         verify(observer, times(1)).onNext(\"three\");\n         verify(observer, never()).onError(any(Throwable.class));\n         verify(observer, times(1)).onCompleted();\n     }\n \n     @Test\n-    public void testSkip2() {\n-        Observable<String> w = Observable.from(\"one\", \"two\", \"three\");\n-        Observable<String> skip = w.lift(new OperatorSkip<String>(1));\n+    public void testSkipZeroElements() {\n+\n+        Observable<String> skip = Observable.from(\"one\", \"two\", \"three\").lift(new OperatorSkip<String>(0));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer = mock(Observer.class);\n+        skip.subscribe(observer);\n+        verify(observer, times(1)).onNext(\"one\");\n+        verify(observer, times(1)).onNext(\"two\");\n+        verify(observer, times(1)).onNext(\"three\");\n+        verify(observer, never()).onError(any(Throwable.class));\n+        verify(observer, times(1)).onCompleted();\n+    }\n+\n+    @Test\n+    public void testSkipOneElement() {\n+\n+        Observable<String> skip = Observable.from(\"one\", \"two\", \"three\").lift(new OperatorSkip<String>(1));\n \n         @SuppressWarnings(\"unchecked\")\n         Observer<String> observer = mock(Observer.class);\n@@ -37,4 +52,75 @@ public void testSkip2() {\n         verify(observer, never()).onError(any(Throwable.class));\n         verify(observer, times(1)).onCompleted();\n     }\n+\n+    @Test\n+    public void testSkipTwoElements() {\n+\n+        Observable<String> skip = Observable.from(\"one\", \"two\", \"three\").lift(new OperatorSkip<String>(2));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer = mock(Observer.class);\n+        skip.subscribe(observer);\n+        verify(observer, never()).onNext(\"one\");\n+        verify(observer, never()).onNext(\"two\");\n+        verify(observer, times(1)).onNext(\"three\");\n+        verify(observer, never()).onError(any(Throwable.class));\n+        verify(observer, times(1)).onCompleted();\n+    }\n+\n+    @Test\n+    public void testSkipEmptyStream() {\n+\n+        Observable<String> w = Observable.empty();\n+        Observable<String> skip = w.lift(new OperatorSkip<String>(1));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer = mock(Observer.class);\n+        skip.subscribe(observer);\n+        verify(observer, never()).onNext(any(String.class));\n+        verify(observer, never()).onError(any(Throwable.class));\n+        verify(observer, times(1)).onCompleted();\n+    }\n+\n+    @Test\n+    public void testSkipMultipleObservers() {\n+\n+        Observable<String> skip = Observable.from(\"one\", \"two\", \"three\").lift(new OperatorSkip<String>(2));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer1 = mock(Observer.class);\n+        skip.subscribe(observer1);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer2 = mock(Observer.class);\n+        skip.subscribe(observer2);\n+\n+        verify(observer1, times(1)).onNext(any(String.class));\n+        verify(observer1, never()).onError(any(Throwable.class));\n+        verify(observer1, times(1)).onCompleted();\n+\n+        verify(observer2, times(1)).onNext(any(String.class));\n+        verify(observer2, never()).onError(any(Throwable.class));\n+        verify(observer2, times(1)).onCompleted();\n+    }\n+\n+    @Test\n+    public void testSkipError() {\n+\n+        Exception e = new Exception();\n+\n+        Observable<String> ok = Observable.from(\"one\");\n+        Observable<String> error = Observable.error(e);\n+\n+        Observable<String> skip = Observable.concat(ok, error).lift(new OperatorSkip<String>(100));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer = mock(Observer.class);\n+        skip.subscribe(observer);\n+\n+        verify(observer, never()).onNext(any(String.class));\n+        verify(observer, times(1)).onError(e);\n+        verify(observer, never()).onCompleted();\n+\n+    }\n }",
    "output": "Fix state capture bug. Added some additional tests"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragment.java b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragment.java\n--- a/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragment.java\n+++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragment.java\n@@ -36,7 +36,7 @@ public RetainedFragment() {\n     public void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        strings = SampleObservables.numberStrings2().cache();\n+        strings = SampleObservables.numberStrings().cache();\n     }\n \n     @Override",
    "output": "Fix project import issue in Android Studio and a compilation failure"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -6431,6 +6431,22 @@ public final Observable<T> skipWhileWithIndex(Func2<? super T, Integer, Boolean>\n         return create(OperationSkipWhile.skipWhileWithIndex(this, predicate));\n     }\n \n+    /**\n+     * Returns an Observable that emits the items in a specified {@link Observable} before it begins to emit items\n+     * emitted by the source Observable.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png\">\n+     * \n+     * @param values\n+     *            an Observable that contains the items you want the modified Observable to emit first\n+     * @return an Observable that emits the items in the specified {@link Observable} and then emits the items\n+     *         emitted by the source Observable\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Combining-Observables#wiki-startwith\">RxJava Wiki: startWith()</a>\n+     */\n+    public final Observable<T> startWith(Observable<T> values) {\n+        return concat(values, this);\n+    }\n+\n     /**\n      * Returns an Observable that emits the items in a specified {@link Iterable} before it begins to emit items\n      * emitted by the source Observable.\n\ndiff --git a/rxjava-core/src/test/java/rx/StartWithTests.java b/rxjava-core/src/test/java/rx/StartWithTests.java\n--- a/rxjava-core/src/test/java/rx/StartWithTests.java\n+++ b/rxjava-core/src/test/java/rx/StartWithTests.java\n@@ -45,4 +45,17 @@ public void startWithIterable() {\n         assertEquals(\"two\", values.get(3));\n     }\n \n+\t@Test\n+    public void startWithObservable() {\n+        List<String> li = new ArrayList<String>();\n+        li.add(\"alpha\");\n+        li.add(\"beta\");\n+        List<String> values = Observable.from(\"one\", \"two\").startWith(Observable.from(li)).toList().toBlockingObservable().single();\n+\n+        assertEquals(\"alpha\", values.get(0));\n+        assertEquals(\"beta\", values.get(1));\n+        assertEquals(\"one\", values.get(2));\n+        assertEquals(\"two\", values.get(3));\n+    }\n+\n }",
    "output": "Add Observable.startWith(Observable) method and unit test to avoid breaking method chaining when want to startWith an Observable rather than just an Iterator or specific values"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOnBounded.java b/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOnBounded.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOnBounded.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOnBounded.java\n@@ -88,14 +88,13 @@ public void onNext(final Observable<T> o) {\n                 if (checkNeedBuffer(o)) {\n                     // use buffering (possibly blocking) for a possibly synchronous subscribe\n                     final BufferUntilSubscriber<T> bus = new BufferUntilSubscriber<T>(bufferSize, subscriber);\n-                    o.subscribe(bus);\n                     subscriber.add(scheduler.schedule(new Action1<Inner>() {\n                         @Override\n                         public void call(final Inner inner) {\n                             bus.enterPassthroughMode();\n                         }\n                     }));\n-                    return;\n+                    o.subscribe(bus);\n                 } else {\n                     // no buffering (async subscribe)\n                     subscriber.add(scheduler.schedule(new Action1<Inner>() {\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnBoundedTest.java b/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnBoundedTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnBoundedTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnBoundedTest.java\n@@ -399,5 +399,18 @@ public void call(Subscriber<? super Integer> sub) {\n         ts.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n         assertEquals(10, count.get());\n     }\n-\n+    @Test(timeout = 2000)\n+    public void testNoDeadlock() {\n+        List<Integer> data = Arrays.asList(1, 2, 3, 4, 5);\n+        Observable<Integer> source = Observable.from(data);\n+        \n+        Observable<Integer> result = source.nest().lift(new OperatorSubscribeOnBounded<Integer>(Schedulers.newThread(), 1));\n+        \n+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+        \n+        result.subscribe(ts);\n+        \n+        ts.awaitTerminalEvent();\n+        ts.assertReceivedOnNext(data);\n+    }\n }",
    "output": "Fix deadlock in SubscribeOnBounded"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/ZipTests.java b/rxjava-core/src/test/java/rx/ZipTests.java\n--- a/rxjava-core/src/test/java/rx/ZipTests.java\n+++ b/rxjava-core/src/test/java/rx/ZipTests.java\n@@ -15,6 +15,10 @@\n  */\n package rx;\n \n+import static org.junit.Assert.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n \n@@ -31,6 +35,7 @@\n import rx.functions.Action1;\n import rx.functions.Func1;\n import rx.functions.Func2;\n+import rx.functions.FuncN;\n import rx.observables.GroupedObservable;\n \n public class ZipTests {\n@@ -91,6 +96,28 @@ public void testCovarianceOfZip() {\n         Observable.<Movie, CoolRating, Result> zip(horrors, ratings, combine);\n     }\n \n+    /**\n+     * Occasionally zip may be invoked with 0 observables. This blocks indefinitely instead\n+     * of immediately invoking zip with 0 argument.\n+     */\n+    @Test(timeout = 5000)\n+    public void nonBlockingObservable() {\n+\n+        final Object invoked = new Object();\n+\n+        Collection<Observable<Object>> observables = Collections.emptyList();\n+\n+        Observable<Object> result = Observable.zip(observables, new FuncN<Object>() {\n+            @Override\n+            public Object call(final Object... args) {\n+                assertEquals(\"No argument should have been passed\", 0, args.length);\n+                return invoked;\n+            }\n+        });\n+\n+        assertSame(invoked, result.toBlockingObservable().last());\n+    }\n+\n     Func2<Media, Rating, ExtendedResult> combine = new Func2<Media, Rating, ExtendedResult>() {\n         @Override\n         public ExtendedResult call(Media m, Rating r) {",
    "output": "Add additional test to prove issue"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -4589,30 +4589,6 @@ public final <K> Observable<GroupedObservable<K, T>> groupBy(final Func1<? super\n         return lift(new OperatorGroupBy<K, T>(keySelector));\n     }\n \n-    /**\n-     * Groups the items emitted by an Observable according to a specified criterion, and emits these grouped\n-     * items, transformed by a selector, within {@link GroupedObservable}s, one {@code GroupedObservable} per\n-     * group.\n-     * <p>\n-     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/groupBy.png\">\n-     * \n-     * @param keySelector\n-     *            a function that extracts the key from an item\n-     * @param elementSelector\n-     *            a function to map a source item to an item emitted by a {@link GroupedObservable}\n-     * @param <K>\n-     *            the key type\n-     * @param <R>\n-     *            the type of items emitted by the resulting {@link GroupedObservable}s\n-     * @return an Observable that emits {@link GroupedObservable}s, each of which corresponds to a unique key\n-     *         value and emits transformed items corresponding to items from the source Observable that share\n-     *         that key value\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Transforming-Observables#wiki-groupby-and-groupbyuntil\">RxJava Wiki: groupBy</a>\n-     */\n-    public final <K, R> Observable<GroupedObservable<K, R>> groupBy(final Func1<? super T, ? extends K> keySelector, final Func1<? super T, ? extends R> elementSelector) {\n-        return null;\n-    }\n-\n     /**\n      * Groups the items emitted by an Observable according to a specified key selector function until the\n      * duration Observable expires for the key.",
    "output": "Remove groupBy with selector.\n\nUse groupBy.map instead"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java\n--- a/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java\n+++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java\n@@ -93,7 +93,9 @@ protected HttpResponse buildResult(HttpContext context) throws Exception {\n \n     @Override\n     protected void releaseResources() {\n-        consumer._releaseResources();\n+        if (consumer != null) {\n+            consumer._releaseResources();\n+        }\n     }\n \n }",
    "output": "Fix NullPointerException that may happen on timeout"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java b/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java\n--- a/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java\n+++ b/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java\n@@ -27,7 +27,6 @@\n import java.nio.charset.CoderResult;\n import java.nio.charset.CodingErrorAction;\n import java.util.Arrays;\n-import java.util.Objects;\n import java.util.regex.Pattern;\n \n import rx.Observable;\n@@ -461,14 +460,23 @@ public String getText() {\n \n         @Override\n         public int hashCode() {\n-            return Objects.hash(number, text);\n+            int result = 31 + number;\n+            result = 31 * result + (text == null ? 0 : text.hashCode());\n+            return result;\n         }\n \n         @Override\n         public boolean equals(Object obj) {\n             if (!(obj instanceof Line))\n                 return false;\n-            return Objects.equals(number, ((Line) obj).number) && Objects.equals(text, ((Line) obj).text);\n+            Line other = (Line) obj;\n+            if (number != other.number)\n+                return false;\n+            if (other.text == text)\n+                return true;\n+            if (text == null)\n+                return false;\n+            return text.equals(other.text);\n         }\n \n         @Override",
    "output": "Remove java 7 dep"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorParallel.java b/rxjava-core/src/main/java/rx/operators/OperatorParallel.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorParallel.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorParallel.java\n@@ -29,33 +29,35 @@ public final class OperatorParallel<T, R> implements Operator<R, T> {\n \n     private final Scheduler scheduler;\n     private final Func1<Observable<T>, Observable<R>> f;\n+    private final int degreeOfParallelism;\n \n     public OperatorParallel(Func1<Observable<T>, Observable<R>> f, Scheduler scheduler) {\n         this.scheduler = scheduler;\n         this.f = f;\n+        this.degreeOfParallelism = scheduler.degreeOfParallelism();\n     }\n \n     @Override\n     public Subscriber<? super T> call(Subscriber<? super R> op) {\n \n-        Func1<Subscriber<? super GroupedObservable<Integer, T>>, Subscriber<? super T>> groupBy =\n-                new OperatorGroupBy<Integer, T>(new Func1<T, Integer>() {\n+        Func1<Subscriber<? super GroupedObservable<Long, T>>, Subscriber<? super T>> groupBy =\n+                new OperatorGroupBy<Long, T>(new Func1<T, Long>() {\n \n-                    int i = 0;\n+                    long i = 0;\n \n                     @Override\n-                    public Integer call(T t) {\n-                        return i++ % scheduler.degreeOfParallelism();\n+                    public Long call(T t) {\n+                        return i++ % degreeOfParallelism;\n                     }\n \n                 });\n \n-        Func1<Subscriber<? super Observable<R>>, Subscriber<? super GroupedObservable<Integer, T>>> map =\n-                new OperatorMap<GroupedObservable<Integer, T>, Observable<R>>(\n-                        new Func1<GroupedObservable<Integer, T>, Observable<R>>() {\n+        Func1<Subscriber<? super Observable<R>>, Subscriber<? super GroupedObservable<Long, T>>> map =\n+                new OperatorMap<GroupedObservable<Long, T>, Observable<R>>(\n+                        new Func1<GroupedObservable<Long, T>, Observable<R>>() {\n \n                             @Override\n-                            public Observable<R> call(GroupedObservable<Integer, T> g) {\n+                            public Observable<R> call(GroupedObservable<Long, T> g) {\n                                 // Must use observeOn not subscribeOn because we have a single source behind groupBy.\n                                 // The origin is already subscribed to, we are moving each group on to a new thread\n                                 // but the origin itself can only be on a single thread.\n\ndiff --git a/rxjava-core/src/perf/java/rx/operators/OperatorParallelPerformance.java b/rxjava-core/src/perf/java/rx/operators/OperatorParallelPerformance.java\n--- a/rxjava-core/src/perf/java/rx/operators/OperatorParallelPerformance.java\n+++ b/rxjava-core/src/perf/java/rx/operators/OperatorParallelPerformance.java\n@@ -0,0 +1,66 @@\n+package rx.operators;\n+\n+import rx.Observable;\n+import rx.functions.Action0;\n+import rx.functions.Func1;\n+import rx.perf.AbstractPerformanceTester;\n+import rx.perf.IntegerSumObserver;\n+\n+public class OperatorParallelPerformance extends AbstractPerformanceTester {\n+\n+    private final static int REPS = 10000000;\n+\n+    OperatorParallelPerformance() {\n+        super(REPS);\n+    }\n+\n+    public static void main(String args[]) {\n+\n+        final OperatorParallelPerformance spt = new OperatorParallelPerformance();\n+        try {\n+            spt.runTest(new Action0() {\n+\n+                @Override\n+                public void call() {\n+                    spt.parallelSum();\n+                }\n+            });\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+\n+    }\n+\n+    /**\n+     * \n+     * Run: 10 - 11,220,888 ops/sec\n+     * Run: 11 - 12,372,424 ops/sec\n+     * Run: 12 - 11,028,921 ops/sec\n+     * Run: 13 - 11,813,711 ops/sec\n+     * Run: 14 - 12,098,364 ops/sec\n+     * \n+     */\n+    public long parallelSum() {\n+\n+        Observable<Integer> s = Observable.range(1, REPS).parallel(new Func1<Observable<Integer>, Observable<Integer>>() {\n+\n+            @Override\n+            public Observable<Integer> call(Observable<Integer> l) {\n+                return l.map(new Func1<Integer, Integer>() {\n+\n+                    @Override\n+                    public Integer call(Integer i) {\n+                        return i + 1;\n+                    }\n+\n+                });\n+            }\n+\n+        });\n+        IntegerSumObserver o = new IntegerSumObserver();\n+\n+        s.subscribe(o);\n+        return o.sum;\n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Change Parallel to use Long instead of Int"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-debug/src/test/java/rx/debug/DebugHookTest.java b/rxjava-contrib/rxjava-debug/src/test/java/rx/debug/DebugHookTest.java\n--- a/rxjava-contrib/rxjava-debug/src/test/java/rx/debug/DebugHookTest.java\n+++ b/rxjava-contrib/rxjava-debug/src/test/java/rx/debug/DebugHookTest.java\n@@ -63,7 +63,7 @@ public void onError(Throwable e) {\n             public void onNext(Integer t) {\n             }\n         });\n-        verify(events, times(6)).call(subscribe());\n+        verify(events, atLeast(3)).call(subscribe());\n         verify(events, times(4)).call(onNext(1));\n         // one less because it originates from the inner observable sent to merge\n         verify(events, times(3)).call(onNext(2));",
    "output": "Fix DebugHookTest as per direction from @abersnaze"
  },
  {
    "input": "diff --git a/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java\n--- a/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java\n+++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java\n@@ -24,19 +24,19 @@ public String call(Object f) {\n     }\n \n     public String call(rx.functions.Func1 f) {\n-        return \"rx.util.functions.Func1\";\n+        return \"rx.functions.Func1\";\n     }\n \n     public String call(rx.functions.Func2 f) {\n-        return \"rx.util.functions.Func2\";\n+        return \"rx.functions.Func2\";\n     }\n \n     public String call(rx.functions.Action1 f) {\n-        return \"rx.util.functions.Action1\";\n+        return \"rx.functions.Action1\";\n     }\n \n     public String call(rx.functions.Action2 f) {\n-        return \"rx.util.functions.Action2\";\n+        return \"rx.functions.Action2\";\n     }\n \n }\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnTest.java b/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnTest.java\n@@ -52,14 +52,14 @@ public void call(\n                             final Subscriber<? super Integer> subscriber) {\n                         scheduled.countDown();\n                         try {\n-                            latch.await();\n+                            try {\n+                                latch.await();\n+                            } catch (InterruptedException e) {\n+                                // this means we were unsubscribed (Scheduler shut down and interrupts)\n+                                // ... but we'll pretend we are like many Observables that ignore interrupts\n+                            }\n \n-                            System.out.println(\"emit onCompleted\");\n-                            // this should not run because the await above will be interrupted by the unsubscribe\n                             subscriber.onCompleted();\n-                        } catch (InterruptedException e) {\n-                            e.printStackTrace();\n-                            throw new RuntimeException(\"should not occur since we are not interuppting\");\n                         } catch (Throwable e) {\n                             subscriber.onError(e);\n                         } finally {\n@@ -75,8 +75,7 @@ public void call(\n         latch.countDown();\n         doneLatch.await();\n         assertEquals(0, observer.getOnErrorEvents().size());\n-        // the unsubscribe shuts down the scheduler which causes the latch to be interrupted\n-        assertEquals(0, observer.getOnCompletedEvents().size());\n+        assertEquals(1, observer.getOnCompletedEvents().size());\n     }\n \n     public static class SlowScheduler extends Scheduler {",
    "output": "Remove rx.util usage from sub-modules\n\nAll sub-modules and tests building and passing"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/operators/OperationForEachFuture.java b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/operators/OperationForEachFuture.java\n--- a/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/operators/OperationForEachFuture.java\n+++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/operators/OperationForEachFuture.java\n@@ -20,7 +20,7 @@\n \n import rx.Observable;\n import rx.Subscription;\n-import rx.util.Exceptions;\n+import rx.exceptions.Exceptions;\n import rx.util.functions.Action0;\n import rx.util.functions.Action1;\n \n\ndiff --git a/rxjava-core/src/test/java/rx/ReduceTests.java b/rxjava-core/src/test/java/rx/ReduceTests.java\n--- a/rxjava-core/src/test/java/rx/ReduceTests.java\n+++ b/rxjava-core/src/test/java/rx/ReduceTests.java\n@@ -21,7 +21,6 @@\n \n import rx.CovarianceTest.HorrorMovie;\n import rx.CovarianceTest.Movie;\n-import rx.operators.OperatorScan;\n import rx.util.functions.Func2;\n \n public class ReduceTests {\n\ndiff --git a/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java b/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java\n--- a/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java\n+++ b/rxjava-core/src/test/java/rx/exceptions/CompositeExceptionTest.java\n@@ -23,10 +23,6 @@\n \n import org.junit.Test;\n \n-import rx.util.CompositeException.CompositeExceptionCausalChain;\n-\n-import rx.exceptions.CompositeException;\n-\n public class CompositeExceptionTest {\n \n     private final Throwable ex1 = new Throwable(\"Ex1\");\n\ndiff --git a/rxjava-core/src/test/java/rx/exceptions/ExceptionsTest.java b/rxjava-core/src/test/java/rx/exceptions/ExceptionsTest.java\n--- a/rxjava-core/src/test/java/rx/exceptions/ExceptionsTest.java\n+++ b/rxjava-core/src/test/java/rx/exceptions/ExceptionsTest.java\n@@ -19,8 +19,6 @@\n \n import rx.Observable;\n import rx.Observer;\n-import rx.exceptions.OnErrorNotImplimport rx.util.OnErrorNotImplementedException;\n-ementedException;\n import rx.subjects.PublishSubject;\n import rx.util.functions.Action1;\n \n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java b/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java\n@@ -28,7 +28,6 @@\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import org.junit.Ignore;\n import org.junit.Test;\n \n import rx.Observable;\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperatorObserveOnTest.java b/rxjava-core/src/test/java/rx/operators/OperatorObserveOnTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorObserveOnTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorObserveOnTest.java\n@@ -30,15 +30,10 @@\n import org.mockito.stubbing.Answer;\n \n import rx.Observable;\n-import rx.Observable.OnSubscribeFunc;\n import rx.Observer;\n import rx.Scheduler;\n-import rx.Subscription;\n-import rx.schedulers.ImmediateScheduler;\n import rx.schedulers.Schedulers;\n import rx.schedulers.TestScheduler;\n-import rx.schedulers.TrampolineScheduler;\n-import rx.subscriptions.BooleanSubscription;\n import rx.util.functions.Action0;\n import rx.util.functions.Action1;\n import rx.util.functions.Func1;\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperatorScanTest.java b/rxjava-core/src/test/java/rx/operators/OperatorScanTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorScanTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorScanTest.java\n@@ -17,7 +17,6 @@\n \n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n-import static rx.operators.OperatorScan.*;\n \n import org.junit.Before;\n import org.junit.Test;\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java b/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java\n@@ -15,14 +15,9 @@\n  */\n package rx.operators;\n \n-import static org.junit.Assert.assertFalse;\n-import static org.mockito.Matchers.any;\n-import static org.mockito.Matchers.isA;\n-import static org.mockito.Mockito.doAnswer;\n-import static org.mockito.Mockito.inOrder;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.verify;\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n \n import java.util.Arrays;\n import java.util.concurrent.CountDownLatch;\n@@ -38,13 +33,10 @@\n import rx.Observable;\n import rx.Observable.OnSubscribe;\n import rx.Observer;\n-import rx.Scheduler;\n import rx.Subscriber;\n import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n import rx.subjects.PublishSubject;\n-import rx.subscriptions.Subscriptions;\n-import rx.util.functions.Action0;\n import rx.util.functions.Func0;\n import rx.util.functions.Func1;\n ",
    "output": "Upgrade sub-modules"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorFilter.java b/rxjava-core/src/main/java/rx/operators/OperatorFilter.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorFilter.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorFilter.java\n@@ -52,20 +52,6 @@ public void onNext(T value) {\n                 try {\n                     if (predicate.call(value)) {\n                         child.onNext(value);\n-                    } else {\n-                        /*\n-                         * Special casing of GroupedObservable since GroupedObservable ***MUST*** be subscribed to\n-                         * otherwise it will block the GroupBy operator. \n-                         * \n-                         * See https://github.com/Netflix/RxJava/issues/844\n-                         */\n-                        if (value instanceof GroupedObservable) {\n-                            System.out.println(\"value is GroupedObservable\");\n-                            @SuppressWarnings(\"rawtypes\")\n-                            GroupedObservable go = (GroupedObservable) value;\n-                            System.out.println(\"********* unsubscribe from go\");\n-                            go.take(0).subscribe();\n-                        }\n                     }\n                 } catch (Throwable ex) {\n                     child.onError(ex);",
    "output": "Remove Bad Filter Logic\n\nThis code was accidentally committed during exploration of groupBy/subscribeOn"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java b/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java\n--- a/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java\n+++ b/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java\n@@ -27,6 +27,7 @@\n import java.nio.charset.CoderResult;\n import java.nio.charset.CodingErrorAction;\n import java.util.Arrays;\n+import java.util.Objects;\n import java.util.regex.Pattern;\n \n import rx.Observable;\n@@ -37,10 +38,28 @@\n import rx.util.functions.Func2;\n \n public class StringObservable {\n+    /**\n+     * Reads from the bytes from a source {@link InputStream} and outputs {@link Observable} of\n+     * {@link byte[]}s\n+     * \n+     * @param i\n+     *            Source {@link InputStream}\n+     * @return\n+     */\n     public static Observable<byte[]> from(final InputStream i) {\n         return from(i, 8 * 1024);\n     }\n \n+    /**\n+     * Reads from the bytes from a source {@link InputStream} and outputs {@link Observable} of\n+     * {@link byte[]}s\n+     * \n+     * @param i\n+     *            Source {@link InputStream}\n+     * @param size\n+     *            internal buffer size\n+     * @return\n+     */\n     public static Observable<byte[]> from(final InputStream i, final int size) {\n         return Observable.create(new OnSubscribe<byte[]>() {\n             @Override\n@@ -65,10 +84,28 @@ public void call(Subscriber<? super byte[]> o) {\n         });\n     }\n \n+    /**\n+     * Reads from the characters from a source {@link Reader} and outputs {@link Observable} of\n+     * {@link String}s\n+     * \n+     * @param i\n+     *            Source {@link Reader}\n+     * @return\n+     */\n     public static Observable<String> from(final Reader i) {\n         return from(i, 8 * 1024);\n     }\n \n+    /**\n+     * Reads from the characters from a source {@link Reader} and outputs {@link Observable} of\n+     * {@link String}s\n+     * \n+     * @param i\n+     *            Source {@link Reader}\n+     * @param size\n+     *            internal buffer size\n+     * @return\n+     */\n     public static Observable<String> from(final Reader i, final int size) {\n         return Observable.create(new OnSubscribe<String>() {\n             @Override\n@@ -80,7 +117,7 @@ public void call(Subscriber<? super String> o) {\n                     int n = 0;\n                     n = i.read(buffer);\n                     while (n != -1 && !o.isUnsubscribed()) {\n-                        o.onNext(new String(buffer));\n+                        o.onNext(new String(buffer, 0, n));\n                         n = i.read(buffer);\n                     }\n                 } catch (IOException e) {\n@@ -119,7 +156,7 @@ public static Observable<String> decode(Observable<byte[]> src, Charset charset)\n \n     /**\n      * Decodes a stream the multibyte chunks into a stream of strings that works on infinite streams\n-     * and where handles when a multibyte character spans two chunks.\n+     * and where it handles when a multibyte character spans two chunks.\n      * This method allows for more control over how malformed and unmappable characters are handled.\n      * \n      * @param src\n@@ -151,6 +188,9 @@ public void onNext(byte[] bytes) {\n                     }\n \n                     public boolean process(byte[] next, ByteBuffer last, boolean endOfInput) {\n+                        if (o.isUnsubscribed())\n+                            return false;\n+\n                         ByteBuffer bb;\n                         if (last != null) {\n                             if (next != null) {\n@@ -270,8 +310,10 @@ public String call(String a, String b) {\n     /**\n      * Rechunks the strings based on a regex pattern and works on infinite stream.\n      * \n-     * resplit([\"boo:an\", \"d:foo\"], \":\") --> [\"boo\", \"and\", \"foo\"]\n-     * resplit([\"boo:an\", \"d:foo\"], \"o\") --> [\"b\", \"\", \":and:f\", \"\", \"\"]\n+     * <pre>\n+     * split([\"boo:an\", \"d:foo\"], \":\") --> [\"boo\", \"and\", \"foo\"]\n+     * split([\"boo:an\", \"d:foo\"], \"o\") --> [\"b\", \"\", \":and:f\", \"\", \"\"]\n+     * </pre>\n      * \n      * See {@link Pattern}\n      * \n@@ -399,4 +441,56 @@ public void onNext(Object t) {\n             }\n         });\n     }\n+\n+    public final static class Line {\n+        private final int number;\n+        private final String text;\n+\n+        public Line(int number, String text) {\n+            this.number = number;\n+            this.text = text;\n+        }\n+\n+        public int getNumber() {\n+            return number;\n+        }\n+\n+        public String getText() {\n+            return text;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(number, text);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!(obj instanceof Line))\n+                return false;\n+            return Objects.equals(number, ((Line) obj).number) && Objects.equals(text, ((Line) obj).text);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return number + \":\" + text;\n+        }\n+    }\n+\n+    /**\n+     * Splits the {@link Observable} of Strings by lines and numbers them (zero based index)\n+     * \n+     * @param source\n+     * @return\n+     */\n+    public static Observable<Line> byLine(Observable<String> source) {\n+        return split(source, System.getProperty(\"line.separator\")).map(new Func1<String, Line>() {\n+            int lineNumber = 0;\n+\n+            @Override\n+            public Line call(String text) {\n+                return new Line(lineNumber++, text);\n+            }\n+        });\n+    }\n }\n\ndiff --git a/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java b/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java\n--- a/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java\n+++ b/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java\n@@ -19,16 +19,23 @@\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n+import java.io.ByteArrayInputStream;\n import java.io.IOException;\n+import java.io.NotSerializableException;\n+import java.io.StringReader;\n import java.nio.charset.Charset;\n import java.nio.charset.CharsetDecoder;\n import java.nio.charset.MalformedInputException;\n import java.util.Arrays;\n+import java.util.List;\n+\n+import junit.framework.Assert;\n \n import org.junit.Test;\n \n import rx.Observable;\n import rx.Observer;\n+import rx.observables.StringObservable.Line;\n import rx.observers.TestObserver;\n import rx.util.AssertObservable;\n \n@@ -221,4 +228,27 @@ public void testJoinThrows() {\n         verify(observer, never()).onCompleted();\n         verify(observer, times(1)).onError(any(Throwable.class));\n     }\n+\n+    @Test\n+    public void testFromInputStream() {\n+        final byte[] inBytes = \"test\".getBytes();\n+        final byte[] outBytes = StringObservable.from(new ByteArrayInputStream(inBytes)).toBlockingObservable().single();\n+        assertNotSame(inBytes, outBytes);\n+        assertArrayEquals(inBytes, outBytes);\n+    }\n+\n+    @Test\n+    public void testFromReader() {\n+        final String inStr = \"test\";\n+        final String outStr = StringObservable.from(new StringReader(inStr)).toBlockingObservable().single();\n+        assertNotSame(inStr, outStr);\n+        assertEquals(inStr, outStr);\n+    }\n+\n+    @Test\n+    public void testByLine() {\n+        List<Line> lines = StringObservable.byLine(Observable.from(Arrays.asList(\"qwer\", \"\\nasdf\\n\", \"zx\", \"cv\"))).toList().toBlockingObservable().single();\n+\n+        assertEquals(Arrays.asList(new Line(0, \"qwer\"), new Line(1, \"asdf\"), new Line(2, \"zxcv\")), lines);\n+    }\n }",
    "output": "Fix an issue with the from(Reader) added a bunch of unit tests"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/subscriptions/CompositeSubscriptionTest.java b/rxjava-core/src/test/java/rx/subscriptions/CompositeSubscriptionTest.java\n--- a/rxjava-core/src/test/java/rx/subscriptions/CompositeSubscriptionTest.java\n+++ b/rxjava-core/src/test/java/rx/subscriptions/CompositeSubscriptionTest.java\n@@ -238,7 +238,7 @@ public void testClear() {\n         s.clear();\n \n         assertTrue(s1.isUnsubscribed());\n-        assertTrue(s1.isUnsubscribed());\n+        assertTrue(s2.isUnsubscribed());\n         assertFalse(s.isUnsubscribed());\n \n         BooleanSubscription s3 = new BooleanSubscription();",
    "output": "Upgrade CompositeSubscriptionTest.java Fix apparent typo, unsubscription of s2 was not checked and should have been"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java b/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java\n@@ -15,12 +15,20 @@\n  */\n package rx.operators;\n \n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertFalse;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.isA;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n \n import java.util.Arrays;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.junit.Test;\n import org.mockito.InOrder;\n@@ -30,6 +38,7 @@\n import rx.Observable;\n import rx.Observable.OnSubscribe;\n import rx.Observer;\n+import rx.Scheduler;\n import rx.Subscriber;\n import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n@@ -329,6 +338,8 @@ public void testTimeoutSelectorWithTimeoutAndOnNextRaceCondition() throws Interr\n         final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n         final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n         final CountDownLatch observerCompleted = new CountDownLatch(1);\n+        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n+        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n \n         final Func1<Integer, Observable<Integer>> timeoutFunc = new Func1<Integer, Observable<Integer>>() {\n             @Override\n@@ -338,31 +349,23 @@ public Observable<Integer> call(Integer t1) {\n                     return Observable.create(new OnSubscribe<Integer>() {\n                         @Override\n                         public void call(Subscriber<? super Integer> subscriber) {\n-                            subscriber.add(Subscriptions.create(new Action0() {\n-                                @Override\n-                                public void call() {\n-                                    try {\n-                                        // emulate \"unsubscribe\" is busy and finishes after timeout.onNext(1)\n-                                        timeoutEmittedOne.await();\n-                                    } catch (InterruptedException e) {\n-                                        // if we are interrupted then we complete (as this can happen when unsubscribed)\n-                                        observerCompleted.countDown();\n-                                        e.printStackTrace();\n+                            enteredTimeoutOne.countDown();\n+                            // force the timeout message be sent after observer.onNext(2)\n+                            while (true) {\n+                                try {\n+                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n+                                        // CountDownLatch timeout\n+                                        // There should be something wrong\n+                                        latchTimeout.set(true);\n                                     }\n+                                    break;\n+                                } catch (InterruptedException e) {\n+                                    // Since we just want to emulate a busy method,\n+                                    // we ignore the interrupt signal from Scheduler.\n                                 }\n-                            }));\n-                            // force the timeout message be sent after observer.onNext(2)\n-                            try {\n-                                observerReceivedTwo.await();\n-                            } catch (InterruptedException e) {\n-                                // if we are interrupted then we complete (as this can happen when unsubscribed)\n-                                observerCompleted.countDown();\n-                                e.printStackTrace();\n-                            }\n-                            if (!subscriber.isUnsubscribed()) {\n-                                subscriber.onNext(1);\n-                                timeoutEmittedOne.countDown();\n                             }\n+                            subscriber.onNext(1);\n+                            timeoutEmittedOne.countDown();\n                         }\n                     }).subscribeOn(Schedulers.newThread());\n                 } else {\n@@ -401,9 +404,18 @@ public void run() {\n                 PublishSubject<Integer> source = PublishSubject.create();\n                 source.timeout(timeoutFunc, Observable.from(3)).subscribe(ts);\n                 source.onNext(1); // start timeout\n+                try {\n+                    if(!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n+                        latchTimeout.set(true);\n+                    }\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n                 source.onNext(2); // disable timeout\n                 try {\n-                    timeoutEmittedOne.await();\n+                    if(!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n+                        latchTimeout.set(true);\n+                    }\n                 } catch (InterruptedException e) {\n                     e.printStackTrace();\n                 }\n@@ -412,7 +424,11 @@ public void run() {\n \n         }).start();\n \n-        observerCompleted.await();\n+        if(!observerCompleted.await(30, TimeUnit.SECONDS)) {\n+            latchTimeout.set(true);\n+        }\n+\n+        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n \n         InOrder inOrder = inOrder(o);\n         inOrder.verify(o).onNext(1);",
    "output": "Add timeout to CoundDownLatch, ignore InterruptException and fix the test to be consistent with the new subscribeOn"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnTest.java b/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnTest.java\n@@ -300,14 +300,15 @@ public void call() {\n \n                             });\n                 } else {\n-                    return group.subscribeOn(Schedulers.newThread()).delay(400, TimeUnit.MILLISECONDS).map(new Func1<Integer, String>() {\n+                    return group.nest().lift(new OperatorSubscribeOn<Integer>(Schedulers.newThread(), 0))\n+                            .delay(400, TimeUnit.MILLISECONDS).map(new Func1<Integer, String>() {\n \n-                        @Override\n-                        public String call(Integer t1) {\n-                            return \"last group: \" + t1;\n-                        }\n+                                @Override\n+                                public String call(Integer t1) {\n+                                    return \"last group: \" + t1;\n+                                }\n \n-                    });\n+                            });\n                 }\n             }\n \n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java b/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperatorTimeoutWithSelectorTest.java\n@@ -31,6 +31,7 @@\n import rx.Observable.OnSubscribe;\n import rx.Observer;\n import rx.Subscriber;\n+import rx.observers.TestSubscriber;\n import rx.schedulers.Schedulers;\n import rx.subjects.PublishSubject;\n import rx.subscriptions.Subscriptions;\n@@ -334,26 +335,31 @@ public void testTimeoutSelectorWithTimeoutAndOnNextRaceCondition() throws Interr\n             public Observable<Integer> call(Integer t1) {\n                 if (t1 == 1) {\n                     // Force \"unsubscribe\" run on another thread\n-                    return Observable.create(new OnSubscribe<Integer>(){\n+                    return Observable.create(new OnSubscribe<Integer>() {\n                         @Override\n                         public void call(Subscriber<? super Integer> subscriber) {\n-                            subscriber.add(Subscriptions.create(new Action0(){\n+                            subscriber.add(Subscriptions.create(new Action0() {\n                                 @Override\n                                 public void call() {\n                                     try {\n                                         // emulate \"unsubscribe\" is busy and finishes after timeout.onNext(1)\n                                         timeoutEmittedOne.await();\n                                     } catch (InterruptedException e) {\n+                                        // if we are interrupted then we complete (as this can happen when unsubscribed)\n+                                        observerCompleted.countDown();\n                                         e.printStackTrace();\n                                     }\n-                                }}));\n+                                }\n+                            }));\n                             // force the timeout message be sent after observer.onNext(2)\n                             try {\n                                 observerReceivedTwo.await();\n                             } catch (InterruptedException e) {\n+                                // if we are interrupted then we complete (as this can happen when unsubscribed)\n+                                observerCompleted.countDown();\n                                 e.printStackTrace();\n                             }\n-                            if(!subscriber.isUnsubscribed()) {\n+                            if (!subscriber.isUnsubscribed()) {\n                                 subscriber.onNext(1);\n                                 timeoutEmittedOne.countDown();\n                             }\n@@ -386,12 +392,14 @@ public Void answer(InvocationOnMock invocation) throws Throwable {\n \n         }).when(o).onCompleted();\n \n+        final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(o);\n+\n         new Thread(new Runnable() {\n \n             @Override\n             public void run() {\n                 PublishSubject<Integer> source = PublishSubject.create();\n-                source.timeout(timeoutFunc, Observable.from(3)).subscribe(o);\n+                source.timeout(timeoutFunc, Observable.from(3)).subscribe(ts);\n                 source.onNext(1); // start timeout\n                 source.onNext(2); // disable timeout\n                 try {",
    "output": "Fix Unit Tests related to SubscribeOn\n\n- timeout test could be interrupted when unsubscribed\n- groupBy.subscribeOn needs blocking buffer"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java\n--- a/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java\n+++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java\n@@ -21,7 +21,7 @@\n import org.apache.http.nio.client.HttpAsyncClient;\n import org.apache.http.nio.client.methods.HttpAsyncMethods;\n import org.apache.http.nio.protocol.HttpAsyncRequestProducer;\n-import org.apache.http.protocol.Http.HttpContext;\n+import org.apache.http.protocol.HttpContext;\n import org.apache.http.protocol.BasicHttpContext;\n \n import rx.Observable;",
    "output": "Fix import org.apache.http.protocol.HttpContext;"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java\n--- a/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java\n+++ b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java\n@@ -28,6 +28,10 @@\n import rx.Scheduler;\n import rx.util.Exceptions;\n import rx.util.OnErrorNotImplementedException;\n+import rx.util.functions.Action2;\n+import rx.util.functions.Actions;\n+import rx.util.functions.Func1;\n+import rx.util.functions.Functions;\n \n /**\n  * This class contains static methods that connect {@link Observable}s and {@link Channel}s.\n@@ -122,45 +126,21 @@ public void onError(Throwable e) {\n     public final static <T> ReceivePort<T> subscribe(int bufferSize, Channels.OverflowPolicy policy, Observable<T> o) {\n         final ChannelWithErrors<T> channel = new ChannelWithErrors<T>(Channels.newChannel(bufferSize, policy));\n \n-        o.subscribe(new Observer<T>() {\n-            @Override\n-            @Suspendable\n-            public void onNext(T t) {\n-                try {\n-                    channel.sendPort().send(t);\n-                } catch (InterruptedException ex) {\n-                    Strand.interrupted();\n-                } catch (SuspendExecution ex) {\n-                    throw new AssertionError(ex);\n-                }\n-            }\n+        System.out.println(Functions.fromFunc(new Func1<String, String>() {\n \n             @Override\n-            public void onCompleted() {\n-                channel.sendPort().close();\n+            public String call(String t1) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n             }\n+        }));\n+        System.out.println(Actions.toFunc(new Action2<String, String>() {\n \n             @Override\n-            public void onError(Throwable e) {\n-                channel.error(e);\n+            public void call(String t1, String t2) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n             }\n-        });\n-        return channel.receivePort();\n-    }\n-\n-    /**\n-     * Creates a {@link ReceivePort} subscribed to an {@link Observable}.\n-     * <p>\n-     * @param <T>        the type of messages emitted by the observable and received on the channel.\n-     * @param bufferSize the channel's buffer size\n-     * @param policy     the channel's {@link Channels.OverflowPolicy OverflowPolicy}\n-     * @param o          the observable\n-     * @param scheduler  the scheduler used to emit the observable's events\n-     * @return A new channel with the given buffer size and overflow policy that will receive all events emitted by the observable.\n-     */\n-    public final static <T> ReceivePort<T> subscribe(int bufferSize, Channels.OverflowPolicy policy, Observable<T> o, Scheduler scheduler) {\n-        final ChannelWithErrors<T> channel = new ChannelWithErrors<T>(Channels.newChannel(bufferSize, policy));\n-\n+        }));\n+        \n         o.subscribe(new Observer<T>() {\n             @Override\n             @Suspendable\n@@ -183,7 +163,7 @@ public void onCompleted() {\n             public void onError(Throwable e) {\n                 channel.error(e);\n             }\n-        }, scheduler);\n+        });\n         return channel.receivePort();\n     }\n \n\ndiff --git a/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/RxSuspendableClassifier.java b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/RxSuspendableClassifier.java\n--- a/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/RxSuspendableClassifier.java\n+++ b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/RxSuspendableClassifier.java\n@@ -0,0 +1,79 @@\n+/**\n+ * Copyright 2014 Netflix, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.quasar;\n+\n+import co.paralleluniverse.fibers.instrument.MethodDatabase;\n+import co.paralleluniverse.fibers.instrument.SimpleSuspendableClassifier;\n+import co.paralleluniverse.fibers.instrument.SuspendableClassifier;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class RxSuspendableClassifier implements SuspendableClassifier {\n+    private static final Set<String> CORE_PACKAGES = new HashSet<String>(Arrays.asList(new String[]{\n+        \"rx\", \"rx.joins\", \"rx.observables\", \"rx.observers\", \"rx.operators\", \"rx.plugins\", \"rx.schedulers\",\n+        \"rx.subjects\", \"rx.subscriptions\", \"rx.util\", \"rx.util.functions\"\n+    }));\n+\n+    private static final Set<String> EXCEPTIONS = new HashSet<String>(Arrays.asList(new String[]{\n+        \"rx/observers/SynchronizedObserver\",\n+        \"rx/schedulers/AbstractSchedulerTests$ConcurrentObserverValidator\",}));\n+\n+    private static final Set<String> OBSERVER_METHODS = new HashSet<String>(Arrays.asList(new String[]{\n+        \"onNext(Ljava/lang/Object;)V\", \"onCompleted()V\", \"onError(Ljava/lang/Throwable;)V\"\n+    }));\n+\n+    private static final String FUNCTION_METHOD = \"call\";\n+\n+    @Override\n+    public MethodDatabase.SuspendableType isSuspendable(MethodDatabase db, String className, String superClassName, String[] interfaces, String methodName, String methodDesc, String methodSignature, String[] methodExceptions) {\n+        MethodDatabase.SuspendableType s = null;\n+        if (isCoreRx(className) && !EXCEPTIONS.contains(className)) {\n+            if (isObserverImplementation(db, className, superClassName, interfaces, methodName, methodDesc))\n+                s = MethodDatabase.SuspendableType.SUSPENDABLE;\n+            else if (isUtilFunction(db, className, superClassName, interfaces, methodName, methodDesc))\n+                s = MethodDatabase.SuspendableType.SUSPENDABLE;\n+        }\n+        // System.out.println(\"-- \" + className + \".\" + methodName + \": \" + s);\n+        return s;\n+    }\n+\n+    private boolean isCoreRx(String className) {\n+        return CORE_PACKAGES.contains(packageOf(className));\n+    }\n+\n+    private static boolean isObserverImplementation(MethodDatabase db, String className, String superClassName, String[] interfaces, String methodName, String methodDesc) {\n+        return !className.equals(\"rx/Observer\")\n+                && OBSERVER_METHODS.contains(methodName + methodDesc)\n+                && SimpleSuspendableClassifier.extendsOrImplements(\"rx/Observer\", db, className, superClassName, interfaces);\n+    }\n+\n+    private static boolean isUtilFunction(MethodDatabase db, String className, String superClassName, String[] interfaces, String methodName, String methodDesc) {\n+        return (className.startsWith(\"rx/util/functions/Functions\") || className.startsWith(\"rx/util/functions/Actions\"))\n+                && methodName.equals(FUNCTION_METHOD)\n+                && (SimpleSuspendableClassifier.extendsOrImplements(\"rx/util/functions/Function\", db, className, superClassName, interfaces)\n+                || SimpleSuspendableClassifier.extendsOrImplements(\"rx/util/functions/Action\", db, className, superClassName, interfaces));\n+    }\n+\n+    private static String packageOf(String className) {\n+        try {\n+            return className.substring(0, className.lastIndexOf('/')).replace('/', '.');\n+        } catch (RuntimeException e) {\n+            System.err.println(\"???? \" + className);\n+            throw e;\n+        }\n+    }\n+}",
    "output": "Use a custom SuspendableClassifier"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java b/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java\n@@ -135,7 +135,6 @@ public void onNext(T t) {\n \n             private void completeInner() {\n                 if (completionCounter.decrementAndGet() == 0 && (completed.get() || childObserver.isUnsubscribed())) {\n-                    System.out.println(\"groupBy INNER completed\");\n                     if (childObserver.isUnsubscribed()) {\n                         // if the entire groupBy has been unsubscribed and children are completed we will propagate the unsubscribe up.\n                         unsubscribe();",
    "output": "Remove Stray Println"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java\n--- a/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java\n+++ b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java\n@@ -17,17 +17,24 @@\n import co.paralleluniverse.fibers.SuspendExecution;\n import co.paralleluniverse.fibers.Suspendable;\n import co.paralleluniverse.strands.Strand;\n+import co.paralleluniverse.strands.Timeout;\n+import co.paralleluniverse.strands.channels.Channel;\n+import co.paralleluniverse.strands.channels.Channels;\n import co.paralleluniverse.strands.channels.ReceivePort;\n import co.paralleluniverse.strands.channels.SendPort;\n+import java.util.concurrent.TimeUnit;\n import rx.Observable;\n import rx.Observer;\n import rx.Scheduler;\n+import rx.util.Exceptions;\n import rx.util.OnErrorNotImplementedException;\n \n /**\n- *\n+ * This class contains static methods that connect {@link Observable}s and {@link Channel}s.\n  */\n-public class ChannelObservable {\n+public final class ChannelObservable {\n+    private ChannelObservable() {\n+    }\n \n     /**\n      * Converts an {@link Iterable} sequence into an Observable that emits each message received on the channel.\n@@ -102,4 +109,152 @@ public void onError(Throwable e) {\n             }\n         };\n     }\n+\n+    /**\n+     * Creates a {@link ReceivePort} subscribed to an {@link Observable}.\n+     * <p>\n+     * @param <T>        the type of messages emitted by the observable and received on the channel.\n+     * @param bufferSize the channel's buffer size\n+     * @param policy     the channel's {@link Channels.OverflowPolicy OverflowPolicy}\n+     * @param o          the observable\n+     * @return A new channel with the given buffer size and overflow policy that will receive all events emitted by the observable.\n+     */\n+    public final static <T> ReceivePort<T> subscribe(int bufferSize, Channels.OverflowPolicy policy, Observable<T> o) {\n+        final ChannelWithErrors<T> channel = new ChannelWithErrors<T>(Channels.newChannel(bufferSize, policy));\n+\n+        o.subscribe(new Observer<T>() {\n+            @Override\n+            @Suspendable\n+            public void onNext(T t) {\n+                try {\n+                    channel.sendPort().send(t);\n+                } catch (InterruptedException ex) {\n+                    Strand.interrupted();\n+                } catch (SuspendExecution ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+                channel.sendPort().close();\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                channel.error(e);\n+            }\n+        });\n+        return channel.receivePort();\n+    }\n+\n+    /**\n+     * Creates a {@link ReceivePort} subscribed to an {@link Observable}.\n+     * <p>\n+     * @param <T>        the type of messages emitted by the observable and received on the channel.\n+     * @param bufferSize the channel's buffer size\n+     * @param policy     the channel's {@link Channels.OverflowPolicy OverflowPolicy}\n+     * @param o          the observable\n+     * @param scheduler  the scheduler used to emit the observable's events\n+     * @return A new channel with the given buffer size and overflow policy that will receive all events emitted by the observable.\n+     */\n+    public final static <T> ReceivePort<T> subscribe(int bufferSize, Channels.OverflowPolicy policy, Observable<T> o, Scheduler scheduler) {\n+        final ChannelWithErrors<T> channel = new ChannelWithErrors<T>(Channels.newChannel(bufferSize, policy));\n+\n+        o.subscribe(new Observer<T>() {\n+            @Override\n+            @Suspendable\n+            public void onNext(T t) {\n+                try {\n+                    channel.sendPort().send(t);\n+                } catch (InterruptedException ex) {\n+                    Strand.interrupted();\n+                } catch (SuspendExecution ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+                channel.sendPort().close();\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                channel.error(e);\n+            }\n+        }, scheduler);\n+        return channel.receivePort();\n+    }\n+\n+    private static class ChannelWithErrors<T> {\n+        private final Channel<Object> ch;\n+\n+        public ChannelWithErrors(Channel<Object> ch) {\n+            this.ch = ch;\n+        }\n+\n+        @Suspendable\n+        public void error(Throwable t) {\n+            try {\n+                ch.send(new ThrowableWrapper(t));\n+                ch.close();\n+            } catch (InterruptedException e) {\n+            } catch (SuspendExecution e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        public ReceivePort<T> receivePort() {\n+            return new ReceivePort<T>() {\n+                @Override\n+                public T receive() throws SuspendExecution, InterruptedException {\n+                    return get(ch.receive());\n+                }\n+\n+                @Override\n+                public T receive(long timeout, TimeUnit unit) throws SuspendExecution, InterruptedException {\n+                    return get(ch.receive(timeout, unit));\n+                }\n+\n+                @Override\n+                public T receive(Timeout timeout) throws SuspendExecution, InterruptedException {\n+                    return get(ch.receive(timeout));\n+                }\n+\n+                @Override\n+                public T tryReceive() {\n+                    return get(ch.tryReceive());\n+                }\n+\n+                @Override\n+                public void close() {\n+                    ch.close();\n+                }\n+\n+                @Override\n+                public boolean isClosed() {\n+                    return ch.isClosed();\n+                }\n+            };\n+        }\n+\n+        public SendPort<T> sendPort() {\n+            return (SendPort<T>) ch;\n+        }\n+\n+        private T get(Object m) {\n+            if (m instanceof ThrowableWrapper)\n+                throw Exceptions.propagate(((ThrowableWrapper) m).t);\n+            return (T) m;\n+        }\n+\n+        private static class ThrowableWrapper {\n+            final Throwable t;\n+\n+            public ThrowableWrapper(Throwable t) {\n+                this.t = t;\n+            }\n+        }\n+    }\n }\n\ndiff --git a/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/OnSubscribeFromChannel.java b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/OnSubscribeFromChannel.java\n--- a/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/OnSubscribeFromChannel.java\n+++ b/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/OnSubscribeFromChannel.java\n@@ -50,7 +50,7 @@ public void call(Subscriber<? super T> o) {\n                 break;\n             } catch (Exception e) {\n                 o.onError(e);\n-                continue;\n+                return;\n             }\n \n             o.onNext(m);\n\ndiff --git a/rxjava-contrib/rxjava-quasar/src/test/java/rx/quasar/ChannelObservableTest.java b/rxjava-contrib/rxjava-quasar/src/test/java/rx/quasar/ChannelObservableTest.java\n--- a/rxjava-contrib/rxjava-quasar/src/test/java/rx/quasar/ChannelObservableTest.java\n+++ b/rxjava-contrib/rxjava-quasar/src/test/java/rx/quasar/ChannelObservableTest.java\n@@ -20,6 +20,7 @@\n import co.paralleluniverse.strands.Strand;\n import co.paralleluniverse.strands.channels.Channel;\n import co.paralleluniverse.strands.channels.Channels;\n+import co.paralleluniverse.strands.channels.ReceivePort;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Queue;\n@@ -30,6 +31,7 @@\n import org.junit.Test;\n import rx.Observable;\n import rx.Observer;\n+import rx.subjects.PublishSubject;\n \n public class ChannelObservableTest {\n     @Test\n@@ -91,4 +93,37 @@ public void testObserverChannel() throws Exception {\n         assertThat(c.receive(), equalTo(\"c\"));\n         assertThat(c.receive(), is(nullValue()));\n     }\n+\n+    @Test\n+    public void testObserverChannel2() throws Exception {\n+        ReceivePort<String> c = ChannelObservable.subscribe(10, Channels.OverflowPolicy.BLOCK, Observable.from(Arrays.asList(\"a\", \"b\", \"c\")));\n+\n+        assertThat(c.receive(), equalTo(\"a\"));\n+        assertThat(c.receive(), equalTo(\"b\"));\n+        assertThat(c.receive(), equalTo(\"c\"));\n+        assertThat(c.receive(), is(nullValue()));\n+    }\n+\n+    @Test\n+    public void testObserverChannelWithError() throws Exception {\n+        PublishSubject<String> o = PublishSubject.create();\n+        ReceivePort<String> c = ChannelObservable.subscribe(10, Channels.OverflowPolicy.BLOCK, o);\n+\n+        o.onNext(\"a\");\n+        o.onError(new MyException());\n+        o.onNext(\"c\");\n+        \n+        assertThat(c.receive(), equalTo(\"a\"));\n+        try {\n+            c.receive();\n+            fail();\n+        } catch(MyException e) {\n+            \n+        }\n+        assertThat(c.receive(), is(nullValue()));\n+    }\n+    \n+    static class MyException extends RuntimeException {\n+        \n+    }\n }",
    "output": "Add ChannelObservable.subscribe"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java b/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java\n--- a/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java\n+++ b/rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java\n@@ -311,7 +311,8 @@ public void onNext(String v) {\n         subject.onNext(\"two\");\n         assertEquals(\"two\", lastValueForObserver1.get());\n \n-        Subscription s2 = subject.observeOn(Schedulers.newThread()).subscribe(observer2);\n+        // use subscribeOn to make this async otherwise we deadlock as we are using CountDownLatches\n+        Subscription s2 = subject.subscribeOn(Schedulers.newThread()).subscribe(observer2);\n \n         System.out.println(\"before waiting for one\");\n \n@@ -321,12 +322,23 @@ public void onNext(String v) {\n         System.out.println(\"after waiting for one\");\n \n         subject.onNext(\"three\");\n+        \n+        System.out.println(\"sent three\");\n+        \n         // if subscription blocked existing subscribers then 'makeSlow' would cause this to not be there yet \n         assertEquals(\"three\", lastValueForObserver1.get());\n+        \n+        System.out.println(\"about to send onCompleted\");\n+        \n         subject.onCompleted();\n \n+        System.out.println(\"completed subject\");\n+        \n         // release \n         makeSlow.countDown();\n+        \n+        System.out.println(\"makeSlow released\");\n+        \n         completed.await();\n         // all of them should be emitted with the last being \"three\"\n         assertEquals(\"three\", lastValueForObserver2.get());",
    "output": "Change to use SubscribeOn instead of ObserveOn for Async Behavior The ObserveOn operator is for moving where it executes, not making it async. SubscribeOn makes it async"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -5296,7 +5296,9 @@ public final Observable<T> onExceptionResumeNext(final Observable<? extends T> r\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#wiki-parallel\">RxJava Wiki: parallel()</a>\n      */\n     public final <R> Observable<R> parallel(Func1<Observable<T>, Observable<R>> f) {\n-        return lift(new OperatorParallel<T, R>(f, Schedulers.computation()));\n+        // TODO move this back to Schedulers.computation() again once that is properly using eventloops\n+        // see https://github.com/Netflix/RxJava/issues/713 for why this was changed\n+        return lift(new OperatorParallel<T, R>(f, Schedulers.newThread()));\n     }\n \n     /**",
    "output": "Make Parallel use NewThread until Computation Fixed\n\nSee https://github.com/Netflix/RxJava/issues/713\nIt was causing non-deterministic behavior, random test failures and poor performance"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java b/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java\n@@ -38,8 +38,7 @@ public OperatorSubscribeOn(Scheduler scheduler) {\n     }\n \n     @Override\n-    public Subscriber<? super Observable<T>> call(\n-            final Subscriber<? super T> subscriber) {\n+    public Subscriber<? super Observable<T>> call(final Subscriber<? super T> subscriber) {\n         return new Subscriber<Observable<T>>() {\n \n             @Override",
    "output": "Remove line break"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java b/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java\n@@ -69,7 +69,6 @@ public void call() {\n                                         @Override\n                                         public void call(final Inner inner) {\n                                             cs.unsubscribe();\n-                                            inner.unsubscribe();\n                                         }\n \n                                     });",
    "output": "Remove 'inner.unsubscribe'"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorCompoundButtonInput.java b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorCompoundButtonInput.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorCompoundButtonInput.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorCompoundButtonInput.java\n@@ -15,17 +15,19 @@\n  */\n package rx.operators;\n \n-import android.view.View;\n-import android.widget.CompoundButton;\n-import rx.Observable;\n-import rx.Observer;\n-import rx.Subscription;\n-\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n import java.util.WeakHashMap;\n \n+import rx.Observable;\n+import rx.Subscriber;\n+import rx.Subscription;\n+import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n+import android.view.View;\n+import android.widget.CompoundButton;\n+\n public class OperatorCompoundButtonInput implements Observable.OnSubscribe<Boolean> {\n     private final boolean emitInitialValue;\n     private final CompoundButton button;\n@@ -36,7 +38,7 @@ public OperatorCompoundButtonInput(final CompoundButton button, final boolean em\n     }\n \n     @Override\n-    public void call(final Observer<? super Boolean> observer) {\n+    public void call(final Subscriber<? super Boolean> observer) {\n         final CompositeOnCheckedChangeListener composite = CachedListeners.getFromViewOrCreate(button);\n \n         final CompoundButton.OnCheckedChangeListener listener = new CompoundButton.OnCheckedChangeListener() {\n@@ -46,12 +48,12 @@ public void onCheckedChanged(final CompoundButton button, final boolean checked)\n             }\n         };\n \n-        final Subscription subscription = new Subscription() {\n+        final Subscription subscription = Subscriptions.create(new Action0() {\n             @Override\n-            public void unsubscribe() {\n+            public void call() {\n                 composite.removeOnCheckedChangeListener(listener);\n             }\n-        };\n+        });\n \n         if (emitInitialValue) {\n             observer.onNext(button.isChecked());\n\ndiff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorEditTextInput.java b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorEditTextInput.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorEditTextInput.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorEditTextInput.java\n@@ -15,12 +15,14 @@\n  */\n package rx.operators;\n \n+import rx.Observable;\n+import rx.Subscriber;\n+import rx.Subscription;\n+import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n import android.text.Editable;\n import android.text.TextWatcher;\n import android.widget.EditText;\n-import rx.Observable;\n-import rx.Observer;\n-import rx.Subscription;\n \n public class OperatorEditTextInput implements Observable.OnSubscribe<String> {\n     private final EditText input;\n@@ -32,20 +34,20 @@ public OperatorEditTextInput(final EditText input, final boolean emitInitialValu\n     }\n \n     @Override\n-    public void call(final Observer<? super String> observer) {\n+    public void call(final Subscriber<? super String> observer) {\n         final TextWatcher watcher = new SimpleTextWatcher() {\n             @Override\n             public void afterTextChanged(final Editable editable) {\n                 observer.onNext(editable.toString());\n             }\n         };\n-\n-        final Subscription subscription = new Subscription() {\n+        \n+        final Subscription subscription = Subscriptions.create(new Action0() {\n             @Override\n-            public void unsubscribe() {\n+            public void call() {\n                 input.removeTextChangedListener(watcher);\n             }\n-        };\n+        });\n \n         if (emitInitialValue) {\n             observer.onNext(input.getEditableText().toString());\n\ndiff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorViewClick.java b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorViewClick.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorViewClick.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorViewClick.java\n@@ -15,15 +15,18 @@\n  */\n package rx.operators;\n \n-import android.view.View;\n-import rx.Observable;\n-import rx.Observer;\n-import rx.Subscription;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n import java.util.WeakHashMap;\n \n+import rx.Observable;\n+import rx.Subscriber;\n+import rx.Subscription;\n+import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n+import android.view.View;\n+\n public final class OperatorViewClick implements Observable.OnSubscribe<View> {\n     private final boolean emitInitialValue;\n     private final View view;\n@@ -34,7 +37,7 @@ public OperatorViewClick(final View view, final boolean emitInitialValue) {\n     }\n \n     @Override\n-    public void call(final Observer<? super View> observer) {\n+    public void call(final Subscriber<? super View> observer) {\n         final CompositeOnClickListener composite = CachedListeners.getFromViewOrCreate(view);\n \n         final View.OnClickListener listener = new View.OnClickListener() {\n@@ -44,12 +47,12 @@ public void onClick(final View clicked) {\n             }\n         };\n \n-        final Subscription subscription = new Subscription() {\n+        final Subscription subscription = Subscriptions.create(new Action0() {\n             @Override\n-            public void unsubscribe() {\n+            public void call() {\n                 composite.removeOnClickListener(listener);\n             }\n-        };\n+        });\n \n         if (emitInitialValue) {\n             observer.onNext(view);",
    "output": "Upgrade to use Subscriber/Subscriptions.create Master had changed since the pull request"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java b/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java\n--- a/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java\n+++ b/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java\n@@ -17,59 +17,72 @@\n \n import static org.junit.Assert.*;\n \n-import org.junit.Test;\n-\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n \n+import org.junit.Test;\n+\n public class CompositeExceptionTest {\n \n     private final Throwable ex1 = new Throwable(\"Ex1\");\n     private final Throwable ex2 = new Throwable(\"Ex2\", ex1);\n     private final Throwable ex3 = new Throwable(\"Ex3\", ex2);\n \n-    private final CompositeException compositeEx;\n-\n     public CompositeExceptionTest() {\n         ex1.initCause(ex2);\n+    }\n+\n+    private CompositeException getNewCompositeExceptionWithEx123() {\n         List<Throwable> throwables = new ArrayList<Throwable>();\n         throwables.add(ex1);\n         throwables.add(ex2);\n         throwables.add(ex3);\n-        compositeEx = new CompositeException(throwables);\n+        return new CompositeException(throwables);\n+    }\n+\n+    @Test(timeout = 1000)\n+    public void testMultipleWithSameCause() {\n+        Throwable rootCause = new Throwable(\"RootCause\");\n+        Throwable e1 = new Throwable(\"1\", rootCause);\n+        Throwable e2 = new Throwable(\"2\", rootCause);\n+        Throwable e3 = new Throwable(\"3\", rootCause);\n+        CompositeException ce = new CompositeException(\"3 failures with same root cause\", Arrays.asList(e1, e2, e3));\n     }\n \n-    @Test\n+    @Test(timeout = 1000)\n     public void testAttachCallingThreadStackParentThenChild() {\n         CompositeException.attachCallingThreadStack(ex1, ex2);\n         assertEquals(\"Ex2\", ex1.getCause().getMessage());\n     }\n \n-    @Test\n+    @Test(timeout = 1000)\n     public void testAttachCallingThreadStackChildThenParent() {\n         CompositeException.attachCallingThreadStack(ex2, ex1);\n         assertEquals(\"Ex1\", ex2.getCause().getMessage());\n     }\n \n-    @Test\n+    @Test(timeout = 1000)\n     public void testAttachCallingThreadStackAddComposite() {\n-        CompositeException.attachCallingThreadStack(ex1, compositeEx);\n+        CompositeException.attachCallingThreadStack(ex1, getNewCompositeExceptionWithEx123());\n         assertEquals(\"Ex2\", ex1.getCause().getMessage());\n     }\n \n-    @Test\n+    @Test(timeout = 1000)\n     public void testAttachCallingThreadStackAddToComposite() {\n+        CompositeException compositeEx = getNewCompositeExceptionWithEx123();\n         CompositeException.attachCallingThreadStack(compositeEx, ex1);\n         assertEquals(CompositeException.CompositeExceptionCausalChain.MESSAGE, compositeEx.getCause().getMessage());\n     }\n \n-    @Test\n+    @Test(timeout = 1000)\n     public void testAttachCallingThreadStackAddCompositeToItself() {\n+        CompositeException compositeEx = getNewCompositeExceptionWithEx123();\n         CompositeException.attachCallingThreadStack(compositeEx, compositeEx);\n         assertEquals(CompositeException.CompositeExceptionCausalChain.MESSAGE, compositeEx.getCause().getMessage());\n     }\n \n-    @Test\n+    @Test(timeout = 1000)\n     public void testAttachCallingThreadStackAddExceptionsToEachOther() {\n         CompositeException.attachCallingThreadStack(ex1, ex2);\n         CompositeException.attachCallingThreadStack(ex2, ex1);",
    "output": "Add testMultipleWithSameCause UnitTest\n\nAlso make tests capable of failing with timeouts. Before the constructor would immediately go into an infinite loop and hang the tests"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java b/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java\n--- a/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java\n+++ b/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java\n@@ -31,6 +31,7 @@ public class CompositeExceptionTest {\n     private final CompositeException compositeEx;\n \n     public CompositeExceptionTest() {\n+        ex1.initCause(ex2);\n         List<Throwable> throwables = new ArrayList<Throwable>();\n         throwables.add(ex1);\n         throwables.add(ex2);\n@@ -67,4 +68,12 @@ public void testAttachCallingThreadStackAddCompositeToItself() {\n         CompositeException.attachCallingThreadStack(compositeEx, compositeEx);\n         assertEquals(CompositeException.CompositeExceptionCausalChain.MESSAGE, compositeEx.getCause().getMessage());\n     }\n+\n+    @Test\n+    public void testAttachCallingThreadStackAddExceptionsToEachOther() {\n+        CompositeException.attachCallingThreadStack(ex1, ex2);\n+        CompositeException.attachCallingThreadStack(ex2, ex1);\n+        assertEquals(\"Ex2\", ex1.getCause().getMessage());\n+        assertEquals(\"Ex1\", ex2.getCause().getMessage());\n+    }\n }\n\\ No newline at end of file",
    "output": "Add more possible failure cases to CompositeExceptionTest"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/util/CompositeException.java b/rxjava-core/src/main/java/rx/util/CompositeException.java\n--- a/rxjava-core/src/main/java/rx/util/CompositeException.java\n+++ b/rxjava-core/src/main/java/rx/util/CompositeException.java\n@@ -18,7 +18,9 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n \n /**\n  * Exception that is a composite of 1 or more other exceptions.\n@@ -84,9 +86,16 @@ private static String getStackTraceAsString(StackTraceElement[] stack) {\n         return s.toString();\n     }\n \n-    private static void attachCallingThreadStack(Throwable e, Throwable cause) {\n+    /* package-private */ static void attachCallingThreadStack(Throwable e, Throwable cause) {\n+        Set<Throwable> seenCauses = new HashSet<Throwable>();\n+\n         while (e.getCause() != null) {\n             e = e.getCause();\n+            if (seenCauses.contains(e.getCause())) {\n+                break;\n+            } else {\n+                seenCauses.add(e.getCause());\n+            }\n         }\n         // we now have 'e' as the last in the chain\n         try {\n@@ -98,12 +107,13 @@ private static void attachCallingThreadStack(Throwable e, Throwable cause) {\n         }\n     }\n \n-    private final static class CompositeExceptionCausalChain extends RuntimeException {\n+    /* package-private */ final static class CompositeExceptionCausalChain extends RuntimeException {\n         private static final long serialVersionUID = 3875212506787802066L;\n+        /* package-private */ static String MESSAGE = \"Chain of Causes for CompositeException In Order Received =>\";\n \n         @Override\n         public String getMessage() {\n-            return \"Chain of Causes for CompositeException In Order Received =>\";\n+            return MESSAGE;\n         }\n     }\n \n\ndiff --git a/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java b/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java\n--- a/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java\n+++ b/rxjava-core/src/test/java/rx/util/CompositeExceptionTest.java\n@@ -0,0 +1,70 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.util;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class CompositeExceptionTest {\n+\n+    private final Throwable ex1 = new Throwable(\"Ex1\");\n+    private final Throwable ex2 = new Throwable(\"Ex2\", ex1);\n+    private final Throwable ex3 = new Throwable(\"Ex3\", ex2);\n+\n+    private final CompositeException compositeEx;\n+\n+    public CompositeExceptionTest() {\n+        List<Throwable> throwables = new ArrayList<Throwable>();\n+        throwables.add(ex1);\n+        throwables.add(ex2);\n+        throwables.add(ex3);\n+        compositeEx = new CompositeException(throwables);\n+    }\n+\n+    @Test\n+    public void testAttachCallingThreadStackParentThenChild() {\n+        CompositeException.attachCallingThreadStack(ex1, ex2);\n+        assertEquals(\"Ex2\", ex1.getCause().getMessage());\n+    }\n+\n+    @Test\n+    public void testAttachCallingThreadStackChildThenParent() {\n+        CompositeException.attachCallingThreadStack(ex2, ex1);\n+        assertEquals(\"Ex1\", ex2.getCause().getMessage());\n+    }\n+\n+    @Test\n+    public void testAttachCallingThreadStackAddComposite() {\n+        CompositeException.attachCallingThreadStack(ex1, compositeEx);\n+        assertEquals(\"Ex2\", ex1.getCause().getMessage());\n+    }\n+\n+    @Test\n+    public void testAttachCallingThreadStackAddToComposite() {\n+        CompositeException.attachCallingThreadStack(compositeEx, ex1);\n+        assertEquals(CompositeException.CompositeExceptionCausalChain.MESSAGE, compositeEx.getCause().getMessage());\n+    }\n+\n+    @Test\n+    public void testAttachCallingThreadStackAddCompositeToItself() {\n+        CompositeException.attachCallingThreadStack(compositeEx, compositeEx);\n+        assertEquals(CompositeException.CompositeExceptionCausalChain.MESSAGE, compositeEx.getCause().getMessage());\n+    }\n+}\n\\ No newline at end of file",
    "output": "Fix issue #799 - Added break to possibly-infinite loop in CompositeException.attachCallingThreadStack"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -6840,6 +6840,10 @@ public final Subscription subscribe(final Action1<? super T> onNext, Scheduler s\n         return subscribeOn(scheduler).subscribe(onNext);\n     }\n \n+    public final Subscription subscribe(final Observer<? super T> observer, Scheduler scheduler) {\n+        return subscribeOn(scheduler).subscribe(observer);\n+    }\n+    \n     public final Subscription subscribe(final Observer<? super T> observer) {\n         return subscribe(new Subscriber<T>() {\n ",
    "output": "Fix Scala Build"
  },
  {
    "input": "diff --git a/rxjava-core/src/perf/java/rx/operators/ObservableBenchmark.java b/rxjava-core/src/perf/java/rx/operators/ObservableBenchmark.java\n--- a/rxjava-core/src/perf/java/rx/operators/ObservableBenchmark.java\n+++ b/rxjava-core/src/perf/java/rx/operators/ObservableBenchmark.java\n@@ -0,0 +1,115 @@\n+package rx.operators;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import rx.Observable;\n+import rx.Observable.OnSubscribe;\n+import rx.Observer;\n+import rx.util.functions.Func1;\n+\n+import com.google.caliper.Benchmark;\n+import com.google.caliper.runner.CaliperMain;\n+\n+public class ObservableBenchmark extends Benchmark {\n+    public void timeBaseline(int reps) {\n+        for (int i = 0; i < reps; i++) {\n+            observableOfInts.subscribe(newObserver());\n+        }\n+        awaitAllObservers();\n+    }\n+\n+    public int timeMapIterate(long reps) {\n+        int x = 0;\n+        for (int i = 0; i < reps; i++) {\n+            for (int j = 0; j < intValues.length; j++) {\n+                // use hash code to make sure the JIT doesn't optimize too much and remove all of\n+                // our code.\n+                x |= ident.call(intValues[j]).hashCode();\n+            }\n+        }\n+        return x;\n+    }\n+\n+    public void timeMap(long reps) {\n+        timeOperator(reps, new OperatorMap<Integer, Object>(ident));\n+    }\n+\n+    /**************************************************************************\n+     * Below is internal stuff to avoid object allocation and time overhead of anything that isn't\n+     * being tested.\n+     **************************************************************************/\n+\n+    public static void main(String[] args) {\n+        CaliperMain.main(ObservableBenchmark.class, args);\n+    }\n+\n+    private void timeOperator(long reps, Operator<Object, Integer> op) {\n+        for (int i = 0; i < reps; i++) {\n+            observableOfInts.lift(op).subscribe(newObserver());\n+        }\n+        awaitAllObservers();\n+    }\n+\n+    private final static AtomicInteger outstanding = new AtomicInteger(0);\n+    private final static CountDownLatch latch = new CountDownLatch(1);\n+\n+    private static <T> Observer<T> newObserver() {\n+        outstanding.incrementAndGet();\n+        return new Observer<T>() {\n+            @Override\n+            public void onCompleted() {\n+                int left = outstanding.decrementAndGet();\n+                if (left == 0) {\n+                    latch.countDown();\n+                }\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                int left = outstanding.decrementAndGet();\n+                if (left == 0) {\n+                    latch.countDown();\n+                }\n+            }\n+\n+            @Override\n+            public void onNext(T t) {\n+                // do nothing\n+            }\n+        };\n+    }\n+\n+    private static void awaitAllObservers() {\n+        try {\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            return;\n+        }\n+    }\n+\n+    private static final Integer[] intValues = new Integer[1000];\n+    static {\n+        for (int i = 0; i < intValues.length; i++) {\n+            intValues[i] = i;\n+        }\n+    }\n+\n+    private static final Observable<Integer> observableOfInts = Observable.create(new OnSubscribe<Integer>() {\n+        @Override\n+        public void call(Observer<? super Integer> o) {\n+            for (int i = 0; i < intValues.length; i++) {\n+                if (o.isUnsubscribed())\n+                    return;\n+                o.onNext(intValues[i]);\n+            }\n+            o.onCompleted();\n+        }\n+    });\n+    private static final Func1<Integer, Object> ident = new Func1<Integer, Object>() {\n+        @Override\n+        public Object call(Integer t) {\n+            return t;\n+        }\n+    };\n+}",
    "output": "Add the first of the perf tests"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/operators/OperationConditionals.java b/rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/operators/OperationConditionals.java\n--- a/rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/operators/OperationConditionals.java\n+++ b/rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/operators/OperationConditionals.java\n@@ -21,6 +21,7 @@\n import rx.Observable.OnSubscribeFunc;\n import rx.Observer;\n import rx.Subscription;\n+import rx.subscriptions.MultipleAssignmentSubscription;\n import rx.subscriptions.SerialSubscription;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Func0;\n@@ -231,7 +232,7 @@ public Subscription onSubscribe(Observer<? super T> t1) {\n                 return Subscriptions.empty();\n             }\n             if (first) {\n-                SerialSubscription ssub = new SerialSubscription();\n+                MultipleAssignmentSubscription ssub = new MultipleAssignmentSubscription();\n \n                 ssub.set(source.subscribe(new SourceObserver(t1, ssub)));\n \n@@ -244,10 +245,10 @@ public Subscription onSubscribe(Observer<? super T> t1) {\n \n         /** Observe the source. */\n         final class SourceObserver extends Observer<T> {\n-            final SerialSubscription cancel;\n+            final MultipleAssignmentSubscription cancel;\n             final Observer<? super T> observer;\n \n-            public SourceObserver(Observer<? super T> observer, SerialSubscription cancel) {\n+            public SourceObserver(Observer<? super T> observer, MultipleAssignmentSubscription cancel) {\n                 this.observer = observer;\n                 this.cancel = cancel;\n             }\n\ndiff --git a/rxjava-contrib/rxjava-computation-expressions/src/test/java/rx/operators/OperationConditionalsTest.java b/rxjava-contrib/rxjava-computation-expressions/src/test/java/rx/operators/OperationConditionalsTest.java\n--- a/rxjava-contrib/rxjava-computation-expressions/src/test/java/rx/operators/OperationConditionalsTest.java\n+++ b/rxjava-contrib/rxjava-computation-expressions/src/test/java/rx/operators/OperationConditionalsTest.java\n@@ -403,7 +403,6 @@ public Boolean call() {\n \n     @Test\n     public void testDoWhileManyTimes() {\n-        fail(\"deadlocking\");\n         Observable<Integer> source1 = Observable.from(1, 2, 3).subscribeOn(Schedulers.currentThread());\n \n         List<Integer> expected = new ArrayList<Integer>(numRecursion * 3);",
    "output": "Fix OperationalConditional\n\nAll unit tests now pass"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observer.java b/rxjava-core/src/main/java/rx/Observer.java\n--- a/rxjava-core/src/main/java/rx/Observer.java\n+++ b/rxjava-core/src/main/java/rx/Observer.java\n@@ -20,9 +20,9 @@\n /**\n  * Provides a mechanism for receiving push-based notifications.\n  * <p>\n- * After an Observer calls an {@link Observable}'s <code>Observable.subscribe</code> method, the {@link Observable} calls the Observer's <code>onNext</code> method to provide notifications. A\n- * well-behaved {@link Observable} will\n- * call an Observer's <code>onCompleted</code> closure exactly once or the Observer's <code>onError</code> closure exactly once.\n+ * After an Observer calls an {@link Observable}'s <code>Observable.subscribe</code> method, the {@link Observable} calls the \n+ * Observer's <code>onNext</code> method to provide notifications. A well-behaved {@link Observable} will call an Observer's \n+ * <code>onCompleted</code> closure exactly once or the Observer's <code>onError</code> closure exactly once.\n  * <p>\n  * For more information see the <a href=\"https://github.com/Netflix/RxJava/wiki/Observable\">RxJava Wiki</a>\n  * \n@@ -34,7 +34,7 @@ public abstract class Observer<T> implements Subscription {\n \n     protected Observer(CompositeSubscription cs) {\n         if (cs == null) {\n-            throw new IllegalArgumentException(\"The CompositeException can not be null\");\n+            throw new IllegalArgumentException(\"The CompositeSubscription can not be null\");\n         }\n         this.cs = cs;\n     }",
    "output": "Fix Typo: s/CompositeException/CompositeSubscription"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n@@ -96,19 +96,19 @@ protected static <T> void emitValueToObserver(Notification<T> n, Observer<? supe\n         }\n     }\n \n-    private final OnSubscribe<T> onSubscribe;\n     private final SubjectSubscriptionManager<T> subscriptionManager;\n     final AtomicReference<Notification<T>> lastNotification;\n+    private final Observable<T> observable;\n \n     protected AsyncSubject(OnSubscribe<T> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, AtomicReference<Notification<T>> lastNotification) {\n-        this.onSubscribe = onSubscribe;\n         this.subscriptionManager = subscriptionManager;\n         this.lastNotification = lastNotification;\n+        this.observable = Observable.create(onSubscribe);\n     }\n \n     @Override\n     public Observable<T> toObservable() {\n-        return Observable.create(onSubscribe);\n+        return observable;\n     }\n \n     @Override\n@@ -130,7 +130,7 @@ public void onError(final Throwable e) {\n \n             @Override\n             public void call(Collection<SubjectObserver<? super T>> observers) {\n-                lastNotification.set(new Notification<T>(e));\n+                lastNotification.set(Notification.<T>createOnError(e));\n                 for (Observer<? super T> o : observers) {\n                     emitValueToObserver(lastNotification.get(), o);\n                 }\n@@ -141,7 +141,7 @@ public void call(Collection<SubjectObserver<? super T>> observers) {\n \n     @Override\n     public void onNext(T v) {\n-        lastNotification.set(new Notification<T>(v));\n+        lastNotification.set(Notification.<T>createOnNext(v));\n     }\n \n }\n\ndiff --git a/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java\n@@ -119,19 +119,19 @@ public void call(SubjectObserver<? super T> o) {\n         return new BehaviorSubject<T>(onSubscribe, subscriptionManager, lastNotification);\n     }\n \n-    private final OnSubscribe<T> onSubscribe;\n     private final SubjectSubscriptionManager<T> subscriptionManager;\n     final AtomicReference<Notification<T>> lastNotification;\n+    private final Observable<T> observable;\n \n     protected BehaviorSubject(OnSubscribe<T> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, AtomicReference<Notification<T>> lastNotification) {\n-        this.onSubscribe = onSubscribe;\n         this.subscriptionManager = subscriptionManager;\n         this.lastNotification = lastNotification;\n+        this.observable = Observable.create(onSubscribe);\n     }\n \n     @Override\n     public Observable<T> toObservable() {\n-        return Observable.create(onSubscribe);\n+        return observable;\n     }\n \n     @Override\n@@ -140,7 +140,7 @@ public void onCompleted() {\n \n             @Override\n             public void call(Collection<SubjectObserver<? super T>> observers) {\n-                lastNotification.set(new Notification<T>());\n+                lastNotification.set(Notification.<T>createOnCompleted());\n                 for (Observer<? super T> o : observers) {\n                     o.onCompleted();\n                 }\n@@ -154,7 +154,7 @@ public void onError(final Throwable e) {\n \n             @Override\n             public void call(Collection<SubjectObserver<? super T>> observers) {\n-                lastNotification.set(new Notification<T>(e));\n+                lastNotification.set(Notification.<T>createOnError(e));\n                 for (Observer<? super T> o : observers) {\n                     o.onError(e);\n                 }\n@@ -168,7 +168,7 @@ public void onNext(T v) {\n         // do not overwrite a terminal notification\n         // so new subscribers can get them\n         if (lastNotification.get().isOnNext()) {\n-            lastNotification.set(new Notification<T>(v));\n+            lastNotification.set(Notification.<T>createOnNext(v));\n             for (Observer<? super T> o : subscriptionManager.rawSnapshot()) {\n                 o.onNext(v);\n             }\n\ndiff --git a/rxjava-core/src/main/java/rx/subjects/PublishSubject.java b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n@@ -86,19 +86,19 @@ public void call(SubjectObserver<? super T> o) {\n         return new PublishSubject<T>(onSubscribe, subscriptionManager, lastNotification);\n     }\n \n-    private final OnSubscribe<T> onSubscribe;\n     private final SubjectSubscriptionManager<T> subscriptionManager;\n     final AtomicReference<Notification<T>> lastNotification;\n+    private final Observable<T> observable;\n \n     protected PublishSubject(OnSubscribe<T> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, AtomicReference<Notification<T>> lastNotification) {\n-        this.onSubscribe = onSubscribe;\n         this.subscriptionManager = subscriptionManager;\n         this.lastNotification = lastNotification;\n+        this.observable = Observable.create(onSubscribe);\n     }\n \n     @Override\n     public Observable<T> toObservable() {\n-        return Observable.create(onSubscribe);\n+        return observable;\n     }\n \n     @Override\n@@ -107,7 +107,7 @@ public void onCompleted() {\n \n             @Override\n             public void call(Collection<SubjectObserver<? super T>> observers) {\n-                lastNotification.set(new Notification<T>());\n+                lastNotification.set(Notification.<T>createOnCompleted());\n                 for (Observer<? super T> o : observers) {\n                     o.onCompleted();\n                 }\n@@ -121,7 +121,7 @@ public void onError(final Throwable e) {\n \n             @Override\n             public void call(Collection<SubjectObserver<? super T>> observers) {\n-                lastNotification.set(new Notification<T>(e));\n+                lastNotification.set(Notification.<T>createOnError(e));\n                 for (Observer<? super T> o : observers) {\n                     o.onError(e);\n                 }\n\ndiff --git a/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java b/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n@@ -108,17 +108,17 @@ public ReplayState(int initialCapacity) {\n \n     private final SubjectSubscriptionManager<T> subscriptionManager;\n     private final ReplayState<T> state;\n-    private final OnSubscribe<T> onSubscribe;\n+    private final Observable<T> observable;\n \n     protected ReplaySubject(OnSubscribe<T> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, ReplayState<T> state) {\n-        this.onSubscribe = onSubscribe;\n         this.subscriptionManager = subscriptionManager;\n         this.state = state;\n+        this.observable = Observable.create(onSubscribe);\n     }\n \n     @Override\n     public Observable<T> toObservable() {\n-        return Observable.create(onSubscribe);\n+        return observable;\n     }\n \n     @Override\n@@ -127,7 +127,7 @@ public void onCompleted() {\n \n             @Override\n             public void call(Collection<SubjectObserver<? super T>> observers) {\n-                state.history.complete(new Notification<T>());\n+                state.history.complete(Notification.<T>createOnCompleted());\n                 for (SubjectObserver<? super T> o : observers) {\n                     if (caughtUp(o)) {\n                         o.onCompleted();\n@@ -143,7 +143,7 @@ public void onError(final Throwable e) {\n \n             @Override\n             public void call(Collection<SubjectObserver<? super T>> observers) {\n-                state.history.complete(new Notification<T>(e));\n+                state.history.complete(Notification.<T>createOnError(e));\n                 for (SubjectObserver<? super T> o : observers) {\n                     if (caughtUp(o)) {\n                         o.onError(e);",
    "output": "Fix Subject.toObservable\n\n- now correctly creates only 1 Observable instance for the life of the Subject\n- this fixes the OperationJoinsTest\n- thanks @akarnokd for pointing out my mistake!\n- all rxjava-core unit tests are now passing"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n--- a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n+++ b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n@@ -24,6 +24,7 @@\n import rx.Observer;\n import rx.Subscription;\n import rx.operators.SafeObservableSubscription;\n+import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action1;\n \n /* package */class SubjectSubscriptionManager<T> {\n@@ -51,10 +52,12 @@ public void call(Observer<? super T> actualObserver) {\n                 State<T> current;\n                 State<T> newState = null;\n                 boolean addedObserver = false;\n+                Subscription s;\n                 do {\n                     current = state.get();\n                     if (current.terminated) {\n                         // we are terminated so don't need to do anything\n+                        s = Subscriptions.empty();\n                         addedObserver = false;\n                         // break out and don't try to modify state\n                         newState = current;\n@@ -67,24 +70,22 @@ public void call(Observer<? super T> actualObserver) {\n                         }\n                         break;\n                     } else {\n-                        final SafeObservableSubscription subscription = new SafeObservableSubscription();\n-                        actualObserver.add(subscription); // add to parent if the Subject itself is unsubscribed\n                         addedObserver = true;\n-                        subscription.wrap(new Subscription() {\n+                        s = new Subscription() {\n                             @Override\n                             public void unsubscribe() {\n                                 State<T> current;\n                                 State<T> newState;\n                                 do {\n                                     current = state.get();\n                                     // on unsubscribe remove it from the map of outbound observers to notify\n-                                    newState = current.removeObserver(subscription);\n+                                    newState = current.removeObserver(this);\n                                 } while (!state.compareAndSet(current, newState));\n                             }\n-                        });\n+                        };\n \n                         // on subscribe add it to the map of outbound observers to notify\n-                        newState = current.addObserver(subscription, observer);\n+                        newState = current.addObserver(s, observer);\n                     }\n                 } while (!state.compareAndSet(current, newState));\n \n@@ -94,12 +95,13 @@ public void unsubscribe() {\n                 if (newState.terminated && !addedObserver) {\n                     onTerminated.call(observer);\n                 }\n+\n+                actualObserver.add(s);\n             }\n \n         };\n     }\n \n-    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     protected void terminate(Action1<Collection<SubjectObserver<? super T>>> onTerminate) {\n         State<T> current;\n         State<T> newState = null;\n@@ -134,7 +136,6 @@ protected void terminate(Action1<Collection<SubjectObserver<? super T>>> onTermi\n      * \n      * @return the array of current observers\n      */\n-    @SuppressWarnings(\"unchecked\")\n     public SubjectObserver<Object>[] rawSnapshot() {\n         return state.get().observers;\n     }\n@@ -231,6 +232,7 @@ protected static class SubjectObserver<T> extends Observer<T> {\n         protected volatile boolean caughtUp = false;\n \n         SubjectObserver(Observer<? super T> actual) {\n+            super(actual);\n             this.actual = actual;\n         }\n \n@@ -251,4 +253,4 @@ public void onNext(T v) {\n \n     }\n \n-}\n+}\n\\ No newline at end of file",
    "output": "Fix Subject SubscriptionManager\n\nRemove possibility of infinite loop"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationZip.java b/rxjava-core/src/main/java/rx/operators/OperationZip.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationZip.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationZip.java\n@@ -103,8 +103,7 @@ public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> OnSubscribeFunc<R> zip(Obs\n     }\n \n     public static <R> OnSubscribeFunc<R> zip(Iterable<? extends Observable<?>> ws, final FuncN<? extends R> zipFunction) {\n-        ManyObservables<?, R> a = new ManyObservables<Object, R>(ws, zipFunction);\n-        return a;\n+        return new ManyObservables<Object, R>(ws, zipFunction);\n     }\n \n     /**\n@@ -246,7 +245,6 @@ public ItemObserver(\n                 this.cancel = cancel;\n             }\n \n-            @SuppressWarnings(\"unchecked\")\n             @Override\n             public void onNext(T value) {\n                 rwLock.readLock().lock();\n@@ -258,43 +256,7 @@ public void onNext(T value) {\n                 } finally {\n                     rwLock.readLock().unlock();\n                 }\n-                // run collector\n-                if (rwLock.writeLock().tryLock()) {\n-                    boolean cu = false;\n-                    try {\n-                        while (true) {\n-                            List<T> values = new ArrayList<T>(all.size());\n-                            for (ItemObserver<T> io : all) {\n-                                if (io.queue.isEmpty()) {\n-                                    if (io.done) {\n-                                        observer.onCompleted();\n-                                        cu = true;\n-                                        return;\n-                                    }\n-                                    continue;\n-                                }\n-                                Object v = io.queue.peek();\n-                                if (v == NULL_SENTINEL) {\n-                                    v = null;\n-                                }\n-                                values.add((T) v);\n-                            }\n-                            if (values.size() == all.size()) {\n-                                for (ItemObserver<T> io : all) {\n-                                    io.queue.poll();\n-                                }\n-                                observer.onNext(values);\n-                            } else {\n-                                break;\n-                            }\n-                        }\n-                    } finally {\n-                        rwLock.writeLock().unlock();\n-                        if (cu) {\n-                            cancel.unsubscribe();\n-                        }\n-                    }\n-                }\n+                runCollector();\n             }\n \n             @Override\n@@ -321,23 +283,7 @@ public void onCompleted() {\n                 } finally {\n                     rwLock.readLock().unlock();\n                 }\n-                if (rwLock.writeLock().tryLock()) {\n-                    boolean cu = false;\n-                    try {\n-                        for (ItemObserver<T> io : all) {\n-                            if (io.queue.isEmpty() && io.done) {\n-                                observer.onCompleted();\n-                                cu = true;\n-                                return;\n-                            }\n-                        }\n-                    } finally {\n-                        rwLock.writeLock().unlock();\n-                        if (cu) {\n-                            cancel.unsubscribe();\n-                        }\n-                    }\n-                }\n+                runCollector();\n                 unsubscribe();\n             }\n \n@@ -351,6 +297,45 @@ public void unsubscribe() {\n                 toSource.unsubscribe();\n             }\n \n+            @SuppressWarnings(\"unchecked\")\n+            private void runCollector() {\n+                if (rwLock.writeLock().tryLock()) {\n+                    boolean cu = false;\n+                    try {\n+                        while (true) {\n+                            List<T> values = new ArrayList<T>(all.size());\n+                            for (ItemObserver<T> io : all) {\n+                                if (io.queue.isEmpty()) {\n+                                    if (io.done) {\n+                                        observer.onCompleted();\n+                                        cu = true;\n+                                        return;\n+                                    }\n+                                    continue;\n+                                }\n+                                Object v = io.queue.peek();\n+                                if (v == NULL_SENTINEL) {\n+                                    v = null;\n+                                }\n+                                values.add((T) v);\n+                            }\n+                            if (values.size() == all.size()) {\n+                                for (ItemObserver<T> io : all) {\n+                                    io.queue.poll();\n+                                }\n+                                observer.onNext(values);\n+                            } else {\n+                                break;\n+                            }\n+                        }\n+                    } finally {\n+                        rwLock.writeLock().unlock();\n+                        if (cu) {\n+                            cancel.unsubscribe();\n+                        }\n+                    }\n+                }\n+            }\n         }\n     }\n ",
    "output": "Fix Zip race condition\n\nItemObserver onNext might not acquire the write lock due to an\nonCompleted being handled by another thread. When handling\nonCompleted, the ItemObserver does not check for any values that are\nready to be emitted, which might cause OperationZip to never emit\nOnNext or OnCompleted"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationNext.java b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationNext.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n@@ -48,7 +48,8 @@ public Iterator<T> iterator() {\n \n     }\n \n-    private static class NextIterator<T> implements Iterator<T> {\n+    // test needs to access the observer.waiting flag non-blockingly.\n+    /* private */static final class NextIterator<T> implements Iterator<T> {\n \n         private final NextObserver<? extends T> observer;\n         private T next;\n@@ -60,6 +61,12 @@ private NextIterator(NextObserver<? extends T> observer) {\n             this.observer = observer;\n         }\n \n+        // in tests, set the waiting flag without blocking for the next value to \n+        // allow lockstepping instead of multi-threading\n+        void setWaiting(boolean value) {\n+            observer.waiting.set(value);\n+        }\n+        \n         @Override\n         public boolean hasNext() {\n             if (error != null) {\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperationNextTest.java b/rxjava-core/src/test/java/rx/operators/OperationNextTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationNextTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationNextTest.java\n@@ -296,24 +296,27 @@ public void run() {\n         System.out.println(\"a: \" + a + \" b: \" + b + \" c: \" + c);\n     }\n \n-    @Test(timeout = 8000)\n+    @Test /* (timeout = 8000) */\n     public void testSingleSourceManyIterators() throws InterruptedException {\n-        BlockingObservable<Long> source = Observable.interval(200, TimeUnit.MILLISECONDS).take(10).toBlockingObservable();\n+        PublishSubject<Long> ps = PublishSubject.create();\n+        BlockingObservable<Long> source = ps.take(10).toBlockingObservable();\n \n         Iterable<Long> iter = source.next();\n \n         for (int j = 0; j < 3; j++) {\n-            Iterator<Long> it = iter.iterator();\n+            OperationNext.NextIterator<Long> it = (OperationNext.NextIterator<Long>)iter.iterator();\n \n-            for (int i = 0; i < 9; i++) {\n+            for (long i = 0; i < 9; i++) {\n                 // hasNext has to set the waiting to true, otherwise, all onNext will be skipped\n+                it.setWaiting(true);\n+                ps.onNext(i);\n                 Assert.assertEquals(true, it.hasNext());\n-                Assert.assertEquals(Long.valueOf(i), it.next());\n+                Assert.assertEquals(j + \"th iteration\", Long.valueOf(i), it.next());\n             }\n+            it.setWaiting(true);\n+            ps.onNext(9L);\n \n-            Thread.sleep(400);\n-\n-            Assert.assertEquals(false, it.hasNext());\n+            Assert.assertEquals(j + \"th iteration\", false, it.hasNext());\n         }\n \n     }",
    "output": "Fix testSingleSourceManyIterators"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperationObserveFromAndroidComponentTest.java b/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperationObserveFromAndroidComponentTest.java\n--- a/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperationObserveFromAndroidComponentTest.java\n+++ b/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperationObserveFromAndroidComponentTest.java\n@@ -1,55 +1,54 @@\n /**\n  * Copyright 2013 Netflix, Inc.\n- *\n+ * \n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package rx.operators;\n+package rx.android.operators;\n \n-import static org.mockito.Matchers.any;\n-import static org.mockito.Matchers.anyInt;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyNoMoreInteractions;\n-import static org.mockito.Mockito.when;\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.Before;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n-import static org.junit.Assert.*;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.annotation.Config;\n \n import rx.Observable;\n+import rx.Observable.OnSubscribeFunc;\n import rx.Observer;\n import rx.Subscription;\n import rx.android.schedulers.AndroidSchedulers;\n+import rx.operators.OperationObserveFromAndroidComponent;\n+import rx.schedulers.Schedulers;\n import rx.subjects.PublishSubject;\n+import rx.subscriptions.BooleanSubscription;\n+import rx.util.functions.Action1;\n import android.app.Activity;\n import android.app.Fragment;\n-import android.os.Looper;\n-import android.util.Log;\n-\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n \n @RunWith(RobolectricTestRunner.class)\n @Config(manifest = Config.NONE)\n@@ -64,9 +63,6 @@ public class OperationObserveFromAndroidComponentTest {\n     @Mock\n     private Activity mockActivity;\n \n-    @Mock\n-    private Observable<Integer> mockObservable;\n-\n     @Before\n     public void setupMocks() {\n         MockitoAnnotations.initMocks(this);\n@@ -75,11 +71,12 @@ public void setupMocks() {\n \n     @Test\n     public void itThrowsIfObserverSubscribesFromBackgroundThread() throws Exception {\n+        final Observable<Integer> testObservable = Observable.from(1);\n         final Future<Object> future = Executors.newSingleThreadExecutor().submit(new Callable<Object>() {\n             @Override\n             public Object call() throws Exception {\n                 OperationObserveFromAndroidComponent.observeFromAndroidComponent(\n-                        mockObservable, mockFragment).subscribe(mockObserver);\n+                        testObservable, mockFragment).subscribe(mockObserver);\n                 return null;\n             }\n         });\n@@ -88,10 +85,44 @@ public Object call() throws Exception {\n         verifyNoMoreInteractions(mockObserver);\n     }\n \n-    @Test\n+    // TODO needs to be fixed, see comments inline below\n+    @Ignore\n     public void itObservesTheSourceSequenceOnTheMainUIThread() {\n-        OperationObserveFromAndroidComponent.observeFromAndroidComponent(mockObservable, mockFragment).subscribe(mockObserver);\n-        verify(mockObservable).observeOn(AndroidSchedulers.mainThread());\n+        final Observable<Integer> testObservable = Observable.from(1)\n+                .observeOn(Schedulers.newThread())\n+                .doOnNext(new Action1<Integer>() {\n+\n+                    @Override\n+                    public void call(Integer t1) {\n+                        System.out.println(\"threadA: \" + Thread.currentThread());\n+                    }\n+                })\n+                .observeOn(AndroidSchedulers.mainThread())\n+                .doOnNext(new Action1<Integer>() {\n+\n+                    @Override\n+                    public void call(Integer t1) {\n+                        System.out.println(\"threadB: \" + Thread.currentThread());\n+                    }\n+                });\n+\n+        final AtomicReference<String> currentThreadName = new AtomicReference<String>();\n+        OperationObserveFromAndroidComponent.observeFromAndroidComponent(testObservable, mockFragment).subscribe(new Action1<Integer>() {\n+\n+            @Override\n+            public void call(Integer i) {\n+                System.out.println(\"threadV: \" + Thread.currentThread());\n+                currentThreadName.set(Thread.currentThread().getName());\n+            }\n+        });\n+\n+        assertEquals(\"androidMainThreadName???\", currentThreadName.get());\n+\n+        //TODO Can't use Mockito to validate Observable.observeOn as it is now marked as final.\n+        //     I can't figure out what to validate about the AndroidSchedulers.mainThread()\n+        //     as the code above doesn't print `threadB` so I can't see what Thread it should be.\n+        //     I was going to run it on NewThread then observeOn to AndroidThread and validate it jumped\n+        //     to the correct thread, but it doesn't do anything. Need to work with Android devs.\n     }\n \n     @Test\n@@ -147,7 +178,7 @@ public void itDropsOnErrorIfTargetComponentIsGone() throws Throwable {\n         verifyNoMoreInteractions(mockObserver);\n     }\n \n-    private Observable.OnSubscribeFunc<Integer> newOnSubscribeFragmentInstance(Observable<Integer> source, Fragment fragment) throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException  {\n+    private Observable.OnSubscribeFunc<Integer> newOnSubscribeFragmentInstance(Observable<Integer> source, Fragment fragment) throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException {\n         final Class[] klasses = OperationObserveFromAndroidComponent.class.getDeclaredClasses();\n         Class onSubscribeFragmentClass = null;\n         for (Class klass : klasses) {\n@@ -200,14 +231,23 @@ public void itDoesNotForwardOnErrorIfFragmentIsDetached() {\n \n     @Test\n     public void itUnsubscribesFromTheSourceSequence() {\n-        Subscription underlying = mock(Subscription.class);\n-        when(mockObservable.observeOn(AndroidSchedulers.mainThread())).thenReturn(mockObservable);\n-        when(mockObservable.subscribe(any(Observer.class))).thenReturn(underlying);\n+        final BooleanSubscription s = new BooleanSubscription();\n+        Observable<Integer> testObservable = Observable.create(new OnSubscribeFunc<Integer>() {\n+\n+            @Override\n+            public Subscription onSubscribe(Observer<? super Integer> o) {\n+                o.onNext(1);\n+                o.onCompleted();\n+                return s;\n+            }\n+\n+        });\n \n         Subscription sub = OperationObserveFromAndroidComponent.observeFromAndroidComponent(\n-                mockObservable, mockActivity).subscribe(mockObserver);\n+                testObservable, mockActivity).subscribe(mockObserver);\n         sub.unsubscribe();\n \n-        verify(underlying).unsubscribe();\n+        assertTrue(s.isUnsubscribed());\n     }\n+\n }\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationGroupByUntil.java b/rxjava-core/src/main/java/rx/operators/OperationGroupByUntil.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationGroupByUntil.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationGroupByUntil.java\n@@ -207,29 +207,20 @@ public void onCompleted() {\n         }\n     }\n \n-    protected static <T> OnSubscribeFunc<T> neverSubscribe() {\n-        return new OnSubscribeFunc<T>() {\n-            @Override\n-            public Subscription onSubscribe(Observer<? super T> t1) {\n-                return Subscriptions.empty();\n-            }\n-        };\n-    }\n-\n     /** A grouped observable with subject-like behavior. */\n     public static class GroupSubject<K, V> extends GroupedObservable<K, V> implements Observer<V> {\n         protected final Subject<V, V> publish;\n \n-        public GroupSubject(K key, Subject<V, V> publish) {\n-            super(key, OperationGroupByUntil.<V> neverSubscribe());\n+        public GroupSubject(K key, final Subject<V, V> publish) {\n+            super(key, new OnSubscribeFunc<V>() {\n+                @Override\n+                public Subscription onSubscribe(Observer<? super V> o) {\n+                    return publish.subscribe(o);\n+                }\n+            });\n             this.publish = publish;\n         }\n \n-        @Override\n-        public Subscription subscribe(Observer<? super V> observer) {\n-            return publish.subscribe(observer);\n-        }\n-\n         @Override\n         public void onNext(V args) {\n             publish.onNext(args);",
    "output": "Make Observable Methods Final\n\nTheir behavior is interrelated and co-dependent and should therefore not be over-written.\nObservable itself is not made final as there are some limited reasons for inheritance (such as GroupedObservable and Subjects)"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationSwitch.java b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationSwitch.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java\n@@ -126,13 +126,12 @@ public void onCompleted() {\n                         sub.unsubscribe();\n                         if (latest == id) {\n                             SwitchObserver.this.hasLatest = false;\n-                        }\n \n-                        if (stopped) {\n-                            SwitchObserver.this.observer.onCompleted();\n-                            SwitchObserver.this.parent.unsubscribe();\n+                            if (stopped) {\n+                                SwitchObserver.this.observer.onCompleted();\n+                                SwitchObserver.this.parent.unsubscribe();\n+                            }\n                         }\n-\n                     }\n                 }\n \n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperationSwitchTest.java b/rxjava-core/src/test/java/rx/operators/OperationSwitchTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationSwitchTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationSwitchTest.java\n@@ -380,4 +380,51 @@ public void call() {\n     @SuppressWarnings(\"serial\")\n     private class TestException extends Throwable {\n     }\n+\n+    @Test\n+    public void testSwitchIssue737() {\n+        // https://github.com/Netflix/RxJava/issues/737\n+        Observable<Observable<String>> source = Observable.create(new Observable.OnSubscribeFunc<Observable<String>>() {\n+            @Override\n+            public Subscription onSubscribe(Observer<? super Observable<String>> observer) {\n+                publishNext(observer, 0, Observable.create(new Observable.OnSubscribeFunc<String>() {\n+                    @Override\n+                    public Subscription onSubscribe(Observer<? super String> observer) {\n+                        publishNext(observer, 10, \"1-one\");\n+                        publishNext(observer, 20, \"1-two\");\n+                        // The following events will be ignored\n+                        publishNext(observer, 30, \"1-three\");\n+                        publishCompleted(observer, 40);\n+                        return Subscriptions.empty();\n+                    }\n+                }));\n+                publishNext(observer, 25, Observable.create(new Observable.OnSubscribeFunc<String>() {\n+                    @Override\n+                    public Subscription onSubscribe(Observer<? super String> observer) {\n+                        publishNext(observer, 10, \"2-one\");\n+                        publishNext(observer, 20, \"2-two\");\n+                        publishNext(observer, 30, \"2-three\");\n+                        publishCompleted(observer, 40);\n+                        return Subscriptions.empty();\n+                    }\n+                }));\n+                publishCompleted(observer, 30);\n+                return Subscriptions.empty();\n+            }\n+        });\n+\n+        Observable<String> sampled = Observable.create(OperationSwitch.switchDo(source));\n+        sampled.subscribe(observer);\n+\n+        scheduler.advanceTimeTo(1000, TimeUnit.MILLISECONDS);\n+\n+        InOrder inOrder = inOrder(observer);\n+        inOrder.verify(observer, times(1)).onNext(\"1-one\");\n+        inOrder.verify(observer, times(1)).onNext(\"1-two\");\n+        inOrder.verify(observer, times(1)).onNext(\"2-one\");\n+        inOrder.verify(observer, times(1)).onNext(\"2-two\");\n+        inOrder.verify(observer, times(1)).onNext(\"2-three\");\n+        inOrder.verify(observer, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n+    }\n }",
    "output": "Fix issue #737"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -5250,7 +5250,7 @@ public ConnectableObservable<T> publish(T initialValue) {\n      * selector on a connectable observable sequence that shares a single\n      * subscription to the underlying sequence.\n      */\n-    public <R> Observable<R> publish(Func1<Observable<T>, Observable<R>> selector) {\n+    public <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector) {\n         return multicast(new Func0<Subject<T, T>>() {\n             @Override\n             public Subject<T, T> call() {\n@@ -5270,7 +5270,7 @@ public Subject<T, T> call() {\n      * @param initialValue the initial value of the underlying BehaviorSubject\n      * @return an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue\n      */\n-    public <R> Observable<R> publish(Func1<Observable<T>, Observable<R>> selector, final T initialValue) {\n+    public <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector, final T initialValue) {\n         return multicast(new Func0<Subject<T, T>>() {\n             @Override\n             public Subject<T, T> call() {\n@@ -5307,7 +5307,7 @@ public ConnectableObservable<T> publishLast() {\n      * subscription to the underlying sequence containing only the last\n      * notification.\n      */\n-    public <R> Observable<R> publishLast(Func1<Observable<T>, Observable<R>> selector) {\n+    public <R> Observable<R> publishLast(Func1<? super Observable<T>, ? extends Observable<R>> selector) {\n         return multicast(new Func0<Subject<T, T>>() {\n             @Override\n             public Subject<T, T> call() {",
    "output": "Add variance to selector functions"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperationMergeTest.java b/rxjava-core/src/test/java/rx/operators/OperationMergeTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationMergeTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationMergeTest.java\n@@ -21,6 +21,8 @@\n import static rx.operators.OperationMerge.*;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n@@ -35,6 +37,7 @@\n import rx.Observable;\n import rx.Observer;\n import rx.Subscription;\n+import rx.schedulers.Schedulers;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;\n import rx.util.functions.Action1;\n@@ -465,4 +468,85 @@ public void unsubscribe() {\n             };\n         }\n     }\n+\n+    @Test\n+    public void testWhenMaxConcurrentIsOne() {\n+        for (int i = 0; i < 100; i++) {\n+            List<Observable<String>> os = new ArrayList<Observable<String>>();\n+            os.add(Observable.from(\"one\", \"two\", \"three\", \"four\", \"five\").subscribeOn(Schedulers.newThread()));\n+            os.add(Observable.from(\"one\", \"two\", \"three\", \"four\", \"five\").subscribeOn(Schedulers.newThread()));\n+            os.add(Observable.from(\"one\", \"two\", \"three\", \"four\", \"five\").subscribeOn(Schedulers.newThread()));\n+\n+            List<String> expected = Arrays.asList(\"one\", \"two\", \"three\", \"four\", \"five\", \"one\", \"two\", \"three\", \"four\", \"five\", \"one\", \"two\", \"three\", \"four\", \"five\");\n+            Iterator<String> iter = Observable.merge(os, 1).toBlockingObservable().toIterable().iterator();\n+            List<String> actual = new ArrayList<String>();\n+            while(iter.hasNext()) {\n+                actual.add(iter.next());\n+            }\n+            assertEquals(expected, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void testMaxConcurrent() {\n+        for (int times = 0; times < 100; times++) {\n+            int observableCount = 100;\n+            // Test maxConcurrent from 2 to 12\n+            int maxConcurrent = 2 + (times % 10);\n+            AtomicInteger subscriptionCount = new AtomicInteger(0);\n+\n+            List<Observable<String>> os = new ArrayList<Observable<String>>();\n+            List<SubscriptionCheckObservable> scos = new ArrayList<SubscriptionCheckObservable>();\n+            for (int i = 0; i < observableCount; i++) {\n+                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(\n+                        subscriptionCount, maxConcurrent);\n+                scos.add(sco);\n+                os.add(Observable.create(sco).subscribeOn(\n+                        Schedulers.threadPoolForComputation()));\n+            }\n+\n+            Iterator<String> iter = Observable.merge(os, maxConcurrent)\n+                    .toBlockingObservable().toIterable().iterator();\n+            List<String> actual = new ArrayList<String>();\n+            while (iter.hasNext()) {\n+                actual.add(iter.next());\n+            }\n+            assertEquals(5 * observableCount, actual.size());\n+            for (SubscriptionCheckObservable sco : scos) {\n+                assertFalse(sco.failed);\n+            }\n+        }\n+    }\n+\n+    private static class SubscriptionCheckObservable implements\n+            Observable.OnSubscribeFunc<String> {\n+\n+        private final AtomicInteger subscriptionCount;\n+        private final int maxConcurrent;\n+        volatile boolean failed = false;\n+\n+        SubscriptionCheckObservable(AtomicInteger subscriptionCount,\n+                int maxConcurrent) {\n+            this.subscriptionCount = subscriptionCount;\n+            this.maxConcurrent = maxConcurrent;\n+        }\n+\n+        @Override\n+        public Subscription onSubscribe(Observer<? super String> t1) {\n+            if (subscriptionCount.incrementAndGet() > maxConcurrent) {\n+                failed = true;\n+            }\n+            t1.onNext(\"one\");\n+            t1.onNext(\"two\");\n+            t1.onNext(\"three\");\n+            t1.onNext(\"four\");\n+            t1.onNext(\"five\");\n+            // We could not decrement subscriptionCount in the unsubscribe method\n+            // as \"unsubscribe\" is not guaranteed to be called before the next \"subscribe\".\n+            subscriptionCount.decrementAndGet();\n+            t1.onCompleted();\n+            return Subscriptions.empty();\n+        }\n+\n+    }\n }",
    "output": "Add unit tests"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java b/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java\n--- a/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java\n+++ b/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java\n@@ -198,10 +198,11 @@ public String call(String s) {\n         List<String> strings = m.toList().toBlockingObservable().last();\n \n         assertEquals(4, strings.size());\n-        assertEquals(\"names=>a-1\", strings.get(0));\n-        assertEquals(\"names=>b-1\", strings.get(1));\n-        assertEquals(\"names=>a-2\", strings.get(2));\n-        assertEquals(\"names=>b-2\", strings.get(3));\n+        // because flatMap does a merge there is no guarantee of order\n+        assertTrue(strings.contains(\"names=>a-1\"));\n+        assertTrue(strings.contains(\"names=>a-2\"));\n+        assertTrue(strings.contains(\"names=>b-1\"));\n+        assertTrue(strings.contains(\"names=>b-2\"));\n     }\n \n     @SuppressWarnings(\"rawtypes\")",
    "output": "Remove Validation of Ordering\n\n- this test does a flatMap which uses merge which has non-deterministic ordering since the Observable.from can be on a new thread each time"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerConcurrencyTests.java b/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerConcurrencyTests.java\n--- a/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerConcurrencyTests.java\n+++ b/rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerConcurrencyTests.java\n@@ -163,7 +163,7 @@ public Subscription call(Scheduler innerScheduler, Long i) {\n         assertEquals(10, counter.get());\n     }\n \n-    @Test(timeout = 20000)\n+    @Test\n     public void recursionUsingFunc2() throws InterruptedException {\n         final CountDownLatch latch = new CountDownLatch(1);\n         getScheduler().schedule(1L, new Func2<Scheduler, Long, Subscription>() {\n@@ -185,7 +185,7 @@ public Subscription call(Scheduler innerScheduler, Long i) {\n         latch.await();\n     }\n \n-    @Test(timeout = 20000)\n+    @Test\n     public void recursionUsingAction0() throws InterruptedException {\n         final CountDownLatch latch = new CountDownLatch(1);\n         getScheduler().schedule(new Action1<Action0>() {",
    "output": "Remove Timeout on Tests"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/schedulers/CurrentThreadScheduler.java b/rxjava-core/src/main/java/rx/schedulers/CurrentThreadScheduler.java\n--- a/rxjava-core/src/main/java/rx/schedulers/CurrentThreadScheduler.java\n+++ b/rxjava-core/src/main/java/rx/schedulers/CurrentThreadScheduler.java\n@@ -55,18 +55,18 @@ protected Boolean initialValue() {\n     public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action) {\n         // immediately move to the InnerCurrentThreadScheduler\n         InnerCurrentThreadScheduler innerScheduler = new InnerCurrentThreadScheduler();\n-        innerScheduler.enqueue(new DiscardableAction<T>(state, action), now());\n+        innerScheduler.schedule(state, action);\n         enqueueFromOuter(innerScheduler, now());\n         return innerScheduler;\n     }\n \n     @Override\n-    public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action, long dueTime, TimeUnit unit) {\n-        long execTime = now() + unit.toMillis(dueTime);\n+    public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action, long delayTime, TimeUnit unit) {\n+        long execTime = now() + unit.toMillis(delayTime);\n \n         // create an inner scheduler and queue it for execution\n         InnerCurrentThreadScheduler innerScheduler = new InnerCurrentThreadScheduler();\n-        innerScheduler.enqueue(new DiscardableAction<T>(state, new SleepingAction<T>(action, this, execTime)), execTime);\n+        innerScheduler.schedule(state, action, delayTime, unit);\n         enqueueFromOuter(innerScheduler, execTime);\n         return innerScheduler;\n     }\n@@ -113,7 +113,7 @@ public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ?\n         public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action, long delayTime, TimeUnit unit) {\n             long execTime = now() + unit.toMillis(delayTime);\n \n-            DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, action);\n+            DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, new SleepingAction<T>(action, this, execTime));\n             childSubscription.set(discardableAction);\n             enqueue(discardableAction, execTime);\n             return childSubscription;",
    "output": "Fix CurrentThreadScheduler Delay Bug\n\n- introduced a bug during refactor, caught it while updating unit tests"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java b/rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java\n--- a/rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java\n+++ b/rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java\n@@ -25,7 +25,9 @@\n import rx.Scheduler;\n import rx.Subscription;\n import rx.subscriptions.CompositeSubscription;\n+import rx.subscriptions.MultipleAssignmentSubscription;\n import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n import rx.util.functions.Func2;\n \n /**\n@@ -46,6 +48,7 @@ private NewThreadScheduler() {\n \n     private static class EventLoopScheduler extends Scheduler {\n         private final ExecutorService executor;\n+        private final MultipleAssignmentSubscription childSubscription = new MultipleAssignmentSubscription();\n \n         private EventLoopScheduler() {\n             executor = Executors.newFixedThreadPool(1, new ThreadFactory() {\n@@ -61,21 +64,30 @@ public Thread newThread(Runnable r) {\n \n         @Override\n         public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action) {\n+            CompositeSubscription s = new CompositeSubscription();\n             final DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, action);\n-            // all subscriptions that may need to be unsubscribed\n-            final CompositeSubscription subscription = new CompositeSubscription(discardableAction);\n-            \n+            s.add(discardableAction);\n+\n             final Scheduler _scheduler = this;\n-            subscription.add(Subscriptions.from(executor.submit(new Runnable() {\n+            s.add(Subscriptions.from(executor.submit(new Runnable() {\n \n                 @Override\n                 public void run() {\n-                    Subscription s = discardableAction.call(_scheduler);\n-                    subscription.add(s);\n+                    discardableAction.call(_scheduler);\n                 }\n             })));\n-            \n-            return subscription;\n+\n+            // replace the EventLoopScheduler child subscription with this one\n+            childSubscription.set(s);\n+            /*\n+             * If `schedule` is run concurrently instead of recursively then we'd lose subscriptions as the `childSubscription`\n+             * only remembers the last one scheduled. However, the parent subscription will shutdown the entire EventLoopScheduler\n+             * and the ExecutorService which will terminate all outstanding tasks so this childSubscription is actually somewhat\n+             * superfluous for stopping and cleanup ... though childSubscription does ensure exactness as can be seen by\n+             * the `testUnSubscribeForScheduler()` unit test which fails if the `childSubscription` does not exist.\n+             */\n+\n+            return childSubscription;\n         }\n \n         @Override\n@@ -103,12 +115,26 @@ public void run() {\n             return subscription;\n         }\n \n+        private void shutdownNow() {\n+            executor.shutdownNow();\n+        }\n+\n     }\n \n     @Override\n     public <T> Subscription schedule(T state, Func2<? super Scheduler, ? super T, ? extends Subscription> action) {\n-        EventLoopScheduler s = new EventLoopScheduler();\n-        return s.schedule(state, action);\n+        final EventLoopScheduler s = new EventLoopScheduler();\n+        CompositeSubscription cs = new CompositeSubscription();\n+        cs.add(s.schedule(state, action));\n+        cs.add(Subscriptions.create(new Action0() {\n+\n+            @Override\n+            public void call() {\n+                // shutdown the executor, all tasks queued to run and clean up resources\n+                s.shutdownNow();\n+            }\n+        }));\n+        return cs;\n     }\n \n     @Override",
    "output": "Fix Memory Leak in NewThreadScheduler Recursion\n\n- the Action0 method did not have a leak\n- the Func2 method on inner scheduler recursion did have a leak"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Scheduler.java b/rxjava-core/src/main/java/rx/Scheduler.java\n--- a/rxjava-core/src/main/java/rx/Scheduler.java\n+++ b/rxjava-core/src/main/java/rx/Scheduler.java\n@@ -165,7 +165,7 @@ public Subscription call(final Scheduler scheduler, final Func2 parentAction) {\n                     @Override\n                     public void call() {\n                         if (!parentSubscription.isUnsubscribed()) {\n-                            childSubscription.setSubscription(scheduler.schedule(parentAction, parentAction));\n+                            childSubscription.set(scheduler.schedule(parentAction, parentAction));\n                         }\n                     }\n ",
    "output": "Fix Deprecated Method Call"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationParallel.java b/rxjava-core/src/main/java/rx/operators/OperationParallel.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationParallel.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationParallel.java\n@@ -46,13 +46,13 @@ public Integer call(T t) {\n                         return i.incrementAndGet() % s.degreeOfParallelism();\n                     }\n \n-                }).flatMap(new Func1<GroupedObservable<Integer, T>, Observable<R>>() {\n+                }).mergeMap(new Func1<GroupedObservable<Integer, T>, Observable<R>>() {\n \n                     @Override\n                     public Observable<R> call(GroupedObservable<Integer, T> group) {\n                         return f.call(group.observeOn(s));\n                     }\n-                }).synchronize();\n+                });\n             }\n         });\n     }",
    "output": "Remove Extra Synchronization\n\nThe use of flatMap/mergeMap already synchronizes"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -6793,7 +6793,7 @@ public void onNext(T args) { }\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach\">RxJava Wiki: doOnNext()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229804.aspx\">MSDN: Observable.Do</a>\n      */\n-    public Observable<T> doOnNext(final Action1<T> onNext) {\n+    public Observable<T> doOnNext(final Action1<? super T> onNext) {\n         Observer<T> observer = new Observer<T>() {\n             @Override\n             public void onCompleted() { }\n@@ -6822,7 +6822,7 @@ public void onNext(T args) {\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach\">RxJava Wiki: doOnEach()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229307.aspx\">MSDN: Observable.Do</a>\n      */\n-    public Observable<T> doOnEach(final Action1<Notification<T>> onNotification) {\n+    public Observable<T> doOnEach(final Action1<Notification<? super T>> onNotification) {\n         Observer<T> observer = new Observer<T>() {\n             @Override\n             public void onCompleted() {\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperationWindowTest.java b/rxjava-core/src/test/java/rx/operators/OperationWindowTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationWindowTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationWindowTest.java\n@@ -50,10 +50,10 @@ private static <T> List<List<T>> toLists(Observable<Observable<T>> observables)\n         final List<List<T>> lists = new ArrayList<List<T>>();\n         Observable.concat(observables.map(new Func1<Observable<T>, Observable<List<T>>>() {\n             @Override\n-            public Observable<List<T>> call(Observable<T> xs) {\n-                return xs.toList();\n-            }\n-        })).toBlockingObservable().forEach(new Action1<List<T>>() {\n+            public Observable<List<T>> call(Observable<T> xs) { return xs.toList(); }\n+        }))\n+                .toBlockingObservable()\n+                .forEach(new Action1<List<T>>() {\n             @Override\n             public void call(List<T> xs) {\n                 lists.add(xs);",
    "output": "Fix Scala bindings"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/joins/JoinObserver1.java b/rxjava-core/src/main/java/rx/joins/JoinObserver1.java\n--- a/rxjava-core/src/main/java/rx/joins/JoinObserver1.java\n+++ b/rxjava-core/src/main/java/rx/joins/JoinObserver1.java\n@@ -23,28 +23,31 @@\n \n import rx.Notification;\n import rx.Observable;\n+import rx.Observer;\n import rx.operators.SafeObservableSubscription;\n+import rx.operators.SafeObserver;\n import rx.util.functions.Action1;\n \n /**\n  * Default implementation of a join observer.\n  */\n-public final class JoinObserver1<T> extends ObserverBase<Notification<T>> implements JoinObserver {\n+public final class JoinObserver1<T> implements Observer<Notification<T>>, JoinObserver {\n     private Object gate;\n     private final Observable<T> source;\n     private final Action1<Throwable> onError;\n     private final List<ActivePlan0> activePlans;\n     private final Queue<Notification<T>> queue;\n-    private final SafeObservableSubscription subscription;\n+    private final SafeObservableSubscription subscription = new SafeObservableSubscription();\n     private volatile boolean done;\n     private final AtomicBoolean subscribed = new AtomicBoolean(false);\n+    private final SafeObserver<Notification<T>> safeObserver;\n     \n     public JoinObserver1(Observable<T> source, Action1<Throwable> onError) {\n         this.source = source;\n         this.onError = onError;\n         queue = new LinkedList<Notification<T>>();\n-        subscription = new SafeObservableSubscription();\n         activePlans = new ArrayList<ActivePlan0>();\n+        safeObserver = new SafeObserver<Notification<T>>(subscription, new InnerObserver());\n     }\n     public Queue<Notification<T>> queue() {\n         return queue;\n@@ -67,35 +70,52 @@ public void dequeue() {\n         queue.remove();\n     }\n \n-    @Override\n-    protected void onNextCore(Notification<T> args) {\n-        synchronized (gate) {\n-            if (!done) {\n-                if (args.isOnError()) {\n-                    onError.call(args.getThrowable());\n-                    return;\n-                }\n-                queue.add(args);\n-                \n-                // remark: activePlans might change while iterating\n-                for (ActivePlan0 a : new ArrayList<ActivePlan0>(activePlans)) {\n-                    a.match();\n+    private final class InnerObserver implements Observer<Notification<T>> {\n+\n+        @Override\n+        public void onNext(Notification<T> args) {\n+            synchronized (gate) {\n+                if (!done) {\n+                    if (args.isOnError()) {\n+                        onError.call(args.getThrowable());\n+                        return;\n+                    }\n+                    queue.add(args);\n+\n+                    // remark: activePlans might change while iterating\n+                    for (ActivePlan0 a : new ArrayList<ActivePlan0>(activePlans)) {\n+                        a.match();\n+                    }\n                 }\n             }\n         }\n+\n+        @Override\n+        public void onError(Throwable e) {\n+            // not expected\n+        }\n+\n+        @Override\n+        public void onCompleted() {\n+            // not expected or ignored\n+        }\n+    }\n+    \n+    @Override\n+    public void onNext(Notification<T> args) {\n+        safeObserver.onNext(args);\n     }\n \n     @Override\n-    protected void onErrorCore(Throwable e) {\n-        // not expected\n+    public void onError(Throwable e) {\n+        safeObserver.onError(e);\n     }\n \n     @Override\n-    protected void onCompletedCore() {\n-        // not expected or ignored\n+    public void onCompleted() {\n+        safeObserver.onCompleted();\n     }\n     \n-    \n     void removeActivePlan(ActivePlan0 activePlan) {\n         activePlans.remove(activePlan);\n         if (activePlans.isEmpty()) {\n\ndiff --git a/rxjava-core/src/main/java/rx/joins/ObserverBase.java b/rxjava-core/src/main/java/rx/joins/ObserverBase.java\n--- a/rxjava-core/src/main/java/rx/joins/ObserverBase.java\n+++ b/rxjava-core/src/main/java/rx/joins/ObserverBase.java\n@@ -1,72 +0,0 @@\n-/**\n- * Copyright 2013 Netflix, Inc.\n- * \n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * \n- * http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package rx.joins;\n-\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import rx.Observer;\n-\n-/**\n- * Implements an observer that ensures proper event delivery\n- * semantics to its abstract onXxxxCore methods.\n- */\n-public abstract class ObserverBase<T> implements Observer<T> {\n-    private final AtomicBoolean completed = new AtomicBoolean();\n-\n-    @Override\n-    public void onNext(T args) {\n-        if (!completed.get()) {\n-            onNextCore(args);\n-        }\n-    }\n-\n-    @Override\n-    public void onError(Throwable e) {\n-        if (completed.compareAndSet(false, true)) {\n-            onErrorCore(e);\n-        }\n-    }\n-\n-    @Override\n-    public void onCompleted() {\n-        if (completed.compareAndSet(false, true)) {\n-            onCompletedCore();\n-        }\n-    }\n-    /**\n-     * Implement this method to react to the receival of a new element in the sequence.\n-     */\n-    protected abstract void onNextCore(T args);\n-    /**\n-     * Implement this method to react to the occurrence of an exception.\n-     */\n-    protected abstract void onErrorCore(Throwable e);\n-    /**\n-     * Implement this method to react to the end of the sequence.\n-     */\n-    protected abstract void onCompletedCore();\n-    /**\n-     * Try to trigger the error state.\n-     * @param t \n-     * @return false if already completed\n-     */\n-    protected boolean fail(Throwable t) {\n-        if (completed.compareAndSet(false, true)) {\n-            onErrorCore(t);\n-            return true;\n-        }\n-        return false;\n-    }\n-}",
    "output": "Remove ObserverBase"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/ObservableDoOnTest.java b/rxjava-core/src/test/java/rx/ObservableDoOnTest.java\n--- a/rxjava-core/src/test/java/rx/ObservableDoOnTest.java\n+++ b/rxjava-core/src/test/java/rx/ObservableDoOnTest.java\n@@ -30,7 +30,7 @@ public class ObservableDoOnTest {\n     @Test\n     public void testDoOnEach() {\n         final AtomicReference<String> r = new AtomicReference<String>();\n-        String output = Observable.from(\"one\").doOnEach(new Action1<String>() {\n+        String output = Observable.from(\"one\").doOnNext(new Action1<String>() {\n \n             @Override\n             public void call(String v) {\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperationDoOnEachTest.java b/rxjava-core/src/test/java/rx/operators/OperationDoOnEachTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationDoOnEachTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationDoOnEachTest.java\n@@ -108,7 +108,7 @@ public String call(String s) {\n     @Test\n     public void testDoOnEachWithErrorInCallback() {\n         Observable<String> base     = Observable.from(\"one\", \"two\", \"fail\", \"three\");\n-        Observable<String> doOnEach = base.doOnEach(new Action1<String>() {\n+        Observable<String> doOnEach = base.doOnNext(new Action1<String>() {\n             @Override\n             public void call(String s) {\n                 if (\"fail\".equals(s)) {\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperationObserveOnTest.java b/rxjava-core/src/test/java/rx/operators/OperationObserveOnTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationObserveOnTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationObserveOnTest.java\n@@ -98,7 +98,7 @@ public void testThreadName() throws InterruptedException {\n         final CountDownLatch completedLatch = new CountDownLatch(1);\n \n         // assert subscribe is on main thread\n-        obs = obs.doOnEach(new Action1<String>() {\n+        obs = obs.doOnNext(new Action1<String>() {\n \n             @Override\n             public void call(String s) {\n@@ -110,7 +110,7 @@ public void call(String s) {\n         });\n \n         // assert observe is on new thread\n-        obs.observeOn(Schedulers.newThread()).doOnEach(new Action1<String>() {\n+        obs.observeOn(Schedulers.newThread()).doOnNext(new Action1<String>() {\n \n             @Override\n             public void call(String t1) {",
    "output": "Upgrade Tests for doOn* Changes"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n@@ -25,7 +25,7 @@\n import rx.Observer;\n import rx.Scheduler;\n import rx.Subscription;\n-import rx.subscriptions.SingleAssignmentSubscription;\n+import rx.subscriptions.BooleanSubscription;\n import rx.util.Timestamped;\n \n /**\n@@ -156,9 +156,9 @@ public TakeLastTimed(Observable<? extends T> source, int count, long time, TimeU\n \n         @Override\n         public Subscription onSubscribe(Observer<? super T> t1) {\n-            SingleAssignmentSubscription sas = new SingleAssignmentSubscription();\n-            sas.set(source.subscribe(new TakeLastTimedObserver<T>(t1, sas, count, ageMillis, scheduler)));\n-            return sas;\n+            SafeObservableSubscription s = new SafeObservableSubscription();\n+            source.subscribe(new TakeLastTimedObserver<T>(t1, s, count, ageMillis, scheduler));\n+            return s;\n         }\n     }\n     /** Observes source values and keeps the most recent items. */",
    "output": "Fix TakeLast after removing SingleAssignmentSubscription\n\n- SingleAssignmentSubscription was removed in one merge, TakeLast modified in another merge"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/joins/JoinObserver1.java b/rxjava-core/src/main/java/rx/joins/JoinObserver1.java\n--- a/rxjava-core/src/main/java/rx/joins/JoinObserver1.java\n+++ b/rxjava-core/src/main/java/rx/joins/JoinObserver1.java\n@@ -19,9 +19,11 @@\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import rx.Notification;\n import rx.Observable;\n-import rx.subscriptions.SingleAssignmentSubscription;\n+import rx.operators.SafeObservableSubscription;\n import rx.util.functions.Action1;\n \n /**\n@@ -33,14 +35,15 @@ public final class JoinObserver1<T> extends ObserverBase<Notification<T>> implem\n     private final Action1<Throwable> onError;\n     private final List<ActivePlan0> activePlans;\n     private final Queue<Notification<T>> queue;\n-    private final SingleAssignmentSubscription subscription;\n+    private final SafeObservableSubscription subscription;\n     private volatile boolean done;\n+    private final AtomicBoolean subscribed = new AtomicBoolean(false);\n     \n     public JoinObserver1(Observable<T> source, Action1<Throwable> onError) {\n         this.source = source;\n         this.onError = onError;\n         queue = new LinkedList<Notification<T>>();\n-        subscription = new SingleAssignmentSubscription();\n+        subscription = new SafeObservableSubscription();\n         activePlans = new ArrayList<ActivePlan0>();\n     }\n     public Queue<Notification<T>> queue() {\n@@ -51,8 +54,12 @@ public void addActivePlan(ActivePlan0 activePlan) {\n     }\n     @Override\n     public void subscribe(Object gate) {\n-        this.gate = gate;\n-        subscription.set(source.materialize().subscribe(this));\n+        if (subscribed.compareAndSet(false, true)) {\n+            this.gate = gate;\n+            subscription.wrap(source.materialize().subscribe(this));\n+        } else {\n+            throw new IllegalStateException(\"Can only be subscribed to once.\");\n+        }\n     }\n \n     @Override\n\ndiff --git a/rxjava-core/src/main/java/rx/subscriptions/SingleAssignmentSubscription.java b/rxjava-core/src/main/java/rx/subscriptions/SingleAssignmentSubscription.java\n--- a/rxjava-core/src/main/java/rx/subscriptions/SingleAssignmentSubscription.java\n+++ b/rxjava-core/src/main/java/rx/subscriptions/SingleAssignmentSubscription.java\n@@ -1,81 +0,0 @@\n-/**\n- * Copyright 2013 Netflix, Inc.\n- * \n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * \n- * http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package rx.subscriptions;\n-\n-import java.util.concurrent.atomic.AtomicReference;\n-import rx.Subscription;\n-\n-/**\n- * A subscription that allows only a single resource to be assigned.\n- * <p>\n- * If this subscription is live, no other subscription may be set() and\n- * yields an {@link IllegalStateException}.\n- * <p>\n- * If the unsubscribe has been called, setting a new subscription will\n- * unsubscribe it immediately.\n- */\n-public final class SingleAssignmentSubscription implements Subscription {\n-    /** Holds the current resource. */\n-    private final AtomicReference<Subscription> current = new AtomicReference<Subscription>();\n-    /** Sentinel for the unsubscribed state. */\n-    private static final Subscription UNSUBSCRIBED_SENTINEL = new Subscription() {\n-        @Override\n-        public void unsubscribe() {\n-        }\n-    };\n-    /**\n-     * Returns the current subscription or null if not yet set.\n-     */\n-    public Subscription get() {\n-        Subscription s = current.get();\n-        if (s == UNSUBSCRIBED_SENTINEL) {\n-            return Subscriptions.empty();\n-        }\n-        return s;\n-    }\n-    /**\n-     * Sets a new subscription if not already set.\n-     * @param s the new subscription\n-     * @throws IllegalStateException if this subscription is live and contains\n-     * another subscription.\n-     */\n-    public void set(Subscription s) {\n-        if (current.compareAndSet(null, s)) {\n-            return;\n-        }\n-        if (current.get() != UNSUBSCRIBED_SENTINEL) {\n-            throw new IllegalStateException(\"Subscription already set\");\n-        }\n-        if (s != null) {\n-            s.unsubscribe();\n-        }\n-    }\n-    @Override\n-    public void unsubscribe() {\n-        Subscription old = current.getAndSet(UNSUBSCRIBED_SENTINEL);\n-        if (old != null) {\n-            old.unsubscribe();\n-        }\n-    }\n-    /**\n-     * Test if this subscription is already unsubscribed.\n-     */\n-    public boolean isUnsubscribed() {\n-        return current.get() == UNSUBSCRIBED_SENTINEL;\n-    }\n-    \n-}",
    "output": "Remove Unnecessary Subscription\n\n- be explicit for error case in JoinObserver"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n--- a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n+++ b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n@@ -17,8 +17,6 @@\n \n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.atomic.AtomicReference;\n \n@@ -126,7 +124,7 @@ protected void terminate(Action1<Collection<SubjectObserver<? super T>>> onTermi\n          */\n         try {\n             // had to circumvent type check, we know what the array contains\n-            onTerminate.call((Collection)newState.observersList);\n+            onTerminate.call((Collection)Arrays.asList(newState.observers));\n         } finally {\n             // mark that termination is completed\n             newState.terminationLatch.countDown();\n@@ -141,33 +139,29 @@ public SubjectObserver<Object>[] rawSnapshot() {\n         return state.get().observers;\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n     protected static class State<T> {\n         final boolean terminated;\n         final CountDownLatch terminationLatch;\n         final Subscription[] subscriptions;\n-        final SubjectObserver<Object>[] observers;\n+        final SubjectObserver[] observers;\n         // to avoid lots of empty arrays\n         final Subscription[] EMPTY_S = new Subscription[0];\n-        @SuppressWarnings(\"rawtypes\")\n         // to avoid lots of empty arrays\n         final SubjectObserver[] EMPTY_O = new SubjectObserver[0];\n-        @SuppressWarnings(\"rawtypes\")\n-        final List<SubjectObserver<Object>> observersList;\n         private State(boolean isTerminated, CountDownLatch terminationLatch, \n                 Subscription[] subscriptions, SubjectObserver[] observers) {\n             this.terminationLatch = terminationLatch;\n             this.terminated = isTerminated;\n             this.subscriptions = subscriptions;\n             this.observers = observers;\n-            this.observersList = Arrays.asList(this.observers);\n         }\n \n         State() {\n             this.terminated = false;\n             this.terminationLatch = null;\n             this.subscriptions = EMPTY_S;\n             this.observers = EMPTY_O;\n-            observersList = Collections.emptyList();\n         }\n \n         public State<T> terminate() {",
    "output": "Add create with initial capacity, minor fix"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java b/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n@@ -50,10 +50,12 @@\n  * @param <T>\n  */\n public final class ReplaySubject<T> extends Subject<T, T> {\n-\n     public static <T> ReplaySubject<T> create() {\n+        return create(16);\n+    }\n+    public static <T> ReplaySubject<T> create(int initialCapacity) {\n         final SubjectSubscriptionManager<T> subscriptionManager = new SubjectSubscriptionManager<T>();\n-        final ReplayState<T> state = new ReplayState<T>();\n+        final ReplayState<T> state = new ReplayState<T>(initialCapacity);\n \n         OnSubscribeFunc<T> onSubscribe = subscriptionManager.getOnSubscribeFunc(\n                 /**\n@@ -91,9 +93,13 @@ public void call(SubjectObserver<? super T> o) {\n \n     private static class ReplayState<T> {\n         // single-producer, multi-consumer\n-        final History<T> history = new History<T>();\n+        final History<T> history;\n         // each Observer is tracked here for what events they have received\n-        final ConcurrentHashMap<Observer<? super T>, Integer> replayState = new ConcurrentHashMap<Observer<? super T>, Integer>();\n+        final ConcurrentHashMap<Observer<? super T>, Integer> replayState;\n+        public ReplayState(int initialCapacity) {\n+            history = new History<T>(initialCapacity);\n+            replayState = new ConcurrentHashMap<Observer<? super T>, Integer>();\n+        }\n     }\n \n     private final SubjectSubscriptionManager<T> subscriptionManager;\n@@ -197,10 +203,14 @@ private static <T> int replayObserverFromIndex(History<T> history, Integer l, Su\n      * @param <T>\n      */\n     private static class History<T> {\n-        private AtomicInteger index = new AtomicInteger(0);\n-        private final ArrayList<T> list = new ArrayList<T>(/* 1024 */);\n-        private AtomicReference<Notification<T>> terminalValue = new AtomicReference<Notification<T>>();\n-\n+        private final AtomicInteger index;\n+        private final ArrayList<T> list;\n+        private final AtomicReference<Notification<T>> terminalValue;\n+        public History(int initialCapacity) {\n+             index = new AtomicInteger(0);\n+             list = new ArrayList<T>(initialCapacity);\n+             terminalValue = new AtomicReference<Notification<T>>();\n+        }\n         public boolean next(T n) {\n             if (terminalValue.get() == null) {\n                 list.add(n);\n\ndiff --git a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n--- a/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n+++ b/rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java\n@@ -15,7 +15,6 @@\n  */\n package rx.subjects;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n@@ -52,7 +51,7 @@ public Subscription onSubscribe(Observer<? super T> actualObserver) {\n                     onSubscribe.call(observer);\n                 }\n \n-                State<T> current = null;\n+                State<T> current;\n                 State<T> newState = null;\n                 boolean addedObserver = false;\n                 Subscription s;\n@@ -107,7 +106,7 @@ public void unsubscribe() {\n     }\n \n     protected void terminate(Action1<Collection<SubjectObserver<? super T>>> onTerminate) {\n-        State<T> current = null;\n+        State<T> current;\n         State<T> newState = null;\n         do {\n             current = state.get();\n@@ -133,21 +132,6 @@ protected void terminate(Action1<Collection<SubjectObserver<? super T>>> onTermi\n             newState.terminationLatch.countDown();\n         }\n     }\n-\n-    /**\n-     * Current snapshot of 'state.observers.keySet()' so that concurrent modifications aren't included.\n-     * \n-     * This makes it behave deterministically in a single-threaded execution when nesting subscribes.\n-     * \n-     * In multi-threaded execution it will cause new subscriptions to wait until the following onNext instead\n-     * of possibly being included in the current onNext iteration.\n-     * \n-     * @return List<Observer<T>>\n-     */\n-    private Collection<SubjectObserver<? super T>> snapshotOfObservers() {\n-        // had to circumvent type check, we know what the array contains\n-        return (Collection)state.get().observersList;\n-    }\n     /**\n      * Returns the array of observers directly.\n      * <em>Don't modify the array!</em>",
    "output": "Add create with initial capacity"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationSingle.java b/rxjava-core/src/main/java/rx/operators/OperationSingle.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationSingle.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationSingle.java\n@@ -47,9 +47,9 @@ public Subscription onSubscribe(final Observer<? super T> observer) {\n                 final SafeObservableSubscription subscription = new SafeObservableSubscription();\n                 subscription.wrap(source.subscribe(new Observer<T>() {\n \n-                    private volatile T value;\n-                    private volatile boolean isEmpty = true;\n-                    private volatile boolean hasTooManyElemenets;\n+                    private T value;\n+                    private boolean isEmpty = true;\n+                    private boolean hasTooManyElemenets;\n \n                     @Override\n                     public void onCompleted() {",
    "output": "Remove volatile"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java b/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java\n@@ -55,10 +55,9 @@ public ToObservableList(Observable<? extends T> that) {\n         public Subscription onSubscribe(final Observer<? super List<T>> observer) {\n \n             return that.subscribe(new Observer<T>() {\n-                final ConcurrentLinkedQueue<T> list = new ConcurrentLinkedQueue<T>();\n+                final List<T> list = new ArrayList<T>();\n \n                 public void onNext(T value) {\n-                    // onNext can be concurrently executed so list must be thread-safe\n                     list.add(value);\n                 }\n \n@@ -68,16 +67,10 @@ public void onError(Throwable ex) {\n \n                 public void onCompleted() {\n                     try {\n-                        // copy from LinkedQueue to List since ConcurrentLinkedQueue does not implement the List interface\n-                        ArrayList<T> l = new ArrayList<T>(list.size());\n-                        for (T t : list) {\n-                            l.add(t);\n-                        }\n-\n                         // benjchristensen => I want to make this list immutable but some clients are sorting this\n                         // instead of using toSortedList() and this change breaks them until we migrate their code.\n                         // observer.onNext(Collections.unmodifiableList(l));\n-                        observer.onNext(l);\n+                        observer.onNext(new ArrayList<T>(list));\n                         observer.onCompleted();\n                     } catch (Throwable e) {\n                         onError(e);\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperationToObservableListTest.java b/rxjava-core/src/test/java/rx/operators/OperationToObservableListTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationToObservableListTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationToObservableListTest.java\n@@ -66,4 +66,17 @@ public void testListMultipleObservers() {\n         verify(o2, Mockito.never()).onError(any(Throwable.class));\n         verify(o2, times(1)).onCompleted();\n     }\n+\n+    @Test\n+    public void testListWithNullValue() {\n+        Observable<String> w = Observable.from(\"one\", null, \"three\");\n+        Observable<List<String>> observable = Observable.create(toObservableList(w));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<List<String>> aObserver = mock(Observer.class);\n+        observable.subscribe(aObserver);\n+        verify(aObserver, times(1)).onNext(Arrays.asList(\"one\", null, \"three\"));\n+        verify(aObserver, Mockito.never()).onError(any(Throwable.class));\n+        verify(aObserver, times(1)).onCompleted();\n+    }\n }",
    "output": "Fix issue #595 about null in toList operator"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperationParallelMergeTest.java b/rxjava-core/src/test/java/rx/operators/OperationParallelMergeTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationParallelMergeTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationParallelMergeTest.java\n@@ -58,24 +58,8 @@ public void testParallelMerge() {\n \n     @Test\n     public void testNumberOfThreads() {\n-        final ConcurrentHashMap<String, String> threads = new ConcurrentHashMap<String, String>();\n-        Observable.merge(getStreams())\n-                .toBlockingObservable().forEach(new Action1<String>() {\n-\n-                    @Override\n-                    public void call(String o) {\n-                        System.out.println(\"o: \" + o + \" Thread: \" + Thread.currentThread());\n-                        threads.put(Thread.currentThread().getName(), Thread.currentThread().getName());\n-                    }\n-                });\n-\n-        // without injecting anything, the getStream() method uses Interval which runs on a default scheduler\n-        assertEquals(Runtime.getRuntime().availableProcessors(), threads.keySet().size());\n-\n-        // clear\n-        threads.clear();\n-\n-        // now we parallelMerge into 3 streams and observeOn for each\n+        final ConcurrentHashMap<Long, Long> threads = new ConcurrentHashMap<Long, Long>();\n+        // parallelMerge into 3 streams and observeOn for each\n         // we expect 3 threads in the output\n         OperationParallelMerge.parallelMerge(getStreams(), 3)\n                 .flatMap(new Func1<Observable<String>, Observable<String>>() {\n@@ -90,8 +74,8 @@ public Observable<String> call(Observable<String> o) {\n \n                     @Override\n                     public void call(String o) {\n-                        System.out.println(\"o: \" + o + \" Thread: \" + Thread.currentThread());\n-                        threads.put(Thread.currentThread().getName(), Thread.currentThread().getName());\n+                        System.out.println(\"o: \" + o + \" Thread: \" + Thread.currentThread().getId());\n+                        threads.put(Thread.currentThread().getId(), Thread.currentThread().getId());\n                     }\n                 });\n \n@@ -100,7 +84,7 @@ public void call(String o) {\n \n     @Test\n     public void testNumberOfThreadsOnScheduledMerge() {\n-        final ConcurrentHashMap<String, String> threads = new ConcurrentHashMap<String, String>();\n+        final ConcurrentHashMap<Long, Long> threads = new ConcurrentHashMap<Long, Long>();\n \n         // now we parallelMerge into 3 streams and observeOn for each\n         // we expect 3 threads in the output\n@@ -109,8 +93,8 @@ public void testNumberOfThreadsOnScheduledMerge() {\n \n                     @Override\n                     public void call(String o) {\n-                        System.out.println(\"o: \" + o + \" Thread: \" + Thread.currentThread());\n-                        threads.put(Thread.currentThread().getName(), Thread.currentThread().getName());\n+                        System.out.println(\"o: \" + o + \" Thread: \" + Thread.currentThread().getId());\n+                        threads.put(Thread.currentThread().getId(), Thread.currentThread().getId());\n                     }\n                 });\n ",
    "output": "Fix non-deterministic unit test\n\n- there is no guarantee for how many threads Interval will use so useless to assert anything on it"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java b/rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java\n--- a/rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java\n+++ b/rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java\n@@ -52,7 +52,9 @@ private EventLoopScheduler() {\n \n                 @Override\n                 public Thread newThread(Runnable r) {\n-                    return new Thread(r, \"RxNewThreadScheduler-\" + count.incrementAndGet());\n+                    Thread t = new Thread(r, \"RxNewThreadScheduler-\" + count.incrementAndGet());\n+                    t.setDaemon(true);\n+                    return t;\n                 }\n             });\n         }",
    "output": "Make NewThreadScheduler create Daemon threads\n\nThis matches the behavior of Schedulers.COMPUTATION_EXECUTOR and Schedulers.IO_EXECUTOR.\n\nSee https://groups.google.com/forum/#!topic/rxjava/Qe1qi0aHtnE and https://github.com/Netflix/RxJava/issues/431#issuecomment-30767610"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java b/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java\n--- a/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java\n+++ b/rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java\n@@ -197,6 +197,7 @@ public byte[] call(String str) {\n      */\n     public static Observable<String> stringConcat(Observable<String> src) {\n         return src.aggregate(new Func2<String, String, String>() {\n+            @Override\n             public String call(String a, String b) {\n                 return a + b;\n             }\n@@ -267,4 +268,58 @@ private void output(String part) {\n             }\n         });\n     }\n+    /**\n+     * Concatenates the sequence of values by adding a separator\n+     * between them and emitting the result once the source completes.\n+     * <p>\n+     * The conversion from the value type to String is performed via\n+     * {@link java.lang.String#valueOf(java.lang.Object)} calls.\n+     * <p>\n+     * For example:\n+     * <pre>\n+     * Observable&lt;Object> source = Observable.from(\"a\", 1, \"c\");\n+     * Observable&lt;String> result = join(source, \", \");\n+     * </pre>\n+     * \n+     * will yield a single element equal to \"a, 1, c\".\n+     * \n+     * @param source the source sequence of CharSequence values\n+     * @param separator the separator to a\n+     * @return an Observable which emits a single String value having the concatenated\n+     *         values of the source observable with the separator between elements\n+     */\n+    public static <T> Observable<String> join(final Observable<T> source, final CharSequence separator) {\n+        return Observable.create(new OnSubscribeFunc<String>() {\n+\n+            @Override\n+            public Subscription onSubscribe(final Observer<? super String> t1) {\n+                return source.subscribe(new Observer<T>() {\n+                    boolean mayAddSeparator;\n+                    StringBuilder b = new StringBuilder();\n+                    @Override\n+                    public void onNext(T args) {\n+                        if (mayAddSeparator) {\n+                            b.append(separator);\n+                        }\n+                        mayAddSeparator = true;\n+                        b.append(String.valueOf(args));\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable e) {\n+                        b = null;\n+                        t1.onError(e);\n+                    }\n+\n+                    @Override\n+                    public void onCompleted() {\n+                        String str = b.toString();\n+                        b = null;\n+                        t1.onNext(str);\n+                        t1.onCompleted();\n+                    }\n+                });\n+            }\n+        });\n+    }\n }\n\ndiff --git a/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java b/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java\n--- a/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java\n+++ b/rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java\n@@ -23,10 +23,10 @@\n import java.nio.charset.MalformedInputException;\n \n import org.junit.Test;\n+import static org.mockito.Mockito.*;\n \n import rx.Observable;\n-import rx.observables.BlockingObservable;\n-import rx.observables.StringObservable;\n+import rx.Observer;\n import rx.util.AssertObservable;\n \n public class StringObservableTest {\n@@ -127,4 +127,89 @@ public void testSplit(String message, String regex, int limit, Observable<String\n         Observable<String> exp = Observable.from(parts);\n         AssertObservable.assertObservableEqualsBlocking(\"when input is \"+message+\" and limit = \"+ limit, exp, act);\n     }\n+    \n+    @Test\n+    public void testJoinMixed() {\n+        Observable<Object> source = Observable.<Object>from(\"a\", 1, \"c\");\n+        \n+        Observable<String> result = StringObservable.join(source, \", \");\n+        \n+        Observer<Object> observer = mock(Observer.class);\n+        \n+        result.subscribe(observer);\n+        \n+        verify(observer, times(1)).onNext(\"a, 1, c\");\n+        verify(observer, times(1)).onCompleted();\n+        verify(observer, never()).onError(any(Throwable.class));\n+    }\n+    @Test\n+    public void testJoinWithEmptyString() {\n+        Observable<String> source = Observable.from(\"\", \"b\", \"c\");\n+        \n+        Observable<String> result = StringObservable.join(source, \", \");\n+        \n+        Observer<Object> observer = mock(Observer.class);\n+        \n+        result.subscribe(observer);\n+        \n+        verify(observer, times(1)).onNext(\", b, c\");\n+        verify(observer, times(1)).onCompleted();\n+        verify(observer, never()).onError(any(Throwable.class));\n+    }\n+    @Test\n+    public void testJoinWithNull() {\n+        Observable<String> source = Observable.from(\"a\", null, \"c\");\n+        \n+        Observable<String> result = StringObservable.join(source, \", \");\n+        \n+        Observer<Object> observer = mock(Observer.class);\n+        \n+        result.subscribe(observer);\n+        \n+        verify(observer, times(1)).onNext(\"a, null, c\");\n+        verify(observer, times(1)).onCompleted();\n+        verify(observer, never()).onError(any(Throwable.class));\n+    }\n+    @Test\n+    public void testJoinSingle() {\n+        Observable<String> source = Observable.from(\"a\");\n+        \n+        Observable<String> result = StringObservable.join(source, \", \");\n+        \n+        Observer<Object> observer = mock(Observer.class);\n+        \n+        result.subscribe(observer);\n+        \n+        verify(observer, times(1)).onNext(\"a\");\n+        verify(observer, times(1)).onCompleted();\n+        verify(observer, never()).onError(any(Throwable.class));\n+    }\n+    @Test\n+    public void testJoinEmpty() {\n+        Observable<String> source = Observable.empty();\n+        \n+        Observable<String> result = StringObservable.join(source, \", \");\n+        \n+        Observer<Object> observer = mock(Observer.class);\n+        \n+        result.subscribe(observer);\n+        \n+        verify(observer, times(1)).onNext(\"\");\n+        verify(observer, times(1)).onCompleted();\n+        verify(observer, never()).onError(any(Throwable.class));\n+    }\n+    @Test\n+    public void testJoinThrows() {\n+        Observable<String> source = Observable.concat(Observable.just(\"a\"), Observable.<String>error(new RuntimeException(\"Forced failure\")));\n+        \n+        Observable<String> result = StringObservable.join(source, \", \");\n+        \n+        Observer<Object> observer = mock(Observer.class);\n+        \n+        result.subscribe(observer);\n+        \n+        verify(observer, never()).onNext(\"a\");\n+        verify(observer, never()).onCompleted();\n+        verify(observer, times(1)).onError(any(Throwable.class));\n+    }\n }",
    "output": "Add op:join to concat objects with separator between elements"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -6271,43 +6271,6 @@ public <TKey, TValue, TDuration> Observable<GroupedObservable<TKey, TValue>> gro\n         return create(new OperationGroupByUntil<T, TKey, TValue, TDuration>(this, keySelector, valueSelector, durationSelector));\n     }\n \n-    /**\n-     * Invokes the action asynchronously, surfacing the result through an observable sequence.\n-     * <p>\n-     * Note: The action is called immediately, not during the subscription of the resulting\n-     * sequence. Multiple subscriptions to the resulting sequence can observe the\n-     * action's outcome.\n-     * \n-     * @param action\n-     *            Action to run asynchronously.\n-     * @return An observable sequence exposing a null value upon completion of the action,\n-     *            or an exception.\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229265(v=vs.103).aspx\">MSDN: Observable.Start</a>\n-     */\n-    public static Observable<Void> start(Action0 action) {\n-        return Async.toAsync(action).call();\n-    }\n-\n-    /**\n-     * Invokes the action asynchronously on the specified scheduler, surfacing the\n-     * result through an observable sequence.\n-     * <p>\n-     * Note: The action is called immediately, not during the subscription of the resulting\n-     * sequence. Multiple subscriptions to the resulting sequence can observe the\n-     * action's outcome.\n-     * \n-     * @param action\n-     *            Action to run asynchronously.\n-     * @param scheduler\n-     *            Scheduler to run the function on.\n-     * @return An observable sequence exposing a null value upon completion of the action,\n-     *            or an exception.\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211971(v=vs.103).aspx\">MSDN: Observable.Start</a>\n-     */\n-    public static Observable<Void> start(Action0 action, Scheduler scheduler) {\n-        return Async.toAsync(action, scheduler).call();\n-    }\n-\n     /**\n      * Invokes the specified function asynchronously, surfacing the result through an observable sequence.\n      * <p>\n\ndiff --git a/rxjava-core/src/test/java/rx/ObservableTests.java b/rxjava-core/src/test/java/rx/ObservableTests.java\n--- a/rxjava-core/src/test/java/rx/ObservableTests.java\n+++ b/rxjava-core/src/test/java/rx/ObservableTests.java\n@@ -951,107 +951,6 @@ public void testRangeWithScheduler() {\n         inOrder.verifyNoMoreInteractions();\n     }\n \n-    @Test\n-    public void testStartWithAction() {\n-        Action0 action = mock(Action0.class);\n-        assertEquals(null, Observable.start(action).toBlockingObservable().single());\n-    }\n-\n-    @Test(expected = RuntimeException.class)\n-    public void testStartWithActionError() {\n-        Action0 action = new Action0() {\n-            @Override\n-            public void call() {\n-                throw new RuntimeException(\"Some error\");\n-            }\n-        };\n-        Observable.start(action).toBlockingObservable().single();\n-    }\n-\n-    @Test\n-    public void testStartWhenSubscribeRunBeforeAction() {\n-        TestScheduler scheduler = new TestScheduler();\n-\n-        Action0 action = mock(Action0.class);\n-\n-        Observable<Void> observable = Observable.start(action, scheduler);\n-\n-        @SuppressWarnings(\"unchecked\")\n-        Observer<Void> observer = mock(Observer.class);\n-        observable.subscribe(observer);\n-\n-        InOrder inOrder = inOrder(observer);\n-        inOrder.verifyNoMoreInteractions();\n-\n-        // Run action\n-        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n-\n-        inOrder.verify(observer, times(1)).onNext(null);\n-        inOrder.verify(observer, times(1)).onCompleted();\n-        inOrder.verifyNoMoreInteractions();\n-    }\n-\n-    @Test\n-    public void testStartWhenSubscribeRunAfterAction() {\n-        TestScheduler scheduler = new TestScheduler();\n-\n-        Action0 action = mock(Action0.class);\n-\n-        Observable<Void> observable = Observable.start(action, scheduler);\n-\n-        // Run action\n-        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n-\n-        @SuppressWarnings(\"unchecked\")\n-        Observer<Void> observer = mock(Observer.class);\n-        observable.subscribe(observer);\n-\n-        InOrder inOrder = inOrder(observer);\n-        inOrder.verify(observer, times(1)).onNext(null);\n-        inOrder.verify(observer, times(1)).onCompleted();\n-        inOrder.verifyNoMoreInteractions();\n-    }\n-\n-    @Test\n-    public void testStartWithActionAndMultipleObservers() {\n-        TestScheduler scheduler = new TestScheduler();\n-\n-        Action0 action = mock(Action0.class);\n-\n-        Observable<Void> observable = Observable.start(action, scheduler);\n-\n-        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n-\n-        @SuppressWarnings(\"unchecked\")\n-        Observer<Void> observer1 = mock(Observer.class);\n-        @SuppressWarnings(\"unchecked\")\n-        Observer<Void> observer2 = mock(Observer.class);\n-        @SuppressWarnings(\"unchecked\")\n-        Observer<Void> observer3 = mock(Observer.class);\n-\n-        observable.subscribe(observer1);\n-        observable.subscribe(observer2);\n-        observable.subscribe(observer3);\n-\n-        InOrder inOrder;\n-        inOrder = inOrder(observer1);\n-        inOrder.verify(observer1, times(1)).onNext(null);\n-        inOrder.verify(observer1, times(1)).onCompleted();\n-        inOrder.verifyNoMoreInteractions();\n-\n-        inOrder = inOrder(observer2);\n-        inOrder.verify(observer2, times(1)).onNext(null);\n-        inOrder.verify(observer2, times(1)).onCompleted();\n-        inOrder.verifyNoMoreInteractions();\n-\n-        inOrder = inOrder(observer3);\n-        inOrder.verify(observer3, times(1)).onNext(null);\n-        inOrder.verify(observer3, times(1)).onCompleted();\n-        inOrder.verifyNoMoreInteractions();\n-\n-        verify(action, times(1)).call();\n-    }\n-\n     @Test\n     public void testStartWithFunc() {\n         Func0<String> func = new Func0<String>() {",
    "output": "Remove the Action0 overloads"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java b/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/ReplaySubject.java\n@@ -164,6 +164,9 @@ public void onError(Throwable e)\n     public void onNext(T args)\n     {\n         synchronized (subscriptions) {\n+            if (isDone) {\n+                return;\n+            }\n             history.add(args);\n             for (Observer<? super T> observer : new ArrayList<Observer<? super T>>(subscriptions.values())) {\n                 observer.onNext(args);",
    "output": "Fix #544 ReplaySubject emits items received after onError"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/ObservableTests.java b/rxjava-core/src/test/java/rx/ObservableTests.java\n--- a/rxjava-core/src/test/java/rx/ObservableTests.java\n+++ b/rxjava-core/src/test/java/rx/ObservableTests.java\n@@ -953,15 +953,8 @@ public void testRangeWithScheduler() {\n \n     @Test\n     public void testStartWithAction() {\n-        TestScheduler scheduler = new TestScheduler();\n-\n         Action0 action = mock(Action0.class);\n-        Observable<Void> observable = Observable.start(action, scheduler);\n-        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);\n-\n-        assertEquals(null, observable.toBlockingObservable().single());\n-        assertEquals(null, observable.toBlockingObservable().single());\n-        verify(action, times(1)).call();\n+        assertEquals(null, Observable.start(action).toBlockingObservable().single());\n     }\n \n     @Test(expected = RuntimeException.class)\n@@ -972,44 +965,214 @@ public void call() {\n                 throw new RuntimeException(\"Some error\");\n             }\n         };\n+        Observable.start(action).toBlockingObservable().single();\n+    }\n+\n+    @Test\n+    public void testStartWhenSubscribeRunBeforeAction() {\n+        TestScheduler scheduler = new TestScheduler();\n+\n+        Action0 action = mock(Action0.class);\n+\n+        Observable<Void> observable = Observable.start(action, scheduler);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Void> observer = mock(Observer.class);\n+        observable.subscribe(observer);\n+\n+        InOrder inOrder = inOrder(observer);\n+        inOrder.verifyNoMoreInteractions();\n+\n+        // Run action\n+        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n \n-        Observable<Void> observable = Observable.start(action);\n-        observable.toBlockingObservable().single();\n+        inOrder.verify(observer, times(1)).onNext(null);\n+        inOrder.verify(observer, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n     }\n \n     @Test\n-    public void testStartWithFunc() {\n+    public void testStartWhenSubscribeRunAfterAction() {\n         TestScheduler scheduler = new TestScheduler();\n \n+        Action0 action = mock(Action0.class);\n+\n+        Observable<Void> observable = Observable.start(action, scheduler);\n+\n+        // Run action\n+        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n+\n         @SuppressWarnings(\"unchecked\")\n-        Func0<String> func = (Func0<String>) mock(Func0.class);\n-        doAnswer(new Answer<String>() {\n+        Observer<Void> observer = mock(Observer.class);\n+        observable.subscribe(observer);\n+\n+        InOrder inOrder = inOrder(observer);\n+        inOrder.verify(observer, times(1)).onNext(null);\n+        inOrder.verify(observer, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void testStartWithActionAndMultipleObservers() {\n+        TestScheduler scheduler = new TestScheduler();\n \n+        Action0 action = mock(Action0.class);\n+\n+        Observable<Void> observable = Observable.start(action, scheduler);\n+\n+        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Void> observer1 = mock(Observer.class);\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Void> observer2 = mock(Observer.class);\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Void> observer3 = mock(Observer.class);\n+\n+        observable.subscribe(observer1);\n+        observable.subscribe(observer2);\n+        observable.subscribe(observer3);\n+\n+        InOrder inOrder;\n+        inOrder = inOrder(observer1);\n+        inOrder.verify(observer1, times(1)).onNext(null);\n+        inOrder.verify(observer1, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n+\n+        inOrder = inOrder(observer2);\n+        inOrder.verify(observer2, times(1)).onNext(null);\n+        inOrder.verify(observer2, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n+\n+        inOrder = inOrder(observer3);\n+        inOrder.verify(observer3, times(1)).onNext(null);\n+        inOrder.verify(observer3, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n+\n+        verify(action, times(1)).call();\n+    }\n+\n+    @Test\n+    public void testStartWithFunc() {\n+        Func0<String> func = new Func0<String>() {\n             @Override\n-            public String answer(InvocationOnMock invocation) throws Throwable {\n+            public String call() {\n                 return \"one\";\n             }\n+        };\n+        assertEquals(\"one\", Observable.start(func).toBlockingObservable().single());\n+    }\n \n-        }).when(func).call();\n+    @Test(expected = RuntimeException.class)\n+    public void testStartWithFuncError() {\n+        Func0<String> func = new Func0<String>() {\n+            @Override\n+            public String call() {\n+                throw new RuntimeException(\"Some error\");\n+            }\n+        };\n+        Observable.start(func).toBlockingObservable().single();\n+    }\n+\n+    @Test\n+    public void testStartWhenSubscribeRunBeforeFunc() {\n+        TestScheduler scheduler = new TestScheduler();\n+\n+        Func0<String> func = new Func0<String>() {\n+            @Override\n+            public String call() {\n+                return \"one\";\n+            }\n+        };\n \n         Observable<String> observable = Observable.start(func, scheduler);\n-        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);\n \n-        assertEquals(\"one\", observable.toBlockingObservable().single());\n-        assertEquals(\"one\", observable.toBlockingObservable().single());\n-        verify(func, times(1)).call();\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer = mock(Observer.class);\n+        observable.subscribe(observer);\n+\n+        InOrder inOrder = inOrder(observer);\n+        inOrder.verifyNoMoreInteractions();\n+\n+        // Run func\n+        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n+\n+        inOrder.verify(observer, times(1)).onNext(\"one\");\n+        inOrder.verify(observer, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n     }\n \n-    @Test(expected = RuntimeException.class)\n-    public void testStartWithFuncError() {\n+    @Test\n+    public void testStartWhenSubscribeRunAfterFunc() {\n+        TestScheduler scheduler = new TestScheduler();\n+\n         Func0<String> func = new Func0<String>() {\n             @Override\n             public String call() {\n-                throw new RuntimeException(\"Some error\");\n+                return \"one\";\n             }\n         };\n \n-        Observable<String> observable = Observable.start(func);\n-        observable.toBlockingObservable().single();\n+        Observable<String> observable = Observable.start(func, scheduler);\n+\n+        // Run func\n+        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer = mock(Observer.class);\n+        observable.subscribe(observer);\n+\n+        InOrder inOrder = inOrder(observer);\n+        inOrder.verify(observer, times(1)).onNext(\"one\");\n+        inOrder.verify(observer, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n     }\n-}\n\\ No newline at end of file\n+\n+    @Test\n+    public void testStartWithFuncAndMultipleObservers() {\n+        TestScheduler scheduler = new TestScheduler();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Func0<String> func = (Func0<String>) mock(Func0.class);\n+        doAnswer(new Answer<String>() {\n+            @Override\n+            public String answer(InvocationOnMock invocation) throws Throwable {\n+                return \"one\";\n+            }\n+        }).when(func).call();\n+\n+        Observable<String> observable = Observable.start(func, scheduler);\n+\n+        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer1 = mock(Observer.class);\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer2 = mock(Observer.class);\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<String> observer3 = mock(Observer.class);\n+\n+        observable.subscribe(observer1);\n+        observable.subscribe(observer2);\n+        observable.subscribe(observer3);\n+\n+        InOrder inOrder;\n+        inOrder = inOrder(observer1);\n+        inOrder.verify(observer1, times(1)).onNext(\"one\");\n+        inOrder.verify(observer1, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n+\n+        inOrder = inOrder(observer2);\n+        inOrder.verify(observer2, times(1)).onNext(\"one\");\n+        inOrder.verify(observer2, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n+\n+        inOrder = inOrder(observer3);\n+        inOrder.verify(observer3, times(1)).onNext(\"one\");\n+        inOrder.verify(observer3, times(1)).onCompleted();\n+        inOrder.verifyNoMoreInteractions();\n+\n+        verify(func, times(1)).call();\n+    }\n+\n+}",
    "output": "Add more unit tests"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationConcat.java b/rxjava-core/src/main/java/rx/operators/OperationConcat.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationConcat.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationConcat.java\n@@ -51,7 +51,12 @@ public static <T> OnSubscribeFunc<T> concat(final Iterable<? extends Observable<\n     }\n \n     public static <T> OnSubscribeFunc<T> concat(final Observable<? extends Observable<? extends T>> sequences) {\n-        return new Concat<T>(sequences);\n+        return new OnSubscribeFunc<T>() {\n+            @Override\n+            public Subscription onSubscribe(Observer<? super T> t1) {\n+                return new Concat<T>(sequences).onSubscribe(t1);\n+            }            \n+        };\n     }\n \n     private static class Concat<T> implements OnSubscribeFunc<T> {\n@@ -121,8 +126,12 @@ public void onNext(Observable<? extends T> nextSequence) {\n                 @Override\n                 public void onError(Throwable e) {\n                     if (completedOrErred.compareAndSet(false, true)) {\n-                        if (innerSubscription != null) {\n-                            innerSubscription.unsubscribe();\n+                        Subscription q;\n+                        synchronized (nextSequences) {\n+                            q = innerSubscription;\n+                        }\n+                        if (q != null) {\n+                            q.unsubscribe();\n                         }\n                         observer.onError(e);\n                     }\n@@ -131,7 +140,11 @@ public void onError(Throwable e) {\n                 @Override\n                 public void onCompleted() {\n                     allSequencesReceived.set(true);\n-                    if (innerSubscription == null) {\n+                    Subscription q;\n+                    synchronized (nextSequences) {\n+                        q = innerSubscription;\n+                    }\n+                    if (q == null) {\n                         // We are not subscribed to any sequence, and none are coming anymore\n                         if (completedOrErred.compareAndSet(false, true)) {\n                             observer.onCompleted();\n@@ -143,11 +156,14 @@ public void onCompleted() {\n             return new Subscription() {\n                 @Override\n                 public void unsubscribe() {\n+                    Subscription q;\n                     synchronized (nextSequences) {\n-                        if (innerSubscription != null)\n-                            innerSubscription.unsubscribe();\n-                        outerSubscription.unsubscribe();\n+                        q = innerSubscription;\n+                    }\n+                    if (q != null) {\n+                        q.unsubscribe();\n                     }\n+                    outerSubscription.unsubscribe();\n                 }\n             };\n         }\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperationConcatTest.java b/rxjava-core/src/test/java/rx/operators/OperationConcatTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationConcatTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationConcatTest.java\n@@ -16,7 +16,6 @@\n package rx.operators;\n \n import static org.junit.Assert.*;\n-import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n import static rx.operators.OperationConcat.*;\n \n@@ -33,6 +32,7 @@\n import rx.Observable;\n import rx.Observer;\n import rx.Subscription;\n+import rx.concurrency.TestScheduler;\n import rx.subscriptions.BooleanSubscription;\n \n public class OperationConcatTest {\n@@ -556,4 +556,46 @@ public void run() {\n             return s;\n         }\n     }\n+    @Test\n+    public void testMultipleObservers() {\n+        Observer<Object> o1 = mock(Observer.class);\n+        Observer<Object> o2 = mock(Observer.class);\n+        \n+        TestScheduler s = new TestScheduler();\n+        \n+        Observable<Long> timer = Observable.interval(500, TimeUnit.MILLISECONDS, s).take(2);\n+        Observable<Long> o = Observable.concat(timer, timer);\n+        \n+        o.subscribe(o1);\n+        o.subscribe(o2);\n+        \n+        InOrder inOrder1 = inOrder(o1);\n+        InOrder inOrder2 = inOrder(o2);\n+\n+        s.advanceTimeBy(500, TimeUnit.MILLISECONDS);\n+        \n+        inOrder1.verify(o1, times(1)).onNext(0L);\n+        inOrder2.verify(o2, times(1)).onNext(0L);\n+\n+        s.advanceTimeBy(500, TimeUnit.MILLISECONDS);\n+\n+        inOrder1.verify(o1, times(1)).onNext(1L);\n+        inOrder2.verify(o2, times(1)).onNext(1L);\n+\n+        s.advanceTimeBy(500, TimeUnit.MILLISECONDS);\n+\n+        inOrder1.verify(o1, times(1)).onNext(0L);\n+        inOrder2.verify(o2, times(1)).onNext(0L);\n+\n+        s.advanceTimeBy(500, TimeUnit.MILLISECONDS);\n+\n+        inOrder1.verify(o1, times(1)).onNext(1L);\n+        inOrder2.verify(o2, times(1)).onNext(1L);\n+\n+        inOrder1.verify(o1, times(1)).onCompleted();\n+        inOrder2.verify(o2, times(1)).onCompleted();\n+\n+        verify(o1, never()).onError(any(Throwable.class));\n+        verify(o2, never()).onError(any(Throwable.class));\n+    }\n }",
    "output": "Fix Concat to allow multiple observers"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -2315,6 +2315,9 @@ public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> firs\n         return sequenceEqual(first, second, new Func2<T, T, Boolean>() {\n             @Override\n             public Boolean call(T first, T second) {\n+                if(first == null) {\n+                    return second == null;\n+                }\n                 return first.equals(second);\n             }\n         });\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperationSequenceEqualTests.java b/rxjava-core/src/test/java/rx/operators/OperationSequenceEqualTests.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationSequenceEqualTests.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationSequenceEqualTests.java\n@@ -25,6 +25,7 @@\n \n import rx.Observable;\n import rx.Observer;\n+import rx.util.functions.Func2;\n \n public class OperationSequenceEqualTests {\n \n@@ -104,18 +105,30 @@ public void testWithEmpty3() {\n     }\n \n     @Test\n-    public void testWithEqualityError() {\n+    public void testWithNull1() {\n         Observable<Boolean> observable = Observable.sequenceEqual(\n                 Observable.from((String) null), Observable.from(\"one\"));\n+        verifyResult(observable, false);\n+    }\n \n-        @SuppressWarnings(\"unchecked\")\n-        Observer<Boolean> observer = mock(Observer.class);\n-        observable.subscribe(observer);\n+    @Test\n+    public void testWithNull2() {\n+        Observable<Boolean> observable = Observable.sequenceEqual(\n+                Observable.from((String) null), Observable.from((String) null));\n+        verifyResult(observable, true);\n+    }\n \n-        InOrder inOrder = inOrder(observer);\n-        inOrder.verify(observer, times(1)).onError(\n-                isA(NullPointerException.class));\n-        inOrder.verifyNoMoreInteractions();\n+    @Test\n+    public void testWithEqualityError() {\n+        Observable<Boolean> observable = Observable.sequenceEqual(\n+                Observable.from(\"one\"), Observable.from(\"one\"),\n+                new Func2<String, String, Boolean>() {\n+                    @Override\n+                    public Boolean call(String t1, String t2) {\n+                        throw new TestException();\n+                    }\n+                });\n+        verifyError(observable);\n     }\n \n     private void verifyResult(Observable<Boolean> observable, boolean result) {",
    "output": "Fix the 'null' issue in the default equality"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperationDelayTest.java b/rxjava-core/src/test/java/rx/operators/OperationDelayTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationDelayTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationDelayTest.java\n@@ -38,7 +38,7 @@ public void before() {\n     @Test\n     public void testDelay() {\n         Observable<Long> source = Observable.interval(1L, TimeUnit.SECONDS, scheduler).take(3);\n-        Observable<Long> delayed = OperationDelay.delay(source, 500L, TimeUnit.MILLISECONDS, scheduler);\n+        Observable<Long> delayed = source.delay(500L, TimeUnit.MILLISECONDS, scheduler);\n         delayed.subscribe(observer);\n         \n         InOrder inOrder = inOrder(observer);\n@@ -78,7 +78,7 @@ public void testDelay() {\n     @Test\n     public void testLongDelay() {\n         Observable<Long> source = Observable.interval(1L, TimeUnit.SECONDS, scheduler).take(3);\n-        Observable<Long> delayed = OperationDelay.delay(source, 5L, TimeUnit.SECONDS, scheduler);\n+        Observable<Long> delayed = source.delay(5L, TimeUnit.SECONDS, scheduler);\n         delayed.subscribe(observer);\n         \n         InOrder inOrder = inOrder(observer);\n@@ -115,7 +115,7 @@ public Long call(Long value) {\n                 return value; \n             }\n         });\n-        Observable<Long> delayed = OperationDelay.delay(source, 1L, TimeUnit.SECONDS, scheduler);\n+        Observable<Long> delayed = source.delay(1L, TimeUnit.SECONDS, scheduler);\n         delayed.subscribe(observer);\n \n         InOrder inOrder = inOrder(observer);\n@@ -141,7 +141,7 @@ public Long call(Long value) {\n     @Test\n     public void testDelayWithMultipleSubscriptions() {\n         Observable<Long> source = Observable.interval(1L, TimeUnit.SECONDS, scheduler).take(3);\n-        Observable<Long> delayed = OperationDelay.delay(source, 500L, TimeUnit.MILLISECONDS, scheduler);\n+        Observable<Long> delayed = source.delay(500L, TimeUnit.MILLISECONDS, scheduler);\n         delayed.subscribe(observer);\n         delayed.subscribe(observer2);\n         ",
    "output": "Make OperationDelayTest test Observable.delay instead of OperationDelay.delay"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -45,6 +45,7 @@\n import rx.operators.OperationDebounce;\n import rx.operators.OperationDefaultIfEmpty;\n import rx.operators.OperationDefer;\n+import rx.operators.OperationDelay;\n import rx.operators.OperationDematerialize;\n import rx.operators.OperationDistinct;\n import rx.operators.OperationDistinctUntilChanged;\n@@ -2013,11 +2014,40 @@ public static Observable<Void> timer(long interval, TimeUnit unit) {\n      * @param scheduler\n      *            the scheduler to use for scheduling the item\n      */\n-    public static Observable<Void> timer(long interval, TimeUnit unit,\n-            Scheduler scheduler) {\n+    public static Observable<Void> timer(long interval, TimeUnit unit, Scheduler scheduler) {\n         return create(OperationTimer.timer(interval, unit, scheduler));\n     }\n \n+    /**\n+     * Returns an Observable that emits the results of shifting the items emitted by the source\n+     * Observable by a specified delay. Errors emitted by the source Observable are not delayed.\n+     * @param delay\n+     *            the delay to shift the source by\n+     * @param unit\n+     *            the {@link TimeUnit} in which <code>period</code> is defined\n+     * @return the source Observable, but shifted by the specified delay\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229810%28v=vs.103%29.aspx\">MSDN: Observable.Delay</a>\n+     */\n+    public Observable<T> delay(long delay, TimeUnit unit) {\n+        return OperationDelay.delay(this, delay, unit, Schedulers.threadPoolForComputation());\n+    }\n+\n+    /**\n+     * Returns an Observable that emits the results of shifting the items emitted by the source\n+     * Observable by a specified delay. Errors emitted by the source Observable are not delayed.\n+     * @param delay\n+     *            the delay to shift the source by\n+     * @param unit\n+     *            the {@link TimeUnit} in which <code>period</code> is defined\n+     * @param scheduler\n+     *            the {@link Scheduler} to use for delaying\n+     * @return the source Observable, but shifted by the specified delay\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229280(v=vs.103).aspx\">MSDN: Observable.Delay</a>\n+     */\n+    public Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {\n+        return OperationDelay.delay(this, delay, unit, scheduler);\n+    }\n+\n     /**\n      * Drops items emitted by an Observable that are followed by newer items\n      * before a timeout value expires. The timer resets on each emission.",
    "output": "Add delay methods in Observable.java (copied those by @jmhofer) source: https://github.com/jmhofer/RxJava/blob/18d40522bb19f80c0ff8d4079bcb925742efecf4/rxjava-core/src/main/java/rx/Observable.java"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationDelay.java b/rxjava-core/src/main/java/rx/operators/OperationDelay.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationDelay.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationDelay.java\n@@ -0,0 +1,42 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.operators;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import rx.Observable;\n+import rx.Scheduler;\n+import rx.observables.ConnectableObservable;\n+import rx.util.functions.Func1;\n+\n+public final class OperationDelay {\n+\n+    public static <T> Observable<T> delay(Observable<T> observable, final long delay, final TimeUnit unit, final Scheduler scheduler) {\n+        // observable.map(x => Observable.timer(t).map(_ => x).startItAlreadyNow()).concat()\n+        Observable<Observable<T>> seqs = observable.map(new Func1<T, Observable<T>>() {\n+            public Observable<T> call(final T x) {\n+                ConnectableObservable<T> co = Observable.timer(delay, unit, scheduler).map(new Func1<Void, T>() {\n+                    public T call(Void ignored) {\n+                        return x;\n+                    }\n+                }).replay();\n+                co.connect();\n+                return co;\n+            }\n+        });\n+        return Observable.concat(seqs);\n+    }\n+}",
    "output": "Add OperationDelay"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -91,6 +91,7 @@\n import rx.operators.OperationThrottleFirst;\n import rx.operators.OperationTimeInterval;\n import rx.operators.OperationTimeout;\n+import rx.operators.OperationTimer;\n import rx.operators.OperationTimestamp;\n import rx.operators.OperationToMap;\n import rx.operators.OperationToMultimap;\n@@ -1990,6 +1991,33 @@ public static Observable<Long> interval(long interval, TimeUnit unit, Scheduler\n         return create(OperationInterval.interval(interval, unit, scheduler));\n     }\n \n+    /**\n+     * Emits one item after a given delay, and then completes.\n+     * \n+     * @param interval\n+     *            interval size in time units\n+     * @param unit\n+     *            time units to use for the interval size\n+     */\n+    public static Observable<Void> timer(long interval, TimeUnit unit) {\n+        return create(OperationTimer.timer(interval, unit));\n+    }\n+\n+    /**\n+     * Emits one item after a given delay, and then completes.\n+     * \n+     * @param interval\n+     *            interval size in time units\n+     * @param unit\n+     *            time units to use for the interval size\n+     * @param scheduler\n+     *            the scheduler to use for scheduling the item\n+     */\n+    public static Observable<Void> timer(long interval, TimeUnit unit,\n+            Scheduler scheduler) {\n+        return create(OperationTimer.timer(interval, unit, scheduler));\n+    }\n+\n     /**\n      * Drops items emitted by an Observable that are followed by newer items\n      * before a timeout value expires. The timer resets on each emission.",
    "output": "Add timer methods in Observable.java"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationTimer.java b/rxjava-core/src/main/java/rx/operators/OperationTimer.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationTimer.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationTimer.java\n@@ -0,0 +1,74 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.operators;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import rx.Observable.OnSubscribeFunc;\n+import rx.Observer;\n+import rx.Scheduler;\n+import rx.Subscription;\n+import rx.concurrency.Schedulers;\n+import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n+\n+public final class OperationTimer {\n+\n+\tpublic static OnSubscribeFunc<Void> timer(long interval, TimeUnit unit) {\n+        return timer(interval, unit, Schedulers.threadPoolForComputation());\n+    }\n+\n+    public static OnSubscribeFunc<Void> timer(final long delay, final TimeUnit unit, final Scheduler scheduler) {\n+        return new OnSubscribeFunc<Void>() {\n+            @Override\n+            public Subscription onSubscribe(Observer<? super Void> observer) {\n+                return new Timer(delay, unit, scheduler, observer).start();\n+            }\n+        };\n+    }\n+\t\n+\tprivate static class Timer {\n+        private final long period;\n+        private final TimeUnit unit;\n+        private final Scheduler scheduler;\n+        private final Observer<? super Void> observer;\n+        \n+        private Timer(long period, TimeUnit unit, Scheduler scheduler, Observer<? super Void> observer) {\n+            this.period = period;\n+            this.unit = unit;\n+            this.scheduler = scheduler;\n+            this.observer = observer;\n+        }\n+\n+        public Subscription start() {\n+            final Subscription s = scheduler.schedule(new Action0() {\n+                @Override\n+                public void call() {\n+                    observer.onNext(null);\n+                    observer.onCompleted();\n+                }\n+            }, period, unit);\n+\n+            return Subscriptions.create(new Action0() {\n+                @Override\n+                public void call() {\n+                    s.unsubscribe();\n+                }\n+            });\n+        }\n+    }\n+\n+}",
    "output": "Add OperationTimer"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java b/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n--- a/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n+++ b/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n@@ -29,7 +29,8 @@\n  */\n public class SerialSubscription implements Subscription {\n     private final AtomicReference<Subscription> reference = new AtomicReference<Subscription>(empty());\n-\n+    private volatile Subscription unsubscribe;\n+    \n     private static final Subscription UNSUBSCRIBED = new Subscription() {\n         @Override\n         public void unsubscribe() {\n@@ -50,8 +51,16 @@ public void setSubscription(final Subscription subscription) {\n             }\n             if (reference.compareAndSet(current, subscription)) {\n                 current.unsubscribe();\n+                if(subscription == UNSUBSCRIBED) {\n+                \tunsubscribe = current;\n+                }\n                 break;\n             }\n         } while (true);\n     }\n+    \n+    public Subscription getSubscription() {\n+    \tSubscription subscription = reference.get();\n+\t\treturn subscription == UNSUBSCRIBED ? unsubscribe : subscription;\n+    }\n }\n\ndiff --git a/rxjava-core/src/test/java/rx/subscriptions/SerialSubscriptionTests.java b/rxjava-core/src/test/java/rx/subscriptions/SerialSubscriptionTests.java\n--- a/rxjava-core/src/test/java/rx/subscriptions/SerialSubscriptionTests.java\n+++ b/rxjava-core/src/test/java/rx/subscriptions/SerialSubscriptionTests.java\n@@ -15,6 +15,7 @@\n  */\n package rx.subscriptions;\n \n+import static org.junit.Assert.assertSame;\n import static org.junit.Assert.fail;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n@@ -46,6 +47,25 @@ public void unsubscribingWithoutUnderlyingDoesNothing() {\n         serialSubscription.unsubscribe();\n     }\n     \n+    @Test\n+    public void getSubscriptionShouldReturnSubscriptionAfterUnsubscribe() {\n+    \t final Subscription underlying = mock(Subscription.class);\n+         serialSubscription.setSubscription(underlying);\n+         serialSubscription.unsubscribe();\n+         assertSame(underlying, serialSubscription.getSubscription());\n+    }\n+    \n+    @Test\n+    public void getSubscriptionShouldReturnSetSubscription() {\n+    \t final Subscription underlying = mock(Subscription.class);\n+         serialSubscription.setSubscription(underlying);\n+         assertSame(underlying, serialSubscription.getSubscription());\n+         \n+         final Subscription another = mock(Subscription.class);\n+         serialSubscription.setSubscription(another);\n+         assertSame(another, serialSubscription.getSubscription());\n+    }\n+    \n     @Test\n     public void unsubscribingTwiceDoesUnsubscribeOnce() {\n     \t Subscription underlying = mock(Subscription.class);",
    "output": "Fix: getSubscription should not expose internal sentinel subscription"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java b/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n--- a/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n+++ b/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n@@ -19,6 +19,9 @@\n \n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import rx.Subscription;\n \n@@ -29,25 +32,43 @@\n  * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.disposables.serialdisposable(v=vs.103).aspx\">Rx.Net equivalent SerialDisposable</a>\n  */\n public class SerialSubscription implements Subscription {\n-\tprivate final AtomicBoolean unsubscribed = new AtomicBoolean();\n-\tprivate final AtomicReference<Subscription> reference = new AtomicReference<Subscription>(empty());\n-\n-\t@Override\n-\tpublic void unsubscribe() {\n-\t\tif (unsubscribed.compareAndSet(false, true)) {\n-\t\t\treference.getAndSet(empty()).unsubscribe();\n-\t\t}\n-\t}\n-\n-\tpublic void setSubscription(final Subscription subscription) {\n-\t\tif (unsubscribed.get()) {\n-\t\t\tsubscription.unsubscribe();\n-\t\t} else {\n-\t\t\treference.getAndSet(subscription == null ? empty() : subscription).unsubscribe();\n-\t\t}\n-\t}\n-\n-\tpublic Subscription getSubscription() {\n-\t\treturn reference.get();\n-\t}\n+    private final AtomicBoolean unsubscribed = new AtomicBoolean();\n+    private final AtomicReference<Subscription> reference = new AtomicReference<Subscription>(empty());\n+    private final Lock read;\n+    private final Lock write;\n+\n+    public SerialSubscription() {\n+        final ReadWriteLock lock = new ReentrantReadWriteLock();\n+        read = lock.readLock();\n+        write = lock.writeLock();\n+    }\n+\n+    @Override\n+    public void unsubscribe() {\n+        write.lock();\n+        try {\n+            if (unsubscribed.compareAndSet(false, true)) {\n+                reference.getAndSet(empty()).unsubscribe();\n+            }\n+        } finally {\n+            write.unlock();\n+        }\n+    }\n+\n+    public void setSubscription(final Subscription subscription) {\n+        read.lock();\n+        try {\n+            if (unsubscribed.get()) {\n+                subscription.unsubscribe();\n+            } else {\n+                reference.getAndSet(subscription).unsubscribe();\n+            }\n+        } finally {\n+            read.unlock();\n+        }\n+    }\n+\n+    public Subscription getSubscription() {\n+        return reference.get();\n+    }\n }",
    "output": "Make unsubscribe + reference modification an atomic operation"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java b/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n--- a/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n+++ b/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n@@ -15,6 +15,11 @@\n  */\n package rx.subscriptions;\n \n+import static rx.subscriptions.Subscriptions.empty;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n import rx.Subscription;\n \n /**\n@@ -24,47 +29,25 @@\n  * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.disposables.serialdisposable(v=vs.103).aspx\">Rx.Net equivalent SerialDisposable</a>\n  */\n public class SerialSubscription implements Subscription {\n-    private boolean unsubscribed;\n-    private Subscription subscription;\n-    private final Object gate = new Object();\n+\tprivate final AtomicBoolean unsubscribed = new AtomicBoolean();\n+\tprivate final AtomicReference<Subscription> reference = new AtomicReference<Subscription>(empty());\n \n-    @Override\n-    public void unsubscribe() {\n-        Subscription toUnsubscribe = null;\n-        synchronized (gate) {\n-            if (!unsubscribed) {\n-                if (subscription != null) {\n-                    toUnsubscribe = subscription;\n-                    subscription = null;\n-                }\n-                unsubscribed = true;\n-            }\n-        }\n-        if (toUnsubscribe != null) {\n-            toUnsubscribe.unsubscribe();\n-        }\n-    }\n+\t@Override\n+\tpublic void unsubscribe() {\n+\t\tif (unsubscribed.compareAndSet(false, true)) {\n+\t\t\treference.getAndSet(empty()).unsubscribe();\n+\t\t}\n+\t}\n \n-    public Subscription getSubscription() {\n-        synchronized (gate) {\n-            return subscription;\n-        }\n-    }\n+\tpublic void setSubscription(final Subscription subscription) {\n+\t\tif (unsubscribed.get()) {\n+\t\t\tsubscription.unsubscribe();\n+\t\t} else {\n+\t\t\treference.getAndSet(subscription == null ? empty() : subscription).unsubscribe();\n+\t\t}\n+\t}\n \n-    public void setSubscription(Subscription subscription) {\n-        Subscription toUnsubscribe = null;\n-        synchronized (gate) {\n-            if (!unsubscribed) {\n-                if (this.subscription != null) {\n-                    toUnsubscribe = this.subscription;\n-                }\n-                this.subscription = subscription;\n-            } else {\n-                toUnsubscribe = subscription;\n-            }\n-        }\n-        if (toUnsubscribe != null) {\n-            toUnsubscribe.unsubscribe();\n-        }\n-    }\n+\tpublic Subscription getSubscription() {\n+\t\treturn reference.get();\n+\t}\n }\n\ndiff --git a/rxjava-core/src/test/java/rx/subscriptions/SerialSubscriptionTests.java b/rxjava-core/src/test/java/rx/subscriptions/SerialSubscriptionTests.java\n--- a/rxjava-core/src/test/java/rx/subscriptions/SerialSubscriptionTests.java\n+++ b/rxjava-core/src/test/java/rx/subscriptions/SerialSubscriptionTests.java\n@@ -15,7 +15,13 @@\n  */\n package rx.subscriptions;\n \n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n \n import org.junit.Before;\n import org.junit.Test;\n@@ -24,53 +30,94 @@\n import rx.Subscription;\n \n public class SerialSubscriptionTests {\n-    private SerialSubscription serialSubscription;\n-\n-    @Before\n-    public void setUp() {\n-        MockitoAnnotations.initMocks(this);\n-\n-        serialSubscription = new SerialSubscription();\n-    }\n-\n-    @Test\n-    public void unsubscribingWithoutUnderlyingDoesNothing() {\n-        serialSubscription.unsubscribe();\n-    }\n-\n-    @Test\n-    public void unsubscribingWithSingleUnderlyingUnsubscribes() {\n-        Subscription underlying = mock(Subscription.class);\n-        serialSubscription.setSubscription(underlying);\n-        underlying.unsubscribe();\n-        verify(underlying).unsubscribe();\n-    }\n-\n-    @Test\n-    public void replacingFirstUnderlyingCausesUnsubscription() {\n-        Subscription first = mock(Subscription.class);\n-        serialSubscription.setSubscription(first);\n-        Subscription second = mock(Subscription.class);\n-        serialSubscription.setSubscription(second);\n-        verify(first).unsubscribe();\n-    }\n-\n-    @Test\n-    public void whenUnsubscribingSecondUnderlyingUnsubscribed() {\n-        Subscription first = mock(Subscription.class);\n-        serialSubscription.setSubscription(first);\n-        Subscription second = mock(Subscription.class);\n-        serialSubscription.setSubscription(second);\n-        serialSubscription.unsubscribe();\n-        verify(second).unsubscribe();\n-    }\n-\n-    @Test\n-    public void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscription()\n-    {\n-        serialSubscription.unsubscribe();\n-        Subscription underlying = mock(Subscription.class);\n-        serialSubscription.setSubscription(underlying);\n-        verify(underlying).unsubscribe();\n-    }\n+\tprivate SerialSubscription serialSubscription;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\n+\t\tserialSubscription = new SerialSubscription();\n+\t}\n+\n+\t@Test\n+\tpublic void unsubscribingWithoutUnderlyingDoesNothing() {\n+\t\tserialSubscription.unsubscribe();\n+\t}\n+\n+\t@Test\n+\tpublic void unsubscribingWithSingleUnderlyingUnsubscribes() {\n+\t\tSubscription underlying = mock(Subscription.class);\n+\t\tserialSubscription.setSubscription(underlying);\n+\t\tunderlying.unsubscribe();\n+\t\tverify(underlying).unsubscribe();\n+\t}\n+\n+\t@Test\n+\tpublic void replacingFirstUnderlyingCausesUnsubscription() {\n+\t\tSubscription first = mock(Subscription.class);\n+\t\tserialSubscription.setSubscription(first);\n+\t\tSubscription second = mock(Subscription.class);\n+\t\tserialSubscription.setSubscription(second);\n+\t\tverify(first).unsubscribe();\n+\t}\n+\n+\t@Test\n+\tpublic void whenUnsubscribingSecondUnderlyingUnsubscribed() {\n+\t\tSubscription first = mock(Subscription.class);\n+\t\tserialSubscription.setSubscription(first);\n+\t\tSubscription second = mock(Subscription.class);\n+\t\tserialSubscription.setSubscription(second);\n+\t\tserialSubscription.unsubscribe();\n+\t\tverify(second).unsubscribe();\n+\t}\n+\n+\t@Test\n+\tpublic void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscription() {\n+\t\tserialSubscription.unsubscribe();\n+\t\tSubscription underlying = mock(Subscription.class);\n+\t\tserialSubscription.setSubscription(underlying);\n+\t\tverify(underlying).unsubscribe();\n+\t}\n+\n+\t@Test(timeout = 1000)\n+\tpublic void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscriptionConcurrently()\n+\t\t\tthrows InterruptedException {\n+\t\tfinal Subscription firstSet = mock(Subscription.class);\n+\t\tserialSubscription.setSubscription(firstSet);\n+\n+\t\tfinal CountDownLatch start = new CountDownLatch(1);\n+\n+\t\tfinal int count = 10;\n+\t\tfinal CountDownLatch end = new CountDownLatch(count);\n+\n+\t\tfinal List<Thread> threads = new ArrayList<Thread>();\n+\t\tfor (int i = 0 ; i < count ; i++) {\n+\t\t\tfinal Thread t = new Thread() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void run() {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tstart.await();\n+\t\t\t\t\t\tserialSubscription.unsubscribe();\n+\t\t\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t\t\tfail(e.getMessage());\n+\t\t\t\t\t} finally {\n+\t\t\t\t\t\tend.countDown();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t};\n+\t\t\tt.start();\n+\t\t\tthreads.add(t);\n+\t\t}\n+\n+\t\tfinal Subscription underlying = mock(Subscription.class);\n+\t\tstart.countDown();\n+\t\tserialSubscription.setSubscription(underlying);\n+\t\tend.await();\n+\t\tverify(firstSet).unsubscribe();\n+\t\tverify(underlying).unsubscribe();\n+\n+\t\tfor (final Thread t : threads) {\n+\t\t\tt.interrupt();\n+\t\t}\n+\t}\n }",
    "output": "Use lock free strategy\n\nReduce contention by using CAS (Compare And Swap) operations to replace\nsubscription"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -5518,7 +5518,7 @@ public Observable<T> doOnEach(Observer<? super T> observer) {\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach\">RxJava Wiki: doOnEach()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229804.aspx\">MSDN: Observable.Do</a>\n      */\n-    public Observable<T> doOnEach(final Action1<T> onNext) {\n+    public Observable<T> doOnEach(final Action1<? super T> onNext) {\n         Observer<T> observer = new Observer<T>() {\n             @Override\n             public void onCompleted() {}\n@@ -5609,7 +5609,7 @@ public void onNext(T args) { }\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach\">RxJava Wiki: doOnEach()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229539.aspx\">MSDN: Observable.Do</a>\n      */\n-    public Observable<T> doOnEach(final Action1<T> onNext, final Action1<Throwable> onError) {\n+    public Observable<T> doOnEach(final Action1<? super T> onNext, final Action1<Throwable> onError) {\n         Observer<T> observer = new Observer<T>() {\n             @Override\n             public void onCompleted() {}\n@@ -5644,7 +5644,7 @@ public void onNext(T args) {\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach\">RxJava Wiki: doOnEach()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229830.aspx\">MSDN: Observable.Do</a>\n      */\n-    public Observable<T> doOnEach(final Action1<T> onNext, final Action1<Throwable> onError, final Action0 onCompleted) {\n+    public Observable<T> doOnEach(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onCompleted) {\n         Observer<T> observer = new Observer<T>() {\n             @Override\n             public void onCompleted() {",
    "output": "Add type variances for doOnEach actions.\n\nThis fixes the use of contravariant actions"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationSkipUntil.java b/rxjava-core/src/main/java/rx/operators/OperationSkipUntil.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationSkipUntil.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationSkipUntil.java\n@@ -113,11 +113,7 @@ public void onError(Throwable e) {\n \n             @Override\n             public void onCompleted() {\n-                if (!running.get()) {\n-                    ResultManager.this.onCompleted();\n-                } else {\n-                    self.unsubscribe();\n-                }\n+                self.unsubscribe();\n             }\n             \n         }\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperationSkipUntilTest.java b/rxjava-core/src/test/java/rx/operators/OperationSkipUntilTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationSkipUntilTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationSkipUntilTest.java\n@@ -89,7 +89,7 @@ public void otherEmpty() {\n         \n         verify(observer, never()).onError(any(Throwable.class));\n         verify(observer, never()).onNext(any());\n-        verify(observer, times(1)).onCompleted();\n+        verify(observer, never()).onCompleted();\n     }\n     @Test\n     public void otherFiresAndCompletes() {",
    "output": "Fix case with skipUntil(empty()) == never() (matches Rx.NET)"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationZip.java b/rxjava-core/src/main/java/rx/operators/OperationZip.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationZip.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationZip.java\n@@ -445,8 +445,9 @@ public void onNext(T value) {\n                                     if (io.done) {\n                                         observer.onCompleted();\n                                         cancel.unsubscribe();\n+                                        return;\n                                     }\n-                                    return;\n+                                    continue;\n                                 }\n                                 Object v = io.queue.peek();\n                                 if (v == NULL_SENTINEL) {\n@@ -459,6 +460,8 @@ public void onNext(T value) {\n                                     io.queue.poll();\n                                 }\n                                 observer.onNext(values);\n+                            } else {\n+                            \tbreak;\n                             }\n                         }\n                     } finally {",
    "output": "Fix Zip issue with infinite streams"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java\n@@ -15,26 +15,145 @@\n  */\n package rx.android.observables;\n \n+import static org.mockito.Mockito.verify;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.robolectric.Robolectric;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n import rx.Observable;\n+import rx.Observer;\n import rx.operators.OperationObserveFromAndroidComponent;\n \n import android.app.Activity;\n import android.app.Fragment;\n+import android.os.Build;\n+import android.support.v4.app.FragmentActivity;\n+\n \n public final class AndroidObservable {\n \n+    private static final boolean USES_SUPPORT_FRAGMENTS;\n+\n+    static {\n+        boolean supportFragmentsAvailable = false;\n+        try {\n+            Class.forName(\"android.support.v4.app.Fragment\");\n+            supportFragmentsAvailable = true;\n+        } catch (ClassNotFoundException e) {\n+        }\n+        USES_SUPPORT_FRAGMENTS = supportFragmentsAvailable;\n+    }\n+\n     private AndroidObservable() {}\n \n+    /**\n+     * Transforms a source observable to be attached to the given Activity, in such a way that notifications will always\n+     * arrive on the main UI thread. Currently, this is equivalent to calling <code>observeOn(AndroidSchedulers.mainThread())</code>,\n+     * but this behavior may change in the future, so it is encouraged to use this wrapper instead.\n+     * <p/>\n+     * You must unsubscribe from the returned observable in <code>onDestroy</code> to not leak the given Activity.\n+     * <p/>\n+     * Ex.:\n+     * <pre>\n+     *     // in any Activity\n+     *     mSubscription = fromActivity(this, Observable.just(\"value\")).subscribe(...);\n+     *     // in onDestroy\n+     *     mSubscription.unsubscribe();\n+     * </pre>\n+     *\n+     * @param activity         the activity in which the source observable will be observed\n+     * @param sourceObservable the observable sequence to observe from the given Activity\n+     * @param <T>\n+     * @return a new observable sequence that will emit notifications on the main UI thread\n+     */\n     public static <T> Observable<T> fromActivity(Activity activity, Observable<T> sourceObservable) {\n         return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);\n     }\n \n-    public static <T> Observable<T> fromFragment(Fragment fragment, Observable<T> sourceObservable) {\n-        return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, fragment);\n+    /**\n+     * Transforms a source observable to be attached to the given fragment, in such a way that notifications will always\n+     * arrive on the main UI thread. Moreover, it will be guaranteed that no notifications will be delivered to the\n+     * fragment while it's in detached state (i.e. its host Activity was destroyed.) In other words, during calls\n+     * to onNext, you may assume that fragment.getActivity() will never return null.\n+     * <p/>\n+     * This method accepts both native fragments and support library fragments in its first parameter. It will throw\n+     * for unsupported types.\n+     * <p/>\n+     * You must unsubscribe from the returned observable in <code>onDestroy</code> to not leak the given fragment.\n+     * <p/>\n+     * Ex.:\n+     * <pre>\n+     *     // in any Fragment\n+     *     mSubscription = fromFragment(this, Observable.just(\"value\")).subscribe(...);\n+     *     // in onDestroy\n+     *     mSubscription.unsubscribe();\n+     * </pre>\n+     *\n+     * @param fragment         the fragment in which the source observable will be observed\n+     * @param sourceObservable the observable sequence to observe from the given fragment\n+     * @param <T>\n+     * @return a new observable sequence that will emit notifications on the main UI thread\n+     */\n+    public static <T> Observable<T> fromFragment(Object fragment, Observable<T> sourceObservable) {\n+        if (USES_SUPPORT_FRAGMENTS && fragment instanceof android.support.v4.app.Fragment) {\n+            return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);\n+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB && fragment instanceof Fragment) {\n+            return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);\n+        } else {\n+            throw new IllegalArgumentException(\"Target fragment is neither a native nor support library Fragment\");\n+        }\n     }\n \n-    public static <T> Observable<T> fromFragment(android.support.v4.app.Fragment fragment, Observable<T> sourceObservable) {\n-        return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, fragment);\n+    @RunWith(RobolectricTestRunner.class)\n+    @Config(manifest = Config.NONE)\n+    public static final class AndroidObservableTest {\n+\n+        // support library fragments\n+        private FragmentActivity fragmentActivity;\n+        private android.support.v4.app.Fragment supportFragment;\n+\n+        // native fragments\n+        private Activity activity;\n+        private Fragment fragment;\n+\n+        @Mock\n+        private Observer<String> observer;\n+\n+        @Before\n+        public void setup() {\n+            MockitoAnnotations.initMocks(this);\n+            supportFragment = new android.support.v4.app.Fragment();\n+            fragmentActivity = Robolectric.buildActivity(FragmentActivity.class).create().get();\n+            fragmentActivity.getSupportFragmentManager().beginTransaction().add(supportFragment, null).commit();\n+\n+            fragment = new Fragment();\n+            activity = Robolectric.buildActivity(Activity.class).create().get();\n+            activity.getFragmentManager().beginTransaction().add(fragment, null).commit();\n+        }\n+\n+        @Test\n+        public void itSupportsFragmentsFromTheSupportV4Library() {\n+            fromFragment(supportFragment, Observable.just(\"success\")).subscribe(observer);\n+            verify(observer).onNext(\"success\");\n+            verify(observer).onCompleted();\n+        }\n+\n+        @Test\n+        public void itSupportsNativeFragments() {\n+            fromFragment(fragment, Observable.just(\"success\")).subscribe(observer);\n+            verify(observer).onNext(\"success\");\n+            verify(observer).onCompleted();\n+        }\n+\n+        @Test(expected = IllegalArgumentException.class)\n+        public void itThrowsIfObjectPassedIsNotAFragment() {\n+            fromFragment(\"not a fragment\", Observable.never());\n+        }\n     }\n \n }",
    "output": "Use Object as argument type for fromFragment helper\n\nThis is to prevent compilation failures in projects that do not link the support-v4 library. The only other option I saw to fix this would have been to split up the android module into one for native fragments and one for support fragments, which I found would come with unjustified overhead. Hence I settled for the cheap way, which is to sacrifice type safety here.\n\nRefs https://github.com/soundcloud/RxJava/issues/2"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationInterval.java b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n@@ -78,7 +78,6 @@ public void call() {\n                 @Override\n                 public void call() {\n                     wrapped.unsubscribe();\n-                    observer.onCompleted();\n                 }\n             });\n         }\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperationIntervalTest.java b/rxjava-core/src/test/java/rx/operators/OperationIntervalTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationIntervalTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationIntervalTest.java\n@@ -66,7 +66,7 @@ public void testInterval() {\n         sub.unsubscribe();\n         scheduler.advanceTimeTo(4, TimeUnit.SECONDS);\n         verify(observer, never()).onNext(2L);\n-        verify(observer, times(1)).onCompleted();\n+        verify(observer, never()).onCompleted();\n         verify(observer, never()).onError(any(Throwable.class));\n     }\n \n@@ -101,11 +101,11 @@ public void testWithMultipleSubscribersStartingAtSameTime() {\n         scheduler.advanceTimeTo(4, TimeUnit.SECONDS);\n \n         verify(observer, never()).onNext(2L);\n-        verify(observer, times(1)).onCompleted();\n+        verify(observer, never()).onCompleted();\n         verify(observer, never()).onError(any(Throwable.class));\n \n         verify(observer2, never()).onNext(2L);\n-        verify(observer2, times(1)).onCompleted();\n+        verify(observer2, never()).onCompleted();\n         verify(observer2, never()).onError(any(Throwable.class));\n     }\n \n@@ -141,11 +141,11 @@ public void testWithMultipleStaggeredSubscribers() {\n         sub2.unsubscribe();\n \n         inOrder1.verify(observer, never()).onNext(anyLong());\n-        inOrder1.verify(observer, times(1)).onCompleted();\n+        inOrder1.verify(observer, never()).onCompleted();\n         verify(observer, never()).onError(any(Throwable.class));\n \n         inOrder2.verify(observer2, never()).onNext(anyLong());\n-        inOrder2.verify(observer2, times(1)).onCompleted();\n+        inOrder2.verify(observer2, never()).onCompleted();\n         verify(observer2, never()).onError(any(Throwable.class));\n     }\n ",
    "output": "Fix the issue #521"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -969,7 +969,18 @@ public static Observable<Integer> range(int start, int count, Scheduler schedule\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229428(v=vs.103).aspx\">MSDN: Observable.Repeat</a>\n      */\n     public Observable<T> repeat() {\n-        return create(rx.operators.OperationRepeat.repeat(this));\n+        return this.repeat(Schedulers.currentThread());\n+    }\n+\n+    /**\n+     * Repeats the observable sequence indefinitely.\n+     * <p>\n+     * @param scheduler the scheduler to send the values on.\n+     * @return The observable sequence producing the elements of the given sequence repeatedly and sequentially.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229428(v=vs.103).aspx\">MSDN: Observable.Repeat</a>\n+     */\n+    public Observable<T> repeat(Scheduler scheduler) {\n+        return create(OperationRepeat.repeat(this, scheduler));\n     }\n \n     /**\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationRepeat.java b/rxjava-core/src/main/java/rx/operators/OperationRepeat.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationRepeat.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationRepeat.java\n@@ -18,35 +18,36 @@\n \n import rx.Observable;\n import rx.Observer;\n+import rx.Scheduler;\n import rx.Subscription;\n-import rx.concurrency.Schedulers;\n-import rx.subscriptions.SerialSubscription;\n+import rx.subscriptions.MultipleAssignmentSubscription;\n import rx.util.functions.Action0;\n import rx.util.functions.Action1;\n \n public class OperationRepeat<T> implements Observable.OnSubscribeFunc<T> {\n \n     private final Observable<T> source;\n+    private final Scheduler scheduler;\n \n-    public static <T> Observable.OnSubscribeFunc<T> repeat(Observable<T> seed) {\n-        return new OperationRepeat(seed);\n+    public static <T> Observable.OnSubscribeFunc<T> repeat(Observable<T> source, Scheduler scheduler) {\n+        return new OperationRepeat(source, scheduler);\n     }\n \n-    private OperationRepeat(Observable<T> source) {\n+    private OperationRepeat(Observable<T> source, Scheduler scheduler) {\n         this.source = source;\n+        this.scheduler = scheduler;\n     }\n \n     @Override\n     public Subscription onSubscribe(final Observer<? super T> observer) {\n-        final SerialSubscription subscription = new SerialSubscription();\n-        subscription.setSubscription(Schedulers.currentThread().schedule(new Action1<Action0>() {\n+        final MultipleAssignmentSubscription subscription = new MultipleAssignmentSubscription();\n+        subscription.setSubscription(scheduler.schedule(new Action1<Action0>() {\n             @Override\n             public void call(final Action0 self) {\n                 subscription.setSubscription(source.subscribe(new Observer<T>() {\n \n                     @Override\n                     public void onCompleted() {\n-                        subscription.getSubscription().unsubscribe();\n                         self.call();\n                     }\n \n\ndiff --git a/rxjava-core/src/test/java/rx/ObservableTests.java b/rxjava-core/src/test/java/rx/ObservableTests.java\n--- a/rxjava-core/src/test/java/rx/ObservableTests.java\n+++ b/rxjava-core/src/test/java/rx/ObservableTests.java\n@@ -15,35 +15,36 @@\n  */\n package rx;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n-\n import rx.Observable.OnSubscribeFunc;\n+import rx.concurrency.Schedulers;\n import rx.concurrency.TestScheduler;\n import rx.observables.ConnectableObservable;\n import rx.subscriptions.BooleanSubscription;\n import rx.subscriptions.Subscriptions;\n-import rx.util.functions.Action0;\n import rx.util.functions.Action1;\n import rx.util.functions.Func1;\n import rx.util.functions.Func2;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.*;\n+\n public class ObservableTests {\n \n     @Mock\n@@ -958,4 +959,11 @@ public void testRangeWithScheduler() {\n         inOrder.verify(aObserver, times(1)).onCompleted();\n         inOrder.verifyNoMoreInteractions();\n     }\n+\n+    @Test\n+    public void testRepeatTake() {\n+        Observable<Integer> xs = Observable.from(1,2);\n+        Object[] ys = xs.repeat(Schedulers.newThread()).take(4).toList().toBlockingObservable().last().toArray();\n+        assertArrayEquals(new Object[]{ 1, 2, 1, 2}, ys);\n+    }\n }\n\\ No newline at end of file",
    "output": "Add test"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationRepeat.java b/rxjava-core/src/main/java/rx/operators/OperationRepeat.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationRepeat.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationRepeat.java\n@@ -18,53 +18,50 @@\n \n import rx.Observable;\n import rx.Observer;\n-import rx.Scheduler;\n import rx.Subscription;\n import rx.concurrency.Schedulers;\n-import rx.subscriptions.MultipleAssignmentSubscription;\n-import rx.util.functions.Func2;\n+import rx.subscriptions.SerialSubscription;\n+import rx.util.functions.Action0;\n+import rx.util.functions.Action1;\n \n-public final class OperationRepeat {\n+public class OperationRepeat<T> implements Observable.OnSubscribeFunc<T> {\n \n-    public static <T> Observable.OnSubscribeFunc<T> repeat(Observable<? extends T> source) {\n-        return new RepeatObservable<T>(source);\n-    }\n-\n-    static class RepeatObservable<T> implements Observable.OnSubscribeFunc<T> {\n+    private final Observable<T> source;\n \n-        RepeatObservable(Observable<? extends T> source) {\n-            this.source = source;\n-        }\n+    public static <T> Observable.OnSubscribeFunc<T> repeat(Observable<T> seed) {\n+        return new OperationRepeat(seed);\n+    }\n \n-        private Observable<? extends T> source;\n-        private Observer<? super T> observer;\n-        private MultipleAssignmentSubscription subscription =  new MultipleAssignmentSubscription();\n+    private OperationRepeat(Observable<T> source) {\n+        this.source = source;\n+    }\n \n-        @Override\n-        public Subscription onSubscribe(Observer observer) {\n-            this.observer = observer;\n-            Loop();\n-            return subscription;\n-        }\n+    @Override\n+    public Subscription onSubscribe(final Observer<? super T> observer) {\n+        final SerialSubscription subscription = new SerialSubscription();\n+        subscription.setSubscription(Schedulers.currentThread().schedule(new Action1<Action0>() {\n+            @Override\n+            public void call(final Action0 self) {\n+                subscription.setSubscription(source.subscribe(new Observer<T>() {\n \n-        void Loop() {\n-            subscription.setSubscription(Schedulers.currentThread().schedule(0, new Func2<Scheduler, Integer, Subscription>() {\n-                @Override\n-                public Subscription call(Scheduler s, Integer n) {\n-                    return source.subscribe(new Observer<T>() {\n-                        @Override\n-                        public void onCompleted() { Loop();  }\n+                    @Override\n+                    public void onCompleted() {\n+                        subscription.getSubscription().unsubscribe();\n+                        self.call();\n+                    }\n \n-                        @Override\n-                        public void onError(Throwable error) { observer.onError(error); }\n+                    @Override\n+                    public void onError(Throwable error) {\n+                        observer.onError(error);\n+                    }\n \n-                        @Override\n-                        public void onNext(T value) { observer.onNext(value); }\n-                    });\n-                }\n-            }));\n-        }\n+                    @Override\n+                    public void onNext(T value) {\n+                        observer.onNext(value);\n+                    }\n+                }));\n+            }\n+        }));\n+        return subscription;\n     }\n-\n-\n-}\n+}\n\\ No newline at end of file",
    "output": "Add OperationRepeat & repeat operator"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -15,83 +15,11 @@\n  */\n package rx;\n \n-import static rx.util.functions.Functions.*;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-\n import rx.concurrency.Schedulers;\n import rx.observables.BlockingObservable;\n import rx.observables.ConnectableObservable;\n import rx.observables.GroupedObservable;\n-import rx.operators.OperationAll;\n-import rx.operators.OperationAmb;\n-import rx.operators.OperationAny;\n-import rx.operators.OperationAverage;\n-import rx.operators.OperationBuffer;\n-import rx.operators.OperationCache;\n-import rx.operators.OperationCast;\n-import rx.operators.OperationCombineLatest;\n-import rx.operators.OperationConcat;\n-import rx.operators.OperationDebounce;\n-import rx.operators.OperationDefaultIfEmpty;\n-import rx.operators.OperationDefer;\n-import rx.operators.OperationDematerialize;\n-import rx.operators.OperationDistinct;\n-import rx.operators.OperationDistinctUntilChanged;\n-import rx.operators.OperationDoOnEach;\n-import rx.operators.OperationElementAt;\n-import rx.operators.OperationFilter;\n-import rx.operators.OperationFinally;\n-import rx.operators.OperationFirstOrDefault;\n-import rx.operators.OperationGroupBy;\n-import rx.operators.OperationInterval;\n-import rx.operators.OperationLast;\n-import rx.operators.OperationMap;\n-import rx.operators.OperationMaterialize;\n-import rx.operators.OperationMerge;\n-import rx.operators.OperationMergeDelayError;\n-import rx.operators.OperationMinMax;\n-import rx.operators.OperationMulticast;\n-import rx.operators.OperationObserveOn;\n-import rx.operators.OperationOnErrorResumeNextViaFunction;\n-import rx.operators.OperationOnErrorResumeNextViaObservable;\n-import rx.operators.OperationOnErrorReturn;\n-import rx.operators.OperationOnExceptionResumeNextViaObservable;\n-import rx.operators.OperationParallel;\n-import rx.operators.OperationParallelMerge;\n-import rx.operators.OperationRetry;\n-import rx.operators.OperationSample;\n-import rx.operators.OperationScan;\n-import rx.operators.OperationSkip;\n-import rx.operators.OperationSkipLast;\n-import rx.operators.OperationSkipWhile;\n-import rx.operators.OperationSubscribeOn;\n-import rx.operators.OperationSum;\n-import rx.operators.OperationSwitch;\n-import rx.operators.OperationSynchronize;\n-import rx.operators.OperationTake;\n-import rx.operators.OperationTakeLast;\n-import rx.operators.OperationTakeUntil;\n-import rx.operators.OperationTakeWhile;\n-import rx.operators.OperationThrottleFirst;\n-import rx.operators.OperationTimeInterval;\n-import rx.operators.OperationTimeout;\n-import rx.operators.OperationTimestamp;\n-import rx.operators.OperationToObservableFuture;\n-import rx.operators.OperationToObservableIterable;\n-import rx.operators.OperationToObservableList;\n-import rx.operators.OperationToObservableSortedList;\n-import rx.operators.OperationUsing;\n-import rx.operators.OperationWindow;\n-import rx.operators.OperationZip;\n-import rx.operators.SafeObservableSubscription;\n-import rx.operators.SafeObserver;\n+import rx.operators.*;\n import rx.plugins.RxJavaErrorHandler;\n import rx.plugins.RxJavaObservableExecutionHook;\n import rx.plugins.RxJavaPlugins;\n@@ -100,26 +28,19 @@\n import rx.subjects.ReplaySubject;\n import rx.subjects.Subject;\n import rx.subscriptions.Subscriptions;\n-import rx.util.Closing;\n-import rx.util.OnErrorNotImplementedException;\n-import rx.util.Opening;\n-import rx.util.Range;\n-import rx.util.TimeInterval;\n-import rx.util.Timestamped;\n-import rx.util.functions.Action0;\n-import rx.util.functions.Action1;\n-import rx.util.functions.Func0;\n-import rx.util.functions.Func1;\n-import rx.util.functions.Func2;\n-import rx.util.functions.Func3;\n-import rx.util.functions.Func4;\n-import rx.util.functions.Func5;\n-import rx.util.functions.Func6;\n-import rx.util.functions.Func7;\n-import rx.util.functions.Func8;\n-import rx.util.functions.Func9;\n-import rx.util.functions.FuncN;\n-import rx.util.functions.Function;\n+import rx.util.*;\n+import rx.util.functions.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static rx.util.functions.Functions.alwaysFalse;\n+import static rx.util.functions.Functions.not;\n \n /**\n  * The Observable interface that implements the Reactive Pattern.\n@@ -1040,6 +961,17 @@ public static Observable<Integer> range(int start, int count, Scheduler schedule\n         return range(start, count).observeOn(scheduler);\n     }\n \n+    /**\n+     * Repeats the observable sequence indefinitely.\n+     * <p>\n+     *\n+     * @return The observable sequence producing the elements of the given sequence repeatedly and sequentially.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229428(v=vs.103).aspx\">MSDN: Observable.Repeat</a>\n+     */\n+    public Observable<T> repeat() {\n+        return create(rx.operators.OperationRepeat.repeat(this));\n+    }\n+\n     /**\n      * Returns an Observable that calls an Observable factory to create its\n      * Observable for each new Observer that subscribes. That is, for each\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationRepeat.java b/rxjava-core/src/main/java/rx/operators/OperationRepeat.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationRepeat.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationRepeat.java\n@@ -0,0 +1,70 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package rx.operators;\n+\n+import rx.Observable;\n+import rx.Observer;\n+import rx.Scheduler;\n+import rx.Subscription;\n+import rx.concurrency.Schedulers;\n+import rx.subscriptions.MultipleAssignmentSubscription;\n+import rx.util.functions.Func2;\n+\n+public final class OperationRepeat {\n+\n+    public static <T> Observable.OnSubscribeFunc<T> repeat(Observable<? extends T> source) {\n+        return new RepeatObservable<T>(source);\n+    }\n+\n+    static class RepeatObservable<T> implements Observable.OnSubscribeFunc<T> {\n+\n+        RepeatObservable(Observable<? extends T> source) {\n+            this.source = source;\n+        }\n+\n+        private Observable<? extends T> source;\n+        private Observer<? super T> observer;\n+        private MultipleAssignmentSubscription subscription =  new MultipleAssignmentSubscription();\n+\n+        @Override\n+        public Subscription onSubscribe(Observer observer) {\n+            this.observer = observer;\n+            Loop();\n+            return subscription;\n+        }\n+\n+        void Loop() {\n+            subscription.setSubscription(Schedulers.currentThread().schedule(0, new Func2<Scheduler, Integer, Subscription>() {\n+                @Override\n+                public Subscription call(Scheduler s, Integer n) {\n+                    return source.subscribe(new Observer<T>() {\n+                        @Override\n+                        public void onCompleted() { Loop();  }\n+\n+                        @Override\n+                        public void onError(Throwable error) { observer.onError(error); }\n+\n+                        @Override\n+                        public void onNext(T value) { observer.onNext(value); }\n+                    });\n+                }\n+            }));\n+        }\n+    }\n+\n+\n+}",
    "output": "Add OperationRepeat & repeat operator"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperationJoinTest.java b/rxjava-core/src/test/java/rx/operators/OperationJoinTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationJoinTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationJoinTest.java\n@@ -49,14 +49,6 @@ public Observable<T> call(Integer t1) {\n             }\n         };\n     }\n-    Action1<Integer> toList(final Collection<Integer> out) {\n-        return new Action1<Integer>() {\n-            @Override\n-            public void call(Integer t1) {\n-                out.add(t1);\n-            }\n-        };\n-    }\n     @Before\n     public void before() {\n         MockitoAnnotations.initMocks(this);",
    "output": "Remove unused test function"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -3649,7 +3649,7 @@ public static Observable<Double> averageDoubles(Observable<Double> source) {\n      *            if the source is empty\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229715(v=vs.103).aspx\">MSDN: Observable.Min</a>\n      */\n-    public static <T extends Comparable<T>> Observable<T> min(Observable<T> source) {\n+    public static <T extends Comparable<? super T>> Observable<T> min(Observable<T> source) {\n         return OperationMinMax.min(source);\n     }\n \n@@ -3665,7 +3665,7 @@ public static <T extends Comparable<T>> Observable<T> min(Observable<T> source)\n      *            if the source is empty\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229095(v=vs.103).aspx\">MSDN: Observable.Min</a>\n      */\n-    public Observable<T> min(Comparator<T> comparator) {\n+    public Observable<T> min(Comparator<? super T> comparator) {\n         return OperationMinMax.min(this, comparator);\n     }\n \n@@ -3678,7 +3678,7 @@ public Observable<T> min(Comparator<T> comparator) {\n      * @return an observable emitting a List of the elements with the minimum key value.\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh228970(v=vs.103).aspx\">MSDN: Observable.MinBy</a>\n      */\n-    public <R extends Comparable<R>> Observable<List<T>> minBy(Func1<T, R> selector) {\n+    public <R extends Comparable<? super R>> Observable<List<T>> minBy(Func1<T, R> selector) {\n         return OperationMinMax.minBy(this, selector);\n     }\n \n@@ -3693,7 +3693,7 @@ public <R extends Comparable<R>> Observable<List<T>> minBy(Func1<T, R> selector)\n      * @return an observable emitting a List of the elements with the minimum key value  according to the specified comparator.\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh228970(v=vs.103).aspx\">MSDN: Observable.MinBy</a>\n      */\n-    public <R> Observable<List<T>> minBy(Func1<T, R> selector, Comparator<R> comparator) {\n+    public <R> Observable<List<T>> minBy(Func1<T, R> selector, Comparator<? super R> comparator) {\n         return OperationMinMax.minBy(this, selector, comparator);\n     }\n \n@@ -3709,7 +3709,7 @@ public <R> Observable<List<T>> minBy(Func1<T, R> selector, Comparator<R> compara\n      *            if the source is empty.\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211837(v=vs.103).aspx\">MSDN: Observable.Max</a>\n      */\n-    public static <T extends Comparable<T>> Observable<T> max(Observable<T> source) {\n+    public static <T extends Comparable<? super T>> Observable<T> max(Observable<T> source) {\n         return OperationMinMax.max(source);\n     }\n \n@@ -3725,7 +3725,7 @@ public static <T extends Comparable<T>> Observable<T> max(Observable<T> source)\n      *            if the source is empty.\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211635(v=vs.103).aspx\">MSDN: Observable.Max</a>\n      */\n-    public Observable<T> max(Comparator<T> comparator) {\n+    public Observable<T> max(Comparator<? super T> comparator) {\n         return OperationMinMax.max(this, comparator);\n     }\n \n@@ -3738,7 +3738,7 @@ public Observable<T> max(Comparator<T> comparator) {\n      * @return an observable emitting a List of the elements with the maximum key value.\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229058(v=vs.103).aspx\">MSDN: Observable.MaxBy</a>\n      */\n-    public <R extends Comparable<R>> Observable<List<T>> maxBy(Func1<T, R> selector) {\n+    public <R extends Comparable<? super R>> Observable<List<T>> maxBy(Func1<T, R> selector) {\n         return OperationMinMax.maxBy(this, selector);\n     }\n \n@@ -3753,7 +3753,7 @@ public <R extends Comparable<R>> Observable<List<T>> maxBy(Func1<T, R> selector)\n      * @return an observable emitting a List of the elements with the maximum key value  according to the specified comparator.\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh244330(v=vs.103).aspx\">MSDN: Observable.MaxBy</a>\n      */\n-    public <R> Observable<List<T>> maxBy(Func1<T, R> selector, Comparator<R> comparator) {\n+    public <R> Observable<List<T>> maxBy(Func1<T, R> selector, Comparator<? super R> comparator) {\n         return OperationMinMax.maxBy(this, selector, comparator);\n     }\n \n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationMinMax.java b/rxjava-core/src/main/java/rx/operators/OperationMinMax.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationMinMax.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationMinMax.java\n@@ -28,47 +28,47 @@\n  */\n public class OperationMinMax {\n \n-    public static <T extends Comparable<T>> Observable<T> min(\n+    public static <T extends Comparable<? super T>> Observable<T> min(\n             Observable<T> source) {\n         return minMax(source, -1L);\n     }\n \n     public static <T> Observable<T> min(Observable<T> source,\n-            final Comparator<T> comparator) {\n+            final Comparator<? super T> comparator) {\n         return minMax(source, comparator, -1L);\n     }\n \n-    public static <T, R extends Comparable<R>> Observable<List<T>> minBy(\n+    public static <T, R extends Comparable<? super R>> Observable<List<T>> minBy(\n             Observable<T> source, final Func1<T, R> selector) {\n         return minMaxBy(source, selector, -1L);\n     }\n \n     public static <T, R> Observable<List<T>> minBy(Observable<T> source,\n-            final Func1<T, R> selector, final Comparator<R> comparator) {\n+            final Func1<T, R> selector, final Comparator<? super R> comparator) {\n         return minMaxBy(source, selector, comparator, -1L);\n     }\n \n-    public static <T extends Comparable<T>> Observable<T> max(\n+    public static <T extends Comparable<? super T>> Observable<T> max(\n             Observable<T> source) {\n         return minMax(source, 1L);\n     }\n \n     public static <T> Observable<T> max(Observable<T> source,\n-            final Comparator<T> comparator) {\n+            final Comparator<? super T> comparator) {\n         return minMax(source, comparator, 1L);\n     }\n \n-    public static <T, R extends Comparable<R>> Observable<List<T>> maxBy(\n+    public static <T, R extends Comparable<? super R>> Observable<List<T>> maxBy(\n             Observable<T> source, final Func1<T, R> selector) {\n         return minMaxBy(source, selector, 1L);\n     }\n \n     public static <T, R> Observable<List<T>> maxBy(Observable<T> source,\n-            final Func1<T, R> selector, final Comparator<R> comparator) {\n+            final Func1<T, R> selector, final Comparator<? super R> comparator) {\n         return minMaxBy(source, selector, comparator, 1L);\n     }\n \n-    private static <T extends Comparable<T>> Observable<T> minMax(\n+    private static <T extends Comparable<? super T>> Observable<T> minMax(\n             Observable<T> source, final long flag) {\n         return source.reduce(new Func2<T, T, T>() {\n             @Override\n@@ -82,7 +82,7 @@ public T call(T acc, T value) {\n     }\n \n     private static <T> Observable<T> minMax(Observable<T> source,\n-            final Comparator<T> comparator, final long flag) {\n+            final Comparator<? super T> comparator, final long flag) {\n         return source.reduce(new Func2<T, T, T>() {\n             @Override\n             public T call(T acc, T value) {\n@@ -94,7 +94,7 @@ public T call(T acc, T value) {\n         });\n     }\n \n-    private static <T, R extends Comparable<R>> Observable<List<T>> minMaxBy(\n+    private static <T, R extends Comparable<? super R>> Observable<List<T>> minMaxBy(\n             Observable<T> source, final Func1<T, R> selector, final long flag) {\n         return source.reduce(new ArrayList<T>(),\n                 new Func2<List<T>, T, List<T>>() {\n@@ -119,7 +119,7 @@ public List<T> call(List<T> acc, T value) {\n     }\n \n     private static <T, R> Observable<List<T>> minMaxBy(Observable<T> source,\n-            final Func1<T, R> selector, final Comparator<R> comparator,\n+            final Func1<T, R> selector, final Comparator<? super R> comparator,\n             final long flag) {\n         return source.reduce(new ArrayList<T>(),\n                 new Func2<List<T>, T, List<T>>() {",
    "output": "Add contravariant for min and max"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -4782,17 +4782,149 @@ public static <T> Observable<T> amb(Iterable<? extends Observable<? extends T>>\n     /**\n      * Invokes an action for each element in the observable sequence.\n      *\n-     * @param func\n+     * @param observer\n      *            The action to invoke for each element in the source sequence.\n      *\n      * @return\n      *            The source sequence with the side-effecting behavior applied.\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229115(v=vs.103).aspx\">MSDN: Observable.Amb</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229307(v=vs.103).aspx\">MSDN: Observable.Do</a>\n      */\n     public Observable<T> doOnEach(Observer<? super T> observer) {\n         return create(OperationDoOnEach.doOnEach(this, observer));\n     }\n \n+    /**\n+     * Invokes an action for each element in the observable sequence.\n+     *\n+     * @param onNext\n+     *            The action to invoke for each element in the source sequence.\n+     *\n+     * @return\n+     *            The source sequence with the side-effecting behavior applied.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229804(v=vs.103).aspx\">MSDN: Observable.Do</a>\n+     */\n+    public Observable<T> doOnEach(final Action1<T> onNext) {\n+        Observer<T> observer = new Observer<T>() {\n+            @Override\n+            public void onCompleted() {}\n+\n+            @Override\n+            public void onError(Throwable e) {}\n+\n+            @Override\n+            public void onNext(T args) {\n+                onNext.call(args);\n+            }\n+\n+        };\n+\n+\n+        return create(OperationDoOnEach.doOnEach(this, observer));\n+    }\n+\n+    /**\n+     * Invokes an action for each element in the observable sequence.\n+     *\n+     * @param onNext\n+     *            The action to invoke for each element in the source sequence.\n+     * @param onCompleted\n+     *            The action to invoke when the source sequence is completed.\n+     *\n+     * @return\n+     *            The source sequence with the side-effecting behavior applied.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229659(v=vs.103).aspx\">MSDN: Observable.Do</a>\n+     */\n+    public Observable<T> doOnEach(final Action1<T> onNext, final Action0 onCompleted) {\n+        Observer<T> observer = new Observer<T>() {\n+            @Override\n+            public void onCompleted() {\n+                onCompleted.call();\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {}\n+\n+            @Override\n+            public void onNext(T args) {\n+                onNext.call(args);\n+            }\n+\n+        };\n+\n+\n+        return create(OperationDoOnEach.doOnEach(this, observer));\n+    }\n+\n+    /**\n+     * Invokes an action for each element in the observable sequence.\n+     *\n+     * @param onNext\n+     *            The action to invoke for each element in the source sequence.\n+     * @param onError\n+     *            The action to invoke when the source sequence calls onError.\n+     *\n+     * @return\n+     *            The source sequence with the side-effecting behavior applied.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229539(v=vs.103).aspx\">MSDN: Observable.Do</a>\n+     */\n+    public Observable<T> doOnEach(final Action1<T> onNext, final Action1<Throwable> onError) {\n+        Observer<T> observer = new Observer<T>() {\n+            @Override\n+            public void onCompleted() {}\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                onError.call(e);\n+            }\n+\n+            @Override\n+            public void onNext(T args) {\n+                onNext.call(args);\n+            }\n+\n+        };\n+\n+\n+        return create(OperationDoOnEach.doOnEach(this, observer));\n+    }\n+\n+\n+    /**\n+     * Invokes an action for each element in the observable sequence.\n+     *\n+     * @param onNext\n+     *            The action to invoke for each element in the source sequence.\n+     * @param onError\n+     *            The action to invoke when the source sequence calls onError.\n+     * @param onCompleted\n+     *            The action to invoke when the source sequence is completed.\n+     *\n+     * @return\n+     *            The source sequence with the side-effecting behavior applied.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229830(v=vs.103).aspx\">MSDN: Observable.Do</a>\n+     */\n+    public Observable<T> doOnEach(final Action1<T> onNext, final Action1<Throwable> onError, final Action0 onCompleted) {\n+        Observer<T> observer = new Observer<T>() {\n+            @Override\n+            public void onCompleted() {\n+                onCompleted.call();\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                onError.call(e);\n+            }\n+\n+            @Override\n+            public void onNext(T args) {\n+                onNext.call(args);\n+            }\n+\n+        };\n+\n+\n+        return create(OperationDoOnEach.doOnEach(this, observer));\n+    }\n \n     /**\n      * Whether a given {@link Function} is an internal implementation inside rx.* packages or not.",
    "output": "Add other overrides for doOnEach"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -43,6 +43,7 @@\n import rx.operators.OperationDematerialize;\n import rx.operators.OperationDistinct;\n import rx.operators.OperationDistinctUntilChanged;\n+import rx.operators.OperationDoOnEach;\n import rx.operators.OperationElementAt;\n import rx.operators.OperationFilter;\n import rx.operators.OperationFinally;\n@@ -4777,6 +4778,22 @@ public static <T> Observable<T> amb(Iterable<? extends Observable<? extends T>>\n         return create(OperationAmb.amb(sources));\n     }\n \n+\n+    /**\n+     * Invokes an action for each element in the observable sequence.\n+     *\n+     * @param func\n+     *            The action to invoke for each element in the source sequence.\n+     *\n+     * @return\n+     *            The source sequence with the side-effecting behavior applied.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229115(v=vs.103).aspx\">MSDN: Observable.Amb</a>\n+     */\n+    public Observable<T> doOnEach(Observer<? super T> observer) {\n+        return create(OperationDoOnEach.doOnEach(this, observer));\n+    }\n+\n+\n     /**\n      * Whether a given {@link Function} is an internal implementation inside rx.* packages or not.\n      * <p>\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationDoOnEach.java b/rxjava-core/src/main/java/rx/operators/OperationDoOnEach.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationDoOnEach.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationDoOnEach.java\n@@ -0,0 +1,66 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.operators;\n+\n+import rx.Observable;\n+import rx.Observer;\n+import rx.Observable.OnSubscribeFunc;\n+import rx.Subscription;\n+\n+/**\n+ * Converts the elements of an observable sequence to the specified type.\n+ */\n+public class OperationDoOnEach {\n+    public static <T> OnSubscribeFunc<T> doOnEach(Observable<? extends T> source, Observer<? super T> observer) {\n+        return new DoOnEachObservable<T>(source, observer);\n+    }\n+\n+    private static class DoOnEachObservable<T> implements OnSubscribeFunc<T> {\n+\n+        private final Observable<? extends T> source;\n+        private final Observer<? super T> doOnEachObserver;\n+\n+        public DoOnEachObservable(Observable<? extends T> source, Observer<? super T> doOnEachObserver) {\n+            this.source = source;\n+            this.doOnEachObserver = doOnEachObserver;\n+        }\n+\n+        @Override\n+        public Subscription onSubscribe(final Observer<? super T> observer) {\n+            return source.subscribe(new Observer<T>() {\n+                @Override\n+                public void onCompleted() {\n+                    doOnEachObserver.onCompleted();\n+                    observer.onCompleted();\n+                }\n+\n+                @Override\n+                public void onError(Throwable e) {\n+                    doOnEachObserver.onError(e);\n+                    observer.onError(e);\n+                }\n+\n+                @Override\n+                public void onNext(T value) {\n+                    doOnEachObserver.onNext(value);\n+                    observer.onNext(value);\n+                }\n+\n+            });\n+        }\n+\n+    }\n+}\n\\ No newline at end of file\n\ndiff --git a/rxjava-core/src/test/java/rx/operators/OperationDoOnEachTest.java b/rxjava-core/src/test/java/rx/operators/OperationDoOnEachTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationDoOnEachTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationDoOnEachTest.java\n@@ -0,0 +1,108 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.operators;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+import static rx.operators.OperationMap.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import rx.Observable;\n+import rx.Observer;\n+import rx.concurrency.Schedulers;\n+import rx.util.functions.Func1;\n+import rx.util.functions.Func2;\n+\n+public class OperationDoOnEachTest {\n+\n+    @Mock\n+    Observer<String> subscribedObserver;\n+    @Mock\n+    Observer<String> sideEffectObserver;\n+\n+    @Before\n+    public void before() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @Test\n+    public void testDoOnEach() {\n+        Observable<String> base     = Observable.from(\"a\", \"b\", \"c\");\n+        Observable<String> doOnEach = base.doOnEach(sideEffectObserver);\n+\n+        doOnEach.subscribe(subscribedObserver);\n+\n+        // ensure the leaf observer is still getting called\n+        verify(subscribedObserver, never()).onError(any(Throwable.class));\n+        verify(subscribedObserver, times(1)).onNext(\"a\");\n+        verify(subscribedObserver, times(1)).onNext(\"b\");\n+        verify(subscribedObserver, times(1)).onNext(\"c\");\n+        verify(subscribedObserver, times(1)).onCompleted();\n+\n+        // ensure our injected observer is getting called\n+        verify(sideEffectObserver, never()).onError(any(Throwable.class));\n+        verify(sideEffectObserver, times(1)).onNext(\"a\");\n+        verify(sideEffectObserver, times(1)).onNext(\"b\");\n+        verify(sideEffectObserver, times(1)).onNext(\"c\");\n+        verify(sideEffectObserver, times(1)).onCompleted();\n+    }\n+    \n+\n+\n+    @Test\n+    public void testDoOnEachWithError() {\n+        Observable<String> base = Observable.from(\"one\", \"fail\", \"two\", \"three\", \"fail\");\n+        Observable<String> errs = base.map(new Func1<String, String>() {\n+            @Override\n+            public String call(String s) {\n+                if (\"fail\".equals(s)) {\n+                    throw new RuntimeException(\"Forced Failure\");\n+                }\n+                return s;\n+            }\n+        });\n+        \n+        Observable<String> doOnEach = errs.doOnEach(sideEffectObserver);\n+\n+\n+        doOnEach.subscribe(subscribedObserver);\n+        verify(subscribedObserver, times(1)).onNext(\"one\");\n+        verify(subscribedObserver, never()).onNext(\"two\");\n+        verify(subscribedObserver, never()).onNext(\"three\");\n+        verify(subscribedObserver, never()).onCompleted();\n+        verify(subscribedObserver, times(1)).onError(any(Throwable.class));\n+\n+\n+        verify(sideEffectObserver, times(1)).onNext(\"one\");\n+        verify(sideEffectObserver, never()).onNext(\"two\");\n+        verify(sideEffectObserver, never()).onNext(\"three\");\n+        verify(sideEffectObserver, never()).onCompleted();\n+        verify(sideEffectObserver, times(1)).onError(any(Throwable.class));\n+    }\n+\n+  \n+}",
    "output": "Add beginnings of doOnEach operator"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperationMapTest.java b/rxjava-core/src/test/java/rx/operators/OperationMapTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationMapTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationMapTest.java\n@@ -264,29 +264,21 @@ public Integer call(Integer arg0) {\n                 }).toBlockingObservable().single();\n     }\n \n-    @Test\n+    @Test(expected = IllegalArgumentException.class)\n     public void testMapWithErrorInFuncAndThreadPoolScheduler() throws InterruptedException {\n         // The error will throw in one of threads in the thread pool.\n         // If map does not handle it, the error will disappear.\n         // so map needs to handle the error by itself.\n-        final CountDownLatch latch = new CountDownLatch(1);\n         Observable<String> m = Observable.from(\"one\")\n                 .observeOn(Schedulers.threadPoolForComputation())\n                 .map(new Func1<String, String>() {\n                     public String call(String arg0) {\n-                        try {\n-                            throw new IllegalArgumentException(\"any error\");\n-                        } finally {\n-                            latch.countDown();\n-                        }\n+                        throw new IllegalArgumentException(\"any error\");\n                     }\n                 });\n \n-        m.subscribe(stringObserver);\n-        latch.await();\n-        InOrder inorder = inOrder(stringObserver);\n-        inorder.verify(stringObserver, times(1)).onError(any(IllegalArgumentException.class));\n-        inorder.verifyNoMoreInteractions();\n+        // block for response, expecting exception thrown\n+        m.toBlockingObservable().last();\n     }\n     \n     /**",
    "output": "Fix non-deterministic unit test\n\n- the latch was before onError is called\n- use BlockingObservable and expect the IllegalArgumentException to be thrown"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperationMapTest.java b/rxjava-core/src/test/java/rx/operators/OperationMapTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationMapTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationMapTest.java\n@@ -212,8 +212,12 @@ public String call(String s) {\n         verify(stringObserver, times(1)).onError(any(Throwable.class));\n     }\n \n+    /**\n+     * This is testing how unsubscribe behavior is handled when an error occurs in a user provided function\n+     * and the source is unsubscribed from ... but ignores or can't receive the unsubscribe as it is synchronous.\n+     */\n     @Test\n-    public void testMapWithSynchronousObservableContainingError() {\n+    public void testMapContainingErrorWithSequenceThatDoesntUnsubscribe() {\n         Observable<String> w = Observable.from(\"one\", \"fail\", \"two\", \"three\", \"fail\");\n         final AtomicInteger c1 = new AtomicInteger();\n         final AtomicInteger c2 = new AtomicInteger();\n@@ -243,7 +247,9 @@ public String call(String s) {\n         verify(stringObserver, never()).onCompleted();\n         verify(stringObserver, times(1)).onError(any(Throwable.class));\n \n-        // we should have only returned 1 value: \"one\"\n+        // We should have only returned 1 value: \"one\"\n+        // Since the unsubscribe doesn't propagate, we will actually be sent all events and need\n+        // to ignore all after the first failure.\n         assertEquals(1, c1.get());\n         assertEquals(1, c2.get());\n     }\n@@ -282,6 +288,52 @@ public String call(String arg0) {\n         inorder.verify(stringObserver, times(1)).onError(any(IllegalArgumentException.class));\n         inorder.verifyNoMoreInteractions();\n     }\n+    \n+    /**\n+     * While mapping over range(1,1).last() we expect IllegalArgumentException since the sequence is empty.\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testErrorPassesThruMap() {\n+        Observable.range(1,0).last().map(new Func1<Integer, Integer>() {\n+\n+            @Override\n+            public Integer call(Integer i) {\n+                return i;\n+            }\n+            \n+        }).toBlockingObservable().single();\n+    }\n+    \n+    /**\n+     * We expect IllegalStateException to pass thru map.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testErrorPassesThruMap2() {\n+        Observable.error(new IllegalStateException()).map(new Func1<Object, Object>() {\n+\n+            @Override\n+            public Object call(Object i) {\n+                return i;\n+            }\n+            \n+        }).toBlockingObservable().single();\n+    }\n+    \n+    /**\n+     * We expect an ArithmeticException exception here because last() emits a single value\n+     * but then we divide by 0.\n+     */\n+    @Test(expected = ArithmeticException.class)\n+    public void testMapWithErrorInFunc() {\n+        Observable.range(1,1).last().map(new Func1<Integer, Integer>() {\n+\n+            @Override\n+            public Integer call(Integer i) {\n+                return i/0;\n+            }\n+            \n+        }).toBlockingObservable().single();\n+    }\n \n     private static Map<String, String> getMap(String prefix) {\n         Map<String, String> m = new HashMap<String, String>();",
    "output": "Add and clarify unit tests in map"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/operators/OperationTakeWhileTest.java b/rxjava-core/src/test/java/rx/operators/OperationTakeWhileTest.java\n--- a/rxjava-core/src/test/java/rx/operators/OperationTakeWhileTest.java\n+++ b/rxjava-core/src/test/java/rx/operators/OperationTakeWhileTest.java\n@@ -119,7 +119,7 @@ public Subscription onSubscribe(Observer<? super String> observer) {\n             public Boolean call(String s) {\n                 return false;\n             }\n-        })).toBlockingObservable().last();\n+        })).toBlockingObservable().lastOrDefault(\"\");\n     }\n \n     @Test",
    "output": "Fix unit test after last() changed behavior"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observables/BlockingObservable.java b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java\n--- a/rxjava-core/src/main/java/rx/observables/BlockingObservable.java\n+++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java\n@@ -178,13 +178,10 @@ public Iterator<T> getIterator() {\n      * <img width=\"640\" src=\"https://github.com/Netflix/RxJava/wiki/images/rx-operators/B.last.png\">\n      * \n      * @return the last item emitted by the source {@link Observable}\n+     * @throws IllegalArgumentException if source contains no elements\n      */\n     public T last() {\n-        T result = null;\n-        for (T value : toIterable()) {\n-            result = value;\n-        }\n-        return result;\n+        return new BlockingObservable<T>(o.last()).single();\n     }\n \n     /**\n\ndiff --git a/rxjava-core/src/test/java/rx/observables/BlockingObservableTest.java b/rxjava-core/src/test/java/rx/observables/BlockingObservableTest.java\n--- a/rxjava-core/src/test/java/rx/observables/BlockingObservableTest.java\n+++ b/rxjava-core/src/test/java/rx/observables/BlockingObservableTest.java\n@@ -49,11 +49,10 @@ public void testLast() {\n         assertEquals(\"three\", obs.last());\n     }\n \n-    @Test\n+    @Test(expected = IllegalArgumentException.class)\n     public void testLastEmptyObservable() {\n         BlockingObservable<Object> obs = BlockingObservable.from(Observable.empty());\n-\n-        assertNull(obs.last());\n+        obs.last();\n     }\n \n     @Test",
    "output": "Fix behavior of BlockingObservable.last\n\nIt now throws an IllegalArgumentException instead of returning null if no elements are emitted.\n\nThis is based on feedback from @headinthebox confirming this expected behavior:\n\nvar xs = Observable.Range(1,0);                       \t\t// empty sequence\nint x = xs.Last().Dump();                             \t\t// throws “sequence contains no elements”       RxJava => BlockingObservable.last()\nIObservable<int> ys = xs.TakeLast(1).Dump();          // OnCompleted()                                                RxJava => Observable.takeLast(1)\nIObservable<int> zs = xs.LastAsync().Dump();          // OnError(“sequence contains no elements”)    RxJava => Observable.last()"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subscriptions/Subscriptions.java b/rxjava-core/src/main/java/rx/subscriptions/Subscriptions.java\n--- a/rxjava-core/src/main/java/rx/subscriptions/Subscriptions.java\n+++ b/rxjava-core/src/main/java/rx/subscriptions/Subscriptions.java\n@@ -15,9 +15,16 @@\n  */\n package rx.subscriptions;\n \n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n import java.util.concurrent.Future;\n \n+import org.junit.Test;\n+\n import rx.Subscription;\n+import rx.operators.SafeObservableSubscription;\n import rx.util.functions.Action0;\n \n /**\n@@ -41,14 +48,14 @@ public static Subscription empty() {\n      * @return {@link Subscription}\n      */\n     public static Subscription create(final Action0 unsubscribe) {\n-        return new Subscription() {\n+        return new SafeObservableSubscription(new Subscription() {\n \n             @Override\n             public void unsubscribe() {\n                 unsubscribe.call();\n             }\n \n-        };\n+        });\n     }\n \n     /**\n@@ -122,4 +129,15 @@ public static CompositeSubscription create(Subscription... subscriptions) {\n         public void unsubscribe() {\n         }\n     };\n+\n+    public static class UnitTest {\n+        @Test\n+        public void testUnsubscribeOnlyOnce() {\n+            Action0 unsubscribe = mock(Action0.class);\n+            Subscription subscription = create(unsubscribe);\n+            subscription.unsubscribe();\n+            subscription.unsubscribe();\n+            verify(unsubscribe, times(1)).call();\n+        }\n+    }\n }",
    "output": "Fix issue #454"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationNext.java b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationNext.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n@@ -234,7 +234,7 @@ public void testOnError() throws Throwable {\n         }\n \n         @Test\n-        public void testOnErrorViaHasNext() throws Throwable {\n+        public void testOnErrorViaHasNext() throws InterruptedException, ExecutionException {\n             Subject<String, String> obs = PublishSubject.create();\n \n             Iterator<String> it = next(obs).iterator();\n@@ -253,15 +253,10 @@ public void testOnErrorViaHasNext() throws Throwable {\n             obs.onError(new TestException());\n \n             // this should not throw an exception but instead just return false\n-            try {\n-                assertFalse(it.hasNext());\n-            } catch (Throwable e) {\n-                fail(\"should not have received exception\");\n-                e.printStackTrace();\n-            }\n+            assertFalse(it.hasNext());\n         }\n \n-        private Future<String> nextAsync(final Iterator<String> it) throws Throwable {\n+        private Future<String> nextAsync(final Iterator<String> it) {\n \n             return executor.submit(new Callable<String>() {\n ",
    "output": "Remove the unnecessary 'catch' and 'fail'"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationNext.java b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationNext.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n@@ -104,6 +104,7 @@ public void remove() {\n     private static class NextObserver<T> implements Observer<Notification<? extends T>> {\n         private final BlockingQueue<Notification<? extends T>> buf = new ArrayBlockingQueue<Notification<? extends T>>(1);\n         private final AtomicBoolean waiting = new AtomicBoolean(false);\n+        private volatile boolean completed = false;\n \n         @Override\n         public void onCompleted() {\n@@ -139,7 +140,11 @@ public void await() {\n         public boolean isCompleted(boolean rethrowExceptionIfExists) {\n             Notification<? extends T> lastItem = buf.peek();\n             if (lastItem == null) {\n-                return false;\n+                // Fixed issue #383 testOnErrorViaHasNext fails sometimes.\n+                // If the buf is empty, there are two cases:\n+                // 1. The next item has not been emitted yet.\n+                // 2. The error or completed notification is removed in takeNext method.\n+                return completed;\n             }\n \n             if (lastItem.isOnError()) {\n@@ -157,10 +162,12 @@ public T takeNext() throws InterruptedException {\n             Notification<? extends T> next = buf.take();\n \n             if (next.isOnError()) {\n+                completed = true;\n                 throw Exceptions.propagate(next.getThrowable());\n             }\n \n             if (next.isOnCompleted()) {\n+                completed = true;\n                 throw new IllegalStateException(\"Observable is completed\");\n             }\n ",
    "output": "Fix testOnErrorViaHasNext in issue #383"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationMap.java b/rxjava-core/src/main/java/rx/operators/OperationMap.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationMap.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationMap.java\n@@ -15,12 +15,16 @@\n  */\n package rx.operators;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n import java.util.HashMap;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Before;\n@@ -33,6 +37,7 @@\n import rx.Observable.OnSubscribeFunc;\n import rx.Observer;\n import rx.Subscription;\n+import rx.concurrency.Schedulers;\n import rx.util.functions.Func1;\n import rx.util.functions.Func2;\n \n@@ -59,17 +64,12 @@ public final class OperationMap {\n      * @return a sequence that is the result of applying the transformation function to each item in the input sequence.\n      */\n     public static <T, R> OnSubscribeFunc<R> map(final Observable<? extends T> sequence, final Func1<? super T, ? extends R> func) {\n-        return new OnSubscribeFunc<R>() {\n-            @Override\n-            public Subscription onSubscribe(Observer<? super R> observer) {\n-                return new MapObservable<T, R>(sequence, new Func2<T, Integer, R>() {\n+        return mapWithIndex(sequence, new Func2<T, Integer, R>() {\n                     @Override\n                     public R call(T value, @SuppressWarnings(\"unused\") Integer unused) {\n                         return func.call(value);\n                     }\n-                }).onSubscribe(observer);\n-            }\n-        };\n+                });\n     }\n \n     /**\n@@ -136,7 +136,8 @@ public MapObservable(Observable<? extends T> sequence, Func2<? super T, Integer,\n \n         @Override\n         public Subscription onSubscribe(final Observer<? super R> observer) {\n-            return sequence.subscribe(new Observer<T>() {\n+            final SafeObservableSubscription subscription = new SafeObservableSubscription();\n+            return subscription.wrap(sequence.subscribe(new SafeObserver<T>(subscription, new Observer<T>() {\n                 @Override\n                 public void onNext(T value) {\n                     observer.onNext(func.call(value, index));\n@@ -152,7 +153,7 @@ public void onError(Throwable ex) {\n                 public void onCompleted() {\n                     observer.onCompleted();\n                 }\n-            });\n+            })));\n         }\n     }\n \n@@ -366,6 +367,41 @@ public String call(String s) {\n             assertEquals(1, c2.get());\n         }\n \n+        @Test(expected = IllegalArgumentException.class)\n+        public void testMapWithIssue417() {\n+            Observable.from(1).observeOn(Schedulers.threadPoolForComputation())\n+            .map(new Func1<Integer, Integer>() {\n+                public Integer call(Integer arg0) {\n+                    throw new IllegalArgumentException(\"any error\");\n+                }\n+            }).toBlockingObservable().single();\n+        }\n+\n+        @Test\n+        public void testMapWithErrorInFuncAndThreadPoolScheduler() throws InterruptedException {\n+            // The error will throw in one of threads in the thread pool.\n+            // If map does not handle it, the error will disappear.\n+            // so map needs to handle the error by itself.\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            Observable<String> m = Observable.from(\"one\")\n+                    .observeOn(Schedulers.threadPoolForComputation())\n+                    .map(new Func1<String, String>() {\n+                        public String call(String arg0) {\n+                            try {\n+                                throw new IllegalArgumentException(\"any error\");\n+                            } finally {\n+                                latch.countDown();\n+                            }\n+                        }\n+                    });\n+\n+            m.subscribe(stringObserver);\n+            latch.await();\n+            InOrder inorder = inOrder(stringObserver);\n+            inorder.verify(stringObserver, times(1)).onError(any(IllegalArgumentException.class));\n+            inorder.verifyNoMoreInteractions();\n+        }\n+\n         private static Map<String, String> getMap(String prefix) {\n             Map<String, String> m = new HashMap<String, String>();\n             m.put(\"firstName\", prefix + \"First\");",
    "output": "Fix issue #417"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationMerge.java b/rxjava-core/src/main/java/rx/operators/OperationMerge.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationMerge.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationMerge.java\n@@ -98,7 +98,6 @@ public Subscription onSubscribe(Observer<? super Observable<? extends T>> observ\n \n                     @Override\n                     public void unsubscribe() {\n-                        System.out.println(\"unsubscribe from merge\");\n                         unsubscribed = true;\n                     }\n ",
    "output": "Remove println from OperationMerge"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationSwitch.java b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationSwitch.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java\n@@ -34,6 +34,7 @@\n import rx.Observer;\n import rx.Subscription;\n import rx.concurrency.TestScheduler;\n+import rx.subscriptions.CompositeSubscription;\n import rx.subscriptions.MultipleAssignmentSubscription;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;\n@@ -78,9 +79,15 @@ public Switch(Observable<? extends Observable<? extends T>> sequences) {\n \n         @Override\n         public Subscription onSubscribe(Observer<? super T> observer) {\n-            SafeObservableSubscription subscription = new SafeObservableSubscription();\n-            subscription.wrap(sequences.subscribe(new SwitchObserver<T>(observer, subscription)));\n-            return subscription;\n+            SafeObservableSubscription parent;\n+            parent = new SafeObservableSubscription();\n+\n+            MultipleAssignmentSubscription child;\n+            child = new MultipleAssignmentSubscription();\n+\n+            parent.wrap(sequences.subscribe(new SwitchObserver<T>(observer, parent, child)));\n+\n+            return new CompositeSubscription(parent, child);\n         }\n     }\n \n@@ -89,24 +96,25 @@ private static class SwitchObserver<T> implements Observer<Observable<? extends\n         private final Object                         gate;\n         private final Observer<? super T>            observer;\n         private final SafeObservableSubscription     parent;\n-        private final MultipleAssignmentSubscription innerSubscription;\n+        private final MultipleAssignmentSubscription child;\n         private long                                 latest;\n         private boolean                              stopped;\n         private boolean                              hasLatest;\n \n-        public SwitchObserver(Observer<? super T> observer, SafeObservableSubscription parent) {\n+        public SwitchObserver(Observer<? super T> observer, SafeObservableSubscription parent,\n+                MultipleAssignmentSubscription child) {\n             this.observer = observer;\n             this.parent = parent;\n+            this.child = child;\n             this.gate = new Object();\n-            this.innerSubscription = new MultipleAssignmentSubscription();\n         }\n \n         @Override\n         public void onNext(Observable<? extends T> args) {\n             final long id;\n             synchronized (gate) {\n                 id = ++latest;\n-                hasLatest = true;\n+                this.hasLatest = true;\n             }\n \n             final SafeObservableSubscription sub;\n@@ -116,7 +124,7 @@ public void onNext(Observable<? extends T> args) {\n                 public void onNext(T args) {\n                     synchronized (gate) {\n                         if (latest == id) {\n-                            observer.onNext(args);\n+                            SwitchObserver.this.observer.onNext(args);\n                         }\n                     }\n                 }\n@@ -126,8 +134,8 @@ public void onError(Throwable e) {\n                     synchronized (gate) {\n                         sub.unsubscribe();\n                         if (latest == id) {\n-                            observer.onError(e);\n-                            parent.unsubscribe();\n+                            SwitchObserver.this.observer.onError(e);\n+                            SwitchObserver.this.parent.unsubscribe();\n                         }\n                     }\n                 }\n@@ -137,39 +145,39 @@ public void onCompleted() {\n                     synchronized (gate) {\n                         sub.unsubscribe();\n                         if (latest == id) {\n-                            hasLatest = false;\n+                            SwitchObserver.this.hasLatest = false;\n                         }\n \n                         if (stopped) {\n-                            observer.onCompleted();\n-                            parent.unsubscribe();\n+                            SwitchObserver.this.observer.onCompleted();\n+                            SwitchObserver.this.parent.unsubscribe();\n                         }\n \n                     }\n                 }\n \n             }));\n \n-            innerSubscription.setSubscription(sub);\n+            this.child.setSubscription(sub);\n         }\n \n         @Override\n         public void onError(Throwable e) {\n             synchronized (gate) {\n-                observer.onError(e);\n+                this.observer.onError(e);\n             }\n \n-            parent.unsubscribe();\n+            this.parent.unsubscribe();\n         }\n \n         @Override\n         public void onCompleted() {\n             synchronized (gate) {\n-                innerSubscription.unsubscribe();\n-                stopped = true;\n-                if (!hasLatest) {\n-                    observer.onCompleted();\n-                    parent.unsubscribe();\n+                this.child.unsubscribe();\n+                this.stopped = true;\n+                if (!this.hasLatest) {\n+                    this.observer.onCompleted();\n+                    this.parent.unsubscribe();\n                 }\n             }\n         }",
    "output": "Fix OperationSwitch so that it does not onComplete() before inner and\nouter subscription completes"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationTake.java b/rxjava-core/src/main/java/rx/operators/OperationTake.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationTake.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationTake.java\n@@ -15,20 +15,30 @@\n  */\n package rx.operators;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n \n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Test;\n+import org.mockito.InOrder;\n \n import rx.Observable;\n import rx.Observable.OnSubscribeFunc;\n import rx.Observer;\n import rx.Subscription;\n import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Func1;\n \n /**\n  * Returns an Observable that emits the first <code>num</code> items emitted by the source\n@@ -114,30 +124,47 @@ private class ItemObserver implements Observer<T> {\n             private final Observer<? super T> observer;\n \n             private final AtomicInteger counter = new AtomicInteger();\n+            private volatile boolean hasEmitedError = false;\n \n             public ItemObserver(Observer<? super T> observer) {\n                 this.observer = observer;\n             }\n \n             @Override\n             public void onCompleted() {\n+                if (hasEmitedError) {\n+                    return;\n+                }\n                 if (counter.getAndSet(num) < num) {\n                     observer.onCompleted();\n                 }\n             }\n \n             @Override\n             public void onError(Throwable e) {\n+                if (hasEmitedError) {\n+                    return;\n+                }\n                 if (counter.getAndSet(num) < num) {\n                     observer.onError(e);\n                 }\n             }\n \n             @Override\n             public void onNext(T args) {\n+                if (hasEmitedError) {\n+                    return;\n+                }\n                 final int count = counter.incrementAndGet();\n                 if (count <= num) {\n-                    observer.onNext(args);\n+                    try {\n+                        observer.onNext(args);\n+                    } catch (Throwable ex) {\n+                        hasEmitedError = true;\n+                        observer.onError(ex);\n+                        subscription.unsubscribe();\n+                        return;\n+                    }\n                     if (count == num) {\n                         observer.onCompleted();\n                     }\n@@ -184,6 +211,47 @@ public void testTake2() {\n             verify(aObserver, times(1)).onCompleted();\n         }\n \n+        @Test(expected = IllegalArgumentException.class)\n+        public void testTakeWithError() {\n+            Observable.from(1, 2, 3).take(1).map(new Func1<Integer, Integer>() {\n+                public Integer call(Integer t1) {\n+                    throw new IllegalArgumentException(\"some error\");\n+                }\n+            }).toBlockingObservable().single();\n+        }\n+\n+        @Test\n+        public void testTakeWithErrorHappeningInOnNext() {\n+            Observable<Integer> w = Observable.from(1, 2, 3).take(2).map(new Func1<Integer, Integer>() {\n+                public Integer call(Integer t1) {\n+                    throw new IllegalArgumentException(\"some error\");\n+                }\n+            });\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Observer<Integer> observer = mock(Observer.class);\n+            w.subscribe(observer);\n+            InOrder inOrder = inOrder(observer);\n+            inOrder.verify(observer, times(1)).onError(any(IllegalArgumentException.class));\n+            inOrder.verifyNoMoreInteractions();\n+        }\n+\n+        @Test\n+        public void testTakeWithErrorHappeningInTheLastOnNext() {\n+            Observable<Integer> w = Observable.from(1, 2, 3).take(1).map(new Func1<Integer, Integer>() {\n+                public Integer call(Integer t1) {\n+                    throw new IllegalArgumentException(\"some error\");\n+                }\n+            });\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Observer<Integer> observer = mock(Observer.class);\n+            w.subscribe(observer);\n+            InOrder inOrder = inOrder(observer);\n+            inOrder.verify(observer, times(1)).onError(any(IllegalArgumentException.class));\n+            inOrder.verifyNoMoreInteractions();\n+        }\n+\n         @Test\n         public void testTakeDoesntLeakErrors() {\n             Observable<String> source = Observable.create(new OnSubscribeFunc<String>()",
    "output": "Fix the issue that 'take' does not call 'onError' when 'onNext' throws any error"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -28,7 +28,62 @@\n import rx.observables.BlockingObservable;\n import rx.observables.ConnectableObservable;\n import rx.observables.GroupedObservable;\n-import rx.operators.*;\n+import rx.operators.OperationAll;\n+import rx.operators.OperationAny;\n+import rx.operators.OperationAverage;\n+import rx.operators.OperationBuffer;\n+import rx.operators.OperationCache;\n+import rx.operators.OperationCast;\n+import rx.operators.OperationCombineLatest;\n+import rx.operators.OperationConcat;\n+import rx.operators.OperationDebounce;\n+import rx.operators.OperationDefaultIfEmpty;\n+import rx.operators.OperationDefer;\n+import rx.operators.OperationDematerialize;\n+import rx.operators.OperationDistinct;\n+import rx.operators.OperationDistinctUntilChanged;\n+import rx.operators.OperationElementAt;\n+import rx.operators.OperationFilter;\n+import rx.operators.OperationFinally;\n+import rx.operators.OperationFirstOrDefault;\n+import rx.operators.OperationGroupBy;\n+import rx.operators.OperationInterval;\n+import rx.operators.OperationMap;\n+import rx.operators.OperationMaterialize;\n+import rx.operators.OperationMerge;\n+import rx.operators.OperationMergeDelayError;\n+import rx.operators.OperationMulticast;\n+import rx.operators.OperationObserveOn;\n+import rx.operators.OperationOnErrorResumeNextViaFunction;\n+import rx.operators.OperationOnErrorResumeNextViaObservable;\n+import rx.operators.OperationOnErrorReturn;\n+import rx.operators.OperationOnExceptionResumeNextViaObservable;\n+import rx.operators.OperationParallel;\n+import rx.operators.OperationRetry;\n+import rx.operators.OperationSample;\n+import rx.operators.OperationScan;\n+import rx.operators.OperationSkip;\n+import rx.operators.OperationSkipLast;\n+import rx.operators.OperationSkipWhile;\n+import rx.operators.OperationSubscribeOn;\n+import rx.operators.OperationSum;\n+import rx.operators.OperationSwitch;\n+import rx.operators.OperationSynchronize;\n+import rx.operators.OperationTake;\n+import rx.operators.OperationTakeLast;\n+import rx.operators.OperationTakeUntil;\n+import rx.operators.OperationTakeWhile;\n+import rx.operators.OperationThrottleFirst;\n+import rx.operators.OperationTimeout;\n+import rx.operators.OperationTimestamp;\n+import rx.operators.OperationToObservableFuture;\n+import rx.operators.OperationToObservableIterable;\n+import rx.operators.OperationToObservableList;\n+import rx.operators.OperationToObservableSortedList;\n+import rx.operators.OperationWindow;\n+import rx.operators.OperationZip;\n+import rx.operators.SafeObservableSubscription;\n+import rx.operators.SafeObserver;\n import rx.plugins.RxJavaErrorHandler;\n import rx.plugins.RxJavaObservableExecutionHook;\n import rx.plugins.RxJavaPlugins;\n@@ -1801,8 +1856,6 @@ public static <T> Observable<T> switchOnNext(Observable<? extends Observable<? e\n      * its {@link Observer}s; it invokes {@code onCompleted} or {@code onError} only once; and it never invokes {@code onNext} after invoking either {@code onCompleted} or {@code onError}.\n      * {@code synchronize} enforces this, and the Observable it returns invokes {@code onNext} and {@code onCompleted} or {@code onError} synchronously.\n      * \n-     * @param <T>\n-     *            the type of item emitted by the source Observable\n      * @return an Observable that is a chronologically well-behaved version of the source\n      *         Observable, and that synchronously notifies its {@link Observer}s\n      */\n@@ -1822,8 +1875,6 @@ public Observable<T> synchronize() {\n      *\n      * @param lock\n      *            The lock object to synchronize each observer call on\n-     * @param <T>\n-     *            the type of item emitted by the source Observable\n      * @return an Observable that is a chronologically well-behaved version of the source\n      *         Observable, and that synchronously notifies its {@link Observer}s\n      */\n@@ -3140,7 +3191,7 @@ public Observable<Boolean> exists(Func1<? super T, Boolean> predicate) {\n     /**\n      * Determines whether an observable sequence contains a specified element.\n      *\n-     * @param value\n+     * @param element\n      *            The element to search in the sequence.\n      * @return an Observable that emits if the element is in the source sequence.\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh228965(v=vs.103).aspx\">MSDN: Observable.Contains</a>",
    "output": "Fix a couple of warnings and reverted change to imports"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java b/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n--- a/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n+++ b/rxjava-core/src/main/java/rx/subscriptions/SerialSubscription.java\n@@ -30,15 +30,19 @@ public class SerialSubscription implements Subscription {\n \n     @Override\n     public void unsubscribe() {\n+        Subscription toUnsubscribe = null;\n         synchronized (gate) {\n             if (!unsubscribed) {\n                 if (subscription != null) {\n-                    subscription.unsubscribe();\n+                    toUnsubscribe = subscription;\n                     subscription = null;\n                 }\n                 unsubscribed = true;\n             }\n         }\n+        if (toUnsubscribe != null) {\n+            toUnsubscribe.unsubscribe();\n+        }\n     }\n \n     public Subscription getSubscription() {\n@@ -48,15 +52,19 @@ public Subscription getSubscription() {\n     }\n \n     public void setSubscription(Subscription subscription) {\n+        Subscription toUnsubscribe = null;\n         synchronized (gate) {\n             if (!unsubscribed) {\n                 if (this.subscription != null) {\n-                    this.subscription.unsubscribe();\n+                    toUnsubscribe = this.subscription;\n                 }\n                 this.subscription = subscription;\n             } else {\n-                subscription.unsubscribe();\n+                toUnsubscribe = subscription;\n             }\n         }\n+        if (toUnsubscribe != null) {\n+            toUnsubscribe.unsubscribe();\n+        }\n     }\n }\n\ndiff --git a/rxjava-core/src/test/java/rx/TimeoutTests.java b/rxjava-core/src/test/java/rx/TimeoutTests.java\n--- a/rxjava-core/src/test/java/rx/TimeoutTests.java\n+++ b/rxjava-core/src/test/java/rx/TimeoutTests.java\n@@ -0,0 +1,117 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.MockitoAnnotations;\n+import rx.concurrency.TestScheduler;\n+import rx.subjects.PublishSubject;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+public class TimeoutTests {\n+    private PublishSubject<String> underlyingSubject;\n+    private TestScheduler testScheduler;\n+    private Observable<String> withTimeout;\n+    private static final long TIMEOUT = 3;\n+    private static final TimeUnit TIME_UNIT = TimeUnit.SECONDS;\n+\n+    @Before\n+    public void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+\n+        underlyingSubject = PublishSubject.create();\n+        testScheduler = new TestScheduler();\n+        withTimeout = underlyingSubject.timeout(TIMEOUT, TIME_UNIT, testScheduler);\n+    }\n+\n+    @Test\n+    public void shouldNotTimeoutIfOnNextWithinTimeout() {\n+        Observer<String> observer = mock(Observer.class);\n+        Subscription subscription = withTimeout.subscribe(observer);\n+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n+        underlyingSubject.onNext(\"One\");\n+        verify(observer).onNext(\"One\");\n+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n+        verify(observer, never()).onError(any(Throwable.class));\n+        subscription.unsubscribe();\n+    }\n+\n+    @Test\n+    public void shouldNotTimeoutIfSecondOnNextWithinTimeout() {\n+        Observer<String> observer = mock(Observer.class);\n+        Subscription subscription = withTimeout.subscribe(observer);\n+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n+        underlyingSubject.onNext(\"One\");\n+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n+        underlyingSubject.onNext(\"Two\");\n+        verify(observer).onNext(\"Two\");\n+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n+        verify(observer, never()).onError(any(Throwable.class));\n+        subscription.unsubscribe();\n+    }\n+\n+    @Test\n+    public void shouldTimeoutIfOnNextNotWithinTimeout() {\n+        Observer<String> observer = mock(Observer.class);\n+        Subscription subscription = withTimeout.subscribe(observer);\n+        testScheduler.advanceTimeBy(TIMEOUT + 1, TimeUnit.SECONDS);\n+        verify(observer).onError(any(TimeoutException.class));\n+        subscription.unsubscribe();\n+    }\n+\n+    @Test\n+    public void shouldTimeoutIfSecondOnNextNotWithinTimeout() {\n+        Observer<String> observer = mock(Observer.class);\n+        Subscription subscription = withTimeout.subscribe(observer);\n+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n+        underlyingSubject.onNext(\"One\");\n+        verify(observer).onNext(\"One\");\n+        testScheduler.advanceTimeBy(TIMEOUT + 1, TimeUnit.SECONDS);\n+        verify(observer).onError(any(TimeoutException.class));\n+        subscription.unsubscribe();\n+    }\n+\n+    @Test\n+    public void shouldCompleteIfUnderlyingComletes() {\n+        Observer<String> observer = mock(Observer.class);\n+        Subscription subscription = withTimeout.subscribe(observer);\n+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n+        underlyingSubject.onCompleted();\n+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n+        verify(observer).onCompleted();\n+        verify(observer, never()).onError(any(Throwable.class));\n+        subscription.unsubscribe();\n+    }\n+\n+    @Test\n+    public void shouldErrorIfUnderlyingErrors() {\n+        Observer<String> observer = mock(Observer.class);\n+        Subscription subscription = withTimeout.subscribe(observer);\n+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n+        underlyingSubject.onError(new UnsupportedOperationException());\n+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);\n+        verify(observer).onError(any(UnsupportedOperationException.class));\n+        subscription.unsubscribe();\n+    }\n+}",
    "output": "Improve efficiency of SerialSubscription and unit tested Timeout"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperationObserveFromAndroidComponent.java b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperationObserveFromAndroidComponent.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperationObserveFromAndroidComponent.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperationObserveFromAndroidComponent.java\n@@ -44,10 +44,10 @@ public static <T> Observable<T> observeFromAndroidComponent(Observable<T> source\n     }\n \n     public static <T> Observable<T> observeFromAndroidComponent(Observable<T> source, Activity activity) {\n-        return Observable.create(new OnSubscribeActivity<T>(source, activity));\n+        return Observable.create(new OnSubscribeBase<T, Activity>(source, activity));\n     }\n \n-    private static abstract class OnSubscribeBase<T, AndroidComponent> implements Observable.OnSubscribeFunc<T> {\n+    private static class OnSubscribeBase<T, AndroidComponent> implements Observable.OnSubscribeFunc<T> {\n \n         private static final String LOG_TAG = OperationObserveFromAndroidComponent.class.getSimpleName();\n \n@@ -68,7 +68,9 @@ private void log(String message) {\n             }\n         }\n \n-        protected abstract boolean isComponentValid(AndroidComponent component);\n+        protected boolean isComponentValid(AndroidComponent component) {\n+            return true;\n+        }\n \n         @Override\n         public Subscription onSubscribe(Observer<? super T> observer) {\n@@ -148,18 +150,6 @@ protected boolean isComponentValid(android.support.v4.app.Fragment fragment) {\n         }\n     }\n \n-    private static final class OnSubscribeActivity<T> extends OnSubscribeBase<T, Activity> {\n-\n-        private OnSubscribeActivity(Observable<T> source, Activity activity) {\n-            super(source, activity);\n-        }\n-\n-        @Override\n-        protected boolean isComponentValid(Activity activity) {\n-            return !activity.isFinishing();\n-        }\n-    }\n-\n     @RunWith(RobolectricTestRunner.class)\n     @Config(manifest = Config.NONE)\n     public static final class UnitTest {\n@@ -292,36 +282,6 @@ public void itDoesNotForwardOnErrorIfFragmentIsDetached() {\n             verify(mockObserver, never()).onError(any(Exception.class));\n         }\n \n-        @Test\n-        public void isDoesNotForwardOnNextOnCompletedSequenceIfActivityIsFinishing() {\n-            PublishSubject<Integer> source = PublishSubject.create();\n-            OperationObserveFromAndroidComponent.observeFromAndroidComponent(source, mockActivity).subscribe(mockObserver);\n-\n-            source.onNext(1);\n-\n-            when(mockActivity.isFinishing()).thenReturn(true);\n-            source.onNext(2);\n-            source.onNext(3);\n-            source.onCompleted();\n-\n-            verify(mockObserver).onNext(1);\n-            verify(mockObserver, never()).onCompleted();\n-        }\n-\n-        @Test\n-        public void itDoesNotForwardOnErrorIfActivityIsFinishing() {\n-            PublishSubject<Integer> source = PublishSubject.create();\n-            OperationObserveFromAndroidComponent.observeFromAndroidComponent(source, mockActivity).subscribe(mockObserver);\n-\n-            source.onNext(1);\n-\n-            when(mockActivity.isFinishing()).thenReturn(true);\n-            source.onError(new Exception());\n-\n-            verify(mockObserver).onNext(1);\n-            verify(mockObserver, never()).onError(any(Exception.class));\n-        }\n-\n         @Test\n         public void itUnsubscribesFromTheSourceSequence() {\n             Subscription underlying = mock(Subscription.class);",
    "output": "Remove isFinishing check when calling back to activities\n\nWe decided it's sufficient for the callback to be safe as long as the caller unsubscribes in onDestroy"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperationObserveFromAndroidComponent.java b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperationObserveFromAndroidComponent.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperationObserveFromAndroidComponent.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperationObserveFromAndroidComponent.java\n@@ -61,9 +61,11 @@ private OnSubscribeBase(Observable<T> source, AndroidComponent component) {\n         }\n \n         private void log(String message) {\n-            Log.d(LOG_TAG, \"componentRef = \" + componentRef);\n-            Log.d(LOG_TAG, \"observerRef = \" + observerRef);\n-            Log.d(LOG_TAG, message);\n+            if (Log.isLoggable(LOG_TAG, Log.DEBUG)) {\n+                Log.d(LOG_TAG, \"componentRef = \" + componentRef);\n+                Log.d(LOG_TAG, \"observerRef = \" + observerRef);\n+                Log.d(LOG_TAG, message);\n+            }\n         }\n \n         protected abstract boolean isComponentValid(AndroidComponent component);",
    "output": "Add guards around log statements"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java b/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java\n--- a/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java\n+++ b/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java\n@@ -187,8 +187,11 @@ public void emitChunk(Chunk<T, C> chunk) {\n                 return;\n             }\n \n-            subscription.unsubscribe();\n+            // Fixed issue 428.\n+            // As unsubscribe will cancel the Future, and the currrent thread's interrupt status\n+            // will be set. So we need to emit the chunk before unsubscribe.\n             super.emitChunk(chunk);\n+            subscription.unsubscribe();\n             createChunk();\n         }\n \n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationBuffer.java b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n@@ -15,8 +15,11 @@\n  */\n package rx.operators;\n \n+import static org.junit.Assert.assertFalse;\n+\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n import org.junit.Before;\n@@ -37,6 +40,7 @@\n import rx.util.Opening;\n import rx.util.Openings;\n import rx.util.functions.Action0;\n+import rx.util.functions.Action1;\n import rx.util.functions.Func0;\n import rx.util.functions.Func1;\n \n@@ -631,6 +635,40 @@ public Subscription onSubscribe(Observer<? super Closing> observer) {\n             inOrder.verify(observer, Mockito.times(1)).onCompleted();\n         }\n \n+        @Test\n+        public void testLongTimeAction() throws InterruptedException {\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            LongTimeAction action = new LongTimeAction(latch);\n+            Observable.from(1).buffer(10, TimeUnit.MILLISECONDS, 10)\n+                    .subscribe(action);\n+            latch.await();\n+            assertFalse(action.fail);\n+        }\n+\n+        private static class LongTimeAction implements Action1<List<Integer>> {\n+\n+            CountDownLatch latch;\n+            boolean fail = false;\n+\n+            public LongTimeAction(CountDownLatch latch) {\n+                this.latch = latch;\n+            }\n+\n+            @Override\n+            public void call(List<Integer> t1) {\n+                try {\n+                    if (fail) {\n+                        return;\n+                    }\n+                    Thread.sleep(200);\n+                } catch (InterruptedException e) {\n+                    fail = true;\n+                } finally {\n+                    latch.countDown();\n+                }\n+            }\n+        }\n+\n         private List<String> list(String... args) {\n             List<String> list = new ArrayList<String>();\n             for (String arg : args) {",
    "output": "Fix issue #428"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n@@ -15,18 +15,22 @@\n  */\n package rx.operators;\n \n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n-import java.util.Iterator;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.junit.Test;\n import org.mockito.InOrder;\n \n import rx.Observable;\n import rx.Observable.OnSubscribeFunc;\n-import rx.subscriptions.Subscriptions;\n import rx.Observer;\n import rx.Subscription;\n \n@@ -60,45 +64,36 @@ private static class TakeLast<T> implements OnSubscribeFunc<T> {\n         }\n \n         public Subscription onSubscribe(Observer<? super T> observer) {\n-            if(count == 0) {\n-                items.subscribe(new Observer<T>() {\n-\n-                    @Override\n-                    public void onCompleted() {\n-                    }\n-\n-                    @Override\n-                    public void onError(Throwable e) {\n-                    }\n-\n-                    @Override\n-                    public void onNext(T args) {\n-                    }\n-\n-                }).unsubscribe();\n-                observer.onCompleted();\n-                return Subscriptions.empty();\n+            if (count < 0) {\n+                throw new IndexOutOfBoundsException(\n+                        \"count could not be negative\");\n             }\n-\n             return subscription.wrap(items.subscribe(new ItemObserver(observer)));\n         }\n \n         private class ItemObserver implements Observer<T> {\n \n-            private LinkedBlockingDeque<T> deque = new LinkedBlockingDeque<T>(count);\n+            /**\n+             * Store the last count elements until now.\n+             */\n+            private Deque<T> deque = new LinkedList<T>();\n             private final Observer<? super T> observer;\n+            private final ReentrantLock lock = new ReentrantLock();\n \n             public ItemObserver(Observer<? super T> observer) {\n                 this.observer = observer;\n             }\n \n             @Override\n             public void onCompleted() {\n-                Iterator<T> reverse = deque.descendingIterator();\n-                while (reverse.hasNext()) {\n-                    observer.onNext(reverse.next());\n+                try {\n+                    for (T value : deque) {\n+                        observer.onNext(value);\n+                    }\n+                    observer.onCompleted();\n+                } catch (Throwable e) {\n+                    observer.onError(e);\n                 }\n-                observer.onCompleted();\n             }\n \n             @Override\n@@ -107,9 +102,27 @@ public void onError(Throwable e) {\n             }\n \n             @Override\n-            public void onNext(T args) {\n-                while (!deque.offerFirst(args)) {\n-                    deque.removeLast();\n+            public void onNext(T value) {\n+                if (count == 0) {\n+                    // If count == 0, we do not need to put value into deque and\n+                    // remove it at once. We can ignore the value directly.\n+                    return;\n+                }\n+                lock.lock();\n+                try {\n+                    deque.offerLast(value);\n+                    if (deque.size() > count) {\n+                        // Now deque has count + 1 elements, so the first\n+                        // element in the deque definitely does not belong\n+                        // to the last count elements of the source\n+                        // sequence. We can drop it now.\n+                        deque.removeFirst();\n+                    }\n+                } catch (Throwable e) {\n+                    observer.onError(e);\n+                    subscription.unsubscribe();\n+                } finally {\n+                    lock.unlock();\n                 }\n             }\n \n@@ -174,6 +187,35 @@ public void testTakeLastWithZeroCount() {\n             verify(aObserver, times(1)).onCompleted();\n         }\n \n+        @Test\n+        public void testTakeLastWithNull() {\n+            Observable<String> w = Observable.from(\"one\", null, \"three\");\n+            Observable<String> take = Observable.create(takeLast(w, 2));\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Observer<String> aObserver = mock(Observer.class);\n+            take.subscribe(aObserver);\n+            verify(aObserver, never()).onNext(\"one\");\n+            verify(aObserver, times(1)).onNext(null);\n+            verify(aObserver, times(1)).onNext(\"three\");\n+            verify(aObserver, never()).onError(any(Throwable.class));\n+            verify(aObserver, times(1)).onCompleted();\n+        }\n+\n+        @Test\n+        public void testTakeLastWithNegativeCount() {\n+            Observable<String> w = Observable.from(\"one\");\n+            Observable<String> take = Observable.create(takeLast(w, -1));\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Observer<String> aObserver = mock(Observer.class);\n+            take.subscribe(aObserver);\n+            verify(aObserver, never()).onNext(\"one\");\n+            verify(aObserver, times(1)).onError(\n+                    any(IndexOutOfBoundsException.class));\n+            verify(aObserver, never()).onCompleted();\n+        }\n+\n     }\n \n }",
    "output": "Fix the issue about null values"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n@@ -26,6 +26,7 @@\n \n import rx.Observable;\n import rx.Observable.OnSubscribeFunc;\n+import rx.subscriptions.Subscriptions;\n import rx.Observer;\n import rx.Subscription;\n \n@@ -59,6 +60,26 @@ private static class TakeLast<T> implements OnSubscribeFunc<T> {\n         }\n \n         public Subscription onSubscribe(Observer<? super T> observer) {\n+            if(count == 0) {\n+                items.subscribe(new Observer<T>() {\n+\n+                    @Override\n+                    public void onCompleted() {\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable e) {\n+                    }\n+\n+                    @Override\n+                    public void onNext(T args) {\n+                    }\n+\n+                }).unsubscribe();\n+                observer.onCompleted();\n+                return Subscriptions.empty();\n+            }\n+\n             return subscription.wrap(items.subscribe(new ItemObserver(observer)));\n         }\n \n@@ -140,6 +161,19 @@ public void testTakeLast2() {\n             verify(aObserver, times(1)).onCompleted();\n         }\n \n+        @Test\n+        public void testTakeLastWithZeroCount() {\n+            Observable<String> w = Observable.from(\"one\");\n+            Observable<String> take = Observable.create(takeLast(w, 0));\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Observer<String> aObserver = mock(Observer.class);\n+            take.subscribe(aObserver);\n+            verify(aObserver, never()).onNext(\"one\");\n+            verify(aObserver, never()).onError(any(Throwable.class));\n+            verify(aObserver, times(1)).onCompleted();\n+        }\n+\n     }\n \n }",
    "output": "Fix the issue of takeLast(items, 0)"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/ObservableTests.java b/rxjava-core/src/test/java/rx/ObservableTests.java\n--- a/rxjava-core/src/test/java/rx/ObservableTests.java\n+++ b/rxjava-core/src/test/java/rx/ObservableTests.java\n@@ -755,6 +755,20 @@ public void testContains() {\n         verify(aObserver, times(1)).onCompleted();\n     }\n \n+    @Test\n+    public void testContainsWithInexistence() {\n+        Observable<Boolean> observable = Observable.from(\"a\", \"b\", null).contains(\"c\");\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Object> aObserver = mock(Observer.class);\n+        observable.subscribe(aObserver);\n+        verify(aObserver, times(1)).onNext(false);\n+        verify(aObserver, never()).onNext(true);\n+        verify(aObserver, never()).onError(\n+                org.mockito.Matchers.any(Throwable.class));\n+        verify(aObserver, times(1)).onCompleted();\n+    }\n+\n     @Test\n     public void testContainsWithNull() {\n         Observable<Boolean> observable = Observable.from(\"a\", \"b\", null).contains(null);",
    "output": "Add one more unit test"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n--- a/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n+++ b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n@@ -361,8 +361,8 @@ public void testSchedulingWithDueTime() throws InterruptedException {\n             @Override\n             public Subscription call(Scheduler scheduler, String state) {\n                 System.out.println(\"doing work\");\n-                latch.countDown();\n                 counter.incrementAndGet();\n+                latch.countDown();\n                 if (latch.getCount() == 0) {\n                     return Subscriptions.empty();\n                 } else {",
    "output": "Upgrade counter before triggering latch"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java b/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java\n--- a/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java\n+++ b/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java\n@@ -54,16 +54,6 @@ protected ConnectableObservable(OnSubscribeFunc<T> onSubscribe) {\n      * @return a {@link Observable}\n      */\n     public Observable<T> refCount() {\n-        return refCount(this);\n-    }\n-\n-    /**\n-     * Returns an observable sequence that stays connected to the source as long\n-     * as there is at least one subscription to the observable sequence.\n-     * @return a {@link Observable}\n-     * @param that a {@link ConnectableObservable}\n-     */\n-    public static <T> Observable<T> refCount(ConnectableObservable<T> that) {\n-        return Observable.create(OperationRefCount.refCount(that));\n+        return Observable.create(OperationRefCount.refCount(this));\n     }\n }\n\ndiff --git a/rxjava-core/src/test/java/rx/RefCountTests.java b/rxjava-core/src/test/java/rx/RefCountTests.java\n--- a/rxjava-core/src/test/java/rx/RefCountTests.java\n+++ b/rxjava-core/src/test/java/rx/RefCountTests.java\n@@ -3,10 +3,13 @@\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.MockitoAnnotations;\n-import rx.observables.ConnectableObservable;\n import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n \n-import static org.mockito.Mockito.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n \n public class RefCountTests {\n \n@@ -16,67 +19,30 @@ public void setUp() {\n     }\n \n     @Test\n-    public void subscriptionToUnderlyingOnFirstSubscription() {\n-        @SuppressWarnings(\"unchecked\")\n-        ConnectableObservable<Integer> connectable = mock(ConnectableObservable.class);\n-        Observable<Integer> refCounted = ConnectableObservable.refCount(connectable);\n-        @SuppressWarnings(\"unchecked\")\n-        Observer<Integer> observer = mock(Observer.class);\n-        when(connectable.subscribe(any(Observer.class))).thenReturn(Subscriptions.empty());\n-        when(connectable.connect()).thenReturn(Subscriptions.empty());\n-        refCounted.subscribe(observer);\n-        verify(connectable, times(1)).subscribe(any(Observer.class));\n-        verify(connectable, times(1)).connect();\n-    }\n-\n-    @Test\n-    public void noSubscriptionToUnderlyingOnSecondSubscription() {\n-        @SuppressWarnings(\"unchecked\")\n-        ConnectableObservable<Integer> connectable = mock(ConnectableObservable.class);\n-        Observable<Integer> refCounted = ConnectableObservable.refCount(connectable);\n-        @SuppressWarnings(\"unchecked\")\n-        Observer<Integer> observer = mock(Observer.class);\n-        when(connectable.subscribe(any(Observer.class))).thenReturn(Subscriptions.empty());\n-        when(connectable.connect()).thenReturn(Subscriptions.empty());\n-        refCounted.subscribe(observer);\n-        refCounted.subscribe(observer);\n-        verify(connectable, times(2)).subscribe(any(Observer.class));\n-        verify(connectable, times(1)).connect();\n-    }\n-\n-    @Test\n-    public void unsubscriptionFromUnderlyingOnLastUnsubscription() {\n-        @SuppressWarnings(\"unchecked\")\n-        ConnectableObservable<Integer> connectable = mock(ConnectableObservable.class);\n-        Observable<Integer> refCounted = ConnectableObservable.refCount(connectable);\n-        @SuppressWarnings(\"unchecked\")\n-        Observer<Integer> observer = mock(Observer.class);\n-        Subscription underlying = mock(Subscription.class);\n-        when(connectable.subscribe(any(Observer.class))).thenReturn(underlying);\n-        Subscription connection = mock(Subscription.class);\n-        when(connectable.connect()).thenReturn(connection);\n-        Subscription first = refCounted.subscribe(observer);\n-        first.unsubscribe();\n-        verify(underlying, times(1)).unsubscribe();\n-        verify(connection, times(1)).unsubscribe();\n-    }\n-\n-    @Test\n-    public void noUnsubscriptionFromUnderlyingOnFirstUnsubscription() {\n-        @SuppressWarnings(\"unchecked\")\n-        ConnectableObservable<Integer> connectable = mock(ConnectableObservable.class);\n-        Observable<Integer> refCounted = ConnectableObservable.refCount(connectable);\n-        @SuppressWarnings(\"unchecked\")\n+    public void onlyFirstShouldSubscribeAndLastUnsubscribe() {\n+        final AtomicInteger subscriptionCount = new AtomicInteger();\n+        final AtomicInteger unsubscriptionCount = new AtomicInteger();\n+        Observable<Integer> observable = Observable.create(new Observable.OnSubscribeFunc<Integer>() {\n+            @Override\n+            public Subscription onSubscribe(Observer<? super Integer> observer) {\n+                subscriptionCount.incrementAndGet();\n+                return Subscriptions.create(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        unsubscriptionCount.incrementAndGet();\n+                    }\n+                });\n+            }\n+        });\n+        Observable<Integer> refCounted = observable.publish().refCount();\n         Observer<Integer> observer = mock(Observer.class);\n-        Subscription underlying = mock(Subscription.class);\n-        when(connectable.subscribe(any(Observer.class))).thenReturn(underlying);\n-        Subscription connection = mock(Subscription.class);\n-        when(connectable.connect()).thenReturn(connection);\n         Subscription first = refCounted.subscribe(observer);\n+        assertEquals(1, subscriptionCount.get());\n         Subscription second = refCounted.subscribe(observer);\n+        assertEquals(1, subscriptionCount.get());\n         first.unsubscribe();\n+        assertEquals(0, unsubscriptionCount.get());\n         second.unsubscribe();\n-        verify(underlying, times(2)).unsubscribe();\n-        verify(connection, times(1)).unsubscribe();\n+        assertEquals(1, unsubscriptionCount.get());\n     }\n }",
    "output": "Remove static variant of refCount"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -33,6 +33,7 @@\n import rx.operators.OperationAverage;\n import rx.operators.OperationBuffer;\n import rx.operators.OperationCache;\n+import rx.operators.OperationCast;\n import rx.operators.OperationCombineLatest;\n import rx.operators.OperationConcat;\n import rx.operators.OperationDebounce;\n@@ -4335,18 +4336,18 @@ public BlockingObservable<T> toBlockingObservable() {\n     /**\n      * Converts the elements of an observable sequence to the specified type.\n      *\n+     * @param klass\n+     *            The target class type which the elements will be converted to.\n+     *\n      * @return An observable sequence that contains each element of the source\n      *         sequence converted to the specified type.\n      *\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211842(v=vs.103).aspx\">MSDN: Observable.Cast</a>\n+     * @see <a\n+     *      href=\"http://msdn.microsoft.com/en-us/library/hh211842(v=vs.103).aspx\">MSDN:\n+     *      Observable.Cast</a>\n      */\n-    public <R> Observable<R> cast() {\n-        return map(new Func1<T, R>() {\n-            @SuppressWarnings(\"unchecked\")\n-            public R call(T t) {\n-                return (R) t;\n-            }\n-        });\n+    public <R> Observable<R> cast(final Class<R> klass) {\n+        return create(OperationCast.cast(this, klass));\n     }\n \n     /**\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationCast.java b/rxjava-core/src/main/java/rx/operators/OperationCast.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationCast.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationCast.java\n@@ -0,0 +1,67 @@\n+package rx.operators;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import org.junit.Test;\n+\n+import rx.Observable;\n+import rx.Observable.OnSubscribeFunc;\n+import rx.Observer;\n+import rx.util.functions.Func1;\n+\n+/**\n+ * Converts the elements of an observable sequence to the specified type.\n+ */\n+public class OperationCast {\n+\n+    public static <T, R> OnSubscribeFunc<R> cast(\n+            Observable<? extends T> source, final Class<R> klass) {\n+        return OperationMap.map(source, new Func1<T, R>() {\n+            @SuppressWarnings(\"unchecked\")\n+            public R call(T t) {\n+                if (klass.isAssignableFrom(t.getClass())) {\n+                    return (R) t;\n+                } else {\n+                    throw new ClassCastException(t.getClass()\n+                            + \" cannot be cast to \" + klass);\n+                }\n+            }\n+        });\n+    }\n+\n+    public static class UnitTest {\n+\n+        @Test\n+        public void testCast() {\n+            Observable<?> source = Observable.from(1, 2);\n+            Observable<Integer> observable = Observable.create(cast(source,\n+                    Integer.class));\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Observer<Integer> aObserver = mock(Observer.class);\n+            observable.subscribe(aObserver);\n+            verify(aObserver, times(1)).onNext(1);\n+            verify(aObserver, times(1)).onNext(1);\n+            verify(aObserver, never()).onError(\n+                    org.mockito.Matchers.any(Throwable.class));\n+            verify(aObserver, times(1)).onCompleted();\n+        }\n+\n+        @Test\n+        public void testCastWithWrongType() {\n+            Observable<?> source = Observable.from(1, 2);\n+            Observable<Boolean> observable = Observable.create(cast(source,\n+                    Boolean.class));\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Observer<Boolean> aObserver = mock(Observer.class);\n+            observable.subscribe(aObserver);\n+            verify(aObserver, times(1)).onError(\n+                    org.mockito.Matchers.any(ClassCastException.class));\n+        }\n+    }\n+\n+}",
    "output": "Add a klass parameter"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java\n--- a/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java\n+++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java\n@@ -143,7 +143,7 @@ public Subscription onSubscribe(final Observer<? super ObservableHttpResponse> o\n                 final CompositeSubscription parentSubscription = new CompositeSubscription();\n \n                 // return a Subscription that wraps the Future so it can be cancelled\n-                parentSubscription.add(Subscriptions.create(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),\n+                parentSubscription.add(Subscriptions.from(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),\n                         new FutureCallback<HttpResponse>() {\n \n                             @Override\n\ndiff --git a/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java\n--- a/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java\n+++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java\n@@ -52,7 +52,9 @@ public ResponseConsumerDelegate(final Observer<? super ObservableHttpResponse> o\n     @Override\n     protected void onResponseReceived(HttpResponse response) throws HttpException, IOException {\n         // when we receive the response with headers we evaluate what type of consumer we want\n-        if (response.getFirstHeader(\"Content-Type\").getValue().equals(\"text/event-stream\")) {\n+        if (response.getFirstHeader(\"Content-Type\").getValue().contains(\"text/event-stream\")) {\n+            // use 'contains' instead of equals since Content-Type can contain additional information\n+            // such as charset ... see here: http://www.w3.org/International/O-HTTP-charset\n             consumer = new ResponseConsumerEventStream(observer, subscription);\n         } else {\n             consumer = new ResponseConsumerBasic(observer, subscription);\n\ndiff --git a/rxjava-contrib/rxjava-apache-http/src/test/java/rx/apache/http/examples/ExampleObservableHttp.java b/rxjava-contrib/rxjava-apache-http/src/test/java/rx/apache/http/examples/ExampleObservableHttp.java\n--- a/rxjava-contrib/rxjava-apache-http/src/test/java/rx/apache/http/examples/ExampleObservableHttp.java\n+++ b/rxjava-contrib/rxjava-apache-http/src/test/java/rx/apache/http/examples/ExampleObservableHttp.java\n@@ -77,41 +77,40 @@ public void call(String resp) {\n \n     protected static void executeStreamingViaObservableHttpWithForEach(final HttpAsyncClient client) throws URISyntaxException, IOException, InterruptedException {\n         System.out.println(\"---- executeStreamingViaObservableHttpWithForEach\");\n-        for (int i = 0; i < 5; i++) {\n-            final int c = i + 1;\n-            ObservableHttp.createRequest(HttpAsyncMethods.createGet(\"http://ec2-54-211-91-164.compute-1.amazonaws.com:8077/eventbus.stream?topic=hystrix-metrics\"), client)\n-                    .toObservable()\n-                    .flatMap(new Func1<ObservableHttpResponse, Observable<String>>() {\n-\n-                        @Override\n-                        public Observable<String> call(ObservableHttpResponse response) {\n-                            return response.getContent().map(new Func1<byte[], String>() {\n-\n-                                @Override\n-                                public String call(byte[] bb) {\n-                                    return new String(bb);\n-                                }\n-\n-                            });\n-                        }\n-                    })\n-                    .filter(new Func1<String, Boolean>() {\n-\n-                        @Override\n-                        public Boolean call(String t1) {\n-                            return !t1.startsWith(\": ping\");\n-                        }\n-                    })\n-                    .take(3)\n-                    .toBlockingObservable()\n-                    .forEach(new Action1<String>() {\n-\n-                        @Override\n-                        public void call(String resp) {\n-                            System.out.println(\"Response [\" + c + \"]: \" + resp + \" (\" + resp.length() + \")\");\n-                        }\n-                    });\n-        }\n+        // URL against https://github.com/Netflix/Hystrix/tree/master/hystrix-examples-webapp\n+        // More information at https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-metrics-event-stream\n+        ObservableHttp.createRequest(HttpAsyncMethods.createGet(\"http://localhost:8989/hystrix-examples-webapp/hystrix.stream\"), client)\n+                .toObservable()\n+                .flatMap(new Func1<ObservableHttpResponse, Observable<String>>() {\n+\n+                    @Override\n+                    public Observable<String> call(ObservableHttpResponse response) {\n+                        return response.getContent().map(new Func1<byte[], String>() {\n+\n+                            @Override\n+                            public String call(byte[] bb) {\n+                                return new String(bb);\n+                            }\n+\n+                        });\n+                    }\n+                })\n+                .filter(new Func1<String, Boolean>() {\n+\n+                    @Override\n+                    public Boolean call(String t1) {\n+                        return !t1.startsWith(\": ping\");\n+                    }\n+                })\n+                .take(3)\n+                .toBlockingObservable()\n+                .forEach(new Action1<String>() {\n+\n+                    @Override\n+                    public void call(String resp) {\n+                        System.out.println(resp);\n+                    }\n+                });\n     }\n \n }",
    "output": "Fix to rxjava-apache-http - made Content-Type inspection more reliable - other small improvments"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -3046,39 +3046,6 @@ public <U> Observable<T> distinctUntilChanged(Func1<? super T, ? extends U> keyS\n         return create(OperationDistinctUntilChanged.distinctUntilChanged(this, keySelector));\n     }\n \n-    /**\n-     * Returns an Observable that forwards all items emitted from the source Observable that are sequentially\n-     * distinct according to a comparator.\n-     * <p>\n-     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinctUntilChanged.png\">\n-     * \n-     * @param equalityComparator\n-     *            a comparator for deciding whether two emitted items are equal or not\n-     * @return an Observable of sequentially distinct items\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229776%28v=vs.103%29.aspx\">MSDN: Observable.distinctUntilChanged</a>\n-     */\n-    public <U> Observable<T> distinctUntilChanged(Comparator<T> equalityComparator) {\n-        return create(OperationDistinctUntilChanged.distinctUntilChanged(this, equalityComparator));\n-    }\n-\n-    /**\n-     * Returns an Observable that forwards all items emitted from the source Observable that are sequentially\n-     * distinct according to a key selector function and a comparator.\n-     * <p>\n-     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinctUntilChanged.key.png\">\n-     * \n-     * @param keySelector\n-     *            a function that projects an emitted item to a key value which is used for deciding whether an item is sequentially\n-     *            distinct from another one or not\n-     * @param equalityComparator\n-     *            a comparator for deciding whether two emitted item keys are equal or not\n-     * @return an Observable of sequentially distinct items\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229533%28v=vs.103%29.aspx\">MSDN: Observable.distinctUntilChanged</a>\n-     */\n-    public <U> Observable<T> distinctUntilChanged(Func1<? super T, ? extends U> keySelector, Comparator<U> equalityComparator) {\n-        return create(OperationDistinctUntilChanged.distinctUntilChanged(this, keySelector, equalityComparator));\n-    }\n-\n     /**\n      * Returns an Observable that forwards all distinct items emitted from the source Observable.\n      * <p>\n@@ -3091,21 +3058,6 @@ public Observable<T> distinct() {\n         return create(OperationDistinct.distinct(this));\n     }\n     \n-    /**\n-     * Returns an Observable that forwards all items emitted from the source Observable that are distinct according\n-     * to a comparator.\n-     * <p>\n-     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinct.png\">\n-     * \n-     * @param equalityComparator\n-     *            a comparator for deciding whether two emitted items are equal or not\n-     * @return an Observable of distinct items\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211630(v=vs.103).aspx\">MSDN: Observable.distinct</a>\n-     */\n-    public <U> Observable<T> distinct(Comparator<T> equalityComparator) {\n-        return create(OperationDistinct.distinct(this, equalityComparator));\n-    }\n-    \n     /**\n      * Returns an Observable that forwards all items emitted from the source Observable that are distinct according\n      * to a key selector function.\n@@ -3122,24 +3074,6 @@ public <U> Observable<T> distinct(Func1<? super T, ? extends U> keySelector) {\n         return create(OperationDistinct.distinct(this, keySelector));\n     }\n     \n-    /**\n-     * Returns an Observable that forwards all items emitted from the source Observable that are distinct according\n-     * to a key selector function and a comparator.\n-     * <p>\n-     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinct.key.png\">\n-     * \n-     * @param keySelector\n-     *            a function that projects an emitted item to a key value which is used for deciding whether an item is\n-     *            distinct from another one or not\n-     * @param equalityComparator\n-     *            a comparator for deciding whether two emitted item keys are equal or not\n-     * @return an Observable of distinct items\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229050(v=vs.103).aspx\">MSDN: Observable.distinct</a>\n-     */\n-    public <U> Observable<T> distinct(Func1<? super T, ? extends U> keySelector, Comparator<U> equalityComparator) {\n-        return create(OperationDistinct.distinct(this, keySelector, equalityComparator));\n-    }\n-    \n     /**\n      * Returns the element at a specified index in a sequence.\n      * ",
    "output": "Remove 'comparator` overloads of `distinct` Removing these fairly recently added overloads as they turn out to not be the best approach. Discussion ongoing as to how to implement them at https://github.com/Netflix/RxJava/issues/395"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationInterval.java b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n@@ -46,7 +46,7 @@ public final class OperationInterval {\n      * Creates an event each time interval.\n      */\n     public static OnSubscribeFunc<Long> interval(long interval, TimeUnit unit) {\n-        return interval(interval, unit, Schedulers.executor(Executors.newSingleThreadScheduledExecutor()));\n+        return interval(interval, unit, Schedulers.threadPoolForComputation());\n     }\n \n     /**\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationSample.java b/rxjava-core/src/main/java/rx/operators/OperationSample.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationSample.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationSample.java\n@@ -49,7 +49,7 @@ public final class OperationSample {\n      * Samples the observable sequence at each interval.\n      */\n     public static <T> OnSubscribeFunc<T> sample(final Observable<? extends T> source, long period, TimeUnit unit) {\n-        return new Sample<T>(source, period, unit, Schedulers.executor(Executors.newSingleThreadScheduledExecutor()));\n+        return new Sample<T>(source, period, unit, Schedulers.threadPoolForComputation());\n     }\n \n     /**",
    "output": "Change Interval and Sample default Scheduler\n\nChange to use built-in thread-pools rather than creating a new Executor on each invocation.\nThe built-in ones are shared across all operators, have threads ready, are marked as daemon threads so don't prevent system shutdown, and are named for clarity when looking at thread dumps and debuggers"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -1783,6 +1783,13 @@ public Observable<T> synchronize() {\n         return create(OperationSynchronize.synchronize(this));\n     }\n \n+    /**\n+     * @deprecated Replaced with instance method. \n+     */\n+    @Deprecated\n+    public static <T> Observable<T> synchronize(Observable<T> source) {\n+        return create(OperationSynchronize.synchronize(source));\n+    }\n     \n     /**\n      * Emits an item each time interval (containing a sequential number).",
    "output": "Make Observable.synchronize an instance method rather than static"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -397,7 +397,7 @@ public Subscription subscribe(final Action1<? super T> onNext, final Action1<Thr\n      * @return a {@link ConnectableObservable} that upon connection causes the source Observable to\n      *         push results into the specified {@link Subject}\n      */\n-    public <R> ConnectableObservable<R> multicast(Subject<T, R> subject) {\n+    public <R> ConnectableObservable<R> multicast(Subject<? super T, ? extends R> subject) {\n         return OperationMulticast.multicast(this, subject);\n     }\n \n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationMulticast.java b/rxjava-core/src/main/java/rx/operators/OperationMulticast.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationMulticast.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationMulticast.java\n@@ -27,19 +27,19 @@\n import rx.subjects.Subject;\n \n public class OperationMulticast {\n-    public static <T, R> ConnectableObservable<R> multicast(Observable<? extends T> source, final Subject<T, R> subject) {\n+    public static <T, R> ConnectableObservable<R> multicast(Observable<? extends T> source, final Subject<? super T, ? extends R> subject) {\n         return new MulticastConnectableObservable<T, R>(source, subject);\n     }\n \n     private static class MulticastConnectableObservable<T, R> extends ConnectableObservable<R> {\n         private final Object lock = new Object();\n \n         private final Observable<? extends T> source;\n-        private final Subject<T, R> subject;\n+        private final Subject<? super T, ? extends R> subject;\n \n         private Subscription subscription;\n \n-        public MulticastConnectableObservable(Observable<? extends T> source, final Subject<T, R> subject) {\n+        public MulticastConnectableObservable(Observable<? extends T> source, final Subject<? super T, ? extends R> subject) {\n             super(new OnSubscribeFunc<R>() {\n                 @Override\n                 public Subscription onSubscribe(Observer<? super R> observer) {",
    "output": "Use Java Subject<T, R> as contravariant in T and covariant in R"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -4188,36 +4188,36 @@ private boolean isInternalImplementation(Object o) {\n         return p != null && p.getName().startsWith(\"rx.operators\");\n     }\n \n-//    /**\n-//     * Returns an {@link Observable} that emits <code>true</code> if the source\n-//     * {@link Observable} is not empty, otherwise <code>false</code>.\n-//     * \n-//     * @param source\n-//     *            The source {@link Observable} to check if not empty.\n-//     * @return A subscription function for creating the target Observable.\n-//     * @see <a href=\n-//     *      \"http://msdn.microsoft.com/en-us/library/hh229905(v=vs.103).aspx\"\n-//     *      >MSDN: Observable.Any</a>\n-//     */\n-//    public Observable<Boolean> any() {\n-//        return create(OperationAny.any(this));\n-//    }\n-//\n-//    /**\n-//     * Returns an {@link Observable} that emits <code>true</code> if all items\n-//     * of the source {@link Observable} satisfy the given condition, otherwise\n-//     * <code>false</code>.\n-//     * \n-//     * @param predicate\n-//     *            The condition all items have to satisfy.\n-//     * @return A subscription function for creating the target Observable.\n-//     * \n-//     * @see <a href=\n-//     *      \"http://msdn.microsoft.com/en-us/library/hh211993(v=vs.103).aspx\"\n-//     *      >MSDN: Observable.Any</a>\n-//     */\n-//    public Observable<Boolean> any(Func1<? super T, Boolean> predicate) {\n-//        return create(OperationAny.any(this, predicate));\n-//    }\n+    /**\n+     * Returns an {@link Observable} that emits <code>true</code> if the source\n+     * {@link Observable} is not empty, otherwise <code>false</code>.\n+     * \n+     * @param source\n+     *            The source {@link Observable} to check if not empty.\n+     * @return A subscription function for creating the target Observable.\n+     * @see <a href=\n+     *      \"http://msdn.microsoft.com/en-us/library/hh229905(v=vs.103).aspx\"\n+     *      >MSDN: Observable.Any</a>\n+     */\n+    public Observable<Boolean> any() {\n+        return create(OperationAny.any(this));\n+    }\n+\n+    /**\n+     * Returns an {@link Observable} that emits <code>true</code> if all items\n+     * of the source {@link Observable} satisfy the given condition, otherwise\n+     * <code>false</code>.\n+     * \n+     * @param predicate\n+     *            The condition all items have to satisfy.\n+     * @return A subscription function for creating the target Observable.\n+     * \n+     * @see <a href=\n+     *      \"http://msdn.microsoft.com/en-us/library/hh211993(v=vs.103).aspx\"\n+     *      >MSDN: Observable.Any</a>\n+     */\n+    public Observable<Boolean> any(Func1<? super T, Boolean> predicate) {\n+        return create(OperationAny.any(this, predicate));\n+    }\n \n }",
    "output": "Add 'any' operator to Observable"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationDistinct.java b/rxjava-core/src/main/java/rx/operators/OperationDistinct.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationDistinct.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationDistinct.java\n@@ -206,6 +206,8 @@ public void call() {\n     public static class UnitTest {\n         @Mock\n         Observer<? super String> w;\n+        @Mock\n+        Observer<? super String> w2;\n         \n         // nulls lead to exceptions\n         final Func1<String, String> TO_UPPER_WITH_EXCEPTION = new Func1<String, String>() {\n@@ -310,6 +312,31 @@ public void testDistinctOfNormalSourceWithKeySelectorAndComparator() {\n             verify(w, never()).onError(any(Throwable.class));\n         }\n \n+        @Test\n+        public void testDistinctOfNormalSourceWithKeySelectorAndComparatorAndTwoSubscriptions() {\n+            Observable<String> src = from(\"a\", \"x\", \"ab\", \"abc\", \"cba\", \"de\", \"x\", \"a\", \"abcd\");\n+            create(distinct(src, TO_UPPER_WITH_EXCEPTION, COMPARE_LENGTH)).subscribe(w);\n+\n+            InOrder inOrder = inOrder(w); \n+            inOrder.verify(w, times(1)).onNext(\"a\");\n+            inOrder.verify(w, times(1)).onNext(\"x\");\n+            create(distinct(src, TO_UPPER_WITH_EXCEPTION, COMPARE_LENGTH)).subscribe(w2);\n+            inOrder.verify(w, times(1)).onNext(\"abc\");\n+            inOrder.verify(w, times(1)).onNext(\"abcd\");\n+            inOrder.verify(w, times(1)).onCompleted();\n+            inOrder.verify(w, never()).onNext(anyString());\n+            verify(w, never()).onError(any(Throwable.class));\n+            \n+            InOrder inOrder2 = inOrder(w2); \n+            inOrder2.verify(w2, times(1)).onNext(\"a\");\n+            inOrder2.verify(w2, times(1)).onNext(\"x\");\n+            inOrder2.verify(w2, times(1)).onNext(\"abc\");\n+            inOrder2.verify(w2, times(1)).onNext(\"abcd\");\n+            inOrder2.verify(w2, times(1)).onCompleted();\n+            inOrder2.verify(w2, never()).onNext(anyString());\n+            verify(w2, never()).onError(any(Throwable.class));\n+        }\n+\n         @Test\n         public void testDistinctOfSourceWithNulls() {\n             Observable<String> src = from(null, \"a\", \"a\", null, null, \"b\", null);\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n@@ -161,6 +161,8 @@ public void call() {\n     public static class UnitTest {\n         @Mock\n         Observer<? super String> w;\n+        @Mock\n+        Observer<? super String> w2;\n         \n         // nulls lead to exceptions\n         final Func1<String, String> TO_UPPER_WITH_EXCEPTION = new Func1<String, String>() {\n@@ -295,5 +297,29 @@ public void testDistinctUntilChangedWithComparatorAndKeySelector() {\n             inOrder.verify(w, never()).onNext(anyString());\n             verify(w, never()).onError(any(Throwable.class));\n         }\n+\n+        @Test\n+        public void testDistinctUntilChangedWithComparatorAndKeySelectorandTwoSubscriptions() {\n+            Observable<String> src = from(\"a\", \"b\", \"x\", \"aa\", \"bb\", \"c\", \"ddd\");\n+            create(distinctUntilChanged(src, TO_UPPER_WITH_EXCEPTION, COMPARE_LENGTH)).subscribe(w);\n+            InOrder inOrder = inOrder(w); \n+            inOrder.verify(w, times(1)).onNext(\"a\");\n+            inOrder.verify(w, times(1)).onNext(\"x\");\n+            create(distinctUntilChanged(src, TO_UPPER_WITH_EXCEPTION, COMPARE_LENGTH)).subscribe(w2);\n+            inOrder.verify(w, times(1)).onNext(\"c\");\n+            inOrder.verify(w, times(1)).onNext(\"ddd\");\n+            inOrder.verify(w, times(1)).onCompleted();\n+            inOrder.verify(w, never()).onNext(anyString());\n+            verify(w, never()).onError(any(Throwable.class));\n+            \n+            InOrder inOrder2 = inOrder(w2); \n+            inOrder2.verify(w2, times(1)).onNext(\"a\");\n+            inOrder2.verify(w2, times(1)).onNext(\"x\");\n+            inOrder2.verify(w2, times(1)).onNext(\"c\");\n+            inOrder2.verify(w2, times(1)).onNext(\"ddd\");\n+            inOrder2.verify(w2, times(1)).onCompleted();\n+            inOrder2.verify(w2, never()).onNext(anyString());\n+            verify(w2, never()).onError(any(Throwable.class));\n+        }\n     }\n }",
    "output": "Add tests against multiple subscriptions, just to be on the safe side"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -19,6 +19,7 @@\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.List;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n@@ -2948,6 +2949,35 @@ public <U> Observable<T> distinctUntilChanged(Func1<? super T, ? extends U> keyS\n         return create(OperationDistinctUntilChanged.distinctUntilChanged(this, keySelector));\n     }\n \n+    /**\n+     * Returns an Observable that forwards all items emitted from the source Observable that are sequentially distinct according to\n+     * a comparator.\n+     * \n+     * @param equalityComparator\n+     *            a comparator for deciding whether two emitted items are equal or not\n+     * @return an Observable of sequentially distinct items\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229508%28v=vs.103%29.aspx\">MSDN: Observable.distinctUntilChanged</a>\n+     */\n+    public <U> Observable<T> distinctUntilChanged(Comparator<T> equalityComparator) {\n+        return create(OperationDistinctUntilChanged.distinctUntilChanged(this, equalityComparator));\n+    }\n+\n+    /**\n+     * Returns an Observable that forwards all items emitted from the source Observable that are sequentially distinct according to\n+     * a key selector function and a comparator.\n+     * \n+     * @param keySelector\n+     *            a function that projects an emitted item to a key value which is used for deciding whether an item is sequentially\n+     *            distinct from another one or not\n+     * @param equalityComparator\n+     *            a comparator for deciding whether two emitted item keys are equal or not\n+     * @return an Observable of sequentially distinct items\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229508%28v=vs.103%29.aspx\">MSDN: Observable.distinctUntilChanged</a>\n+     */\n+    public <U> Observable<T> distinctUntilChanged(Func1<? super T, ? extends U> keySelector, Comparator<U> equalityComparator) {\n+        return create(OperationDistinctUntilChanged.distinctUntilChanged(this, keySelector, equalityComparator));\n+    }\n+\n     /**\n      * Returns an Observable that forwards all distinct items emitted from the source Observable.\n      * \n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n@@ -43,6 +43,14 @@\n  */\n public final class OperationDistinctUntilChanged {\n \n+    /**\n+     * Returns an Observable that emits all sequentially distinct items emitted by the source.\n+     * @param source\n+     *            The source Observable to emit the sequentially distinct items for.\n+     * @param equalityComparator\n+     *            The comparator to use for deciding whether to consider two items as equal or not.\n+     * @return A subscription function for creating the target Observable.\n+     */\n     public static <T> OnSubscribeFunc<T> distinctUntilChanged(Observable<? extends T> source, Comparator<T> equalityComparator) {\n         return new DistinctUntilChanged<T, T>(source, Functions.<T>identity(), equalityComparator);\n     }\n@@ -51,6 +59,22 @@ public static <T> OnSubscribeFunc<T> distinctUntilChanged(Observable<? extends T\n      * Returns an Observable that emits all sequentially distinct items emitted by the source.\n      * @param source\n      *            The source Observable to emit the sequentially distinct items for.\n+     * @param keySelector\n+     *            The function to select the key to use for the equality checks.\n+     * @param equalityComparator\n+     *            The comparator to use for deciding whether to consider the two item keys as equal or not.\n+     * @return A subscription function for creating the target Observable.\n+     */\n+    public static <T, U> OnSubscribeFunc<T> distinctUntilChanged(Observable<? extends T> source, Func1<? super T, ? extends U> keySelector, Comparator<U> equalityComparator) {\n+        return new DistinctUntilChanged<T, U>(source, keySelector, equalityComparator);\n+    }\n+    \n+    /**\n+     * Returns an Observable that emits all sequentially distinct items emitted by the source.\n+     * @param source\n+     *            The source Observable to emit the sequentially distinct items for.\n+     * @param keySelector\n+     *            The function to select the key to use for the equality checks.\n      * @return A subscription function for creating the target Observable.\n      */\n     public static <T, U> OnSubscribeFunc<T> distinctUntilChanged(Observable<? extends T> source, Func1<? super T, ? extends U> keySelector) {\n@@ -142,6 +166,9 @@ public static class UnitTest {\n         final Func1<String, String> TO_UPPER_WITH_EXCEPTION = new Func1<String, String>() {\n             @Override\n             public String call(String s) {\n+                if (s.equals(\"x\")) {\n+                    return \"xx\";\n+                }\n                 return s.toUpperCase();\n             }\n         };\n@@ -254,5 +281,19 @@ public void testDistinctUntilChangedWithComparator() {\n             inOrder.verify(w, never()).onNext(anyString());\n             verify(w, never()).onError(any(Throwable.class));\n         }\n+\n+        @Test\n+        public void testDistinctUntilChangedWithComparatorAndKeySelector() {\n+            Observable<String> src = from(\"a\", \"b\", \"x\", \"aa\", \"bb\", \"c\", \"ddd\");\n+            create(distinctUntilChanged(src, TO_UPPER_WITH_EXCEPTION, COMPARE_LENGTH)).subscribe(w);\n+            InOrder inOrder = inOrder(w); \n+            inOrder.verify(w, times(1)).onNext(\"a\");\n+            inOrder.verify(w, times(1)).onNext(\"x\");\n+            inOrder.verify(w, times(1)).onNext(\"c\");\n+            inOrder.verify(w, times(1)).onNext(\"ddd\");\n+            inOrder.verify(w, times(1)).onCompleted();\n+            inOrder.verify(w, never()).onNext(anyString());\n+            verify(w, never()).onError(any(Throwable.class));\n+        }\n     }\n }",
    "output": "Add both new variants to observable"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n@@ -146,6 +146,13 @@ public String call(String s) {\n             }\n         };\n         \n+        final Comparator<String> COMPARE_LENGTH = new Comparator<String>() {\n+            @Override\n+            public int compare(String s1, String s2) {\n+                return s1.length() - s2.length();\n+            }\n+        };\n+        \n         @Before\n         public void before() {\n             initMocks(this);\n@@ -233,5 +240,19 @@ public void testDistinctUntilChangedOfSourceWithExceptionsFromKeySelector() {\n             inOrder.verify(w, never()).onNext(anyString());\n             inOrder.verify(w, never()).onCompleted();\n         }\n+        \n+        @Test\n+        public void testDistinctUntilChangedWithComparator() {\n+            Observable<String> src = from(\"a\", \"b\", \"c\", \"aa\", \"bb\", \"c\", \"ddd\");\n+            create(distinctUntilChanged(src, COMPARE_LENGTH)).subscribe(w);\n+            InOrder inOrder = inOrder(w); \n+            inOrder.verify(w, times(1)).onNext(\"a\");\n+            inOrder.verify(w, times(1)).onNext(\"aa\");\n+            inOrder.verify(w, times(1)).onNext(\"c\");\n+            inOrder.verify(w, times(1)).onNext(\"ddd\");\n+            inOrder.verify(w, times(1)).onCompleted();\n+            inOrder.verify(w, never()).onNext(anyString());\n+            verify(w, never()).onError(any(Throwable.class));\n+        }\n     }\n }",
    "output": "Add test against comparator usage"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationInterval.java b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n@@ -32,7 +32,6 @@\n import rx.Subscription;\n import rx.concurrency.Schedulers;\n import rx.concurrency.TestScheduler;\n-import rx.observables.ConnectableObservable;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;\n \n@@ -165,5 +164,46 @@ public void testWithMultipleSubscribersStartingAtSameTime() {\n             verify(observer2, times(1)).onCompleted();\n             verify(observer2, never()).onError(any(Throwable.class));\n         }\n+\n+        @Test\n+        public void testWithMultipleStaggeredSubscribers() {\n+            Observable<Long> w = Observable.create(OperationInterval.interval(1, TimeUnit.SECONDS, scheduler));\n+            Subscription sub1 = w.subscribe(observer);\n+\n+            verify(observer, never()).onNext(anyLong());\n+            \n+            scheduler.advanceTimeTo(2, TimeUnit.SECONDS);\n+            Subscription sub2 = w.subscribe(observer2);\n+            \n+            InOrder inOrder1 = inOrder(observer);\n+            inOrder1.verify(observer, times(1)).onNext(0L);\n+            inOrder1.verify(observer, times(1)).onNext(1L);\n+            inOrder1.verify(observer, never()).onNext(2L);\n+            \n+            verify(observer, never()).onCompleted();\n+            verify(observer, never()).onError(any(Throwable.class));\n+            verify(observer2, never()).onNext(anyLong());\n+\n+            scheduler.advanceTimeTo(4, TimeUnit.SECONDS);\n+            \n+            inOrder1.verify(observer, times(1)).onNext(2L);\n+            inOrder1.verify(observer, times(1)).onNext(3L);\n+            inOrder1.verify(observer, never()).onNext(4L);\n+            \n+            InOrder inOrder2 = inOrder(observer2);\n+            inOrder2.verify(observer2, times(1)).onNext(0L);\n+            inOrder2.verify(observer2, times(1)).onNext(1L);\n+            \n+            sub1.unsubscribe();\n+            sub2.unsubscribe();\n+\n+            inOrder1.verify(observer, never()).onNext(anyLong());\n+            inOrder1.verify(observer, times(1)).onCompleted();\n+            verify(observer, never()).onError(any(Throwable.class));\n+\n+            inOrder2.verify(observer2, never()).onNext(2L);\n+            inOrder2.verify(observer2, times(1)).onCompleted();\n+            verify(observer2, never()).onError(any(Throwable.class));\n+        }\n     }\n }",
    "output": "Add another test against multiple staggered subscribers"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationInterval.java b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n@@ -32,6 +32,7 @@\n import rx.Subscription;\n import rx.concurrency.Schedulers;\n import rx.concurrency.TestScheduler;\n+import rx.observables.ConnectableObservable;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;\n \n@@ -98,6 +99,7 @@ public static class UnitTest {\n         public void before() {\n             scheduler = new TestScheduler();\n             observer = mock(Observer.class);\n+            observer2 = mock(Observer.class);\n         }\n         \n         @Test",
    "output": "Add missing mock"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationInterval.java b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n@@ -91,6 +91,7 @@ public void call() {\n     public static class UnitTest {\n         private TestScheduler scheduler;\n         private Observer<Long> observer;\n+        private Observer<Long> observer2;\n         \n         @Before\n         @SuppressWarnings(\"unchecked\") // due to mocking\n@@ -123,5 +124,44 @@ public void testInterval() {\n             verify(observer, times(1)).onCompleted();\n             verify(observer, never()).onError(any(Throwable.class));\n         }\n+        \n+        @Test\n+        public void testWithMultipleSubscribersStartingAtSameTime() {\n+            Observable<Long> w = Observable.create(OperationInterval.interval(1, TimeUnit.SECONDS, scheduler));\n+            Subscription sub1 = w.subscribe(observer);\n+            Subscription sub2 = w.subscribe(observer2);\n+\n+            verify(observer, never()).onNext(anyLong());\n+            verify(observer2, never()).onNext(anyLong());\n+            \n+            scheduler.advanceTimeTo(2, TimeUnit.SECONDS);\n+            \n+            InOrder inOrder1 = inOrder(observer);\n+            InOrder inOrder2 = inOrder(observer2);\n+            \n+            inOrder1.verify(observer, times(1)).onNext(0L);\n+            inOrder1.verify(observer, times(1)).onNext(1L);\n+            inOrder1.verify(observer, never()).onNext(2L);\n+            verify(observer, never()).onCompleted();\n+            verify(observer, never()).onError(any(Throwable.class));\n+\n+            inOrder2.verify(observer2, times(1)).onNext(0L);\n+            inOrder2.verify(observer2, times(1)).onNext(1L);\n+            inOrder2.verify(observer2, never()).onNext(2L);\n+            verify(observer2, never()).onCompleted();\n+            verify(observer2, never()).onError(any(Throwable.class));\n+\n+            sub1.unsubscribe();\n+            sub2.unsubscribe();\n+            scheduler.advanceTimeTo(4, TimeUnit.SECONDS);\n+\n+            verify(observer, never()).onNext(2L);\n+            verify(observer, times(1)).onCompleted();\n+            verify(observer, never()).onError(any(Throwable.class));\n+\n+            verify(observer2, never()).onNext(2L);\n+            verify(observer2, times(1)).onCompleted();\n+            verify(observer2, never()).onError(any(Throwable.class));\n+        }\n     }\n }",
    "output": "Add test with multiple subscribers"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -36,6 +36,7 @@\n import rx.operators.OperationConcat;\n import rx.operators.OperationDefer;\n import rx.operators.OperationDematerialize;\n+import rx.operators.OperationDistinctUntilChanged;\n import rx.operators.OperationFilter;\n import rx.operators.OperationFinally;\n import rx.operators.OperationFirstOrDefault;\n@@ -2925,6 +2926,30 @@ public Observable<T> filter(Func1<? super T, Boolean> predicate) {\n         return create(OperationFilter.filter(this, predicate));\n     }\n \n+    /**\n+     * Returns an Observable that forwards all sequentially distinct items emitted from the source Observable.\n+     * \n+     * @return an Observable of sequentially distinct items\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229494%28v=vs.103%29.aspx\">MSDN: Observable.distinctUntilChanged</a>\n+     */\n+    public Observable<T> distinctUntilChanged() {\n+        return create(OperationDistinctUntilChanged.distinctUntilChanged(this));\n+    }\n+\n+    /**\n+     * Returns an Observable that forwards all items emitted from the source Observable that are sequentially distinct according to\n+     * a key selector function.\n+     * \n+     * @param keySelector\n+     *            a function that projects an emitted item to a key value which is used for deciding whether an item is sequentially\n+     *            distinct from another one or not\n+     * @return an Observable of sequentially distinct items\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229508%28v=vs.103%29.aspx\">MSDN: Observable.distinctUntilChanged</a>\n+     */\n+    public <U> Observable<T> distinctUntilChanged(Func1<? super T, ? extends U> keySelector) {\n+        return create(OperationDistinctUntilChanged.distinctUntilChanged(this, keySelector));\n+    }\n+\n     /**\n      * Registers an {@link Action0} to be called when this Observable invokes {@link Observer#onCompleted onCompleted} or {@link Observer#onError onError}.\n      * <p>",
    "output": "Add distinctUntilChanged member methods to Observable"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java\n@@ -22,9 +22,6 @@\n import static rx.Observable.empty;\n import static rx.Observable.from;\n \n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.InOrder;\n@@ -36,35 +33,49 @@\n import rx.Subscription;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;\n+import rx.util.functions.Func1;\n+import rx.util.functions.Functions;\n \n /**\n  * Returns an Observable that emits the first item emitted by the source\n  * Observable, or a default value if the source emits nothing.\n  */\n public final class OperationDistinctUntilChanged {\n \n+    /**\n+     * Returns an Observable that emits all sequentially distinct items emitted by the source\n+     * @param source\n+     *            The source Observable to emit the sequentially distinct items for.\n+     * @return A subscription function for creating the target Observable.\n+     */\n+    public static <T, U> OnSubscribeFunc<T> distinctUntilChanged(Observable<? extends T> source, Func1<? super T, ? extends U> keySelector) {\n+        return new DistinctUntilChanged<T, U>(source, keySelector);\n+    }\n+    \n     /**\n      * Returns an Observable that emits all sequentially distinct items emitted by the source\n      * @param source\n      *            The source Observable to emit the sequentially distinct items for.\n      * @return A subscription function for creating the target Observable.\n      */\n     public static <T> OnSubscribeFunc<T> distinctUntilChanged(Observable<? extends T> source) {\n-        return new DistinctUntilChanged<T>(source);\n+        return new DistinctUntilChanged<T, T>(source, Functions.<T>identity());\n     }\n     \n-    private static class DistinctUntilChanged<T> implements OnSubscribeFunc<T> {\n+    private static class DistinctUntilChanged<T, U> implements OnSubscribeFunc<T> {\n         private final Observable<? extends T> source;\n-\n-        private DistinctUntilChanged(Observable<? extends T> source) {\n+        private final Func1<? super T, ? extends U> keySelector;\n+        \n+        private DistinctUntilChanged(Observable<? extends T> source, Func1<? super T, ? extends U> keySelector) {\n             this.source = source;\n+            this.keySelector = keySelector;\n         }\n \n         @Override\n         public Subscription onSubscribe(final Observer<? super T> observer) {\n             final Subscription sourceSub = source.subscribe(new Observer<T>() {\n-                private final AtomicReference<T> lastEmittedValue = new AtomicReference<T>(null);\n-                private final AtomicBoolean hasEmitted = new AtomicBoolean();\n+                private U lastEmittedKey;\n+                private boolean hasEmitted;\n                 \n                 @Override\n                 public void onCompleted() {\n@@ -78,16 +89,27 @@ public void onError(Throwable e) {\n \n                 @Override\n                 public void onNext(T next) {\n-                    boolean hasAlreadyEmitted = hasEmitted.getAndSet(true);\n-                    T lastEmitted = lastEmittedValue.getAndSet(next);\n-                    if (!hasAlreadyEmitted) {\n-                        observer.onNext(next);\n-                    } else if (lastEmitted == null) {\n-                        if (next != null) {\n+                    U lastKey = lastEmittedKey;\n+                    try {\n+                        U nextKey = keySelector.call(next);\n+                        lastEmittedKey = nextKey;\n+                        if (!hasEmitted) {\n+                            hasEmitted = true;\n                             observer.onNext(next);\n+                        } else {\n+                            if (lastKey == null) {\n+                                if (nextKey != null) {\n+                                    observer.onNext(next);\n+                                }\n+                            } else {\n+                                if (!lastKey.equals(nextKey)) {\n+                                    observer.onNext(next);\n+                                }\n+                            }\n                         }\n-                    } else if (!lastEmitted.equals(next)) {\n-                        observer.onNext(next);\n+                    } catch (Throwable t) {\n+                        // keySelector is a user function, may throw something\n+                        observer.onError(t);\n                     }\n                 }\n             });\n@@ -105,6 +127,14 @@ public static class UnitTest {\n         @Mock\n         Observer<? super String> w;\n         \n+        // nulls lead to exceptions\n+        final Func1<String, String> TO_UPPER_WITH_EXCEPTION = new Func1<String, String>() {\n+            @Override\n+            public String call(String s) {\n+                return s.toUpperCase();\n+            }\n+        };\n+        \n         @Before\n         public void before() {\n             initMocks(this);\n@@ -120,6 +150,16 @@ public void testDistinctUntilChangedOfNone() {\n             verify(w, times(1)).onCompleted();\n         }\n \n+        @Test\n+        public void testDistinctUntilChangedOfNoneWithKeySelector() {\n+            Observable<String> src = empty();\n+            create(distinctUntilChanged(src, TO_UPPER_WITH_EXCEPTION)).subscribe(w);\n+\n+            verify(w, never()).onNext(anyString());\n+            verify(w, never()).onError(any(Throwable.class));\n+            verify(w, times(1)).onCompleted();\n+        }\n+\n         @Test\n         public void testDistinctUntilChangedOfNormalSource() {\n             Observable<String> src = from(\"a\", \"b\", \"c\", \"c\", \"c\", \"b\", \"b\", \"a\", \"e\");\n@@ -137,6 +177,23 @@ public void testDistinctUntilChangedOfNormalSource() {\n             verify(w, never()).onError(any(Throwable.class));\n         }\n \n+        @Test\n+        public void testDistinctUntilChangedOfNormalSourceWithKeySelector() {\n+            Observable<String> src = from(\"a\", \"b\", \"c\", \"C\", \"c\", \"B\", \"b\", \"a\", \"e\");\n+            create(distinctUntilChanged(src, TO_UPPER_WITH_EXCEPTION)).subscribe(w);\n+\n+            InOrder inOrder = inOrder(w); \n+            inOrder.verify(w, times(1)).onNext(\"a\");\n+            inOrder.verify(w, times(1)).onNext(\"b\");\n+            inOrder.verify(w, times(1)).onNext(\"c\");\n+            inOrder.verify(w, times(1)).onNext(\"B\");\n+            inOrder.verify(w, times(1)).onNext(\"a\");\n+            inOrder.verify(w, times(1)).onNext(\"e\");\n+            inOrder.verify(w, times(1)).onCompleted();\n+            inOrder.verify(w, never()).onNext(anyString());\n+            verify(w, never()).onError(any(Throwable.class));\n+        }\n+\n         @Test\n         public void testDistinctUntilChangedOfSourceWithNulls() {\n             Observable<String> src = from(null, \"a\", \"a\", null, null, \"b\", null, null);\n@@ -152,5 +209,18 @@ public void testDistinctUntilChangedOfSourceWithNulls() {\n             inOrder.verify(w, never()).onNext(anyString());\n             verify(w, never()).onError(any(Throwable.class));\n         }\n+\n+        @Test\n+        public void testDistinctUntilChangedOfSourceWithExceptionsFromKeySelector() {\n+            Observable<String> src = from(\"a\", \"b\", null, \"c\");\n+            create(distinctUntilChanged(src, TO_UPPER_WITH_EXCEPTION)).subscribe(w);\n+\n+            InOrder inOrder = inOrder(w); \n+            inOrder.verify(w, times(1)).onNext(\"a\");\n+            inOrder.verify(w, times(1)).onNext(\"b\");\n+            verify(w, times(1)).onError(any(NullPointerException.class));\n+            inOrder.verify(w, never()).onNext(anyString());\n+            inOrder.verify(w, never()).onCompleted();\n+        }\n     }\n }",
    "output": "Add methods taking key selectors"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -3021,7 +3021,7 @@ public Observable<T> onErrorReturn(Func1<Throwable, ? extends T> resumeFunction)\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx\">MSDN: Observable.Aggregate</a>\n      * @see <a href=\"http://en.wikipedia.org/wiki/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)</a>\n      */\n-    public Observable<T> reduce(Func2<? super T, ? super T, ? extends T> accumulator) {\n+    public Observable<T> reduce(Func2<T, T, T> accumulator) {\n         return create(OperationScan.scan(this, accumulator)).takeLast(1);\n     }\n \n@@ -3166,7 +3166,7 @@ public ConnectableObservable<T> publish() {\n      * \n      * @see #reduce(Func2)\n      */\n-    public Observable<T> aggregate(Func2<? super T, ? super T, ? extends T> accumulator) {\n+    public Observable<T> aggregate(Func2<T, T, T> accumulator) {\n         return reduce(accumulator);\n     }\n \n@@ -3227,7 +3227,7 @@ public <R> Observable<R> aggregate(R initialValue, Func2<? super R, ? super T, ?\n      * @return an Observable that emits the results of each call to the accumulator function\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211665(v%3Dvs.103).aspx\">MSDN: Observable.Scan</a>\n      */\n-    public Observable<T> scan(Func2<? super T, ? super T, ? extends T> accumulator) {\n+    public Observable<T> scan(Func2<T, T, T> accumulator) {\n         return create(OperationScan.scan(this, accumulator));\n     }\n \n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationScan.java b/rxjava-core/src/main/java/rx/operators/OperationScan.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationScan.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationScan.java\n@@ -70,7 +70,7 @@ public static <T, R> OnSubscribeFunc<R> scan(Observable<? extends T> sequence, R\n      * @return An observable sequence whose elements are the result of accumulating the output from the list of Observables.\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211665(v=vs.103).aspx\">Observable.Scan(TSource) Method (IObservable(TSource), Func(TSource, TSource, TSource))</a>\n      */\n-    public static <T> OnSubscribeFunc<T> scan(Observable<? extends T> sequence, Func2<? super T, ? super T, ? extends T> accumulator) {\n+    public static <T> OnSubscribeFunc<T> scan(Observable<? extends T> sequence, Func2<T, T, T> accumulator) {\n         return new AccuWithoutInitialValue<T>(sequence, accumulator);\n     }\n \n\ndiff --git a/rxjava-core/src/test/java/rx/CovarianceTest.java b/rxjava-core/src/test/java/rx/CovarianceTest.java\n--- a/rxjava-core/src/test/java/rx/CovarianceTest.java\n+++ b/rxjava-core/src/test/java/rx/CovarianceTest.java\n@@ -4,6 +4,8 @@\n \n import org.junit.Test;\n \n+import rx.util.functions.Func2;\n+\n /**\n  * Test super/extends of generics.\n  * \n@@ -21,6 +23,25 @@ public void testCovarianceOfFrom() {\n         // Observable.<HorrorMovie>from(new Movie()); // may not compile\n     }\n \n+    @Test\n+    public void testSortedList() {\n+        Func2<Media, Media, Integer> SORT_FUNCTION = new Func2<Media, Media, Integer>() {\n+\n+            @Override\n+            public Integer call(Media t1, Media t2) {\n+                return 1;\n+            }\n+        };\n+\n+        // this one would work without the covariance generics\n+        Observable<Media> o = Observable.from(new Movie(), new TVSeason(), new Album());\n+        o.toSortedList(SORT_FUNCTION);\n+\n+        // this one would NOT work without the covariance generics\n+        Observable<Movie> o2 = Observable.from(new Movie(), new ActionMovie(), new HorrorMovie());\n+        o2.toSortedList(SORT_FUNCTION);\n+    }\n+\n     /*\n      * Most tests are moved into their applicable classes such as [Operator]Tests.java\n      */\n@@ -34,6 +55,15 @@ static class Movie extends Media {\n     static class HorrorMovie extends Movie {\n     }\n \n+    static class ActionMovie extends Movie {\n+    }\n+\n+    static class Album extends Media {\n+    }\n+\n+    static class TVSeason extends Media {\n+    }\n+\n     static class Rating {\n     }\n \n\ndiff --git a/rxjava-core/src/test/java/rx/ReduceTests.java b/rxjava-core/src/test/java/rx/ReduceTests.java\n--- a/rxjava-core/src/test/java/rx/ReduceTests.java\n+++ b/rxjava-core/src/test/java/rx/ReduceTests.java\n@@ -25,6 +25,7 @@ public Integer call(Integer t1, Integer t2) {\n         assertEquals(6, value);\n     }\n \n+    @SuppressWarnings(\"unused\")\n     @Test\n     public void reduceWithObjects() {\n         Observable<Movie> horrorMovies = Observable.<Movie> from(new HorrorMovie());\n@@ -41,9 +42,15 @@ public Movie call(Movie t1, Movie t2) {\n         Observable<Movie> reduceResult2 = horrorMovies.reduce(chooseSecondMovie);\n     }\n \n+    /**\n+     * Reduce consumes and produces T so can't do covariance.\n+     * \n+     * https://github.com/Netflix/RxJava/issues/360#issuecomment-24203016\n+     */\n+    @SuppressWarnings(\"unused\")\n     @Test\n     public void reduceWithCovariantObjects() {\n-        Observable<HorrorMovie> horrorMovies = Observable.from(new HorrorMovie());\n+        Observable<Movie> horrorMovies = Observable.<Movie> from(new HorrorMovie());\n \n         Func2<Movie, Movie, Movie> chooseSecondMovie =\n                 new Func2<Movie, Movie, Movie>() {\n@@ -52,36 +59,33 @@ public Movie call(Movie t1, Movie t2) {\n                     }\n                 };\n \n-        Observable<Movie> reduceResult = Observable.create(OperationScan.scan(horrorMovies, chooseSecondMovie)).takeLast(1);\n-\n-        //TODO this isn't compiling\n-        //        Observable<Movie> reduceResult2 = horrorMovies.reduce(chooseSecondMovie);\n+        Observable<Movie> reduceResult2 = horrorMovies.reduce(chooseSecondMovie);\n     }\n \n+    /**\n+     * Reduce consumes and produces T so can't do covariance.\n+     * \n+     * https://github.com/Netflix/RxJava/issues/360#issuecomment-24203016\n+     */\n     @Test\n     public void reduceCovariance() {\n-        Observable<HorrorMovie> horrorMovies = Observable.from(new HorrorMovie());\n-\n-        // do something with horrorMovies, relying on the fact that all are HorrorMovies\n-        // and not just any Movies...\n-\n-        // pass it to library (works because it takes Observable<? extends Movie>)\n+        // must type it to <Movie>\n+        Observable<Movie> horrorMovies = Observable.<Movie> from(new HorrorMovie());\n         libraryFunctionActingOnMovieObservables(horrorMovies);\n     }\n \n-    public void libraryFunctionActingOnMovieObservables(Observable<? extends Movie> obs) {\n+    /*\n+     * This accepts <Movie> instead of <? super Movie> since `reduce` can't handle covariants\n+     */\n+    public void libraryFunctionActingOnMovieObservables(Observable<Movie> obs) {\n         Func2<Movie, Movie, Movie> chooseSecondMovie =\n                 new Func2<Movie, Movie, Movie>() {\n                     public Movie call(Movie t1, Movie t2) {\n                         return t2;\n                     }\n                 };\n \n-        Observable<Movie> reduceResult = Observable.create(OperationScan.scan(obs, chooseSecondMovie)).takeLast(1);\n-\n-        //TODO this isn't compiling\n-        //        Observable<Movie> reduceResult2 = obs.reduce(chooseSecondMovie);\n-        // do something with reduceResult...\n+        obs.reduce(chooseSecondMovie);\n     }\n \n }",
    "output": "Remove covariance of scan/reduce since consumer/producer are the same <T, T, T>\n\nSee https://github.com/Netflix/RxJava/issues/360#issuecomment-24203016"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -2308,12 +2308,12 @@ public Observable<T> first(Func1<? super T, Boolean> predicate) {\n      *            The default value to emit if the source Observable doesn't emit anything.\n      * @return an Observable that emits only the very first item from the source, or a default value \n      *         if the source Observable completes without emitting a single item.\n-     * @see <a href=\"\">MSDN: Observable.FirstOrDefault</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229320%28v=vs.103%29.aspx\">MSDN: Observable.FirstOrDefault</a>\n      */\n     public Observable<T> firstOrDefault(T defaultValue) {\n         return create(OperationFirstOrDefault.firstOrDefault(this, defaultValue));\n     }\n-    \n+\n     /**\n      * Returns an Observable that emits only the very first item emitted by the source Observable\n      * that satisfies a given condition, or a default value otherwise.\n@@ -2324,12 +2324,12 @@ public Observable<T> firstOrDefault(T defaultValue) {\n      *            satisfies the given condition.\n      * @return an Observable that emits only the very first item from the source that satisfies the\n      *         given condition, or a default value otherwise.\n-     * @see <a href=\"\">MSDN: Observable.FirstOrDefault</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229759%28v=vs.103%29.aspx\">MSDN: Observable.FirstOrDefault</a>\n      */\n     public Observable<T> firstOrDefault(Func1<? super T, Boolean> predicate, T defaultValue) {\n         return create(OperationFirstOrDefault.firstOrDefault(this, predicate, defaultValue));\n     }\n-    \n+\n     /**\n      * Returns an Observable that emits items emitted by the source Observable so long as a\n      * specified condition is true.",
    "output": "Add link urls to the msdn descriptions"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -15,6 +15,8 @@\n  */\n package rx;\n \n+import static rx.util.functions.Functions.not;\n+\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -2275,6 +2277,26 @@ public Observable<T> take(final int num) {\n         return create(OperationTake.take(this, num));\n     }\n \n+    /**\n+     * Returns an Observable that emits only the very first item emitted by the source Observable.\n+     * @return an Observable that emits only the very first item from the source, or none if the\n+     *         source Observable completes without emitting a single item.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229177%28v=vs.103%29.aspx\">MSDN: Observable.First</a>\n+     */\n+    public Observable<T> first() {\n+        return take(1);\n+    }\n+    \n+    /**\n+     * Returns an Observable that emits only the very first item emitted by the source Observable.\n+     * @return an Observable that emits only the very first item from the source, or none if the\n+     *         source Observable completes without emitting a single item.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229177%28v=vs.103%29.aspx\">MSDN: Observable.First</a>\n+     */\n+    public Observable<T> first(Func1<? super T, Boolean> predicate) {\n+        return skipWhile(not(predicate)).take(1);\n+    }\n+    \n     /**\n      * Returns an Observable that emits items emitted by the source Observable so long as a\n      * specified condition is true.\n\ndiff --git a/rxjava-core/src/main/java/rx/util/functions/Functions.java b/rxjava-core/src/main/java/rx/util/functions/Functions.java\n--- a/rxjava-core/src/main/java/rx/util/functions/Functions.java\n+++ b/rxjava-core/src/main/java/rx/util/functions/Functions.java\n@@ -313,6 +313,16 @@ public Void call(Object... args) {\n         };\n     }\n \n+    /**\n+     * Constructs a predicate that returns true for each input that the source\n+     * predicate returns false for and vice versa.\n+     * \n+     * @param predicate The source predicate to negate.\n+     */\n+    public static <T> Func1<T, Boolean> not(Func1<? super T, Boolean> predicate) {\n+        return new Not<T>(predicate);\n+    }\n+\n     public static <T> Func1<? super T, Boolean> alwaysTrue() {\n         return AlwaysTrue.INSTANCE;\n     }\n@@ -334,4 +344,5 @@ public Boolean call(Object o) {\n             return true;\n         }\n     }\n+    \n }\n\ndiff --git a/rxjava-core/src/main/java/rx/util/functions/Not.java b/rxjava-core/src/main/java/rx/util/functions/Not.java\n--- a/rxjava-core/src/main/java/rx/util/functions/Not.java\n+++ b/rxjava-core/src/main/java/rx/util/functions/Not.java\n@@ -0,0 +1,40 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.util.functions;\n+\n+/**\n+ * Implements the negation of a predicate. \n+ * \n+ * @param <T> The type of the single input parameter.\n+ */\n+public class Not<T> implements Func1<T, Boolean> {\n+    private final Func1<? super T, Boolean> predicate;\n+ \n+    /**\n+     * Constructs a predicate that returns true for each input that the source\n+     * predicate returns false for and vice versa.\n+     * \n+     * @param predicate The source predicate to negate.\n+     */\n+    public Not(Func1<? super T, Boolean> predicate) {\n+        this.predicate = predicate;\n+    }\n+    \n+    @Override\n+    public Boolean call(T param) {\n+        return !predicate.call(param);\n+    }\n+}\n\ndiff --git a/rxjava-core/src/test/java/rx/ObservableTests.java b/rxjava-core/src/test/java/rx/ObservableTests.java\n--- a/rxjava-core/src/test/java/rx/ObservableTests.java\n+++ b/rxjava-core/src/test/java/rx/ObservableTests.java\n@@ -35,13 +35,21 @@\n import rx.subscriptions.BooleanSubscription;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action1;\n+import rx.util.functions.Func1;\n import rx.util.functions.Func2;\n \n public class ObservableTests {\n \n     @Mock\n     Observer<Integer> w;\n \n+    private static final Func1<Integer, Boolean> IS_EVEN = new Func1<Integer, Boolean>() {\n+        @Override\n+        public Boolean call(Integer value) {\n+            return value % 2 == 0;\n+        }\n+    };\n+    \n     @Before\n     public void before() {\n         MockitoAnnotations.initMocks(this);\n@@ -73,6 +81,44 @@ public Subscription onSubscribe(Observer<? super String> Observer) {\n         verify(aObserver, times(1)).onCompleted();\n     }\n \n+    @Test\n+    public void testFirstWithPredicateOfSome() {\n+        Observable<Integer> observable = Observable.from(1, 3, 5, 4, 6, 3);\n+        observable.first(IS_EVEN).subscribe(w);\n+        verify(w, times(1)).onNext(anyInt());\n+        verify(w).onNext(4);\n+        verify(w, times(1)).onCompleted();\n+        verify(w, never()).onError(any(Throwable.class));\n+    }\n+    \n+    @Test\n+    public void testFirstWithPredicateOfNoneMatchingThePredicate() {\n+        Observable<Integer> observable = Observable.from(1, 3, 5, 7, 9, 7, 5, 3, 1);\n+        observable.first(IS_EVEN).subscribe(w);\n+        verify(w, never()).onNext(anyInt());\n+        verify(w, times(1)).onCompleted();\n+        verify(w, never()).onError(any(Throwable.class));\n+    }\n+    \n+    @Test\n+    public void testFirstOfSome() {\n+        Observable<Integer> observable = Observable.from(1, 2, 3);\n+        observable.first().subscribe(w);\n+        verify(w, times(1)).onNext(anyInt());\n+        verify(w).onNext(1);\n+        verify(w, times(1)).onCompleted();\n+        verify(w, never()).onError(any(Throwable.class));\n+    }\n+    \n+    @Test\n+    public void testFirstOfNone() {\n+        Observable<Integer> observable = Observable.empty();\n+        observable.first().subscribe(w);\n+        verify(w, never()).onNext(anyInt());\n+        verify(w, times(1)).onCompleted();\n+        verify(w, never()).onError(any(Throwable.class));\n+    }\n+    \n     @Test\n     public void testReduce() {\n         Observable<Integer> observable = Observable.from(1, 2, 3, 4);",
    "output": "Add the two variants of the first operator"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -19,7 +19,6 @@\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n \n@@ -67,7 +66,6 @@\n import rx.operators.OperationZip;\n import rx.operators.SafeObservableSubscription;\n import rx.operators.SafeObserver;\n-import rx.operators.OperationInterval.Interval;\n import rx.plugins.RxJavaErrorHandler;\n import rx.plugins.RxJavaObservableExecutionHook;\n import rx.plugins.RxJavaPlugins;",
    "output": "Remove unused imports"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -19,6 +19,7 @@\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n \n@@ -36,6 +37,7 @@\n import rx.operators.OperationFilter;\n import rx.operators.OperationFinally;\n import rx.operators.OperationGroupBy;\n+import rx.operators.OperationInterval;\n import rx.operators.OperationMap;\n import rx.operators.OperationMaterialize;\n import rx.operators.OperationMerge;\n@@ -65,6 +67,7 @@\n import rx.operators.OperationZip;\n import rx.operators.SafeObservableSubscription;\n import rx.operators.SafeObserver;\n+import rx.operators.OperationInterval.Interval;\n import rx.plugins.RxJavaErrorHandler;\n import rx.plugins.RxJavaObservableExecutionHook;\n import rx.plugins.RxJavaPlugins;\n@@ -827,6 +830,35 @@ public static <T> Observable<T> synchronize(Observable<? extends T> observable)\n         return create(OperationSynchronize.synchronize(observable));\n     }\n \n+    \n+    /**\n+     * Emits an item each time interval (containing a sequential number).\n+     * @param interval\n+     *            Interval size in time units (see below).\n+     * @param unit\n+     *            Time units to use for the interval size.\n+     * @return An Observable that emits an item each time interval.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229027%28v=vs.103%29.aspx\">MSDN: Observable.Interval</a>\n+     */\n+    public static Observable<Long> interval(long interval, TimeUnit unit) {\n+        return create(OperationInterval.interval(interval, unit));\n+    }\n+    \n+    /**\n+     * Emits an item each time interval (containing a sequential number).\n+     * @param interval\n+     *            Interval size in time units (see below).\n+     * @param unit\n+     *            Time units to use for the interval size.\n+     * @param scheduler\n+     *            The scheduler to use for scheduling the items.\n+     * @return An Observable that emits an item each time interval.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh228911%28v=vs.103%29.aspx\">MSDN: Observable.Interval</a>\n+     */\n+    public static Observable<Long> interval(long interval, TimeUnit unit, Scheduler scheduler) {\n+        return create(OperationInterval.interval(interval, unit, scheduler));\n+    }\n+    \n     /**\n      * Wraps each item emitted by a source Observable in a {@link Timestamped} object.\n      * <p>",
    "output": "Add interval methods to Observable, where they were still missing"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationSum.java b/rxjava-core/src/main/java/rx/operators/OperationSum.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationSum.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationSum.java\n@@ -95,6 +95,28 @@ public void testEmptySum() throws Throwable {\n             verify(w, times(1)).onCompleted();\n         }\n \n+        @Test\n+        public void testSumOfAFewLongs() throws Throwable {\n+            Observable<Long> src = Observable.from(1L, 2L, 3L, 4L, 5L);\n+            sumLongs(src).subscribe(wl);\n+\n+            verify(wl, times(1)).onNext(anyLong());\n+            verify(wl).onNext(15L);\n+            verify(wl, never()).onError(any(Throwable.class));\n+            verify(wl, times(1)).onCompleted();\n+        }\n+\n+        @Test\n+        public void testEmptySumLongs() throws Throwable {\n+            Observable<Long> src = Observable.from();\n+            sumLongs(src).subscribe(wl);\n+\n+            verify(wl, times(1)).onNext(anyLong());\n+            verify(wl).onNext(0L);\n+            verify(wl, never()).onError(any(Throwable.class));\n+            verify(wl, times(1)).onCompleted();\n+        }\n+\n         @Test\n         public void testSumOfAFewFloats() throws Throwable {\n             Observable<Float> src = Observable.from(1.0f);",
    "output": "Add test against long sum, too"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -50,6 +50,7 @@\n import rx.operators.OperationScan;\n import rx.operators.OperationSkip;\n import rx.operators.OperationSubscribeOn;\n+import rx.operators.OperationSum;\n import rx.operators.OperationSwitch;\n import rx.operators.OperationSynchronize;\n import rx.operators.OperationTake;\n@@ -2058,6 +2059,42 @@ public Integer call(Integer t1, T t2) {\n         });\n     }\n     \n+    /**\n+     * Returns an Observable that sums up the elements in the source Observable.\n+     * @param source\n+     *            Source observable to compute the sum of.      \n+     * @return an Observable emitting the sum of all the elements of the source Observable \n+     *         as its single item.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.sum%28v=vs.103%29.aspx\">MSDN: Observable.Sum</a>\n+     */\n+    public static Observable<Integer> sum(Observable<Integer> source) {\n+        return OperationSum.sum(source);\n+    }\n+    \n+    /**\n+     * @see #sum(Observable)\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.sum%28v=vs.103%29.aspx\">MSDN: Observable.Sum</a>\n+     */\n+    public static Observable<Long> sumLongs(Observable<Long> source) {\n+        return OperationSum.sumLongs(source);\n+    }\n+    \n+    /**\n+     * @see #sum(Observable)\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.sum%28v=vs.103%29.aspx\">MSDN: Observable.Sum</a>\n+     */\n+    public static Observable<Float> sumFloats(Observable<Float> source) {\n+        return OperationSum.sumFloats(source);\n+    }\n+    \n+    /**\n+     * @see #sum(Observable)\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.sum%28v=vs.103%29.aspx\">MSDN: Observable.Sum</a>\n+     */\n+    public static Observable<Double> sumDoubles(Observable<Double> source) {\n+        return OperationSum.sumDoubles(source);\n+    }\n+    \n     /**\n      * Returns a {@link ConnectableObservable} that shares a single subscription to the underlying\n      * Observable that will replay all of its items and notifications to any future {@link Observer}.\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationSum.java b/rxjava-core/src/main/java/rx/operators/OperationSum.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationSum.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationSum.java\n@@ -0,0 +1,142 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.operators;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+\n+import rx.Observable;\n+import rx.Observer;\n+import rx.util.functions.Func2;\n+\n+/**\n+ * A few operators for implementing the sum operation.\n+ */\n+public final class OperationSum {\n+    public static Observable<Integer> sum(Observable<Integer> source) {\n+        return source.reduce(0, new Func2<Integer, Integer, Integer>() {\n+            @Override\n+            public Integer call(Integer accu, Integer next) {\n+                return accu + next;\n+            }\n+        });\n+    }\n+\n+    public static Observable<Long> sumLongs(Observable<Long> source) {\n+        return source.reduce(0L, new Func2<Long, Long, Long>() {\n+            @Override\n+            public Long call(Long accu, Long next) {\n+                return accu + next;\n+            }\n+        });\n+    }\n+\n+    public static Observable<Float> sumFloats(Observable<Float> source) {\n+        return source.reduce(0.0f, new Func2<Float, Float, Float>() {\n+            @Override\n+            public Float call(Float accu, Float next) {\n+                return accu + next;\n+            }\n+        });\n+    }\n+\n+    public static Observable<Double> sumDoubles(Observable<Double> source) {\n+        return source.reduce(0.0d, new Func2<Double, Double, Double>() {\n+            @Override\n+            public Double call(Double accu, Double next) {\n+                return accu + next;\n+            }\n+        });\n+    }\n+\n+    public static class UnitTest {\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Integer> w = mock(Observer.class);\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Long> wl = mock(Observer.class);\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Float> wf = mock(Observer.class);\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Double> wd = mock(Observer.class);\n+\n+        @Test\n+        public void testSumOfAFewInts() throws Throwable {\n+            Observable<Integer> src = Observable.from(1, 2, 3, 4, 5);\n+            sum(src).subscribe(w);\n+\n+            verify(w, times(1)).onNext(anyInt());\n+            verify(w).onNext(15);\n+            verify(w, never()).onError(any(Throwable.class));\n+            verify(w, times(1)).onCompleted();\n+        }\n+\n+        @Test\n+        public void testEmptySum() throws Throwable {\n+            Observable<Integer> src = Observable.from();\n+            sum(src).subscribe(w);\n+\n+            verify(w, times(1)).onNext(anyInt());\n+            verify(w).onNext(0);\n+            verify(w, never()).onError(any(Throwable.class));\n+            verify(w, times(1)).onCompleted();\n+        }\n+\n+        @Test\n+        public void testSumOfAFewFloats() throws Throwable {\n+            Observable<Float> src = Observable.from(1.0f);\n+            sumFloats(src).subscribe(wf);\n+\n+            verify(wf, times(1)).onNext(anyFloat());\n+            verify(wf).onNext(1.0f);\n+            verify(wf, never()).onError(any(Throwable.class));\n+            verify(wf, times(1)).onCompleted();\n+        }\n+\n+        @Test\n+        public void testEmptySumFloats() throws Throwable {\n+            Observable<Float> src = Observable.from();\n+            sumFloats(src).subscribe(wf);\n+\n+            verify(wf, times(1)).onNext(anyFloat());\n+            verify(wf).onNext(0.0f);\n+            verify(wf, never()).onError(any(Throwable.class));\n+            verify(wf, times(1)).onCompleted();\n+        }\n+\n+        @Test\n+        public void testSumOfAFewDoubles() throws Throwable {\n+            Observable<Double> src = Observable.from(0.0d, 1.0d, 0.5d);\n+            sumDoubles(src).subscribe(wd);\n+\n+            verify(wd, times(1)).onNext(anyDouble());\n+            verify(wd).onNext(1.5d);\n+            verify(wd, never()).onError(any(Throwable.class));\n+            verify(wd, times(1)).onCompleted();\n+        }\n+\n+        @Test\n+        public void testEmptySumDoubles() throws Throwable {\n+            Observable<Double> src = Observable.from();\n+            sumDoubles(src).subscribe(wd);\n+\n+            verify(wd, times(1)).onNext(anyDouble());\n+            verify(wd).onNext(0.0d);\n+            verify(wd, never()).onError(any(Throwable.class));\n+            verify(wd, times(1)).onCompleted();\n+        }\n+    }\n+}",
    "output": "Add sum operations"
  },
  {
    "input": "diff --git a/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java\n--- a/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java\n+++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java\n@@ -21,6 +21,12 @@\n import rx.util.functions.Func2;\n import rx.util.functions.Func3;\n import rx.util.functions.Func4;\n+import rx.util.functions.Func5;\n+import rx.util.functions.Func6;\n+import rx.util.functions.Func7;\n+import rx.util.functions.Func8;\n+import rx.util.functions.Func9;\n+import rx.util.functions.FuncN;\n import rx.util.functions.Function;\n \n /**\n@@ -32,11 +38,21 @@\n  * @param <T4>\n  * @param <R>\n  */\n-public class GroovyFunctionWrapper<T1, T2, T3, T4, R> implements Func0<R>, Func1<T1, R>, Func2<T1, T2, R>, Func3<T1, T2, T3, R>, Func4<T1, T2, T3, T4, R> {\n+public class GroovyFunctionWrapper<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> implements\n+        Func0<R>,\n+        Func1<T1, R>,\n+        Func2<T1, T2, R>,\n+        Func3<T1, T2, T3, R>,\n+        Func4<T1, T2, T3, T4, R>,\n+        Func5<T1, T2, T3, T4, T5, R>,\n+        Func6<T1, T2, T3, T4, T5, T6, R>,\n+        Func7<T1, T2, T3, T4, T5, T6, T7, R>,\n+        Func8<T1, T2, T3, T4, T5, T6, T7, T8, R>,\n+        Func9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>,\n+        FuncN<R> {\n \n     private final Closure<R> closure;\n \n-    \n     public GroovyFunctionWrapper(Closure<R> closure) {\n         this.closure = closure;\n     }\n@@ -65,4 +81,34 @@ public R call(T1 t1, T2 t2, T3 t3) {\n     public R call(T1 t1, T2 t2, T3 t3, T4 t4) {\n         return (R) closure.call(t1, t2, t3, t4);\n     }\n+\n+    @Override\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) {\n+        return (R) closure.call(t1, t2, t3, t4, t5);\n+    }\n+\n+    @Override\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) {\n+        return (R) closure.call(t1, t2, t3, t4, t5, t6);\n+    }\n+\n+    @Override\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) {\n+        return (R) closure.call(t1, t2, t3, t4, t5, t6, t7);\n+    }\n+\n+    @Override\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) {\n+        return (R) closure.call(t1, t2, t3, t4, t5, t6, t7, t8);\n+    }\n+\n+    @Override\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) {\n+        return (R) closure.call(t1, t2, t3, t4, t5, t6, t7, t8, t9);\n+    }\n+\n+    @Override\n+    public R call(Object... args) {\n+        return (R) closure.call(args);\n+    }\n }\n\\ No newline at end of file",
    "output": "Add Func5-9 and N to the wrapper"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationMostRecent.java b/rxjava-core/src/main/java/rx/operators/OperationMostRecent.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationMostRecent.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationMostRecent.java\n@@ -16,7 +16,6 @@\n package rx.operators;\n \n import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n \n import java.util.Iterator;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -26,7 +25,6 @@\n \n import rx.Observable;\n import rx.Observer;\n-import rx.Subscription;\n import rx.subjects.PublishSubject;\n import rx.subjects.Subject;\n import rx.util.Exceptions;\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationNext.java b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationNext.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n@@ -16,7 +16,6 @@\n package rx.operators;\n \n import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n \n import java.util.Iterator;\n import java.util.concurrent.ArrayBlockingQueue;\n\ndiff --git a/rxjava-core/src/test/java/rx/ObservableTests.java b/rxjava-core/src/test/java/rx/ObservableTests.java\n--- a/rxjava-core/src/test/java/rx/ObservableTests.java\n+++ b/rxjava-core/src/test/java/rx/ObservableTests.java\n@@ -35,7 +35,6 @@\n import rx.subscriptions.BooleanSubscription;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action1;\n-import rx.util.functions.Func1;\n import rx.util.functions.Func2;\n \n public class ObservableTests {",
    "output": "Remove a few unused imports"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java b/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java\n--- a/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java\n+++ b/rxjava-core/src/main/java/rx/operators/ChunkedOperation.java\n@@ -105,7 +105,7 @@ protected static class NonOverlappingChunks<T, C> extends Chunks<T, C> {\n \n         private final Object lock = new Object();\n \n-        public NonOverlappingChunks(Observer<? super C> observer, Func0 chunkMaker) {\n+        public NonOverlappingChunks(Observer<? super C> observer, Func0<? extends Chunk<T, C>> chunkMaker) {\n             super(observer, chunkMaker);\n         }\n \n@@ -134,7 +134,7 @@ public void pushValue(T value) {\n      *            <C> The type of object being tracked by the {@link rx.operators.ChunkedOperation.Chunk}\n      */\n     protected static class OverlappingChunks<T, C> extends Chunks<T, C> {\n-        public OverlappingChunks(Observer<? super C> observer, Func0 chunkMaker) {\n+        public OverlappingChunks(Observer<? super C> observer, Func0<? extends Chunk<T, C>> chunkMaker) {\n             super(observer, chunkMaker);\n         }\n     }\n@@ -158,7 +158,7 @@ protected static class TimeAndSizeBasedChunks<T, C> extends Chunks<T, C> {\n         private final TimeUnit unit;\n         private final int maxSize;\n \n-        public TimeAndSizeBasedChunks(Observer<? super C> observer, Func0 chunkMaker, int maxSize, long maxTime, TimeUnit unit, Scheduler scheduler) {\n+        public TimeAndSizeBasedChunks(Observer<? super C> observer, Func0<? extends Chunk<T, C>> chunkMaker, int maxSize, long maxTime, TimeUnit unit, Scheduler scheduler) {\n             super(observer, chunkMaker);\n             this.maxSize = maxSize;\n             this.maxTime = maxTime;\n@@ -224,7 +224,7 @@ protected static class TimeBasedChunks<T, C> extends OverlappingChunks<T, C> {\n         private final long time;\n         private final TimeUnit unit;\n \n-        public TimeBasedChunks(Observer<? super C> observer, Func0 chunkMaker, long time, TimeUnit unit, Scheduler scheduler) {\n+        public TimeBasedChunks(Observer<? super C> observer, Func0<? extends Chunk<T, C>> chunkMaker, long time, TimeUnit unit, Scheduler scheduler) {\n             super(observer, chunkMaker);\n             this.time = time;\n             this.unit = unit;\n@@ -263,7 +263,7 @@ protected static class SizeBasedChunks<T, C> extends Chunks<T, C> {\n \n         private final int size;\n \n-        public SizeBasedChunks(Observer<? super C> observer, Func0 chunkMaker, int size) {\n+        public SizeBasedChunks(Observer<? super C> observer, Func0<? extends Chunk<T, C>> chunkMaker, int size) {\n             super(observer, chunkMaker);\n             this.size = size;\n         }\n@@ -295,15 +295,15 @@ protected static class Chunks<T, C> {\n \n         private final Queue<Chunk<T, C>> chunks = new ConcurrentLinkedQueue<Chunk<T, C>>();\n         private final Observer<? super C> observer;\n-        private final Func0<Chunk<T, C>> chunkMaker;\n+        private final Func0<? extends Chunk<T, C>> chunkMaker;\n \n         /**\n          * Constructs a new {@link ChunkedOperation.Chunks} object for the specified {@link rx.Observer}.\n          * \n          * @param observer\n          *            The {@link rx.Observer} to which this object will emit its internal {@link rx.operators.ChunkedOperation.Chunk} objects to when requested.\n          */\n-        public Chunks(Observer<? super C> observer, Func0 chunkMaker) {\n+        public Chunks(Observer<? super C> observer, Func0<? extends Chunk<T, C>> chunkMaker) {\n             this.observer = observer;\n             this.chunkMaker = chunkMaker;\n         }\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationWindow.java b/rxjava-core/src/main/java/rx/operators/OperationWindow.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationWindow.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationWindow.java\n@@ -76,7 +76,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                NonOverlappingChunks<T, Observable<T>> windows = new NonOverlappingChunks<T, Observable<T>>(observer, windowMaker());\n+                NonOverlappingChunks<T, Observable<T>> windows = new NonOverlappingChunks<T, Observable<T>>(observer, OperationWindow.<T>windowMaker());\n                 ChunkCreator creator = new ObservableBasedSingleChunkCreator<T, Observable<T>>(windows, windowClosingSelector);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(windows, observer, creator));\n             }\n@@ -113,7 +113,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                OverlappingChunks<T, Observable<T>> windows = new OverlappingChunks<T, Observable<T>>(observer, windowMaker());\n+                OverlappingChunks<T, Observable<T>> windows = new OverlappingChunks<T, Observable<T>>(observer, OperationWindow.<T>windowMaker());\n                 ChunkCreator creator = new ObservableBasedMultiChunkCreator<T, Observable<T>>(windows, windowOpenings, windowClosingSelector);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(windows, observer, creator));\n             }\n@@ -168,7 +168,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                Chunks<T, Observable<T>> chunks = new SizeBasedChunks<T, Observable<T>>(observer, windowMaker(), count);\n+                Chunks<T, Observable<T>> chunks = new SizeBasedChunks<T, Observable<T>>(observer, OperationWindow.<T>windowMaker(), count);\n                 ChunkCreator creator = new SkippingChunkCreator<T, Observable<T>>(chunks, skip);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(chunks, observer, creator));\n             }\n@@ -223,7 +223,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                NonOverlappingChunks<T, Observable<T>> windows = new NonOverlappingChunks<T, Observable<T>>(observer, windowMaker());\n+                NonOverlappingChunks<T, Observable<T>> windows = new NonOverlappingChunks<T, Observable<T>>(observer, OperationWindow.<T>windowMaker());\n                 ChunkCreator creator = new TimeBasedChunkCreator<T, Observable<T>>(windows, timespan, unit, scheduler);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(windows, observer, creator));\n             }\n@@ -284,7 +284,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                Chunks<T, Observable<T>> chunks = new TimeAndSizeBasedChunks<T, Observable<T>>(observer, windowMaker(), count, timespan, unit, scheduler);\n+                Chunks<T, Observable<T>> chunks = new TimeAndSizeBasedChunks<T, Observable<T>>(observer, OperationWindow.<T>windowMaker(), count, timespan, unit, scheduler);\n                 ChunkCreator creator = new SingleChunkCreator<T, Observable<T>>(chunks);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(chunks, observer, creator));\n             }\n@@ -345,7 +345,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                OverlappingChunks<T, Observable<T>> windows = new TimeBasedChunks<T, Observable<T>>(observer, windowMaker(), timespan, unit, scheduler);\n+                OverlappingChunks<T, Observable<T>> windows = new TimeBasedChunks<T, Observable<T>>(observer, OperationWindow.<T>windowMaker(), timespan, unit, scheduler);\n                 ChunkCreator creator = new TimeBasedChunkCreator<T, Observable<T>>(windows, timeshift, unit, scheduler);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(windows, observer, creator));\n             }",
    "output": "Remove raw Func0s from the chunks"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationWindow.java b/rxjava-core/src/main/java/rx/operators/OperationWindow.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationWindow.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationWindow.java\n@@ -43,12 +43,14 @@\n \n public final class OperationWindow extends ChunkedOperation {\n \n-    public static final Func0 WINDOW_MAKER = new Func0() {\n-        @Override\n-        public Object call() {\n-            return new Window();\n-        }\n-    };\n+    public static <T> Func0<Window<T>> windowMaker() {\n+        return new Func0<Window<T>>() {\n+            @Override\n+            public Window<T> call() {\n+                return new Window<T>();\n+            }\n+        };\n+     }\n \n     /**\n      * <p>This method creates a {@link rx.util.functions.Func1} object which represents the window operation. This operation takes\n@@ -74,7 +76,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                NonOverlappingChunks<T, Observable<T>> windows = new NonOverlappingChunks<T, Observable<T>>(observer, WINDOW_MAKER);\n+                NonOverlappingChunks<T, Observable<T>> windows = new NonOverlappingChunks<T, Observable<T>>(observer, windowMaker());\n                 ChunkCreator creator = new ObservableBasedSingleChunkCreator<T, Observable<T>>(windows, windowClosingSelector);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(windows, observer, creator));\n             }\n@@ -111,7 +113,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                OverlappingChunks<T, Observable<T>> windows = new OverlappingChunks<T, Observable<T>>(observer, WINDOW_MAKER);\n+                OverlappingChunks<T, Observable<T>> windows = new OverlappingChunks<T, Observable<T>>(observer, windowMaker());\n                 ChunkCreator creator = new ObservableBasedMultiChunkCreator<T, Observable<T>>(windows, windowOpenings, windowClosingSelector);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(windows, observer, creator));\n             }\n@@ -166,7 +168,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                Chunks<T, Observable<T>> chunks = new SizeBasedChunks<T, Observable<T>>(observer, WINDOW_MAKER, count);\n+                Chunks<T, Observable<T>> chunks = new SizeBasedChunks<T, Observable<T>>(observer, windowMaker(), count);\n                 ChunkCreator creator = new SkippingChunkCreator<T, Observable<T>>(chunks, skip);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(chunks, observer, creator));\n             }\n@@ -221,7 +223,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                NonOverlappingChunks<T, Observable<T>> windows = new NonOverlappingChunks<T, Observable<T>>(observer, WINDOW_MAKER);\n+                NonOverlappingChunks<T, Observable<T>> windows = new NonOverlappingChunks<T, Observable<T>>(observer, windowMaker());\n                 ChunkCreator creator = new TimeBasedChunkCreator<T, Observable<T>>(windows, timespan, unit, scheduler);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(windows, observer, creator));\n             }\n@@ -282,7 +284,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                Chunks<T, Observable<T>> chunks = new TimeAndSizeBasedChunks<T, Observable<T>>(observer, WINDOW_MAKER, count, timespan, unit, scheduler);\n+                Chunks<T, Observable<T>> chunks = new TimeAndSizeBasedChunks<T, Observable<T>>(observer, windowMaker(), count, timespan, unit, scheduler);\n                 ChunkCreator creator = new SingleChunkCreator<T, Observable<T>>(chunks);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(chunks, observer, creator));\n             }\n@@ -343,7 +345,7 @@ public static <T> OnSubscribeFunc<Observable<T>> window(final Observable<T> sour\n         return new OnSubscribeFunc<Observable<T>>() {\n             @Override\n             public Subscription onSubscribe(final Observer<? super Observable<T>> observer) {\n-                OverlappingChunks<T, Observable<T>> windows = new TimeBasedChunks<T, Observable<T>>(observer, WINDOW_MAKER, timespan, unit, scheduler);\n+                OverlappingChunks<T, Observable<T>> windows = new TimeBasedChunks<T, Observable<T>>(observer, windowMaker(), timespan, unit, scheduler);\n                 ChunkCreator creator = new TimeBasedChunkCreator<T, Observable<T>>(windows, timeshift, unit, scheduler);\n                 return source.subscribe(new ChunkObserver<T, Observable<T>>(windows, observer, creator));\n             }\n@@ -373,7 +375,6 @@ public static class UnitTest {\n         private TestScheduler scheduler;\n \n         @Before\n-        @SuppressWarnings(\"unchecked\")\n         public void before() {\n             scheduler = new TestScheduler();\n         }",
    "output": "Make WINDOW_MAKER typed"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -287,7 +287,7 @@ public Subscription subscribe(final Action1<? super T> onNext, Scheduler schedul\n         return subscribeOn(scheduler).subscribe(onNext);\n     }\n \n-    public Subscription subscribe(final Action1<? super T> onNext, final Action1<? super Throwable> onError) {\n+    public Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError) {\n         if (onNext == null) {\n             throw new IllegalArgumentException(\"onNext can not be null\");\n         }\n@@ -321,11 +321,11 @@ public void onNext(T args) {\n         });\n     }\n \n-    public Subscription subscribe(final Action1<? super T> onNext, final Action1<? super Throwable> onError, Scheduler scheduler) {\n+    public Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, Scheduler scheduler) {\n         return subscribeOn(scheduler).subscribe(onNext, onError);\n     }\n \n-    public Subscription subscribe(final Action1<? super T> onNext, final Action1<? super Throwable> onError, final Action0 onComplete) {\n+    public Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onComplete) {\n         if (onNext == null) {\n             throw new IllegalArgumentException(\"onNext can not be null\");\n         }\n@@ -362,7 +362,7 @@ public void onNext(T args) {\n         });\n     }\n \n-    public Subscription subscribe(final Action1<? super T> onNext, final Action1<? super Throwable> onError, final Action0 onComplete, Scheduler scheduler) {\n+    public Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onComplete, Scheduler scheduler) {\n         return subscribeOn(scheduler).subscribe(onNext, onError, onComplete);\n     }\n \n@@ -1730,7 +1730,7 @@ public <T2> Observable<T2> dematerialize() {\n      *            encounters an error\n      * @return the original Observable, with appropriately modified behavior\n      */\n-    public Observable<T> onErrorResumeNext(final Func1<? super Throwable, ? extends Observable<? extends T>> resumeFunction) {\n+    public Observable<T> onErrorResumeNext(final Func1<Throwable, ? extends Observable<? extends T>> resumeFunction) {\n         return create(OperationOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(this, resumeFunction));\n     }\n \n@@ -1815,7 +1815,7 @@ public Observable<T> onExceptionResumeNext(final Observable<? extends T> resumeS\n      *            Observable encounters an error\n      * @return the original Observable with appropriately modified behavior\n      */\n-    public Observable<T> onErrorReturn(Func1<? super Throwable, ? extends T> resumeFunction) {\n+    public Observable<T> onErrorReturn(Func1<Throwable, ? extends T> resumeFunction) {\n         return create(OperationOnErrorReturn.onErrorReturn(this, resumeFunction));\n     }\n \n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationGroupBy.java b/rxjava-core/src/main/java/rx/operators/OperationGroupBy.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationGroupBy.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationGroupBy.java\n@@ -418,7 +418,7 @@ public String call(Event event) {\n                         }\n                     });\n \n-                };\n+                }\n             }).subscribe(new Observer<String>() {\n \n                 @Override\n@@ -515,7 +515,7 @@ public String call(Event event) {\n                                         }\n                                     });\n \n-                        };\n+                        }\n                     }).subscribe(new Observer<String>() {\n \n                         @Override\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaFunction.java b/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaFunction.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaFunction.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaFunction.java\n@@ -53,16 +53,16 @@\n  */\n public final class OperationOnErrorResumeNextViaFunction<T> {\n \n-    public static <T> Func1<Observer<? super T>, Subscription> onErrorResumeNextViaFunction(Observable<? extends T> originalSequence, Func1<? super Throwable, ? extends Observable<? extends T>> resumeFunction) {\n+    public static <T> Func1<Observer<? super T>, Subscription> onErrorResumeNextViaFunction(Observable<? extends T> originalSequence, Func1<Throwable, ? extends Observable<? extends T>> resumeFunction) {\n         return new OnErrorResumeNextViaFunction<T>(originalSequence, resumeFunction);\n     }\n \n     private static class OnErrorResumeNextViaFunction<T> implements Func1<Observer<? super T>, Subscription> {\n \n-        private final Func1<? super Throwable, ? extends Observable<? extends T>> resumeFunction;\n+        private final Func1<Throwable, ? extends Observable<? extends T>> resumeFunction;\n         private final Observable<? extends T> originalSequence;\n \n-        public OnErrorResumeNextViaFunction(Observable<? extends T> originalSequence, Func1<? super Throwable, ? extends Observable<? extends T>> resumeFunction) {\n+        public OnErrorResumeNextViaFunction(Observable<? extends T> originalSequence, Func1<Throwable, ? extends Observable<? extends T>> resumeFunction) {\n             this.resumeFunction = resumeFunction;\n             this.originalSequence = originalSequence;\n         }\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationOnErrorReturn.java b/rxjava-core/src/main/java/rx/operators/OperationOnErrorReturn.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationOnErrorReturn.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationOnErrorReturn.java\n@@ -50,15 +50,15 @@\n  */\n public final class OperationOnErrorReturn<T> {\n \n-    public static <T> Func1<Observer<? super T>, Subscription> onErrorReturn(Observable<? extends T> originalSequence, Func1<? super Throwable, ? extends T> resumeFunction) {\n+    public static <T> Func1<Observer<? super T>, Subscription> onErrorReturn(Observable<? extends T> originalSequence, Func1<Throwable, ? extends T> resumeFunction) {\n         return new OnErrorReturn<T>(originalSequence, resumeFunction);\n     }\n \n     private static class OnErrorReturn<T> implements Func1<Observer<? super T>, Subscription> {\n-        private final Func1<? super Throwable, ? extends T> resumeFunction;\n+        private final Func1<Throwable, ? extends T> resumeFunction;\n         private final Observable<? extends T> originalSequence;\n \n-        public OnErrorReturn(Observable<? extends T> originalSequence, Func1<? super Throwable, ? extends T> resumeFunction) {\n+        public OnErrorReturn(Observable<? extends T> originalSequence, Func1<Throwable, ? extends T> resumeFunction) {\n             this.resumeFunction = resumeFunction;\n             this.originalSequence = originalSequence;\n         }",
    "output": "Remove some <? super Throwable>s because that's rather unnecessary"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -515,7 +515,7 @@ public static <T> Observable<T> error(Throwable exception) {\n      *            emitted by the resulting Observable\n      * @return an Observable that emits each item in the source {@link Iterable} sequence\n      */\n-    public static <T> Observable<T> from(Iterable<T> iterable) {\n+    public static <T> Observable<T> from(Iterable<? extends T> iterable) {\n         return create(OperationToObservableIterable.toObservableIterable(iterable));\n     }\n \n@@ -579,7 +579,7 @@ public static Observable<Integer> range(int start, int count) {\n      * @return an Observable whose {@link Observer}s trigger an invocation of the given Observable\n      *         factory function\n      */\n-    public static <T> Observable<T> defer(Func0<? extends Observable<T>> observableFactory) {\n+    public static <T> Observable<T> defer(Func0<? extends Observable<? extends T>> observableFactory) {\n         return create(OperationDefer.defer(observableFactory));\n     }\n \n\ndiff --git a/rxjava-core/src/test/java/rx/CovarianceTest.java b/rxjava-core/src/test/java/rx/CovarianceTest.java\n--- a/rxjava-core/src/test/java/rx/CovarianceTest.java\n+++ b/rxjava-core/src/test/java/rx/CovarianceTest.java\n@@ -1,5 +1,7 @@\n package rx;\n \n+import java.util.ArrayList;\n+\n import org.junit.Test;\n \n import rx.util.functions.Action1;\n@@ -12,6 +14,26 @@\n  */\n public class CovarianceTest {\n \n+    /**\n+     * This won't compile if super/extends isn't done correctly on generics\n+     */\n+    @Test\n+    public void testCovarianceOfFrom() {\n+        Observable.<Movie>from(new HorrorMovie());\n+        Observable.<Movie>from(new ArrayList<HorrorMovie>());\n+        // Observable.<HorrorMovie>from(new Movie()); // may not compile\n+    }\n+    \n+    /**\n+     * This won't compile if super/extends isn't done correctly on generics\n+     */\n+    @Test\n+    public void testCovarianceOfMerge() {\n+        Observable<HorrorMovie> horrors = Observable.from(new HorrorMovie());\n+        Observable<Observable<HorrorMovie>> metaHorrors = Observable.just(horrors);\n+        Observable.<Media>merge(metaHorrors);\n+    }\n+    \n     /**\n      * This won't compile if super/extends isn't done correctly on generics\n      */\n@@ -20,51 +42,53 @@ public void testCovarianceOfZip() {\n         Observable<HorrorMovie> horrors = Observable.from(new HorrorMovie());\n         Observable<CoolRating> ratings = Observable.from(new CoolRating());\n \n-        Func2<Media, Rating, ExtendedResult> combine = new Func2<Media, Rating, ExtendedResult>() {\n-            @Override\n-            public ExtendedResult call(Media m, Rating r) {\n-                return new ExtendedResult();\n-            }\n-        };\n-\n-        Observable.<Movie, CoolRating, Result> zip(horrors, ratings, combine).toBlockingObservable().forEach(new Action1<Result>() {\n-            @Override\n-            public void call(Result t1) {\n-                System.out.println(\"Result: \" + t1);\n-            }\n-        });\n-\n-        Observable.<Movie, CoolRating, Result> zip(horrors, ratings, combine).toBlockingObservable().forEach(new Action1<Result>() {\n-            @Override\n-            public void call(Result t1) {\n-                System.out.println(\"Result: \" + t1);\n-            }\n-        });\n-\n-        Observable.<Media, Rating, ExtendedResult> zip(horrors, ratings, combine).toBlockingObservable().forEach(new Action1<ExtendedResult>() {\n-            @Override\n-            public void call(ExtendedResult t1) {\n-                System.out.println(\"Result: \" + t1);\n-            }\n-        });\n-\n-        Observable.<Media, Rating, Result> zip(horrors, ratings, combine).toBlockingObservable().forEach(new Action1<Result>() {\n-            @Override\n-            public void call(Result t1) {\n-                System.out.println(\"Result: \" + t1);\n-            }\n-        });\n-\n-        Observable.<Media, Rating, ExtendedResult> zip(horrors, ratings, combine).toBlockingObservable().forEach(new Action1<Result>() {\n-            @Override\n-            public void call(Result t1) {\n-                System.out.println(\"Result: \" + t1);\n-            }\n-        });\n-\n+        Observable.<Movie, CoolRating, Result> zip(horrors, ratings, combine).toBlockingObservable().forEach(action);\n+        Observable.<Movie, CoolRating, Result> zip(horrors, ratings, combine).toBlockingObservable().forEach(action);\n+        Observable.<Media, Rating, ExtendedResult> zip(horrors, ratings, combine).toBlockingObservable().forEach(extendedAction);\n+        Observable.<Media, Rating, Result> zip(horrors, ratings, combine).toBlockingObservable().forEach(action);\n+        Observable.<Media, Rating, ExtendedResult> zip(horrors, ratings, combine).toBlockingObservable().forEach(action);\n+        \n         Observable.<Movie, CoolRating, Result> zip(horrors, ratings, combine);\n     }\n \n+    /**\n+     * This won't compile if super/extends isn't done correctly on generics\n+     */\n+    @Test\n+    public void testCovarianceOfCombineLatest() {\n+        Observable<HorrorMovie> horrors = Observable.from(new HorrorMovie());\n+        Observable<CoolRating> ratings = Observable.from(new CoolRating());\n+\n+        Observable.<Movie, CoolRating, Result> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);\n+        Observable.<Movie, CoolRating, Result> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);\n+        Observable.<Media, Rating, ExtendedResult> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(extendedAction);\n+        Observable.<Media, Rating, Result> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);\n+        Observable.<Media, Rating, ExtendedResult> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);\n+        \n+        Observable.<Movie, CoolRating, Result> combineLatest(horrors, ratings, combine);\n+    }\n+\n+    Func2<Media, Rating, ExtendedResult> combine = new Func2<Media, Rating, ExtendedResult>() {\n+        @Override\n+        public ExtendedResult call(Media m, Rating r) {\n+            return new ExtendedResult();\n+        }\n+    };\n+\n+    Action1<Result> action = new Action1<Result>() {\n+        @Override\n+        public void call(Result t1) {\n+            System.out.println(\"Result: \" + t1);\n+        }\n+    };\n+    \n+    Action1<ExtendedResult> extendedAction = new Action1<ExtendedResult>() {\n+        @Override\n+        public void call(ExtendedResult t1) {\n+            System.out.println(\"Result: \" + t1);\n+        }\n+    };\n+    \n     static class Media {\n     }\n ",
    "output": "Add a few 'compiler' tests"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationToObservableFuture.java b/rxjava-core/src/main/java/rx/operators/OperationToObservableFuture.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationToObservableFuture.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationToObservableFuture.java\n@@ -59,7 +59,7 @@ public ToObservableFuture(Future<? extends T> that, long time, TimeUnit unit) {\n         @Override\n         public Subscription call(Observer<? super T> observer) {\n             try {\n-                T value = (time == null) ? that.get() : that.get(time, unit);\n+                T value = (time == null) ? (T) that.get() : (T) that.get(time, unit);\n \n                 if (!that.isCancelled()) {\n                     observer.onNext(value);",
    "output": "Add an unnecessary explicit cast because the Jenkins java compiler is unhappy otherwise?"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationMaterialize.java b/rxjava-core/src/main/java/rx/operators/OperationMaterialize.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationMaterialize.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationMaterialize.java\n@@ -19,6 +19,7 @@\n \n import java.util.List;\n import java.util.Vector;\n+import java.util.concurrent.ExecutionException;\n \n import org.junit.Test;\n \n@@ -139,25 +140,13 @@ public void testMaterialize2() {\n         }\n \n         @Test\n-        public void testMultipleSubscribes() {\n-            final TestAsyncErrorObservable o1 = new TestAsyncErrorObservable(\"one\", \"two\", null, \"three\");\n-\n-            Observable<Notification<String>> m = Observable.create(materialize(o1));\n-\n-            TestObserver Observer1 = new TestObserver();\n-            m.subscribe(Observer1);\n-\n-            TestObserver Observer2 = new TestObserver();\n-            m.subscribe(Observer2);\n+        public void testMultipleSubscribes() throws InterruptedException, ExecutionException {\n+            final TestAsyncErrorObservable o = new TestAsyncErrorObservable(\"one\", \"two\", null, \"three\");\n \n-            try {\n-                o1.t.join();\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n+            Observable<Notification<String>> m = Observable.create(materialize(o));\n \n-            assertEquals(3, Observer1.notifications.size());\n-            assertEquals(3, Observer2.notifications.size());\n+            assertEquals(3, m.toList().toBlockingObservable().toFuture().get().size());\n+            assertEquals(3, m.toList().toBlockingObservable().toFuture().get().size());\n         }\n \n     }\n@@ -193,7 +182,7 @@ private static class TestAsyncErrorObservable extends Observable<String> {\n             valuesToReturn = values;\n         }\n \n-        Thread t;\n+        volatile Thread t;\n \n         @Override\n         public Subscription subscribe(final Observer<String> observer) {",
    "output": "Make Materialize.testMultipleSubscribes test deterministic\n\nRefactored to use BlockingObservable instead of non-blocking subscribe and waiting on the underlying thread (it was only waiting on one of two threads running).\nThis should resolve one of the issues reported in http://github.com/Netflix/RxJava/issues/329"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationGroupBy.java b/rxjava-core/src/main/java/rx/operators/OperationGroupBy.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationGroupBy.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationGroupBy.java\n@@ -548,8 +548,8 @@ public void onNext(String outputMessage) {\n             // sentEvents will go until 'eventCounter' hits 20 and then unsubscribes\n             // which means it will also send (but ignore) the 19/20 events for the other group\n             // It will not however send all 100 events.\n-            assertEquals(39, sentEventCounter.get(), 2);\n-            // gave it a delta of 2 so the threading/unsubscription race has wiggle \n+            assertEquals(39, sentEventCounter.get(), 10);\n+            // gave it a delta of 10 to account for the threading/unsubscription race condition which can vary depending on a machines performance, thread-scheduler, etc\n         }\n \n         private static class Event {",
    "output": "Improve determinism of GroupBy.testUnsubscribe\n\nIncreased delta value from 2 to 10 to try and resolve issue reported in issue https://github.com/Netflix/RxJava/issues/329"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n--- a/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n+++ b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n@@ -306,12 +306,7 @@ public Subscription call(Scheduler scheduler, BooleanSubscription cancel) {\n                         observer.onNext(42);\n                         latch.countDown();\n \n-                        try {\n-                            Thread.sleep(1);\n-                        } catch (InterruptedException e) {\n-                            e.printStackTrace();\n-                        }\n-\n+                        // this will recursively schedule this task for execution again\n                         scheduler.schedule(cancel, this);\n \n                         return cancel;\n@@ -353,7 +348,8 @@ public void onNext(Integer args) {\n             fail(\"Timed out waiting on completion latch\");\n         }\n \n-        assertEquals(10, count.get()); // wondering if this could be 11 in a race condition (which would be okay due to how unsubscribe works ... just it would make this test non-deterministic)\n+        // the count can be 10 or higher due to thread scheduling of the unsubscribe vs the scheduler looping to emit the count\n+        assertTrue(count.get() >= 10);\n         assertTrue(completed.get());\n     }\n ",
    "output": "Improve testRecursiveScheduler2 determinism\n\nRemoved use of Thread.sleep and changed assertion to allow for the expected race condition between the counter loop and unsubscribe event to fix non-determinism issue reported in https://github.com/Netflix/RxJava/issues/329"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationNext.java b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationNext.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n@@ -27,6 +27,7 @@\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n@@ -313,6 +314,8 @@ private static class TestException extends RuntimeException {\n         @Test\n         public void testNoBufferingOrBlockingOfSequence() throws Throwable {\n             final CountDownLatch finished = new CountDownLatch(1);\n+            final int COUNT = 30;\n+            final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);\n             final AtomicBoolean running = new AtomicBoolean(true);\n             final AtomicInteger count = new AtomicInteger(0);\n             final Observable<Integer> obs = Observable.create(new Func1<Observer<Integer>, Subscription>() {\n@@ -326,7 +329,7 @@ public void run() {\n                             try {\n                                 while (running.get()) {\n                                     o.onNext(count.incrementAndGet());\n-                                    Thread.sleep(0, 100);\n+                                    timeHasPassed.countDown();\n                                 }\n                                 o.onCompleted();\n                             } catch (Throwable e) {\n@@ -350,19 +353,14 @@ public void run() {\n             // we should have a different value\n             assertTrue(\"a and b should be different\", a != b);\n \n-            // wait for some time\n-            Thread.sleep(100);\n-            // make sure the counter in the observable has increased beyond b\n-            while (count.get() <= (b + 10)) {\n-                Thread.sleep(100);\n-            }\n+            // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)\n+            timeHasPassed.await(8000, TimeUnit.MILLISECONDS);\n \n             assertTrue(it.hasNext());\n-            int expectedHigherThan = count.get();\n             int c = it.next();\n \n             assertTrue(\"c should not just be the next in sequence\", c != (b + 1));\n-            assertTrue(\"expected that c [\" + c + \"] is higher than \" + expectedHigherThan, c > expectedHigherThan);\n+            assertTrue(\"expected that c [\" + c + \"] is higher than or equal to \" + COUNT, c >= COUNT);\n \n             assertTrue(it.hasNext());\n ",
    "output": "Improve testNoBufferingOrBlockingOfSequence determinism\n\nRemoved use of Thread.sleep to fix non-determinism issue reported in https://github.com/Netflix/RxJava/issues/329"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -247,7 +247,7 @@ private Subscription protectivelyWrapAndSubscribe(Observer<T> o) {\n         return subscription.wrap(subscribe(new SafeObserver<T>(subscription, o)));\n     }\n \n-    public Subscription subscribe(final Action1<T> onNext) {\n+    public Subscription subscribe(final Action1<? super T> onNext) {\n         if (onNext == null) {\n             throw new IllegalArgumentException(\"onNext can not be null\");\n         }\n@@ -278,11 +278,11 @@ public void onNext(T args) {\n         });\n     }\n \n-    public Subscription subscribe(final Action1<T> onNext, Scheduler scheduler) {\n+    public Subscription subscribe(final Action1<? super T> onNext, Scheduler scheduler) {\n         return subscribeOn(scheduler).subscribe(onNext);\n     }\n \n-    public Subscription subscribe(final Action1<T> onNext, final Action1<Throwable> onError) {\n+    public Subscription subscribe(final Action1<? super T> onNext, final Action1<? super Throwable> onError) {\n         if (onNext == null) {\n             throw new IllegalArgumentException(\"onNext can not be null\");\n         }\n@@ -316,11 +316,11 @@ public void onNext(T args) {\n         });\n     }\n \n-    public Subscription subscribe(final Action1<T> onNext, final Action1<Throwable> onError, Scheduler scheduler) {\n+    public Subscription subscribe(final Action1<? super T> onNext, final Action1<? super Throwable> onError, Scheduler scheduler) {\n         return subscribeOn(scheduler).subscribe(onNext, onError);\n     }\n \n-    public Subscription subscribe(final Action1<T> onNext, final Action1<Throwable> onError, final Action0 onComplete) {\n+    public Subscription subscribe(final Action1<? super T> onNext, final Action1<? super Throwable> onError, final Action0 onComplete) {\n         if (onNext == null) {\n             throw new IllegalArgumentException(\"onNext can not be null\");\n         }\n@@ -357,7 +357,7 @@ public void onNext(T args) {\n         });\n     }\n \n-    public Subscription subscribe(final Action1<T> onNext, final Action1<Throwable> onError, final Action0 onComplete, Scheduler scheduler) {\n+    public Subscription subscribe(final Action1<? super T> onNext, final Action1<? super Throwable> onError, final Action0 onComplete, Scheduler scheduler) {\n         return subscribeOn(scheduler).subscribe(onNext, onError, onComplete);\n     }\n \n\ndiff --git a/rxjava-core/src/main/java/rx/observables/BlockingObservable.java b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java\n--- a/rxjava-core/src/main/java/rx/observables/BlockingObservable.java\n+++ b/rxjava-core/src/main/java/rx/observables/BlockingObservable.java\n@@ -355,7 +355,7 @@ private Subscription protectivelyWrapAndSubscribe(Observer<T> o) {\n      * @throws RuntimeException\n      *             if an error occurs\n      */\n-    public void forEach(final Action1<T> onNext) {\n+    public void forEach(final Action1<? super T> onNext) {\n         final CountDownLatch latch = new CountDownLatch(1);\n         final AtomicReference<Throwable> exceptionFromOnError = new AtomicReference<Throwable>();\n \n\ndiff --git a/rxjava-core/src/main/java/rx/util/functions/Functions.java b/rxjava-core/src/main/java/rx/util/functions/Functions.java\n--- a/rxjava-core/src/main/java/rx/util/functions/Functions.java\n+++ b/rxjava-core/src/main/java/rx/util/functions/Functions.java\n@@ -253,7 +253,7 @@ public Void call(Object... args) {\n      * @param f\n      * @return {@link FuncN}\n      */\n-    public static <T0> FuncN<Void> fromAction(final Action1<T0> f) {\n+    public static <T0> FuncN<Void> fromAction(final Action1<? super T0> f) {\n         return new FuncN<Void>() {\n \n             @SuppressWarnings(\"unchecked\")\n@@ -275,7 +275,7 @@ public Void call(Object... args) {\n      * @param f\n      * @return {@link FuncN}\n      */\n-    public static <T0, T1> FuncN<Void> fromAction(final Action2<T0, T1> f) {\n+    public static <T0, T1> FuncN<Void> fromAction(final Action2<? super T0, ? super T1> f) {\n         return new FuncN<Void>() {\n \n             @SuppressWarnings(\"unchecked\")\n@@ -297,7 +297,7 @@ public Void call(Object... args) {\n      * @param f\n      * @return {@link FuncN}\n      */\n-    public static <T0, T1, T2> FuncN<Void> fromAction(final Action3<T0, T1, T2> f) {\n+    public static <T0, T1, T2> FuncN<Void> fromAction(final Action3<? super T0, ? super T1, ? super T2> f) {\n         return new FuncN<Void>() {\n \n             @SuppressWarnings(\"unchecked\")",
    "output": "Add variance to Action*, too"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/plugins/RxJavaPlugins.java b/rxjava-core/src/main/java/rx/plugins/RxJavaPlugins.java\n--- a/rxjava-core/src/main/java/rx/plugins/RxJavaPlugins.java\n+++ b/rxjava-core/src/main/java/rx/plugins/RxJavaPlugins.java\n@@ -20,6 +20,7 @@\n import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.After;\n+import org.junit.Before;\n import org.junit.Test;\n \n /**\n@@ -153,6 +154,7 @@ private static Object getPluginImplementationViaProperty(Class<?> pluginClass) {\n     public static class UnitTest {\n \n         @After\n+        @Before\n         public void reset() {\n             // use private access to reset so we can test different initializations via the public static flow\n             RxJavaPlugins.getInstance().errorHandler.set(null);",
    "output": "Improve unit test determinism\n\n… apparently the before/after was a race condition … adding @Before seems to have made it better for me"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -77,6 +77,7 @@\n import rx.util.OnErrorNotImplementedException;\n import rx.util.Range;\n import rx.util.Timestamped;\n+import rx.util.functions.Action;\n import rx.util.functions.Action0;\n import rx.util.functions.Action1;\n import rx.util.functions.Func0;\n@@ -249,56 +250,6 @@ private Subscription protectivelyWrapAndSubscribe(Observer<T> o) {\n         return subscription.wrap(subscribe(new SafeObserver<T>(subscription, o)));\n     }\n \n-    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n-    public Subscription subscribe(final Map<String, Object> callbacks) {\n-        if (callbacks == null) {\n-            throw new RuntimeException(\"callbacks map can not be null\");\n-        }\n-        Object _onNext = callbacks.get(\"onNext\");\n-        if (_onNext == null) {\n-            throw new RuntimeException(\"'onNext' key must contain an implementation\");\n-        }\n-        // lookup and memoize onNext\n-        final FuncN onNext = Functions.from(_onNext);\n-\n-        /**\n-         * Wrapping since raw functions provided by the user are being invoked.\n-         * \n-         * See https://github.com/Netflix/RxJava/issues/216 for discussion on \"Guideline 6.4: Protect calls to user code from within an operator\"\n-         */\n-        return protectivelyWrapAndSubscribe(new Observer() {\n-\n-            @Override\n-            public void onCompleted() {\n-                Object onComplete = callbacks.get(\"onCompleted\");\n-                if (onComplete != null) {\n-                    Functions.from(onComplete).call();\n-                }\n-            }\n-\n-            @Override\n-            public void onError(Throwable e) {\n-                handleError(e);\n-                Object onError = callbacks.get(\"onError\");\n-                if (onError != null) {\n-                    Functions.from(onError).call(e);\n-                } else {\n-                    throw new OnErrorNotImplementedException(e);\n-                }\n-            }\n-\n-            @Override\n-            public void onNext(Object args) {\n-                onNext.call(args);\n-            }\n-\n-        });\n-    }\n-\n-    public Subscription subscribe(final Map<String, Object> callbacks, Scheduler scheduler) {\n-        return subscribeOn(scheduler).subscribe(callbacks);\n-    }\n-\n     public Subscription subscribe(final Action1<T> onNext) {\n         if (onNext == null) {\n             throw new IllegalArgumentException(\"onNext can not be null\");\n@@ -1086,13 +1037,13 @@ public static <R, T0, T1, T2, T3> Observable<R> zip(Observable<T0> w0, Observabl\n      * each time an event is received from one of the source observables, where the aggregation is defined by the given function.\n      * <p>\n      * <img width=\"640\" src=\"https://github.com/Netflix/RxJava/wiki/images/rx-operators/combineLatest.png\">\n-     *\n+     * \n      * @param w0\n-     * The first source observable.\n+     *            The first source observable.\n      * @param w1\n-     * The second source observable.\n+     *            The second source observable.\n      * @param combineFunction\n-     * The aggregation function used to combine the source observable values.\n+     *            The aggregation function used to combine the source observable values.\n      * @return An Observable that combines the source Observables with the given combine function\n      */\n     public static <R, T0, T1> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> combineFunction) {\n@@ -1112,7 +1063,7 @@ public static <R, T0, T1, T2> Observable<R> combineLatest(Observable<T0> w0, Obs\n     public static <R, T0, T1, T2, T3> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Observable<T3> w3, Func4<T0, T1, T2, T3, R> combineFunction) {\n         return create(OperationCombineLatest.combineLatest(w0, w1, w2, w3, combineFunction));\n     }\n-    \n+\n     /**\n      * Creates an Observable which produces buffers of collected values.\n      * ",
    "output": "Remove subscribe(Map<String, Object>)\n\nWe considered it being <String, Action> but that is also awkward as it's not a real functional interface.\nAlso because of type erasure extension methods aren't super helpful here as Map<String, Action> collides with Map<String, Closure>"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subscriptions/Subscriptions.java b/rxjava-core/src/main/java/rx/subscriptions/Subscriptions.java\n--- a/rxjava-core/src/main/java/rx/subscriptions/Subscriptions.java\n+++ b/rxjava-core/src/main/java/rx/subscriptions/Subscriptions.java\n@@ -20,6 +20,7 @@\n import rx.Subscription;\n import rx.util.functions.Action0;\n import rx.util.functions.FuncN;\n+import rx.util.functions.Function;\n import rx.util.functions.Functions;\n \n /**\n@@ -83,23 +84,6 @@ public static CompositeSubscription create(Subscription... subscriptions) {\n         return new CompositeSubscription(subscriptions);\n     }\n \n-    /**\n-     * A {@link Subscription} implemented via an anonymous function (such as closures from other languages).\n-     *\n-     * @return {@link Subscription}\n-     */\n-    public static Subscription create(final Object unsubscribe) {\n-        final FuncN<?> f = Functions.from(unsubscribe);\n-        return new Subscription() {\n-\n-            @Override\n-            public void unsubscribe() {\n-                f.call();\n-            }\n-\n-        };\n-    }\n-\n     /**\n      * A {@link Subscription} that does nothing when its unsubscribe method is called.\n      */\n\ndiff --git a/rxjava-core/src/main/java/rx/util/functions/Action.java b/rxjava-core/src/main/java/rx/util/functions/Action.java\n--- a/rxjava-core/src/main/java/rx/util/functions/Action.java\n+++ b/rxjava-core/src/main/java/rx/util/functions/Action.java\n@@ -5,6 +5,6 @@\n  * <p>\n  * Marker interface to allow instanceof checks.\n  */\n-public interface Action {\n+public interface Action extends Function {\n \n }\n\ndiff --git a/rxjava-core/src/main/java/rx/util/functions/Functions.java b/rxjava-core/src/main/java/rx/util/functions/Functions.java\n--- a/rxjava-core/src/main/java/rx/util/functions/Functions.java\n+++ b/rxjava-core/src/main/java/rx/util/functions/Functions.java\n@@ -15,9 +15,6 @@\n  */\n package rx.util.functions;\n \n-import java.util.Collection;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n public class Functions {\n \n     /**\n@@ -26,17 +23,11 @@ public class Functions {\n      * @param function\n      */\n     @SuppressWarnings({ \"rawtypes\" })\n-    public static FuncN from(final Object function) {\n+    public static FuncN from(final Function function) {\n         if (function == null) {\n             throw new RuntimeException(\"function is null. Can't send arguments to null function.\");\n         }\n-\n-        /* check for typed Rx Function implementation first */\n-        if (function instanceof Function) {\n-            return fromFunction((Function) function);\n-        }\n-        // no support found\n-        throw new RuntimeException(\"Unsupported closure type: \" + function.getClass().getSimpleName());\n+        return fromFunction(function);\n     }\n \n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })",
    "output": "Make Functions.from typesafe"
  },
  {
    "input": "diff --git a/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java\n--- a/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java\n+++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java\n@@ -1,31 +0,0 @@\n-/**\n- * Copyright 2013 Netflix, Inc.\n- * \n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * \n- * http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package rx.lang.groovy;\n-\n-import groovy.lang.Closure;\n-import rx.util.functions.FunctionLanguageAdaptor;\n-\n-public class GroovyAdaptor implements FunctionLanguageAdaptor {\n-\n-    @Override\n-    public Object call(Object function, Object[] args) {\n-        return ((Closure<?>) function).call(args);\n-    }\n-\n-    public Class<?>[] getFunctionClass() {\n-        return new Class<?>[] { Closure.class };\n-    }\n-}",
    "output": "Remove Java GroovyAdaptor - will be replaced by Groovy idiomatic version"
  },
  {
    "input": "diff --git a/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java\n--- a/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java\n+++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java\n@@ -1,128 +0,0 @@\n-/**\n- * Copyright 2013 Netflix, Inc.\n- * \n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * \n- * http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package rx.lang.clojure;\n-\n-import java.util.Arrays;\n-\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.mockito.Mock;\n-import org.mockito.MockitoAnnotations;\n-\n-import rx.Observer;\n-import rx.util.functions.FunctionLanguageAdaptor;\n-\n-import clojure.lang.IFn;\n-import clojure.lang.RT;\n-import clojure.lang.Var;\n-\n-public class ClojureAdaptor implements FunctionLanguageAdaptor {\n-\n-    @Override\n-    public Object call(Object function, Object[] args) {\n-        if (args.length == 0) {\n-            return ((IFn) function).invoke();\n-        } else if (args.length == 1) {\n-            return ((IFn) function).invoke(args[0]);\n-        } else if (args.length == 2) {\n-            return ((IFn) function).invoke(args[0], args[1]);\n-        } else if (args.length == 3) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2]);\n-        } else if (args.length == 4) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3]);\n-        } else if (args.length == 5) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4]);\n-        } else if (args.length == 6) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5]);\n-        } else if (args.length == 7) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n-        } else if (args.length == 8) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\n-        } else if (args.length == 9) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\n-        } else if (args.length == 10) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);\n-        } else if (args.length == 11) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]);\n-        } else if (args.length == 12) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);\n-        } else if (args.length == 13) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12]);\n-        } else if (args.length == 14) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13]);\n-        } else if (args.length == 15) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14]);\n-        } else if (args.length == 16) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15]);\n-        } else if (args.length == 17) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16]);\n-        } else if (args.length == 18) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16], args[17]);\n-        } else if (args.length == 19) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16], args[17], args[18]);\n-        } else if (args.length == 20) {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16], args[17], args[18], args[19]);\n-        } else {\n-            return ((IFn) function).invoke(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16], args[17], args[18], args[19], Arrays.copyOfRange(args, 20, args.length));\n-        }\n-    }\n-\n-    @Override\n-    public Class<?>[] getFunctionClass() {\n-        return new Class<?>[] { IFn.class };\n-    }\n-\n-    public static class UnitTest {\n-\n-        @Mock\n-        ScriptAssertion assertion;\n-\n-        @Mock\n-        Observer<Integer> w;\n-\n-        @Before\n-        public void before() {\n-            MockitoAnnotations.initMocks(this);\n-        }\n-\n-        @Test\n-        public void testTake() {\n-            runClojureScript(\"(-> (rx.Observable/toObservable [\\\"one\\\" \\\"two\\\" \\\"three\\\"]) (.take 2) (.subscribe (fn [arg] (println arg))))\");\n-        }\n-\n-        // commented out for now as I can't figure out how to set the var 'a' with the 'assertion' instance when running the code from java \n-        //        @Test\n-        //        public void testFilter() {\n-        //            runClojureScript(\"(-> (org.rx.reactive.Observable/toObservable [1 2 3])  (.filter (fn [v] (>= v 2))) (.subscribe (fn [result] (a.received(result)))))\");\n-        //            verify(assertion, times(0)).received(1);\n-        //            verify(assertion, times(1)).received(2);\n-        //            verify(assertion, times(1)).received(3);\n-        //        }\n-\n-        private static interface ScriptAssertion {\n-            public void error(Exception o);\n-\n-            public void received(Object o);\n-        }\n-\n-        private void runClojureScript(String script) {\n-            Object code = RT.var(\"clojure.core\", \"read-string\").invoke(script);\n-            Var eval = RT.var(\"clojure.core\", \"eval\");\n-            Object result = eval.invoke(code);\n-            System.out.println(\"Result: \" + result);\n-        }\n-    }\n-}",
    "output": "Remove Java ClojureAdaptor - will be replaced by an idiomatic Clojure version"
  },
  {
    "input": "diff --git a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n--- a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n+++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n@@ -1,225 +0,0 @@\n-/**\n- * Copyright 2013 Netflix, Inc.\n- * \n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * \n- * http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package rx.lang.jruby;\n-\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n-\n-import java.util.Arrays;\n-\n-import org.jruby.Ruby;\n-import org.jruby.RubyProc;\n-import org.jruby.embed.ScriptingContainer;\n-import org.jruby.javasupport.JavaEmbedUtils;\n-import org.jruby.runtime.builtin.IRubyObject;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.mockito.Mock;\n-import org.mockito.MockitoAnnotations;\n-\n-import rx.Notification;\n-import rx.Observable;\n-import rx.Observer;\n-import rx.Subscription;\n-import rx.util.functions.Func1;\n-import rx.util.functions.FunctionLanguageAdaptor;\n-\n-public class JRubyAdaptor implements FunctionLanguageAdaptor {\n-\n-    @Override\n-    public Object call(Object function, Object[] args) {\n-        RubyProc rubyProc = ((RubyProc) function);\n-        Ruby ruby = rubyProc.getRuntime();\n-        IRubyObject rubyArgs[] = new IRubyObject[args.length];\n-        for (int i = 0; i < args.length; i++) {\n-            rubyArgs[i] = JavaEmbedUtils.javaToRuby(ruby, args[i]);\n-        }\n-        return rubyProc.getBlock().call(ruby.getCurrentContext(), rubyArgs);\n-    }\n-\n-    @Override\n-    public Class<?>[] getFunctionClass() {\n-        return new Class<?>[] { RubyProc.class };\n-    }\n-\n-    public static class UnitTest {\n-\n-        @Mock\n-        ScriptAssertion assertion;\n-\n-        @Mock\n-        Observer<Integer> w;\n-\n-        @Before\n-        public void before() {\n-            MockitoAnnotations.initMocks(this);\n-        }\n-\n-        @Test\n-        public void testCreateViaGroovy() {\n-            runGroovyScript(\"Observable.create(lambda{|it| it.onNext('hello');it.onCompleted();}).subscribe(lambda{|result| a.received(result)});\");\n-            verify(assertion, times(1)).received(\"hello\");\n-        }\n-\n-        @Test\n-        public void testFilterViaGroovy() {\n-            runGroovyScript(\"Observable.filter(Observable.from(1, 2, 3), lambda{|it| it >= 2}).subscribe(lambda{|result| a.received(result)});\");\n-            verify(assertion, times(0)).received(1L);\n-            verify(assertion, times(1)).received(2L);\n-            verify(assertion, times(1)).received(3L);\n-        }\n-\n-        @Test\n-        public void testLast() {\n-            String script = \"mockApiCall.getObservable().takeLast(1).subscribe(lambda{|result| a.received(result)})\";\n-            runGroovyScript(script);\n-            verify(assertion, times(1)).received(\"hello_1\");\n-        }\n-\n-        @Test\n-        public void testMap() {\n-            String script = \"mockApiCall.getObservable().map(lambda{|v| 'say' + v}).subscribe(lambda{|result| a.received(result)});\";\n-            runGroovyScript(script);\n-            verify(assertion, times(1)).received(\"sayhello_1\");\n-        }\n-\n-        @Test\n-        public void testMaterializeViaGroovy() {\n-            runGroovyScript(\"Observable.materialize(Observable.from(1, 2, 3)).subscribe(lambda{|result| a.received(result)});\");\n-            // we expect 4 onNext calls: 3 for 1, 2, 3 ObservableNotification.OnNext and 1 for ObservableNotification.OnCompleted\n-            verify(assertion, times(4)).received(any(Notification.class));\n-            verify(assertion, times(0)).error(any(Exception.class));\n-        }\n-\n-        @Test\n-        public void testScriptWithMaterialize() {\n-            String script = \"mockApiCall.getObservable().materialize().subscribe(lambda{|result| a.received(result)});\";\n-            runGroovyScript(script);\n-            // 2 times: once for hello_1 and once for onCompleted\n-            verify(assertion, times(2)).received(any(Notification.class));\n-        }\n-\n-        @Test\n-        public void testScriptWithMerge() {\n-            String script = \"Observable.merge(mockApiCall.getObservable(), mockApiCall.getObservable()).subscribe(lambda{|result| a.received(result)});\";\n-            runGroovyScript(script);\n-            verify(assertion, times(1)).received(\"hello_1\");\n-            verify(assertion, times(1)).received(\"hello_2\");\n-        }\n-\n-        @Test\n-        public void testScriptWithOnNext() {\n-            String script = \"mockApiCall.getObservable().subscribe(lambda{|result| a.received(result)})\";\n-            runGroovyScript(script);\n-            verify(assertion).received(\"hello_1\");\n-        }\n-\n-        @Test\n-        public void testSkipTakeViaGroovy() {\n-            runGroovyScript(\"Observable.skip(Observable.from(1, 2, 3), 1).take(1).subscribe(lambda{|result| a.received(result)});\");\n-            verify(assertion, times(0)).received(1);\n-            verify(assertion, times(1)).received(2L);\n-            verify(assertion, times(0)).received(3);\n-        }\n-\n-        @Test\n-        public void testSkipViaGroovy() {\n-            runGroovyScript(\"Observable.skip(Observable.from(1, 2, 3), 2).subscribe(lambda{|result| a.received(result)});\");\n-            verify(assertion, times(0)).received(1);\n-            verify(assertion, times(0)).received(2);\n-            verify(assertion, times(1)).received(3L);\n-        }\n-\n-        @Test\n-        public void testTakeViaGroovy() {\n-            runGroovyScript(\"Observable.take(Observable.from(1, 2, 3), 2).subscribe(lambda{|result| a.received(result)});\");\n-            verify(assertion, times(1)).received(1L);\n-            verify(assertion, times(1)).received(2L);\n-            verify(assertion, times(0)).received(3);\n-        }\n-\n-        @Test\n-        public void testToSortedList() {\n-            runGroovyScript(\"mockApiCall.getNumbers().toSortedList().subscribe(lambda{|result| a.received(result)});\");\n-            verify(assertion, times(1)).received(Arrays.asList(1, 2, 3, 4, 5));\n-        }\n-\n-        private void runGroovyScript(String script) {\n-            ScriptingContainer container = new ScriptingContainer();\n-            container.put(\"mockApiCall\", new TestFactory());\n-            container.put(\"a\", assertion);\n-\n-            StringBuilder b = new StringBuilder();\n-            // force JRuby to always use subscribe(Object)\n-            b.append(\"import \\\"rx.Observable\\\"\").append(\"\\n\");\n-            b.append(\"class Observable\").append(\"\\n\");\n-            b.append(\"  java_alias :subscribe, :subscribe, [java.lang.Object]\").append(\"\\n\");\n-            b.append(\"end\").append(\"\\n\");\n-            b.append(script);\n-\n-            container.runScriptlet(b.toString());\n-        }\n-\n-        private static interface ScriptAssertion {\n-            public void error(Exception o);\n-\n-            public void received(Object o);\n-        }\n-\n-        public static class TestFactory {\n-            int counter = 1;\n-\n-            public Observable<Integer> getNumbers() {\n-                return Observable.from(1, 3, 2, 5, 4);\n-            }\n-\n-            public TestObservable getObservable() {\n-                return new TestObservable(counter++);\n-            }\n-        }\n-\n-        private static class TestObservable extends Observable<String> {\n-            private final int count;\n-\n-            public TestObservable(int count) {\n-                super(new Func1<Observer<String>, Subscription>() {\n-\n-                    @Override\n-                    public Subscription call(Observer<String> t1) {\n-                        // do nothing, override subscribe for test\n-                        return null;\n-                    }\n-                });\n-                this.count = count;\n-            }\n-\n-            public Subscription subscribe(Observer<String> observer) {\n-\n-                observer.onNext(\"hello_\" + count);\n-                observer.onCompleted();\n-\n-                return new Subscription() {\n-\n-                    public void unsubscribe() {\n-                        // unregister ... will never be called here since we are executing synchronously\n-                    }\n-\n-                };\n-            }\n-        }\n-    }\n-\n-}",
    "output": "Remove JRuby adaptor (temporarily)"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java\n@@ -4,9 +4,10 @@\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.ArgumentCaptor;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n import rx.Scheduler;\n import rx.Subscription;\n-import rx.android.testsupport.AndroidTestRunner;\n import rx.operators.AtomicObservableSubscription;\n import rx.util.functions.Func2;\n \n@@ -67,7 +68,8 @@ public void run() {\n         return subscription;\n     }\n \n-    @RunWith(AndroidTestRunner.class)\n+    @RunWith(RobolectricTestRunner.class)\n+    @Config(manifest=Config.NONE)\n     public static final class UnitTest {\n \n         @Test\n\ndiff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/AndroidTestRunner.java b/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/AndroidTestRunner.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/AndroidTestRunner.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/AndroidTestRunner.java\n@@ -1,14 +0,0 @@\n-package rx.android.testsupport;\n-\n-import com.xtremelabs.robolectric.RobolectricConfig;\n-import com.xtremelabs.robolectric.RobolectricTestRunner;\n-import org.junit.runners.model.InitializationError;\n-\n-import java.io.File;\n-\n-public class AndroidTestRunner extends RobolectricTestRunner {\n-\n-    public AndroidTestRunner(Class<?> testClass) throws InitializationError {\n-        super(testClass, new RobolectricConfig(new File(\"src/test/resources\")));\n-    }\n-}\n\ndiff --git a/rxjava-contrib/rxjava-android/src/test/java/rx/android/testsupport/R.java b/rxjava-contrib/rxjava-android/src/test/java/rx/android/testsupport/R.java\n--- a/rxjava-contrib/rxjava-android/src/test/java/rx/android/testsupport/R.java\n+++ b/rxjava-contrib/rxjava-android/src/test/java/rx/android/testsupport/R.java\n@@ -1,5 +0,0 @@\n-package rx.android.testsupport;\n-\n-public class R {\n-    // resource stub for Robolectric\n-}",
    "output": "Upgrade to Robolectric 2.0 and remove all the things"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/concurrency/HandlerThreadScheduler.java b/rxjava-contrib/rxjava-android/src/main/java/rx/concurrency/HandlerThreadScheduler.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/concurrency/HandlerThreadScheduler.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/concurrency/HandlerThreadScheduler.java\n@@ -1,13 +1,24 @@\n package rx.concurrency;\n \n import android.os.Handler;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n import rx.Scheduler;\n import rx.Subscription;\n+import rx.android.testsupport.AndroidTestRunner;\n import rx.operators.AtomicObservableSubscription;\n import rx.util.functions.Func2;\n \n import java.util.concurrent.TimeUnit;\n \n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n /**\n  * Schedules actions to run on an Android Handler thread.\n  */\n@@ -49,6 +60,61 @@ public void run() {\n             return subscription;\n         }\n     }\n+\n+    @RunWith(AndroidTestRunner.class)\n+    public static final class UnitTest {\n+\n+        @Test\n+        public void shouldScheduleActionOnHandlerThread() {\n+            final Handler handler = mock(Handler.class);\n+            final Object state = new Object();\n+            final Func2<Scheduler, Object, Subscription> action = mock(Func2.class);\n+\n+            Scheduler scheduler = new HandlerThreadScheduler(handler);\n+            scheduler.schedule(state, action);\n+\n+            // verify that we post to the given Handler\n+            ArgumentCaptor<Runnable> runnable = ArgumentCaptor.forClass(Runnable.class);\n+            verify(handler).post(runnable.capture());\n+\n+            // verify that the given handler delegates to our action\n+            runnable.getValue().run();\n+            verify(action).call(scheduler, state);\n+        }\n+\n+        @Test\n+        public void shouldScheduleDelayedActionOnHandlerThread() {\n+            final Handler handler = mock(Handler.class);\n+            final Object state = new Object();\n+            final Func2<Scheduler, Object, Subscription> action = mock(Func2.class);\n+\n+            Scheduler scheduler = new HandlerThreadScheduler(handler);\n+            scheduler.schedule(state, action, 1L, TimeUnit.SECONDS);\n+\n+            // verify that we post to the given Handler\n+            ArgumentCaptor<Runnable> runnable = ArgumentCaptor.forClass(Runnable.class);\n+            verify(handler).postDelayed(runnable.capture(), eq(1000L));\n+\n+            // verify that the given handler delegates to our action\n+            runnable.getValue().run();\n+            verify(action).call(scheduler, state);\n+        }\n+\n+        @Test\n+        public void scheduleDelayedActionShouldForwardToNormalPostIfDelayIsZero() {\n+            final Handler handler = mock(Handler.class);\n+            final Object state = new Object();\n+            final Func2<Scheduler, Object, Subscription> action = mock(Func2.class);\n+\n+            Scheduler scheduler = new HandlerThreadScheduler(handler);\n+            scheduler.schedule(state, action, 0L, TimeUnit.SECONDS);\n+\n+            // verify that we post to the given Handler\n+            verify(handler).post(any(Runnable.class));\n+            verify(handler, never()).postDelayed(any(Runnable.class), anyLong());\n+        }\n+\n+    }\n }\n \n ",
    "output": "Add unit tests for HandlerThreadScheduler"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/AndroidTestRunner.java b/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/AndroidTestRunner.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/AndroidTestRunner.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/AndroidTestRunner.java\n@@ -0,0 +1,14 @@\n+package rx.android.testsupport;\n+\n+import com.xtremelabs.robolectric.RobolectricConfig;\n+import com.xtremelabs.robolectric.RobolectricTestRunner;\n+import org.junit.runners.model.InitializationError;\n+\n+import java.io.File;\n+\n+public class AndroidTestRunner extends RobolectricTestRunner {\n+\n+    public AndroidTestRunner(Class<?> testClass) throws InitializationError {\n+        super(testClass, new RobolectricConfig(new File(\"src/test/resources\")));\n+    }\n+}\n\ndiff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/R.java b/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/R.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/R.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/R.java\n@@ -0,0 +1,5 @@\n+package rx.android.testsupport;\n+\n+public class R {\n+    // resource stub for Robolectric\n+}",
    "output": "Add support for running Robolectric tests"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-android/src/main/java/rx/concurrency/HandlerThreadScheduler.java b/rxjava-contrib/rxjava-android/src/main/java/rx/concurrency/HandlerThreadScheduler.java\n--- a/rxjava-contrib/rxjava-android/src/main/java/rx/concurrency/HandlerThreadScheduler.java\n+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/concurrency/HandlerThreadScheduler.java\n@@ -0,0 +1,54 @@\n+package rx.concurrency;\n+\n+import android.os.Handler;\n+import rx.Scheduler;\n+import rx.Subscription;\n+import rx.operators.AtomicObservableSubscription;\n+import rx.util.functions.Func2;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Schedules actions to run on an Android Handler thread.\n+ */\n+public class HandlerThreadScheduler extends Scheduler {\n+\n+    private final Handler handler;\n+\n+    public HandlerThreadScheduler(Handler handler) {\n+        this.handler = handler;\n+    }\n+\n+    @Override\n+    public <T> Subscription schedule(final T state, final Func2<Scheduler, T, Subscription> action) {\n+        final AtomicObservableSubscription subscription = new AtomicObservableSubscription();\n+        final Scheduler _scheduler = this;\n+\n+        handler.post(new Runnable() {\n+            @Override\n+            public void run() {\n+                subscription.wrap(action.call(_scheduler, state));\n+            }\n+        });\n+        return subscription;\n+    }\n+\n+    @Override\n+    public <T> Subscription schedule(final T state, final Func2<Scheduler, T, Subscription> action, long delayTime, TimeUnit unit) {\n+        if (delayTime == 0) {\n+            return schedule(state, action);\n+        } else {\n+            final AtomicObservableSubscription subscription = new AtomicObservableSubscription();\n+            final Scheduler _scheduler = this;\n+            handler.postDelayed(new Runnable() {\n+                @Override\n+                public void run() {\n+                    subscription.wrap(action.call(_scheduler, state));\n+                }\n+            }, unit.toMillis(delayTime));\n+            return subscription;\n+        }\n+    }\n+}\n+\n+",
    "output": "Add HandlerThreadScheduler which schedules actions on an Android Handler thread"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/util/Exceptions.java b/rxjava-core/src/main/java/rx/util/Exceptions.java\n--- a/rxjava-core/src/main/java/rx/util/Exceptions.java\n+++ b/rxjava-core/src/main/java/rx/util/Exceptions.java\n@@ -21,8 +21,18 @@ private Exceptions() {\n     }\n \n     public static RuntimeException propagate(Throwable t) {\n+        /**\n+         * The return type of RuntimeException is a trick for code to be like this:\n+         * \n+         * throw Exceptions.propagate(e);\n+         * \n+         * Even though nothing will return and throw via that 'throw', it allows the code to look like it\n+         * so it's easy to read and understand that it will always result in a throw.\n+         */\n         if (t instanceof RuntimeException) {\n             throw (RuntimeException) t;\n+        } else if (t instanceof Error) {\n+            throw (Error) t;\n         } else {\n             throw new RuntimeException(t);\n         }",
    "output": "Add Error propagation now that we use Throwable"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Notification.java b/rxjava-core/src/main/java/rx/Notification.java\n--- a/rxjava-core/src/main/java/rx/Notification.java\n+++ b/rxjava-core/src/main/java/rx/Notification.java\n@@ -91,7 +91,7 @@ public boolean hasValue() {\n      * \n      * @return a value indicating whether this notification has an exception.\n      */\n-    public boolean hasException() {\n+    public boolean hasThrowable() {\n         return isOnError() && throwable != null;\n     }\n \n@@ -125,7 +125,7 @@ public String toString() {\n         StringBuilder str = new StringBuilder(\"[\").append(super.toString()).append(\" \").append(getKind());\n         if (hasValue())\n             str.append(\" \").append(getValue());\n-        if (hasException())\n+        if (hasThrowable())\n             str.append(\" \").append(getThrowable().getMessage());\n         str.append(\"]\");\n         return str.toString();\n@@ -136,7 +136,7 @@ public int hashCode() {\n         int hash = getKind().hashCode();\n         if (hasValue())\n             hash = hash * 31 + getValue().hashCode();\n-        if (hasException())\n+        if (hasThrowable())\n             hash = hash * 31 + getThrowable().hashCode();\n         return hash;\n     }\n@@ -154,7 +154,7 @@ public boolean equals(Object obj) {\n             return false;\n         if (hasValue() && !getValue().equals(notification.getValue()))\n             return false;\n-        if (hasException() && !getThrowable().equals(notification.getThrowable()))\n+        if (hasThrowable() && !getThrowable().equals(notification.getThrowable()))\n             return false;\n         return true;\n     }",
    "output": "Change hasException to hasThrowable"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaObservable.java b/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaObservable.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaObservable.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaObservable.java\n@@ -73,8 +73,9 @@ public Subscription call(final Observer<T> observer) {\n             // subscribe to the original Observable and remember the subscription\n             subscription.wrap(originalSequence.subscribe(new Observer<T>() {\n                 public void onNext(T value) {\n-                    // forward the successful calls\n-                    observer.onNext(value);\n+                    // forward the successful calls unless resumed\n+                    if (subscriptionRef.get()==subscription)\n+                        observer.onNext(value);\n                 }\n \n                 /**\n@@ -97,8 +98,9 @@ public void onError(Exception ex) {\n                 }\n \n                 public void onCompleted() {\n-                    // forward the successful calls\n-                    observer.onCompleted();\n+                    // forward the successful calls unless resumed\n+                    if (subscriptionRef.get()==subscription)\n+                        observer.onCompleted();\n                 }\n             }));\n \n@@ -119,7 +121,8 @@ public static class UnitTest {\n         @Test\n         public void testResumeNext() {\n             Subscription s = mock(Subscription.class);\n-            TestObservable w = new TestObservable(s, \"one\");\n+            // Trigger failure on second element\n+            TestObservable w = new TestObservable(s, \"one\", \"fail\", \"two\", \"three\");\n             Observable<String> resume = Observable.from(\"twoResume\", \"threeResume\");\n             Observable<String> observable = Observable.create(onErrorResumeNextViaObservable(w, resume));\n \n@@ -140,7 +143,46 @@ public void testResumeNext() {\n             verify(aObserver, Mockito.never()).onNext(\"three\");\n             verify(aObserver, times(1)).onNext(\"twoResume\");\n             verify(aObserver, times(1)).onNext(\"threeResume\");\n+        }\n+\n+        @Test\n+        public void testMapResumeAsyncNext() {\n+            Subscription sr = mock(Subscription.class);\n+            // Trigger failure on the second event\n+            Observable<String> w = Observable.from(\"one\", \"fail\", \"two\", \"three\");\n+            // Resume Observable is async\n+            TestObservable resume = new TestObservable(sr, \"twoResume\", \"threeResume\");\n+\n+            // Introduce map function that fails intermittently (Map does not prevent this when the observer is a\n+            //  rx.operator incl onErrorResumeNextViaObservable)\n+            w = w.map(new Func1<String, String>() {\n+                public String call(String s) {\n+                    if (\"fail\".equals(s))\n+                        throw new RuntimeException(\"Forced Failure\");\n+                    System.out.println(\"BadMapper:\" + s);\n+                    return s;\n+                }\n+            });\n+\n+            Observable<String> observable = Observable.create(onErrorResumeNextViaObservable(w, resume));\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Observer<String> aObserver = mock(Observer.class);\n+            observable.subscribe(aObserver);\n+\n+            try {\n+                resume.t.join();\n+            } catch (InterruptedException e) {\n+                fail(e.getMessage());\n+            }\n \n+            verify(aObserver, Mockito.never()).onError(any(Exception.class));\n+            verify(aObserver, times(1)).onCompleted();\n+            verify(aObserver, times(1)).onNext(\"one\");\n+            verify(aObserver, Mockito.never()).onNext(\"two\");\n+            verify(aObserver, Mockito.never()).onNext(\"three\");\n+            verify(aObserver, times(1)).onNext(\"twoResume\");\n+            verify(aObserver, times(1)).onNext(\"threeResume\");\n         }\n \n         private static class TestObservable extends Observable<String> {\n@@ -164,11 +206,15 @@ public void run() {\n                         try {\n                             System.out.println(\"running TestObservable thread\");\n                             for (String s : values) {\n+                                if (\"fail\".equals(s))\n+                                    throw new RuntimeException(\"Forced Failure\");\n                                 System.out.println(\"TestObservable onNext: \" + s);\n                                 observer.onNext(s);\n                             }\n-                            throw new RuntimeException(\"Forced Failure\");\n+                            System.out.println(\"TestObservable onCompleted\");\n+                            observer.onCompleted();\n                         } catch (Exception e) {\n+                            System.out.println(\"TestObservable onError: \" + e);\n                             observer.onError(e);\n                         }\n                     }",
    "output": "Fix for case where resume is async and original is still emits events after onError"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -638,7 +638,6 @@ public Subscription call(Observer<T> observer) {\n     }\n \n     /**\n-<<<<<<< HEAD\n      * Creates an Observable which produces buffers of collected values. This Observable produces connected\n      * non-overlapping buffers. The current buffer is emitted and replaced with a new buffer when the\n      * Observable produced by the specified {@link Func0} produces a {@link BufferClosing} object. The",
    "output": "Remove stray HEAD line"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationBuffer.java b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n@@ -926,6 +926,7 @@ public Subscription call(Observer<String> observer) {\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"one\", \"two\", \"three\"));\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"two\", \"three\", \"four\"));\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"three\", \"four\", \"five\"));\n+            inOrder.verify(observer, Mockito.never()).onNext(Mockito.anyListOf(String.class));\n             inOrder.verify(observer, Mockito.never()).onError(Mockito.any(Exception.class));\n             inOrder.verify(observer, Mockito.never()).onCompleted();\n         }\n@@ -951,6 +952,7 @@ public Subscription call(Observer<String> observer) {\n             InOrder inOrder = Mockito.inOrder(observer);\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"one\", \"two\", \"three\"));\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"four\", \"five\"));\n+            inOrder.verify(observer, Mockito.never()).onNext(Mockito.anyListOf(String.class));\n             inOrder.verify(observer, Mockito.never()).onError(Mockito.any(Exception.class));\n             inOrder.verify(observer, Mockito.times(1)).onCompleted();\n         }\n@@ -976,6 +978,7 @@ public Subscription call(Observer<String> observer) {\n             InOrder inOrder = Mockito.inOrder(observer);\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"one\", \"two\"));\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"four\", \"five\"));\n+            inOrder.verify(observer, Mockito.never()).onNext(Mockito.anyListOf(String.class));\n             inOrder.verify(observer, Mockito.never()).onError(Mockito.any(Exception.class));\n             inOrder.verify(observer, Mockito.times(1)).onCompleted();\n         }\n@@ -1007,6 +1010,7 @@ public Subscription call(Observer<String> observer) {\n \n             scheduler.advanceTimeTo(300, TimeUnit.MILLISECONDS);\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"five\"));\n+            inOrder.verify(observer, Mockito.never()).onNext(Mockito.anyListOf(String.class));\n             inOrder.verify(observer, Mockito.never()).onError(Mockito.any(Exception.class));\n             inOrder.verify(observer, Mockito.times(1)).onCompleted();\n         }\n@@ -1035,6 +1039,7 @@ public Subscription call(Observer<String> observer) {\n \n             scheduler.advanceTimeTo(201, TimeUnit.MILLISECONDS);\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"four\", \"five\"));\n+            inOrder.verify(observer, Mockito.never()).onNext(Mockito.anyListOf(String.class));\n             inOrder.verify(observer, Mockito.never()).onError(Mockito.any(Exception.class));\n             inOrder.verify(observer, Mockito.times(1)).onCompleted();\n         }\n@@ -1085,6 +1090,7 @@ public Subscription call(Observer<BufferClosing> observer) {\n             scheduler.advanceTimeTo(500, TimeUnit.MILLISECONDS);\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"two\", \"three\"));\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"five\"));\n+            inOrder.verify(observer, Mockito.never()).onNext(Mockito.anyListOf(String.class));\n             inOrder.verify(observer, Mockito.never()).onError(Mockito.any(Exception.class));\n             inOrder.verify(observer, Mockito.times(1)).onCompleted();\n         }\n@@ -1099,7 +1105,7 @@ public Subscription call(Observer<String> observer) {\n                     push(observer, \"three\", 110);\n                     push(observer, \"four\", 160);\n                     push(observer, \"five\", 210);\n-                    complete(observer, 500);\n+                    complete(observer, 250);\n                     return Subscriptions.empty();\n                 }\n             });\n@@ -1126,6 +1132,7 @@ public Subscription call(Observer<BufferClosing> observer) {\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"one\", \"two\"));\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"three\", \"four\"));\n             inOrder.verify(observer, Mockito.times(1)).onNext(list(\"five\"));\n+            inOrder.verify(observer, Mockito.never()).onNext(Mockito.anyListOf(String.class));\n             inOrder.verify(observer, Mockito.never()).onError(Mockito.any(Exception.class));\n             inOrder.verify(observer, Mockito.times(1)).onCompleted();\n         }",
    "output": "Improve buffer operation test cases with checks for empty buffers"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -3745,7 +3745,8 @@ private boolean isInternalImplementation(Object o) {\n         if (o instanceof AtomicObserver)\n             return true;\n         // we treat the following package as \"internal\" and don't wrap it\n-        return o.getClass().getPackage().getName().startsWith(\"rx.operators\");\n+        Package p = o.getClass().getPackage(); // it can be null\n+        return p != null && p.getName().startsWith(\"rx.operators\");\n     }\n \n     public static class UnitTest {",
    "output": "Upgrade Observable.isInternalImplementation, get rid of NullPointerException NullPointerException has been encountered during my tests. It is because java.lang.Class.getPackage() may return null \"... if no package information is available from the archive or codebase\" (documented feature)"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -2647,7 +2647,66 @@ public R call(T0 t0, T1 t1, T2 t2, T3 t3) {\n      * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png\">\n      * \n      * @param ws\n-     *            A collection of source Observable\n+     *            An Observable of source Observables\n+     * @param reduceFunction\n+     *            a function that, when applied to an item emitted by each of the source\n+     *            Observables, results in an item that will be emitted by the resulting Observable\n+     * @return an Observable that emits the zipped results\n+     */\n+    public static <R> Observable<R> zip(Observable<Observable<?>> ws, final FuncN<R> reduceFunction) {\n+        return ws.toList().mapMany(new Func1<List<Observable<?>>, Observable<R>>() {\n+            @Override\n+            public Observable<R> call(List<Observable<?>> wsList) {\n+                return create(OperationZip.zip(wsList, reduceFunction));\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Returns an Observable that emits the results of a function of your choosing applied to\n+     * combinations of four items emitted, in sequence, by four other Observables.\n+     * <p>\n+     * <code>zip</code> applies this function in strict sequence, so the first item emitted by the\n+     * new Observable will be the result of the function applied to the first item emitted by\n+     * all of the Observalbes; the second item emitted by the new Observable will be the result of\n+     * the function applied to the second item emitted by each of those Observables; and so forth.\n+     * <p>\n+     * The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke\n+     * <code>onNext</code> as many times as the number of <code>onNext</code> invocations of the\n+     * source Observable that emits the fewest items.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png\">\n+     * \n+     * @param ws\n+     *            An Observable of source Observables\n+     * @param function\n+     *            a function that, when applied to an item emitted by each of the source\n+     *            Observables, results in an item that will be emitted by the resulting Observable\n+     * @return an Observable that emits the zipped results\n+     */\n+    public static <R> Observable<R> zip(Observable<Observable<?>> ws, final Object function) {\n+        @SuppressWarnings({ \"unchecked\" })\n+        final FuncN<R> _f = Functions.from(function);\n+        return zip(ws, _f);\n+    }\n+\n+    /**\n+     * Returns an Observable that emits the results of a function of your choosing applied to\n+     * combinations of four items emitted, in sequence, by four other Observables.\n+     * <p>\n+     * <code>zip</code> applies this function in strict sequence, so the first item emitted by the\n+     * new Observable will be the result of the function applied to the first item emitted by\n+     * all of the Observalbes; the second item emitted by the new Observable will be the result of\n+     * the function applied to the second item emitted by each of those Observables; and so forth.\n+     * <p>\n+     * The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke\n+     * <code>onNext</code> as many times as the number of <code>onNext</code> invokations of the\n+     * source Observable that emits the fewest items.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png\">\n+     * \n+     * @param ws\n+     *            A collection of source Observables\n      * @param reduceFunction\n      *            a function that, when applied to an item emitted by each of the source\n      *            Observables, results in an item that will be emitted by the resulting Observable\n@@ -2673,7 +2732,7 @@ public static <R> Observable<R> zip(Collection<Observable<?>> ws, FuncN<R> reduc\n      * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png\">\n      * \n      * @param ws\n-     *            A collection of source Observable\n+     *            A collection of source Observables\n      * @param function\n      *            a function that, when applied to an item emitted by each of the source\n      *            Observables, results in an item that will be emitted by the resulting Observable",
    "output": "Add zip(Ob<Ob<?>>)"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationBuffer.java b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n@@ -189,7 +189,7 @@ public Subscription call(final Observer<List<T>> observer) {\n      *            the {@link Func1} object representing the specified buffer operation.\n      */\n     public static <T> Func1<Observer<List<T>>, Subscription> buffer(Observable<T> source, long timespan, TimeUnit unit) {\n-        return buffer(source, timespan, unit, Schedulers.newThread());\n+        return buffer(source, timespan, unit, Schedulers.threadPoolForComputation());\n     }\n \n     /**\n@@ -247,7 +247,7 @@ public Subscription call(final Observer<List<T>> observer) {\n      *            the {@link Func1} object representing the specified buffer operation.\n      */\n     public static <T> Func1<Observer<List<T>>, Subscription> buffer(Observable<T> source, long timespan, TimeUnit unit, int count) {\n-        return buffer(source, timespan, unit, count, Schedulers.newThread());\n+        return buffer(source, timespan, unit, count, Schedulers.threadPoolForComputation());\n     }\n \n     /**\n@@ -308,7 +308,7 @@ public Subscription call(final Observer<List<T>> observer) {\n      *            the {@link Func1} object representing the specified buffer operation.\n      */\n     public static <T> Func1<Observer<List<T>>, Subscription> buffer(Observable<T> source, long timespan, long timeshift, TimeUnit unit) {\n-        return buffer(source, timespan, timeshift, unit, Schedulers.newThread());\n+        return buffer(source, timespan, timeshift, unit, Schedulers.threadPoolForComputation());\n     }\n \n     /**\n@@ -370,7 +370,6 @@ public void onError(Exception e) {\n             creator.stop();\n             buffers.emitAllBuffers();\n             observer.onError(e);\n-            e.printStackTrace();\n         }\n \n         @Override",
    "output": "Change default scheduler used in buffer operation and removed printStackTrace call"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -21,6 +21,7 @@\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.CountDownLatch;\n@@ -2630,6 +2631,60 @@ public R call(T0 t0, T1 t1, T2 t2, T3 t3) {\n         });\n     }\n \n+    /**\n+     * Returns an Observable that emits the results of a function of your choosing applied to\n+     * combinations of four items emitted, in sequence, by four other Observables.\n+     * <p>\n+     * <code>zip</code> applies this function in strict sequence, so the first item emitted by the\n+     * new Observable will be the result of the function applied to the first item emitted by\n+     * all of the Observalbes; the second item emitted by the new Observable will be the result of\n+     * the function applied to the second item emitted by each of those Observables; and so forth.\n+     * <p>\n+     * The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke\n+     * <code>onNext</code> as many times as the number of <code>onNext</code> invokations of the\n+     * source Observable that emits the fewest items.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png\">\n+     * \n+     * @param ws\n+     *            A collection of source Observable\n+     * @param reduceFunction\n+     *            a function that, when applied to an item emitted by each of the source\n+     *            Observables, results in an item that will be emitted by the resulting Observable\n+     * @return an Observable that emits the zipped results\n+     */\n+    public static <R> Observable<R> zip(Collection<Observable<?>> ws, FuncN<R> reduceFunction) {\n+        return create(OperationZip.zip(ws, reduceFunction));\n+    }\n+\n+    /**\n+     * Returns an Observable that emits the results of a function of your choosing applied to\n+     * combinations of four items emitted, in sequence, by four other Observables.\n+     * <p>\n+     * <code>zip</code> applies this function in strict sequence, so the first item emitted by the\n+     * new Observable will be the result of the function applied to the first item emitted by\n+     * all of the Observalbes; the second item emitted by the new Observable will be the result of\n+     * the function applied to the second item emitted by each of those Observables; and so forth.\n+     * <p>\n+     * The resulting <code>Observable<R></code> returned from <code>zip</code> will invoke\n+     * <code>onNext</code> as many times as the number of <code>onNext</code> invocations of the\n+     * source Observable that emits the fewest items.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png\">\n+     * \n+     * @param ws\n+     *            A collection of source Observable\n+     * @param function\n+     *            a function that, when applied to an item emitted by each of the source\n+     *            Observables, results in an item that will be emitted by the resulting Observable\n+     * @return an Observable that emits the zipped results\n+     */\n+    public static <R> Observable<R> zip(Collection<Observable<?>> ws, final Object function) {\n+        @SuppressWarnings({ \"unchecked\" })\n+        final FuncN<R> _f = Functions.from(function);\n+        return zip(ws, _f);\n+    }\n+\n     /**\n      * Filters an Observable by discarding any items it emits that do not meet some test.\n      * <p>\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationZip.java b/rxjava-core/src/main/java/rx/operators/OperationZip.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationZip.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationZip.java\n@@ -19,6 +19,7 @@\n import static org.mockito.Mockito.*;\n \n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -63,6 +64,16 @@ public static <T0, T1, T2, T3, R> Func1<Observer<R>, Subscription> zip(Observabl\n         return a;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public static <R> Func1<Observer<R>, Subscription> zip(Collection<Observable<?>> ws, FuncN<R> zipFunction) {\n+        Aggregator a = new Aggregator(zipFunction);\n+        for (Observable<?> w : ws) {\n+            ZipObserver zipObserver = new ZipObserver(a, w);\n+            a.addObserver(zipObserver);\n+        }\n+        return a;\n+    }\n+\n     /*\n      * ThreadSafe\n      */",
    "output": "Add zip of a collection of Observables"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -1294,6 +1294,28 @@ public static <K, T, R> Observable<GroupedObservable<K, R>> groupBy(Observable<T\n         return create(OperationGroupBy.groupBy(source, keySelector, elementSelector));\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n+    public static <K, T, R> Observable<GroupedObservable<K, R>> groupBy(Observable<T> source, final Object keySelector, final Object elementSelector) {\n+        final FuncN _k = Functions.from(keySelector);\n+        final FuncN _e = Functions.from(elementSelector);\n+\n+        return groupBy(source, new Func1<T, K>() {\n+\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public K call(T t1) {\n+                return (K) _k.call(t1);\n+            }\n+        }, new Func1<T, R>() {\n+\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public R call(T t1) {\n+                return (R) _e.call(t1);\n+            }\n+        });\n+    }\n+\n     /**\n      * Groups the items emitted by an Observable according to a specified criteria, and emits these\n      * grouped items as Observables, one Observable per group.\n@@ -1314,6 +1336,20 @@ public static <K, T, R> Observable<GroupedObservable<K, R>> groupBy(Observable<T\n     public static <K, T> Observable<GroupedObservable<K, T>> groupBy(Observable<T> source, final Func1<T, K> keySelector) {\n         return create(OperationGroupBy.groupBy(source, keySelector));\n     }\n+    \n+    @SuppressWarnings(\"rawtypes\")\n+    public static <K, T> Observable<GroupedObservable<K, T>> groupBy(Observable<T> source, final Object keySelector) {\n+        final FuncN _k = Functions.from(keySelector);\n+\n+        return groupBy(source, new Func1<T, K>() {\n+\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public K call(T t1) {\n+                return (K) _k.call(t1);\n+            }\n+        });\n+    }\n \n     /**\n      * This behaves like <code>merge</code> except that if any of the merged Observables notify\n@@ -3560,6 +3596,10 @@ public Observable<T> startWith(T... values) {\n     public <K, R> Observable<GroupedObservable<K, R>> groupBy(final Func1<T, K> keySelector, final Func1<T, R> elementSelector) {\n         return groupBy(this, keySelector, elementSelector);\n     }\n+    \n+    public <K, R> Observable<GroupedObservable<K, R>> groupBy(final Object keySelector, final Object elementSelector) {\n+        return groupBy(this, keySelector, elementSelector);\n+    }\n \n     /**\n      * Groups the items emitted by an Observable according to a specified criteria, and emits these\n@@ -3578,6 +3618,10 @@ public <K, R> Observable<GroupedObservable<K, R>> groupBy(final Func1<T, K> keyS\n     public <K> Observable<GroupedObservable<K, T>> groupBy(final Func1<T, K> keySelector) {\n         return groupBy(this, keySelector);\n     }\n+    \n+    public <K> Observable<GroupedObservable<K, T>> groupBy(final Object keySelector) {\n+        return groupBy(this, keySelector);\n+    }\n \n     /**\n      * Converts an Observable into a BlockingObservable (an Observable with blocking operators).",
    "output": "Add Object overloads for dynamic language support.\n\nNeed these until we finish work at https://github.com/Netflix/RxJava/issues/204"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationBuffer.java b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n@@ -1,3 +1,18 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package rx.operators;\n \n import java.util.ArrayList;\n@@ -925,8 +940,8 @@ public Subscription call(Observer<String> observer) {\n             Observable<BufferOpening> openings = Observable.create(new Func1<Observer<BufferOpening>, Subscription>() {\n                 @Override\n                 public Subscription call(Observer<BufferOpening> observer) {\n-                    push(observer, new BufferOpenings(), 50);\n-                    push(observer, new BufferOpenings(), 200);\n+                    push(observer, BufferOpenings.create(), 50);\n+                    push(observer, BufferOpenings.create(), 200);\n                     complete(observer, 250);\n                     return Subscriptions.empty();\n                 }\n@@ -938,7 +953,7 @@ public Observable<BufferClosing> call(BufferOpening opening) {\n                     return Observable.create(new Func1<Observer<BufferClosing>, Subscription>() {\n                         @Override\n                         public Subscription call(Observer<BufferClosing> observer) {\n-                            push(observer, new BufferClosings(), 100);\n+                            push(observer, BufferClosings.create(), 100);\n                             complete(observer, 101);\n                             return Subscriptions.empty();\n                         }\n@@ -978,7 +993,7 @@ public Observable<BufferClosing> call() {\n                     return Observable.create(new Func1<Observer<BufferClosing>, Subscription>() {\n                         @Override\n                         public Subscription call(Observer<BufferClosing> observer) {\n-                            push(observer, new BufferClosings(), 100);\n+                            push(observer, BufferClosings.create(), 100);\n                             complete(observer, 101);\n                             return Subscriptions.empty();\n                         }",
    "output": "Add license header to OperationBuffer"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationBuffer.java b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationBuffer.java\n@@ -722,11 +722,25 @@ public interface BufferClosing {\n         // Tagging interface for objects which can close buffers.\n     }\n \n-    public static class BufferOpenings implements BufferOpening {\n-        // Simple class implementing BufferOpening for conveniance.\n+    public static class BufferOpenings {\n+\n+        public static BufferOpening create() {\n+            return new BufferOpening() {};\n+        }\n+\n+        private BufferOpenings() {\n+            // Prevent instantation.\n+        }\n     }\n-    public static class BufferClosings implements BufferClosing {\n-        // Simple class implementing BufferClosing for conveniance.\n+    public static class BufferClosings {\n+\n+        public static BufferClosing create() {\n+            return new BufferClosing() {};\n+        }\n+\n+        private BufferClosings() {\n+            // Prevent instantation.\n+        }\n     }\n \n     public static class UnitTest {",
    "output": "Add static create methods to BufferOpenings and BufferClosings"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java b/rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java\n--- a/rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java\n+++ b/rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java\n@@ -15,15 +15,19 @@\n  */\n package rx.subscriptions;\n \n+import static org.junit.Assert.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.junit.Test;\n \n import rx.Subscription;\n-import rx.util.functions.Functions;\n+import rx.util.CompositeException;\n \n /**\n  * Subscription that represents a group of Subscriptions that are unsubscribed together.\n@@ -32,8 +36,6 @@\n  */\n public class CompositeSubscription implements Subscription {\n \n-    private static final Logger logger = LoggerFactory.getLogger(Functions.class);\n-\n     /*\n      * The reason 'synchronized' is used on 'add' and 'unsubscribe' is because AtomicBoolean/ConcurrentLinkedQueue are both being modified so it needs to be done atomically.\n      * \n@@ -67,13 +69,80 @@ public synchronized void add(Subscription s) {\n     @Override\n     public synchronized void unsubscribe() {\n         if (unsubscribed.compareAndSet(false, true)) {\n+            Collection<Exception> es = null;\n             for (Subscription s : subscriptions) {\n                 try {\n                     s.unsubscribe();\n                 } catch (Exception e) {\n-                    logger.error(\"Failed to unsubscribe.\", e);\n+                    if (es == null) {\n+                        es = new ArrayList<Exception>();\n+                    }\n+                    es.add(e);\n                 }\n             }\n+            if (es != null) {\n+                throw new CompositeException(\"Failed to unsubscribe to 1 or more subscriptions.\", es);\n+            }\n+        }\n+    }\n+\n+    public static class UnitTest {\n+\n+        @Test\n+        public void testSuccess() {\n+            final AtomicInteger counter = new AtomicInteger();\n+            CompositeSubscription s = new CompositeSubscription();\n+            s.add(new Subscription() {\n+\n+                @Override\n+                public void unsubscribe() {\n+                    counter.incrementAndGet();\n+                }\n+            });\n+\n+            s.add(new Subscription() {\n+\n+                @Override\n+                public void unsubscribe() {\n+                    counter.incrementAndGet();\n+                }\n+            });\n+\n+            s.unsubscribe();\n+\n+            assertEquals(2, counter.get());\n+        }\n+\n+        @Test\n+        public void testException() {\n+            final AtomicInteger counter = new AtomicInteger();\n+            CompositeSubscription s = new CompositeSubscription();\n+            s.add(new Subscription() {\n+\n+                @Override\n+                public void unsubscribe() {\n+                    throw new RuntimeException(\"failed on first one\");\n+                }\n+            });\n+\n+            s.add(new Subscription() {\n+\n+                @Override\n+                public void unsubscribe() {\n+                    counter.incrementAndGet();\n+                }\n+            });\n+\n+            try {\n+                s.unsubscribe();\n+                fail(\"Expecting an exception\");\n+            } catch (CompositeException e) {\n+                // we expect this\n+                assertEquals(1, e.getExceptions().size());\n+            }\n+\n+            // we should still have unsubscribed to the second one\n+            assertEquals(1, counter.get());\n         }\n     }\n \n\ndiff --git a/rxjava-core/src/main/java/rx/util/functions/Functions.java b/rxjava-core/src/main/java/rx/util/functions/Functions.java\n--- a/rxjava-core/src/main/java/rx/util/functions/Functions.java\n+++ b/rxjava-core/src/main/java/rx/util/functions/Functions.java\n@@ -18,9 +18,6 @@\n import java.util.Collection;\n import java.util.concurrent.ConcurrentHashMap;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n /**\n  * Allows execution of functions from multiple different languages.\n  * <p>\n@@ -30,8 +27,6 @@\n  */\n public class Functions {\n \n-    private static final Logger logger = LoggerFactory.getLogger(Functions.class);\n-\n     private final static ConcurrentHashMap<Class<?>, FunctionLanguageAdaptor> languageAdaptors = new ConcurrentHashMap<Class<?>, FunctionLanguageAdaptor>();\n \n     static {\n@@ -49,12 +44,17 @@ private static boolean loadLanguageAdaptor(String name) {\n             Class<?> c = Class.forName(className);\n             FunctionLanguageAdaptor a = (FunctionLanguageAdaptor) c.newInstance();\n             registerLanguageAdaptor(a.getFunctionClass(), a);\n-            logger.info(\"Successfully loaded function language adaptor: \" + name + \" with path: \" + className);\n+            /*\n+             * Using System.err/System.out as this is the only place in the library where we do logging and it's only at startup.\n+             * I don't want to include SL4J/Log4j just for this and no one uses Java Logging.\n+             */\n+            System.out.println(\"RxJava => Successfully loaded function language adaptor: \" + name + \" with path: \" + className);\n         } catch (ClassNotFoundException e) {\n-            logger.info(\"Could not find function language adaptor: \" + name + \" with path: \" + className);\n+            System.err.println(\"RxJava => Could not find function language adaptor: \" + name + \" with path: \" + className);\n             return false;\n         } catch (Exception e) {\n-            logger.error(\"Failed trying to initialize function language adaptor: \" + className, e);\n+            System.err.println(\"RxJava => Failed trying to initialize function language adaptor: \" + className);\n+            e.printStackTrace();\n             return false;\n         }\n         return true;",
    "output": "Remove SLF4J dependency"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationConcat.java b/rxjava-core/src/main/java/rx/operators/OperationConcat.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationConcat.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationConcat.java\n@@ -23,10 +23,12 @@\n import java.util.List;\n import java.util.Queue;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.concurrent.ConcurrentLinkedQueue;\n \n+import org.junit.Ignore;\n import org.junit.Test;\n \n import org.mockito.InOrder;\n@@ -460,6 +462,69 @@ public void testConcatConcurrentWithInfinity() {\n             \n  \t\t}\n         \n+      \n+       \n+        @Test\n+ \t\tpublic void testConcatUnSubscribeNotBlockingObservables() {\n+ \n+        \tfinal CountDownLatch okToContinueW1 = new CountDownLatch(1);\n+        \tfinal CountDownLatch okToContinueW2 = new CountDownLatch(1);\n+        \t\n+           \tfinal TestObservable<String> w1 = new TestObservable<String>(null, okToContinueW1, \"one\", \"two\", \"three\");\n+           \tfinal TestObservable<String> w2 = new TestObservable<String>(null, okToContinueW2, \"four\", \"five\", \"six\");\n+\n+             @SuppressWarnings(\"unchecked\")\n+             Observer<String> aObserver = mock(Observer.class);\n+             Observable<Observable<String>> observableOfObservables = Observable.create(new Func1<Observer<Observable<String>>, Subscription>() {\n+\n+                 @Override\n+                 public Subscription call(Observer<Observable<String>> observer) {\n+                     // simulate what would happen in an observable\n+                     observer.onNext(w1);\n+                     observer.onNext(w2);\n+                     observer.onCompleted();\n+\n+                     return new Subscription() {\n+\n+                         @Override\n+                         public void unsubscribe() {\n+                         }\n+\n+                     };\n+                 }\n+\n+             });\n+             Observable<String> concat = Observable.create(concat(observableOfObservables));           \n+         \n+             concat.subscribe(aObserver);\n+             \n+             verify(aObserver, times(0)).onCompleted();\n+\n+             \n+             //Wait for the thread to start up.\n+             try {\n+ \t\t\t\tThread.sleep(25);\n+ \t\t\t\tw1.t.join();\n+ \t\t\t\tw2.t.join();\n+ \t\t\t\tokToContinueW1.countDown();\n+ \t\t\t\tokToContinueW2.countDown();\n+\t\t\t} catch (InterruptedException e) {\n+ \t\t\t\t// TODO Auto-generated catch block\n+ \t\t\t\te.printStackTrace();\n+ \t\t\t}\n+             \n+            InOrder inOrder = inOrder(aObserver);\n+            inOrder.verify(aObserver, times(1)).onNext(\"one\");   \n+            inOrder.verify(aObserver, times(1)).onNext(\"two\");\n+            inOrder.verify(aObserver, times(1)).onNext(\"three\");\n+            inOrder.verify(aObserver, times(1)).onNext(\"four\");   \n+            inOrder.verify(aObserver, times(1)).onNext(\"five\");\n+            inOrder.verify(aObserver, times(1)).onNext(\"six\");\n+            verify(aObserver, times(1)).onCompleted();\n+          \n+             \n+  \t\t}\n+        \n         \n         /**\n          * Test unsubscribing the concatenated Observable in a single thread.\n@@ -608,7 +673,7 @@ public void run() {\n                                         once.countDown();\n                                     //Block until the main thread has called unsubscribe.\n                                     if (null != okToContinue)\n-                                        okToContinue.await();\n+                                        okToContinue.await(1, TimeUnit.SECONDS);\n                                 }\n                                 if (subscribed)\n                                     observer.onCompleted();",
    "output": "Add new unit test to check for non-blocking"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationConcat.java b/rxjava-core/src/main/java/rx/operators/OperationConcat.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationConcat.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationConcat.java\n@@ -36,7 +36,7 @@\n import rx.Subscription;\n import rx.subscriptions.BooleanSubscription;\n import rx.util.AtomicObservableSubscription;\n-import rx.util.Exceptions;\n+\n import rx.util.functions.Func1;\n \n public final class OperationConcat {\n@@ -460,6 +460,38 @@ public void testConcatConcurrentWithInfinity() {\n             \n  \t\t}\n         \n+        @Test\n+ \t\tpublic void testConcatConcurrentWithInfinityFirstSequence() {\n+             final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\");\n+             //This observable will send \"hello\" MAX_VALUE time.\n+             final TestObservable<String> w2 = new TestObservable<String>(\"hello\", Integer.MAX_VALUE);\n+\n+             @SuppressWarnings(\"unchecked\")\n+             Observer<String> aObserver = mock(Observer.class);\n+             @SuppressWarnings(\"unchecked\")\n+  \t\t\t TestObservable<Observable<String>> observableOfObservables = new TestObservable<Observable<String>>(w2, w1);\n+             Func1<Observer<String>, Subscription> concatF = concat(observableOfObservables);\n+             \n+             Observable<String> concat = Observable.create(concatF);\n+             \n+             concat.take(50).subscribe(aObserver);\n+\n+             //Wait for the thread to start up.\n+             try {\n+ \t\t\t\tThread.sleep(25);\n+ \t\t\t\tw2.t.join();\n+\t\t\t} catch (InterruptedException e) {\n+ \t\t\t\t// TODO Auto-generated catch block\n+ \t\t\t\te.printStackTrace();\n+ \t\t\t}\n+             \n+             InOrder inOrder = inOrder(aObserver);\n+             inOrder.verify(aObserver, times(50)).onNext(\"hello\");\n+             verify(aObserver, times(1)).onCompleted();\n+             verify(aObserver, never()).onError(any(Exception.class));\n+             \n+  \t\t}\n+        \n         \n         /**\n          * Test unsubscribing the concatenated Observable in a single thread.",
    "output": "Add new unit test to cover infinite observable being the first sequence"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/concurrency/SwingScheduler.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/concurrency/SwingScheduler.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/concurrency/SwingScheduler.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/concurrency/SwingScheduler.java\n@@ -15,12 +15,13 @@\n  */\n package rx.concurrency;\n \n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n \n import java.awt.EventQueue;\n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicReference;\n \n@@ -41,7 +42,7 @@\n import rx.util.functions.Func2;\n \n /**\n- * Executes work on the Swing UI thread. \n+ * Executes work on the Swing UI thread.\n  * This scheduler should only be used with actions that execute quickly.\n  */\n public final class SwingScheduler extends Scheduler {\n@@ -77,33 +78,33 @@ public void call() {\n     @Override\n     public <T> Subscription schedule(final T state, final Func2<Scheduler, T, Subscription> action, long dueTime, TimeUnit unit) {\n         final AtomicReference<Subscription> sub = new AtomicReference<Subscription>();\n-        long delay = unit.toMillis(dueTime); \n+        long delay = unit.toMillis(dueTime);\n         assertThatTheDelayIsValidForTheSwingTimer(delay);\n-        \n+\n         class ExecuteOnceAction implements ActionListener {\n             private Timer timer;\n-            \n+\n             private void setTimer(Timer timer) {\n                 this.timer = timer;\n             }\n-            \n+\n             @Override\n             public void actionPerformed(ActionEvent e) {\n                 timer.stop();\n                 sub.set(action.call(SwingScheduler.this, state));\n             }\n         }\n-        \n+\n         ExecuteOnceAction executeOnce = new ExecuteOnceAction();\n         final Timer timer = new Timer((int) delay, executeOnce);\n         executeOnce.setTimer(timer);\n         timer.start();\n-        \n+\n         return Subscriptions.create(new Action0() {\n             @Override\n             public void call() {\n                 timer.stop();\n-                \n+\n                 Subscription subscription = sub.get();\n                 if (subscription != null) {\n                     subscription.unsubscribe();\n@@ -115,28 +116,28 @@ public void call() {\n     @Override\n     public <T> Subscription schedulePeriodically(T state, final Func2<Scheduler, T, Subscription> action, long initialDelay, long period, TimeUnit unit) {\n         final AtomicReference<Timer> timer = new AtomicReference<Timer>();\n-        \n-        final long delay = unit.toMillis(period); \n+\n+        final long delay = unit.toMillis(period);\n         assertThatTheDelayIsValidForTheSwingTimer(delay);\n-        \n+\n         final CompositeSubscription subscriptions = new CompositeSubscription();\n         final Func2<Scheduler, T, Subscription> initialAction = new Func2<Scheduler, T, Subscription>() {\n-              @Override\n-              public Subscription call(final Scheduler scheduler, final T state0) {\n-                  // start timer for periodic execution, collect subscriptions\n-                  timer.set(new Timer((int) delay, new ActionListener() {\n-                      @Override\n-                      public void actionPerformed(ActionEvent e) {\n-                          subscriptions.add(action.call(scheduler,  state0));\n-                      }\n-                  }));\n-                  timer.get().start();\n-                  \n-                  return action.call(scheduler, state0);\n-              }\n+            @Override\n+            public Subscription call(final Scheduler scheduler, final T state0) {\n+                // start timer for periodic execution, collect subscriptions\n+                timer.set(new Timer((int) delay, new ActionListener() {\n+                    @Override\n+                    public void actionPerformed(ActionEvent e) {\n+                        subscriptions.add(action.call(scheduler, state0));\n+                    }\n+                }));\n+                timer.get().start();\n+\n+                return action.call(scheduler, state0);\n+            }\n         };\n         subscriptions.add(schedule(state, initialAction, initialDelay, unit));\n-        \n+\n         subscriptions.add(Subscriptions.create(new Action0() {\n             @Override\n             public void call() {\n@@ -147,7 +148,7 @@ public void call() {\n                 }\n             }\n         }));\n-        \n+\n         return subscriptions;\n     }\n \n@@ -156,11 +157,11 @@ private static void assertThatTheDelayIsValidForTheSwingTimer(long delay) {\n             throw new IllegalArgumentException(String.format(\"The swing timer only accepts non-negative delays up to %d milliseconds.\", Integer.MAX_VALUE));\n         }\n     }\n-    \n+\n     public static class UnitTest {\n         @Rule\n         public ExpectedException exception = ExpectedException.none();\n-        \n+\n         @Test\n         public void testInvalidDelayValues() {\n             final SwingScheduler scheduler = new SwingScheduler();\n@@ -174,34 +175,44 @@ public void testInvalidDelayValues() {\n \n             exception.expect(IllegalArgumentException.class);\n             scheduler.schedulePeriodically(action, 1L + Integer.MAX_VALUE, 100L, TimeUnit.MILLISECONDS);\n-            \n+\n             exception.expect(IllegalArgumentException.class);\n             scheduler.schedulePeriodically(action, 100L, 1L + Integer.MAX_VALUE / 1000, TimeUnit.SECONDS);\n         }\n-        \n+\n         @Test\n         public void testPeriodicScheduling() throws Exception {\n             final SwingScheduler scheduler = new SwingScheduler();\n \n+            final CountDownLatch latch = new CountDownLatch(4);\n+\n             final Action0 innerAction = mock(Action0.class);\n             final Action0 unsubscribe = mock(Action0.class);\n             final Func0<Subscription> action = new Func0<Subscription>() {\n                 @Override\n                 public Subscription call() {\n-                    innerAction.call();\n-                    assertTrue(SwingUtilities.isEventDispatchThread());\n-                    return Subscriptions.create(unsubscribe);\n+                    try {\n+                        innerAction.call();\n+                        assertTrue(SwingUtilities.isEventDispatchThread());\n+                        return Subscriptions.create(unsubscribe);\n+                    } finally {\n+                        latch.countDown();\n+                    }\n                 }\n             };\n-            \n+\n             Subscription sub = scheduler.schedulePeriodically(action, 50, 200, TimeUnit.MILLISECONDS);\n-            Thread.sleep(840);\n+\n+            if (!latch.await(5000, TimeUnit.MILLISECONDS)) {\n+                fail(\"timed out waiting for tasks to execute\");\n+            }\n+\n             sub.unsubscribe();\n             waitForEmptyEventQueue();\n             verify(innerAction, times(4)).call();\n             verify(unsubscribe, times(4)).call();\n         }\n-        \n+\n         @Test\n         public void testNestedActions() throws Exception {\n             final SwingScheduler scheduler = new SwingScheduler();",
    "output": "Make unit test more deterministic"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/ScheduledObserver.java b/rxjava-core/src/main/java/rx/operators/ScheduledObserver.java\n--- a/rxjava-core/src/main/java/rx/operators/ScheduledObserver.java\n+++ b/rxjava-core/src/main/java/rx/operators/ScheduledObserver.java\n@@ -15,16 +15,21 @@\n  */\n package rx.operators;\n \n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n import rx.Notification;\n import rx.Observer;\n import rx.Scheduler;\n-import rx.concurrency.Schedulers;\n import rx.util.functions.Action0;\n \n /* package */class ScheduledObserver<T> implements Observer<T> {\n     private final Observer<T> underlying;\n     private final Scheduler scheduler;\n \n+    private final ConcurrentLinkedQueue<Notification<T>> queue = new ConcurrentLinkedQueue<Notification<T>>();\n+    private final AtomicInteger counter = new AtomicInteger(0);\n+\n     public ScheduledObserver(Observer<T> underlying, Scheduler scheduler) {\n         this.underlying = underlying;\n         this.scheduler = scheduler;\n@@ -41,38 +46,50 @@ public void onError(final Exception e) {\n     }\n \n     @Override\n-    public void onNext(final T v) {\n-        enqueue(new Notification<T>(v));\n+    public void onNext(final T args) {\n+        enqueue(new Notification<T>(args));\n     }\n \n-    private void enqueue(final Notification<T> notification) {\n+    private void enqueue(Notification<T> notification) {\n+        // this must happen before 'counter' is used to provide synchronization between threads\n+        queue.offer(notification);\n \n-        Schedulers.currentThread().schedule(new Action0() {\n+        // we now use counter to atomically determine if we need to start processing or not\n+        // it will be 0 if it's the first notification or the scheduler has finished processing work\n+        // and we need to start doing it again\n+        if (counter.getAndIncrement() == 0) {\n+            processQueue();\n+        }\n+    }\n+\n+    private void processQueue() {\n+        scheduler.schedule(new Action0() {\n             @Override\n             public void call() {\n+                Notification<T> not = queue.poll();\n \n-                scheduler.schedule(new Action0() {\n-                    @Override\n-                    public void call() {\n-                        switch (notification.getKind()) {\n-                        case OnNext:\n-                            underlying.onNext(notification.getValue());\n-                            break;\n-                        case OnError:\n-                            underlying.onError(notification.getException());\n-                            break;\n-                        case OnCompleted:\n-                            underlying.onCompleted();\n-                            break;\n-                        default:\n-                            throw new IllegalStateException(\"Unknown kind of notification \" + notification);\n+                switch (not.getKind()) {\n+                case OnNext:\n+                    underlying.onNext(not.getValue());\n+                    break;\n+                case OnError:\n+                    underlying.onError(not.getException());\n+                    break;\n+                case OnCompleted:\n+                    underlying.onCompleted();\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown kind of notification \" + not);\n \n-                        }\n-                    }\n-                });\n-            }\n+                }\n \n-        });\n-    };\n+                // decrement count and if we still have work to do\n+                // recursively schedule ourselves to process again\n+                if (counter.decrementAndGet() > 0) {\n+                    scheduler.schedule(this);\n+                }\n \n+            }\n+        });\n+    }\n }",
    "output": "Fix concurrency bug in ScheduledObserver\n\nThis is a followup to https://github.com/Netflix/RxJava/commit/1fa6ae3be23200c787cc1c25c0bb8cac99ae0d17 that fixed one issue (concurrency) and created another (broke Rx contract by allowing concurrent execution of onNext).\n\nI have reverted back to the previous implementatio and then attempted to fix the concurrency issue again.\n\nI think it ended up being a simple fix … just re-ordering the `enqueue` method to remove the race-condition between the logic protected by the AtomicInteger and adding to the queue.\n\nIt's not an atomic operation (adding then processing) so we need to just add to the queue and treat it as an async data structure and keep the AtomicInteger portion to only protecting the \"process or not process\" logic.\n\n```java\n        // this must happen before 'counter' is used to provide synchronization between threads\n        queue.offer(notification);\n```\n\nThis may still have issues but it's now working in all of my concurrency tests (the ones that broken with the original and then my modified version). The tests are not easy to build unit tests out of as they require running for many seconds and non-deterministically causing a race condition so I have not yet spend the time to try and figure out a deterministic unit test hence them not being committed"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java\n@@ -30,6 +30,7 @@\n import rx.Observer;\n import rx.Scheduler;\n import rx.Subscription;\n+import rx.concurrency.ImmediateScheduler;\n import rx.concurrency.Schedulers;\n import rx.util.functions.Func1;\n \n@@ -50,7 +51,12 @@ public ObserveOn(Observable<T> source, Scheduler scheduler) {\n \n         @Override\n         public Subscription call(final Observer<T> observer) {\n-            return source.subscribe(new ScheduledObserver<T>(observer, scheduler));\n+            if (scheduler instanceof ImmediateScheduler) {\n+                // do nothing if we request ImmediateScheduler so we don't invoke overhead\n+                return source.subscribe(observer);\n+            } else {\n+                return source.subscribe(new ScheduledObserver<T>(observer, scheduler));\n+            }\n         }\n     }\n \n\ndiff --git a/rxjava-core/src/main/java/rx/operators/ScheduledObserver.java b/rxjava-core/src/main/java/rx/operators/ScheduledObserver.java\n--- a/rxjava-core/src/main/java/rx/operators/ScheduledObserver.java\n+++ b/rxjava-core/src/main/java/rx/operators/ScheduledObserver.java\n@@ -1,12 +1,12 @@\n /**\n  * Copyright 2013 Netflix, Inc.\n- *\n+ * \n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n+ * \n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * \n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -18,18 +18,13 @@\n import rx.Notification;\n import rx.Observer;\n import rx.Scheduler;\n+import rx.concurrency.Schedulers;\n import rx.util.functions.Action0;\n \n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n /* package */class ScheduledObserver<T> implements Observer<T> {\n     private final Observer<T> underlying;\n     private final Scheduler scheduler;\n \n-    private final ConcurrentLinkedQueue<Notification<T>> queue = new ConcurrentLinkedQueue<Notification<T>>();\n-    private final AtomicInteger counter = new AtomicInteger(0);\n-\n     public ScheduledObserver(Observer<T> underlying, Scheduler scheduler) {\n         this.underlying = underlying;\n         this.scheduler = scheduler;\n@@ -46,47 +41,38 @@ public void onError(final Exception e) {\n     }\n \n     @Override\n-    public void onNext(final T args) {\n-        enqueue(new Notification<T>(args));\n+    public void onNext(final T v) {\n+        enqueue(new Notification<T>(v));\n     }\n \n-    private void enqueue(Notification<T> notification) {\n-        int count = counter.getAndIncrement();\n-\n-        queue.offer(notification);\n+    private void enqueue(final Notification<T> notification) {\n \n-        if (count == 0) {\n-            processQueue();\n-        }\n-    }\n-\n-    private void processQueue() {\n-        scheduler.schedule(new Action0() {\n+        Schedulers.currentThread().schedule(new Action0() {\n             @Override\n             public void call() {\n-                Notification<T> not = queue.poll();\n-\n-                switch (not.getKind()) {\n-                    case OnNext:\n-                        underlying.onNext(not.getValue());\n-                        break;\n-                    case OnError:\n-                        underlying.onError(not.getException());\n-                        break;\n-                    case OnCompleted:\n-                        underlying.onCompleted();\n-                        break;\n-                    default:\n-                        throw new IllegalStateException(\"Unknown kind of notification \" + not);\n-\n-                }\n-\n-                int count = counter.decrementAndGet();\n-                if (count > 0) {\n-                    scheduler.schedule(this);\n-                }\n \n+                scheduler.schedule(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        switch (notification.getKind()) {\n+                        case OnNext:\n+                            underlying.onNext(notification.getValue());\n+                            break;\n+                        case OnError:\n+                            underlying.onError(notification.getException());\n+                            break;\n+                        case OnCompleted:\n+                            underlying.onCompleted();\n+                            break;\n+                        default:\n+                            throw new IllegalStateException(\"Unknown kind of notification \" + notification);\n+\n+                        }\n+                    }\n+                });\n             }\n+\n         });\n-    }\n+    };\n+\n }",
    "output": "Fix concurrency bug in ScheduledObserver - found a concurrency bug while working on https://github.com/Netflix/Hystrix/issues/123 - the following code would lock up occasionally due to onCompleted not being delivered: ```java public class RunTest { public static void main(String[] args) { System.out.println(\"Starting test...\"); final ArrayList<String> strings = new ArrayList<String>(200000); int num = 10000; while (true) { long start = System.currentTimeMillis(); final AtomicInteger count = new AtomicInteger(); for (int i = 0; i < num; i++) { new TestService1(2, 5).toObservable().forEach(new Action1<Integer>() { @Override public void call(Integer v) { count.addAndGet(v); } }); new TestService2(\"hello\").toObservable().forEach(new Action1<String>() { @Override public void call(String v) { strings.add(v); } }); } long time = (System.currentTimeMillis() - start); long executions = num * 2; System.out.println(\"Time: \" + time + \"ms for \" + executions + \" executions (\" + (time * 1000) / executions + \" microseconds)\"); System.out.println(\" Count: \" + count); System.out.println(\" Strings: \" + strings.size()); strings.clear(); } } } ``` - Also made OperationObserveOn not use ScheduledObserver if the `ImmediateScheduler` is chosen to allow an optimization. I believe this optimization is safe because ScheduledObserver does not require knowledge of a Scheduler (such as for now()) and all we do is emit data to the Observer on a scheduler and if we know it's Immediate we can go direct and skip the enqueuing step. This allows shaving off a noticable number of microseconds per execution in the loop above"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -2749,21 +2749,21 @@ public R call(T0 t0, T1 t1, T2 t2, T3 t3) {\n      *          The aggregation function used to combine the source observable values.\n      * @return A function from an observer to a subscription. This can be used to create an observable from.\n      */\n-    public static <R, T0, T1> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> combineFunction) {\n+    public static <R, T0, T1> Observable<R> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Func2<? super T0, ? super T1, ? extends R> combineFunction) {\n         return create(OperationCombineLatest.combineLatest(w0, w1, combineFunction));\n     }\n     \n     /**\n      * @see #combineLatest(Observable, Observable, Func2)\n      */\n-    public static <R, T0, T1, T2> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Func3<T0, T1, T2, R> combineFunction) {\n+    public static <R, T0, T1, T2> Observable<R> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Observable<? super T2> w2, Func3<? super T0, ? super T1, ? super T2, ? extends R> combineFunction) {\n         return create(OperationCombineLatest.combineLatest(w0, w1, w2, combineFunction));\n     }\n \n     /**\n      * @see #combineLatest(Observable, Observable, Func2)\n      */\n-    public static <R, T0, T1, T2, T3> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Observable<T3> w3, Func4<T0, T1, T2, T3, R> combineFunction) {\n+    public static <R, T0, T1, T2, T3> Observable<R> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Observable<? super T2> w2, Observable<? super T3> w3, Func4<? super T0, ? super T1, ? super T2, ? super T3, ? extends R> combineFunction) {\n         return create(OperationCombineLatest.combineLatest(w0, w1, w2, w3, combineFunction));\n     }\n     \n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java\n@@ -54,7 +54,7 @@ public class OperationCombineLatest {\n      *          The aggregation function used to combine the source observable values.\n      * @return A function from an observer to a subscription. This can be used to create an observable from.\n      */\n-    public static <T0, T1, R> Func1<Observer<R>, Subscription> combineLatest(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> combineLatestFunction) {\n+    public static <T0, T1, R> Func1<Observer<? super R>, Subscription> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Func2<? super T0, ? super T1, ? extends R> combineLatestFunction) {\n         Aggregator<R> a = new Aggregator<R>(Functions.fromFunc(combineLatestFunction));\n         a.addObserver(new CombineObserver<R, T0>(a, w0));\n         a.addObserver(new CombineObserver<R, T1>(a, w1));\n@@ -64,7 +64,7 @@ public static <T0, T1, R> Func1<Observer<R>, Subscription> combineLatest(Observa\n     /**\n      * @see #combineLatest(Observable w0, Observable w1, Func2 combineLatestFunction)\n      */\n-    public static <T0, T1, T2, R> Func1<Observer<R>, Subscription> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Func3<T0, T1, T2, R> combineLatestFunction) {\n+    public static <T0, T1, T2, R> Func1<Observer<? super R>, Subscription> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Observable<? super T2> w2, Func3<? super T0, ? super T1, ? super T2, ? extends R> combineLatestFunction) {\n         Aggregator<R> a = new Aggregator<R>(Functions.fromFunc(combineLatestFunction));\n         a.addObserver(new CombineObserver<R, T0>(a, w0));\n         a.addObserver(new CombineObserver<R, T1>(a, w1));\n@@ -75,7 +75,7 @@ public static <T0, T1, T2, R> Func1<Observer<R>, Subscription> combineLatest(Obs\n     /**\n      * @see #combineLatest(Observable w0, Observable w1, Func2 combineLatestFunction)\n      */\n-    public static <T0, T1, T2, T3, R> Func1<Observer<R>, Subscription> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Observable<T3> w3, Func4<T0, T1, T2, T3, R> combineLatestFunction) {\n+    public static <T0, T1, T2, T3, R> Func1<Observer<? super R>, Subscription> combineLatest(Observable<? super T0> w0, Observable<? super T1> w1, Observable<? super T2> w2, Observable<? super T3> w3, Func4<? super T0, ? super T1, ? super T2, ? super T3, ? extends R> combineLatestFunction) {\n         Aggregator<R> a = new Aggregator<R>(Functions.fromFunc(combineLatestFunction));\n         a.addObserver(new CombineObserver<R, T0>(a, w0));\n         a.addObserver(new CombineObserver<R, T1>(a, w1));\n@@ -85,11 +85,11 @@ public static <T0, T1, T2, T3, R> Func1<Observer<R>, Subscription> combineLatest\n     }\n \n     private static class CombineObserver<R, T> implements Observer<T> {\n-        final Observable<T> w;\n-        final Aggregator<R> a;\n+        final Observable<? super T> w;\n+        final Aggregator<? super R> a;\n         private Subscription subscription;\n \n-        public CombineObserver(Aggregator<R> a, Observable<T> w) {\n+        public CombineObserver(Aggregator<? super R> a, Observable<? super T> w) {\n             this.a = a;\n             this.w = w;\n         }\n@@ -122,11 +122,11 @@ public void onNext(T args) {\n      * whenever we have received an event from one of the observables, as soon as each Observable has received \n      * at least one event.\n      */\n-    private static class Aggregator<R> implements Func1<Observer<R>, Subscription> {\n+    private static class Aggregator<R> implements Func1<Observer<? super R>, Subscription> {\n \n-        private Observer<R> observer;\n+        private Observer<? super R> observer;\n \n-        private final FuncN<R> combineLatestFunction;\n+        private final FuncN<? extends R> combineLatestFunction;\n         private final AtomicBoolean running = new AtomicBoolean(true);\n         \n         // Stores how many observers have already completed\n@@ -135,15 +135,15 @@ private static class Aggregator<R> implements Func1<Observer<R>, Subscription> {\n         /**\n          * The latest value from each observer.\n          */\n-        private final Map<CombineObserver<R, ?>, Object> latestValue = new ConcurrentHashMap<CombineObserver<R, ?>, Object>();\n+        private final Map<CombineObserver<? extends R, ?>, Object> latestValue = new ConcurrentHashMap<CombineObserver<? extends R, ?>, Object>();\n         \n         /**\n          * Ordered list of observers to combine.\n          * No synchronization is necessary as these can not be added or changed asynchronously.\n          */\n         private final List<CombineObserver<R, ?>> observers = new LinkedList<CombineObserver<R, ?>>();\n \n-        public Aggregator(FuncN<R> combineLatestFunction) {\n+        public Aggregator(FuncN<? extends R> combineLatestFunction) {\n             this.combineLatestFunction = combineLatestFunction;\n         }\n \n@@ -161,7 +161,7 @@ <T> void addObserver(CombineObserver<R, T> w) {\n          * \n          * @param w The observer that has completed.\n          */\n-        <T> void complete(CombineObserver<R, T> w) {\n+        <T> void complete(CombineObserver<? extends R, ? super T> w) {\n             int completed = numCompleted.incrementAndGet();\n             // if all CombineObservers are completed, we mark the whole thing as completed\n             if (completed == observers.size()) {\n@@ -191,7 +191,7 @@ void error(Exception e) {\n          * @param w\n          * @param arg\n          */\n-        <T> void next(CombineObserver<R, T> w, T arg) {\n+        <T> void next(CombineObserver<? extends R, ? super T> w, T arg) {\n             if (observer == null) {\n                 throw new RuntimeException(\"This shouldn't be running if an Observer isn't registered\");\n             }\n@@ -224,7 +224,7 @@ <T> void next(CombineObserver<R, T> w, T arg) {\n         }\n \n         @Override\n-        public Subscription call(Observer<R> observer) {\n+        public Subscription call(Observer<? super R> observer) {\n             if (this.observer != null) {\n                 throw new IllegalStateException(\"Only one Observer can subscribe to this Observable.\");\n             }",
    "output": "Improve generics for combineLatest (PECS principle)"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java\n@@ -19,6 +19,7 @@\n \n import java.awt.Component;\n import java.awt.Dimension;\n+import java.awt.Point;\n import java.awt.event.ActionEvent;\n import java.awt.event.ComponentEvent;\n import java.awt.event.KeyEvent;\n@@ -110,6 +111,16 @@ public static Observable<MouseEvent> fromMouseMotionEvents(Component component)\n         return MouseEventSource.fromMouseMotionEventsOf(component);\n     }\n     \n+    /**\n+     * Creates an observable corresponding to relative mouse motion.\n+     * @param component\n+     *            The component to register the observable for.\n+     * @return A point whose x and y coordinate represent the relative horizontal and vertical mouse motion.\n+     */\n+    public static Observable<Point> fromRelativeMouseMotion(Component component) {\n+        return MouseEventSource.fromRelativeMouseMotion(component);\n+    }\n+    \n     /**\n      * Creates an observable corresponding to raw component events.\n      * \n\ndiff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java\n@@ -15,17 +15,28 @@\n  */\n package rx.swing.sources;\n \n+import static org.mockito.Mockito.*;\n+\n import java.awt.Component;\n+import java.awt.Point;\n import java.awt.event.MouseEvent;\n import java.awt.event.MouseListener;\n import java.awt.event.MouseMotionListener;\n \n+import javax.swing.JPanel;\n+\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Matchers;\n+\n import rx.Observable;\n import rx.Observer;\n import rx.Subscription;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;\n+import rx.util.functions.Action1;\n import rx.util.functions.Func1;\n+import rx.util.functions.Func2;\n \n public enum MouseEventSource { ; // no instances\n \n@@ -103,4 +114,86 @@ public void call() {\n             }\n         });\n     }\n+    \n+    /**\n+     * @see rx.observables.SwingObservable#fromRelativeMouseMotion\n+     */\n+    public static Observable<Point> fromRelativeMouseMotion(final Component component) {\n+        class OldAndRelative {\n+            public final Point old;\n+            public final Point relative;\n+\n+            private OldAndRelative(Point old, Point relative) {\n+                this.old = old;\n+                this.relative = relative;\n+            }\n+        }\n+        \n+        class Relativize implements Func2<OldAndRelative, MouseEvent, OldAndRelative> {\n+            @Override\n+            public OldAndRelative call(OldAndRelative last, MouseEvent event) {\n+                Point current = new Point(event.getX(), event.getY());\n+                Point relative = new Point(current.x - last.old.x, current.y - last.old.y);\n+                return new OldAndRelative(current, relative);\n+            }\n+        }\n+        \n+        class OnlyRelative implements Func1<OldAndRelative, Point> {\n+            @Override\n+            public Point call(OldAndRelative oar) {\n+                return oar.relative;\n+            }\n+        }\n+        \n+        return fromMouseMotionEventsOf(component)\n+                    .scan(new OldAndRelative(new Point(0, 0), new Point(0, 0)), new Relativize())\n+                    .map(new OnlyRelative())\n+                    .skip(2); // skip the useless initial value and the invalid first computation\n+    }\n+    \n+    public static class UnitTest {\n+        private Component comp = new JPanel();\n+        \n+        @Test\n+        public void testRelativeMouseMotion() {\n+            @SuppressWarnings(\"unchecked\")\n+            Action1<Point> action = mock(Action1.class);\n+            @SuppressWarnings(\"unchecked\")\n+            Action1<Exception> error = mock(Action1.class);\n+            Action0 complete = mock(Action0.class);\n+            \n+            Subscription sub = fromRelativeMouseMotion(comp).subscribe(action, error, complete);\n+            \n+            InOrder inOrder = inOrder(action);\n+            \n+            verify(action, never()).call(Matchers.<Point>any());\n+            verify(error, never()).call(Matchers.<Exception>any());\n+            verify(complete, never()).call();\n+            \n+            fireMouseEvent(mouseEvent(0, 0));\n+            verify(action, never()).call(Matchers.<Point>any());\n+            \n+            fireMouseEvent(mouseEvent(10, -5));\n+            inOrder.verify(action, times(1)).call(new Point(10, -5));\n+            \n+            fireMouseEvent(mouseEvent(6, 10));\n+            inOrder.verify(action, times(1)).call(new Point(-4, 15));\n+            \n+            sub.unsubscribe();\n+            fireMouseEvent(mouseEvent(0, 0));\n+            inOrder.verify(action, never()).call(Matchers.<Point>any());\n+            verify(error, never()).call(Matchers.<Exception>any());\n+            verify(complete, never()).call();\n+        }\n+        \n+        private MouseEvent mouseEvent(int x, int y) {\n+            return new MouseEvent(comp, MouseEvent.MOUSE_MOVED, 1L, 0, x, y, 0, false);\n+        }\n+        \n+        private void fireMouseEvent(MouseEvent event) {\n+            for (MouseMotionListener listener: comp.getMouseMotionListeners()) {\n+                listener.mouseMoved(event);\n+            }\n+        }\n+    }\n }",
    "output": "Add a helper for computing relative mouse motion"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -40,6 +40,7 @@\n import rx.observables.GroupedObservable;\n import rx.operators.OperationAll;\n import rx.operators.OperationCache;\n+import rx.operators.OperationCombineLatest;\n import rx.operators.OperationConcat;\n import rx.operators.OperationDefer;\n import rx.operators.OperationDematerialize;\n@@ -2737,6 +2738,35 @@ public R call(T0 t0, T1 t1, T2 t2, T3 t3) {\n         });\n     }\n \n+    /**\n+     * Combines the given observables, emitting an event containing an aggregation of the latest values of each of the source observables\n+     * each time an event is received from one of the source observables, where the aggregation is defined by the given function.\n+     * @param w0 \n+     *          The first source observable.\n+     * @param w1 \n+     *          The second source observable.\n+     * @param combineLatestFunction \n+     *          The aggregation function used to combine the source observable values.\n+     * @return A function from an observer to a subscription. This can be used to create an observable from.\n+     */\n+    public static <R, T0, T1> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Func2<T0, T1, R> combineFunction) {\n+        return create(OperationCombineLatest.combineLatest(w0, w1, combineFunction));\n+    }\n+    \n+    /**\n+     * @see #combineLatest(Observable, Observable, Func2)\n+     */\n+    public static <R, T0, T1, T2> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Func3<T0, T1, T2, R> combineFunction) {\n+        return create(OperationCombineLatest.combineLatest(w0, w1, w2, combineFunction));\n+    }\n+\n+    /**\n+     * @see #combineLatest(Observable, Observable, Func2)\n+     */\n+    public static <R, T0, T1, T2, T3> Observable<R> combineLatest(Observable<T0> w0, Observable<T1> w1, Observable<T2> w2, Observable<T3> w3, Func4<T0, T1, T2, T3, R> combineFunction) {\n+        return create(OperationCombineLatest.combineLatest(w0, w1, w2, w3, combineFunction));\n+    }\n+    \n     /**\n      * Filters an Observable by discarding any of its emissions that do not meet some test.\n      * <p>",
    "output": "Add combineLatest static methods to Observable"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java\n@@ -103,6 +103,5 @@ private Predicate(int id) {\n         public Boolean call(ComponentEvent event) {\n             return event.getID() == id;\n         }\n-        \n     }\n }\n\ndiff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java\n@@ -85,7 +85,7 @@ public void call() {\n      * @see SwingObservable.fromKeyEvents(Component, Set)\n      */\n     public static Observable<Set<Integer>> currentlyPressedKeysOf(Component component) {\n-        return Observable.<KeyEvent, Set<Integer>>scan(fromKeyEventsOf(component), new HashSet<Integer>(), new Func2<Set<Integer>, KeyEvent, Set<Integer>>() {\n+        class CollectKeys implements Func2<Set<Integer>, KeyEvent, Set<Integer>>{\n             @Override\n             public Set<Integer> call(Set<Integer> pressedKeys, KeyEvent event) {\n                 Set<Integer> afterEvent = new HashSet<Integer>(pressedKeys);\n@@ -102,7 +102,16 @@ public Set<Integer> call(Set<Integer> pressedKeys, KeyEvent event) {\n                 }\n                 return afterEvent;\n             }\n+        }\n+        \n+        Observable<KeyEvent> filteredKeyEvents = fromKeyEventsOf(component).filter(new Func1<KeyEvent, Boolean>() {\n+            @Override\n+            public Boolean call(KeyEvent event) {\n+                return event.getID() == KeyEvent.KEY_PRESSED || event.getID() == KeyEvent.KEY_RELEASED;\n+            }\n         });\n+        \n+        return Observable.<KeyEvent, Set<Integer>>scan(filteredKeyEvents, Collections.<Integer>emptySet(), new CollectKeys());\n     }\n     \n     public static class UnitTest {\n@@ -158,6 +167,7 @@ public void testObservingPressedKeys() {\n             verify(complete, never()).call();\n \n             fireKeyEvent(keyEvent(2, KeyEvent.KEY_PRESSED));\n+            fireKeyEvent(keyEvent(KeyEvent.VK_UNDEFINED, KeyEvent.KEY_TYPED));\n             inOrder.verify(action, times(1)).call(new HashSet<Integer>(asList(1, 2)));\n \n             fireKeyEvent(keyEvent(2, KeyEvent.KEY_RELEASED));",
    "output": "Improve key press observable to filter out events of type KEY_TYPED completely"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java\n@@ -87,7 +87,7 @@ public Dimension call(ComponentEvent event) {\n     /**\n      * Predicates that help with filtering observables for specific component events. \n      */\n-    public enum Predicate implements Func1<ComponentEvent, Boolean> { \n+    public enum Predicate implements rx.util.functions.Func1<java.awt.event.ComponentEvent, Boolean> { \n         RESIZED(ComponentEvent.COMPONENT_RESIZED),\n         HIDDEN(ComponentEvent.COMPONENT_HIDDEN),\n         MOVED(ComponentEvent.COMPONENT_MOVED),",
    "output": "Fix strange compilation problems by specifying the packages directly"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java\n@@ -17,7 +17,9 @@\n \n import static rx.Observable.filter;\n \n+import java.awt.Dimension;\n import java.awt.event.ActionEvent;\n+import java.awt.event.ComponentEvent;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseEvent;\n import java.util.Set;\n@@ -27,6 +29,7 @@\n \n import rx.Observable;\n import rx.swing.sources.AbstractButtonSource;\n+import rx.swing.sources.ComponentEventSource;\n import rx.swing.sources.KeyEventSource;\n import rx.swing.sources.MouseEventSource;\n import rx.util.functions.Func1;\n@@ -106,4 +109,26 @@ public static Observable<MouseEvent> fromMouseEvents(JComponent component) {\n     public static Observable<MouseEvent> fromMouseMotionEvents(JComponent component) {\n         return MouseEventSource.fromMouseMotionEventsOf(component);\n     }\n+    \n+    /**\n+     * Creates an observable corresponding to raw component events.\n+     * \n+     * @param component\n+     *            The component to register the observable for.\n+     * @return Observable of component events.\n+     */\n+    public static Observable<ComponentEvent> fromComponentEvents(JComponent component) {\n+        return ComponentEventSource.fromComponentEventsOf(component);\n+    }\n+\n+    /**\n+     * Creates an observable corresponding to component resize events.\n+     * \n+     * @param component\n+     *            The component to register the observable for.\n+     * @return Observable emitting the current size of the given component after each resize event.\n+     */\n+    public static Observable<Dimension> fromResizing(JComponent component) {\n+        return ComponentEventSource.fromResizing(component);\n+    }\n }\n\ndiff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java\n@@ -0,0 +1,100 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.swing.sources;\n+\n+import java.awt.Dimension;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n+\n+import javax.swing.JComponent;\n+\n+import rx.Observable;\n+import rx.Observer;\n+import rx.Subscription;\n+import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n+import rx.util.functions.Func1;\n+\n+public enum ComponentEventSource { ; // no instances\n+\n+    public static Observable<ComponentEvent> fromComponentEventsOf(final JComponent component) {\n+        return Observable.create(new Func1<Observer<ComponentEvent>, Subscription>() {\n+            @Override\n+            public Subscription call(final Observer<ComponentEvent> observer) {\n+                final ComponentListener listener = new ComponentListener() {\n+                    @Override\n+                    public void componentHidden(ComponentEvent event) {\n+                        observer.onNext(event);\n+                    }\n+\n+                    @Override\n+                    public void componentMoved(ComponentEvent event) {\n+                        observer.onNext(event);\n+                    }\n+\n+                    @Override\n+                    public void componentResized(ComponentEvent event) {\n+                        observer.onNext(event);\n+                    }\n+\n+                    @Override\n+                    public void componentShown(ComponentEvent event) {\n+                        observer.onNext(event);\n+                    }\n+                };\n+                component.addComponentListener(listener);\n+                \n+                return Subscriptions.create(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        component.removeComponentListener(listener);\n+                    }\n+                });\n+            }\n+        });\n+    }\n+    \n+    public static Observable<Dimension> fromResizing(final JComponent component) {\n+        return fromComponentEventsOf(component).filter(Predicate.RESIZED).map(new Func1<ComponentEvent, Dimension>() {\n+            @Override\n+            public Dimension call(ComponentEvent event) {\n+                return event.getComponent().getSize();\n+            }\n+        });\n+    }\n+    \n+    /**\n+     * Predicates that help with filtering observables for specific component events. \n+     */\n+    public enum Predicate implements Func1<ComponentEvent, Boolean> { \n+        RESIZED(ComponentEvent.COMPONENT_RESIZED),\n+        HIDDEN(ComponentEvent.COMPONENT_HIDDEN),\n+        MOVED(ComponentEvent.COMPONENT_MOVED),\n+        SHOWN(ComponentEvent.COMPONENT_SHOWN);\n+        \n+        private final int id;\n+        \n+        private Predicate(int id) {\n+            this.id = id;\n+        }\n+        \n+        @Override\n+        public Boolean call(ComponentEvent event) {\n+            return event.getID() == id;\n+        }\n+        \n+    }\n+}",
    "output": "Add observables for component events"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/AsyncSubject.java\n@@ -15,11 +15,8 @@\n  */\n package rx.subjects;\n \n-import static org.mockito.Matchers.any;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Matchers.anyString;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n \n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -30,7 +27,6 @@\n import rx.Observer;\n import rx.Subscription;\n import rx.util.AtomicObservableSubscription;\n-import rx.util.SynchronizedObserver;\n import rx.util.functions.Action1;\n import rx.util.functions.Func0;\n import rx.util.functions.Func1;\n@@ -80,7 +76,7 @@ public void unsubscribe() {\n                 });\n \n                 // on subscribe add it to the map of outbound observers to notify\n-                observers.put(subscription, new SynchronizedObserver<T>(observer, subscription));\n+                observers.put(subscription, observer);\n                 return subscription;\n             }\n         };\n\ndiff --git a/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java\n@@ -27,7 +27,6 @@\n import rx.Observer;\n import rx.Subscription;\n import rx.util.AtomicObservableSubscription;\n-import rx.util.SynchronizedObserver;\n import rx.util.functions.Action1;\n import rx.util.functions.Func0;\n import rx.util.functions.Func1;\n@@ -86,11 +85,10 @@ public void unsubscribe() {\n                     }\n                 });\n \n-                SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(observer, subscription);\n-                synchronizedObserver.onNext(currentValue.get());\n+                observer.onNext(currentValue.get());\n \n                 // on subscribe add it to the map of outbound observers to notify\n-                observers.put(subscription, synchronizedObserver);\n+                observers.put(subscription, observer);\n                 return subscription;\n             }\n         };\n\ndiff --git a/rxjava-core/src/main/java/rx/subjects/PublishSubject.java b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n@@ -34,7 +34,6 @@\n import rx.Observer;\n import rx.Subscription;\n import rx.util.AtomicObservableSubscription;\n-import rx.util.SynchronizedObserver;\n import rx.util.functions.Action1;\n import rx.util.functions.Func0;\n import rx.util.functions.Func1;\n@@ -78,7 +77,7 @@ public void unsubscribe() {\n                 });\n \n                 // on subscribe add it to the map of outbound observers to notify\n-                observers.put(subscription, new SynchronizedObserver<T>(observer, subscription));\n+                observers.put(subscription, observer);\n                 return subscription;\n             }\n         };",
    "output": "Remove SynchronizedObserver usage from Subject implementations. - We don't need to add synchronization as the subjects can trust their source Observables to comply with the Rx contract. - This optimization follows Rx Design Guidelines 6.8. Avoid serializing operators This was discussed at https://github.com/Netflix/RxJava/pull/256"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -4229,7 +4229,6 @@ public Subscription call(final Observer<String> observer) {\n                         @Override\n                         public void run() {\n                             counter.incrementAndGet();\n-                            System.out.println(\"published observable being executed\");\n                             observer.onNext(\"one\");\n                             observer.onCompleted();\n                         }\n@@ -4246,7 +4245,6 @@ public void run() {\n                 @Override\n                 public void call(String v) {\n                     assertEquals(\"one\", v);\n-                    System.out.println(\"v: \" + v);\n                     latch.countDown();\n                 }\n             });\n@@ -4257,7 +4255,6 @@ public void call(String v) {\n                 @Override\n                 public void call(String v) {\n                     assertEquals(\"one\", v);\n-                    System.out.println(\"v: \" + v);\n                     latch.countDown();\n                 }\n             });\n@@ -4286,7 +4283,6 @@ public Subscription call(final Observer<String> observer) {\n                         @Override\n                         public void run() {\n                             counter.incrementAndGet();\n-                            System.out.println(\"published observable being executed\");\n                             observer.onNext(\"one\");\n                             observer.onCompleted();\n                         }\n@@ -4308,7 +4304,6 @@ public void run() {\n                     @Override\n                     public void call(String v) {\n                         assertEquals(\"one\", v);\n-                        System.out.println(\"v: \" + v);\n                         latch.countDown();\n                     }\n                 });\n@@ -4319,7 +4314,6 @@ public void call(String v) {\n                     @Override\n                     public void call(String v) {\n                         assertEquals(\"one\", v);\n-                        System.out.println(\"v: \" + v);\n                         latch.countDown();\n                     }\n                 });\n@@ -4346,7 +4340,6 @@ public Subscription call(final Observer<String> observer) {\n                         @Override\n                         public void run() {\n                             counter.incrementAndGet();\n-                            System.out.println(\"published observable being executed\");\n                             observer.onNext(\"one\");\n                             observer.onCompleted();\n                         }\n@@ -4364,7 +4357,6 @@ public void run() {\n                 @Override\n                 public void call(String v) {\n                     assertEquals(\"one\", v);\n-                    System.out.println(\"v: \" + v);\n                     latch.countDown();\n                 }\n             });\n@@ -4375,7 +4367,6 @@ public void call(String v) {\n                 @Override\n                 public void call(String v) {\n                     assertEquals(\"one\", v);\n-                    System.out.println(\"v: \" + v);\n                     latch.countDown();\n                 }\n             });",
    "output": "Remove debug statements from unit tests"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n@@ -19,13 +19,15 @@\n \n import java.awt.event.ActionEvent;\n import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n import java.util.Set;\n \n import javax.swing.AbstractButton;\n import javax.swing.JComponent;\n \n import rx.swing.sources.AbstractButtonSource;\n import rx.swing.sources.KeyEventSource;\n+import rx.swing.sources.MouseEventSource;\n import rx.util.functions.Func1;\n \n /**\n@@ -81,4 +83,26 @@ public Boolean call(KeyEvent event) {\n     public static Observable<Set<Integer>> currentlyPressedKeys(JComponent component) {\n         return KeyEventSource.currentlyPressedKeysOf(component);\n     }\n+\n+    /**\n+     * Creates an observable corresponding to raw mouse events (excluding mouse motion events).\n+     * \n+     * @param component\n+     *            The component to register the observable for.\n+     * @return Observable of mouse events.\n+     */\n+    public static Observable<MouseEvent> fromMouseEvents(JComponent component) {\n+        return MouseEventSource.fromMouseEventsOf(component);\n+    }\n+\n+    /**\n+     * Creates an observable corresponding to raw mouse motion events.\n+     * \n+     * @param component\n+     *            The component to register the observable for.\n+     * @return Observable of mouse motion events.\n+     */\n+    public static Observable<MouseEvent> fromMouseMotionEvents(JComponent component) {\n+        return MouseEventSource.fromMouseMotionEventsOf(component);\n+    }\n }\n\ndiff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java\n@@ -0,0 +1,101 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.swing.sources;\n+\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.awt.event.MouseMotionListener;\n+\n+import javax.swing.JComponent;\n+\n+import rx.Observable;\n+import rx.Observer;\n+import rx.Subscription;\n+import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n+import rx.util.functions.Func1;\n+\n+public enum MouseEventSource { ; // no instances\n+\n+    public static Observable<MouseEvent> fromMouseEventsOf(final JComponent component) {\n+        return Observable.create(new Func1<Observer<MouseEvent>, Subscription>() {\n+            @Override\n+            public Subscription call(final Observer<MouseEvent> observer) {\n+                final MouseListener listener = new MouseListener() {\n+                    @Override\n+                    public void mouseClicked(MouseEvent event) {\n+                        observer.onNext(event);\n+                    }\n+\n+                    @Override\n+                    public void mousePressed(MouseEvent event) {\n+                        observer.onNext(event);\n+                    }\n+\n+                    @Override\n+                    public void mouseReleased(MouseEvent event) {\n+                        observer.onNext(event);\n+                    }\n+\n+                    @Override\n+                    public void mouseEntered(MouseEvent event) {\n+                        observer.onNext(event);\n+                    }\n+\n+                    @Override\n+                    public void mouseExited(MouseEvent event) {\n+                        observer.onNext(event);\n+                    }\n+                };\n+                component.addMouseListener(listener);\n+                \n+                return Subscriptions.create(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        component.removeMouseListener(listener);\n+                    }\n+                });\n+            }\n+        });\n+    }\n+    \n+    public static Observable<MouseEvent> fromMouseMotionEventsOf(final JComponent component) {\n+        return Observable.create(new Func1<Observer<MouseEvent>, Subscription>() {\n+            @Override\n+            public Subscription call(final Observer<MouseEvent> observer) {\n+                final MouseMotionListener listener = new MouseMotionListener() {\n+                    @Override\n+                    public void mouseDragged(MouseEvent event) {\n+                        observer.onNext(event);\n+                    }\n+\n+                    @Override\n+                    public void mouseMoved(MouseEvent event) {\n+                        observer.onNext(event);\n+                    }\n+                };\n+                component.addMouseMotionListener(listener);\n+                \n+                return Subscriptions.create(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        component.removeMouseMotionListener(listener);\n+                    }\n+                });\n+            }\n+        });\n+    }\n+}",
    "output": "Add basic mouse event observables"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n@@ -70,4 +70,15 @@ public Boolean call(KeyEvent event) {\n             }\n         });\n     }\n+\n+    /**\n+     * Creates an observable that emits the set of all currently pressed keys each time\n+     * this set changes. \n+     * @param component\n+     *            The component to register the observable for.\n+     * @return Observable of currently pressed keys.\n+     */\n+    public static Observable<Set<Integer>> currentlyPressedKeys(JComponent component) {\n+        return KeyEventSource.currentlyPressedKeysOf(component);\n+    }\n }\n\ndiff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java\n@@ -1,15 +1,34 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package rx.swing.sources;\n \n+import static java.util.Arrays.asList;\n import static org.mockito.Mockito.*;\n \n-import java.awt.event.ActionEvent;\n import java.awt.event.KeyEvent;\n import java.awt.event.KeyListener;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n \n import javax.swing.JComponent;\n import javax.swing.JPanel;\n \n import org.junit.Test;\n+import org.mockito.InOrder;\n import org.mockito.Matchers;\n \n import rx.Observable;\n@@ -19,6 +38,7 @@\n import rx.util.functions.Action0;\n import rx.util.functions.Action1;\n import rx.util.functions.Func1;\n+import rx.util.functions.Func2;\n \n public enum KeyEventSource { ; // no instances\n \n@@ -54,40 +74,105 @@ public void call() {\n         });\n     }\n \n+    public static Observable<Set<Integer>> currentlyPressedKeysOf(JComponent component) {\n+        return Observable.<KeyEvent, Set<Integer>>scan(fromKeyEventsOf(component), new HashSet<Integer>(), new Func2<Set<Integer>, KeyEvent, Set<Integer>>() {\n+            @Override\n+            public Set<Integer> call(Set<Integer> pressedKeys, KeyEvent event) {\n+                Set<Integer> afterEvent = new HashSet<Integer>(pressedKeys);\n+                switch (event.getID()) {\n+                    case KeyEvent.KEY_PRESSED:\n+                        afterEvent.add(event.getKeyCode());\n+                        break;\n+                        \n+                    case KeyEvent.KEY_RELEASED:\n+                        afterEvent.remove(event.getKeyCode());\n+                        break;\n+                      \n+                    default: // nothing to do\n+                }\n+                return afterEvent;\n+            }\n+        });\n+    }\n+    \n     public static class UnitTest {\n+        private JComponent comp = new JPanel();\n+        \n         @Test\n-        public void testObservingActionEvents() {\n+        public void testObservingKeyEvents() {\n             @SuppressWarnings(\"unchecked\")\n-            Action1<ActionEvent> action = mock(Action1.class);\n+            Action1<KeyEvent> action = mock(Action1.class);\n             @SuppressWarnings(\"unchecked\")\n             Action1<Exception> error = mock(Action1.class);\n             Action0 complete = mock(Action0.class);\n             \n             final KeyEvent event = mock(KeyEvent.class);\n             \n-            JComponent comp = new JPanel();\n-            \n             Subscription sub = fromKeyEventsOf(comp).subscribe(action, error, complete);\n             \n-            verify(action, never()).call(Matchers.<ActionEvent>any());\n+            verify(action, never()).call(Matchers.<KeyEvent>any());\n             verify(error, never()).call(Matchers.<Exception>any());\n             verify(complete, never()).call();\n             \n-            fireKeyEvent(comp, event);\n-            verify(action, times(1)).call(Matchers.<ActionEvent>any());\n+            fireKeyEvent(event);\n+            verify(action, times(1)).call(Matchers.<KeyEvent>any());\n             \n-            fireKeyEvent(comp, event);\n-            verify(action, times(2)).call(Matchers.<ActionEvent>any());\n+            fireKeyEvent(event);\n+            verify(action, times(2)).call(Matchers.<KeyEvent>any());\n             \n             sub.unsubscribe();\n-            fireKeyEvent(comp, event);\n-            verify(action, times(2)).call(Matchers.<ActionEvent>any());\n+            fireKeyEvent(event);\n+            verify(action, times(2)).call(Matchers.<KeyEvent>any());\n             verify(error, never()).call(Matchers.<Exception>any());\n             verify(complete, never()).call();\n         }\n         \n-        private static void fireKeyEvent(JComponent component, KeyEvent event) {\n-            for (KeyListener listener: component.getKeyListeners()) {\n+        @Test\n+        public void testObservingPressedKeys() {\n+            @SuppressWarnings(\"unchecked\")\n+            Action1<Set<Integer>> action = mock(Action1.class);\n+            @SuppressWarnings(\"unchecked\")\n+            Action1<Exception> error = mock(Action1.class);\n+            Action0 complete = mock(Action0.class);\n+            \n+            Subscription sub = currentlyPressedKeysOf(comp).subscribe(action, error, complete);\n+            \n+            InOrder inOrder = inOrder(action);\n+            inOrder.verify(action, times(1)).call(Collections.<Integer>emptySet());\n+            verify(error, never()).call(Matchers.<Exception>any());\n+            verify(complete, never()).call();\n+            \n+            fireKeyEvent(keyEvent(1, KeyEvent.KEY_PRESSED));\n+            inOrder.verify(action, times(1)).call(new HashSet<Integer>(asList(1)));\n+            verify(error, never()).call(Matchers.<Exception>any());\n+            verify(complete, never()).call();\n+\n+            fireKeyEvent(keyEvent(2, KeyEvent.KEY_PRESSED));\n+            inOrder.verify(action, times(1)).call(new HashSet<Integer>(asList(1, 2)));\n+\n+            fireKeyEvent(keyEvent(2, KeyEvent.KEY_RELEASED));\n+            inOrder.verify(action, times(1)).call(new HashSet<Integer>(asList(1)));\n+\n+            fireKeyEvent(keyEvent(3, KeyEvent.KEY_RELEASED));\n+            inOrder.verify(action, times(1)).call(new HashSet<Integer>(asList(1)));\n+\n+            fireKeyEvent(keyEvent(1, KeyEvent.KEY_RELEASED));\n+            inOrder.verify(action, times(1)).call(Collections.<Integer>emptySet());\n+\n+            sub.unsubscribe();\n+\n+            fireKeyEvent(keyEvent(1, KeyEvent.KEY_PRESSED));\n+            inOrder.verify(action, never()).call(Matchers.<Set<Integer>>any());\n+            verify(error, never()).call(Matchers.<Exception>any());\n+            verify(complete, never()).call();\n+        }\n+\n+        private KeyEvent keyEvent(int keyCode, int id) {\n+            return new KeyEvent(comp, id, -1L, 0, keyCode, ' ');\n+        }\n+        \n+        private void fireKeyEvent(KeyEvent event) {\n+            for (KeyListener listener: comp.getKeyListeners()) {\n                 listener.keyTyped(event);\n             }\n         }",
    "output": "Add observable for all currently pressed keys"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationSwitch.java b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationSwitch.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java\n@@ -93,29 +93,27 @@ public void onError(Exception e) {\n \n         @Override\n         public void onNext(Observable<T> args) {\n-            synchronized (subscription) {\n-                Subscription previousSubscription = subscription.get();\n-                if (previousSubscription != null) {\n-                    previousSubscription.unsubscribe();\n-                }\n-                \n-                subscription.set(args.subscribe(new Observer<T>() {\n-                    @Override\n-                    public void onCompleted() {\n-                        // Do nothing.\n-                    }\n-\n-                    @Override\n-                    public void onError(Exception e) {\n-                        // Do nothing.\n-                    }\n-\n-                    @Override\n-                    public void onNext(T args) {\n-                        observer.onNext(args);\n-                    }\n-                }));\n+            Subscription previousSubscription = subscription.get();\n+            if (previousSubscription != null) {\n+                previousSubscription.unsubscribe();\n             }\n+            \n+            subscription.set(args.subscribe(new Observer<T>() {\n+                @Override\n+                public void onCompleted() {\n+                    // Do nothing.\n+                }\n+\n+                @Override\n+                public void onError(Exception e) {\n+                    // Do nothing.\n+                }\n+\n+                @Override\n+                public void onNext(T args) {\n+                    observer.onNext(args);\n+                }\n+            }));\n         }\n     }\n     ",
    "output": "Remove synchronized block as per RxJava guidelines (6.7)"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationThrottle.java b/rxjava-core/src/main/java/rx/operators/OperationThrottle.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationThrottle.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationThrottle.java\n@@ -210,11 +210,11 @@ public void before() {\n         public void testThrottlingWithCompleted() {\n             Observable<String> source = Observable.create(new Func1<Observer<String>, Subscription>() {\n                 @Override\n-                public Subscription call(Observer<String> observser) {\n-                    publishNext(observser, 100, \"one\");    // Should be skipped since \"two\" will arrive before the timeout expires.\n-                    publishNext(observser, 400, \"two\");    // Should be published since \"three\" will arrive after the timeout expires.\n-                    publishNext(observser, 900, \"four\");   // Should be skipped since onCompleted will arrive before the timeout expires.\n-                    publishCompleted(observser, 1000);     // Should be published as soon as the timeout expires.\n+                public Subscription call(Observer<String> observer) {\n+                    publishNext(observer, 100, \"one\");    // Should be skipped since \"two\" will arrive before the timeout expires.\n+                    publishNext(observer, 400, \"two\");    // Should be published since \"three\" will arrive after the timeout expires.\n+                    publishNext(observer, 900, \"four\");   // Should be skipped since onCompleted will arrive before the timeout expires.\n+                    publishCompleted(observer, 1000);     // Should be published as soon as the timeout expires.\n \n                     return Subscriptions.empty();\n                 }",
    "output": "Fix a typo the UnitTest class of OperationThrottle"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationScan.java b/rxjava-core/src/main/java/rx/operators/OperationScan.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationScan.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationScan.java\n@@ -26,6 +26,7 @@\n import rx.Observer;\n import rx.Subscription;\n import rx.util.AtomicObservableSubscription;\n+import rx.util.functions.Action0;\n import rx.util.functions.Action1;\n import rx.util.functions.Func1;\n import rx.util.functions.Func2;\n@@ -65,12 +66,12 @@ public static <T> Func1<Observer<T>, Subscription> scan(Observable<T> sequence,\n \n     private static class AccuWithoutInitialValue<T> implements Func1<Observer<T>, Subscription> {\n         private final Observable<T> sequence;\n-        private final Func2<T, T, T> accumlatorFunction;\n+        private final Func2<T, T, T> accumulatorFunction;\n         private T initialValue;\n \n         private AccuWithoutInitialValue(Observable<T> sequence, Func2<T, T, T> accumulator) {\n             this.sequence = sequence;\n-            this.accumlatorFunction = accumulator;\n+            this.accumulatorFunction = accumulator;\n         }\n         \n         @Override\n@@ -80,22 +81,32 @@ public Subscription call(final Observer<T> observer) {\n                 public void call(T value) {\n                     initialValue = value;\n                 }\n+            }, new Action1<Exception>() {\n+                @Override\n+                public void call(Exception e) {\n+                    observer.onError(e);\n+                }\n+            }, new Action0() {\n+                @Override\n+                public void call() {\n+                    observer.onCompleted();\n+                }\n             });\n-            Accumulator<T, T> scan = new Accumulator<T, T>(sequence.skip(1), initialValue, accumlatorFunction);\n+            Accumulator<T, T> scan = new Accumulator<T, T>(sequence.skip(1), initialValue, accumulatorFunction);\n             return scan.call(observer);\n         }\n     }\n     \n     private static class Accumulator<T, R> implements Func1<Observer<R>, Subscription> {\n         private final Observable<T> sequence;\n         private final R initialValue;\n-        private final Func2<R, T, R> accumlatorFunction;\n+        private final Func2<R, T, R> accumulatorFunction;\n         private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();\n \n         private Accumulator(Observable<T> sequence, R initialValue, Func2<R, T, R> accumulator) {\n             this.sequence = sequence;\n             this.initialValue = initialValue;\n-            this.accumlatorFunction = accumulator;\n+            this.accumulatorFunction = accumulator;\n         }\n \n         @Override\n@@ -115,7 +126,7 @@ public Subscription call(final Observer<R> observer) {\n                 @Override\n                 public synchronized void onNext(T value) {\n                     try {\n-                        acc = accumlatorFunction.call(acc, value);\n+                        acc = accumulatorFunction.call(acc, value);\n                         observer.onNext(acc);\n                     } catch (Exception ex) {\n                         observer.onError(ex);",
    "output": "Fix a typo, added missing error and completion handling"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n@@ -15,14 +15,18 @@\n  */\n package rx;\n \n+import static rx.Observable.filter;\n+\n import java.awt.event.ActionEvent;\n import java.awt.event.KeyEvent;\n+import java.util.Set;\n \n import javax.swing.AbstractButton;\n import javax.swing.JComponent;\n \n import rx.swing.sources.AbstractButtonSource;\n import rx.swing.sources.KeyEventSource;\n+import rx.util.functions.Func1;\n \n /**\n  * Allows creating observables from various sources specific to Swing. \n@@ -50,4 +54,20 @@ public static Observable<ActionEvent> fromButtonAction(AbstractButton button) {\n     public static Observable<KeyEvent> fromKeyEvents(JComponent component) {\n         return KeyEventSource.fromKeyEventsOf(component);\n     }\n+\n+    /**\n+     * Creates an observable corresponding to raw key events, restricted a set of given key codes.\n+     * \n+     * @param component\n+     *            The component to register the observable for.\n+     * @return Observable of key events.\n+     */\n+    public static Observable<KeyEvent> fromKeyEvents(JComponent component, final Set<Integer> keyCodes) {\n+        return filter(fromKeyEvents(component), new Func1<KeyEvent, Boolean>() {\n+            @Override\n+            public Boolean call(KeyEvent event) {\n+                return keyCodes.contains(event.getKeyCode());\n+            }\n+        });\n+    }\n }",
    "output": "Add filtering for key codes"
  },
  {
    "input": "diff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java\n@@ -16,10 +16,13 @@\n package rx;\n \n import java.awt.event.ActionEvent;\n+import java.awt.event.KeyEvent;\n \n import javax.swing.AbstractButton;\n+import javax.swing.JComponent;\n \n import rx.swing.sources.AbstractButtonSource;\n+import rx.swing.sources.KeyEventSource;\n \n /**\n  * Allows creating observables from various sources specific to Swing. \n@@ -36,4 +39,15 @@ public enum SwingObservable { ; // no instances\n     public static Observable<ActionEvent> fromButtonAction(AbstractButton button) {\n         return AbstractButtonSource.fromActionOf(button);\n     }\n+\n+    /**\n+     * Creates an observable corresponding to raw key events.\n+     * \n+     * @param component\n+     *            The component to register the observable for.\n+     * @return Observable of key events.\n+     */\n+    public static Observable<KeyEvent> fromKeyEvents(JComponent component) {\n+        return KeyEventSource.fromKeyEventsOf(component);\n+    }\n }\n\ndiff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/AbstractButtonSource.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/AbstractButtonSource.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/AbstractButtonSource.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/AbstractButtonSource.java\n@@ -56,6 +56,7 @@ public void testObservingActionEvents() {\n             \n             final ActionEvent event = new ActionEvent(this, 1, \"command\");\n             \n+            @SuppressWarnings(\"serial\")\n             class TestButton extends AbstractButton {\n                 void testAction() {\n                     fireActionPerformed(event);\n\ndiff --git a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java\n--- a/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java\n+++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java\n@@ -0,0 +1,95 @@\n+package rx.swing.sources;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.awt.event.ActionEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+\n+import org.junit.Test;\n+import org.mockito.Matchers;\n+\n+import rx.Observable;\n+import rx.Observer;\n+import rx.Subscription;\n+import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n+import rx.util.functions.Action1;\n+import rx.util.functions.Func1;\n+\n+public enum KeyEventSource { ; // no instances\n+\n+    public static Observable<KeyEvent> fromKeyEventsOf(final JComponent component) {\n+        return Observable.create(new Func1<Observer<KeyEvent>, Subscription>() {\n+            @Override\n+            public Subscription call(final Observer<KeyEvent> observer) {\n+                final KeyListener listener = new KeyListener() {\n+                    @Override\n+                    public void keyPressed(KeyEvent event) {\n+                        observer.onNext(event);\n+                    }\n+  \n+                    @Override\n+                    public void keyReleased(KeyEvent event) {\n+                        observer.onNext(event);\n+                    }\n+  \n+                    @Override\n+                    public void keyTyped(KeyEvent event) {\n+                        observer.onNext(event);\n+                    }\n+                };\n+                component.addKeyListener(listener);\n+                \n+                return Subscriptions.create(new Action0() {\n+                    @Override\n+                    public void call() {\n+                        component.removeKeyListener(listener);\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    public static class UnitTest {\n+        @Test\n+        public void testObservingActionEvents() {\n+            @SuppressWarnings(\"unchecked\")\n+            Action1<ActionEvent> action = mock(Action1.class);\n+            @SuppressWarnings(\"unchecked\")\n+            Action1<Exception> error = mock(Action1.class);\n+            Action0 complete = mock(Action0.class);\n+            \n+            final KeyEvent event = mock(KeyEvent.class);\n+            \n+            JComponent comp = new JPanel();\n+            \n+            Subscription sub = fromKeyEventsOf(comp).subscribe(action, error, complete);\n+            \n+            verify(action, never()).call(Matchers.<ActionEvent>any());\n+            verify(error, never()).call(Matchers.<Exception>any());\n+            verify(complete, never()).call();\n+            \n+            fireKeyEvent(comp, event);\n+            verify(action, times(1)).call(Matchers.<ActionEvent>any());\n+            \n+            fireKeyEvent(comp, event);\n+            verify(action, times(2)).call(Matchers.<ActionEvent>any());\n+            \n+            sub.unsubscribe();\n+            fireKeyEvent(comp, event);\n+            verify(action, times(2)).call(Matchers.<ActionEvent>any());\n+            verify(error, never()).call(Matchers.<Exception>any());\n+            verify(complete, never()).call();\n+        }\n+        \n+        private static void fireKeyEvent(JComponent component, KeyEvent event) {\n+            for (KeyListener listener: component.getKeyListeners()) {\n+                listener.keyTyped(event);\n+            }\n+        }\n+    }\n+}",
    "output": "Add key events as source for Swing observables"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java b/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java\n--- a/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java\n@@ -15,8 +15,6 @@\n  */\n package rx.concurrency;\n \n-import java.util.concurrent.TimeUnit;\n-\n import rx.Scheduler;\n import rx.Subscription;\n import rx.util.functions.Func2;\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationFinally.java b/rxjava-core/src/main/java/rx/operators/OperationFinally.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationFinally.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationFinally.java\n@@ -15,7 +15,6 @@\n  */\n package rx.operators;\n \n-import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n \n import org.junit.Before;\n@@ -24,7 +23,6 @@\n import rx.Observable;\n import rx.Observer;\n import rx.Subscription;\n-import rx.util.AtomicObservableSubscription;\n import rx.util.functions.Action0;\n import rx.util.functions.Func1;\n \n@@ -103,19 +101,24 @@ public void onNext(T args) {\n     public static class UnitTest {\n         private Action0 aAction0;\n         private Observer<String> aObserver;\n+        \n+        @SuppressWarnings(\"unchecked\") // mocking has to be unchecked, unfortunately\n         @Before\n         public void before() {\n             aAction0 = mock(Action0.class);\n             aObserver = mock(Observer.class);\n         }\n+        \n         private void checkActionCalled(Observable<String> input) {\n             Observable.create(finallyDo(input, aAction0)).subscribe(aObserver);\n             verify(aAction0, times(1)).call();\n         }\n+        \n         @Test\n         public void testFinallyCalledOnComplete() {\n             checkActionCalled(Observable.toObservable(new String[] {\"1\", \"2\", \"3\"}));\n         }\n+        \n         @Test\n         public void testFinallyCalledOnError() {\n             checkActionCalled(Observable.<String>error(new RuntimeException(\"expected\")));\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationMulticast.java b/rxjava-core/src/main/java/rx/operators/OperationMulticast.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationMulticast.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationMulticast.java\n@@ -98,6 +98,7 @@ public void testMulticast() {\n             ConnectableObservable<String> multicasted = OperationMulticast.multicast(source,\n                     PublishSubject.<String>create());\n \n+            @SuppressWarnings(\"unchecked\")\n             Observer<String> observer = mock(Observer.class);\n             multicasted.subscribe(observer);\n \n@@ -125,6 +126,7 @@ public void testMulticastConnectTwice() {\n             ConnectableObservable<String> multicasted = OperationMulticast.multicast(source,\n                     PublishSubject.<String>create());\n \n+            @SuppressWarnings(\"unchecked\")\n             Observer<String> observer = mock(Observer.class);\n             multicasted.subscribe(observer);\n \n@@ -149,6 +151,7 @@ public void testMulticastDisconnect() {\n             ConnectableObservable<String> multicasted = OperationMulticast.multicast(source,\n                     PublishSubject.<String>create());\n \n+            @SuppressWarnings(\"unchecked\")\n             Observer<String> observer = mock(Observer.class);\n             multicasted.subscribe(observer);\n \n@@ -226,11 +229,6 @@ public void sendOnNext(String value) {\n                 observer.onNext(value);\n             }\n \n-            /* used to simulate subscription */\n-            public void sendOnError(Exception e) {\n-                observer.onError(e);\n-            }\n-\n             @Override\n             public Subscription subscribe(final Observer<String> observer) {\n                 this.observer = observer;\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java b/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java\n@@ -104,6 +104,7 @@ public void testListMultipleObservers() {\n             Observer<List<String>> o1 = mock(Observer.class);\n             observable.subscribe(o1);\n \n+            @SuppressWarnings(\"unchecked\")\n             Observer<List<String>> o2 = mock(Observer.class);\n             observable.subscribe(o2);\n \n\ndiff --git a/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n--- a/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n+++ b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n@@ -16,7 +16,6 @@\n package rx.concurrency;\n \n import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n \n import java.util.Date;\n import java.util.concurrent.CountDownLatch;\n@@ -321,9 +320,6 @@ public Subscription call(Scheduler scheduler, BooleanSubscription cancel) {\n             }\n         });\n \n-        @SuppressWarnings(\"unchecked\")\n-        Observer<Integer> o = mock(Observer.class);\n-\n         final AtomicInteger count = new AtomicInteger();\n         final AtomicBoolean completed = new AtomicBoolean(false);\n         Subscription subscribe = obs.subscribe(new Observer<Integer>() {",
    "output": "Remove some unused code, fixed some (Eclipse) warnings"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java b/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java\n@@ -20,20 +20,22 @@\n import java.awt.EventQueue;\n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n-import java.lang.reflect.InvocationTargetException;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicReference;\n \n import javax.swing.Timer;\n \n+import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n import org.mockito.InOrder;\n \n import rx.Scheduler;\n import rx.Subscription;\n import rx.subscriptions.CompositeSubscription;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;\n+import rx.util.functions.Func0;\n import rx.util.functions.Func2;\n \n /**\n@@ -110,7 +112,6 @@ public void call() {\n \n     @Override\n     public <T> Subscription schedulePeriodically(T state, final Func2<Scheduler, T, Subscription> action, long initialDelay, long period, TimeUnit unit) {\n-        // FIXME test this!\n         final AtomicReference<Timer> timer = new AtomicReference<Timer>();\n         \n         final long delay = unit.toMillis(period); \n@@ -119,20 +120,17 @@ public <T> Subscription schedulePeriodically(T state, final Func2<Scheduler, T,\n         final CompositeSubscription subscriptions = new CompositeSubscription();\n         final Func2<Scheduler, T, Subscription> initialAction = new Func2<Scheduler, T, Subscription>() {\n               @Override\n-              public Subscription call(final Scheduler scheduler, final T state) {\n-                  // call the action once initially\n-                  subscriptions.add(action.call(scheduler, state));\n-                  \n+              public Subscription call(final Scheduler scheduler, final T state0) {\n                   // start timer for periodic execution, collect subscriptions\n                   timer.set(new Timer((int) delay, new ActionListener() {\n                       @Override\n                       public void actionPerformed(ActionEvent e) {\n-                          subscriptions.add(action.call(scheduler,  state));\n+                          subscriptions.add(action.call(scheduler,  state0));\n                       }\n                   }));\n                   timer.get().start();\n                   \n-                  return action.call(scheduler, state);\n+                  return action.call(scheduler, state0);\n               }\n         };\n         subscriptions.add(schedule(state, initialAction, initialDelay, unit));\n@@ -141,22 +139,68 @@ public void actionPerformed(ActionEvent e) {\n             @Override\n             public void call() {\n                 // in addition to all the individual unsubscriptions, stop the timer on unsubscribing\n-                timer.get().stop();\n+                Timer maybeTimer = timer.get();\n+                if (maybeTimer != null) {\n+                    maybeTimer.stop();\n+                }\n             }\n         }));\n         \n         return subscriptions;\n     }\n \n     private static void assertThatTheDelayIsValidForTheSwingTimer(long delay) {\n-        if (delay > Integer.MAX_VALUE) {\n-            throw new IllegalArgumentException(String.format(\"The swing timer only accepts delays up to %d milliseconds.\", Integer.MAX_VALUE));\n+        if (delay < 0 || delay > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(String.format(\"The swing timer only accepts non-negative delays up to %d milliseconds.\", Integer.MAX_VALUE));\n         }\n     }\n     \n     public static class UnitTest {\n+        @Rule\n+        public ExpectedException exception = ExpectedException.none();\n+        \n         @Test\n-        public void testNestedActions() throws InterruptedException, InvocationTargetException {\n+        public void testInvalidDelayValues() {\n+            final SwingScheduler scheduler = new SwingScheduler();\n+            final Action0 action = mock(Action0.class);\n+\n+            exception.expect(IllegalArgumentException.class);\n+            scheduler.schedulePeriodically(action, -1L, 100L, TimeUnit.SECONDS);\n+\n+            exception.expect(IllegalArgumentException.class);\n+            scheduler.schedulePeriodically(action, 100L, -1L, TimeUnit.SECONDS);\n+\n+            exception.expect(IllegalArgumentException.class);\n+            scheduler.schedulePeriodically(action, 1L + Integer.MAX_VALUE, 100L, TimeUnit.MILLISECONDS);\n+            \n+            exception.expect(IllegalArgumentException.class);\n+            scheduler.schedulePeriodically(action, 100L, 1L + Integer.MAX_VALUE / 1000, TimeUnit.SECONDS);\n+        }\n+        \n+        @Test\n+        public void testPeriodicScheduling() throws Exception {\n+            final SwingScheduler scheduler = new SwingScheduler();\n+\n+            final Action0 innerAction = mock(Action0.class);\n+            final Action0 unsubscribe = mock(Action0.class);\n+            final Func0<Subscription> action = new Func0<Subscription>() {\n+                @Override\n+                public Subscription call() {\n+                    innerAction.call();\n+                    return Subscriptions.create(unsubscribe);\n+                }\n+            };\n+            \n+            Subscription sub = scheduler.schedulePeriodically(action, 20, 100, TimeUnit.MILLISECONDS);\n+            Thread.sleep(400);\n+            sub.unsubscribe();\n+            waitForEmptyEventQueue();\n+            verify(innerAction, times(4)).call();\n+            verify(unsubscribe, times(4)).call();\n+        }\n+        \n+        @Test\n+        public void testNestedActions() throws Exception {\n             final SwingScheduler scheduler = new SwingScheduler();\n \n             final Action0 firstStepStart = mock(Action0.class);\n@@ -195,12 +239,7 @@ public void call() {\n             InOrder inOrder = inOrder(firstStepStart, firstStepEnd, secondStepStart, secondStepEnd, thirdStepStart, thirdStepEnd);\n \n             scheduler.schedule(thirdAction);\n-            EventQueue.invokeAndWait(new Runnable() {\n-                @Override\n-                public void run() {\n-                    // nothing to do, we're just waiting here for the event queue to be emptied\n-                }\n-            });\n+            waitForEmptyEventQueue();\n \n             inOrder.verify(thirdStepStart, times(1)).call();\n             inOrder.verify(thirdStepEnd, times(1)).call();\n@@ -210,5 +249,13 @@ public void run() {\n             inOrder.verify(firstStepEnd, times(1)).call();\n         }\n \n+        private static void waitForEmptyEventQueue() throws Exception {\n+            EventQueue.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+                    // nothing to do, we're just waiting here for the event queue to be emptied\n+                }\n+            });\n+        }\n     }\n }",
    "output": "Add tests against periodic scheduling. I hope the delays are stable yet fast enough"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationFilter.java b/rxjava-core/src/main/java/rx/operators/OperationFilter.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationFilter.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationFilter.java\n@@ -37,14 +37,14 @@ private static class Filter<T> implements Func1<Observer<T>, Subscription> {\n \n         private final Observable<T> that;\n         private final Func1<T, Boolean> predicate;\n-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();\n \n         public Filter(Observable<T> that, Func1<T, Boolean> predicate) {\n             this.that = that;\n             this.predicate = predicate;\n         }\n \n         public Subscription call(final Observer<T> observer) {\n+            final AtomicObservableSubscription subscription = new AtomicObservableSubscription();\n             return subscription.wrap(that.subscribe(new Observer<T>() {\n                 public void onNext(T value) {\n                     try {",
    "output": "Fix multiple subscription bug on operation filter\n\nA new subscription must be created on every subscribe call, otherwise any\nsubscribe call after the first directly fails"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -56,6 +56,7 @@\n import rx.operators.OperationOnErrorResumeNextViaFunction;\n import rx.operators.OperationOnErrorResumeNextViaObservable;\n import rx.operators.OperationOnErrorReturn;\n+import rx.operators.OperationSample;\n import rx.operators.OperationScan;\n import rx.operators.OperationSkip;\n import rx.operators.OperationSubscribeOn;\n@@ -252,13 +253,15 @@ public Subscription subscribe(final Map<String, Object> callbacks) {\n          */\n         return protectivelyWrapAndSubscribe(new Observer() {\n \n+            @Override\n             public void onCompleted() {\n                 Object onComplete = callbacks.get(\"onCompleted\");\n                 if (onComplete != null) {\n                     Functions.from(onComplete).call();\n                 }\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 Object onError = callbacks.get(\"onError\");\n@@ -267,6 +270,7 @@ public void onError(Exception e) {\n                 }\n             }\n \n+            @Override\n             public void onNext(Object args) {\n                 onNext.call(args);\n             }\n@@ -298,15 +302,18 @@ public Subscription subscribe(final Object o) {\n          */\n         return protectivelyWrapAndSubscribe(new Observer() {\n \n+            @Override\n             public void onCompleted() {\n                 // do nothing\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 // no callback defined\n             }\n \n+            @Override\n             public void onNext(Object args) {\n                 onNext.call(args);\n             }\n@@ -327,15 +334,18 @@ public Subscription subscribe(final Action1<T> onNext) {\n          */\n         return protectivelyWrapAndSubscribe(new Observer<T>() {\n \n+            @Override\n             public void onCompleted() {\n                 // do nothing\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 // no callback defined\n             }\n \n+            @Override\n             public void onNext(T args) {\n                 if (onNext == null) {\n                     throw new RuntimeException(\"onNext must be implemented\");\n@@ -365,17 +375,20 @@ public Subscription subscribe(final Object onNext, final Object onError) {\n          */\n         return protectivelyWrapAndSubscribe(new Observer() {\n \n+            @Override\n             public void onCompleted() {\n                 // do nothing\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 if (onError != null) {\n                     Functions.from(onError).call(e);\n                 }\n             }\n \n+            @Override\n             public void onNext(Object args) {\n                 onNextFunction.call(args);\n             }\n@@ -396,17 +409,20 @@ public Subscription subscribe(final Action1<T> onNext, final Action1<Exception>\n          */\n         return protectivelyWrapAndSubscribe(new Observer<T>() {\n \n+            @Override\n             public void onCompleted() {\n                 // do nothing\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 if (onError != null) {\n                     onError.call(e);\n                 }\n             }\n \n+            @Override\n             public void onNext(T args) {\n                 if (onNext == null) {\n                     throw new RuntimeException(\"onNext must be implemented\");\n@@ -436,19 +452,22 @@ public Subscription subscribe(final Object onNext, final Object onError, final O\n          */\n         return protectivelyWrapAndSubscribe(new Observer() {\n \n+            @Override\n             public void onCompleted() {\n                 if (onComplete != null) {\n                     Functions.from(onComplete).call();\n                 }\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 if (onError != null) {\n                     Functions.from(onError).call(e);\n                 }\n             }\n \n+            @Override\n             public void onNext(Object args) {\n                 onNextFunction.call(args);\n             }\n@@ -469,17 +488,20 @@ public Subscription subscribe(final Action1<T> onNext, final Action1<Exception>\n          */\n         return protectivelyWrapAndSubscribe(new Observer<T>() {\n \n+            @Override\n             public void onCompleted() {\n                 onComplete.call();\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 if (onError != null) {\n                     onError.call(e);\n                 }\n             }\n \n+            @Override\n             public void onNext(T args) {\n                 if (onNext == null) {\n                     throw new RuntimeException(\"onNext must be implemented\");\n@@ -516,10 +538,12 @@ public void forEach(final Action1<T> onNext) {\n          * See https://github.com/Netflix/RxJava/issues/216 for discussion on \"Guideline 6.4: Protect calls to user code from within an operator\"\n          */\n         protectivelyWrapAndSubscribe(new Observer<T>() {\n+            @Override\n             public void onCompleted() {\n                 latch.countDown();\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 /*\n                  * If we receive an onError event we set the reference on the outer thread\n@@ -531,6 +555,7 @@ public void onError(Exception e) {\n                 latch.countDown();\n             }\n \n+            @Override\n             public void onNext(T args) {\n                 onNext.call(args);\n             }\n@@ -582,6 +607,7 @@ public void forEach(final Object o) {\n \n         forEach(new Action1() {\n \n+            @Override\n             public void call(Object args) {\n                 onNext.call(args);\n             }\n@@ -2743,6 +2769,7 @@ public Observable<T> filter(final Object callback) {\n         final FuncN _f = Functions.from(callback);\n         return filter(this, new Func1<T, Boolean>() {\n \n+            @Override\n             public Boolean call(T t1) {\n                 return (Boolean) _f.call(t1);\n             }\n@@ -2913,6 +2940,7 @@ public <R> Observable<R> map(final Object callback) {\n         final FuncN _f = Functions.from(callback);\n         return map(this, new Func1<T, R>() {\n \n+            @Override\n             @SuppressWarnings(\"unchecked\")\n             public R call(T t1) {\n                 return (R) _f.call(t1);\n@@ -2963,6 +2991,7 @@ public <R> Observable<R> mapMany(final Object callback) {\n         final FuncN _f = Functions.from(callback);\n         return mapMany(this, new Func1<T, Observable<R>>() {\n \n+            @Override\n             @SuppressWarnings(\"unchecked\")\n             public Observable<R> call(T t1) {\n                 return (Observable<R>) _f.call(t1);\n@@ -3071,6 +3100,7 @@ public Observable<T> onErrorResumeNext(final Object resumeFunction) {\n         final FuncN _f = Functions.from(resumeFunction);\n         return onErrorResumeNext(this, new Func1<Exception, Observable<T>>() {\n \n+            @Override\n             @SuppressWarnings(\"unchecked\")\n             public Observable<T> call(Exception e) {\n                 return (Observable<T>) _f.call(e);\n@@ -3152,6 +3182,7 @@ public Observable<T> onErrorReturn(final Object resumeFunction) {\n         final FuncN _f = Functions.from(resumeFunction);\n         return onErrorReturn(this, new Func1<Exception, T>() {\n \n+            @Override\n             @SuppressWarnings(\"unchecked\")\n             public T call(Exception e) {\n                 return (T) _f.call(e);\n@@ -3288,6 +3319,34 @@ public Observable<T> scan(Func2<T, T, T> accumulator) {\n         return scan(this, accumulator);\n     }\n \n+    /**\n+     * Samples the observable sequence at each interval.\n+     * \n+     * @param period\n+     *            The period of time that defines the sampling rate.\n+     * @param unit\n+     *            The time unit for the sampling rate time period.\n+     * @return An observable sequence whose elements are the results of sampling the current observable sequence.\n+     */\n+    public Observable<T> sample(long period, TimeUnit unit) {\n+        return create(OperationSample.sample(this, period, unit));\n+    }\n+  \n+    /**\n+     * Samples the observable sequence at each interval.\n+     * \n+     * @param period\n+     *            The period of time that defines the sampling rate.\n+     * @param unit\n+     *            The time unit for the sampling rate time period.\n+     * @param scheduler\n+     *            The scheduler to use for sampling.\n+     * @return An observable sequence whose elements are the results of sampling the current observable sequence.\n+     */\n+    public Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {\n+        return create(OperationSample.sample(this, period, unit, scheduler));\n+    }\n+    \n     /**\n      * Returns an Observable that applies a function of your choosing to the first item emitted by a\n      * source Observable, then feeds the result of that function along with the second item emitted",
    "output": "Add sample methods to observable"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -64,6 +64,7 @@\n import rx.operators.OperationTakeLast;\n import rx.operators.OperationTakeUntil;\n import rx.operators.OperationTakeWhile;\n+import rx.operators.OperationTimestamp;\n import rx.operators.OperationToIterator;\n import rx.operators.OperationToObservableFuture;\n import rx.operators.OperationToObservableIterable;\n@@ -80,6 +81,7 @@\n import rx.util.AtomicObservableSubscription;\n import rx.util.AtomicObserver;\n import rx.util.Range;\n+import rx.util.Timestamped;\n import rx.util.functions.Action0;\n import rx.util.functions.Action1;\n import rx.util.functions.Func0;\n@@ -251,13 +253,15 @@ public Subscription subscribe(final Map<String, Object> callbacks) {\n          */\n         return protectivelyWrapAndSubscribe(new Observer() {\n \n+            @Override\n             public void onCompleted() {\n                 Object onComplete = callbacks.get(\"onCompleted\");\n                 if (onComplete != null) {\n                     Functions.from(onComplete).call();\n                 }\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 Object onError = callbacks.get(\"onError\");\n@@ -266,6 +270,7 @@ public void onError(Exception e) {\n                 }\n             }\n \n+            @Override\n             public void onNext(Object args) {\n                 onNext.call(args);\n             }\n@@ -297,15 +302,18 @@ public Subscription subscribe(final Object o) {\n          */\n         return protectivelyWrapAndSubscribe(new Observer() {\n \n+            @Override\n             public void onCompleted() {\n                 // do nothing\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 // no callback defined\n             }\n \n+            @Override\n             public void onNext(Object args) {\n                 onNext.call(args);\n             }\n@@ -326,15 +334,18 @@ public Subscription subscribe(final Action1<T> onNext) {\n          */\n         return protectivelyWrapAndSubscribe(new Observer<T>() {\n \n+            @Override\n             public void onCompleted() {\n                 // do nothing\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 // no callback defined\n             }\n \n+            @Override\n             public void onNext(T args) {\n                 if (onNext == null) {\n                     throw new RuntimeException(\"onNext must be implemented\");\n@@ -364,17 +375,20 @@ public Subscription subscribe(final Object onNext, final Object onError) {\n          */\n         return protectivelyWrapAndSubscribe(new Observer() {\n \n+            @Override\n             public void onCompleted() {\n                 // do nothing\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 if (onError != null) {\n                     Functions.from(onError).call(e);\n                 }\n             }\n \n+            @Override\n             public void onNext(Object args) {\n                 onNextFunction.call(args);\n             }\n@@ -395,17 +409,20 @@ public Subscription subscribe(final Action1<T> onNext, final Action1<Exception>\n          */\n         return protectivelyWrapAndSubscribe(new Observer<T>() {\n \n+            @Override\n             public void onCompleted() {\n                 // do nothing\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 if (onError != null) {\n                     onError.call(e);\n                 }\n             }\n \n+            @Override\n             public void onNext(T args) {\n                 if (onNext == null) {\n                     throw new RuntimeException(\"onNext must be implemented\");\n@@ -435,19 +452,22 @@ public Subscription subscribe(final Object onNext, final Object onError, final O\n          */\n         return protectivelyWrapAndSubscribe(new Observer() {\n \n+            @Override\n             public void onCompleted() {\n                 if (onComplete != null) {\n                     Functions.from(onComplete).call();\n                 }\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 if (onError != null) {\n                     Functions.from(onError).call(e);\n                 }\n             }\n \n+            @Override\n             public void onNext(Object args) {\n                 onNextFunction.call(args);\n             }\n@@ -468,17 +488,20 @@ public Subscription subscribe(final Action1<T> onNext, final Action1<Exception>\n          */\n         return protectivelyWrapAndSubscribe(new Observer<T>() {\n \n+            @Override\n             public void onCompleted() {\n                 onComplete.call();\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 handleError(e);\n                 if (onError != null) {\n                     onError.call(e);\n                 }\n             }\n \n+            @Override\n             public void onNext(T args) {\n                 if (onNext == null) {\n                     throw new RuntimeException(\"onNext must be implemented\");\n@@ -515,10 +538,12 @@ public void forEach(final Action1<T> onNext) {\n          * See https://github.com/Netflix/RxJava/issues/216 for discussion on \"Guideline 6.4: Protect calls to user code from within an operator\"\n          */\n         protectivelyWrapAndSubscribe(new Observer<T>() {\n+            @Override\n             public void onCompleted() {\n                 latch.countDown();\n             }\n \n+            @Override\n             public void onError(Exception e) {\n                 /*\n                  * If we receive an onError event we set the reference on the outer thread\n@@ -530,6 +555,7 @@ public void onError(Exception e) {\n                 latch.countDown();\n             }\n \n+            @Override\n             public void onNext(T args) {\n                 onNext.call(args);\n             }\n@@ -581,6 +607,7 @@ public void forEach(final Object o) {\n \n         forEach(new Action1() {\n \n+            @Override\n             public void call(Object args) {\n                 onNext.call(args);\n             }\n@@ -2664,6 +2691,7 @@ public Observable<T> filter(final Object callback) {\n         final FuncN _f = Functions.from(callback);\n         return filter(this, new Func1<T, Boolean>() {\n \n+            @Override\n             public Boolean call(T t1) {\n                 return (Boolean) _f.call(t1);\n             }\n@@ -2792,6 +2820,7 @@ public <R> Observable<R> map(final Object callback) {\n         final FuncN _f = Functions.from(callback);\n         return map(this, new Func1<T, R>() {\n \n+            @Override\n             @SuppressWarnings(\"unchecked\")\n             public R call(T t1) {\n                 return (R) _f.call(t1);\n@@ -2836,6 +2865,7 @@ public <R> Observable<R> mapMany(final Object callback) {\n         final FuncN _f = Functions.from(callback);\n         return mapMany(this, new Func1<T, Observable<R>>() {\n \n+            @Override\n             @SuppressWarnings(\"unchecked\")\n             public Observable<R> call(T t1) {\n                 return (Observable<R>) _f.call(t1);\n@@ -2944,6 +2974,7 @@ public Observable<T> onErrorResumeNext(final Object resumeFunction) {\n         final FuncN _f = Functions.from(resumeFunction);\n         return onErrorResumeNext(this, new Func1<Exception, Observable<T>>() {\n \n+            @Override\n             @SuppressWarnings(\"unchecked\")\n             public Observable<T> call(Exception e) {\n                 return (Observable<T>) _f.call(e);\n@@ -3025,6 +3056,7 @@ public Observable<T> onErrorReturn(final Object resumeFunction) {\n         final FuncN _f = Functions.from(resumeFunction);\n         return onErrorReturn(this, new Func1<Exception, T>() {\n \n+            @Override\n             @SuppressWarnings(\"unchecked\")\n             public T call(Exception e) {\n                 return (T) _f.call(e);\n@@ -3360,6 +3392,14 @@ public <E> Observable<T> takeUntil(Observable<E> other) {\n         return takeUntil(this, other);\n     }\n \n+    /**\n+     * Adds a timestamp to each item emitted by this observable.\n+     * @return An observable sequence of timestamped items.\n+     */\n+    public Observable<Timestamped<T>> timestamp() {\n+        return create(OperationTimestamp.timestamp(this));\n+    }\n+\n     /**\n      * Returns an Observable that emits a single item, a list composed of all the items emitted by\n      * the source Observable.",
    "output": "Add `timestamp` method to `Observable`, too"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/util/Timestamped.java b/rxjava-core/src/main/java/rx/util/Timestamped.java\n--- a/rxjava-core/src/main/java/rx/util/Timestamped.java\n+++ b/rxjava-core/src/main/java/rx/util/Timestamped.java\n@@ -40,9 +40,6 @@ public boolean equals(Object obj) {\n         if (this == obj) {\n             return true;\n         }\n-        if (obj == null) {\n-            return false;\n-        }\n         if (!(obj instanceof Timestamped)) {\n             return false;\n         }",
    "output": "Remove superfluous null check"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/util/Timestamped.java b/rxjava-core/src/main/java/rx/util/Timestamped.java\n--- a/rxjava-core/src/main/java/rx/util/Timestamped.java\n+++ b/rxjava-core/src/main/java/rx/util/Timestamped.java\n@@ -53,4 +53,9 @@ public int hashCode() {\n         result = prime * result + ((value == null) ? 0 : value.hashCode());\n         return result;\n     }\n+    \n+    @Override\n+    public String toString() {\n+        return String.format(\"Timestamped(timestampMillis = %d, value = %s)\", timestampMillis, value.toString());\n+    }\n }",
    "output": "Add toString to Timestamped"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/util/Timestamped.java b/rxjava-core/src/main/java/rx/util/Timestamped.java\n--- a/rxjava-core/src/main/java/rx/util/Timestamped.java\n+++ b/rxjava-core/src/main/java/rx/util/Timestamped.java\n@@ -0,0 +1,56 @@\n+package rx.util;\n+\n+/**\n+ * Composite class that takes a value and a timestamp and wraps them.   \n+ */\n+public final class Timestamped<T> {\n+    private final long timestampMillis;\n+    private final T value;\n+\n+    public Timestamped(long timestampMillis, T value) {\n+        this.value = value;\n+        this.timestampMillis = timestampMillis;\n+    }\n+\n+    public long getTimestampMillis() {\n+        return timestampMillis;\n+    }\n+\n+    public T getValue() {\n+        return value;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (!(obj instanceof Timestamped)) {\n+            return false;\n+        }\n+        Timestamped<?> other = (Timestamped<?>) obj;\n+        if (timestampMillis != other.timestampMillis) {\n+            return false;\n+        }\n+        if (value == null) {\n+            if (other.value != null) {\n+                return false;\n+            }\n+        } else if (!value.equals(other.value)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+    \n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + (int) (timestampMillis ^ (timestampMillis));\n+        result = prime * result + ((value == null) ? 0 : value.hashCode());\n+        return result;\n+    }\n+}",
    "output": "Add value class wrapping timestamped values"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java b/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java\n@@ -87,10 +87,8 @@ private void setTimer(Timer timer) {\n             }\n             \n             @Override\n-            public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n-                if (timer != null) {\n-                    timer.stop();\n-                }\n+            public void actionPerformed(ActionEvent e) {\n+                timer.stop();\n                 sub.set(action.call(SwingScheduler.this, state));\n             }\n         }\n@@ -112,7 +110,7 @@ public void call() {\n             }\n         });\n     }\n-\n+    \n     public static class UnitTest {\n         @Test\n         public void testNestedActions() throws InterruptedException, InvocationTargetException {\n@@ -155,10 +153,10 @@ public void call() {\n \n             scheduler.schedule(thirdAction);\n             EventQueue.invokeAndWait(new Runnable() {\n-              @Override\n-              public void run() {\n-                // nothing to do, we're just waiting here for the event queue to be emptied\n-              }\n+                @Override\n+                public void run() {\n+                    // nothing to do, we're just waiting here for the event queue to be emptied\n+                }\n             });\n \n             inOrder.verify(thirdStepStart, times(1)).call();",
    "output": "Fix formatting and removed superfluous checks"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Scheduler.java b/rxjava-core/src/main/java/rx/Scheduler.java\n--- a/rxjava-core/src/main/java/rx/Scheduler.java\n+++ b/rxjava-core/src/main/java/rx/Scheduler.java\n@@ -19,15 +19,13 @@\n import static org.mockito.Mockito.*;\n \n import java.util.Date;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n \n-import rx.concurrency.Schedulers;\n import rx.concurrency.TestScheduler;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;",
    "output": "Remove unused imports"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Scheduler.java b/rxjava-core/src/main/java/rx/Scheduler.java\n--- a/rxjava-core/src/main/java/rx/Scheduler.java\n+++ b/rxjava-core/src/main/java/rx/Scheduler.java\n@@ -15,10 +15,21 @@\n  */\n package rx;\n \n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n import java.util.Date;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Mockito;\n+\n+import rx.concurrency.TestScheduler;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;\n import rx.util.functions.Func0;\n@@ -97,9 +108,9 @@ public <T> Subscription schedulePeriodically(T state, final Func2<Scheduler, T,\n             @Override\n             public Subscription call(Scheduler scheduler, T state0) {\n                 if (! complete.get()) {\n-                    long startedAt = System.nanoTime();\n+                    long startedAt = now();\n                     final Subscription sub1 = action.call(scheduler, state0);\n-                    long timeTakenByActionInNanos = System.nanoTime() - startedAt;\n+                    long timeTakenByActionInNanos = TimeUnit.MILLISECONDS.toNanos(now() - startedAt);\n                     final Subscription sub2 = schedule(state0, this, periodInNanos - timeTakenByActionInNanos, TimeUnit.NANOSECONDS);\n                     return Subscriptions.create(new Action0() {\n                         @Override\n@@ -325,4 +336,39 @@ public long now() {\n         return System.currentTimeMillis();\n     }\n \n+    public static class UnitTest {\n+        @SuppressWarnings(\"unchecked\") // mocking is unchecked, unfortunately\n+        @Test\n+        public void testPeriodicScheduling() {\n+            final Func1<Long, Void> calledOp = mock(Func1.class);\n+            \n+            final TestScheduler scheduler = new TestScheduler();\n+            scheduler.schedulePeriodically(new Action0() {\n+                @Override public void call() {\n+                    System.out.println(scheduler.now());\n+                    calledOp.call(scheduler.now());\n+                }\n+            }, 1, 2, TimeUnit.SECONDS);\n+            \n+            verify(calledOp, never()).call(anyLong());\n+\n+            InOrder inOrder = Mockito.inOrder(calledOp);\n+            \n+            scheduler.advanceTimeBy(999L, TimeUnit.MILLISECONDS);\n+            inOrder.verify(calledOp, never()).call(anyLong());\n+\n+            scheduler.advanceTimeBy(1L, TimeUnit.MILLISECONDS);\n+            inOrder.verify(calledOp, times(1)).call(1000L);\n+            \n+            scheduler.advanceTimeBy(1999L, TimeUnit.MILLISECONDS);\n+            inOrder.verify(calledOp, never()).call(3000L);\n+            \n+            scheduler.advanceTimeBy(1L, TimeUnit.MILLISECONDS);\n+            inOrder.verify(calledOp, times(1)).call(3000L);\n+            \n+            scheduler.advanceTimeBy(5L, TimeUnit.SECONDS);\n+            inOrder.verify(calledOp, times(1)).call(5000L);\n+            inOrder.verify(calledOp, times(1)).call(7000L);\n+        }\n+    }\n }\n\ndiff --git a/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java b/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java\n@@ -54,11 +54,12 @@ public int compare(TimedAction<?> action1, TimedAction<?> action2) {\n         }\n     }\n \n+    // Storing time in nanoseconds internally.\n     private long time;\n \n     @Override\n     public long now() {\n-        return time;\n+        return TimeUnit.NANOSECONDS.toMillis(time);\n     }\n \n     public void advanceTimeBy(long delayTime, TimeUnit unit) {\n@@ -96,7 +97,7 @@ public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> acti\n \n     @Override\n     public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action, long delayTime, TimeUnit unit) {\n-        queue.add(new TimedAction<T>(this, now() + unit.toNanos(delayTime), action, state));\n+        queue.add(new TimedAction<T>(this, time + unit.toNanos(delayTime), action, state));\n         return Subscriptions.empty();\n     }\n }",
    "output": "Fix millisecond/nanosecond confusion in test scheduler, fixed schedulePeriodically to use now() instead of System.nanoTime() and added a test against scheduling periodically"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java b/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java\n@@ -79,6 +79,7 @@ private void triggerActions(long targetTimeInNanos) {\n         while (!queue.isEmpty()) {\n             TimedAction<?> current = queue.peek();\n             if (current.time > targetTimeInNanos) {\n+                time = targetTimeInNanos;\n                 break;\n             }\n             time = current.time;",
    "output": "Fix a bug in the test scheduler that happened when advancing time by a too little amount"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationSample.java b/rxjava-core/src/main/java/rx/operators/OperationSample.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationSample.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationSample.java\n@@ -55,6 +55,7 @@ public static <T> Func1<Observer<T>, Subscription> sample(final Observable<T> so\n     public static <T> Func1<Observer<T>, Subscription> sample(final Observable<T> source, long interval, TimeUnit unit, Scheduler scheduler) {\n         return new Sample<T>(source, interval, unit, scheduler);\n     }\n+    \n     private static class Sample<T> implements Func1<Observer<T>, Subscription> {\n         private final Observable<T> source;\n         private final long interval;",
    "output": "Add missing linebreak"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Scheduler.java b/rxjava-core/src/main/java/rx/Scheduler.java\n--- a/rxjava-core/src/main/java/rx/Scheduler.java\n+++ b/rxjava-core/src/main/java/rx/Scheduler.java\n@@ -71,6 +71,18 @@ public abstract class Scheduler {\n      */\n     public abstract <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action, long delayTime, TimeUnit unit);\n \n+    /**\n+     * Schedules a cancelable action to be executed periodically.\n+     *\n+     * @param state State to pass into the action.\n+     * @param action The action to execute periodically.\n+     * @param initialDelay Time to wait before executing the action for the first time.\n+     * @param period The time interval to wait each time in between executing the action.\n+     * @param unit The time unit the interval above is given in.\n+     * @return A subscription to be able to unsubscribe from action.\n+     */\n+    public abstract <T> Subscription schedulePeriodically(T state, Func2<Scheduler, T, Subscription> action, long initialDelay, long period, TimeUnit unit);\n+    \n     /**\n      * Schedules a cancelable action to be executed at dueTime.\n      * \n@@ -103,7 +115,7 @@ public Subscription schedule(final Func1<Scheduler, Subscription> action) {\n         return schedule(null, new Func2<Scheduler, Void, Subscription>() {\n \n             @Override\n-            public Subscription call(Scheduler scheduler, Void t2) {\n+            public Subscription call(Scheduler scheduler, @SuppressWarnings(\"unused\") Void state) {\n                 return action.call(scheduler);\n             }\n         });\n@@ -120,7 +132,7 @@ public Subscription schedule(final Func0<Subscription> action) {\n         return schedule(null, new Func2<Scheduler, Void, Subscription>() {\n \n             @Override\n-            public Subscription call(Scheduler scheduler, Void t2) {\n+            public Subscription call(@SuppressWarnings(\"unused\") Scheduler scheduler, @SuppressWarnings(\"unused\") Void state) {\n                 return action.call();\n             }\n         });\n@@ -137,7 +149,7 @@ public Subscription schedule(final Action0 action) {\n         return schedule(null, new Func2<Scheduler, Void, Subscription>() {\n \n             @Override\n-            public Subscription call(Scheduler scheduler, Void t2) {\n+            public Subscription call(@SuppressWarnings(\"unused\") Scheduler scheduler, @SuppressWarnings(\"unused\") Void state) {\n                 action.call();\n                 return Subscriptions.empty();\n             }\n@@ -159,7 +171,7 @@ public Subscription schedule(final Func1<Scheduler, Subscription> action, long d\n         return schedule(null, new Func2<Scheduler, Void, Subscription>() {\n \n             @Override\n-            public Subscription call(Scheduler scheduler, Void t2) {\n+            public Subscription call(Scheduler scheduler, @SuppressWarnings(\"unused\") Void state) {\n                 return action.call(scheduler);\n             }\n         }, delayTime, unit);\n@@ -176,7 +188,7 @@ public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit\n         return schedule(null, new Func2<Scheduler, Void, Subscription>() {\n \n             @Override\n-            public Subscription call(Scheduler scheduler, Void t2) {\n+            public Subscription call(@SuppressWarnings(\"unused\") Scheduler scheduler, @SuppressWarnings(\"unused\") Void state) {\n                 action.call();\n                 return Subscriptions.empty();\n             }\n@@ -194,23 +206,12 @@ public Subscription schedule(final Func0<Subscription> action, long delayTime, T\n         return schedule(null, new Func2<Scheduler, Void, Subscription>() {\n \n             @Override\n-            public Subscription call(Scheduler scheduler, Void t2) {\n+            public Subscription call(@SuppressWarnings(\"unused\") Scheduler scheduler, @SuppressWarnings(\"unused\") Void state) {\n                 return action.call();\n             }\n         }, delayTime, unit);\n     }\n \n-    /**\n-     * Schedules an action to be executed periodically.\n-     * \n-     * @param action The action to execute periodically.\n-     * @param initialDelay Time to wait before executing the action for the first time.\n-     * @param period The time interval to wait each time in between executing the action.\n-     * @param unit The time unit the interval above is given in.\n-     * @return A subscription to be able to unsubscribe from action.\n-     */\n-    Subscription schedulePeriodically(Action0 action, long initialDelay, long period, TimeUnit unit);\n-\n     /**\n      * Schedules a cancelable action to be executed periodically.\n      * \n@@ -220,7 +221,14 @@ public Subscription call(Scheduler scheduler, Void t2) {\n      * @param unit The time unit the interval above is given in.\n      * @return A subscription to be able to unsubscribe from action.\n      */\n-    Subscription schedulePeriodically(Func0<Subscription> action, long initialDelay, long period, TimeUnit unit);\n+    public Subscription schedulePeriodically(final Func1<Scheduler, Subscription> action, long initialDelay, long period, TimeUnit unit) {\n+        return schedulePeriodically(null, new Func2<Scheduler, Void, Subscription>() {\n+            @Override\n+            public Subscription call(Scheduler scheduler, @SuppressWarnings(\"unused\") Void state) {\n+                return action.call(scheduler);\n+            }\n+        }, initialDelay, period, unit);\n+    }\n \n     /**\n      * Schedules a cancelable action to be executed periodically.\n@@ -231,19 +239,33 @@ public Subscription call(Scheduler scheduler, Void t2) {\n      * @param unit The time unit the interval above is given in.\n      * @return A subscription to be able to unsubscribe from action.\n      */\n-    Subscription schedulePeriodically(Func1<Scheduler, Subscription> action, long initialDelay, long period, TimeUnit unit);\n+    public Subscription schedulePeriodically(final Func0<Subscription> action, long initialDelay, long period, TimeUnit unit) {\n+        return schedulePeriodically(null, new Func2<Scheduler, Void, Subscription>() {\n+            @Override\n+            public Subscription call(@SuppressWarnings(\"unused\") Scheduler scheduler, @SuppressWarnings(\"unused\") Void state) {\n+                return action.call();\n+            }\n+        }, initialDelay, period, unit);\n+    }\n \n     /**\n-     * Schedules a cancelable action to be executed periodically.\n-     *\n-     * @param state State to pass into the action.\n+     * Schedules an action to be executed periodically.\n+     * \n      * @param action The action to execute periodically.\n      * @param initialDelay Time to wait before executing the action for the first time.\n      * @param period The time interval to wait each time in between executing the action.\n      * @param unit The time unit the interval above is given in.\n      * @return A subscription to be able to unsubscribe from action.\n      */\n-    <T> Subscription schedulePeriodically(T state, Func2<Scheduler, T, Subscription> action, long initialDelay, long period, TimeUnit unit);\n+    public Subscription schedulePeriodically(final Action0 action, long initialDelay, long period, TimeUnit unit) {\n+        return schedulePeriodically(null, new Func2<Scheduler, Void, Subscription>() {\n+            @Override\n+            public Subscription call(@SuppressWarnings(\"unused\") Scheduler scheduler, @SuppressWarnings(\"unused\") Void state) {\n+                action.call();\n+                return Subscriptions.empty();\n+            }\n+        }, initialDelay, period, unit);\n+    }\n \n     /**\n      * Returns the scheduler's notion of current absolute time in milliseconds.",
    "output": "Fix the scheduler methods to fit the new pattern"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java b/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java\n@@ -20,75 +20,82 @@\n import java.util.Queue;\n import java.util.concurrent.TimeUnit;\n \n+import rx.Scheduler;\n import rx.Subscription;\n import rx.subscriptions.Subscriptions;\n-import rx.util.functions.Func0;\n+import rx.util.functions.Func2;\n \n-public class TestScheduler extends AbstractScheduler {\n-    private final Queue<TimedAction> queue = new PriorityQueue<TimedAction>(11, new CompareActionsByTime());\n-    \n-    private static class TimedAction {\n+public class TestScheduler extends Scheduler {\n+    private final Queue<TimedAction<?>> queue = new PriorityQueue<TimedAction<?>>(11, new CompareActionsByTime());\n+\n+    private static class TimedAction<T> {\n         private final long time;\n-        private final Func0<Subscription> action;\n+        private final Func2<Scheduler, T, Subscription> action;\n+        private final T state;\n+        private final TestScheduler scheduler;\n \n-        private TimedAction(long time, Func0<Subscription> action) {\n+        private TimedAction(TestScheduler scheduler, long time, Func2<Scheduler, T, Subscription> action, T state) {\n             this.time = time;\n             this.action = action;\n+            this.state = state;\n+            this.scheduler = scheduler;\n         }\n-        \n+\n         @Override\n         public String toString() {\n             return String.format(\"TimedAction(time = %d, action = %s)\", time, action.toString());\n         }\n     }\n-    \n-    private static class CompareActionsByTime implements Comparator<TimedAction> {\n-      @Override\n-      public int compare(TimedAction action1, TimedAction action2) {\n-          return Long.valueOf(action1.time).compareTo(Long.valueOf(action2.time));\n-      }\n+\n+    private static class CompareActionsByTime implements Comparator<TimedAction<?>> {\n+        @Override\n+        public int compare(TimedAction<?> action1, TimedAction<?> action2) {\n+            return Long.valueOf(action1.time).compareTo(Long.valueOf(action2.time));\n+        }\n     }\n-    \n+\n     private long time;\n-    \n-    @Override\n-    public Subscription schedule(Func0<Subscription> action) {\n-        return schedule(action, 0L, TimeUnit.NANOSECONDS);\n-    }\n \n-    @Override\n-    public Subscription schedule(Func0<Subscription> action, long dueTime, TimeUnit unit) {\n-        queue.add(new TimedAction(now() + unit.toNanos(dueTime), action));\n-        return Subscriptions.empty();\n-    }\n-    \n     @Override\n     public long now() {\n         return time;\n     }\n \n-    public void advanceTimeBy(long dueTime, TimeUnit unit) {\n-        advanceTimeTo(time + unit.toNanos(dueTime), TimeUnit.NANOSECONDS);\n+    public void advanceTimeBy(long delayTime, TimeUnit unit) {\n+        advanceTimeTo(time + unit.toNanos(delayTime), TimeUnit.NANOSECONDS);\n     }\n-    \n-    public void advanceTimeTo(long dueTime, TimeUnit unit) {\n-        long targetTime = unit.toNanos(dueTime);\n+\n+    public void advanceTimeTo(long delayTime, TimeUnit unit) {\n+        long targetTime = unit.toNanos(delayTime);\n         triggerActions(targetTime);\n     }\n \n     public void triggerActions() {\n-      triggerActions(time);\n+        triggerActions(time);\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     private void triggerActions(long targetTimeInNanos) {\n-        while (! queue.isEmpty()) {\n-            TimedAction current = queue.peek();\n+        while (!queue.isEmpty()) {\n+            TimedAction<?> current = queue.peek();\n             if (current.time > targetTimeInNanos) {\n                 break;\n             }\n             time = current.time;\n             queue.remove();\n-            current.action.call();\n+            // because the queue can have wildcards we have to ignore the type T for the state\n+            ((Func2<Scheduler, Object, Subscription>) current.action).call(current.scheduler, current.state);\n         }\n     }\n+\n+    @Override\n+    public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action) {\n+        return schedule(state, action, 0, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @Override\n+    public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action, long delayTime, TimeUnit unit) {\n+        queue.add(new TimedAction<T>(this, now() + unit.toNanos(delayTime), action, state));\n+        return Subscriptions.empty();\n+    }\n }",
    "output": "Upgrade TestScheduler to match merged Scheduler changes - I accidentally merged this code before fixing it to match the changes to AbstractScheduler/Scheduler"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java b/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java\n--- a/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/SleepingAction.java\n@@ -29,14 +29,18 @@\n     public SleepingAction(Func0<Subscription> underlying, Scheduler scheduler, long timespan, TimeUnit timeUnit) {\n         this.underlying = underlying;\n         this.scheduler = scheduler;\n-        this.execTime = scheduler.now() + timeUnit.toMillis(timespan);\n+        this.execTime = scheduler.now() + timeUnit.toNanos(timespan);\n     }\n \n     @Override\n     public Subscription call() {\n-        if (execTime < scheduler.now()) {\n+        if (execTime > scheduler.now()) {\n             try {\n-                Thread.sleep(scheduler.now() - execTime);\n+                long nanos = execTime - scheduler.now();\n+                long milis = nanos / 1000000;\n+                if (milis > 0) {\n+                    Thread.sleep(milis);\n+                }\n             } catch (InterruptedException e) {\n                 Thread.currentThread().interrupt();\n                 throw new RuntimeException(e);",
    "output": "Fix sleeping action"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n--- a/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n+++ b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n@@ -16,20 +16,24 @@\n package rx.concurrency;\n \n import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n \n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.Test;\n \n import rx.Observable;\n import rx.Observer;\n+import rx.Scheduler;\n import rx.Subscription;\n+import rx.subscriptions.BooleanSubscription;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action1;\n import rx.util.functions.Func1;\n+import rx.util.functions.Func2;\n \n public class TestSchedulers {\n \n@@ -245,4 +249,114 @@ public void call(Integer t) {\n         assertEquals(5, count.get());\n     }\n \n+    @Test\n+    public void testRecursiveScheduler1() {\n+        Observable<Integer> obs = Observable.create(new Func1<Observer<Integer>, Subscription>() {\n+            @Override\n+            public Subscription call(final Observer<Integer> observer) {\n+                return Schedulers.currentThread().schedule(0, new Func2<Scheduler, Integer, Subscription>() {\n+                    @Override\n+                    public Subscription call(Scheduler scheduler, Integer i) {\n+                        if (i > 42) {\n+                            observer.onCompleted();\n+                            return Subscriptions.empty();\n+                        }\n+\n+                        observer.onNext(i);\n+\n+                        return scheduler.schedule(i + 1, this);\n+                    }\n+                });\n+            }\n+        });\n+\n+        final AtomicInteger lastValue = new AtomicInteger();\n+        obs.forEach(new Action1<Integer>() {\n+\n+            @Override\n+            public void call(Integer v) {\n+                System.out.println(\"Value: \" + v);\n+                lastValue.set(v);\n+            }\n+        });\n+\n+        assertEquals(42, lastValue.get());\n+    }\n+\n+    @Test\n+    public void testRecursiveScheduler2() throws InterruptedException {\n+        // use latches instead of Thread.sleep\n+        final CountDownLatch latch = new CountDownLatch(10);\n+        final CountDownLatch completionLatch = new CountDownLatch(1);\n+\n+        Observable<Integer> obs = Observable.create(new Func1<Observer<Integer>, Subscription>() {\n+            @Override\n+            public Subscription call(final Observer<Integer> observer) {\n+\n+                return Schedulers.threadPoolForComputation().schedule(new BooleanSubscription(), new Func2<Scheduler, BooleanSubscription, Subscription>() {\n+                    @Override\n+                    public Subscription call(Scheduler scheduler, BooleanSubscription cancel) {\n+                        if (cancel.isUnsubscribed()) {\n+                            observer.onCompleted();\n+                            completionLatch.countDown();\n+                            return Subscriptions.empty();\n+                        }\n+\n+                        observer.onNext(42);\n+                        latch.countDown();\n+\n+                        try {\n+                            Thread.sleep(1);\n+                        } catch (InterruptedException e) {\n+                            e.printStackTrace();\n+                        }\n+\n+                        scheduler.schedule(cancel, this);\n+\n+                        return cancel;\n+                    }\n+                });\n+            }\n+        });\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Observer<Integer> o = mock(Observer.class);\n+\n+        final AtomicInteger count = new AtomicInteger();\n+        final AtomicBoolean completed = new AtomicBoolean(false);\n+        Subscription subscribe = obs.subscribe(new Observer<Integer>() {\n+            @Override\n+            public void onCompleted() {\n+                System.out.println(\"Completed\");\n+                completed.set(true);\n+            }\n+\n+            @Override\n+            public void onError(Exception e) {\n+                System.out.println(\"Error\");\n+            }\n+\n+            @Override\n+            public void onNext(Integer args) {\n+                count.incrementAndGet();\n+                System.out.println(args);\n+            }\n+        });\n+\n+        if (!latch.await(5000, TimeUnit.MILLISECONDS)) {\n+            fail(\"Timed out waiting on onNext latch\");\n+        }\n+\n+        // now unsubscribe and ensure it stops the recursive loop\n+        subscribe.unsubscribe();\n+        System.out.println(\"unsubscribe\");\n+\n+        if (!completionLatch.await(5000, TimeUnit.MILLISECONDS)) {\n+            fail(\"Timed out waiting on completion latch\");\n+        }\n+\n+        assertEquals(10, count.get()); // wondering if this could be 11 in a race condition (which would be okay due to how unsubscribe works ... just it would make this test non-deterministic)\n+        assertTrue(completed.get());\n+    }\n+\n }",
    "output": "Add unit tests for recursive scheduler usage\n\nThese tests came from @mairbek at https://github.com/Netflix/RxJava/pull/229#issuecomment-16115941"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java\n@@ -69,14 +69,17 @@ public void testObserveOn() {\n \n         @Test\n         @SuppressWarnings(\"unchecked\")\n-        public void testOrdering() {\n+        public void testOrdering() throws InterruptedException {\n             Observable<String> obs = Observable.from(\"one\", null, \"two\", \"three\", \"four\");\n \n             Observer<String> observer = mock(Observer.class);\n \n             InOrder inOrder = inOrder(observer);\n \n             obs.observeOn(Schedulers.threadPoolForComputation()).subscribe(observer);\n+\n+            Thread.sleep(500); // !!! not a true unit test\n+\n             inOrder.verify(observer, times(1)).onNext(\"one\");\n             inOrder.verify(observer, times(1)).onNext(null);\n             inOrder.verify(observer, times(1)).onNext(\"two\");",
    "output": "Fix UnitTest"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java b/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java\n--- a/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java\n@@ -24,8 +24,6 @@\n import rx.subjects.Subject;\n import rx.util.functions.Func1;\n \n-import javax.annotation.concurrent.GuardedBy;\n-\n import static org.mockito.Mockito.*;\n \n public class OperatorMulticast {\n@@ -39,7 +37,6 @@ private static class MulticastConnectableObservable<T, R> extends ConnectableObs\n         private final Observable<T> source;\n         private final Subject<T, R> subject;\n \n-        @GuardedBy(\"lock\")\n         private Subscription subscription;\n \n         public MulticastConnectableObservable(Observable<T> source, final Subject<T, R> subject) {",
    "output": "Remove annotation"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationSample.java b/rxjava-core/src/main/java/rx/operators/OperationSample.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationSample.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationSample.java\n@@ -15,23 +15,24 @@\n  */\n package rx.operators;\n \n-import static org.junit.Assert.*;\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n-import static rx.operators.Tester.UnitTest.*;\n \n import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n \n+import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.InOrder;\n \n import rx.Observable;\n import rx.Observer;\n import rx.Scheduler;\n import rx.Subscription;\n import rx.concurrency.Schedulers;\n+import rx.concurrency.TestScheduler;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;\n import rx.util.functions.Func1;\n@@ -78,7 +79,7 @@ public Subscription call(final Observer<T> observer) {\n                 public void onCompleted() { /* the clock never completes */ }\n                 \n                 @Override\n-                public void onError(Exception e) { /* the clock has no errors */ }\n+                public void onError(@SuppressWarnings(\"unused\") Exception e) { /* the clock has no errors */ }\n                 \n                 @Override\n                 public void onNext(@SuppressWarnings(\"unused\") Long tick) {\n@@ -119,6 +120,77 @@ public void call() {\n     }\n     \n     public static class UnitTest {\n-        // TODO\n+        private TestScheduler scheduler;\n+        private Observer<Long> observer;\n+        \n+        @Before\n+        @SuppressWarnings(\"unchecked\") // due to mocking\n+        public void before() {\n+            scheduler = new TestScheduler();\n+            observer = mock(Observer.class);\n+        }\n+        \n+        @Test\n+        public void testSample() {\n+            Observable<Long> source = Observable.create(new Func1<Observer<Long>, Subscription>() {\n+                @Override\n+                public Subscription call(final Observer<Long> observer1) {\n+                    scheduler.schedule(new Action0() {\n+                        @Override\n+                        public void call() {\n+                            observer1.onNext(1L);\n+                        }\n+                    }, 1, TimeUnit.SECONDS);\n+                    scheduler.schedule(new Action0() {\n+                        @Override\n+                        public void call() {\n+                            observer1.onNext(2L);\n+                        }\n+                    }, 2, TimeUnit.SECONDS);\n+                    scheduler.schedule(new Action0() {\n+                        @Override\n+                        public void call() {\n+                            observer1.onCompleted();\n+                        }\n+                    }, 3, TimeUnit.SECONDS);\n+                    \n+                    return Subscriptions.empty();\n+                }\n+            });\n+            \n+            Observable<Long> sampled = Observable.create(OperationSample.sample(source, 400L, TimeUnit.MILLISECONDS, scheduler));\n+            sampled.subscribe(observer);\n+            \n+            InOrder inOrder = inOrder(observer);\n+\n+            scheduler.advanceTimeTo(800L, TimeUnit.MILLISECONDS);\n+            verify(observer, never()).onNext(any(Long.class));\n+            verify(observer, never()).onCompleted();\n+            verify(observer, never()).onError(any(Exception.class));\n+            \n+            scheduler.advanceTimeTo(1200L, TimeUnit.MILLISECONDS);\n+            inOrder.verify(observer, times(1)).onNext(1L);\n+            verify(observer, never()).onNext(2L);\n+            verify(observer, never()).onCompleted();\n+            verify(observer, never()).onError(any(Exception.class));\n+\n+            scheduler.advanceTimeTo(1600L, TimeUnit.MILLISECONDS);\n+            inOrder.verify(observer, times(1)).onNext(1L);\n+            verify(observer, never()).onNext(2L);\n+            verify(observer, never()).onCompleted();\n+            verify(observer, never()).onError(any(Exception.class));\n+            \n+            scheduler.advanceTimeTo(2000L, TimeUnit.MILLISECONDS);\n+            inOrder.verify(observer, never()).onNext(1L);\n+            inOrder.verify(observer, times(1)).onNext(2L);\n+            verify(observer, never()).onCompleted();\n+            verify(observer, never()).onError(any(Exception.class));\n+            \n+            scheduler.advanceTimeTo(3000L, TimeUnit.MILLISECONDS);\n+            inOrder.verify(observer, never()).onNext(1L);\n+            inOrder.verify(observer, times(2)).onNext(2L);\n+            verify(observer, times(1)).onCompleted();\n+            verify(observer, never()).onError(any(Exception.class));\n+        }\n     }\n }",
    "output": "Add a unit test against the sample operator"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java b/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/SwingScheduler.java\n@@ -0,0 +1,173 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.concurrency;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.awt.EventQueue;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.swing.Timer;\n+\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+\n+import rx.Subscription;\n+import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n+import rx.util.functions.Func0;\n+\n+/**\n+ * Executes work on the Swing UI thread. \n+ * This scheduler should only be used with actions that execute quickly.\n+ */\n+public final class SwingScheduler extends AbstractScheduler {\n+    private static final SwingScheduler INSTANCE = new SwingScheduler();\n+\n+    public static SwingScheduler getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    private SwingScheduler() {\n+    }\n+\n+    @Override\n+    public Subscription schedule(final Func0<Subscription> action) {\n+        final AtomicReference<Subscription> sub = new AtomicReference<Subscription>();\n+        EventQueue.invokeLater(new Runnable() {\n+            @Override\n+            public void run() {\n+                sub.set(action.call());\n+            }\n+        });\n+        return Subscriptions.create(new Action0() {\n+            @Override\n+            public void call() {\n+                Subscription subscription = sub.get();\n+                if (subscription != null) {\n+                    subscription.unsubscribe();\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public Subscription schedule(final Func0<Subscription> action, long dueTime, TimeUnit unit) {\n+        final AtomicReference<Subscription> sub = new AtomicReference<Subscription>();\n+        long delay = unit.toMillis(dueTime); \n+        \n+        if (delay > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"The swing timer only accepts delays up to %d milliseconds.\", Integer.MAX_VALUE));\n+        }\n+        \n+        class ExecuteOnceAction implements ActionListener {\n+            private Timer timer;\n+            \n+            private void setTimer(Timer timer) {\n+                this.timer = timer;\n+            }\n+            \n+            @Override\n+            public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n+                if (timer != null) {\n+                    timer.stop();\n+                }\n+                sub.set(action.call());\n+            }\n+        }\n+        \n+        ExecuteOnceAction executeOnce = new ExecuteOnceAction();\n+        final Timer timer = new Timer((int) delay, executeOnce);\n+        executeOnce.setTimer(timer);\n+        timer.start();\n+        \n+        return Subscriptions.create(new Action0() {\n+            @Override\n+            public void call() {\n+                timer.stop();\n+                \n+                Subscription subscription = sub.get();\n+                if (subscription != null) {\n+                    subscription.unsubscribe();\n+                }\n+            }\n+        });\n+    }\n+\n+    public static class UnitTest {\n+        @Test\n+        public void testNestedActions() throws InterruptedException, InvocationTargetException {\n+            final SwingScheduler scheduler = new SwingScheduler();\n+\n+            final Action0 firstStepStart = mock(Action0.class);\n+            final Action0 firstStepEnd = mock(Action0.class);\n+\n+            final Action0 secondStepStart = mock(Action0.class);\n+            final Action0 secondStepEnd = mock(Action0.class);\n+\n+            final Action0 thirdStepStart = mock(Action0.class);\n+            final Action0 thirdStepEnd = mock(Action0.class);\n+\n+            final Action0 firstAction = new Action0() {\n+                @Override\n+                public void call() {\n+                    firstStepStart.call();\n+                    firstStepEnd.call();\n+                }\n+            };\n+            final Action0 secondAction = new Action0() {\n+                @Override\n+                public void call() {\n+                    secondStepStart.call();\n+                    scheduler.schedule(firstAction);\n+                    secondStepEnd.call();\n+                }\n+            };\n+            final Action0 thirdAction = new Action0() {\n+                @Override\n+                public void call() {\n+                    thirdStepStart.call();\n+                    scheduler.schedule(secondAction);\n+                    thirdStepEnd.call();\n+                }\n+            };\n+\n+            InOrder inOrder = inOrder(firstStepStart, firstStepEnd, secondStepStart, secondStepEnd, thirdStepStart, thirdStepEnd);\n+\n+            scheduler.schedule(thirdAction);\n+            EventQueue.invokeAndWait(new Runnable() {\n+              @Override\n+              public void run() {\n+                // nothing to do, we're just waiting here for the event queue to be emptied\n+              }\n+            });\n+\n+            inOrder.verify(thirdStepStart, times(1)).call();\n+            inOrder.verify(thirdStepEnd, times(1)).call();\n+            inOrder.verify(secondStepStart, times(1)).call();\n+            inOrder.verify(secondStepEnd, times(1)).call();\n+            inOrder.verify(firstStepStart, times(1)).call();\n+            inOrder.verify(firstStepEnd, times(1)).call();\n+        }\n+\n+    }\n+\n+}",
    "output": "Add a scheduler for scheduling actions on the Swing event thread"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java b/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java\n--- a/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java\n+++ b/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java\n@@ -45,21 +45,21 @@ public String toString() {\n     private static class CompareActionsByTime implements Comparator<TimedAction> {\n       @Override\n       public int compare(TimedAction action1, TimedAction action2) {\n-        return Long.valueOf(action1.time).compareTo(Long.valueOf(action2.time));\n+          return Long.valueOf(action1.time).compareTo(Long.valueOf(action2.time));\n       }\n     }\n     \n     private long time;\n     \n     @Override\n     public Subscription schedule(Func0<Subscription> action) {\n-      return schedule(action, 0L, TimeUnit.NANOSECONDS);\n+        return schedule(action, 0L, TimeUnit.NANOSECONDS);\n     }\n \n     @Override\n     public Subscription schedule(Func0<Subscription> action, long dueTime, TimeUnit unit) {\n-      queue.add(new TimedAction(now() + unit.toNanos(dueTime), action));\n-      return Subscriptions.empty();\n+        queue.add(new TimedAction(now() + unit.toNanos(dueTime), action));\n+        return Subscriptions.empty();\n     }\n     \n     @Override\n@@ -68,7 +68,7 @@ public long now() {\n     }\n \n     public void advanceTimeBy(long dueTime, TimeUnit unit) {\n-      advanceTimeTo(time + unit.toNanos(dueTime), TimeUnit.NANOSECONDS);\n+        advanceTimeTo(time + unit.toNanos(dueTime), TimeUnit.NANOSECONDS);\n     }\n     \n     public void advanceTimeTo(long dueTime, TimeUnit unit) {",
    "output": "Fix yet more indentation issues"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationInterval.java b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n@@ -74,10 +74,10 @@ private Interval(long interval, TimeUnit unit, Scheduler scheduler) {\n         public Subscription call(final Observer<Long> observer) {\n             scheduler.schedule(new IntervalAction(observer), interval, unit);\n             return Subscriptions.create(new Action0() {\n-              @Override\n-              public void call() {\n-                complete.set(true);\n-              }\n+                @Override\n+                public void call() {\n+                    complete.set(true);\n+                }\n             });\n         }\n         ",
    "output": "Fix indentation"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationInterval.java b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationInterval.java\n@@ -15,20 +15,24 @@\n  */\n package rx.operators;\n \n-import static org.junit.Assert.*;\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n-import static rx.operators.Tester.UnitTest.*;\n \n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n+import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.InOrder;\n \n+import rx.Observable;\n import rx.Observer;\n import rx.Scheduler;\n import rx.Subscription;\n import rx.concurrency.Schedulers;\n-import rx.util.functions.Func0;\n+import rx.concurrency.TestScheduler;\n+import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n import rx.util.functions.Func1;\n \n /**\n@@ -57,6 +61,7 @@ private static class Interval implements Func1<Observer<Long>, Subscription> {\n         private final Scheduler scheduler;\n         \n         private long currentValue;\n+        private final AtomicBoolean complete = new AtomicBoolean();\n \n         private Interval(long interval, TimeUnit unit, Scheduler scheduler) {\n             this.interval = interval;\n@@ -66,18 +71,69 @@ private Interval(long interval, TimeUnit unit, Scheduler scheduler) {\n \n         @Override\n         public Subscription call(final Observer<Long> observer) {\n-            return scheduler.schedule(new Func0<Subscription>() {\n-                @Override\n-                public Subscription call() {\n+            scheduler.schedule(new IntervalAction(observer), interval, unit);\n+            return Subscriptions.create(new Action0() {\n+              @Override\n+              public void call() {\n+                complete.set(true);\n+              }\n+            });\n+        }\n+        \n+        private class IntervalAction implements Action0 {\n+            private final Observer<Long> observer;\n+            \n+            private IntervalAction(Observer<Long> observer) {\n+                this.observer = observer;\n+            }\n+            \n+            @Override\n+            public void call() {\n+                if (complete.get()) {\n+                    observer.onCompleted();\n+                } else {\n                     observer.onNext(currentValue);\n                     currentValue++;\n-                    return Interval.this.call(observer);\n+                    scheduler.schedule(this, interval, unit);\n                 }\n-            }, interval, unit);\n+            }\n         }\n     }\n     \n     public static class UnitTest {\n-        // TODO\n+        private TestScheduler scheduler;\n+        private Observer<Long> observer;\n+        \n+        @Before\n+        @SuppressWarnings(\"unchecked\") // due to mocking\n+        public void before() {\n+            scheduler = new TestScheduler();\n+            observer = mock(Observer.class);\n+        }\n+        \n+        @Test\n+        public void testInterval() {\n+            Observable<Long> w = Observable.create(OperationInterval.interval(1, TimeUnit.SECONDS, scheduler));\n+            Subscription sub = w.subscribe(observer);\n+            \n+            verify(observer, never()).onNext(0L);\n+            verify(observer, never()).onCompleted();\n+            verify(observer, never()).onError(any(Exception.class));\n+            \n+            scheduler.advanceTimeTo(2, TimeUnit.SECONDS);\n+\n+            InOrder inOrder = inOrder(observer);\n+            inOrder.verify(observer, times(1)).onNext(0L);\n+            inOrder.verify(observer, times(1)).onNext(1L);\n+            inOrder.verify(observer, never()).onNext(2L);\n+            verify(observer, never()).onCompleted();\n+            verify(observer, never()).onError(any(Exception.class));\n+            \n+            sub.unsubscribe();\n+            scheduler.advanceTimeTo(4, TimeUnit.SECONDS);\n+            verify(observer, never()).onNext(2L);\n+            verify(observer, times(1)).onCompleted();\n+            verify(observer, never()).onError(any(Exception.class));\n+        }\n     }\n }\n\ndiff --git a/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java b/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java\n--- a/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java\n+++ b/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java\n@@ -35,6 +35,11 @@ private TimedAction(long time, Func0<Subscription> action) {\n             this.time = time;\n             this.action = action;\n         }\n+        \n+        @Override\n+        public String toString() {\n+            return String.format(\"TimedAction(time = %d, action = %s)\", time, action.toString());\n+        }\n     }\n     \n     private static class CompareActionsByTime implements Comparator<TimedAction> {",
    "output": "Add a unit test. Fixed the implementation. Maybe still a bit naive when it comes to intervals that are too small to keep up with?"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java b/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java\n--- a/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java\n+++ b/rxjava-core/src/test/java/rx/concurrency/TestScheduler.java\n@@ -0,0 +1,89 @@\n+/**\n+ * Copyright 2013 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.concurrency;\n+\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.Queue;\n+import java.util.concurrent.TimeUnit;\n+\n+import rx.Subscription;\n+import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Func0;\n+\n+public class TestScheduler extends AbstractScheduler {\n+    private final Queue<TimedAction> queue = new PriorityQueue<TimedAction>(11, new CompareActionsByTime());\n+    \n+    private static class TimedAction {\n+        private final long time;\n+        private final Func0<Subscription> action;\n+\n+        private TimedAction(long time, Func0<Subscription> action) {\n+            this.time = time;\n+            this.action = action;\n+        }\n+    }\n+    \n+    private static class CompareActionsByTime implements Comparator<TimedAction> {\n+      @Override\n+      public int compare(TimedAction action1, TimedAction action2) {\n+        return Long.valueOf(action1.time).compareTo(Long.valueOf(action2.time));\n+      }\n+    }\n+    \n+    private long time;\n+    \n+    @Override\n+    public Subscription schedule(Func0<Subscription> action) {\n+      return schedule(action, 0L, TimeUnit.NANOSECONDS);\n+    }\n+\n+    @Override\n+    public Subscription schedule(Func0<Subscription> action, long dueTime, TimeUnit unit) {\n+      queue.add(new TimedAction(now() + unit.toNanos(dueTime), action));\n+      return Subscriptions.empty();\n+    }\n+    \n+    @Override\n+    public long now() {\n+        return time;\n+    }\n+\n+    public void advanceTimeBy(long dueTime, TimeUnit unit) {\n+      advanceTimeTo(time + unit.toNanos(dueTime), TimeUnit.NANOSECONDS);\n+    }\n+    \n+    public void advanceTimeTo(long dueTime, TimeUnit unit) {\n+        long targetTime = unit.toNanos(dueTime);\n+        triggerActions(targetTime);\n+    }\n+\n+    public void triggerActions() {\n+      triggerActions(time);\n+    }\n+    \n+    private void triggerActions(long targetTimeInNanos) {\n+        while (! queue.isEmpty()) {\n+            TimedAction current = queue.peek();\n+            if (current.time > targetTimeInNanos) {\n+                break;\n+            }\n+            time = current.time;\n+            queue.remove();\n+            current.action.call();\n+        }\n+    }\n+}",
    "output": "Add a TestScheduler which collects actions in a queue and has adjustable time"
  },
  {
    "input": "diff --git a/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n--- a/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n+++ b/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java\n@@ -17,11 +17,17 @@\n \n import static org.junit.Assert.*;\n \n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.Test;\n \n import rx.Observable;\n+import rx.Observer;\n+import rx.Subscription;\n+import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action1;\n import rx.util.functions.Func1;\n \n@@ -181,7 +187,7 @@ public void call(String t) {\n     }\n \n     @Test\n-    public void testSubscribeWithScheduler1() {\n+    public void testSubscribeWithScheduler1() throws InterruptedException {\n \n         final AtomicInteger count = new AtomicInteger();\n \n@@ -204,16 +210,39 @@ public void call(Integer t) {\n \n         // now we'll subscribe with a scheduler and it should be async\n \n+        final String currentThreadName = Thread.currentThread().getName();\n+\n+        // latches for deterministically controlling the test below across threads\n+        final CountDownLatch latch = new CountDownLatch(5);\n+        final CountDownLatch first = new CountDownLatch(1);\n+\n         o1.subscribe(new Action1<Integer>() {\n \n             @Override\n             public void call(Integer t) {\n+                try {\n+                    // we block the first one so we can assert this executes asynchronously with a count\n+                    first.await(1000, TimeUnit.SECONDS);\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(\"The latch should have released if we are async.\", e);\n+                }\n+                assertFalse(Thread.currentThread().getName().equals(currentThreadName));\n+                assertTrue(Thread.currentThread().getName().startsWith(\"RxComputationThreadPool\"));\n                 System.out.println(\"Thread: \" + Thread.currentThread().getName());\n                 System.out.println(\"t: \" + t);\n                 count.incrementAndGet();\n+                latch.countDown();\n             }\n         }, Schedulers.threadPoolForComputation());\n \n+        // assert we are async\n         assertEquals(0, count.get());\n+        // release the latch so it can go forward\n+        first.countDown();\n+\n+        // wait for all 5 responses\n+        latch.await();\n+        assertEquals(5, count.get());\n     }\n+\n }",
    "output": "Fix non-deterministic unit test"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/Schedulers.java b/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n--- a/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n@@ -20,6 +20,7 @@\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import rx.Scheduler;\n \n@@ -127,7 +128,7 @@ public Thread newThread(Runnable r) {\n \n     private static Executor createIOExecutor() {\n         Executor result = Executors.newCachedThreadPool(new ThreadFactory() {\n-            final AtomicInteger counter = new AtomicInteger();\n+            final AtomicLong counter = new AtomicLong();\n \n             @Override\n             public Thread newThread(Runnable r) {",
    "output": "Use long instead of int\n\n … considering very long running app with lots of IO events"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/ForwardingScheduler.java b/rxjava-core/src/main/java/rx/concurrency/ForwardingScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/ForwardingScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/ForwardingScheduler.java\n@@ -1,56 +0,0 @@\n-/**\n- * Copyright 2013 Netflix, Inc.\n- * \n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * \n- * http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package rx.concurrency;\n-\n-import rx.Scheduler;\n-import rx.Subscription;\n-import rx.util.functions.Action0;\n-import rx.util.functions.Func0;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-public class ForwardingScheduler implements Scheduler {\n-    private final Scheduler underlying;\n-\n-    public ForwardingScheduler(Scheduler underlying) {\n-        this.underlying = underlying;\n-    }\n-\n-    @Override\n-    public Subscription schedule(Action0 action) {\n-        return underlying.schedule(action);\n-    }\n-\n-    @Override\n-    public Subscription schedule(Func0<Subscription> action) {\n-        return underlying.schedule(action);\n-    }\n-\n-    @Override\n-    public Subscription schedule(Action0 action, long dueTime, TimeUnit unit) {\n-        return underlying.schedule(action, dueTime, unit);\n-    }\n-\n-    @Override\n-    public Subscription schedule(Func0<Subscription> action, long dueTime, TimeUnit unit) {\n-        return underlying.schedule(action, dueTime, unit);\n-    }\n-\n-    @Override\n-    public long now() {\n-        return underlying.now();\n-    }\n-}\n\\ No newline at end of file\n\ndiff --git a/rxjava-core/src/main/java/rx/concurrency/Schedulers.java b/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n--- a/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n@@ -63,10 +63,6 @@ public static Scheduler threadPoolForIO() {\n         return fromScheduledExecutorService(IO_EXECUTOR);\n     }\n \n-    public static Scheduler forwardingScheduler(Scheduler underlying) {\n-        return new ForwardingScheduler(underlying);\n-    }\n-\n     private static ScheduledExecutorService createComputationExecutor() {\n         int cores = Runtime.getRuntime().availableProcessors();\n         return Executors.newScheduledThreadPool(cores, new ThreadFactory() {\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java\n@@ -1,12 +1,12 @@\n /**\n  * Copyright 2013 Netflix, Inc.\n- *\n+ * \n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n+ * \n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * \n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -15,7 +15,11 @@\n  */\n package rx.operators;\n \n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n import org.junit.Test;\n+\n import rx.Observable;\n import rx.Observer;\n import rx.Scheduler;\n@@ -24,11 +28,6 @@\n import rx.util.functions.Action0;\n import rx.util.functions.Func1;\n \n-import static org.mockito.Matchers.any;\n-import static org.mockito.Mockito.*;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n-\n public class OperationObserveOn {\n \n     public static <T> Func1<Observer<T>, Subscription> observeOn(Observable<T> source, Scheduler scheduler) {\n@@ -56,7 +55,7 @@ public static class UnitTest {\n         @SuppressWarnings(\"unchecked\")\n         public void testObserveOn() {\n \n-            Scheduler scheduler = spy(Schedulers.forwardingScheduler(Schedulers.immediate()));\n+            Scheduler scheduler = spy(Tester.UnitTest.forwardingScheduler(Schedulers.immediate()));\n \n             Observer<Integer> observer = mock(Observer.class);\n             Observable.create(observeOn(Observable.toObservable(1, 2, 3), scheduler)).subscribe(observer);\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationSubscribeOn.java b/rxjava-core/src/main/java/rx/operators/OperationSubscribeOn.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationSubscribeOn.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationSubscribeOn.java\n@@ -81,7 +81,7 @@ public static class UnitTest {\n         public void testSubscribeOn() {\n             Observable<Integer> w = Observable.toObservable(1, 2, 3);\n \n-            Scheduler scheduler = spy(Schedulers.forwardingScheduler(Schedulers.immediate()));\n+            Scheduler scheduler = spy(Tester.UnitTest.forwardingScheduler(Schedulers.immediate()));\n \n             Observer<Integer> observer = mock(Observer.class);\n             Subscription subscription = Observable.create(subscribeOn(w, scheduler)).subscribe(observer);\n\ndiff --git a/rxjava-core/src/main/java/rx/operators/Tester.java b/rxjava-core/src/main/java/rx/operators/Tester.java\n--- a/rxjava-core/src/main/java/rx/operators/Tester.java\n+++ b/rxjava-core/src/main/java/rx/operators/Tester.java\n@@ -5,15 +5,19 @@\n import java.lang.Thread.UncaughtExceptionHandler;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.Test;\n \n import rx.Observable;\n import rx.Observer;\n+import rx.Scheduler;\n import rx.Subscription;\n import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n+import rx.util.functions.Func0;\n import rx.util.functions.Func1;\n \n /**\n@@ -43,6 +47,16 @@ public Subscription call(Observer<T> observer)\n             };\n         }\n \n+        /**\n+         * Used for mocking of Schedulers since many Scheduler implementations are static/final.\n+         * \n+         * @param underlying\n+         * @return\n+         */\n+        public static Scheduler forwardingScheduler(Scheduler underlying) {\n+            return new ForwardingScheduler(underlying);\n+        }\n+\n         public static class TestingObserver<T> implements Observer<T> {\n \n             private final Observer<T> actual;\n@@ -257,5 +271,38 @@ public void onNext(String args)\n                 }\n             }\n         }\n+\n+        public static class ForwardingScheduler implements Scheduler {\n+            private final Scheduler underlying;\n+\n+            public ForwardingScheduler(Scheduler underlying) {\n+                this.underlying = underlying;\n+            }\n+\n+            @Override\n+            public Subscription schedule(Action0 action) {\n+                return underlying.schedule(action);\n+            }\n+\n+            @Override\n+            public Subscription schedule(Func0<Subscription> action) {\n+                return underlying.schedule(action);\n+            }\n+\n+            @Override\n+            public Subscription schedule(Action0 action, long dueTime, TimeUnit unit) {\n+                return underlying.schedule(action, dueTime, unit);\n+            }\n+\n+            @Override\n+            public Subscription schedule(Func0<Subscription> action, long dueTime, TimeUnit unit) {\n+                return underlying.schedule(action, dueTime, unit);\n+            }\n+\n+            @Override\n+            public long now() {\n+                return underlying.now();\n+            }\n+        }\n     }\n }\n\\ No newline at end of file",
    "output": "Make ForwardingScheduler Internal\n\nUntil there is a use case other than unit testing I'm moving this to a non-public role so it's not part of the public API"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/Schedulers.java b/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n--- a/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n@@ -17,10 +17,15 @@\n \n import rx.Scheduler;\n \n-import java.util.concurrent.Executor;\n-import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n public class Schedulers {\n+    private static final ScheduledExecutorService COMPUTATION_EXECUTOR = createComputationExecutor();\n+    private static final ScheduledExecutorService IO_EXECUTOR = createIOExecutor();\n+    private static final int DEFAULT_MAX_IO_THREADS = 10;\n+    private static final int DEFAULT_KEEP_ALIVE_TIME = 10 * 1000; // 10 seconds\n+\n     private Schedulers() {\n \n     }\n@@ -45,7 +50,43 @@ public static Scheduler fromScheduledExecutorService(ScheduledExecutorService ex\n         return new ScheduledExecutorServiceScheduler(executor);\n     }\n \n+    public static Scheduler threadPoolForComputation() {\n+        return fromScheduledExecutorService(COMPUTATION_EXECUTOR);\n+    }\n+\n+    public static Scheduler threadPoolForIO() {\n+        return fromScheduledExecutorService(IO_EXECUTOR);\n+    }\n+\n     public static Scheduler forwardingScheduler(Scheduler underlying) {\n         return new ForwardingScheduler(underlying);\n     }\n+\n+    private static ScheduledExecutorService createComputationExecutor() {\n+        int cores = Runtime.getRuntime().availableProcessors();\n+        return Executors.newScheduledThreadPool(cores, new ThreadFactory() {\n+            final AtomicInteger counter = new AtomicInteger();\n+\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                return new Thread(r, \"RxComputationThreadPool-\" + counter.incrementAndGet());\n+            }\n+        });\n+    }\n+\n+    private static ScheduledExecutorService createIOExecutor() {\n+        ScheduledThreadPoolExecutor result = new ScheduledThreadPoolExecutor(DEFAULT_MAX_IO_THREADS, new ThreadFactory() {\n+            final AtomicInteger counter = new AtomicInteger();\n+\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                return new Thread(r, \"RxIOThreadPool-\" + counter.incrementAndGet());\n+            }\n+        });\n+\n+        result.setKeepAliveTime(DEFAULT_KEEP_ALIVE_TIME, TimeUnit.MILLISECONDS);\n+        result.allowCoreThreadTimeOut(true);\n+\n+        return result;\n+    }\n }",
    "output": "Add threadPoolForComputation and threadPoolForIO schedulers"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/AbstractScheduler.java b/rxjava-core/src/main/java/rx/concurrency/AbstractScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/AbstractScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/AbstractScheduler.java\n@@ -35,11 +35,6 @@ public Subscription schedule(Action0 action, long dueTime, TimeUnit unit) {\n         return schedule(asFunc0(action), dueTime, unit);\n     }\n \n-    @Override\n-    public Subscription schedule(Func0<Subscription> action, long dueTime, TimeUnit unit) {\n-        return schedule(new SleepingAction(action, this, dueTime, unit));\n-    }\n-\n     @Override\n     public long now() {\n         return System.nanoTime();\n\ndiff --git a/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java\n@@ -23,6 +23,7 @@\n \n import java.util.LinkedList;\n import java.util.Queue;\n+import java.util.concurrent.TimeUnit;\n \n import static org.mockito.Mockito.*;\n \n@@ -45,6 +46,11 @@ public Subscription schedule(Func0<Subscription> action) {\n         return discardableAction;\n     }\n \n+    @Override\n+    public Subscription schedule(Func0<Subscription> action, long dueTime, TimeUnit unit) {\n+        return schedule(new SleepingAction(action, this, dueTime, unit));\n+    }\n+\n     private void enqueue(DiscardableAction action) {\n         Queue<DiscardableAction> queue = QUEUE.get();\n         boolean exec = queue == null;\n\ndiff --git a/rxjava-core/src/main/java/rx/concurrency/ExecutorScheduler.java b/rxjava-core/src/main/java/rx/concurrency/ExecutorScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/ExecutorScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/ExecutorScheduler.java\n@@ -19,6 +19,7 @@\n import rx.util.functions.Func0;\n \n import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n \n public class ExecutorScheduler extends AbstractScheduler {\n     private final Executor executor;\n@@ -41,4 +42,9 @@ public void run() {\n         return discardableAction;\n \n     }\n+\n+    @Override\n+    public Subscription schedule(Func0<Subscription> action, long dueTime, TimeUnit unit) {\n+        throw new IllegalStateException(\"Delayed scheduling is not supported\");\n+    }\n }\n\ndiff --git a/rxjava-core/src/main/java/rx/concurrency/ImmediateScheduler.java b/rxjava-core/src/main/java/rx/concurrency/ImmediateScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/ImmediateScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/ImmediateScheduler.java\n@@ -18,10 +18,11 @@\n import org.junit.Test;\n import org.mockito.InOrder;\n import rx.Subscription;\n-import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;\n import rx.util.functions.Func0;\n \n+import java.util.concurrent.TimeUnit;\n+\n import static org.mockito.Mockito.inOrder;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n@@ -41,6 +42,11 @@ public Subscription schedule(Func0<Subscription> action) {\n         return action.call();\n     }\n \n+    @Override\n+    public Subscription schedule(Func0<Subscription> action, long dueTime, TimeUnit unit) {\n+        return schedule(new SleepingAction(action, this, dueTime, unit));\n+    }\n+\n     public static class UnitTest {\n \n         @Test\n\ndiff --git a/rxjava-core/src/main/java/rx/concurrency/NewThreadScheduler.java b/rxjava-core/src/main/java/rx/concurrency/NewThreadScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/NewThreadScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/NewThreadScheduler.java\n@@ -18,6 +18,8 @@\n import rx.Subscription;\n import rx.util.functions.Func0;\n \n+import java.util.concurrent.TimeUnit;\n+\n public class NewThreadScheduler extends AbstractScheduler {\n     private static final NewThreadScheduler INSTANCE = new NewThreadScheduler();\n \n@@ -42,4 +44,9 @@ public void run() {\n         return discardableAction;\n     }\n \n+    @Override\n+    public Subscription schedule(Func0<Subscription> action, long dueTime, TimeUnit unit) {\n+        return schedule(new SleepingAction(action, this, dueTime, unit));\n+    }\n+\n }\n\ndiff --git a/rxjava-core/src/main/java/rx/concurrency/Schedulers.java b/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n--- a/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n@@ -41,7 +41,7 @@ public static Scheduler executor(Executor executor) {\n         return new ExecutorScheduler(executor);\n     }\n \n-    public static Scheduler scheduledExecutor(ScheduledExecutorService executor) {\n+    public static Scheduler fromScheduledExecutorService(ScheduledExecutorService executor) {\n         return new ScheduledExecutorServiceScheduler(executor);\n     }\n ",
    "output": "Remove SleepingAction from Abstract scheduler. ExecutorScheduler throws exception for the delayed action"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/PublishSubject.java b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n--- a/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java\n@@ -10,15 +10,23 @@\n \n import org.junit.Test;\n \n+import org.mockito.Mockito;\n import rx.Notification;\n import rx.Observable;\n import rx.Observer;\n import rx.Subscription;\n+import rx.testing.UnsubscribeTester;\n import rx.util.AtomicObservableSubscription;\n import rx.util.SynchronizedObserver;\n import rx.util.functions.Action1;\n+import rx.util.functions.Func0;\n import rx.util.functions.Func1;\n \n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n public class PublishSubject<T> extends Subject<T, T> {\n     public static <T> PublishSubject<T> create() {\n         final ConcurrentHashMap<Subscription, Observer<T>> observers = new ConcurrentHashMap<Subscription, Observer<T>>();\n@@ -122,5 +130,178 @@ public void unsubscribe() {\n \n             sub.unsubscribe();\n         }\n+\n+        private final Exception testException = new Exception();\n+\n+        @Test\n+        public void testCompleted() {\n+            PublishSubject<Object> subject = PublishSubject.create();\n+\n+            Observer<String> aObserver = mock(Observer.class);\n+            subject.subscribe(aObserver);\n+\n+            subject.onNext(\"one\");\n+            subject.onNext(\"two\");\n+            subject.onNext(\"three\");\n+            subject.onCompleted();\n+\n+            Observer<String> anotherObserver = mock(Observer.class);\n+            subject.subscribe(anotherObserver);\n+\n+            subject.onNext(\"four\");\n+            subject.onCompleted();\n+            subject.onError(new Exception());\n+\n+            assertCompletedObserver(aObserver);\n+// todo bug?            assertNeverObserver(anotherObserver);\n+        }\n+\n+        private void assertCompletedObserver(Observer<String> aObserver)\n+        {\n+            verify(aObserver, times(1)).onNext(\"one\");\n+            verify(aObserver, times(1)).onNext(\"two\");\n+            verify(aObserver, times(1)).onNext(\"three\");\n+            verify(aObserver, Mockito.never()).onError(any(Exception.class));\n+            verify(aObserver, times(1)).onCompleted();\n+        }\n+\n+        private void assertNeverObserver(Observer<String> aObserver)\n+        {\n+            verify(aObserver, Mockito.never()).onNext(any(String.class));\n+            verify(aObserver, Mockito.never()).onError(any(Exception.class));\n+            verify(aObserver, Mockito.never()).onCompleted();\n+        }\n+\n+        @Test\n+        public void testError() {\n+            PublishSubject<Object> subject = PublishSubject.create();\n+\n+            Observer<String> aObserver = mock(Observer.class);\n+            subject.subscribe(aObserver);\n+\n+            subject.onNext(\"one\");\n+            subject.onNext(\"two\");\n+            subject.onNext(\"three\");\n+            subject.onError(testException);\n+\n+            Observer<String> anotherObserver = mock(Observer.class);\n+            subject.subscribe(anotherObserver);\n+\n+            subject.onNext(\"four\");\n+            subject.onError(new Exception());\n+            subject.onCompleted();\n+\n+            assertErrorObserver(aObserver);\n+// todo bug?            assertNeverObserver(anotherObserver);\n+        }\n+\n+        private void assertErrorObserver(Observer<String> aObserver)\n+        {\n+            verify(aObserver, times(1)).onNext(\"one\");\n+            verify(aObserver, times(1)).onNext(\"two\");\n+            verify(aObserver, times(1)).onNext(\"three\");\n+            verify(aObserver, times(1)).onError(testException);\n+            verify(aObserver, Mockito.never()).onCompleted();\n+        }\n+\n+\n+        @Test\n+        public void testSubscribeMidSequence() {\n+            PublishSubject<Object> subject = PublishSubject.create();\n+\n+            Observer<String> aObserver = mock(Observer.class);\n+            subject.subscribe(aObserver);\n+\n+            subject.onNext(\"one\");\n+            subject.onNext(\"two\");\n+\n+            assertObservedUntilTwo(aObserver);\n+\n+            Observer<String> anotherObserver = mock(Observer.class);\n+            subject.subscribe(anotherObserver);\n+\n+            subject.onNext(\"three\");\n+            subject.onCompleted();\n+\n+            assertCompletedObserver(aObserver);\n+            assertCompletedStartingWithThreeObserver(anotherObserver);\n+        }\n+\n+\n+        private void assertCompletedStartingWithThreeObserver(Observer<String> aObserver)\n+        {\n+            verify(aObserver, Mockito.never()).onNext(\"one\");\n+            verify(aObserver, Mockito.never()).onNext(\"two\");\n+            verify(aObserver, times(1)).onNext(\"three\");\n+            verify(aObserver, Mockito.never()).onError(any(Exception.class));\n+            verify(aObserver, times(1)).onCompleted();\n+        }\n+\n+        @Test\n+        public void testUnsubscribeFirstObserver() {\n+            PublishSubject<Object> subject = PublishSubject.create();\n+\n+            Observer<String> aObserver = mock(Observer.class);\n+            Subscription subscription = subject.subscribe(aObserver);\n+\n+            subject.onNext(\"one\");\n+            subject.onNext(\"two\");\n+\n+            subscription.unsubscribe();\n+            assertObservedUntilTwo(aObserver);\n+\n+            Observer<String> anotherObserver = mock(Observer.class);\n+            subject.subscribe(anotherObserver);\n+\n+            subject.onNext(\"three\");\n+            subject.onCompleted();\n+\n+            assertObservedUntilTwo(aObserver);\n+            assertCompletedStartingWithThreeObserver(anotherObserver);\n+        }\n+\n+        private void assertObservedUntilTwo(Observer<String> aObserver)\n+        {\n+            verify(aObserver, times(1)).onNext(\"one\");\n+            verify(aObserver, times(1)).onNext(\"two\");\n+            verify(aObserver, Mockito.never()).onNext(\"three\");\n+            verify(aObserver, Mockito.never()).onError(any(Exception.class));\n+            verify(aObserver, Mockito.never()).onCompleted();\n+        }\n+\n+        @Test\n+        public void testUnsubscribe()\n+        {\n+            UnsubscribeTester.test(new Func0<PublishSubject<Object>>()\n+                                   {\n+                                       @Override\n+                                       public PublishSubject<Object> call()\n+                                       {\n+                                           return PublishSubject.create();\n+                                       }\n+                                   }, new Action1<PublishSubject<Object>>()\n+                                   {\n+                                       @Override\n+                                       public void call(PublishSubject<Object> PublishSubject)\n+                                       {\n+                                           PublishSubject.onCompleted();\n+                                       }\n+                                   }, new Action1<PublishSubject<Object>>()\n+                                   {\n+                                       @Override\n+                                       public void call(PublishSubject<Object> PublishSubject)\n+                                       {\n+                                           PublishSubject.onError(new Exception());\n+                                       }\n+                                   }, new Action1<PublishSubject<Object>>()\n+                                   {\n+                                       @Override\n+                                       public void call(PublishSubject<Object> PublishSubject)\n+                                       {\n+                                           PublishSubject.onNext(\"one\");\n+                                       }\n+                                   }\n+            );\n+        }\n     }\n }",
    "output": "Add unit tests to PublishSubject"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationTake.java b/rxjava-core/src/main/java/rx/operators/OperationTake.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationTake.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationTake.java\n@@ -31,6 +31,7 @@\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n+import static rx.testing.TrustedObservableTester.assertTrustedObservable;\n \n /**\n  * Returns a specified number of contiguous values from the start of an observable sequence.\n@@ -97,12 +98,16 @@ public ItemObserver(Observer<T> observer) {\n \n             @Override\n             public void onCompleted() {\n-                observer.onCompleted();\n+                if (counter.getAndSet(num) < num) {\n+                    observer.onCompleted();\n+                }\n             }\n \n             @Override\n             public void onError(Exception e) {\n-                observer.onError(e);\n+                if (counter.getAndSet(num) < num) {\n+                    observer.onError(e);\n+                }\n             }\n \n             @Override\n@@ -129,7 +134,7 @@ public static class UnitTest {\n         @Test\n         public void testTake1() {\n             Observable<String> w = Observable.toObservable(\"one\", \"two\", \"three\");\n-            Observable<String> take = Observable.create(take(w, 2));\n+            Observable<String> take = Observable.create(assertTrustedObservable(take(w, 2)));\n \n             @SuppressWarnings(\"unchecked\")\n             Observer<String> aObserver = mock(Observer.class);\n@@ -144,7 +149,7 @@ public void testTake1() {\n         @Test\n         public void testTake2() {\n             Observable<String> w = Observable.toObservable(\"one\", \"two\", \"three\");\n-            Observable<String> take = Observable.create(take(w, 1));\n+            Observable<String> take = Observable.create(assertTrustedObservable(take(w, 1)));\n \n             @SuppressWarnings(\"unchecked\")\n             Observer<String> aObserver = mock(Observer.class);\n@@ -158,14 +163,23 @@ public void testTake2() {\n \n         @Test\n         public void testTakeDoesntLeakErrors() {\n-            Observable<String> source = Observable.concat(Observable.from(\"one\"), Observable.<String>error(new Exception(\"test failed\")));\n-            Observable.create(take(source, 1)).last();\n+            Observable<String> source = Observable.create(new Func1<Observer<String>, Subscription>()\n+            {\n+                @Override\n+                public Subscription call(Observer<String> observer)\n+                {\n+                    observer.onNext(\"one\");\n+                    observer.onError(new Exception(\"test failed\"));\n+                    return Subscriptions.empty();\n+                }\n+            });\n+            Observable.create(assertTrustedObservable(take(source, 1))).last();\n         }\n \n         @Test\n         public void testTakeZeroDoesntLeakError() {\n-            Observable<String> source = Observable.<String>error(new Exception(\"test failed\"));\n-            Observable.create(take(source, 0)).lastOrDefault(\"ok\");\n+            Observable<String> source = Observable.error(new Exception(\"test failed\"));\n+            Observable.create(assertTrustedObservable(take(source, 0))).lastOrDefault(\"ok\");\n         }\n \n         @Test\n@@ -175,7 +189,7 @@ public void testUnsubscribeAfterTake() {\n \n             @SuppressWarnings(\"unchecked\")\n             Observer<String> aObserver = mock(Observer.class);\n-            Observable<String> take = Observable.create(take(w, 1));\n+            Observable<String> take = Observable.create(assertTrustedObservable(take(w, 1)));\n             take.subscribe(aObserver);\n \n             // wait for the Observable to complete",
    "output": "Fix violations of the Observer contract"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationTake.java b/rxjava-core/src/main/java/rx/operators/OperationTake.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationTake.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationTake.java\n@@ -260,6 +260,18 @@ public void testTake2() {\n             verify(aObserver, times(1)).onCompleted();\n         }\n \n+        @Test\n+        public void testTakeDoesntLeakErrors() {\n+            Observable<String> source = Observable.concat(Observable.from(\"one\"), Observable.<String>error(new Exception(\"test failed\")));\n+            Observable.create(take(source, 1)).last();\n+        }\n+\n+        @Test\n+        public void testTakeZeroDoesntLeakError() {\n+            Observable<String> source = Observable.<String>error(new Exception(\"test failed\"));\n+            Observable.create(take(source, 0)).lastOrDefault(\"ok\");\n+        }\n+\n         @Test\n         public void testUnsubscribeAfterTake() {\n             Subscription s = mock(Subscription.class);",
    "output": "Add tests to demonstrate bugs"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java\n@@ -94,7 +94,7 @@ public void onError(Exception e) {\n         }\n \n         @Override\n-        public void onNext(Object args) {\n+        public void onNext(T args) {\n             a.next(this, args);\n         }\n     }\n@@ -185,7 +185,7 @@ synchronized void error(CombineObserver<R, ?> w, Exception e) {\n          * @param w\n          * @param arg\n          */\n-        void next(CombineObserver<R, ?> w, Object arg) {\n+        <T> void next(CombineObserver<R, T> w, T arg) {\n             if (Observer == null) {\n                 throw new RuntimeException(\"This shouldn't be running if a Observer isn't registered\");\n             }\n@@ -485,7 +485,7 @@ public void testAggregateMultipleTypes() {\n \n             /* mock the Observable Observers that are 'pushing' data for us */\n             CombineObserver<String, String> r1 = mock(CombineObserver.class);\n-            CombineObserver<String, Integer> r2 = mock(CombineObserver.class);\n+            CombineObserver<String, String> r2 = mock(CombineObserver.class);\n \n             /* pretend we're starting up */\n             a.addObserver(r1);",
    "output": "Make 'next' more typesafe"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java b/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationToObservableList.java\n@@ -40,7 +40,6 @@ public static <T> Func1<Observer<List<T>>, Subscription> toObservableList(Observ\n     private static class ToObservableList<T> implements Func1<Observer<List<T>>, Subscription> {\n \n         private final Observable<T> that;\n-        final ConcurrentLinkedQueue<T> list = new ConcurrentLinkedQueue<T>();\n \n         public ToObservableList(Observable<T> that) {\n             this.that = that;\n@@ -49,6 +48,7 @@ public ToObservableList(Observable<T> that) {\n         public Subscription call(final Observer<List<T>> observer) {\n \n             return that.subscribe(new Observer<T>() {\n+                final ConcurrentLinkedQueue<T> list = new ConcurrentLinkedQueue<T>();\n                 public void onNext(T value) {\n                     // onNext can be concurrently executed so list must be thread-safe\n                     list.add(value);",
    "output": "Fix for Observable.toList failing with multiple subscribers"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/Schedulers.java b/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n--- a/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/Schedulers.java\n@@ -3,6 +3,7 @@\n import rx.Scheduler;\n \n import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n \n public class Schedulers {\n     private Schedulers() {\n@@ -24,4 +25,8 @@ public static Scheduler newThread() {\n     public static Scheduler executor(Executor executor) {\n         return new ExecutorScheduler(executor);\n     }\n+\n+    public static Scheduler scheduledExecutor(ScheduledExecutorService executor) {\n+        return new ScheduledExecutorServiceScheduler(executor);\n+    }\n }",
    "output": "Add to Schedulers"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/concurrency/ScheduledExecutorServiceScheduler.java b/rxjava-core/src/main/java/rx/concurrency/ScheduledExecutorServiceScheduler.java\n--- a/rxjava-core/src/main/java/rx/concurrency/ScheduledExecutorServiceScheduler.java\n+++ b/rxjava-core/src/main/java/rx/concurrency/ScheduledExecutorServiceScheduler.java\n@@ -0,0 +1,34 @@\n+package rx.concurrency;\n+\n+import rx.Subscription;\n+import rx.util.functions.Func0;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+// TODO [@mairbek] silly name\n+public class ScheduledExecutorServiceScheduler extends AbstractScheduler {\n+    private final ScheduledExecutorService executorService;\n+\n+    public ScheduledExecutorServiceScheduler(ScheduledExecutorService executorService) {\n+        this.executorService = executorService;\n+    }\n+\n+    @Override\n+    public Subscription schedule(Func0<Subscription> action) {\n+        return schedule(action, 0, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @Override\n+    public Subscription schedule(Func0<Subscription> action, long timespan, TimeUnit unit) {\n+        final DiscardableAction discardableAction = new DiscardableAction(action);\n+        executorService.schedule(new Runnable() {\n+            @Override\n+            public void run() {\n+                discardableAction.call();\n+            }\n+        }, timespan, unit);\n+        return discardableAction;\n+    }\n+\n+}",
    "output": "Add ScheduledExecutorServiceScheduler"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -2426,6 +2426,17 @@ public Observable<T> filter(Func1<T, Boolean> predicate) {\n         return filter(this, predicate);\n     }\n \n+    /**\n+     * Registers an action to be called when this observable calls\n+     * <code>onComplete</code> or <code>onError</code>.\n+     * @param action an action to be called when this observable completes or errors.\n+     * @return an Observable that emits the same objects as this observable, then calls the action.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh212133(v=vs.103).aspx\">MSDN: Observable.Finally Method</a>\n+     */\n+    public Observable<T> finally0(Action0 action) {\n+        return _create(OperationFinally.finally0(this, action));\n+    }\n+\n     /**\n      * Filters an Observable by discarding any of its emissions that do not meet some test.\n      * <p>",
    "output": "Add nonstatic Observable.finally0"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -1182,6 +1182,18 @@ public static <T> Observable<T> concat(Observable<T>... source) {\n         return _create(OperationConcat.concat(source));\n     }\n \n+    /**\n+     * Emits the same objects as the given Observable, calling the given action\n+     * when it calls <code>onComplete</code> or <code>onError</code>.\n+     * @param source an observable\n+     * @param action an action to be called when the source completes or errors.\n+     * @return an Observable that emits the same objects, then calls the action.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh212133(v=vs.103).aspx\">MSDN: Observable.Finally Method</a>\n+     */\n+    public static <T> Observable<T> finally0(Observable source, Action0 action) {\n+        return _create(OperationFinally.finally0(source, action));\n+    }\n+\n     /**\n      * Groups the elements of an observable and selects the resulting elements by using a specified function.\n      * \n\ndiff --git a/rxjava-core/src/main/java/rx/operators/OperationFinally.java b/rxjava-core/src/main/java/rx/operators/OperationFinally.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationFinally.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationFinally.java\n@@ -1,12 +1,12 @@\n /**\n  * Copyright 2013 Netflix, Inc.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -23,15 +23,12 @@\n import java.util.List;\n import java.util.concurrent.CountDownLatch;\n \n-import org.junit.Assert;\n-import org.junit.Before;\n import org.junit.Test;\n \n import rx.Observable;\n import rx.Observer;\n import rx.Subscription;\n import rx.util.AtomicObservableSubscription;\n-import rx.util.AtomicObserver;\n import rx.util.functions.Action0;\n import rx.util.functions.Func1;\n \n@@ -42,16 +39,16 @@ public final class OperationFinally {\n      * exception).  The returned observable is exactly as threadsafe as the\n      * source observable; in particular, any situation allowing the source to\n      * call onComplete or onError multiple times allows the returned observable\n-     * to call the action multiple times.\n+     * to call the final action multiple times.\n      * <p/>\n      * Note that \"finally\" is a Java reserved word and cannot be an identifier,\n      * so we use \"finally0\".\n-     * \n+     *\n      * @param sequence An observable sequence of elements\n      * @param action An action to be taken when the sequence is complete or throws an exception\n      * @return An observable sequence with the same elements as the input.\n      *         After the last element is consumed (just before {@link Observer#onComplete} is called),\n-     *         or when an exception is thrown (just before {@link Observer#onError}), the action will be taken.\n+     *         or when an exception is thrown (just before {@link Observer#onError}), the action will be called.\n      * @see http://msdn.microsoft.com/en-us/library/hh212133(v=vs.103).aspx\n      */\n     public static <T> Func1<Observer<T>, Subscription> finally0(final Observable<T> sequence, final Action0 action) {\n@@ -121,25 +118,24 @@ private static class TestAction implements Action0 {\n                 called++;\n             }\n         }\n-        \n+\n         @Test\n         public void testFinally() {\n             final String[] n = {\"1\", \"2\", \"3\"};\n             final Observable<String> nums = Observable.toObservable(n);\n             TestAction action = new TestAction();\n             action.called = 0;\n-            @SuppressWarnings(\"unchecked\")\n             Observable<String> fin = Observable.create(finally0(nums, action));\n             @SuppressWarnings(\"unchecked\")\n             Observer<String> aObserver = mock(Observer.class);\n             fin.subscribe(aObserver);\n-            Assert.assertEquals(1, action.called);\n+            assertEquals(1, action.called);\n \n             action.called = 0;\n             Observable<String> error = Observable.<String>error(new RuntimeException(\"expected\"));\n             fin = Observable.create(finally0(error, action));\n             fin.subscribe(aObserver);\n-            Assert.assertEquals(1, action.called);\n+            assertEquals(1, action.called);\n         }\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Add finally0 to Observable.java"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -40,6 +40,7 @@\n import rx.operators.OperationDefer;\n import rx.operators.OperationDematerialize;\n import rx.operators.OperationFilter;\n+import rx.operators.OperationWhere;\n import rx.operators.OperationMap;\n import rx.operators.OperationMaterialize;\n import rx.operators.OperationMerge;\n@@ -722,6 +723,21 @@ public Boolean call(T t1) {\n         });\n     }\n \n+    /**\n+     * Filters an Observable by discarding any of its emissions that do not meet some test.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/filter.png\">\n+     *\n+     * @param that\n+     *            the Observable to filter\n+     * @param predicate\n+     *            a function that evaluates the items emitted by the source Observable, returning <code>true</code> if they pass the filter\n+     * @return an Observable that emits only those items in the original Observable that the filter evaluates as true\n+     */\n+    public static <T> Observable<T> where(Observable<T> that, Func1<T, Boolean> predicate) {\n+        return _create(OperationWhere.where(that, predicate));\n+    }\n+\n     /**\n      * Converts an {@link Iterable} sequence to an Observable sequence.\n      * \n@@ -2419,6 +2435,21 @@ public Boolean call(T t1) {\n         });\n     }\n \n+    /**\n+     * Filters an Observable by discarding any of its emissions that do not meet some test.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/filter.png\">\n+     *\n+     * @param predicate\n+     *            a function that evaluates the items emitted by the source Observable, returning\n+     *            <code>true</code> if they pass the filter\n+     * @return an Observable that emits only those items in the original Observable that the filter\n+     *         evaluates as <code>true</code>\n+     */\n+    public Observable<T> where(Func1<T, Boolean> predicate) {\n+        return where(this, predicate);\n+    }\n+\n     /**\n      * Returns the last element of an observable sequence with a specified source.\n      * ",
    "output": "Add where operation to Observable"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -2171,7 +2171,7 @@ public Boolean call(T first, T second) {\n      *            type of sequence\n      * @return sequence of booleans, true if two sequences are equal by comparing the elements pairwise; otherwise, false.\n      */\n-    private static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observable<T> second, Func2<T, T, Boolean> equality) {\n+    public static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observable<T> second, Func2<T, T, Boolean> equality) {\n         return zip(first, second, equality);\n     }\n \n@@ -2188,7 +2188,7 @@ private static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observ\n      *            type of sequence\n      * @return sequence of booleans, true if two sequences are equal by comparing the elements pairwise; otherwise, false.\n      */\n-    private static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observable<T> second, Object equality) {\n+    public static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observable<T> second, Object equality) {\n         return zip(first, second, equality);\n     }\n ",
    "output": "Make sequenceEqual private methods public These should be public as part of issue https://github.com/Netflix/RxJava/issues/76"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -30,6 +30,7 @@\n import org.mockito.MockitoAnnotations;\n \n import rx.operators.OperationConcat;\n+import rx.operators.OperationDematerialize;\n import rx.operators.OperationFilter;\n import rx.operators.OperationLast;\n import rx.operators.OperationMap;\n@@ -927,6 +928,18 @@ public static <T> Observable<Notification<T>> materialize(final Observable<T> se\n         return _create(OperationMaterialize.materialize(sequence));\n     }\n \n+    /**\n+     * Dematerializes the explicit notification values of an observable sequence as implicit notifications.\n+     *\n+     * @param sequence\n+     *            An observable sequence containing explicit notification values which have to be turned into implicit notifications.\n+     * @return An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx\">MSDN: Observable.Dematerialize</a>\n+     */\n+    public static <T> Observable<T> dematerialize(final Observable<Notification<T>> sequence) {\n+        return _create(OperationDematerialize.dematerialize(sequence));\n+    }\n+\n     /**\n      * Flattens the Observable sequences from a list of Observables into one Observable sequence\n      * without any transformation. You can combine the output of multiple Observables so that they\n@@ -2406,6 +2419,16 @@ public Observable<Notification<T>> materialize() {\n         return materialize(this);\n     }\n \n+    /**\n+     * Dematerializes the explicit notification values of an observable sequence as implicit notifications.\n+     *\n+     * @return An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx\">MSDN: Observable.dematerialize</a>\n+     */\n+    public Observable<T> dematerialize() {\n+        return dematerialize((Observable<Notification<T>>)this);\n+    }\n+\n     /**\n      * Instruct an Observable to pass control to another Observable rather than calling <code>onError</code> if it encounters an error.\n      * <p>",
    "output": "Add dematerialize api to observable"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationNext.java b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationNext.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationNext.java\n@@ -1,12 +1,12 @@\n /**\n  * Copyright 2013 Netflix, Inc.\n- *\n+ * \n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n+ * \n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * \n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -15,20 +15,29 @@\n  */\n package rx.operators;\n \n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n import org.junit.Test;\n+\n import rx.Notification;\n import rx.Observable;\n import rx.Observer;\n import rx.Subscription;\n import rx.util.Exceptions;\n-\n-import java.util.Iterator;\n-import java.util.concurrent.*;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.mock;\n-\n+import rx.util.functions.Func1;\n \n /**\n  * Samples the next value (blocking without buffering) from in an observable sequence.\n@@ -87,7 +96,6 @@ public void remove() {\n         }\n     }\n \n-\n     private static class NextObserver<T> implements Observer<Notification<T>> {\n         private final BlockingQueue<Notification<T>> buf = new ArrayBlockingQueue<Notification<T>>(1);\n         private final AtomicBoolean waiting = new AtomicBoolean(false);\n@@ -153,7 +161,6 @@ public T takeNext() throws InterruptedException {\n \n     }\n \n-\n     public static class UnitTest {\n         private final ExecutorService executor = Executors.newSingleThreadExecutor();\n \n@@ -183,7 +190,6 @@ public void testNext() throws Exception {\n             obs.sendOnCompleted();\n \n             assertFalse(it.hasNext());\n-\n         }\n \n         @Test(expected = TestException.class)\n@@ -257,10 +263,83 @@ public Subscription subscribe(final Observer<String> observer) {\n \n         }\n \n+        @SuppressWarnings(\"serial\")\n         private static class TestException extends RuntimeException {\n \n         }\n \n+        /**\n+         * Confirm that no buffering or blocking of the Observable onNext calls occurs and it just grabs the next emitted value.\n+         * \n+         * This results in output such as => a: 1 b: 2 c: 89\n+         * \n+         * @throws Exception\n+         */\n+        @Test\n+        public void testNoBufferingOrBlockingOfSequence() throws Exception {\n+            final CountDownLatch finished = new CountDownLatch(1);\n+            final AtomicBoolean running = new AtomicBoolean(true);\n+            final AtomicInteger count = new AtomicInteger(0);\n+            final Observable<Integer> obs = Observable.create(new Func1<Observer<Integer>, Subscription>() {\n+\n+                @Override\n+                public Subscription call(final Observer<Integer> o) {\n+                    new Thread(new Runnable() {\n+\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                while (running.get()) {\n+                                    o.onNext(count.incrementAndGet());\n+                                    Thread.sleep(0, 100);\n+                                }\n+                                o.onCompleted();\n+                            } catch (Exception e) {\n+                                o.onError(e);\n+                            } finally {\n+                                finished.countDown();\n+                            }\n+                        }\n+                    }).start();\n+                    return Observable.noOpSubscription();\n+                }\n+\n+            });\n+\n+            Iterator<Integer> it = next(obs).iterator();\n+\n+            assertTrue(it.hasNext());\n+            int a = it.next();\n+            assertTrue(it.hasNext());\n+            int b = it.next();\n+            // we should have a different value\n+            assertTrue(\"a and b should be different\", a != b);\n+\n+            // wait for some time\n+            Thread.sleep(100);\n+            // make sure the counter in the observable has increased beyond b\n+            while (count.get() <= (b + 10)) {\n+                Thread.sleep(100);\n+            }\n+\n+            assertTrue(it.hasNext());\n+            int expectedHigherThan = count.get();\n+            int c = it.next();\n+\n+            assertTrue(\"c should not just be the next in sequence\", c != (b + 1));\n+            assertTrue(\"expected that c [\" + c + \"] is higher than \" + expectedHigherThan, c > expectedHigherThan);\n+\n+            assertTrue(it.hasNext());\n+\n+            // shut down the thread\n+            running.set(false);\n+\n+            finished.await();\n+\n+            assertFalse(it.hasNext());\n+\n+            System.out.println(\"a: \" + a + \" b: \" + b + \" c: \" + c);\n+        }\n \n     }\n ",
    "output": "Add unit test testNoBufferingOrBlockingOfSequence\n\nAs part of reviewing the code I added another unit test"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/util/Range.java b/rxjava-core/src/main/java/rx/util/Range.java\n--- a/rxjava-core/src/main/java/rx/util/Range.java\n+++ b/rxjava-core/src/main/java/rx/util/Range.java\n@@ -27,7 +27,7 @@ public final class Range implements Iterable<Integer> {\n     private final int step;\n \n     public static Range createWithCount(int start, int count) {\n-        return create(start, start * (count + 1));\n+        return create(start, start + count);\n     }\n \n     public static Range create(int start, int end) {\n@@ -94,6 +94,21 @@ public void testRangeWithCount() {\n             assertEquals(Arrays.asList(1, 2, 3, 4, 5), toList(Range.createWithCount(1, 5)));\n         }\n \n+        @Test\n+        public void testRangeWithCount2() {\n+            assertEquals(Arrays.asList(2, 3, 4, 5), toList(Range.createWithCount(2, 4)));\n+        }\n+\n+        @Test\n+        public void testRangeWithCount3() {\n+            assertEquals(Arrays.asList(0, 1, 2, 3), toList(Range.createWithCount(0, 4)));\n+        }\n+\n+        @Test\n+        public void testRangeWithCount4() {\n+            assertEquals(Arrays.asList(10, 11, 12, 13, 14), toList(Range.createWithCount(10, 5)));\n+        }\n+\n \n         private static <T> List<T> toList(Iterable<T> iterable) {\n             List<T> result = new ArrayList<T>();",
    "output": "Fix bug in ranges"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/util/AtomicObserver.java b/rxjava-core/src/main/java/rx/util/AtomicObserver.java\n--- a/rxjava-core/src/main/java/rx/util/AtomicObserver.java\n+++ b/rxjava-core/src/main/java/rx/util/AtomicObserver.java\n@@ -67,8 +67,13 @@ public void onError(Exception e) {\n \n     @Override\n     public void onNext(T args) {\n-        if (!isFinished.get()) {\n-            actual.onNext(args);\n+        try {\n+            if (!isFinished.get()) {\n+                actual.onNext(args);\n+            }\n+        }catch(Exception e) {\n+            // handle errors if the onNext implementation fails, not just if the Observable fails\n+            onError(e);\n         }\n     }\n ",
    "output": "Add error handling for onNext failure so exceptions don't get thrown up the stack but instead via onError"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -120,7 +120,7 @@ private Observable(Func1<Observer<T>, Subscription> onSubscribe, boolean isTrust\n      * For more information see the <a href=\"https://github.com/Netflix/RxJava/wiki/Observable\">RxJava Wiki</a>\n      * \n      * \n-     * @param Observer\n+     * @param observer\n      * @return a {@link Subscription} reference that allows observers\n      *         to stop receiving notifications before the provider has finished sending them\n      */\n@@ -447,9 +447,9 @@ private static <T> Observable<T> _create(Func1<Observer<T>, Subscription> func)\n      *            as appropriate, and returns a {@link Subscription} to allow canceling the subscription (if applicable)\n      * @return an Observable that, when an {@link Observer} subscribes to it, will execute the given function\n      */\n-    public static <T> Observable<T> create(final Object callback) {\n+    public static <T> Observable<T> create(final Object func) {\n         @SuppressWarnings(\"rawtypes\")\n-        final FuncN _f = Functions.from(callback);\n+        final FuncN _f = Functions.from(func);\n         return create(new Func1<Observer<T>, Subscription>() {\n \n             @Override\n@@ -509,7 +509,7 @@ public static <T> Observable<T> filter(Observable<T> that, Func1<T, Boolean> pre\n      * \n      * @param that\n      *            the Observable to filter\n-     * @param predicate\n+     * @param function\n      *            a function that evaluates the items emitted by the source Observable, returning <code>true</code> if they pass the filter\n      * @return an Observable that emits only those items in the original Observable that the filter evaluates as true\n      */\n@@ -544,7 +544,7 @@ public static <T> Observable<T> from(Iterable<T> iterable) {\n     /**\n      * Converts an Array to an Observable sequence.\n      * \n-     * @param iterable\n+     * @param items\n      *            the source Array\n      * @param <T>\n      *            the type of items in the Array, and the type of items emitted by the resulting Observable\n@@ -574,7 +574,7 @@ public static Observable<Integer> range(int start, int count) {\n      * <p>\n      * To convert any object into an Observable that emits that object, pass that object into the <code>just</code> method.\n      * <p>\n-     * This is similar to the {@link toObservable} method, except that <code>toObservable</code> will convert\n+     * This is similar to the {@link #toObservable} method, except that <code>toObservable</code> will convert\n      * an {@link Iterable} object into an Observable that emits each of the items in the {@link Iterable}, one\n      * at a time, while the <code>just</code> method would convert the {@link Iterable} into an Observable\n      * that emits the entire {@link Iterable} as a single item.\n@@ -647,9 +647,9 @@ public static <T, R> Observable<R> map(Observable<T> sequence, Func1<T, R> func)\n      * @return an Observable that is the result of applying the transformation function to each item\n      *         in the sequence emitted by the source Observable\n      */\n-    public static <T, R> Observable<R> map(Observable<T> sequence, final Object function) {\n+    public static <T, R> Observable<R> map(Observable<T> sequence, final Object func) {\n         @SuppressWarnings(\"rawtypes\")\n-        final FuncN _f = Functions.from(function);\n+        final FuncN _f = Functions.from(func);\n         return map(sequence, new Func1<T, R>() {\n \n             @SuppressWarnings(\"unchecked\")\n@@ -707,9 +707,9 @@ public static <T, R> Observable<R> mapMany(Observable<T> sequence, Func1<T, Obse\n      *         function to each item emitted by the source Observable and merging the results of\n      *         the Observables obtained from this transformation\n      */\n-    public static <T, R> Observable<R> mapMany(Observable<T> sequence, final Object function) {\n+    public static <T, R> Observable<R> mapMany(Observable<T> sequence, final Object func) {\n         @SuppressWarnings(\"rawtypes\")\n-        final FuncN _f = Functions.from(function);\n+        final FuncN _f = Functions.from(func);\n         return mapMany(sequence, new Func1<T, R>() {\n \n             @SuppressWarnings(\"unchecked\")\n@@ -726,10 +726,10 @@ public R call(T t1) {\n      * <p>\n      * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/materialize.png\">\n      * \n-     * @param source\n+     * @param sequence\n      *            An observable sequence of elements to project.\n      * @return An observable sequence whose elements are the result of materializing the notifications of the given sequence.\n-     * @see http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx\">MSDN: Observable.Materialize</a>\n      */\n     public static <T> Observable<Notification<T>> materialize(final Observable<T> sequence) {\n         return _create(OperationMaterialize.materialize(sequence));\n@@ -746,7 +746,7 @@ public static <T> Observable<Notification<T>> materialize(final Observable<T> se\n      *            a list of Observables that emit sequences of items\n      * @return an Observable that emits a sequence of elements that are the result of flattening the\n      *         output from the <code>source</code> list of Observables\n-     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx\">MSDN: Observable.Merge Method</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx\">MSDN: Observable.Merge</a>\n      */\n     public static <T> Observable<T> merge(List<Observable<T>> source) {\n         return _create(OperationMerge.merge(source));\n@@ -1003,7 +1003,7 @@ public Observable<T> call(Exception e) {\n      * \n      * @param that\n      *            the source Observable\n-     * @param resumeFunction\n+     * @param resumeSequence\n      *            a function that returns an Observable that will take over if the source Observable\n      *            encounters an error\n      * @return the source Observable, with its behavior modified as described\n@@ -1461,7 +1461,7 @@ public static <T> Observable<T> toObservable(Future<T> future, long time, TimeUn\n      * <p>\n      * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toObservable.png\">\n      * \n-     * @param iterable\n+     * @param items\n      *            the source Array\n      * @param <T>\n      *            the type of items in the Array, and the type of items emitted by the resulting\n@@ -1612,7 +1612,7 @@ private static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observ\n      *            one source Observable\n      * @param w1\n      *            another source Observable\n-     * @param reduceFunction\n+     * @param function\n      *            a function that, when applied to an item emitted by each of the source Observables,\n      *            results in a value that will be emitted by the resulting Observable\n      * @return an Observable that emits the zipped results\n@@ -1918,7 +1918,7 @@ public Observable<R> call(T t1) {\n      * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/materialize.png\">\n      * \n      * @return An observable sequence whose elements are the result of materializing the notifications of the given sequence.\n-     * @see http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx\">MSDN: Observable.materialize</a>\n      */\n     public Observable<Notification<T>> materialize() {\n         return materialize(this);\n@@ -2050,8 +2050,7 @@ public Observable<T> onErrorReturn(Func1<Exception, T> resumeFunction) {\n      * <p>\n      * You can use this to prevent errors from propagating or to supply fallback data should errors\n      * be encountered.\n-     * \n-     * @param that\n+     *\n      * @param resumeFunction\n      * @return the original Observable with appropriately modified behavior\n      */",
    "output": "Fix javadocs - cleanup some warnings"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/util/functions/Functions.java b/rxjava-core/src/main/java/rx/util/functions/Functions.java\n--- a/rxjava-core/src/main/java/rx/util/functions/Functions.java\n+++ b/rxjava-core/src/main/java/rx/util/functions/Functions.java\n@@ -43,17 +43,21 @@ public class Functions {\n         // as new languages arise we can add them here but this does not prevent someone from using 'registerLanguageAdaptor' directly\n     }\n \n-    private static void loadLanguageAdaptor(String name) {\n+    private static boolean loadLanguageAdaptor(String name) {\n         String className = \"rx.lang.\" + name.toLowerCase() + \".\" + name + \"Adaptor\";\n         try {\n             Class<?> c = Class.forName(className);\n             FunctionLanguageAdaptor a = (FunctionLanguageAdaptor) c.newInstance();\n             registerLanguageAdaptor(a.getFunctionClass(), a);\n+            logger.info(\"Successfully loaded function language adaptor: \" + name + \" with path: \" + className);\n         } catch (ClassNotFoundException e) {\n-            logger.info(\"Could not found function language adaptor: \" + name + \" with path: \" + className);\n+            logger.info(\"Could not find function language adaptor: \" + name + \" with path: \" + className);\n+            return false;\n         } catch (Exception e) {\n             logger.error(\"Failed trying to initialize function language adaptor: \" + className, e);\n+            return false;\n         }\n+        return true;\n     }\n \n     public static void registerLanguageAdaptor(Class<?>[] functionClasses, FunctionLanguageAdaptor adaptor) {",
    "output": "Fix grammar and add success log"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n--- a/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n+++ b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java\n@@ -24,6 +24,7 @@\n \n import java.util.Iterator;\n import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.*;\n@@ -135,6 +136,39 @@ public void testTakeLast2() {\n             verify(aObserver, times(1)).onCompleted();\n         }\n \n+        @Test\n+        public void testTakeLastOrdering() {\n+            Observable<String> w = Observable.toObservable(\"one\", \"two\", \"three\");\n+            Observable<String> take = Observable.create(takeLast(w, 2));\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Observer<String> aObserver = mock(Observer.class);\n+            take.subscribe(countingWrapper(aObserver));\n+            verify(aObserver, times(1)).onNext(\"two_1\");\n+            verify(aObserver, times(1)).onNext(\"three_2\");\n+        }\n+\n+\n+        private static Observer<String> countingWrapper(final Observer<String> underlying) {\n+            return new Observer<String>() {\n+                private final AtomicInteger counter = new AtomicInteger();\n+                @Override\n+                public void onCompleted() {\n+                    underlying.onCompleted();\n+                }\n+\n+                @Override\n+                public void onError(Exception e) {\n+                    underlying.onCompleted();\n+                }\n+\n+                @Override\n+                public void onNext(String args) {\n+                    underlying.onNext(args + \"_\" + counter.incrementAndGet());\n+                }\n+            };\n+        }\n+\n     }\n \n }\n\\ No newline at end of file",
    "output": "Add ordering unit test"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -46,6 +46,7 @@\n import rx.operators.OperationSkip;\n import rx.operators.OperationSynchronize;\n import rx.operators.OperationTake;\n+import rx.operators.OperationTakeLast;\n import rx.operators.OperationToObservableFuture;\n import rx.operators.OperationToObservableIterable;\n import rx.operators.OperationToObservableList;",
    "output": "Fix import"
  },
  {
    "input": "diff --git a/rxjava-examples/src/main/java/rx/examples/java/RxExamples.java b/rxjava-examples/src/main/java/rx/examples/java/RxExamples.java\n--- a/rxjava-examples/src/main/java/rx/examples/java/RxExamples.java\n+++ b/rxjava-examples/src/main/java/rx/examples/java/RxExamples.java\n@@ -1,22 +0,0 @@\n-package rx.examples.java;\n-\n-import rx.Observable;\n-import rx.util.functions.Action1;\n-\n-public class RxExamples {\n-\n-    public static void main(String args[]) {\n-        hello(\"Ben\", \"George\");\n-    }\n-\n-    public static void hello(String... names) {\n-        Observable.toObservable(names).subscribe(new Action1<String>() {\n-\n-            @Override\n-            public void call(String s) {\n-                System.out.println(\"Hello \" + s + \"!\");\n-            }\n-\n-        });\n-    }\n-}",
    "output": "Remove rxjava-examples Examples have been moved into /src/examples folders of each language-adaptor subproject"
  },
  {
    "input": "diff --git a/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java\n--- a/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java\n+++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java\n@@ -100,7 +100,7 @@ public void before() {\n \n         @Test\n         public void testTake() {\n-            runClojureScript(\"(-> (rx.observables.Observable/toObservable [\\\"one\\\" \\\"two\\\" \\\"three\\\"]) (.take 2) (.subscribe (fn [arg] (println arg))))\");\n+            runClojureScript(\"(-> (rx.Observable/toObservable [\\\"one\\\" \\\"two\\\" \\\"three\\\"]) (.take 2) (.subscribe (fn [arg] (println arg))))\");\n         }\n \n         // commented out for now as I can't figure out how to set the var 'a' with the 'assertion' instance when running the code from java \n\ndiff --git a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n--- a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n+++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n@@ -164,7 +164,7 @@ private void runGroovyScript(String script) {\n \n             StringBuilder b = new StringBuilder();\n             // force JRuby to always use subscribe(Object)\n-            b.append(\"import \\\"rx.observables.Observable\\\"\").append(\"\\n\");\n+            b.append(\"import \\\"rx.Observable\\\"\").append(\"\\n\");\n             b.append(\"class Observable\").append(\"\\n\");\n             b.append(\"  java_alias :subscribe, :subscribe, [java.lang.Object]\").append(\"\\n\");\n             b.append(\"end\").append(\"\\n\");",
    "output": "Fix package names for imports"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java\n--- a/rxjava-core/src/main/java/rx/Observable.java\n+++ b/rxjava-core/src/main/java/rx/Observable.java\n@@ -913,7 +913,7 @@ public void unsubscribe() {\n      * @return\n      */\n     public static Subscription createSubscription(final Object unsubscribe) {\n-        final FuncN f = Functions.from(unsubscribe);\n+        final FuncN<?> f = Functions.from(unsubscribe);\n         return new Subscription() {\n \n             @Override",
    "output": "Fix warning"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observables/operations/OperationConcat.java b/rxjava-core/src/main/java/rx/observables/operations/OperationConcat.java\n--- a/rxjava-core/src/main/java/rx/observables/operations/OperationConcat.java\n+++ b/rxjava-core/src/main/java/rx/observables/operations/OperationConcat.java\n@@ -22,6 +22,9 @@\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n \n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.concurrent.CountDownLatch;\n \n import org.junit.Assert;\n@@ -32,6 +35,7 @@\n import rx.observables.Observer;\n import rx.observables.Subscription;\n import rx.util.AtomicObservableSubscription;\n+import rx.util.functions.Action1;\n import rx.util.functions.Func1;\n \n public final class OperationConcat {\n@@ -46,6 +50,25 @@ public Subscription call(Observer<T> observer) {\n         };\n     }\n \n+    public static <T> Func1<Observer<T>, Subscription> concat(final List<Observable<T>> sequences) {\n+    \t@SuppressWarnings(\"unchecked\")\n+\t\tObservable<T>[] o = sequences.toArray((Observable<T>[])Array.newInstance(Observable.class, sequences.size()));\n+    \treturn concat(o);\n+    }\n+\n+    public static <T> Func1<Observer<T>, Subscription> concat(final Observable<Observable<T>> sequences) {   \t\n+    \tfinal List<Observable<T>> list = new ArrayList<Observable<T>>();\n+     \tsequences.toList().subscribe(new Action1<List<Observable<T>>>(){\n+\t\t\t@Override\n+\t\t\tpublic void call(List<Observable<T>> t1) {\n+\t\t\t\tlist.addAll(t1);\n+\t\t\t}\n+     \t\t\n+     \t});    \t\n+     \n+    \treturn concat(list);\n+    }\n+    \n     private static class Concat<T> implements OperatorSubscribeFunction<T> {\n         private final Observable<T>[] sequences;\n         private int num = 0;\n@@ -133,8 +156,8 @@ public void before() {\n \t\n \t\t@Test\n \t\tpublic void testConcat() {\t\t        \n-\t\t\tString[] o = {\"1\", \"3\", \"5\", \"7\"};\t\t\t        \n-\t\t\tString[] e = {\"2\", \"4\", \"6\"};\t\t\t         \n+\t\t\tfinal String[] o = {\"1\", \"3\", \"5\", \"7\"};\t\t\t        \n+\t\t\tfinal String[] e = {\"2\", \"4\", \"6\"};\t\t\t         \n \t\t\t        \n \t\t\tfinal Observable<String> odds  = Observable.toObservable(o);\t\t\t        \n \t\t\tfinal Observable<String> even = Observable.toObservable(e);\n@@ -145,13 +168,30 @@ public void testConcat() {\n \t\t\tAssert.assertEquals(expected.length, index);\n \t\t \n \t\t}\n+\n+\t\t@Test\n+\t\tpublic void testConcatWithList() {\t\t        \n+\t\t\tfinal String[] o = {\"1\", \"3\", \"5\", \"7\"};\t\t\t        \n+\t\t\tfinal String[] e = {\"2\", \"4\", \"6\"};\t\t\t         \n+\t\t\t        \n+\t\t\tfinal Observable<String> odds  = Observable.toObservable(o);\t\t\t        \n+\t\t\tfinal Observable<String> even = Observable.toObservable(e);\n+\t\t\tfinal List<Observable<String>> list = new ArrayList<Observable<String>>();\n+\t\t\tlist.add(odds);\n+\t\t\tlist.add(even);\n+\t\t\t@SuppressWarnings(\"unchecked\")\n+\t        Observable<String> concat = Observable.create(concat(list));\t\t\t        \n+\t\t\tconcat.subscribe(observer);   \t\n+\t\t\tAssert.assertEquals(expected.length, index);\n+\t\t \n+\t\t}\n \t\t\n \t\t@Test \n \t\tpublic void testConcatUnsubscribe() {\n-            CountDownLatch callOnce = new CountDownLatch(1);\n-            CountDownLatch okToContinue = new CountDownLatch(1);\n-            TestObservable w1 = new TestObservable(null, null, \"one\", \"two\", \"three\");\n-            TestObservable w2 = new TestObservable(callOnce, okToContinue, \"four\", \"five\", \"six\");\n+            final CountDownLatch callOnce = new CountDownLatch(1);\n+            final CountDownLatch okToContinue = new CountDownLatch(1);\n+            final TestObservable w1 = new TestObservable(null, null, \"one\", \"two\", \"three\");\n+            final TestObservable w2 = new TestObservable(callOnce, okToContinue, \"four\", \"five\", \"six\");\n \n             @SuppressWarnings(\"unchecked\")\n             Observer<String> aObserver = mock(Observer.class);\n@@ -180,6 +220,41 @@ public void testConcatUnsubscribe() {\n             verify(aObserver, never()).onNext(\"six\");\n  \t\t}\n \t\t\n+        @Test\n+        public void testMergeObservableOfObservables() {\n+\t\t\tfinal String[] o = {\"1\", \"3\", \"5\", \"7\"};\t\t\t        \n+\t\t\tfinal String[] e = {\"2\", \"4\", \"6\"};\t\t\t         \n+\t\t\t        \n+\t\t\tfinal Observable<String> odds  = Observable.toObservable(o);\t\t\t        \n+\t\t\tfinal Observable<String> even = Observable.toObservable(e);\n+\n+            Observable<Observable<String>> observableOfObservables = Observable.create(new Func1<Observer<Observable<String>>, Subscription>() {\n+\n+                @Override\n+                public Subscription call(Observer<Observable<String>> observer) {\n+                    // simulate what would happen in an observable\n+                    observer.onNext(odds);\n+                    observer.onNext(even);\n+                    observer.onCompleted();\n+\n+                    return new Subscription() {\n+\n+                        @Override\n+                        public void unsubscribe() {\n+                            // unregister ... will never be called here since we are executing synchronously\n+                        }\n+\n+                    };\n+                }\n+\n+            });\n+\t\t\t@SuppressWarnings(\"unchecked\")\n+\t        Observable<String> concat = Observable.create(concat(observableOfObservables));\t\t\t        \n+\t\t\tconcat.subscribe(observer);   \t\n+\t\t\tAssert.assertEquals(expected.length, index);\n+       }\n+\n+\t\t\n \t    private static class TestObservable extends Observable<String> {\n \n \t            private final Subscription s = new Subscription() {",
    "output": "Add overloaded methods and unit tests for list<observable<T>> and Observable<Observable<T>>"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observables/Observable.java b/rxjava-core/src/main/java/rx/observables/Observable.java\n--- a/rxjava-core/src/main/java/rx/observables/Observable.java\n+++ b/rxjava-core/src/main/java/rx/observables/Observable.java\n@@ -24,6 +24,7 @@\n import java.util.Map;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n \n import org.junit.Before;\n import org.junit.Test;\n@@ -1406,6 +1407,7 @@ public static <T> Observable<T> toObservable(Iterable<T> iterable) {\n      * \n      * Any object that supports the {@link Future} interface can be converted into a Observable that emits\n      * the return value of the get() method in the object, by passing the object into the <code>toObservable</code> method.\n+     * The subscribe method on this synchronously so the Subscription returned doesn't nothing.\n      * \n      * @param future\n      *            the source {@link Future}\n@@ -1423,6 +1425,8 @@ public static <T> Observable<T> toObservable(Future<T> future) {\n      * \n      * Any object that supports the {@link Future} interface can be converted into a Observable that emits\n      * the return value of the get() method in the object, by passing the object into the <code>toObservable</code> method.\n+     * The subscribe method on this synchronously so the Subscription returned doesn't nothing.\n+     * If the future timesout the {@link TimeoutException} exception is passed to the onError. \n      * \n      * @param future\n      *            the source {@link Future}",
    "output": "Add more details about how the toObservable behaves"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observables/operations/OperationConcat.java b/rxjava-core/src/main/java/rx/observables/operations/OperationConcat.java\n--- a/rxjava-core/src/main/java/rx/observables/operations/OperationConcat.java\n+++ b/rxjava-core/src/main/java/rx/observables/operations/OperationConcat.java\n@@ -150,30 +150,34 @@ public void testConcat() {\n \t\tpublic void testConcatUnsubscribe() {\n             CountDownLatch callOnce = new CountDownLatch(1);\n             CountDownLatch okToContinue = new CountDownLatch(1);\n-            TestObservable w = new TestObservable(callOnce, okToContinue, \"one\", \"two\", \"three\");\n+            TestObservable w1 = new TestObservable(null, null, \"one\", \"two\", \"three\");\n+            TestObservable w2 = new TestObservable(callOnce, okToContinue, \"four\", \"five\", \"six\");\n \n             @SuppressWarnings(\"unchecked\")\n             Observer<String> aObserver = mock(Observer.class);\n             @SuppressWarnings(\"unchecked\")\n-            Observable<String> concat = Observable.create(concat(w));\n+            Observable<String> concat = Observable.create(concat(w1, w2));\n             Subscription s1 = concat.subscribe(aObserver);\n             \n             try {\n-                //Allow the observable to call onNext once.\n+                //Block main thread to allow observable \"w1\" to complete and observable \"w2\" to call onNext once.\n             \tcallOnce.await();\n                 s1.unsubscribe();\n                 //Unblock the observable to continue.\n                 okToContinue.countDown();\n-                w.t.join();                \n+                w1.t.join();   \n+                w2.t.join();\n             } catch (Exception e) {\n                 e.printStackTrace();\n                 fail(e.getMessage());\n             }\n \n-            System.out.println(\"TestObservable thread finished\");\n             verify(aObserver, times(1)).onNext(\"one\");\n-            verify(aObserver, never()).onNext(\"two\");\n-            verify(aObserver, never()).onNext(\"three\");\n+            verify(aObserver, times(1)).onNext(\"two\");\n+            verify(aObserver, times(1)).onNext(\"three\");\n+            verify(aObserver, times(1)).onNext(\"four\");\n+            verify(aObserver, never()).onNext(\"five\");\n+            verify(aObserver, never()).onNext(\"six\");\n  \t\t}\n \t\t\n \t    private static class TestObservable extends Observable<String> {\n@@ -211,34 +215,31 @@ public Subscription call(Observer<String> t1) {\n \t            \n \t            @Override\n \t            public Subscription subscribe(final Observer<String> observer) {\n-\t                System.out.println(\"TestObservable subscribed to ...\");\n \t                t = new Thread(new Runnable() {\n \n \t                    @Override\n \t                    public void run() {\n \t                        try {\n-\t                            System.out.println(\"running TestObservable thread\");\n \t\t                        while(count < values.length && subscribed) {\n-\t                                System.out.println(\"TestObservable onNext: \" + s);\n \t                                observer.onNext(values[count]);\n \t                                count++;\n \t                                //Unblock the main thread to call unsubscribe.\n-\t                                once.countDown();\n+\t                                if (null != once)\n+\t                                \tonce.countDown();\n \t                                //Block until the main thread has called unsubscribe.\n-\t                                okToContinue.await();\n-\t\t                        }\n-\t\t                        \n+\t                                if (null != once)\n+\t                                \tokToContinue.await();\n+\t\t                        }\t\t                        \n \t\t                        if (subscribed)\n-\t                            observer.onCompleted();\n-\t                        } catch (Exception e) {\n-\t                            throw new RuntimeException(e);\n+\t\t                        \tobserver.onCompleted();\n+\t                        } catch (InterruptedException e) {\n+\t                            e.printStackTrace();\n+\t                            fail(e.getMessage());\n \t                        }\n \t                    }\n \n \t                });\n-\t                System.out.println(\"starting TestObservable thread\");\n \t                t.start();\n-\t                System.out.println(\"done starting TestObservable thread\");\n \t                return s;\n \t            }\n ",
    "output": "Upgrade example with two observables"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observables/Observable.java b/rxjava-core/src/main/java/rx/observables/Observable.java\n--- a/rxjava-core/src/main/java/rx/observables/Observable.java\n+++ b/rxjava-core/src/main/java/rx/observables/Observable.java\n@@ -23,6 +23,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n \n import org.junit.Before;\n import org.junit.Test;\n@@ -1377,6 +1378,25 @@ public static <T> Observable<T> toObservable(Iterable<T> iterable) {\n     public static <T> Observable<T> toObservable(Future<T> future) {\n         return create(OperationToObservableFuture.toObservableFuture(future));\n     }\n+    \n+    /**\n+     * Converts an Future to a Observable sequence.\n+     * \n+     * Any object that supports the {@link Future} interface can be converted into a Observable that emits\n+     * the return value of the get() method in the object, by passing the object into the <code>toObservable</code> method.\n+     * \n+     * @param future\n+     *            the source {@link Future}\n+     * @param time the maximum time to wait\n+     * @param unit the time unit of the time argument\n+     * @param <T>\n+     *            the type of of object that the future's returns and the type emitted by the resulting\n+     *            Observable\n+     * @return a Observable that emits the item from the source Future\n+     */\n+    public static <T> Observable<T> toObservable(Future<T> future, long time, TimeUnit unit) {\n+        return create(OperationToObservableFuture.toObservableFuture(future, time, unit));\n+    }\n \n     /**\n      * Converts an Array sequence to a Observable sequence.\n\ndiff --git a/rxjava-core/src/main/java/rx/observables/operations/OperationToObservableFuture.java b/rxjava-core/src/main/java/rx/observables/operations/OperationToObservableFuture.java\n--- a/rxjava-core/src/main/java/rx/observables/operations/OperationToObservableFuture.java\n+++ b/rxjava-core/src/main/java/rx/observables/operations/OperationToObservableFuture.java\n@@ -7,6 +7,7 @@\n import static org.mockito.Mockito.when;\n \n import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n \n import org.junit.Test;\n \n@@ -18,15 +19,26 @@\n public class OperationToObservableFuture {\n     private static class ToObservableFuture<T> implements OperatorSubscribeFunction<T> {\n         private final Future<T> that;\n+        private final Long time;\n+        private final TimeUnit unit;\n \n         public ToObservableFuture(Future<T> that) {\n             this.that = that;\n+            this.time = null;\n+            this.unit = null;\n+        }\n+\n+        public ToObservableFuture(Future<T> that, long time, TimeUnit unit) {\n+            this.that = that;\n+            this.time = time;\n+            this.unit = unit;\n         }\n \n         @Override\n         public Subscription call(Observer<T> observer) {\n             try {\n-                T value = that.get();\n+                T value = (time == null) ? that.get() : that.get(time, unit);\n+\n                 if (!that.isCancelled()) {\n                     observer.onNext(value);\n                 }\n@@ -45,6 +57,10 @@ public static <T> Func1<Observer<T>, Subscription> toObservableFuture(final Futu\n         return new ToObservableFuture<T>(that);\n     }\n \n+    public static <T> Func1<Observer<T>, Subscription> toObservableFuture(final Future<T> that, long time, TimeUnit unit) {\n+        return new ToObservableFuture<T>(that, time, unit);\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     public static class UnitTest {\n         @Test",
    "output": "Add support for also get time outs"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observables/Observable.java b/rxjava-core/src/main/java/rx/observables/Observable.java\n--- a/rxjava-core/src/main/java/rx/observables/Observable.java\n+++ b/rxjava-core/src/main/java/rx/observables/Observable.java\n@@ -343,7 +343,7 @@ public NeverObservable() {\n \n                 @Override\n                 public Subscription call(Observer<T> t1) {\n-                    return new NullObservableSubscription();\n+                    return new NoOpObservableSubscription();\n                 }\n \n             });\n@@ -353,7 +353,7 @@ public Subscription call(Observer<T> t1) {\n     /**\n      * A disposable object that does nothing when its unsubscribe method is called.\n      */\n-    private static class NullObservableSubscription implements Subscription {\n+    private static class NoOpObservableSubscription implements Subscription {\n         public void unsubscribe() {\n         }\n     }\n@@ -379,7 +379,7 @@ public ThrowObservable(final Exception exception) {\n                 @Override\n                 public Subscription call(Observer<T> observer) {\n                     observer.onError(exception);\n-                    return new NullObservableSubscription();\n+                    return new NoOpObservableSubscription();\n                 }\n \n             });\n@@ -862,7 +862,7 @@ public static <T> Observable<T> never() {\n      * @return\n      */\n     public static Subscription noOpSubscription() {\n-        return new NullObservableSubscription();\n+        return new NoOpObservableSubscription();\n     }\n \n     /**",
    "output": "Change NullObservableSubscription to NoOpObservableSubscription\n\nGives stacktraces that make more sense as \"null\" has nothing to do with it"
  },
  {
    "input": "diff --git a/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java\n--- a/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java\n+++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java\n@@ -33,6 +33,7 @@\n import rx.observables.Observable;\n import rx.observables.Observer;\n import rx.observables.Subscription;\n+import rx.util.functions.Func1;\n import rx.util.functions.FunctionLanguageAdaptor;\n \n public class GroovyAdaptor implements FunctionLanguageAdaptor {\n@@ -239,6 +240,14 @@ private static class TestObservable extends Observable<String> {\n             private final int count;\n \n             public TestObservable(int count) {\n+                super(new Func1<Observer<String>, Subscription>() {\n+\n+                    @Override\n+                    public Subscription call(Observer<String> t1) {\n+                        // do nothing, override subscribe for test\n+                        return null;\n+                    }\n+                });\n                 this.count = count;\n             }\n \n\ndiff --git a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n--- a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n+++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n@@ -34,6 +34,7 @@\n import rx.observables.Observable;\n import rx.observables.Observer;\n import rx.observables.Subscription;\n+import rx.util.functions.Func1;\n import rx.util.functions.FunctionLanguageAdaptor;\n \n public class JRubyAdaptor implements FunctionLanguageAdaptor {\n@@ -194,6 +195,14 @@ private static class TestObservable extends Observable<String> {\n             private final int count;\n \n             public TestObservable(int count) {\n+                super(new Func1<Observer<String>, Subscription>() {\n+\n+                    @Override\n+                    public Subscription call(Observer<String> t1) {\n+                        // do nothing, override subscribe for test\n+                        return null;\n+                    }\n+                });\n                 this.count = count;\n             }\n ",
    "output": "Fix compile issues after core refactoring"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/subjects/Subject.java b/rxjava-core/src/main/java/rx/subjects/Subject.java\n--- a/rxjava-core/src/main/java/rx/subjects/Subject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/Subject.java\n@@ -1,11 +1,10 @@\n package rx.subjects;\n \n-import groovy.lang.Reference;\n-\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import junit.framework.Assert;\n \n@@ -78,7 +77,7 @@ public static class UnitTest {\n         @Test\n         public void test() {\n             Subject<Integer> subject = Subject.<Integer> create();\n-            final Reference<List<Notification<String>>> actualRef = new Reference<List<Notification<String>>>();\n+            final AtomicReference<List<Notification<String>>> actualRef = new AtomicReference<List<Notification<String>>>();\n \n             Observable<List<Notification<Integer>>> wNotificationsList = subject.materialize().toList();\n             wNotificationsList.subscribe(new Action1<List<Notification<String>>>() {",
    "output": "Remove the dependency on groovy"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/rx/observables/Notification.java b/rxjava-core/src/main/java/rx/observables/Notification.java\n--- a/rxjava-core/src/main/java/rx/observables/Notification.java\n+++ b/rxjava-core/src/main/java/rx/observables/Notification.java\n@@ -119,4 +119,43 @@ public boolean isOnNext() {\n     public static enum Kind {\n         OnNext, OnError, OnCompleted\n     }\n+    \n+    @Override\n+    public String toString() {\n+        StringBuilder str = new StringBuilder(\"[\").append(super.toString()).append(\" \").append(getKind());\n+        if (hasValue())\n+            str.append(\" \").append(getValue());\n+        if (hasException())\n+            str.append(\" \").append(getException().getMessage());\n+        str.append(\"]\");\n+        return str.toString();\n+    }\n+    \n+    @Override\n+    public int hashCode() {\n+        int hash = getKind().hashCode();\n+        if (hasValue())\n+            hash = hash * 31 + getValue().hashCode();\n+        if (hasException())\n+            hash = hash * 31 + getException().hashCode();\n+        return hash;\n+    }\n+    \n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null)\n+            return false;\n+        if (this == obj)\n+            return true;\n+        if (obj.getClass() != getClass())\n+            return false;\n+        Notification notification = (Notification) obj;\n+        if (notification.getKind() != getKind())\n+            return false;\n+        if (hasValue() && !getValue().equals(notification.getValue()))\n+            return false;\n+        if (hasException() && !getException().equals(notification.getException()))\n+            return false;\n+        return true;\n+    }\n }\n\ndiff --git a/rxjava-core/src/main/java/rx/subjects/Subject.java b/rxjava-core/src/main/java/rx/subjects/Subject.java\n--- a/rxjava-core/src/main/java/rx/subjects/Subject.java\n+++ b/rxjava-core/src/main/java/rx/subjects/Subject.java\n@@ -0,0 +1,127 @@\n+package rx.subjects;\n+\n+import groovy.lang.Reference;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import junit.framework.Assert;\n+\n+import org.junit.Test;\n+\n+import rx.observables.Notification;\n+import rx.observables.Observable;\n+import rx.observables.Observer;\n+import rx.observables.Subscription;\n+import rx.util.AtomicObservableSubscription;\n+import rx.util.AtomicObserver;\n+import rx.util.functions.Action1;\n+import rx.util.functions.Func1;\n+\n+public class Subject<T> extends Observable<T> implements Observer<T> {\n+    public static <T> Subject<T> create() {\n+        final ConcurrentHashMap<Subscription, Observer<T>> observers = new ConcurrentHashMap<Subscription, Observer<T>>();\n+\n+        Func1<Observer<T>, Subscription> onSubscribe = new Func1<Observer<T>, Subscription>() {\n+            @Override\n+            public Subscription call(Observer<T> observer) {\n+                final AtomicObservableSubscription subscription = new AtomicObservableSubscription();\n+\n+                subscription.wrap(new Subscription() {\n+                    @Override\n+                    public void unsubscribe() {\n+                        // on unsubscribe remove it from the map of outbound observers to notify\n+                        observers.remove(subscription);\n+                    }\n+                });\n+\n+                // on subscribe add it to the map of outbound observers to notify\n+                observers.put(subscription, new AtomicObserver<T>(observer, subscription));\n+                return subscription;\n+            }\n+        };\n+\n+        return new Subject<T>(onSubscribe, observers);\n+    }\n+\n+    private final ConcurrentHashMap<Subscription, Observer<T>> observers;\n+\n+    protected Subject(Func1<Observer<T>, Subscription> onSubscribe, ConcurrentHashMap<Subscription, Observer<T>> observers) {\n+        super(onSubscribe);\n+        this.observers = observers;\n+    }\n+\n+    @Override\n+    public void onCompleted() {\n+        for (Observer<T> observer : observers.values()) {\n+            observer.onCompleted();\n+        }\n+    }\n+\n+    @Override\n+    public void onError(Exception e) {\n+        for (Observer<T> observer : observers.values()) {\n+            observer.onError(e);\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(T args) {\n+        for (Observer<T> observer : observers.values()) {\n+            observer.onNext(args);\n+        }\n+    }\n+\n+    public static class UnitTest {\n+        @Test\n+        public void test() {\n+            Subject<Integer> subject = Subject.<Integer> create();\n+            final Reference<List<Notification<String>>> actualRef = new Reference<List<Notification<String>>>();\n+\n+            Observable<List<Notification<Integer>>> wNotificationsList = subject.materialize().toList();\n+            wNotificationsList.subscribe(new Action1<List<Notification<String>>>() {\n+                @Override\n+                public void call(List<Notification<String>> actual) {\n+                    actualRef.set(actual);\n+                }\n+            });\n+\n+            Subscription sub = Observable.create(new Func1<Observer<Integer>, Subscription>() {\n+                @Override\n+                public Subscription call(final Observer<Integer> observer) {\n+                    final AtomicBoolean stop = new AtomicBoolean(false);\n+                    new Thread() {\n+                        @Override\n+                        public void run() {\n+                            int i = 1;\n+                            while (!stop.get()) {\n+                                observer.onNext(i++);\n+                            }\n+                            observer.onCompleted();\n+                        }\n+                    }.start();\n+                    return new Subscription() {\n+                        @Override\n+                        public void unsubscribe() {\n+                            stop.set(true);\n+                        }\n+                    };\n+                }\n+            }).subscribe(subject);\n+            // the subject has received an onComplete from the first subscribe because\n+            // it is synchronous and the next subscribe won't do anything.\n+            Observable.toObservable(-1, -2, -3).subscribe(subject);\n+            \n+            List<Notification<Integer>> expected = new ArrayList<Notification<Integer>>();\n+            expected.add(new Notification<Integer>(-1));\n+            expected.add(new Notification<Integer>(-2));\n+            expected.add(new Notification<Integer>(-3));\n+            expected.add(new Notification<Integer>());\n+            Assert.assertTrue(actualRef.get().containsAll(expected));\n+            \n+            sub.unsubscribe();\n+        }\n+    }\n+}\n\ndiff --git a/rxjava-core/src/main/java/rx/util/AtomicObserverSingleThreaded.java b/rxjava-core/src/main/java/rx/util/AtomicObserverSingleThreaded.java\n--- a/rxjava-core/src/main/java/rx/util/AtomicObserverSingleThreaded.java\n+++ b/rxjava-core/src/main/java/rx/util/AtomicObserverSingleThreaded.java\n@@ -65,13 +65,13 @@ public final class AtomicObserverSingleThreaded<T> implements Observer<T> {\n      * compositional by its very nature.\n      */\n \n-    private final Observer<T> Observer;\n+    private final Observer<T> observer;\n     private final AtomicObservableSubscription subscription;\n     private volatile boolean finishRequested = false;\n     private volatile boolean finished = false;\n \n     public AtomicObserverSingleThreaded(Observer<T> Observer, AtomicObservableSubscription subscription) {\n-        this.Observer = Observer;\n+        this.observer = Observer;\n         this.subscription = subscription;\n     }\n \n@@ -86,7 +86,7 @@ public void onNext(T arg) {\n                 // if we're already stopped, or a finish request has been received, we won't allow further onNext requests\n                 return;\n             }\n-            Observer.onNext(arg);\n+            observer.onNext(arg);\n         }\n     }\n \n@@ -101,7 +101,7 @@ public void onError(Exception e) {\n             if (finished || subscription.isUnsubscribed()) {\n                 return;\n             }\n-            Observer.onError(e);\n+            observer.onError(e);\n             finished = true;\n         }\n     }\n@@ -117,7 +117,7 @@ public void onCompleted() {\n             if (finished || subscription.isUnsubscribed()) {\n                 return;\n             }\n-            Observer.onCompleted();\n+            observer.onCompleted();\n             finished = true;\n         }\n     }",
    "output": "Add a draft of Subject class https://github.com/Netflix/RxJava/issues/19"
  },
  {
    "input": "diff --git a/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java\n--- a/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java\n+++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java\n@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.rx.lang.clojure;\n+package rx.lang.clojure;\n \n import java.util.Arrays;\n \n@@ -100,7 +100,7 @@ public void before() {\n \n         @Test\n         public void testTake() {\n-            runClojureScript(\"(-> (org.rx.reactive.Observable/toObservable [\\\"one\\\" \\\"two\\\" \\\"three\\\"]) (.take 2) (.subscribe (fn [arg] (println arg))))\");\n+            runClojureScript(\"(-> (rx.observables.Observable/toObservable [\\\"one\\\" \\\"two\\\" \\\"three\\\"]) (.take 2) (.subscribe (fn [arg] (println arg))))\");\n         }\n \n         // commented out for now as I can't figure out how to set the var 'a' with the 'assertion' instance when running the code from java \n\ndiff --git a/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java\n--- a/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java\n+++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java\n@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.rx.lang.groovy;\n+package rx.lang.groovy;\n \n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n\ndiff --git a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n--- a/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n+++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java\n@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.rx.lang.jruby;\n+package rx.lang.jruby;\n \n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n@@ -163,7 +163,7 @@ private void runGroovyScript(String script) {\n \n             StringBuilder b = new StringBuilder();\n             // force JRuby to always use subscribe(Object)\n-            b.append(\"import org.rx.reactive.Observable\").append(\"\\n\");\n+            b.append(\"import \\\"rx.observables.Observable\\\"\").append(\"\\n\");\n             b.append(\"class Observable\").append(\"\\n\");\n             b.append(\"  java_alias :subscribe, :subscribe, [java.lang.Object]\").append(\"\\n\");\n             b.append(\"end\").append(\"\\n\");\n\ndiff --git a/rxjava-core/src/main/java/rx/util/Functions.java b/rxjava-core/src/main/java/rx/util/Functions.java\n--- a/rxjava-core/src/main/java/rx/util/Functions.java\n+++ b/rxjava-core/src/main/java/rx/util/Functions.java\n@@ -44,7 +44,7 @@ public class Functions {\n     }\n \n     private static void loadLanguageAdaptor(String name) {\n-        String className = \"org.rx.lang.\" + name.toLowerCase() + \".\" + name + \"Adaptor\";\n+        String className = \"rx.lang.\" + name.toLowerCase() + \".\" + name + \"Adaptor\";\n         try {\n             Class<?> c = Class.forName(className);\n             FunctionLanguageAdaptor a = (FunctionLanguageAdaptor) c.newInstance();",
    "output": "Upgrade language adaptors to rx.* package"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/org/rx/reactive/Observable.java b/rxjava-core/src/main/java/org/rx/reactive/Observable.java\n--- a/rxjava-core/src/main/java/org/rx/reactive/Observable.java\n+++ b/rxjava-core/src/main/java/org/rx/reactive/Observable.java\n@@ -69,15 +69,6 @@ public abstract class Observable<T> {\n     public Observable() {\n     }\n \n-    public static <T> Observable<T> create(final Func1<Subscription, Observer<T>> f, Observer<T> observer) {\n-        return new Observable<T>() {\n-            @Override\n-            public Subscription subscribe(Observer<T> observer) {\n-                return f.call(observer);\n-            }\n-        };\n-    }\n-\n     /**\n      * A Observer must call a Observable's <code>subscribe</code> method in order to register itself\n      * to receive push-based notifications from the Observable. A typical implementation of the",
    "output": "Remove erroneous create method\n\nIt was a method I was playing with during refactoring and accidentally committed.\r\n\r\nThe real create methods already exist"
  },
  {
    "input": "diff --git a/rxjava-core/src/main/java/org/rx/functions/Func5.java b/rxjava-core/src/main/java/org/rx/functions/Func5.java\n--- a/rxjava-core/src/main/java/org/rx/functions/Func5.java\n+++ b/rxjava-core/src/main/java/org/rx/functions/Func5.java\n@@ -0,0 +1,5 @@\n+package org.rx.functions;\n+\n+public interface Func5<R, T1, T2, T3, T4, T5> {\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);\n+}\n\\ No newline at end of file\n\ndiff --git a/rxjava-core/src/main/java/org/rx/functions/Func6.java b/rxjava-core/src/main/java/org/rx/functions/Func6.java\n--- a/rxjava-core/src/main/java/org/rx/functions/Func6.java\n+++ b/rxjava-core/src/main/java/org/rx/functions/Func6.java\n@@ -0,0 +1,5 @@\n+package org.rx.functions;\n+\n+public interface Func6<R, T1, T2, T3, T4, T5, T6> {\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);\n+}\n\\ No newline at end of file\n\ndiff --git a/rxjava-core/src/main/java/org/rx/functions/Func7.java b/rxjava-core/src/main/java/org/rx/functions/Func7.java\n--- a/rxjava-core/src/main/java/org/rx/functions/Func7.java\n+++ b/rxjava-core/src/main/java/org/rx/functions/Func7.java\n@@ -0,0 +1,5 @@\n+package org.rx.functions;\n+\n+public interface Func7<R, T1, T2, T3, T4, T5, T6, T7> {\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7);\n+}\n\\ No newline at end of file\n\ndiff --git a/rxjava-core/src/main/java/org/rx/functions/Func8.java b/rxjava-core/src/main/java/org/rx/functions/Func8.java\n--- a/rxjava-core/src/main/java/org/rx/functions/Func8.java\n+++ b/rxjava-core/src/main/java/org/rx/functions/Func8.java\n@@ -0,0 +1,5 @@\n+package org.rx.functions;\n+\n+public interface Func8<R, T1, T2, T3, T4, T5, T6, T7, T8> {\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8);\n+}\n\\ No newline at end of file\n\ndiff --git a/rxjava-core/src/main/java/org/rx/functions/Func9.java b/rxjava-core/src/main/java/org/rx/functions/Func9.java\n--- a/rxjava-core/src/main/java/org/rx/functions/Func9.java\n+++ b/rxjava-core/src/main/java/org/rx/functions/Func9.java\n@@ -0,0 +1,5 @@\n+package org.rx.functions;\n+\n+public interface Func9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9> {\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9);\n+}\n\\ No newline at end of file",
    "output": "Add more arities"
  }
]