[
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.config.metadata;\n+import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository;\n@@ -31,6 +32,7 @@\n import org.apache.dubbo.registry.client.metadata.MetadataServiceDelegationV2;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.ExecutorService;\n@@ -71,7 +73,7 @@ public ConfigurableMetadataServiceExporter(\n     }\n     public synchronized ConfigurableMetadataServiceExporter export() {\n-        if (serviceConfig == null || !isExported()) {\n+        if (!isExported()) {\n             if (MetadataServiceVersionUtils.needExportV1(applicationModel)) {\n                 exportV1();\n             }\n@@ -84,13 +86,28 @@ public synchronized ConfigurableMetadataServiceExporter export() {\n                         CONFIG_METADATA_SERVICE_EXPORTED,\n                         \"\",\n                         \"\",\n-                        \"The MetadataService has been exported : \" + serviceConfig.getExportedUrls());\n+                        \"The MetadataService has been exported : \" + getExportedUrls());\n             }\n         }\n         return this;\n     }\n+    /**\n+     * Get exported urls which include v1 and v2 if existed\n+     * @return exported urls\n+     */\n+    public List<URL> getExportedUrls() {\n+        List<URL> urls = new ArrayList<>();\n+        if (serviceConfig != null) {\n+            urls.addAll(serviceConfig.getExportedUrls());\n+        }\n+        if (serviceConfigV2 != null) {\n+            urls.addAll(serviceConfigV2.getExportedUrls());\n+        }\n+        return urls;\n+    }\n+\n     private static final String INTERNAL_METADATA_REGISTRY_ID = \"internal-metadata-registry\";\n     private void exportV1() {",
    "output": "Add serviceConfigV2 null check at metadata service export * Remove redundant condition checking from ConfigurableMetadataServiceExporter method ---------"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/AbstractNettyConnectionClient.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/AbstractNettyConnectionClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/AbstractNettyConnectionClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/AbstractNettyConnectionClient.java\n@@ -177,15 +177,21 @@ protected void doDisConnect() {\n         NettyChannel.removeChannelIfDisconnected(getNettyChannel());\n     }\n-    protected void doReconnect() {\n-        connectivityExecutor.execute(() -> {\n-            try {\n-                doConnect();\n-            } catch (RemotingException e) {\n-                logger.error(\n-                        TRANSPORT_FAILED_RECONNECT, \"\", \"\", \"Failed to reconnect to server: \" + getConnectAddress());\n-            }\n-        });\n+    protected void scheduleReconnect(long reconnectDuration, TimeUnit unit) {\n+        connectivityExecutor.schedule(\n+                () -> {\n+                    try {\n+                        doConnect();\n+                    } catch (RemotingException e) {\n+                        logger.error(\n+                                TRANSPORT_FAILED_RECONNECT,\n+                                \"\",\n+                                \"\",\n+                                \"Failed to connect to server: \" + getConnectAddress());\n+                    }\n+                },\n+                reconnectDuration,\n+                unit);\n     }\n     @Override\n@@ -378,7 +384,7 @@ public void operationComplete(ChannelFuture future) {\n             // Notify the connection is unavailable.\n             disconnectedPromise.trySuccess(null);\n-            doReconnect();\n+            scheduleReconnect(reconnectDuration, TimeUnit.MILLISECONDS);\n         }\n     }\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionHandler.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionHandler.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionHandler.java\n@@ -26,7 +26,6 @@\n import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n-import io.netty.channel.EventLoop;\n import io.netty.util.Attribute;\n import io.netty.util.AttributeKey;\n@@ -71,16 +70,14 @@ public void reconnect(Object channel) {\n         if (!(channel instanceof Channel)) {\n             return;\n         }\n-        Channel nettyChannel = ((Channel) channel);\n         if (LOGGER.isDebugEnabled()) {\n             LOGGER.debug(\"Connection:{} is reconnecting, attempt={}\", connectionClient, 1);\n         }\n-        EventLoop eventLoop = nettyChannel.eventLoop();\n         if (connectionClient.isClosed()) {\n             LOGGER.info(\"The connection {} has been closed and will not reconnect\", connectionClient);\n             return;\n         }\n-        eventLoop.schedule(connectionClient::doReconnect, 1, TimeUnit.SECONDS);\n+        connectionClient.scheduleReconnect(1, TimeUnit.SECONDS);\n     }\n     @Override",
    "output": "Fix mistaken deletion of reconnect interval"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java\n@@ -283,7 +283,7 @@ public void add(double x, int w) {\n     private void add(double x, int w, List<Double> history) {\n         if (Double.isNaN(x)) {\n-            throw new IllegalArgumentException(\"Cannot add NaN to t-digest\");\n+            return;\n         }\n         int where;",
    "output": "Fix nan problem * fix provider get baggage error * fix BytesEncoder Cast Exception * add zipkin-sender-urlconnection default * format code * fix nan problem ---------"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java\n@@ -82,16 +82,15 @@ private void resetInvokerToNoException() {\n     // TODO assert error log\n     @Test\n-    void testInvokeExceptoin() {\n+    void testInvokeException() {\n         resetInvokerToException();\n         FailsafeClusterInvoker<DemoService> invoker = new FailsafeClusterInvoker<DemoService>(dic);\n         invoker.invoke(invocation);\n         Assertions.assertNull(RpcContext.getServiceContext().getInvoker());\n     }\n     @Test\n-    void testInvokeNoExceptoin() {\n-\n+    void testInvokeNoException() {\n         resetInvokerToNoException();\n         FailsafeClusterInvoker<DemoService> invoker = new FailsafeClusterInvoker<DemoService>(dic);",
    "output": "Fix typos in test method names of FailSafeClusterInvokerTest"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotationUtils.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotationUtils.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotationUtils.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotationUtils.java\n@@ -631,22 +631,30 @@ public static Annotation tryGetMergedAnnotation(\n         if (ClassUtils.isPresent(ANNOTATED_ELEMENT_UTILS_CLASS_NAME, classLoader)) {\n             Class<?> annotatedElementUtilsClass = resolveClassName(ANNOTATED_ELEMENT_UTILS_CLASS_NAME, classLoader);\n-            // getMergedAnnotation method appears in the Spring Framework 4.2\n-            Method getMergedAnnotationMethod = findMethod(\n-                    annotatedElementUtilsClass,\n-                    \"getMergedAnnotation\",\n-                    AnnotatedElement.class,\n-                    Class.class,\n-                    boolean.class,\n-                    boolean.class);\n+            // getMergedAnnotation method appears in the Spring Framework 5.x\n+            Method getMergedAnnotationMethod =\n+                    findMethod(annotatedElementUtilsClass, \"getMergedAnnotation\", AnnotatedElement.class, Class.class);\n             if (getMergedAnnotationMethod != null) {\n-                mergedAnnotation = (Annotation) invokeMethod(\n-                        getMergedAnnotationMethod,\n-                        null,\n-                        annotatedElement,\n-                        annotationType,\n-                        classValuesAsString,\n-                        nestedAnnotationsAsMap);\n+                mergedAnnotation =\n+                        (Annotation) invokeMethod(getMergedAnnotationMethod, null, annotatedElement, annotationType);\n+            } else {\n+                // getMergedAnnotation method appears in the Spring Framework 4.2\n+                getMergedAnnotationMethod = findMethod(\n+                        annotatedElementUtilsClass,\n+                        \"getMergedAnnotation\",\n+                        AnnotatedElement.class,\n+                        Class.class,\n+                        boolean.class,\n+                        boolean.class);\n+                if (getMergedAnnotationMethod != null) {\n+                    mergedAnnotation = (Annotation) invokeMethod(\n+                            getMergedAnnotationMethod,\n+                            null,\n+                            annotatedElement,\n+                            annotationType,\n+                            classValuesAsString,\n+                            nestedAnnotationsAsMap);\n+                }\n             }\n         }",
    "output": "Fix the issue where MergedAnnotation is null when retrieved in Spring 5.x Added compatibility support for Spring 5.x in the method org.apache.dubbo.config.spring.util.AnnotationUtils#tryGetMergedAnnotation to ensure that MergedAnnotations can be correctly retrieved in Spring 5.x environments"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListenerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListenerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListenerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListenerTest.java\n@@ -88,7 +88,7 @@ class MeshAppRuleListenerTest {\n             + \"      name: testing\\n\"\n             + \"  trafficPolicy:\\n\"\n             + \"    loadBalancer: { simple: ROUND_ROBIN }\\n\";\n-    private static final String rule4 = \"apiVersionservice.dubbo.apache.org/v1alpha1\\n\";\n+    private static final String rule4 = \"apiVersion: service.dubbo.apache.org/v1alpha1\\n\";\n     private static final String rule5 = \"apiVersion: service.dubbo.apache.org/v1alpha1\\n\" + \"kind: DestinationRule\\n\"\n             + \"metadata: { name: demo-route.Type1 }\\n\"\n             + \"spec:\\n\"",
    "output": "Fix MeshAppRuleListenerTest"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n@@ -160,7 +160,7 @@ private static Object generalize(Object pojo, Map<Object, Object> history) {\n         }\n         if (pojo instanceof LocalDate || pojo instanceof LocalDateTime || pojo instanceof LocalTime) {\n-            return pojo.toString();\n+            return pojo;\n         }\n         if (pojo instanceof Class) {\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n@@ -772,15 +772,15 @@ void testJava8Time() {\n         Object localDateTimeGen = PojoUtils.generalize(LocalDateTime.now());\n         Object localDateTime = PojoUtils.realize(localDateTimeGen, LocalDateTime.class);\n-        assertEquals(localDateTimeGen, localDateTime.toString());\n+        assertEquals(localDateTimeGen, localDateTime);\n         Object localDateGen = PojoUtils.generalize(LocalDate.now());\n         Object localDate = PojoUtils.realize(localDateGen, LocalDate.class);\n-        assertEquals(localDateGen, localDate.toString());\n+        assertEquals(localDateGen, localDate);\n         Object localTimeGen = PojoUtils.generalize(LocalTime.now());\n         Object localTime = PojoUtils.realize(localTimeGen, LocalTime.class);\n-        assertEquals(localTimeGen, localTime.toString());\n+        assertEquals(localTimeGen, localTime);\n     }\n     @Test",
    "output": "Fix the issue of type loss in generalized call cases"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/test/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtilsTest.java b/dubbo-registry/dubbo-registry-nacos/src/test/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtilsTest.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/test/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtilsTest.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/test/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtilsTest.java\n@@ -57,7 +57,7 @@ void testToInstance() {\n     @Test\n     void testToServiceInstance() {\n-        URL registryUrl = URL.valueOf(\"test://test:8080/test\");\n+        URL registryUrl = URL.valueOf(\"nacos://127.0.0.1:8080/test\");\n         Instance instance = new Instance();\n         instance.setServiceName(\"serviceName\");\n         instance.setIp(\"1.1.1.1\");\n@@ -78,7 +78,7 @@ void testToServiceInstance() {\n     @Test\n     void testCreateNamingService() {\n-        URL url = URL.valueOf(\"test://test:8080/test?backup=backup&nacos.check=false\");\n+        URL url = URL.valueOf(\"nacos://127.0.0.1:8080/test?backup=127.0.0.1&nacos.check=false\");\n         NacosNamingServiceWrapper namingService = NacosNamingServiceUtils.createNamingService(url);\n         Assertions.assertNotNull(namingService);\n     }",
    "output": "Fix NacosNamingServiceUtilsTest UnknownHostException"
  },
  {
    "input": "diff --git a/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/DubboProtocCompilerMojo.java b/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/DubboProtocCompilerMojo.java\n--- a/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/DubboProtocCompilerMojo.java\n+++ b/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/DubboProtocCompilerMojo.java\n@@ -173,9 +173,8 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n                     \"protoc did not exit cleanly. Review output for more information.\");\n             } else if (StringUtils.isNotBlank(getError())) {\n                 getLog().warn(\"PROTOC: \" + getError());\n-            } else {\n-                linkProtoFilesToMaven();\n             }\n+            linkProtoFilesToMaven();\n         } catch (CommandLineException e) {\n             throw new MojoExecutionException(e);\n         }",
    "output": "Fix the source directory was not attached when the protoc error message was not empty * Fix the source directory was not attached when the protoc error message was not empty ---------"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java\n@@ -851,7 +851,7 @@ public CompletableFuture<List<User>> getUsersAsync() {\n         }\n         public void sayHello() {\n-            System.out.println(\"hello prety\");\n+            System.out.println(\"hello pretty\");\n         }\n     }\n@@ -902,7 +902,7 @@ public Boolean getBoolean2() {\n         }\n         public void sayHello() {\n-            System.out.println(\"hello prety\");\n+            System.out.println(\"hello pretty\");\n         }\n     }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/status/reporter/FrameworkStatusReportServiceTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/status/reporter/FrameworkStatusReportServiceTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/status/reporter/FrameworkStatusReportServiceTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/status/reporter/FrameworkStatusReportServiceTest.java\n@@ -67,13 +67,13 @@ void test() {\n                 consumerURL.getGroup(),\n                 \"FORCE_INTERFACE\",\n                 \"FORCE_APPLICATION\",\n-                \"ture\"));\n+                \"true\"));\n         MockFrameworkStatusReporter statusReporter =\n                 (MockFrameworkStatusReporter) applicationModel.getExtension(FrameworkStatusReporter.class, \"mock\");\n         // \"migrationStepStatus\" ->\n-        // \"{\"originStep\":\"FORCE_INTERFACE\",\"application\":\"APP\",\"service\":\"Test\",\"success\":\"ture\",\"newStep\":\"FORCE_APPLICATION\",\"type\":\"migrationStepStatus\",\"version\":\"0.0.0\",\"group\":\"Group\"}\"\n+        // \"{\"originStep\":\"FORCE_INTERFACE\",\"application\":\"APP\",\"service\":\"Test\",\"success\":\"true\",\"newStep\":\"FORCE_APPLICATION\",\"type\":\"migrationStepStatus\",\"version\":\"0.0.0\",\"group\":\"Group\"}\"\n         // \"registration\" -> \"{\"application\":\"APP\",\"status\":\"instance\"}\"\n         // \"consumption\" ->\n         // \"{\"application\":\"APP\",\"service\":\"Test\",\"type\":\"consumption\",\"version\":\"0.0.0\",\"group\":\"Group\",\"status\":\"status\"}\"\n@@ -104,7 +104,7 @@ void test() {\n         Assertions.assertEquals(migrationStepStatusMap.get(\"originStep\"), \"FORCE_INTERFACE\");\n         Assertions.assertEquals(migrationStepStatusMap.get(\"application\"), \"APP\");\n         Assertions.assertEquals(migrationStepStatusMap.get(\"service\"), \"Test\");\n-        Assertions.assertEquals(migrationStepStatusMap.get(\"success\"), \"ture\");\n+        Assertions.assertEquals(migrationStepStatusMap.get(\"success\"), \"true\");\n         Assertions.assertEquals(migrationStepStatusMap.get(\"newStep\"), \"FORCE_APPLICATION\");\n         Assertions.assertEquals(migrationStepStatusMap.get(\"type\"), \"migrationStepStatus\");\n         Assertions.assertEquals(migrationStepStatusMap.get(\"version\"), \"0.0.0\");",
    "output": "Fix typos"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java\n@@ -53,13 +53,13 @@ public class ConsistentHashLoadBalance extends AbstractLoadBalance {\n     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n         String methodName = RpcUtils.getMethodName(invocation);\n         String key = invokers.get(0).getUrl().getServiceKey() + \".\" + methodName;\n-        // using the hashcode of list to compute the hash only pay attention to the elements in the list\n         int invokersHashCode = invokers.hashCode();\n-        ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);\n-        if (selector == null || selector.identityHashCode != invokersHashCode) {\n-            selectors.put(key, new ConsistentHashSelector<T>(invokers, methodName, invokersHashCode));\n-            selector = (ConsistentHashSelector<T>) selectors.get(key);\n-        }\n+        // using the hashcode of invoker list to create consistent selector by atomic computation.\n+        ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.compute(\n+                key,\n+                (k, oldSelector) -> (oldSelector == null || oldSelector.identityHashCode != invokersHashCode)\n+                        ? new ConsistentHashSelector<>(invokers, methodName, invokersHashCode)\n+                        : oldSelector);\n         return selector.select(invocation);\n     }",
    "output": "Fix the issue of high CPU load caused by continuously creating new ConsistentHashSelector instances under high concurrency"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-spring-security/src/test/java/org/apache/dubbo/spring/security/jackson/ObjectMapperCodecTest.java b/dubbo-plugin/dubbo-spring-security/src/test/java/org/apache/dubbo/spring/security/jackson/ObjectMapperCodecTest.java\n--- a/dubbo-plugin/dubbo-spring-security/src/test/java/org/apache/dubbo/spring/security/jackson/ObjectMapperCodecTest.java\n+++ b/dubbo-plugin/dubbo-spring-security/src/test/java/org/apache/dubbo/spring/security/jackson/ObjectMapperCodecTest.java\n@@ -18,30 +18,18 @@\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Collections;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.condition.EnabledForJreRange;\n-import org.junit.jupiter.api.condition.JRE;\n-import org.springframework.security.core.authority.SimpleGrantedAuthority;\n import org.springframework.security.oauth2.client.OAuth2AuthorizedClient;\n import org.springframework.security.oauth2.client.registration.ClientRegistration;\n import org.springframework.security.oauth2.core.AuthorizationGrantType;\n import org.springframework.security.oauth2.core.ClientAuthenticationMethod;\n-import org.springframework.security.oauth2.core.DefaultOAuth2AuthenticatedPrincipal;\n import org.springframework.security.oauth2.core.OAuth2AccessToken;\n-import org.springframework.security.oauth2.core.OAuth2AccessToken.TokenType;\n-import org.springframework.security.oauth2.server.authorization.authentication.OAuth2ClientAuthenticationToken;\n-import org.springframework.security.oauth2.server.authorization.client.RegisteredClient;\n-import org.springframework.security.oauth2.server.authorization.settings.ClientSettings;\n-import org.springframework.security.oauth2.server.authorization.settings.OAuth2TokenFormat;\n-import org.springframework.security.oauth2.server.authorization.settings.TokenSettings;\n-import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthentication;\n public class ObjectMapperCodecTest {\n-    private final ObjectMapperCodec mapper = new ObjectMapperCodec();\n+    private ObjectMapperCodec mapper = new ObjectMapperCodec();\n     @Test\n     public void testOAuth2AuthorizedClientCodec() {\n@@ -56,66 +44,6 @@ public void testOAuth2AuthorizedClientCodec() {\n         Assertions.assertNotNull(deserialize);\n     }\n-    @EnabledForJreRange(min = JRE.JAVA_17)\n-    @Test\n-    public void bearerTokenAuthenticationTest() {\n-        BearerTokenAuthentication bearerTokenAuthentication = new BearerTokenAuthentication(\n-                new DefaultOAuth2AuthenticatedPrincipal(\n-                        \"principal-name\",\n-                        Collections.singletonMap(\"name\", \"kali\"),\n-                        Collections.singleton(new SimpleGrantedAuthority(\"1\"))),\n-                new OAuth2AccessToken(TokenType.BEARER, \"111\", Instant.MIN, Instant.MAX),\n-                Collections.emptyList());\n-        String content = mapper.serialize(bearerTokenAuthentication);\n-\n-        BearerTokenAuthentication deserialize = mapper.deserialize(content.getBytes(), BearerTokenAuthentication.class);\n-\n-        Assertions.assertNotNull(deserialize);\n-    }\n-\n-    @EnabledForJreRange(min = JRE.JAVA_17)\n-    @Test\n-    public void oAuth2ClientAuthenticationTokenTest() {\n-        OAuth2ClientAuthenticationToken oAuth2ClientAuthenticationToken = new OAuth2ClientAuthenticationToken(\n-                \"client-id\", ClientAuthenticationMethod.CLIENT_SECRET_POST, \"111\", Collections.emptyMap());\n-\n-        String content = mapper.serialize(oAuth2ClientAuthenticationToken);\n-\n-        OAuth2ClientAuthenticationToken deserialize =\n-                mapper.deserialize(content.getBytes(), OAuth2ClientAuthenticationToken.class);\n-\n-        Assertions.assertNotNull(deserialize);\n-    }\n-\n-    @EnabledForJreRange(min = JRE.JAVA_17)\n-    @Test\n-    public void registeredClientTest() {\n-        RegisteredClient registeredClient = RegisteredClient.withId(\"id\")\n-                .clientId(\"client-id\")\n-                .clientName(\"client-name\")\n-                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n-                .redirectUri(\"https://example.com\")\n-                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_JWT)\n-                .clientSecret(\"client-secret\")\n-                .clientIdIssuedAt(Instant.MIN)\n-                .clientSecretExpiresAt(Instant.MAX)\n-                .tokenSettings(TokenSettings.builder()\n-                        .accessTokenFormat(OAuth2TokenFormat.REFERENCE)\n-                        .accessTokenTimeToLive(Duration.ofSeconds(1000))\n-                        .build())\n-                .clientSettings(ClientSettings.builder()\n-                        .setting(\"name\", \"value\")\n-                        .requireProofKey(true)\n-                        .build())\n-                .build();\n-\n-        String content = mapper.serialize(registeredClient);\n-\n-        RegisteredClient deserialize = mapper.deserialize(content.getBytes(), RegisteredClient.class);\n-\n-        Assertions.assertNotNull(deserialize);\n-    }\n-\n     public static ClientRegistration.Builder clientRegistration() {\n         // @formatter:off\n         return ClientRegistration.withRegistrationId(\"registration-id\")",
    "output": "Remove oauth test cases which could not been compiled with jdk8 or jdk11"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-spring-security/src/test/java/org/apache/dubbo/spring/security/jackson/ObjectMapperCodecTest.java b/dubbo-plugin/dubbo-spring-security/src/test/java/org/apache/dubbo/spring/security/jackson/ObjectMapperCodecTest.java\n--- a/dubbo-plugin/dubbo-spring-security/src/test/java/org/apache/dubbo/spring/security/jackson/ObjectMapperCodecTest.java\n+++ b/dubbo-plugin/dubbo-spring-security/src/test/java/org/apache/dubbo/spring/security/jackson/ObjectMapperCodecTest.java\n@@ -22,6 +22,8 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledForJreRange;\n+import org.junit.jupiter.api.condition.JRE;\n import org.springframework.security.core.authority.SimpleGrantedAuthority;\n import org.springframework.security.oauth2.client.OAuth2AuthorizedClient;\n import org.springframework.security.oauth2.client.registration.ClientRegistration;\n@@ -39,7 +41,7 @@\n public class ObjectMapperCodecTest {\n-    private ObjectMapperCodec mapper = new ObjectMapperCodec();\n+    private final ObjectMapperCodec mapper = new ObjectMapperCodec();\n     @Test\n     public void testOAuth2AuthorizedClientCodec() {\n@@ -54,6 +56,7 @@ public void testOAuth2AuthorizedClientCodec() {\n         Assertions.assertNotNull(deserialize);\n     }\n+    @EnabledForJreRange(min = JRE.JAVA_17)\n     @Test\n     public void bearerTokenAuthenticationTest() {\n         BearerTokenAuthentication bearerTokenAuthentication = new BearerTokenAuthentication(\n@@ -70,6 +73,7 @@ public void bearerTokenAuthenticationTest() {\n         Assertions.assertNotNull(deserialize);\n     }\n+    @EnabledForJreRange(min = JRE.JAVA_17)\n     @Test\n     public void oAuth2ClientAuthenticationTokenTest() {\n         OAuth2ClientAuthenticationToken oAuth2ClientAuthenticationToken = new OAuth2ClientAuthenticationToken(\n@@ -83,6 +87,7 @@ public void oAuth2ClientAuthenticationTokenTest() {\n         Assertions.assertNotNull(deserialize);\n     }\n+    @EnabledForJreRange(min = JRE.JAVA_17)\n     @Test\n     public void registeredClientTest() {\n         RegisteredClient registeredClient = RegisteredClient.withId(\"id\")",
    "output": "Add jre range annotation to oauth2 test cases which need jdk17+"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n@@ -221,7 +221,7 @@ public static InetSocketAddress getLocalSocketAddress(String host, int port) {\n     }\n     static boolean isValidV4Address(InetAddress address) {\n-        if (address == null || address.isLoopbackAddress()) {\n+        if (address == null || address.isLoopbackAddress() || address.isLinkLocalAddress()) {\n             return false;\n         }",
    "output": "Fix NetUtils: should ignore link-local address"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n@@ -244,9 +244,7 @@ public static boolean isOneway(URL url, Invocation inv) {\n     private static Method getMethodByService(Invocation invocation, String service) throws NoSuchMethodException {\n         Class<?> invokerInterface = invocation.getInvoker().getInterface();\n-        Class<?> cls = invokerInterface != null\n-                ? ReflectUtils.forName(invokerInterface.getClassLoader(), service)\n-                : ReflectUtils.forName(service);\n+        Class<?> cls = invokerInterface != null ? invokerInterface : ReflectUtils.forName(service);\n         Method method = cls.getMethod(invocation.getMethodName(), invocation.getParameterTypes());\n         if (method.getReturnType() == void.class) {\n             return null;",
    "output": "Fix RpcUtils by getting method from invokerInterface if it is not null"
  },
  {
    "input": "diff --git a/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/DubboProtocCompilerMojo.java b/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/DubboProtocCompilerMojo.java\n--- a/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/DubboProtocCompilerMojo.java\n+++ b/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/DubboProtocCompilerMojo.java\n@@ -125,8 +125,7 @@ public class DubboProtocCompilerMojo extends AbstractMojo {\n     public void execute() throws MojoExecutionException, MojoFailureException {\n         Properties versionMatrix = new Properties();\n         ClassLoader loader = Thread.currentThread().getContextClassLoader();\n-        InputStream stream = loader.getResourceAsStream(\"version-matrix.properties\");\n-        try {\n+        try (InputStream stream = loader.getResourceAsStream(\"version-matrix.properties\")) {\n             versionMatrix.load(stream);\n         } catch (IOException e) {\n             getLog().warn(\"Unable to load default version matrix\", e);\ndiff --git a/dubbo-plugin/dubbo-native/src/main/java/org/apache/dubbo/aot/generate/JarScanner.java b/dubbo-plugin/dubbo-native/src/main/java/org/apache/dubbo/aot/generate/JarScanner.java\n--- a/dubbo-plugin/dubbo-native/src/main/java/org/apache/dubbo/aot/generate/JarScanner.java\n+++ b/dubbo-plugin/dubbo-native/src/main/java/org/apache/dubbo/aot/generate/JarScanner.java\n@@ -77,8 +77,9 @@ private void scanURL(String prefixName) {\n                 if (\"file\".equals(protocol)) {\n                     scanFile(resource.getPath());\n                 } else if (\"jar\".equals(protocol)) {\n-                    JarFile jar = ((JarURLConnection) resource.openConnection()).getJarFile();\n-                    scanJar(jar);\n+                    try (JarFile jar = ((JarURLConnection) resource.openConnection()).getJarFile()) {\n+                        scanJar(jar);\n+                    }\n                 }\n             }\n         } catch (Throwable ex) {\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/codec/ExchangeCodec.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/codec/ExchangeCodec.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/codec/ExchangeCodec.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/codec/ExchangeCodec.java\n@@ -327,38 +327,39 @@ protected void encodeResponse(Channel channel, ChannelBuffer buffer, Response re\n             Bytes.long2bytes(res.getId(), header, 4);\n             buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);\n-            ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);\n+            int len;\n+            try (ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer)) {\n-            // encode response data or error message.\n-            if (status == Response.OK) {\n-                if (res.isHeartbeat()) {\n-                    // heartbeat response data is always null\n-                    bos.write(CodecSupport.getNullBytesOf(serialization));\n-                } else {\n-                    ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n-                    if (res.isEvent()) {\n-                        encodeEventData(channel, out, res.getResult());\n+                // encode response data or error message.\n+                if (status == Response.OK) {\n+                    if (res.isHeartbeat()) {\n+                        // heartbeat response data is always null\n+                        bos.write(CodecSupport.getNullBytesOf(serialization));\n                     } else {\n-                        encodeResponseData(channel, out, res.getResult(), res.getVersion());\n+                        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n+                        if (res.isEvent()) {\n+                            encodeEventData(channel, out, res.getResult());\n+                        } else {\n+                            encodeResponseData(channel, out, res.getResult(), res.getVersion());\n+                        }\n+                        out.flushBuffer();\n+                        if (out instanceof Cleanable) {\n+                            ((Cleanable) out).cleanup();\n+                        }\n                     }\n+                } else {\n+                    ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n+                    out.writeUTF(res.getErrorMessage());\n                     out.flushBuffer();\n                     if (out instanceof Cleanable) {\n                         ((Cleanable) out).cleanup();\n                     }\n                 }\n-            } else {\n-                ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n-                out.writeUTF(res.getErrorMessage());\n-                out.flushBuffer();\n-                if (out instanceof Cleanable) {\n-                    ((Cleanable) out).cleanup();\n-                }\n-            }\n-            bos.flush();\n-            bos.close();\n+                bos.flush();\n+                len = bos.writtenBytes();\n+            }\n-            int len = bos.writtenBytes();\n             checkPayload(channel, len);\n             Bytes.int2bytes(len, header, 12);\n             // write\ndiff --git a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/initializer/ConfigZookeeperInitializer.java b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/initializer/ConfigZookeeperInitializer.java\n--- a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/initializer/ConfigZookeeperInitializer.java\n+++ b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/initializer/ConfigZookeeperInitializer.java\n@@ -25,6 +25,7 @@\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n@@ -55,7 +56,9 @@ private void updateConfig(ZookeeperContext context, int clientPort, int adminSer\n         Properties properties = new Properties();\n         try {\n             // use Files.newInputStream instead of new FileInputStream\n-            properties.load(Files.newInputStream(zooSample.toPath()));\n+            try (InputStream is = Files.newInputStream(zooSample.toPath())) {\n+                properties.load(is);\n+            }\n             properties.setProperty(\"clientPort\", String.valueOf(clientPort));\n             properties.setProperty(\"admin.serverPort\", String.valueOf(availableAdminServerPort));\n             Path dataDir = Paths.get(zookeeperConf.getParent().toString(), \"data\");\n@@ -93,7 +96,9 @@ private void updateConfig(ZookeeperContext context, int clientPort, int adminSer\n         File log4j = Paths.get(zookeeperConf.toString(), \"log4j.properties\").toFile();\n         try {\n             // use Files.newInputStream instead of new FileInputStream\n-            properties.load(Files.newInputStream(log4j.toPath()));\n+            try (InputStream is = Files.newInputStream(log4j.toPath())) {\n+                properties.load(is);\n+            }\n             Path logDir = Paths.get(zookeeperConf.getParent().toString(), \"logs\");\n             if (!Files.exists(logDir)) {\n                 try {",
    "output": "Fix some potential resource leaks"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java\n@@ -188,6 +188,9 @@ protected void customizeHeaders(HttpHeaders headers, Throwable throwable, HttpOu\n     }\n     protected final void sendMetadata(HttpMetadata metadata) {\n+        if (headerSent) {\n+            return;\n+        }\n         getHttpChannel().writeHeader(metadata);\n         headerSent = true;\n         if (LOGGER.isDebugEnabled()) {\n@@ -327,6 +330,10 @@ protected String getContentType() {\n         return responseEncoder.contentType();\n     }\n+    protected boolean isHeaderSent() {\n+        return headerSent;\n+    }\n+\n     protected void customizeTrailers(HttpHeaders headers, Throwable throwable) {\n         List<BiConsumer<HttpHeaders, Throwable>> trailersCustomizers = this.trailersCustomizers;\n         if (trailersCustomizers != null) {\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/Http1SseServerChannelObserver.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/Http1SseServerChannelObserver.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/Http1SseServerChannelObserver.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/Http1SseServerChannelObserver.java\n@@ -35,6 +35,14 @@ public void setResponseEncoder(HttpMessageEncoder responseEncoder) {\n         super.setResponseEncoder(new ServerSentEventEncoder(responseEncoder));\n     }\n+    @Override\n+    protected void doOnCompleted(Throwable throwable) {\n+        if (!isHeaderSent()) {\n+            sendMetadata(encodeHttpMetadata(true));\n+        }\n+        super.doOnCompleted(throwable);\n+    }\n+\n     @Override\n     protected HttpMetadata encodeHttpMetadata(boolean endStream) {\n         return super.encodeHttpMetadata(endStream)\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/Http2SseServerChannelObserver.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/Http2SseServerChannelObserver.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/Http2SseServerChannelObserver.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/Http2SseServerChannelObserver.java\n@@ -40,4 +40,13 @@ protected HttpMetadata encodeHttpMetadata(boolean endStream) {\n         return super.encodeHttpMetadata(endStream)\n                 .header(HttpHeaderNames.CACHE_CONTROL.getKey(), HttpConstants.NO_CACHE);\n     }\n+\n+    @Override\n+    protected void doOnCompleted(Throwable throwable) {\n+        // if throwable is not null, the header will be flushed by super.doOnCompleted(throwable)\n+        if (!isHeaderSent() && throwable == null) {\n+            sendMetadata(encodeHttpMetadata(true));\n+        }\n+        super.doOnCompleted(throwable);\n+    }\n }",
    "output": "Fix StreamObserver object calls onCompleted() without first calling onNext() will fail"
  },
  {
    "input": "diff --git a/dubbo-demo/dubbo-demo-spring-boot-idl/dubbo-demo-spring-boot-idl-provider/src/main/java/org/apache/dubbo/springboot/idl/demo/provider/GreeterServiceImpl.java b/dubbo-demo/dubbo-demo-spring-boot-idl/dubbo-demo-spring-boot-idl-provider/src/main/java/org/apache/dubbo/springboot/idl/demo/provider/GreeterServiceImpl.java\n--- a/dubbo-demo/dubbo-demo-spring-boot-idl/dubbo-demo-spring-boot-idl-provider/src/main/java/org/apache/dubbo/springboot/idl/demo/provider/GreeterServiceImpl.java\n+++ b/dubbo-demo/dubbo-demo-spring-boot-idl/dubbo-demo-spring-boot-idl-provider/src/main/java/org/apache/dubbo/springboot/idl/demo/provider/GreeterServiceImpl.java\n@@ -16,12 +16,14 @@\n  */\n package org.apache.dubbo.springboot.idl.demo.provider;\n+import org.apache.dubbo.common.stream.StreamObserver;\n import org.apache.dubbo.config.annotation.DubboService;\n import org.apache.dubbo.demo.hello.GreeterService;\n import org.apache.dubbo.demo.hello.HelloReply;\n import org.apache.dubbo.demo.hello.HelloRequest;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -45,6 +47,22 @@ public CompletableFuture<HelloReply> sayHelloAsync(HelloRequest request) {\n                 HelloReply.newBuilder().setMessage(\"Hello \" + request.getName()).build());\n     }\n+    @Override\n+    public void sayHelloStream(HelloRequest request, StreamObserver<HelloReply> responseObserver) {\n+        LOGGER.info(\"Received sayHelloStream request: {}\", request.getName());\n+        for (int i = 0; i < 5; i++) {\n+            try {\n+                TimeUnit.SECONDS.sleep(1);\n+            } catch (InterruptedException e) {\n+                responseObserver.onError(e);\n+            }\n+            responseObserver.onNext(HelloReply.newBuilder()\n+                    .setMessage(i + \"# Hello \" + request.getName())\n+                    .build());\n+        }\n+        responseObserver.onCompleted();\n+    }\n+\n     private static HelloReply toReply(String message) {\n         return HelloReply.newBuilder().setMessage(message).build();\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.FluentLogger;\n+import org.apache.dubbo.common.stream.StreamObserver;\n import org.apache.dubbo.common.utils.ClassUtils;\n import org.apache.dubbo.config.context.ConfigManager;\n import org.apache.dubbo.config.nested.RestConfig;\n@@ -31,6 +32,7 @@\n import org.apache.dubbo.rpc.model.ReflectionMethodDescriptor;\n import org.apache.dubbo.rpc.model.ReflectionServiceDescriptor;\n import org.apache.dubbo.rpc.model.ServiceDescriptor;\n+import org.apache.dubbo.rpc.model.StubServiceDescriptor;\n import org.apache.dubbo.rpc.protocol.tri.DescriptorUtils;\n import org.apache.dubbo.rpc.protocol.tri.TripleProtocol;\n import org.apache.dubbo.rpc.protocol.tri.rest.Messages;\n@@ -48,6 +50,7 @@\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.IdentityHashMap;\n import java.util.LinkedList;\n@@ -129,7 +132,14 @@ public void register(Invoker<?> invoker) {\n                 RequestMapping classMapping = resolver.resolve(serviceMeta);\n                 consumer.accept((methods) -> {\n                     Method method = methods.get(0);\n-                    MethodDescriptor md = sd.getMethod(method.getName(), method.getParameterTypes());\n+                    Class<?>[] paramTypes = method.getParameterTypes();\n+                    MethodDescriptor md = sd.getMethod(method.getName(), paramTypes);\n+                    if (md == null && sd instanceof StubServiceDescriptor) {\n+                        int len = paramTypes.length;\n+                        if (len > 0 && StreamObserver.class.isAssignableFrom(paramTypes[len - 1])) {\n+                            md = sd.getMethod(method.getName(), Arrays.copyOf(paramTypes, len - 1));\n+                        }\n+                    }\n                     MethodMeta methodMeta = new MethodMeta(methods, md, serviceMeta);\n                     if (!resolver.accept(methodMeta)) {\n                         return;",
    "output": "Fix ignore params type of StreamObserver * fix: ignore params type of StreamObserver * code format * rm test file * code format * fix: add the match logic of proto service with params type of StreamObserver * fix: support server stream only * fix: support server stream only * code format"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java\n@@ -169,7 +169,7 @@ private void register0(RequestMapping mapping, HandlerMeta handler, AtomicIntege\n         try {\n             Registration registration = new Registration(mapping, handler);\n             for (PathExpression path : mapping.getPathCondition().getExpressions()) {\n-                Registration exists = tree.addPath(path, registration);\n+                Registration exists = tree.addPath(path, registration, Registration::isMappingOverlap);\n                 if (exists == null) {\n                     counter.incrementAndGet();\n                     if (LOGGER.isDebugEnabled()) {\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RadixTree.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RadixTree.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RadixTree.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RadixTree.java\n@@ -31,7 +31,9 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Objects;\n import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n import java.util.function.Predicate;\n /**\n@@ -63,13 +65,25 @@ public RadixTree() {\n         this(true, '/');\n     }\n+    /**\n+     * This is a default implementation that does not check for equality.\n+     */\n     public T addPath(PathExpression path, T value) {\n+        return addPath(path, value, (t, t2) -> Boolean.TRUE);\n+    }\n+\n+    /**\n+     * When the path is the same, the predicate is used to determine whether the values are considered equal.\n+     * If the predicate returns true, the existing value is returned directly.\n+     */\n+    public T addPath(PathExpression path, T value, BiFunction<T, T, Boolean> predicate) {\n+        Objects.requireNonNull(predicate);\n         if (path.isDirect()) {\n             KeyString key = new KeyString(path.getPath(), caseSensitive);\n             List<Match<T>> matches = directPathMap.computeIfAbsent(key, k -> new ArrayList<>());\n             for (int i = 0, size = matches.size(); i < size; i++) {\n                 Match<T> match = matches.get(i);\n-                if (match.getValue().equals(value)) {\n+                if (predicate.apply(match.getValue(), value)) {\n                     return match.getValue();\n                 }\n             }\n@@ -85,7 +99,9 @@ public T addPath(PathExpression path, T value) {\n                 List<Pair<PathExpression, T>> values = child.values;\n                 for (int j = 0, size = values.size(); j < size; j++) {\n                     if (values.get(j).getLeft().equals(path)) {\n-                        return values.get(j).getRight();\n+                        if (predicate.apply(values.get(j).getRight(), value)) {\n+                            return values.get(j).getRight();\n+                        }\n                     }\n                 }\n                 values.add(Pair.of(path, value));\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/Registration.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/Registration.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/Registration.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/Registration.java\n@@ -18,6 +18,9 @@\n import org.apache.dubbo.rpc.protocol.tri.rest.mapping.meta.HandlerMeta;\n+import java.util.Collections;\n+import java.util.Objects;\n+\n public final class Registration {\n     private final RequestMapping mapping;\n@@ -47,6 +50,24 @@ public boolean equals(Object obj) {\n         return mapping.equals(((Registration) obj).mapping);\n     }\n+    public boolean isMappingOverlap(Registration other) {\n+        RequestMapping otherMapping = other.getMapping();\n+        if (mapping == otherMapping) {\n+            return true;\n+        }\n+        return (mapping.getMethodsCondition() == null\n+                        || otherMapping.getMethodsCondition() == null\n+                        || !Collections.disjoint(\n+                                mapping.getMethodsCondition().getMethods(),\n+                                otherMapping.getMethodsCondition().getMethods()))\n+                && Objects.equals(mapping.getParamsCondition(), otherMapping.getParamsCondition())\n+                && Objects.equals(mapping.getHeadersCondition(), otherMapping.getHeadersCondition())\n+                && Objects.equals(mapping.getConsumesCondition(), otherMapping.getConsumesCondition())\n+                && Objects.equals(mapping.getProducesCondition(), otherMapping.getProducesCondition())\n+                && Objects.equals(mapping.getCustomCondition(), otherMapping.getCustomCondition())\n+                && Objects.equals(mapping.getSig(), otherMapping.getSig());\n+    }\n+\n     @Override\n     public int hashCode() {\n         return mapping.hashCode();\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RequestMapping.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RequestMapping.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RequestMapping.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RequestMapping.java\n@@ -236,6 +236,10 @@ public ProducesCondition getProducesCondition() {\n         return producesCondition;\n     }\n+    public ConditionWrapper getCustomCondition() {\n+        return customCondition;\n+    }\n+\n     public CorsMeta getCors() {\n         return cors;\n     }",
    "output": "Fix diff method can not be added to RadixTree"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -718,9 +718,13 @@ public RegistryConfig getRegistry() {\n     }\n     public void setRegistry(RegistryConfig registry) {\n-        List<RegistryConfig> registries = new ArrayList<>(1);\n-        registries.add(registry);\n-        setRegistries(registries);\n+        if (registry != null) {\n+            List<RegistryConfig> registries = new ArrayList<>(1);\n+            registries.add(registry);\n+            setRegistries(registries);\n+        } else {\n+            this.registries = null;\n+        }\n     }\n     public List<RegistryConfig> getRegistries() {",
    "output": "Fix AbstractInterfaceConfig#setRegistry to avoid NPE at post-processing"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/handler/DubboClientTracingObservationHandler.java b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/handler/DubboClientTracingObservationHandler.java\n--- a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/handler/DubboClientTracingObservationHandler.java\n+++ b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/handler/DubboClientTracingObservationHandler.java\n@@ -20,7 +20,6 @@\n import io.micrometer.observation.Observation;\n import io.micrometer.observation.ObservationHandler;\n-import io.micrometer.observation.transport.SenderContext;\n import io.micrometer.tracing.Tracer;\n public class DubboClientTracingObservationHandler<T extends DubboClientContext> implements ObservationHandler<T> {\n@@ -35,6 +34,6 @@ public void onScopeOpened(T context) {}\n     @Override\n     public boolean supportsContext(Observation.Context context) {\n-        return context instanceof SenderContext;\n+        return context instanceof DubboClientContext;\n     }\n }\ndiff --git a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/handler/DubboServerTracingObservationHandler.java b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/handler/DubboServerTracingObservationHandler.java\n--- a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/handler/DubboServerTracingObservationHandler.java\n+++ b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/handler/DubboServerTracingObservationHandler.java\n@@ -21,7 +21,6 @@\n import io.micrometer.observation.Observation;\n import io.micrometer.observation.ObservationHandler;\n-import io.micrometer.observation.transport.ReceiverContext;\n import io.micrometer.tracing.TraceContext;\n import io.micrometer.tracing.Tracer;\n@@ -46,6 +45,6 @@ public void onScopeOpened(T context) {\n     @Override\n     public boolean supportsContext(Observation.Context context) {\n-        return context instanceof ReceiverContext;\n+        return context instanceof DubboServerContext;\n     }\n }",
    "output": "Fix ClassCastException caused by overly broad type check in Dubbo tracing integration with Spring WebFlux."
  },
  {
    "input": "diff --git a/dubbo-spring-boot-project/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/observability/zipkin/ZipkinAutoConfiguration.java b/dubbo-spring-boot-project/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/observability/zipkin/ZipkinAutoConfiguration.java\n--- a/dubbo-spring-boot-project/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/observability/zipkin/ZipkinAutoConfiguration.java\n+++ b/dubbo-spring-boot-project/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/observability/zipkin/ZipkinAutoConfiguration.java\n@@ -67,4 +67,11 @@ public class ZipkinAutoConfiguration {\n     public BytesEncoder<Span> spanBytesEncoder() {\n         return SpanBytesEncoder.JSON_V2;\n     }\n+\n+    @Bean\n+    @ConditionalOnProperty(prefix = DUBBO_TRACING_ZIPKIN_CONFIG_PREFIX, name = \"endpoint\")\n+    @ConditionalOnMissingBean\n+    public zipkin2.reporter.BytesEncoder<Span> reporterBytesEncoder() {\n+        return zipkin2.reporter.SpanBytesEncoder.JSON_V2;\n+    }\n }\ndiff --git a/dubbo-spring-boot-project/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/observability/zipkin/ZipkinConfigurations.java b/dubbo-spring-boot-project/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/observability/zipkin/ZipkinConfigurations.java\n--- a/dubbo-spring-boot-project/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/observability/zipkin/ZipkinConfigurations.java\n+++ b/dubbo-spring-boot-project/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/observability/zipkin/ZipkinConfigurations.java\n@@ -133,8 +133,8 @@ static class ReporterConfiguration {\n         @Bean\n         @ConditionalOnMissingBean\n         @ConditionalOnBean(Sender.class)\n-        AsyncReporter<Span> spanReporter(Sender sender, BytesEncoder<Span> encoder) {\n-            return AsyncReporter.builder(sender).build((zipkin2.reporter.BytesEncoder<Span>) encoder);\n+        AsyncReporter<Span> spanReporter(Sender sender, zipkin2.reporter.BytesEncoder<Span> encoder) {\n+            return AsyncReporter.builder(sender).build(encoder);\n         }\n     }",
    "output": "Fix/bytes encoder cast exception * fix provider get baggage error * fix BytesEncoder Cast Exception * add zipkin-sender-urlconnection default * format code ---------"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -340,6 +340,17 @@ private void refreshInvoker(List<URL> invokerUrls) {\n                 return;\n             }\n+            int originSize = invokerUrls.size();\n+            invokerUrls = invokerUrls.stream().distinct().collect(Collectors.toList());\n+            if (invokerUrls.size() != originSize) {\n+                logger.info(\"Received duplicated invoker urls changed event from registry. \"\n+                        + \"Registry type: instance. \"\n+                        + \"Service Key: \"\n+                        + getConsumerUrl().getServiceKey() + \". \"\n+                        + \"Notify Urls Size : \" + originSize + \". \"\n+                        + \"Distinct Urls Size: \" + invokerUrls.size() + \".\");\n+            }\n+\n             // use local reference to avoid NPE as this.urlInvokerMap will be set null concurrently at\n             // destroyAllInvokers().\n             Map<ProtocolServiceKeyWithAddress, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap;\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -305,6 +305,17 @@ private void refreshInvoker(List<URL> invokerUrls) {\n                 return;\n             }\n+            int originSize = invokerUrls.size();\n+            invokerUrls = invokerUrls.stream().distinct().collect(Collectors.toList());\n+            if (invokerUrls.size() != originSize) {\n+                logger.info(\"Received duplicated invoker urls changed event from registry. \"\n+                        + \"Registry type: interface. \"\n+                        + \"Service Key: \"\n+                        + getConsumerUrl().getServiceKey() + \". \"\n+                        + \"Notify Urls Size : \" + originSize + \". \"\n+                        + \"Distinct Urls Size: \" + invokerUrls.size() + \".\");\n+            }\n+\n             // use local reference to avoid NPE as this.urlInvokerMap will be set null concurrently at\n             // destroyAllInvokers().\n             Map<URL, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap;",
    "output": "Remove duplicated invokers in registry notification"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java\n@@ -1242,14 +1242,20 @@ public static byte decodeHexByte(CharSequence s, int pos) {\n     }\n     /**\n-     * Create the common-delimited {@link String} by one or more {@link String} members\n+     * Creates a comma-delimited string from one or more string values.\n      *\n-     * @param one    one {@link String}\n-     * @param others others {@link String}\n-     * @return <code>null</code> if <code>one</code> or <code>others</code> is <code>null</code>\n+     * @param one    the first string value\n+     * @param others additional string values\n+     * @return the combined string, or null if the first value is null\n      * @since 2.7.8\n      */\n     public static String toCommaDelimitedString(String one, String... others) {\n+        if (one == null) {\n+            return null;\n+        }\n+        if (others == null) {\n+            return one;\n+        }\n         String another = arrayToDelimitedString(others, COMMA_SEPARATOR);\n         return isEmpty(another) ? one : one + COMMA_SEPARATOR + another;\n     }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/StringUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/StringUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/StringUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/StringUtilsTest.java\n@@ -474,6 +474,7 @@ private void assertEqualsWithoutSpaces(String expect, String actual) {\n     /**\n      * Test {@link StringUtils#toCommaDelimitedString(String, String...)}\n+     *\n      * @since 2.7.8\n      */\n     @Test\n@@ -484,6 +485,9 @@ void testToCommaDelimitedString() {\n         value = toCommaDelimitedString(null, null);\n         assertNull(value);\n+        value = toCommaDelimitedString(\"one\", null);\n+        assertEquals(\"one\", value);\n+\n         value = toCommaDelimitedString(\"\");\n         assertEquals(\"\", value);",
    "output": "Fix toCommaDelimitedString returns \"null,null\" when inputs are null * fix: return 'one' if others is null in toCommaDelimitedString * fix:"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanManager.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanManager.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanManager.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanManager.java\n@@ -26,7 +26,6 @@\n import org.apache.dubbo.config.spring.util.DubboBeanUtils;\n import org.apache.dubbo.rpc.model.ModuleModel;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashSet;\n@@ -35,6 +34,7 @@\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import org.springframework.beans.BeansException;\n import org.springframework.context.ApplicationContext;\n@@ -47,7 +47,7 @@ public class ReferenceBeanManager implements ApplicationContextAware {\n     private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(getClass());\n     // reference key -> reference bean names\n-    private ConcurrentMap<String, List<String>> referenceKeyMap = new ConcurrentHashMap<>();\n+    private ConcurrentMap<String, CopyOnWriteArrayList<String>> referenceKeyMap = new ConcurrentHashMap<>();\n     // reference alias -> reference bean name\n     private ConcurrentMap<String, String> referenceAliasMap = new ConcurrentHashMap<>();\n@@ -102,8 +102,8 @@ public void addReference(ReferenceBean referenceBean) throws Exception {\n     }\n     private String getReferenceKeyByBeanName(String referenceBeanName) {\n-        Set<Map.Entry<String, List<String>>> entries = referenceKeyMap.entrySet();\n-        for (Map.Entry<String, List<String>> entry : entries) {\n+        Set<Map.Entry<String, CopyOnWriteArrayList<String>>> entries = referenceKeyMap.entrySet();\n+        for (Map.Entry<String, CopyOnWriteArrayList<String>> entry : entries) {\n             if (entry.getValue().contains(referenceBeanName)) {\n                 return entry.getKey();\n             }\n@@ -112,10 +112,9 @@ private String getReferenceKeyByBeanName(String referenceBeanName) {\n     }\n     public void registerReferenceKeyAndBeanName(String referenceKey, String referenceBeanNameOrAlias) {\n-        List<String> list =\n-                ConcurrentHashMapUtils.computeIfAbsent(referenceKeyMap, referenceKey, (key) -> new ArrayList<>());\n-        if (!list.contains(referenceBeanNameOrAlias)) {\n-            list.add(referenceBeanNameOrAlias);\n+        CopyOnWriteArrayList<String> list = ConcurrentHashMapUtils.computeIfAbsent(\n+                referenceKeyMap, referenceKey, (key) -> new CopyOnWriteArrayList<>());\n+        if (list.addIfAbsent(referenceBeanNameOrAlias)) {\n             // register bean name as alias\n             referenceAliasMap.put(referenceBeanNameOrAlias, list.get(0));\n         }\n@@ -132,7 +131,7 @@ private String transformName(String referenceBeanNameOrAlias) {\n     }\n     public List<String> getBeanNamesByKey(String key) {\n-        return Collections.unmodifiableList(referenceKeyMap.getOrDefault(key, Collections.EMPTY_LIST));\n+        return Collections.unmodifiableList(referenceKeyMap.getOrDefault(key, new CopyOnWriteArrayList<>()));\n     }\n     public Collection<ReferenceBean> getReferences() {",
    "output": "Change referenceKeyMap entry value type to CopyOnWriteArrayList"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-fastjson2/src/test/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2SerializationTest.java b/dubbo-serialization/dubbo-serialization-fastjson2/src/test/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2SerializationTest.java\n--- a/dubbo-serialization/dubbo-serialization-fastjson2/src/test/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2SerializationTest.java\n+++ b/dubbo-serialization/dubbo-serialization-fastjson2/src/test/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2SerializationTest.java\n@@ -27,7 +27,7 @@\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n-import java.util.Date;\n+import java.time.LocalDate;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -227,7 +227,8 @@ void testReadByte() throws IOException {\n         {\n             ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n             ObjectOutput objectOutput = serialization.serialize(url, outputStream);\n-            objectOutput.writeObject(new Date());\n+            // fastjson2 could not read byte from the serialization of LocalDate by now. 2025/04/02\n+            objectOutput.writeObject(LocalDate.now());\n             objectOutput.flushBuffer();\n             byte[] bytes = outputStream.toByteArray();",
    "output": "Change FastJson2SerializationTest#testReadByte date variable type to LocalDate"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-event/src/main/java/org/apache/dubbo/metrics/event/MetricsEventBus.java b/dubbo-metrics/dubbo-metrics-event/src/main/java/org/apache/dubbo/metrics/event/MetricsEventBus.java\n--- a/dubbo-metrics/dubbo-metrics-event/src/main/java/org/apache/dubbo/metrics/event/MetricsEventBus.java\n+++ b/dubbo-metrics/dubbo-metrics-event/src/main/java/org/apache/dubbo/metrics/event/MetricsEventBus.java\n@@ -38,7 +38,7 @@ public class MetricsEventBus {\n      * @param event event to post.\n      */\n     public static void publish(MetricsEvent event) {\n-        if (event.getSource() == null) {\n+        if (event == null || event.getSource() == null) {\n             return;\n         }\n         MetricsEventMulticaster dispatcher = event.getMetricsEventMulticaster();\n@@ -92,6 +92,9 @@ public static <T> T post(MetricsEvent event, Supplier<T> targetSupplier, Functio\n     }\n     public static void tryInvoke(Runnable runnable) {\n+        if (runnable == null) {\n+            return;\n+        }\n         try {\n             runnable.run();\n         } catch (Throwable e) {\n@@ -115,14 +118,20 @@ public static void after(MetricsEvent event, Object result) {\n         if (dispatcher == null) return;\n         tryInvoke(() -> {\n             event.customAfterPost(result);\n-            dispatcher.publishFinishEvent((TimeCounterEvent) event);\n+            if (event instanceof TimeCounterEvent) {\n+                dispatcher.publishFinishEvent((TimeCounterEvent) event);\n+            }\n         });\n     }\n     public static void error(MetricsEvent event) {\n         MetricsEventMulticaster dispatcher = validate(event);\n         if (dispatcher == null) return;\n-        tryInvoke(() -> dispatcher.publishErrorEvent((TimeCounterEvent) event));\n+        tryInvoke(() -> {\n+            if (event instanceof TimeCounterEvent) {\n+                dispatcher.publishErrorEvent((TimeCounterEvent) event);\n+            }\n+        });\n     }\n     private static MetricsEventMulticaster validate(MetricsEvent event) {",
    "output": "Fix some bugs"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java b/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java\n@@ -800,8 +800,9 @@ private T createExtension(String name, boolean wrap) {\n                                                 || ArrayUtils.contains(wrapper.matches(), name))\n                                         && !ArrayUtils.contains(wrapper.mismatches(), name));\n                         if (match) {\n-                            instance = injectExtension(\n-                                    (T) wrapperClass.getConstructor(type).newInstance(instance));\n+                            instance = (T) wrapperClass.getConstructor(type).newInstance(instance);\n+                            instance = postProcessBeforeInitialization(instance, name);\n+                            injectExtension(instance);\n                             instance = postProcessAfterInitialization(instance, name);\n                         }\n                     }",
    "output": "Fix initialization problem when generateing wrapper object"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/aot/MetadataProxyDescriberRegistrar.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/aot/MetadataProxyDescriberRegistrar.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/aot/MetadataProxyDescriberRegistrar.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/aot/MetadataProxyDescriberRegistrar.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.aot.api.JdkProxyDescriber;\n import org.apache.dubbo.aot.api.ProxyDescriberRegistrar;\n import org.apache.dubbo.metadata.MetadataService;\n+import org.apache.dubbo.metadata.MetadataServiceV2;\n import org.apache.dubbo.rpc.service.Destroyable;\n import org.apache.dubbo.rpc.service.EchoService;\n@@ -30,6 +31,7 @@ public class MetadataProxyDescriberRegistrar implements ProxyDescriberRegistrar\n     public List<JdkProxyDescriber> getJdkProxyDescribers() {\n         List<JdkProxyDescriber> describers = new ArrayList<>();\n         describers.add(buildJdkProxyDescriber(MetadataService.class));\n+        describers.add(buildJdkProxyDescriber(MetadataServiceV2.class));\n         return describers;\n     }\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/aot/MetadataReflectionTypeDescriberRegistrar.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/aot/MetadataReflectionTypeDescriberRegistrar.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/aot/MetadataReflectionTypeDescriberRegistrar.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/aot/MetadataReflectionTypeDescriberRegistrar.java\n@@ -20,7 +20,9 @@\n import org.apache.dubbo.aot.api.ReflectionTypeDescriberRegistrar;\n import org.apache.dubbo.aot.api.TypeDescriber;\n import org.apache.dubbo.metadata.MetadataInfo;\n+import org.apache.dubbo.metadata.MetadataInfoV2;\n import org.apache.dubbo.metadata.MetadataService;\n+import org.apache.dubbo.metadata.MetadataServiceV2;\n import java.util.ArrayList;\n import java.util.HashSet;\n@@ -33,7 +35,9 @@ public class MetadataReflectionTypeDescriberRegistrar implements ReflectionTypeD\n     public List<TypeDescriber> getTypeDescribers() {\n         List<TypeDescriber> typeDescribers = new ArrayList<>();\n         typeDescribers.add(buildTypeDescriberWithPublicMethod(MetadataService.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(MetadataServiceV2.class));\n         typeDescribers.add(buildTypeDescriberWithDeclaredConstructors(MetadataInfo.class));\n+        typeDescribers.add(buildTypeDescriberWithDeclaredConstructors(MetadataInfoV2.class));\n         return typeDescribers;\n     }\ndiff --git a/dubbo-plugin/dubbo-rest-spring/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/spring/RestSpringScopeModelInitializer.java b/dubbo-plugin/dubbo-rest-spring/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/spring/RestSpringScopeModelInitializer.java\n--- a/dubbo-plugin/dubbo-rest-spring/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/spring/RestSpringScopeModelInitializer.java\n+++ b/dubbo-plugin/dubbo-rest-spring/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/spring/RestSpringScopeModelInitializer.java\n@@ -0,0 +1,34 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.tri.rest.support.spring;\n+\n+import org.apache.dubbo.common.beans.factory.ScopeBeanFactory;\n+import org.apache.dubbo.common.utils.DefaultParameterNameReader;\n+import org.apache.dubbo.rpc.model.FrameworkModel;\n+import org.apache.dubbo.rpc.model.ScopeModelInitializer;\n+import org.apache.dubbo.rpc.protocol.tri.rest.argument.CompositeArgumentResolver;\n+import org.apache.dubbo.rpc.protocol.tri.rest.argument.GeneralTypeConverter;\n+\n+public class RestSpringScopeModelInitializer implements ScopeModelInitializer {\n+    @Override\n+    public void initializeFrameworkModel(FrameworkModel frameworkModel) {\n+        ScopeBeanFactory beanFactory = frameworkModel.getBeanFactory();\n+        beanFactory.registerBean(GeneralTypeConverter.class);\n+        beanFactory.registerBean(DefaultParameterNameReader.class);\n+        beanFactory.registerBean(CompositeArgumentResolver.class);\n+    }\n+}\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryScopeModelInitializer.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryScopeModelInitializer.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryScopeModelInitializer.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryScopeModelInitializer.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.beans.factory.ScopeBeanFactory;\n import org.apache.dubbo.registry.client.metadata.MetadataServiceDelegation;\n+import org.apache.dubbo.registry.client.metadata.MetadataServiceDelegationV2;\n import org.apache.dubbo.registry.integration.ExporterFactory;\n import org.apache.dubbo.registry.support.RegistryManager;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n@@ -37,5 +38,6 @@ public void initializeApplicationModel(ApplicationModel applicationModel) {\n         ScopeBeanFactory beanFactory = applicationModel.getBeanFactory();\n         beanFactory.registerBean(RegistryManager.class);\n         beanFactory.registerBean(MetadataServiceDelegation.class);\n+        beanFactory.registerBean(MetadataServiceDelegationV2.class);\n     }\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n@@ -176,7 +176,7 @@ public static RemoteMetadataService referMetadataService(ServiceInstance instanc\n         RemoteMetadataService remoteMetadataService;\n         ProxyFactory proxyFactory =\n                 applicationModel.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n-        if (useV2) {\n+        if (useV2 && !inNativeImage) {\n             Invoker<MetadataServiceV2> invoker = protocol.refer(MetadataServiceV2.class, url);\n             if (url.getParameter(AUTH_KEY, false)) {",
    "output": "Fix triple protocol for native image * Fix triple protocol for native image"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java\n@@ -20,9 +20,9 @@\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n import java.util.List;\n import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.CountDownLatch;\n import javassist.ClassPool;\n@@ -238,7 +238,7 @@ public void test_getClassPool() throws InterruptedException {\n         int threadCount = 5;\n         CountDownLatch LATCH = new CountDownLatch(threadCount);\n         ClassLoader loader = Thread.currentThread().getContextClassLoader();\n-        List<Integer> hashCodeList = new ArrayList<>();\n+        List<Integer> hashCodeList = new CopyOnWriteArrayList<>();\n         for (int i = 0; i < threadCount; i++) {\n             new Thread(new Runnable() {\n                         @Override",
    "output": "Fix concurrent issue of ClassGeneratorTest"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/context/DubboServerContext.java b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/context/DubboServerContext.java\n--- a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/context/DubboServerContext.java\n+++ b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/context/DubboServerContext.java\n@@ -32,7 +32,7 @@ public class DubboServerContext extends ReceiverContext<Invocation> {\n     private final Invocation invocation;\n     public DubboServerContext(Invoker<?> invoker, Invocation invocation) {\n-        super((carrier, s) -> String.valueOf(carrier.getAttachment(s)), Kind.SERVER);\n+        super((carrier, s) -> carrier.getAttachment(s), Kind.SERVER);\n         this.invoker = invoker;\n         this.invocation = invocation;\n         setCarrier(invocation);",
    "output": "Fix provider get baggage error"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java b/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java\n--- a/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java\n+++ b/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java\n@@ -63,10 +63,6 @@ public class MultipleRegistry extends AbstractRegistry {\n     public MultipleRegistry(URL url) {\n         this(url, true, true);\n-        this.registryFactory = url.getOrDefaultApplicationModel()\n-                .getExtensionLoader(RegistryFactory.class)\n-                .getAdaptiveExtension();\n-\n         boolean defaultRegistry = url.getParameter(CommonConstants.DEFAULT_KEY, true);\n         if (defaultRegistry && effectServiceRegistryURLs.isEmpty() && effectReferenceRegistryURLs.isEmpty()) {\n             throw new IllegalArgumentException(\"Illegal registry url. You need to configure parameter \"",
    "output": "Fix repeat load registryFactory"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n@@ -95,8 +95,9 @@ private static void throwIfInterrupted() throws InterruptedException {\n     public void execute(Runnable runnable) {\n         RunnableWrapper run = new RunnableWrapper(runnable);\n         queue.add(run);\n-        if (waiter.get() != SHUTDOWN) {\n-            LockSupport.unpark((Thread) waiter.get());\n+        Object waiter = this.waiter.get();\n+        if (waiter != SHUTDOWN) {\n+            LockSupport.unpark((Thread) waiter);\n         } else if (queue.remove(run)) {\n             throw new RejectedExecutionException();\n         }",
    "output": "Fix concurrency problem"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java\n@@ -44,6 +44,7 @@\n import io.netty.channel.ChannelFuture;\n import io.netty.channel.ChannelFutureListener;\n import io.netty.handler.codec.EncoderException;\n+import io.netty.util.ReferenceCountUtil;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_ENCODE_IN_IO_THREAD;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_TIMEOUT;\n@@ -185,10 +186,11 @@ public void send(Object message, boolean sent) throws RemotingException {\n         boolean success = true;\n         int timeout = 0;\n+        ByteBuf buf = null;\n         try {\n             Object outputMessage = message;\n             if (!encodeInIOThread) {\n-                ByteBuf buf = channel.alloc().buffer();\n+                buf = channel.alloc().buffer();\n                 ChannelBuffer buffer = new NettyBackedChannelBuffer(buf);\n                 codec.encode(this, buffer, message);\n                 outputMessage = buf;\n@@ -224,6 +226,10 @@ public void operationComplete(ChannelFuture future) throws Exception {\n             }\n         } catch (Throwable e) {\n             removeChannelIfDisconnected(channel);\n+            if (buf != null) {\n+                // Release the ByteBuf if an exception occurs\n+                ReferenceCountUtil.safeRelease(buf);\n+            }\n             throw new RemotingException(\n                     this,\n                     \"Failed to send message \" + PayloadDropper.getRequestWithoutData(message) + \" to \"",
    "output": "Fix memory leak when OOM"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadlocal/NamedInternalThreadFactory.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadlocal/NamedInternalThreadFactory.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadlocal/NamedInternalThreadFactory.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadlocal/NamedInternalThreadFactory.java\n@@ -39,7 +39,7 @@ public NamedInternalThreadFactory(String prefix, boolean daemon) {\n     @Override\n     public Thread newThread(Runnable runnable) {\n         String name = mPrefix + mThreadNum.getAndIncrement();\n-        InternalThread ret = new InternalThread(mGroup, InternalRunnable.Wrap(runnable), name, 0);\n+        InternalThread ret = new InternalThread(InternalRunnable.Wrap(runnable), name);\n         ret.setDaemon(mDaemon);\n         return ret;\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NamedThreadFactory.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NamedThreadFactory.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NamedThreadFactory.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NamedThreadFactory.java\n@@ -32,8 +32,6 @@ public class NamedThreadFactory implements ThreadFactory {\n     protected final boolean mDaemon;\n-    protected final ThreadGroup mGroup;\n-\n     public NamedThreadFactory() {\n         this(\"pool-\" + POOL_SEQ.getAndIncrement(), false);\n     }\n@@ -45,22 +43,16 @@ public NamedThreadFactory(String prefix) {\n     public NamedThreadFactory(String prefix, boolean daemon) {\n         mPrefix = prefix + \"-thread-\";\n         mDaemon = daemon;\n-        SecurityManager s = System.getSecurityManager();\n-        mGroup = (s == null) ? Thread.currentThread().getThreadGroup() : s.getThreadGroup();\n     }\n     @Override\n     public Thread newThread(Runnable runnable) {\n         String name = mPrefix + mThreadNum.getAndIncrement();\n-        Thread ret = new Thread(mGroup, runnable, name, 0);\n+        Thread ret = new Thread(runnable, name);\n         ret.setDaemon(mDaemon);\n         return ret;\n     }\n-    public ThreadGroup getThreadGroup() {\n-        return mGroup;\n-    }\n-\n     // for test\n     public AtomicInteger getThreadNum() {\n         return mThreadNum;\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/NamedThreadFactoryTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/NamedThreadFactoryTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/NamedThreadFactoryTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/NamedThreadFactoryTest.java\n@@ -59,11 +59,4 @@ public void testGetThreadNum() {\n         assertNotNull(threadNum);\n         assertEquals(INITIAL_THREAD_NUM, threadNum.get());\n     }\n-\n-    @Test\n-    public void testGetThreadGroup() {\n-        NamedThreadFactory threadFactory = new NamedThreadFactory();\n-        ThreadGroup threadGroup = threadFactory.getThreadGroup();\n-        assertNotNull(threadGroup);\n-    }\n }",
    "output": "Remove mGroup from NamedThreadFactory"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n@@ -81,6 +81,22 @@ public static List<HttpCookie> decodeCookies(String value) {\n         return cookies;\n     }\n+    public static String getCharsetFromContentType(String contentType) {\n+        String charset = null;\n+        if (contentType == null) {\n+            charset = StringUtils.EMPTY_STRING;\n+        } else {\n+            int index = contentType.lastIndexOf(CHARSET_PREFIX);\n+            if (index == -1) {\n+                charset = StringUtils.EMPTY_STRING;\n+            } else {\n+                charset = contentType.substring(index + CHARSET_PREFIX.length()).trim();\n+                charset = charset.split(\";\")[0];\n+            }\n+        }\n+        return charset;\n+    }\n+\n     public static String encodeCookie(HttpCookie cookie) {\n         DefaultCookie c = new DefaultCookie(cookie.name(), cookie.value());\n         c.setPath(cookie.path());\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/DefaultHttpRequest.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/DefaultHttpRequest.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/DefaultHttpRequest.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/DefaultHttpRequest.java\n@@ -243,14 +243,7 @@ public String charset() {\n         String charset = this.charset;\n         if (charset == null) {\n             String contentType = contentType();\n-            if (contentType == null) {\n-                charset = StringUtils.EMPTY_STRING;\n-            } else {\n-                int index = contentType.lastIndexOf(HttpUtils.CHARSET_PREFIX);\n-                charset = index == -1\n-                        ? StringUtils.EMPTY_STRING\n-                        : contentType.substring(index + 8).trim();\n-            }\n+            charset = HttpUtils.getCharsetFromContentType(contentType);\n             this.charset = charset;\n         }\n         return charset.isEmpty() ? null : charset;\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/DefaultHttpResponse.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/DefaultHttpResponse.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/DefaultHttpResponse.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/DefaultHttpResponse.java\n@@ -166,14 +166,7 @@ public String charset() {\n         String charset = this.charset;\n         if (charset == null) {\n             String contentType = contentType();\n-            if (contentType == null) {\n-                charset = StringUtils.EMPTY_STRING;\n-            } else {\n-                int index = contentType.lastIndexOf(HttpUtils.CHARSET_PREFIX);\n-                charset = index == -1\n-                        ? StringUtils.EMPTY_STRING\n-                        : contentType.substring(index + 8).trim();\n-            }\n+            charset = HttpUtils.getCharsetFromContentType(contentType);\n             this.charset = charset;\n         }\n         return charset.isEmpty() ? null : charset;\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/test/java/org/apache/dubbo/remoting/http12/message/codec/HttpUtilsTest.java b/dubbo-remoting/dubbo-remoting-http12/src/test/java/org/apache/dubbo/remoting/http12/message/codec/HttpUtilsTest.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/test/java/org/apache/dubbo/remoting/http12/message/codec/HttpUtilsTest.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/test/java/org/apache/dubbo/remoting/http12/message/codec/HttpUtilsTest.java\n@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.remoting.http12.message.codec;\n+\n+import org.apache.dubbo.remoting.http12.HttpUtils;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+public class HttpUtilsTest {\n+\n+    @Test\n+    void testGetCharsetFromContentType() {\n+        String charset = HttpUtils.getCharsetFromContentType(\"text/html;charset=utf-8\");\n+        Assertions.assertEquals(\"utf-8\", charset);\n+        charset = HttpUtils.getCharsetFromContentType(\"text/html\");\n+        Assertions.assertEquals(\"\", charset);\n+        charset = HttpUtils.getCharsetFromContentType(\"application/json;charset=utf-8; boundary=__X_PAW_BOUNDARY__\");\n+        Assertions.assertEquals(\"utf-8\", charset);\n+        charset =\n+                HttpUtils.getCharsetFromContentType(\"multipart/form-data; charset=utf-8; boundary=__X_PAW_BOUNDARY__\");\n+        Assertions.assertEquals(\"utf-8\", charset);\n+    }\n+}",
    "output": "Fix the issue where the charset from Content-Type is not parsed correctly, and refactor the related code"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/aot/GenericProxyDescriberRegistrar.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/aot/GenericProxyDescriberRegistrar.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/aot/GenericProxyDescriberRegistrar.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/aot/GenericProxyDescriberRegistrar.java\n@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.aot;\n+\n+import org.apache.dubbo.aot.api.JdkProxyDescriber;\n+import org.apache.dubbo.aot.api.ProxyDescriberRegistrar;\n+import org.apache.dubbo.rpc.service.Destroyable;\n+import org.apache.dubbo.rpc.service.EchoService;\n+import org.apache.dubbo.rpc.service.GenericService;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class GenericProxyDescriberRegistrar implements ProxyDescriberRegistrar {\n+\n+    @Override\n+    public List<JdkProxyDescriber> getJdkProxyDescribers() {\n+        List<JdkProxyDescriber> describers = new ArrayList<>();\n+        List<String> proxiedInterfaces = new ArrayList<>();\n+        proxiedInterfaces.add(GenericService.class.getName());\n+        proxiedInterfaces.add(EchoService.class.getName());\n+        proxiedInterfaces.add(Destroyable.class.getName());\n+        describers.add(new JdkProxyDescriber(proxiedInterfaces, null));\n+        return describers;\n+    }\n+}",
    "output": "Fix native support generic service * Fix native support generic service * remove support com.alibaba.dubbo"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n@@ -20,11 +20,14 @@\n import org.apache.dubbo.common.URLStrParser;\n import org.apache.dubbo.common.constants.RemotingConstants;\n import org.apache.dubbo.common.url.component.ServiceConfigURL;\n+import org.apache.dubbo.rpc.model.ServiceMetadata;\n+import org.apache.dubbo.rpc.model.ServiceModel;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.Set;\n import java.util.function.Function;\n import java.util.function.Predicate;\n@@ -690,7 +693,10 @@ public static boolean isConsumer(URL url) {\n     @SuppressWarnings(\"unchecked\")\n     public static <T> T computeServiceAttribute(URL url, String key, Function<URL, T> fn) {\n-        return (T)\n-                url.getServiceModel().getServiceMetadata().getAttributeMap().computeIfAbsent(key, k -> fn.apply(url));\n+        return Optional.ofNullable(url.getServiceModel())\n+                .map(ServiceModel::getServiceMetadata)\n+                .map(ServiceMetadata::getAttributeMap)\n+                .map(stringObjectMap -> (T) stringObjectMap.computeIfAbsent(key, k -> fn.apply(url)))\n+                .orElse(null);\n     }\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n@@ -279,6 +279,9 @@ protected final RpcInvocation buildRpcInvocation(RpcInvocationBuildContext conte\n         // customizer RpcInvocation\n         HeaderFilter[] headerFilters =\n                 UrlUtils.computeServiceAttribute(invoker.getUrl(), HEADER_FILTERS_CACHE, this::loadHeaderFilters);\n+        if (headerFilters == null) {\n+            headerFilters = this.loadHeaderFilters(invoker.getUrl());\n+        }\n         for (HeaderFilter headerFilter : headerFilters) {\n             headerFilter.invoke(invoker, inv);\n         }",
    "output": "Fix gRPC-related URL object caused a NullPointerException (NPE) * FIX gRPC-related URL object caused a NullPointerException (NPE) * Simplify the code"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n@@ -30,6 +30,9 @@\n import java.util.function.Function;\n import java.util.stream.Collectors;\n+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SEPARATOR;\n+import static org.apache.dubbo.common.constants.CommonConstants.EXT_PROTOCOL;\n+\n public abstract class AbstractPortUnificationServer extends AbstractServer {\n     /**\n@@ -60,11 +63,18 @@ public Map<String, WireProtocol> getProtocols() {\n     @Override\n     protected final void doOpen() {\n-        ExtensionLoader<WireProtocol> extensionLoader =\n+        ExtensionLoader<WireProtocol> loader =\n                 getUrl().getOrDefaultFrameworkModel().getExtensionLoader(WireProtocol.class);\n-        this.protocols = extensionLoader.getActivateExtension(getUrl(), new String[0]).stream()\n-                .collect(Collectors.toConcurrentMap(extensionLoader::getExtensionName, Function.identity()));\n-\n+        Map<String, WireProtocol> protocols = loader.getActivateExtension(getUrl(), new String[0]).stream()\n+                .collect(Collectors.toConcurrentMap(loader::getExtensionName, Function.identity()));\n+        // load extra protocols\n+        String extraProtocols = getUrl().getParameter(EXT_PROTOCOL);\n+        if (StringUtils.isNotEmpty(extraProtocols)) {\n+            Arrays.stream(extraProtocols.split(COMMA_SEPARATOR)).forEach(p -> {\n+                protocols.put(p, loader.getExtension(p));\n+            });\n+        }\n+        this.protocols = protocols;\n         doOpen0();\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/AbstractTripleClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/AbstractTripleClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/AbstractTripleClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/AbstractTripleClientStream.java\n@@ -19,6 +19,8 @@\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.remoting.Constants;\n+import org.apache.dubbo.remoting.http12.HttpHeaderNames;\n import org.apache.dubbo.rpc.TriRpcStatus;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\n@@ -57,7 +59,7 @@\n import io.netty.handler.codec.http2.Http2Error;\n import io.netty.handler.codec.http2.Http2Headers;\n import io.netty.handler.codec.http2.Http2StreamChannel;\n-import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\n+import io.netty.util.AttributeKey;\n import io.netty.util.ReferenceCountUtil;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\ndiff --git a/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2ScopeModelInitializer.java b/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2ScopeModelInitializer.java\n--- a/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2ScopeModelInitializer.java\n+++ b/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2ScopeModelInitializer.java\n@@ -18,7 +18,6 @@\n import org.apache.dubbo.common.beans.factory.ScopeBeanFactory;\n import org.apache.dubbo.common.utils.ClassUtils;\n-import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ScopeModelInitializer;",
    "output": "Fix merge conflicts"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -144,12 +144,17 @@ protected Result doInvoke(final Invocation invocation) {\n         ServiceDescriptor serviceDescriptor = consumerModel.getServiceModel();\n         MethodDescriptor methodDescriptor =\n                 serviceDescriptor.getMethod(invocation.getMethodName(), invocation.getParameterTypes());\n-        if (methodDescriptor == null\n-                && RpcUtils.isGenericCall(\n-                        ((RpcInvocation) invocation).getParameterTypesDesc(), invocation.getMethodName())) {\n-            // Only reach when server generic\n-            methodDescriptor = ServiceDescriptorInternalCache.genericService()\n-                    .getMethod(invocation.getMethodName(), invocation.getParameterTypes());\n+        if (methodDescriptor == null) {\n+            if (RpcUtils.isGenericCall(\n+                    ((RpcInvocation) invocation).getParameterTypesDesc(), invocation.getMethodName())) {\n+                // Only reach when server generic\n+                methodDescriptor = ServiceDescriptorInternalCache.genericService()\n+                        .getMethod(invocation.getMethodName(), invocation.getParameterTypes());\n+            } else if (RpcUtils.isEcho(\n+                    ((RpcInvocation) invocation).getParameterTypesDesc(), invocation.getMethodName())) {\n+                methodDescriptor = ServiceDescriptorInternalCache.echoService()\n+                        .getMethod(invocation.getMethodName(), invocation.getParameterTypes());\n+            }\n         }\n         ExecutorService callbackExecutor =\n                 isSync(methodDescriptor, invocation) ? new ThreadlessExecutor() : streamExecutor;\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocolTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocolTest.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.rpc.protocol.tri;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.stream.StreamObserver;\n import org.apache.dubbo.common.utils.ClassUtils;\n import org.apache.dubbo.common.utils.NetUtils;\n@@ -33,13 +34,15 @@\n import org.apache.dubbo.rpc.protocol.tri.support.IGreeter;\n import org.apache.dubbo.rpc.protocol.tri.support.IGreeterImpl;\n import org.apache.dubbo.rpc.protocol.tri.support.MockStreamObserver;\n+import org.apache.dubbo.rpc.service.EchoService;\n import java.util.concurrent.TimeUnit;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import static org.apache.dubbo.rpc.protocol.tri.support.IGreeter.SERVER_MSG;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n class TripleProtocolTest {\n@@ -65,7 +68,8 @@ void testDemoProtocol() throws Exception {\n         serviceRepository.registerProvider(providerModel);\n         providerUrl = providerUrl.setServiceModel(providerModel);\n-        Protocol protocol = new TripleProtocol(providerUrl.getOrDefaultFrameworkModel());\n+        Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(\"tri\");\n+\n         ProxyFactory proxy =\n                 applicationModel.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n         Invoker<IGreeter> invoker = proxy.getInvoker(serviceImpl, IGreeter.class, providerUrl);\n@@ -107,6 +111,11 @@ void testDemoProtocol() throws Exception {\n         Assertions.assertEquals(REQUEST_MSG, serverOutboundMessageSubscriber.getOnNextData());\n         Assertions.assertTrue(serverOutboundMessageSubscriber.isOnCompleted());\n+        EchoService echo = proxy.getProxy(protocol.refer(EchoService.class, consumerUrl));\n+        assertEquals(echo.$echo(\"test\"), \"test\");\n+        assertEquals(echo.$echo(\"abcdefg\"), \"abcdefg\");\n+        assertEquals(echo.$echo(1234), 1234);\n+\n         export.unexport();\n         protocol.destroy();\n         // resource recycle.",
    "output": "Fix triple protocol echoService invoke."
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/DubboObservationRegistry.java b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/DubboObservationRegistry.java\n--- a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/DubboObservationRegistry.java\n+++ b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/DubboObservationRegistry.java\n@@ -20,16 +20,24 @@\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.JsonUtils;\n import org.apache.dubbo.config.TracingConfig;\n-import org.apache.dubbo.metrics.MetricsGlobalRegistry;\n import org.apache.dubbo.metrics.utils.MetricsSupportUtil;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.tracing.handler.DubboClientTracingObservationHandler;\n import org.apache.dubbo.tracing.handler.DubboServerTracingObservationHandler;\n+import org.apache.dubbo.tracing.metrics.ObservationMeter;\n import org.apache.dubbo.tracing.tracer.PropagatorProvider;\n import org.apache.dubbo.tracing.tracer.PropagatorProviderFactory;\n import org.apache.dubbo.tracing.tracer.TracerProvider;\n import org.apache.dubbo.tracing.tracer.TracerProviderFactory;\n+import io.micrometer.observation.ObservationHandler;\n+import io.micrometer.observation.ObservationRegistry;\n+import io.micrometer.tracing.Tracer;\n+import io.micrometer.tracing.handler.DefaultTracingObservationHandler;\n+import io.micrometer.tracing.handler.PropagatingReceiverTracingObservationHandler;\n+import io.micrometer.tracing.handler.PropagatingSenderTracingObservationHandler;\n+import io.micrometer.tracing.propagation.Propagator;\n+\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_NOT_FOUND_TRACER_DEPENDENCY;\n public class DubboObservationRegistry {\n@@ -48,8 +56,8 @@ public DubboObservationRegistry(ApplicationModel applicationModel, TracingConfig\n     public void initObservationRegistry() {\n         // If get ObservationRegistry.class from external(eg Spring.), use external.\n-        io.micrometer.observation.ObservationRegistry externalObservationRegistry =\n-                applicationModel.getBeanFactory().getBean(io.micrometer.observation.ObservationRegistry.class);\n+        ObservationRegistry externalObservationRegistry =\n+                applicationModel.getBeanFactory().getBean(ObservationRegistry.class);\n         if (externalObservationRegistry != null) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"ObservationRegistry.class from external is existed.\");\n@@ -71,36 +79,26 @@ public void initObservationRegistry() {\n             return;\n         }\n         // The real tracer will come from tracer implementation (OTel / Brave)\n-        io.micrometer.tracing.Tracer tracer = tracerProvider.getTracer();\n+        Tracer tracer = tracerProvider.getTracer();\n         // The real propagator will come from tracer implementation (OTel / Brave)\n         PropagatorProvider propagatorProvider = PropagatorProviderFactory.getPropagatorProvider();\n-        io.micrometer.tracing.propagation.Propagator propagator = propagatorProvider != null\n-                ? propagatorProvider.getPropagator()\n-                : io.micrometer.tracing.propagation.Propagator.NOOP;\n+        Propagator propagator = propagatorProvider != null ? propagatorProvider.getPropagator() : Propagator.NOOP;\n-        io.micrometer.observation.ObservationRegistry registry = io.micrometer.observation.ObservationRegistry.create();\n+        ObservationRegistry registry = ObservationRegistry.create();\n         registry.observationConfig()\n                 // set up a first matching handler that creates spans - it comes from Micrometer Tracing.\n                 // set up spans for sending and receiving data over the wire and a default one.\n-                .observationHandler(\n-                        new io.micrometer.observation.ObservationHandler.FirstMatchingCompositeObservationHandler(\n-                                new io.micrometer.tracing.handler.PropagatingSenderTracingObservationHandler<>(\n-                                        tracer, propagator),\n-                                new io.micrometer.tracing.handler.PropagatingReceiverTracingObservationHandler<>(\n-                                        tracer, propagator),\n-                                new io.micrometer.tracing.handler.DefaultTracingObservationHandler(tracer)))\n-                .observationHandler(\n-                        new io.micrometer.observation.ObservationHandler.FirstMatchingCompositeObservationHandler(\n-                                new DubboClientTracingObservationHandler<>(tracer),\n-                                new DubboServerTracingObservationHandler<>(tracer)));\n+                .observationHandler(new ObservationHandler.FirstMatchingCompositeObservationHandler(\n+                        new PropagatingSenderTracingObservationHandler<>(tracer, propagator),\n+                        new PropagatingReceiverTracingObservationHandler<>(tracer, propagator),\n+                        new DefaultTracingObservationHandler(tracer)))\n+                .observationHandler(new ObservationHandler.FirstMatchingCompositeObservationHandler(\n+                        new DubboClientTracingObservationHandler<>(tracer),\n+                        new DubboServerTracingObservationHandler<>(tracer)));\n         if (MetricsSupportUtil.isSupportMetrics()) {\n-            io.micrometer.core.instrument.MeterRegistry meterRegistry =\n-                    MetricsGlobalRegistry.getCompositeRegistry(applicationModel);\n-            registry.observationConfig()\n-                    .observationHandler(new io.micrometer.core.instrument.observation.DefaultMeterObservationHandler(\n-                            meterRegistry));\n+            ObservationMeter.addMeterRegistry(registry, applicationModel);\n         }\n         applicationModel.getBeanFactory().registerBean(registry);\ndiff --git a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/metrics/ObservationMeter.java b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/metrics/ObservationMeter.java\n--- a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/metrics/ObservationMeter.java\n+++ b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/metrics/ObservationMeter.java\n@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.tracing.metrics;\n+\n+import org.apache.dubbo.metrics.MetricsGlobalRegistry;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.observation.ObservationRegistry;\n+\n+public class ObservationMeter {\n+\n+    public static void addMeterRegistry(ObservationRegistry registry, ApplicationModel applicationModel) {\n+        MeterRegistry meterRegistry = MetricsGlobalRegistry.getCompositeRegistry(applicationModel);\n+        registry.observationConfig()\n+                .observationHandler(\n+                        new io.micrometer.core.instrument.observation.DefaultMeterObservationHandler(meterRegistry));\n+    }\n+}",
    "output": "Remove strong dep micrometer in tracing * remove strong dep micrometer in tracing * format code"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/context/AbstractConfigManager.java b/dubbo-common/src/main/java/org/apache/dubbo/config/context/AbstractConfigManager.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/context/AbstractConfigManager.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/context/AbstractConfigManager.java\n@@ -161,8 +161,10 @@ public final <T extends AbstractConfig> T addConfig(AbstractConfig config) {\n             config.setScopeModel(scopeModel);\n         }\n+        Class<? extends AbstractConfig> targetConfigType = getTargetConfigType(config.getClass());\n+\n         Map<String, AbstractConfig> configsMap =\n-                configsCache.computeIfAbsent(getTagName(config.getClass()), type -> new ConcurrentHashMap<>());\n+                configsCache.computeIfAbsent(getTagName(targetConfigType), type -> new ConcurrentHashMap<>());\n         // fast check duplicated equivalent config before write lock\n         if (!(config instanceof ReferenceConfigBase || config instanceof ServiceConfigBase)) {\n@@ -175,17 +177,21 @@ public final <T extends AbstractConfig> T addConfig(AbstractConfig config) {\n         // lock by config type\n         synchronized (configsMap) {\n-            return (T) addIfAbsent(config, configsMap);\n+            return (T) addIfAbsent(config, configsMap, targetConfigType);\n         }\n     }\n     protected boolean isSupportConfigType(Class<? extends AbstractConfig> type) {\n+        return getTargetConfigType(type) != null;\n+    }\n+\n+    protected Class<? extends AbstractConfig> getTargetConfigType(Class<? extends AbstractConfig> type) {\n         for (Class<? extends AbstractConfig> supportedConfigType : supportedConfigTypes) {\n             if (supportedConfigType.isAssignableFrom(type)) {\n-                return true;\n+                return supportedConfigType;\n             }\n         }\n-        return false;\n+        return null;\n     }\n     /**\n@@ -196,7 +202,9 @@ protected boolean isSupportConfigType(Class<? extends AbstractConfig> type) {\n      * @return the existing equivalent config or the new adding config\n      * @throws IllegalStateException\n      */\n-    private <C extends AbstractConfig> C addIfAbsent(C config, Map<String, C> configsMap) throws IllegalStateException {\n+    private <C extends AbstractConfig> C addIfAbsent(\n+            C config, Map<String, C> configsMap, Class<? extends AbstractConfig> targetConfigType)\n+            throws IllegalStateException {\n         if (config == null || configsMap == null) {\n             return config;\n@@ -218,7 +226,7 @@ private <C extends AbstractConfig> C addIfAbsent(C config, Map<String, C> config\n         C existedConfig = configsMap.get(key);\n         if (existedConfig != null && !isEquals(existedConfig, config)) {\n-            String type = config.getClass().getSimpleName();\n+            String type = targetConfigType.getSimpleName();\n             logger.warn(\n                     COMMON_UNEXPECTED_EXCEPTION,\n                     \"\",\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java b/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n@@ -251,6 +251,21 @@ void testAddConfig() {\n         assertFalse(moduleConfigManager.getProviders().isEmpty());\n     }\n+    @Test\n+    void testAddCustomConfig() {\n+        configManager.addConfig(new CustomRegistryConfig(\"CustomConfigManagerTest\"));\n+\n+        assertTrue(configManager.getRegistry(\"CustomConfigManagerTest\").isPresent());\n+    }\n+\n+    static class CustomRegistryConfig extends RegistryConfig {\n+\n+        CustomRegistryConfig(String id) {\n+            super();\n+            this.setId(id);\n+        }\n+    }\n+\n     @Test\n     void testRefreshAll() {\n         configManager.refreshAll();",
    "output": "Fix An instance of the subclass of RegistryConfig should be added to configsCache as the RegistryConfig class type"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -738,6 +738,15 @@ interface DubboProperty {\n          */\n         String DUBBO_PREFERRED_NETWORK_INTERFACE = \"dubbo.network.interface.preferred\";\n+        /**\n+         * The property name for {@link NetworkInterface#isPointToPoint() return whether a network interface is a point\n+         * to point interface} that the Dubbo application will determine whether to ignore the point-to-point network\n+         * interface\n+         *\n+         * @since 3.3\n+         */\n+        String DUBBO_NETWORK_INTERFACE_POINT_TO_POINT_IGNORED = \"dubbo.network.interface.point-to-point.ignored\";\n+\n         String DUBBO_CLASS_DESERIALIZE_ALLOWED_LIST = \"dubbo.security.serialize.allowedClassList\";\n         String DUBBO_CLASS_DESERIALIZE_BLOCKED_LIST = \"dubbo.security.serialize.blockedClassList\";\n         String DUBBO_CLASS_DESERIALIZE_OPEN_CHECK = \"dubbo.security.serialize.openCheckClass\";\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n@@ -451,6 +451,11 @@ private static boolean ignoreNetworkInterface(NetworkInterface networkInterface)\n                 || !networkInterface.isUp()) {\n             return true;\n         }\n+        if (Boolean.parseBoolean(SystemPropertyConfigUtils.getSystemProperty(\n+                        CommonConstants.DubboProperty.DUBBO_NETWORK_INTERFACE_POINT_TO_POINT_IGNORED, \"false\"))\n+                && networkInterface.isPointToPoint()) {\n+            return true;\n+        }\n         String ignoredInterfaces = SystemPropertyConfigUtils.getSystemProperty(\n                 CommonConstants.DubboProperty.DUBBO_NETWORK_IGNORED_INTERFACE);\n         String networkInterfaceDisplayName;",
    "output": "Add a configuration to determine whether to enable the point-to-point network interface * Add a configuration to determine whether to enable the point-to-point network interface Add a configuration to determine whether to enable the point-to-point network interface * Update to dubbo.network.interface.point-to-point.ignored"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/TelnetCodecTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/TelnetCodecTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/TelnetCodecTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/TelnetCodecTest.java\n@@ -247,7 +247,7 @@ void testDecode_Backspace() throws IOException {\n         testDecode_assertEquals(new byte[] {'\\b'}, Codec2.DecodeResult.NEED_MORE_INPUT, new String(new byte[] {32, 8}));\n         // test chinese\n-        byte[] chineseBytes = \"\".getBytes();\n+        byte[] chineseBytes = \"\".getBytes(StandardCharsets.UTF_8);\n         byte[] request = join(chineseBytes, new byte[] {'\\b'});\n         testDecode_assertEquals(request, Codec2.DecodeResult.NEED_MORE_INPUT, new String(new byte[] {32, 32, 8, 8}));\n         // There may be some problem handling chinese (negative number recognition). Ignoring this problem, the",
    "output": "Fix testDecode_Backspace"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/TelnetCodecTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/TelnetCodecTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/TelnetCodecTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/TelnetCodecTest.java\n@@ -29,6 +29,7 @@\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n import java.util.HashMap;\n import java.util.Map;\n@@ -75,7 +76,7 @@ protected byte[] join(byte[] in1, byte[] in2) {\n     protected byte[] objectToByte(Object obj) {\n         byte[] bytes;\n         if (obj instanceof String) {\n-            bytes = ((String) obj).getBytes();\n+            bytes = ((String) obj).getBytes(StandardCharsets.UTF_8);\n         } else if (obj instanceof byte[]) {\n             bytes = (byte[]) obj;\n         } else {",
    "output": "Fix TelnetCodecTest in Windows"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/io/UnsafeByteArrayOutputStreamTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/io/UnsafeByteArrayOutputStreamTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/io/UnsafeByteArrayOutputStreamTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/io/UnsafeByteArrayOutputStreamTest.java\n@@ -19,6 +19,7 @@\n import java.io.IOException;\n import java.io.OutputStream;\n import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n@@ -72,7 +73,7 @@ void testExtendLengthForBuffer() throws IOException {\n     @Test\n     void testToStringWithCharset() throws IOException {\n         UnsafeByteArrayOutputStream outputStream = new UnsafeByteArrayOutputStream();\n-        outputStream.write(\"Ha Bnh\".getBytes());\n+        outputStream.write(\"Ha Bnh\".getBytes(StandardCharsets.UTF_8));\n         assertThat(outputStream.toString(\"UTF-8\"), is(\"Ha Bnh\"));\n     }",
    "output": "Fix CI Upload Configuration * Fix CI Upload Configuration * Fix UnsafeByteArrayOutputStreamTest"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -137,13 +137,15 @@ public static void beforeAll() {\n     @BeforeEach\n     public void setUp() throws Exception {\n         DubboBootstrap.reset();\n+        FrameworkModel.destroyAll();\n         ApplicationModel.defaultModel().getApplicationConfigManager();\n         DubboBootstrap.getInstance();\n     }\n     @AfterEach\n     public void tearDown() throws IOException {\n         DubboBootstrap.reset();\n+        FrameworkModel.destroyAll();\n         Mockito.framework().clearInlineMocks();\n     }",
    "output": "Fix codecov no result"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/DefaultRequestMappingRegistry.java\n@@ -180,6 +180,7 @@ public void unregister(Invoker<?> invoker) {\n         if (tree == null) {\n             return;\n         }\n+\n         lock.writeLock().lock();\n         try {\n             tree.remove(mapping -> mapping.meta.getInvoker() == invoker);\n@@ -193,6 +194,7 @@ public void destroy() {\n         if (tree == null) {\n             return;\n         }\n+\n         lock.writeLock().lock();\n         try {\n             tree.clear();\n@@ -202,6 +204,10 @@ public void destroy() {\n     }\n     public HandlerMeta lookup(HttpRequest request) {\n+        if (tree == null) {\n+            return null;\n+        }\n+\n         String stringPath = PathUtils.normalize(request.uri());\n         request.setAttribute(RestConstants.PATH_ATTRIBUTE, stringPath);\n         KeyString path = new KeyString(stringPath, restConfig.getCaseSensitiveMatchOrDefault());\n@@ -365,6 +371,10 @@ private void handleNoMatch(HttpRequest request, List<RequestMapping> partialMatc\n     @Override\n     public boolean exists(String stringPath, String method) {\n+        if (tree == null) {\n+            return false;\n+        }\n+\n         KeyString path = new KeyString(stringPath, restConfig.getCaseSensitiveMatchOrDefault());\n         if (tryExists(path, method)) {\n             return true;",
    "output": "Fix DefaultRequestMappingRegistry.exists NPE when not initialized"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/DubboAppenderTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/DubboAppenderTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/DubboAppenderTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/DubboAppenderTest.java\n@@ -27,8 +27,6 @@\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.is;\n-import static org.junit.jupiter.api.Assumptions.assumeFalse;\n-import static org.junit.jupiter.api.Assumptions.assumeTrue;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n@@ -42,6 +40,9 @@ public void setUp() throws Exception {\n         when(event.getLevel()).thenReturn(Level.INFO);\n         when(event.getThreadName()).thenReturn(\"thread-name\");\n         when(event.getMessage()).thenReturn(new SimpleMessage(\"message\"));\n+\n+        DubboAppender.clear();\n+        DubboAppender.doStop();\n     }\n     @AfterEach\n@@ -52,7 +53,7 @@ public void tearDown() throws Exception {\n     @Test\n     void testAvailable() {\n-        assumeFalse(DubboAppender.available);\n+        assertThat(DubboAppender.available, is(false));\n         DubboAppender.doStart();\n         assertThat(DubboAppender.available, is(true));\n         DubboAppender.doStop();\n@@ -62,8 +63,9 @@ void testAvailable() {\n     @Test\n     void testAppend() {\n         DubboAppender appender = new DubboAppender();\n+        assertThat(DubboAppender.logList, hasSize(0));\n         appender.append(event);\n-        assumeTrue(DubboAppender.logList.isEmpty());\n+        assertThat(DubboAppender.logList, hasSize(0));\n         DubboAppender.doStart();\n         appender.append(event);\n         assertThat(DubboAppender.logList, hasSize(1));\n@@ -75,7 +77,7 @@ void testClear() {\n         DubboAppender.doStart();\n         DubboAppender appender = new DubboAppender();\n         appender.append(event);\n-        assumeTrue(1 == DubboAppender.logList.size());\n+        assertThat(DubboAppender.logList, hasSize(1));\n         DubboAppender.clear();\n         assertThat(DubboAppender.logList, hasSize(0));\n     }",
    "output": "Fix flaky tests under DubboAppenderTest * fix flaky test under DubboAppenderTest * fix format issue * format code issue ---------"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h3/negotiation/NegotiateClientCall.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h3/negotiation/NegotiateClientCall.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h3/negotiation/NegotiateClientCall.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h3/negotiation/NegotiateClientCall.java\n@@ -59,6 +59,10 @@ public CompletableFuture<String> start(URL url) {\n         CompletableFuture<String> future = new CompletableFuture<>();\n         try {\n             Channel channel = connectionClient.getChannel(true);\n+            if (channel == null) {\n+                future.completeExceptionally(new IllegalStateException(\"Channel is null\"));\n+                return future;\n+            }\n             Http2StreamChannelBootstrap bootstrap = new Http2StreamChannelBootstrap(channel);\n             bootstrap.handler(new ChannelInboundHandlerAdapter() {\n                 @Override\n@@ -112,9 +116,6 @@ private static final class Listener implements H2TransportListener {\n         @Override\n         public void onHeader(Http2Headers headers, boolean endStream) {\n-            if (endStream) {\n-                return;\n-            }\n             CharSequence line = headers.status();\n             if (line != null) {\n                 HttpResponseStatus status = HttpResponseStatus.parseLine(line);\n@@ -124,6 +125,9 @@ public void onHeader(Http2Headers headers, boolean endStream) {\n                     return;\n                 }\n             }\n+            if (endStream) {\n+                return;\n+            }\n             executor.execute(() -> future.completeExceptionally(new RuntimeException(\"Status: \" + line)));\n         }",
    "output": "Fix http3 negotiation failed"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java\n@@ -96,7 +96,14 @@ public final void onNext(Object data) {\n             doOnNext(data);\n         } catch (Throwable t) {\n             LOGGER.warn(INTERNAL_ERROR, \"\", \"\", \"Error while doOnNext\", t);\n-            onError(t);\n+            Throwable throwable = t;\n+            try {\n+                doOnError(throwable);\n+            } catch (Throwable t1) {\n+                LOGGER.warn(INTERNAL_ERROR, \"\", \"\", \"Error while doOnError, original error: \" + throwable, t1);\n+                throwable = t1;\n+            }\n+            onCompleted(throwable);\n         }\n     }\n@@ -105,7 +112,6 @@ public final void onError(Throwable throwable) {\n         if (closed) {\n             return;\n         }\n-\n         try {\n             throwable = customizeError(throwable);\n             if (throwable == null) {\n@@ -122,7 +128,6 @@ public final void onError(Throwable throwable) {\n             LOGGER.warn(INTERNAL_ERROR, \"\", \"\", \"Error while doOnError, original error: \" + throwable, t);\n             throwable = t;\n         }\n-\n         onCompleted(throwable);\n     }",
    "output": "Fix dead loop in onNext"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/support/eager/TaskQueueTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/support/eager/TaskQueueTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/support/eager/TaskQueueTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/support/eager/TaskQueueTest.java\n@@ -20,6 +20,7 @@\n import java.util.concurrent.TimeUnit;\n import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.mockito.Mockito;\n@@ -29,6 +30,16 @@\n class TaskQueueTest {\n+    private TaskQueue<Runnable> queue;\n+    private EagerThreadPoolExecutor executor;\n+\n+    @BeforeEach\n+    void setup() {\n+        queue = new TaskQueue<Runnable>(1);\n+        executor = mock(EagerThreadPoolExecutor.class);\n+        queue.setExecutor(executor);\n+    }\n+\n     @Test\n     void testOffer1() throws Exception {\n         Assertions.assertThrows(RejectedExecutionException.class, () -> {\n@@ -39,53 +50,38 @@ void testOffer1() throws Exception {\n     @Test\n     void testOffer2() throws Exception {\n-        TaskQueue<Runnable> queue = new TaskQueue<Runnable>(1);\n-        EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);\n         Mockito.when(executor.getPoolSize()).thenReturn(2);\n         Mockito.when(executor.getActiveCount()).thenReturn(1);\n-        queue.setExecutor(executor);\n         assertThat(queue.offer(mock(Runnable.class)), is(true));\n     }\n     @Test\n     void testOffer3() throws Exception {\n-        TaskQueue<Runnable> queue = new TaskQueue<Runnable>(1);\n-        EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);\n         Mockito.when(executor.getPoolSize()).thenReturn(2);\n         Mockito.when(executor.getActiveCount()).thenReturn(2);\n         Mockito.when(executor.getMaximumPoolSize()).thenReturn(4);\n-        queue.setExecutor(executor);\n         assertThat(queue.offer(mock(Runnable.class)), is(false));\n     }\n     @Test\n     void testOffer4() throws Exception {\n-        TaskQueue<Runnable> queue = new TaskQueue<Runnable>(1);\n-        EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);\n         Mockito.when(executor.getPoolSize()).thenReturn(4);\n         Mockito.when(executor.getActiveCount()).thenReturn(4);\n         Mockito.when(executor.getMaximumPoolSize()).thenReturn(4);\n-        queue.setExecutor(executor);\n         assertThat(queue.offer(mock(Runnable.class)), is(true));\n     }\n     @Test\n     void testRetryOffer1() throws Exception {\n         Assertions.assertThrows(RejectedExecutionException.class, () -> {\n-            TaskQueue<Runnable> queue = new TaskQueue<Runnable>(1);\n-            EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);\n             Mockito.when(executor.isShutdown()).thenReturn(true);\n-            queue.setExecutor(executor);\n             queue.retryOffer(mock(Runnable.class), 1000, TimeUnit.MILLISECONDS);\n         });\n     }\n     @Test\n     void testRetryOffer2() throws Exception {\n-        TaskQueue<Runnable> queue = new TaskQueue<Runnable>(1);\n-        EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);\n         Mockito.when(executor.isShutdown()).thenReturn(false);\n-        queue.setExecutor(executor);\n         assertThat(queue.retryOffer(mock(Runnable.class), 1000, TimeUnit.MILLISECONDS), is(true));\n     }\n }",
    "output": "Fix three flaky tests in TaskQueueTest.java * fix flaky test fix flaky test fix flaky test fix format issue fix flaky test * fix format issue * fix format issue"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n@@ -94,7 +94,7 @@ public static String encodeCookie(HttpCookie cookie) {\n     public static List<String> parseAccept(String header) {\n         if (header == null) {\n-            return Collections.emptyList();\n+            return new ArrayList<>();\n         }\n         List<Item<String>> mediaTypes = new ArrayList<>();\n         for (String item : StringUtils.tokenize(header, ',')) {\n@@ -126,7 +126,7 @@ public static float parseQuality(String expr, int index) {\n     public static List<Locale> parseAcceptLanguage(String header) {\n         List<Item<Locale>> locales = new ArrayList<>();\n         if (header == null) {\n-            return Collections.emptyList();\n+            return new ArrayList<>();\n         }\n         for (String item : StringUtils.tokenize(header, ',')) {\n             String[] pair = StringUtils.tokenize(item, ';');\n@@ -138,7 +138,7 @@ public static List<Locale> parseAcceptLanguage(String header) {\n     public static List<Locale> parseContentLanguage(String header) {\n         List<Locale> locales = new ArrayList<>();\n         if (header == null) {\n-            return Collections.emptyList();\n+            return new ArrayList<>();\n         }\n         for (String item : StringUtils.tokenize(header, ',')) {\n             locales.add(parseLocale(item));",
    "output": "Fix Collections.emptyList() is final"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n@@ -33,7 +33,7 @@ public abstract class AbstractPortUnificationServer extends AbstractServer {\n     /**\n      * extension name -> activate WireProtocol\n      */\n-    private final Map<String, WireProtocol> protocols;\n+    private volatile Map<String, WireProtocol> protocols;\n     /*\n     protocol name --> URL object\n@@ -50,16 +50,24 @@ public abstract class AbstractPortUnificationServer extends AbstractServer {\n     public AbstractPortUnificationServer(URL url, ChannelHandler handler) throws RemotingException {\n         super(url, handler);\n-        ExtensionLoader<WireProtocol> extensionLoader =\n-                url.getOrDefaultFrameworkModel().getExtensionLoader(WireProtocol.class);\n-        this.protocols = extensionLoader.getActivateExtension(url, new String[0]).stream()\n-                .collect(Collectors.toConcurrentMap(extensionLoader::getExtensionName, Function.identity()));\n     }\n     public Map<String, WireProtocol> getProtocols() {\n         return protocols;\n     }\n+    @Override\n+    protected final void doOpen() {\n+        ExtensionLoader<WireProtocol> extensionLoader =\n+                getUrl().getOrDefaultFrameworkModel().getExtensionLoader(WireProtocol.class);\n+        this.protocols = extensionLoader.getActivateExtension(getUrl(), new String[0]).stream()\n+                .collect(Collectors.toConcurrentMap(extensionLoader::getExtensionName, Function.identity()));\n+\n+        doOpen0();\n+    }\n+\n+    protected abstract void doOpen0();\n+\n     /*\n     This method registers URL object and corresponding channel handler to pu server.\n     In PuServerExchanger.bind, this method is called with ConcurrentHashMap.computeIfPresent to register messages to\ndiff --git a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyPortUnificationServer.java b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyPortUnificationServer.java\n--- a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyPortUnificationServer.java\n+++ b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyPortUnificationServer.java\n@@ -90,7 +90,7 @@ public void bind() {\n     }\n     @Override\n-    protected void doOpen() {\n+    protected void doOpen0() {\n         NettyHelper.setNettyLoggerFactory();\n         ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory(EVENT_LOOP_BOSS_POOL_NAME, true));\n         ExecutorService worker =\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java\n@@ -105,7 +105,7 @@ public void bind() throws Throwable {\n     }\n     @Override\n-    public void doOpen() throws Throwable {\n+    public void doOpen0() {\n         bootstrap = new ServerBootstrap();\n         bossGroup = NettyEventLoopFactory.eventLoopGroup(1, EVENT_LOOP_BOSS_POOL_NAME);",
    "output": "Fix init order in AbstractPortUnificationServer * Fix init order * Fix init order"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n@@ -211,8 +211,12 @@ public void doSubscribe(URL url, NotifyListener listener) {\n                 mappingLock.lock();\n                 mappingByUrl = serviceNameMapping.getMapping(url);\n                 try {\n-                    MappingListener mappingListener = new DefaultMappingListener(url, mappingByUrl, listener);\n+                    DefaultMappingListener mappingListener = new DefaultMappingListener(url, mappingByUrl, listener);\n                     mappingByUrl = serviceNameMapping.getAndListen(this.getUrl(), url, mappingListener);\n+                    // update the initial mapping apps we started to listen, to make sure it reflects the real value\n+                    // used do subscription before any event.\n+                    // it's protected by the mapping lock, so it won't override the event value.\n+                    mappingListener.updateInitialApps(mappingByUrl);\n                     synchronized (mappingListeners) {\n                         mappingListeners\n                                 .computeIfAbsent(url.getProtocolServiceKey(), (k) -> new ConcurrentHashSet<>())\n@@ -399,8 +403,8 @@ public Map<String, ServiceInstancesChangedListener> getServiceListeners() {\n     private class DefaultMappingListener implements MappingListener {\n         private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(DefaultMappingListener.class);\n         private final URL url;\n-        private Set<String> oldApps;\n-        private NotifyListener listener;\n+        private final NotifyListener listener;\n+        private volatile Set<String> oldApps;\n         private volatile boolean stopped;\n         public DefaultMappingListener(URL subscribedURL, Set<String> serviceNames, NotifyListener listener) {\n@@ -424,16 +428,15 @@ public synchronized void onEvent(MappingChangedEvent event) {\n             Set<String> newApps = event.getApps();\n             Set<String> tempOldApps = oldApps;\n-            if (CollectionUtils.isEmpty(newApps) || CollectionUtils.equals(newApps, tempOldApps)) {\n-                return;\n-            }\n-\n-            logger.info(\n-                    \"Mapping of service \" + event.getServiceKey() + \"changed from \" + tempOldApps + \" to \" + newApps);\n-\n             Lock mappingLock = serviceNameMapping.getMappingLock(event.getServiceKey());\n             try {\n                 mappingLock.lock();\n+                if (CollectionUtils.isEmpty(newApps) || CollectionUtils.equals(newApps, tempOldApps)) {\n+                    return;\n+                }\n+                logger.info(\"Mapping of service \" + event.getServiceKey() + \"changed from \" + tempOldApps + \" to \"\n+                        + newApps);\n+\n                 if (CollectionUtils.isEmpty(tempOldApps) && !newApps.isEmpty()) {\n                     serviceNameMapping.putCachedMapping(ServiceNameMapping.buildMappingKey(url), newApps);\n                     subscribeURLs(url, listener, newApps);\n@@ -478,6 +481,14 @@ protected NotifyListener getListener() {\n             return listener;\n         }\n+        // writing of oldApps is protected by mapping lock to guarantee sequence consistency.\n+        public void updateInitialApps(Set<String> oldApps) {\n+            if (oldApps != null && !CollectionUtils.equals(oldApps, this.oldApps)) {\n+                this.oldApps = oldApps;\n+                logger.info(\"Update initial mapping apps from \" + this.oldApps + \" to \" + oldApps);\n+            }\n+        }\n+\n         @Override\n         public void stop() {\n             stopped = true;",
    "output": "Upgrade initial mapping apps of service discovery MappingListener"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n@@ -67,6 +67,10 @@ protected Serializer getDefaultSerializer(Class cl) {\n     @Override\n     protected Deserializer getDefaultDeserializer(Class cl) {\n+        if (InputStream.class.equals(cl)) {\n+            return InputStreamDeserializer.DESER;\n+        }\n+\n         try {\n             // pre-check if class is allow\n             defaultSerializeClassChecker.loadClass(getClassLoader(), cl.getName());\n@@ -76,9 +80,7 @@ protected Deserializer getDefaultDeserializer(Class cl) {\n         checkSerializable(cl);\n-        if (InputStream.class.equals(cl)) {\n-            return InputStreamDeserializer.DESER;\n-        } else if (RecordUtil.isRecord(cl)) {\n+        if (RecordUtil.isRecord(cl)) {\n             return new RecordDeserializer(cl, getFieldDeserializerFactory());\n         } else {\n             if (isEnableUnsafeSerializer()) {",
    "output": "Fix input stream unable to being deserialized"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n@@ -18,11 +18,15 @@\n import org.apache.dubbo.common.utils.DefaultSerializeClassChecker;\n+import java.io.InputStream;\n import java.io.Serializable;\n import com.alibaba.com.caucho.hessian.io.Deserializer;\n+import com.alibaba.com.caucho.hessian.io.InputStreamDeserializer;\n import com.alibaba.com.caucho.hessian.io.JavaDeserializer;\n import com.alibaba.com.caucho.hessian.io.JavaSerializer;\n+import com.alibaba.com.caucho.hessian.io.RecordDeserializer;\n+import com.alibaba.com.caucho.hessian.io.RecordUtil;\n import com.alibaba.com.caucho.hessian.io.Serializer;\n import com.alibaba.com.caucho.hessian.io.SerializerFactory;\n import com.alibaba.com.caucho.hessian.io.UnsafeDeserializer;\n@@ -72,9 +76,15 @@ protected Deserializer getDefaultDeserializer(Class cl) {\n         checkSerializable(cl);\n-        if (isEnableUnsafeSerializer()) {\n-            return new UnsafeDeserializer(cl, getFieldDeserializerFactory());\n-        } else return new JavaDeserializer(cl, getFieldDeserializerFactory());\n+        if (InputStream.class.equals(cl)) {\n+            return InputStreamDeserializer.DESER;\n+        } else if (RecordUtil.isRecord(cl)) {\n+            return new RecordDeserializer(cl, getFieldDeserializerFactory());\n+        } else {\n+            if (isEnableUnsafeSerializer()) {\n+                return new UnsafeDeserializer(cl, getFieldDeserializerFactory());\n+            } else return new JavaDeserializer(cl, getFieldDeserializerFactory());\n+        }\n     }\n     private void checkSerializable(Class<?> cl) {",
    "output": "Fix unable to deserialize Record using Hessian2"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n@@ -130,7 +130,7 @@ public boolean map(URL url) {\n                                 + waitTime + \". \" + \"Service Interface: \"\n                                 + serviceInterface + \". \" + \"Origin Content: \"\n                                 + oldConfigContent + \". \" + \"Ticket: \"\n-                                + configItem.getTicket() + \". \" + \"Excepted context: \"\n+                                + configItem.getTicket() + \". \" + \"Expected Content: \"\n                                 + newConfigContent);\n                         Thread.sleep(waitTime);\n                     }",
    "output": "Fix spelling typo"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/MethodMetadata.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/MethodMetadata.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/MethodMetadata.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/MethodMetadata.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.rpc.model.StubMethodDescriptor;\n import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n public class MethodMetadata {\n@@ -64,18 +65,18 @@ private static MethodMetadata doResolveReflection(ReflectionMethodDescriptor met\n             case CLIENT_STREAM:\n             case BI_STREAM:\n                 actualRequestTypes = new Class<?>[] {\n-                    (Class<?>)\n-                            ((ParameterizedType) method.getMethod().getGenericReturnType()).getActualTypeArguments()[0]\n+                    obtainActualTypeInStreamObserver(\n+                            ((ParameterizedType) method.getMethod().getGenericReturnType()).getActualTypeArguments()[0])\n                 };\n-                actualResponseType =\n-                        (Class<?>) ((ParameterizedType) method.getMethod().getGenericParameterTypes()[0])\n-                                .getActualTypeArguments()[0];\n+                actualResponseType = obtainActualTypeInStreamObserver(\n+                        ((ParameterizedType) method.getMethod().getGenericParameterTypes()[0])\n+                                .getActualTypeArguments()[0]);\n                 return new MethodMetadata(actualRequestTypes, actualResponseType);\n             case SERVER_STREAM:\n                 actualRequestTypes = new Class[] {method.getMethod().getParameterTypes()[0]};\n-                actualResponseType =\n-                        (Class<?>) ((ParameterizedType) method.getMethod().getGenericParameterTypes()[1])\n-                                .getActualTypeArguments()[0];\n+                actualResponseType = obtainActualTypeInStreamObserver(\n+                        ((ParameterizedType) method.getMethod().getGenericParameterTypes()[1])\n+                                .getActualTypeArguments()[0]);\n                 return new MethodMetadata(actualRequestTypes, actualResponseType);\n             case UNARY:\n                 actualRequestTypes = method.getParameterClasses();\n@@ -84,4 +85,11 @@ private static MethodMetadata doResolveReflection(ReflectionMethodDescriptor met\n         }\n         throw new IllegalStateException(\"Can not reach here\");\n     }\n+\n+    static Class<?> obtainActualTypeInStreamObserver(Type typeInStreamObserver) {\n+        return (Class<?>)\n+                (typeInStreamObserver instanceof ParameterizedType\n+                        ? ((ParameterizedType) typeInStreamObserver).getRawType()\n+                        : typeInStreamObserver);\n+    }\n }",
    "output": "Fix ParameterizedType in SERVER_STREAM"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2ScopeModelInitializer.java b/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2ScopeModelInitializer.java\n--- a/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2ScopeModelInitializer.java\n+++ b/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2ScopeModelInitializer.java\n@@ -17,22 +17,40 @@\n package org.apache.dubbo.common.serialize.fastjson2;\n import org.apache.dubbo.common.beans.factory.ScopeBeanFactory;\n+import org.apache.dubbo.common.utils.ClassUtils;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ModuleModel;\n import org.apache.dubbo.rpc.model.ScopeModelInitializer;\n+import java.util.Arrays;\n+\n public class Fastjson2ScopeModelInitializer implements ScopeModelInitializer {\n     @Override\n     public void initializeFrameworkModel(FrameworkModel frameworkModel) {\n-        Class<?> aClass = null;\n+        boolean classExist = false;\n         try {\n-            aClass = com.alibaba.fastjson2.JSONB.class;\n+            for (String className : Arrays.asList(\n+                    \"com.alibaba.fastjson2.JSONB\",\n+                    \"com.alibaba.fastjson2.reader.ObjectReaderCreatorASM\",\n+                    \"com.alibaba.fastjson2.writer.ObjectWriterCreatorASM\",\n+                    \"com.alibaba.fastjson2.JSONValidator\",\n+                    \"com.alibaba.fastjson2.JSONFactory\",\n+                    \"com.alibaba.fastjson2.JSONWriter\",\n+                    \"com.alibaba.fastjson2.util.TypeUtils\",\n+                    \"com.alibaba.fastjson2.filter.ContextAutoTypeBeforeHandler\")) {\n+                Class<?> aClass =\n+                        ClassUtils.forName(className, Thread.currentThread().getContextClassLoader());\n+                if (aClass == null) {\n+                    throw new ClassNotFoundException(className);\n+                }\n+            }\n+            classExist = true;\n         } catch (Throwable ignored) {\n         }\n-        if (aClass != null) {\n+        if (classExist) {\n             ScopeBeanFactory beanFactory = frameworkModel.getBeanFactory();\n             beanFactory.registerBean(Fastjson2CreatorManager.class);\n             beanFactory.registerBean(Fastjson2SecurityManager.class);",
    "output": "Fix fastjson2 init error cause startup failure"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n@@ -32,7 +32,6 @@\n import io.netty.buffer.ByteBufAllocator;\n import io.netty.buffer.ByteBufInputStream;\n import io.netty.buffer.ByteBufOutputStream;\n-import io.netty.buffer.Unpooled;\n import io.netty.buffer.UnpooledByteBufAllocator;\n import io.netty.handler.codec.http.DefaultFullHttpRequest;\n import io.netty.handler.codec.http.DefaultHttpHeaders;\n@@ -169,7 +168,7 @@ public static HttpPostRequestDecoder createPostRequestDecoder(\n                 inputStream.mark(Integer.MAX_VALUE);\n             }\n             if (inputStream.available() == 0) {\n-                data = Unpooled.EMPTY_BUFFER;\n+                return null;\n             } else {\n                 data = HEAP_ALLOC.buffer();\n                 ByteBufOutputStream os = new ByteBufOutputStream(data);",
    "output": "Fix memory leak in HttpPostRequestDecoder when body is empty"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-rest-spring/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/spring/SpringRestToolKit.java b/dubbo-plugin/dubbo-rest-spring/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/spring/SpringRestToolKit.java\n--- a/dubbo-plugin/dubbo-rest-spring/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/spring/SpringRestToolKit.java\n+++ b/dubbo-plugin/dubbo-rest-spring/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/spring/SpringRestToolKit.java\n@@ -79,7 +79,7 @@ public SpringRestToolKit(FrameworkModel frameworkModel) {\n             configuration = new ConfigurationWrapper(applicationModel);\n         }\n         if (context != null && context.containsBean(\"mvcConversionService\")) {\n-            conversionService = context.getBean(ConversionService.class, \"mvcConversionService\");\n+            conversionService = context.getBean(\"mvcConversionService\", ConversionService.class);\n         } else {\n             conversionService = DefaultConversionService.getSharedInstance();\n         }",
    "output": "Fix SpringRestToolKit getBean param mistake"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpUtils.java\n@@ -29,8 +29,11 @@\n import java.util.Locale;\n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.buffer.Unpooled;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n import io.netty.handler.codec.http.DefaultFullHttpRequest;\n import io.netty.handler.codec.http.DefaultHttpHeaders;\n import io.netty.handler.codec.http.HttpHeaders;\n@@ -51,6 +54,7 @@\n public final class HttpUtils {\n+    public static final ByteBufAllocator HEAP_ALLOC = new UnpooledByteBufAllocator(false, false);\n     public static final HttpDataFactory DATA_FACTORY = new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE);\n     public static final String CHARSET_PREFIX = \"charset=\";\n@@ -164,7 +168,13 @@ public static HttpPostRequestDecoder createPostRequestDecoder(\n             if (canMark) {\n                 inputStream.mark(Integer.MAX_VALUE);\n             }\n-            data = Unpooled.wrappedBuffer(StreamUtils.readBytes(inputStream));\n+            if (inputStream.available() == 0) {\n+                data = Unpooled.EMPTY_BUFFER;\n+            } else {\n+                data = HEAP_ALLOC.buffer();\n+                ByteBufOutputStream os = new ByteBufOutputStream(data);\n+                StreamUtils.copy(inputStream, os);\n+            }\n         } catch (IOException e) {\n             throw new DecodeException(\"Error while reading post data: \" + e.getMessage(), e);\n         } finally {\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n@@ -23,6 +23,7 @@\n import org.apache.dubbo.common.threadpool.manager.ExecutorRepository;\n import org.apache.dubbo.common.threadpool.serial.SerializingExecutor;\n import org.apache.dubbo.common.utils.MethodUtils;\n+import org.apache.dubbo.common.utils.UrlUtils;\n import org.apache.dubbo.remoting.http12.HttpChannel;\n import org.apache.dubbo.remoting.http12.HttpInputMessage;\n import org.apache.dubbo.remoting.http12.HttpStatus;\n@@ -278,14 +279,27 @@ protected final RpcInvocation buildRpcInvocation(RpcInvocationBuildContext conte\n         if (consumerAppName != null) {\n             inv.put(TripleHeaderEnum.CONSUMER_APP_NAME_KEY, consumerAppName);\n         }\n+\n         // customizer RpcInvocation\n-        headerFilters.forEach(f -> f.invoke(invoker, inv));\n+        HeaderFilter[] headerFilters =\n+                UrlUtils.computeServiceAttribute(invoker.getUrl(), HEADER_FILTERS_CACHE, this::loadHeaderFilters);\n+        for (HeaderFilter headerFilter : headerFilters) {\n+            headerFilter.invoke(invoker, inv);\n+        }\n         initializeAltSvc(url);\n         return onBuildRpcInvocationCompletion(inv);\n     }\n+    private HeaderFilter[] loadHeaderFilters(URL url) {\n+        List<HeaderFilter> headerFilters = frameworkModel\n+                .getExtensionLoader(HeaderFilter.class)\n+                .getActivateExtension(url, CommonConstants.HEADER_FILTER_KEY);\n+        LOGGER.info(\"Header filters for [{}] loaded: {}\", url, headerFilters);\n+        return headerFilters.toArray(new HeaderFilter[0]);\n+    }\n+\n     protected RpcInvocation onBuildRpcInvocationCompletion(RpcInvocation invocation) {\n         String timeoutString = httpMetadata.header(TripleHeaderEnum.SERVICE_TIMEOUT.getKey());\n         try {",
    "output": "Fix memory leak in HttpPostRequestDecoder"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LockUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LockUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LockUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LockUtils.java\n@@ -31,18 +31,24 @@ public class LockUtils {\n     public static void safeLock(Lock lock, int timeout, Runnable runnable) {\n         try {\n-            if (!lock.tryLock(timeout, TimeUnit.MILLISECONDS)) {\n-                logger.error(\n-                        LoggerCodeConstants.INTERNAL_ERROR,\n-                        \"\",\n-                        \"\",\n-                        \"Try to lock failed, timeout: \" + timeout,\n-                        new TimeoutException());\n+            boolean interrupted = false;\n+            try {\n+                if (!lock.tryLock(timeout, TimeUnit.MILLISECONDS)) {\n+                    logger.error(\n+                            LoggerCodeConstants.INTERNAL_ERROR,\n+                            \"\",\n+                            \"\",\n+                            \"Try to lock failed, timeout: \" + timeout,\n+                            new TimeoutException());\n+                }\n+            } catch (InterruptedException e) {\n+                logger.warn(LoggerCodeConstants.INTERNAL_ERROR, \"\", \"\", \"Try to lock failed\", e);\n+                interrupted = true;\n             }\n             runnable.run();\n-        } catch (InterruptedException e) {\n-            logger.warn(LoggerCodeConstants.INTERNAL_ERROR, \"\", \"\", \"Try to lock failed\", e);\n-            Thread.currentThread().interrupt();\n+            if (interrupted) {\n+                Thread.currentThread().interrupt();\n+            }\n         } finally {\n             try {\n                 lock.unlock();\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/LockUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/LockUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/LockUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/LockUtilsTest.java\n@@ -114,7 +114,7 @@ void testInterrupt() {\n         thread.interrupt();\n         await().until(() -> thread.getState() == State.TERMINATED);\n-        Assertions.assertFalse(locked.get());\n+        Assertions.assertTrue(locked.get());\n         reentrantLock.unlock();\n     }\n@@ -141,4 +141,24 @@ void testHoldLock() throws InterruptedException {\n         Assertions.assertTrue(lockTime.get() - startTime > 1000);\n         Assertions.assertTrue(lockTime.get() - startTime < 10000);\n     }\n+\n+    @RepeatedTest(5)\n+    void testInterrupted() throws InterruptedException {\n+        ReentrantLock reentrantLock = new ReentrantLock();\n+        reentrantLock.lock();\n+\n+        AtomicLong lockTime = new AtomicLong(0);\n+        long startTime = System.currentTimeMillis();\n+        Thread thread = new Thread(() -> {\n+            Thread.currentThread().interrupt();\n+            LockUtils.safeLock(reentrantLock, 10000, () -> {\n+                lockTime.set(System.currentTimeMillis());\n+            });\n+        });\n+        thread.start();\n+\n+        await().until(() -> thread.getState() == State.TERMINATED);\n+        Assertions.assertTrue(lockTime.get() >= startTime);\n+        Assertions.assertTrue(lockTime.get() - startTime < 10000);\n+    }\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n@@ -182,28 +182,8 @@ private synchronized void doOnEvent(ServiceInstancesChangedEvent event) {\n         }\n         int emptyNum = hasEmptyMetadata(revisionToInstances);\n-        if (emptyNum != 0) { // retry every 10 seconds\n+        if (emptyNum != 0) {\n             hasEmptyMetadata = true;\n-            if (retryPermission.tryAcquire()) {\n-                if (retryFuture != null && !retryFuture.isDone()) {\n-                    // cancel last retryFuture because only one retryFuture will be canceled at destroy().\n-                    retryFuture.cancel(true);\n-                }\n-                try {\n-                    retryFuture = scheduler.schedule(\n-                            new AddressRefreshRetryTask(retryPermission, event.getServiceName()),\n-                            10_000L,\n-                            TimeUnit.MILLISECONDS);\n-                } catch (Exception e) {\n-                    logger.error(\n-                            INTERNAL_ERROR,\n-                            \"unknown error in registry module\",\n-                            \"\",\n-                            \"Error submitting async retry task.\");\n-                }\n-                logger.warn(\n-                        INTERNAL_ERROR, \"unknown error in registry module\", \"\", \"Address refresh try task submitted\");\n-            }\n             // return if all metadata is empty, this notification will not take effect.\n             if (emptyNum == revisionToInstances.size()) {\n@@ -214,10 +194,12 @@ private synchronized void doOnEvent(ServiceInstancesChangedEvent event) {\n                         \"\",\n                         \"Address refresh failed because of Metadata Server failure, wait for retry or new address refresh event.\");\n+                submitRetryTask(event);\n                 return;\n             }\n+        } else {\n+            hasEmptyMetadata = false;\n         }\n-        hasEmptyMetadata = false;\n         Map<String, Map<Integer, Map<Set<String>, Object>>> protocolRevisionsToUrls = new HashMap<>();\n         Map<String, List<ProtocolServiceKeyWithUrls>> newServiceUrls = new HashMap<>();\n@@ -241,6 +223,30 @@ private synchronized void doOnEvent(ServiceInstancesChangedEvent event) {\n         this.serviceUrls = newServiceUrls;\n         this.notifyAddressChanged();\n+\n+        if (hasEmptyMetadata) {\n+            submitRetryTask(event);\n+        }\n+    }\n+\n+    private void submitRetryTask(ServiceInstancesChangedEvent event) {\n+        // retry every 10 seconds\n+        if (retryPermission.tryAcquire()) {\n+            if (retryFuture != null && !retryFuture.isDone()) {\n+                // cancel last retryFuture because only one retryFuture will be canceled at destroy().\n+                retryFuture.cancel(true);\n+            }\n+            try {\n+                retryFuture = scheduler.schedule(\n+                        new AddressRefreshRetryTask(retryPermission, event.getServiceName()),\n+                        10_000L,\n+                        TimeUnit.MILLISECONDS);\n+            } catch (Exception e) {\n+                logger.error(\n+                        INTERNAL_ERROR, \"unknown error in registry module\", \"\", \"Error submitting async retry task.\");\n+            }\n+            logger.warn(INTERNAL_ERROR, \"unknown error in registry module\", \"\", \"Address refresh try task submitted\");\n+        }\n     }\n     public synchronized void addListenerAndNotify(URL url, NotifyListener listener) {",
    "output": "Fix safeLock not run when interrupt & Fix partial notification being cancelled in ServiceInstancesChangedListener * Fix safeLock not run when interrupt & Clear interrupted status for MetadataUtils * Fix safeLock not run when interrupt & Clear interrupted status for MetadataUtils * Fix safeLock not run when interrupt & Clear interrupted status for MetadataUtils * Fix notify * Fix style * Fix ut"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/nested/ServletConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/nested/ServletConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/nested/ServletConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/nested/ServletConfig.java\n@@ -28,6 +28,14 @@ public class ServletConfig implements Serializable {\n      */\n     private Boolean enabled;\n+    /**\n+     * Maximum concurrent streams.\n+     * <p>For HTTP/2\n+     * <p>Note that the default value for tomcat is 20. Highly recommended to change it to {@link Integer#MAX_VALUE}\n+     * <p>If set to zero or a negative number, the actual value will be set to {@link Integer#MAX_VALUE}.\n+     */\n+    private Integer maxConcurrentStreams;\n+\n     /**\n      * The URL patterns that the servlet filter will be registered for.\n      * <p>The default value is '/*'.\n@@ -48,6 +56,14 @@ public void setEnabled(Boolean enabled) {\n         this.enabled = enabled;\n     }\n+    public Integer getMaxConcurrentStreams() {\n+        return maxConcurrentStreams;\n+    }\n+\n+    public void setMaxConcurrentStreams(Integer maxConcurrentStreams) {\n+        this.maxConcurrentStreams = maxConcurrentStreams;\n+    }\n+\n     public String[] getFilterUrlPatterns() {\n         return filterUrlPatterns;\n     }\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-3-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboTriple3AutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-3-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboTriple3AutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-3-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboTriple3AutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-3-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboTriple3AutoConfiguration.java\n@@ -20,11 +20,16 @@\n import org.apache.dubbo.rpc.protocol.tri.servlet.jakarta.TripleFilter;\n import jakarta.servlet.Filter;\n+import org.apache.coyote.ProtocolHandler;\n+import org.apache.coyote.UpgradeProtocol;\n+import org.apache.coyote.http2.Http2Protocol;\n import org.springframework.beans.factory.annotation.Value;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;\n+import org.springframework.boot.web.embedded.tomcat.ConfigurableTomcatWebServerFactory;\n+import org.springframework.boot.web.server.WebServerFactoryCustomizer;\n import org.springframework.boot.web.servlet.FilterRegistrationBean;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Conditional;\n@@ -39,7 +44,7 @@ public class DubboTriple3AutoConfiguration {\n     @Configuration(proxyBeanMethods = false)\n     @ConditionalOnClass(Filter.class)\n     @ConditionalOnWebApplication(type = Type.SERVLET)\n-    @ConditionalOnProperty(prefix = PREFIX, name = \"enabled\")\n+    @ConditionalOnProperty(prefix = PREFIX, name = \"enabled\", havingValue = \"true\")\n     public static class TripleServletConfiguration {\n         @Bean\n@@ -54,5 +59,23 @@ public FilterRegistrationBean<TripleFilter> tripleProtocolFilter(\n             registrationBean.setOrder(order);\n             return registrationBean;\n         }\n+\n+        @Bean\n+        @ConditionalOnClass(Http2Protocol.class)\n+        @ConditionalOnProperty(prefix = PREFIX, name = \"max-concurrent-streams\")\n+        public WebServerFactoryCustomizer<ConfigurableTomcatWebServerFactory> tripleTomcatHttp2Customizer(\n+                @Value(\"${\" + PREFIX + \".max-concurrent-streams}\") int maxConcurrentStreams) {\n+            return factory -> factory.addConnectorCustomizers(connector -> {\n+                ProtocolHandler handler = connector.getProtocolHandler();\n+                for (UpgradeProtocol upgradeProtocol : handler.findUpgradeProtocols()) {\n+                    if (upgradeProtocol instanceof Http2Protocol) {\n+                        Http2Protocol protocol = (Http2Protocol) upgradeProtocol;\n+                        int value = maxConcurrentStreams <= 0 ? Integer.MAX_VALUE : maxConcurrentStreams;\n+                        protocol.setMaxConcurrentStreams(value);\n+                        protocol.setMaxConcurrentStreamExecution(value);\n+                    }\n+                }\n+            });\n+        }\n     }\n }\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboTripleAutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboTripleAutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboTripleAutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboTripleAutoConfiguration.java\n@@ -21,11 +21,16 @@\n import javax.servlet.Filter;\n+import org.apache.coyote.ProtocolHandler;\n+import org.apache.coyote.UpgradeProtocol;\n+import org.apache.coyote.http2.Http2Protocol;\n import org.springframework.beans.factory.annotation.Value;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;\n+import org.springframework.boot.web.embedded.tomcat.ConfigurableTomcatWebServerFactory;\n+import org.springframework.boot.web.server.WebServerFactoryCustomizer;\n import org.springframework.boot.web.servlet.FilterRegistrationBean;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Conditional;\n@@ -40,7 +45,7 @@ public class DubboTripleAutoConfiguration {\n     @Configuration(proxyBeanMethods = false)\n     @ConditionalOnClass(Filter.class)\n     @ConditionalOnWebApplication(type = Type.SERVLET)\n-    @ConditionalOnProperty(prefix = PREFIX, name = \"enabled\")\n+    @ConditionalOnProperty(prefix = PREFIX, name = \"enabled\", havingValue = \"true\")\n     public static class TripleServletConfiguration {\n         @Bean\n@@ -55,5 +60,23 @@ public FilterRegistrationBean<TripleFilter> tripleProtocolFilter(\n             registrationBean.setOrder(order);\n             return registrationBean;\n         }\n+\n+        @Bean\n+        @ConditionalOnClass(Http2Protocol.class)\n+        @ConditionalOnProperty(prefix = PREFIX, name = \"max-concurrent-streams\")\n+        public WebServerFactoryCustomizer<ConfigurableTomcatWebServerFactory> tripleTomcatHttp2Customizer(\n+                @Value(\"${\" + PREFIX + \".max-concurrent-streams}\") int maxConcurrentStreams) {\n+            return factory -> factory.addConnectorCustomizers(connector -> {\n+                ProtocolHandler handler = connector.getProtocolHandler();\n+                for (UpgradeProtocol upgradeProtocol : handler.findUpgradeProtocols()) {\n+                    if (upgradeProtocol instanceof Http2Protocol) {\n+                        Http2Protocol protocol = (Http2Protocol) upgradeProtocol;\n+                        int value = maxConcurrentStreams <= 0 ? Integer.MAX_VALUE : maxConcurrentStreams;\n+                        protocol.setMaxConcurrentStreams(value);\n+                        protocol.setMaxConcurrentStreamExecution(value);\n+                    }\n+                }\n+            });\n+        }\n     }\n }",
    "output": "Add support for configuring Tomcat HTTP2 max stream size in Spring boot * Added support for configuring Tomcat HTTP2 max stream size in Spring Boot * Does not override defaults max stream size"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/AbstractConnectionClient.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/AbstractConnectionClient.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/AbstractConnectionClient.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/AbstractConnectionClient.java\n@@ -61,13 +61,17 @@ public final void increase() {\n     /**\n      * Increments the reference count by 1.\n      */\n-    public final AbstractConnectionClient retain() {\n+    public final boolean retain() {\n         long oldCount = COUNTER_UPDATER.getAndIncrement(this);\n         if (oldCount <= 0) {\n             COUNTER_UPDATER.getAndDecrement(this);\n-            throw new AssertionError(\"This instance has been destroyed\");\n+            logger.info(\n+                    \"Retain failed, because connection \" + remote\n+                            + \" has been destroyed but not yet removed, will create a new one instead.\"\n+                            + \" Check logs below to confirm that this connection finally gets removed to make sure there's no potential memory leak!\");\n+            return false;\n         }\n-        return this;\n+        return true;\n     }\n     /**\n@@ -77,6 +81,7 @@ public boolean release() {\n         long remainingCount = COUNTER_UPDATER.decrementAndGet(this);\n         if (remainingCount == 0) {\n+            logger.info(\"Destroying connection to {}, because the reference count reaches 0\", remote);\n             destroy();\n             return true;\n         } else if (remainingCount <= -1) {\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/SingleProtocolConnectionManager.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/SingleProtocolConnectionManager.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/SingleProtocolConnectionManager.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/SingleProtocolConnectionManager.java\n@@ -17,6 +17,8 @@\n package org.apache.dubbo.remoting.api.connection;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.remoting.ChannelHandler;\n import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n@@ -26,6 +28,9 @@\n import java.util.function.Consumer;\n public class SingleProtocolConnectionManager implements ConnectionManager {\n+    private static final ErrorTypeAwareLogger logger =\n+            LoggerFactory.getErrorTypeAwareLogger(SingleProtocolConnectionManager.class);\n+\n     public static final String NAME = \"single\";\n     private final ConcurrentMap<String, AbstractConnectionClient> connections = new ConcurrentHashMap<>(16);\n@@ -42,21 +47,34 @@ public AbstractConnectionClient connect(URL url, ChannelHandler handler) {\n             throw new IllegalArgumentException(\"url == null\");\n         }\n         return connections.compute(url.getAddress(), (address, conn) -> {\n+            String transport = url.getParameter(Constants.TRANSPORTER_KEY, \"netty4\");\n             if (conn == null) {\n-                String transport = url.getParameter(Constants.TRANSPORTER_KEY, \"netty4\");\n-                ConnectionManager manager = frameworkModel\n-                        .getExtensionLoader(ConnectionManager.class)\n-                        .getExtension(transport);\n-                final AbstractConnectionClient connectionClient = manager.connect(url, handler);\n-                connectionClient.addCloseListener(() -> connections.remove(address, connectionClient));\n-                return connectionClient;\n+                return createAbstractConnectionClient(url, handler, address, transport);\n             } else {\n-                conn.retain();\n+                boolean shouldReuse = conn.retain();\n+                if (!shouldReuse) {\n+                    logger.info(\"Trying to create a new connection for {}.\", address);\n+                    return createAbstractConnectionClient(url, handler, address, transport);\n+                }\n                 return conn;\n             }\n         });\n     }\n+    private AbstractConnectionClient createAbstractConnectionClient(\n+            URL url, ChannelHandler handler, String address, String transport) {\n+        ConnectionManager manager =\n+                frameworkModel.getExtensionLoader(ConnectionManager.class).getExtension(transport);\n+        final AbstractConnectionClient connectionClient = manager.connect(url, handler);\n+        connectionClient.addCloseListener(() -> {\n+            logger.info(\n+                    \"Remove closed connection (with reference count==0) for address {}, a new one will be created for upcoming RPC requests routing to this address.\",\n+                    address);\n+            connections.remove(address, connectionClient);\n+        });\n+        return connectionClient;\n+    }\n+\n     @Override\n     public void forEachConnection(Consumer<AbstractConnectionClient> connectionConsumer) {\n         connections.values().forEach(connectionConsumer);",
    "output": "Fix triple client connection shareing race condition * fix triple client connection management issue, #14717, #14716 * fix triple client connection management issue, #14717, #14716 * add comment * polish warning log format * polish warning log format * Make stub implement Destroyable * format code"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring6/src/main/java/org/apache/dubbo/config/spring6/beans/factory/annotation/ReferenceAnnotationWithAotBeanPostProcessor.java b/dubbo-config/dubbo-config-spring6/src/main/java/org/apache/dubbo/config/spring6/beans/factory/annotation/ReferenceAnnotationWithAotBeanPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring6/src/main/java/org/apache/dubbo/config/spring6/beans/factory/annotation/ReferenceAnnotationWithAotBeanPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring6/src/main/java/org/apache/dubbo/config/spring6/beans/factory/annotation/ReferenceAnnotationWithAotBeanPostProcessor.java\n@@ -261,7 +261,17 @@ private CodeBlock generateStatementForElement(\n                 Class<?> c = referenceElement.getInjectedType();\n                 AotUtils.registerSerializationForService(c, hints);\n                 hints.reflection().registerType(TypeReference.of(c), MemberCategory.INVOKE_PUBLIC_METHODS);\n+                // need to enumerate all interfaces by the proxy\n+                hints.proxies().registerJdkProxy(c, EchoService.class, Destroyable.class);\n                 hints.proxies().registerJdkProxy(c, EchoService.class, Destroyable.class, GenericService.class);\n+                hints.proxies()\n+                        .registerJdkProxy(\n+                                c,\n+                                EchoService.class,\n+                                Destroyable.class,\n+                                SpringProxy.class,\n+                                Advised.class,\n+                                DecoratingProxy.class);\n                 hints.proxies()\n                         .registerJdkProxy(\n                                 c,",
    "output": "Fix native image for proxy"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/nested/TripleConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/nested/TripleConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/nested/TripleConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/nested/TripleConfig.java\n@@ -38,6 +38,7 @@ public class TripleConfig implements Serializable {\n     public static final boolean DEFAULT_ENABLE_PUSH = false;\n     public static final int DEFAULT_MAX_CONCURRENT_STREAMS = Integer.MAX_VALUE;\n     public static final int DEFAULT_INITIAL_WINDOW_SIZE = 8_388_608;\n+    public static final int DEFAULT_CONNECTION_INITIAL_WINDOW_SIZE_KEY = 65_536;\n     public static final int DEFAULT_MAX_FRAME_SIZE = 8_388_608;\n     public static final int DEFAULT_MAX_HEADER_LIST_SIZE = 32_768;\n@@ -124,6 +125,12 @@ public class TripleConfig implements Serializable {\n      */\n     private Integer initialWindowSize;\n+    /**\n+     * Connection initial window size.\n+     * <p>For HTTP/2\n+     */\n+    private Integer connectionInitialWindowSize;\n+\n     /**\n      * Maximum frame size.\n      * <p>For HTTP/2\n@@ -283,6 +290,21 @@ public void setInitialWindowSize(Integer initialWindowSize) {\n         this.initialWindowSize = initialWindowSize;\n     }\n+    public Integer getConnectionInitialWindowSize() {\n+        return connectionInitialWindowSize;\n+    }\n+\n+    @Parameter(excluded = true)\n+    public Integer getConnectionInitialWindowSizeOrDefault() {\n+        return connectionInitialWindowSize == null\n+                ? DEFAULT_CONNECTION_INITIAL_WINDOW_SIZE_KEY\n+                : connectionInitialWindowSize;\n+    }\n+\n+    public void setConnectionInitialWindowSize(Integer connectionInitialWindowSize) {\n+        this.connectionInitialWindowSize = connectionInitialWindowSize;\n+    }\n+\n     public Integer getMaxFrameSize() {\n         return maxFrameSize;\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/TripleBuilder.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/TripleBuilder.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/TripleBuilder.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/TripleBuilder.java\n@@ -90,6 +90,11 @@ public class TripleBuilder {\n      */\n     private Integer initialWindowSize;\n+    /**\n+     * Connection initial window size.\n+     */\n+    private Integer connectionInitialWindowSize;\n+\n     /**\n      * Maximum frame size.\n      */\n@@ -154,6 +159,11 @@ public TripleBuilder initialWindowSize(Integer initialWindowSize) {\n         return getThis();\n     }\n+    public TripleBuilder connectionInitialWindowSize(Integer connectionInitialWindowSize) {\n+        this.connectionInitialWindowSize = connectionInitialWindowSize;\n+        return getThis();\n+    }\n+\n     public TripleBuilder maxFrameSize(Integer maxFrameSize) {\n         this.maxFrameSize = maxFrameSize;\n         return getThis();\n@@ -201,6 +211,9 @@ public TripleConfig build() {\n         if (initialWindowSize != null) {\n             triple.setInitialWindowSize(initialWindowSize);\n         }\n+        if (connectionInitialWindowSize != null) {\n+            triple.setConnectionInitialWindowSize(connectionInitialWindowSize);\n+        }\n         if (maxFrameSize != null) {\n             triple.setMaxFrameSize(maxFrameSize);\n         }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/DubboBootstrapTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/DubboBootstrapTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/DubboBootstrapTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/DubboBootstrapTest.java\n@@ -514,6 +514,7 @@ void testDefaultTriple() {\n         Assertions.assertFalse(tripleConfig.getEnablePushOrDefault());\n         Assertions.assertEquals(Integer.MAX_VALUE, tripleConfig.getMaxConcurrentStreamsOrDefault());\n         Assertions.assertEquals(1 << 23, tripleConfig.getInitialWindowSizeOrDefault());\n+        Assertions.assertEquals(1 << 16, tripleConfig.getConnectionInitialWindowSizeOrDefault());\n         Assertions.assertEquals(1 << 23, tripleConfig.getMaxFrameSizeOrDefault());\n         Assertions.assertEquals(1 << 15, tripleConfig.getMaxHeaderListSizeOrDefault());\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/builders/TripleBuilderTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/builders/TripleBuilderTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/builders/TripleBuilderTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/builders/TripleBuilderTest.java\n@@ -93,6 +93,13 @@ void initialWindowSize() {\n         Assertions.assertEquals(10240, builder.build().getInitialWindowSize());\n     }\n+    @Test\n+    void connectionInitialWindowSize() {\n+        TripleBuilder builder = TripleBuilder.newBuilder();\n+        builder.connectionInitialWindowSize(8192);\n+        Assertions.assertEquals(8192, builder.build().getConnectionInitialWindowSize());\n+    }\n+\n     @Test\n     void maxFrameSize() {\n         TripleBuilder builder = TripleBuilder.newBuilder();\n@@ -120,6 +127,7 @@ void build() {\n                 .enablePush(true)\n                 .maxConcurrentStreams(Integer.MAX_VALUE)\n                 .initialWindowSize(4096)\n+                .connectionInitialWindowSize(8192)\n                 .maxFrameSize(1024)\n                 .maxHeaderListSize(500);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java\n@@ -18,6 +18,9 @@\n import org.apache.dubbo.config.nested.TripleConfig;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2Connection;\n import io.netty.handler.codec.http2.Http2ConnectionAdapter;\n@@ -32,9 +35,6 @@\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n-import java.util.ArrayDeque;\n-import java.util.Deque;\n-\n import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_WEIGHT;\n import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_WEIGHT;\n import static io.netty.handler.codec.http2.Http2Error.FLOW_CONTROL_ERROR;\n@@ -82,7 +82,7 @@ public TriHttp2RemoteFlowController(\n             TripleConfig config) {\n         this.connection = checkNotNull(connection, \"connection\");\n         this.streamByteDistributor = checkNotNull(streamByteDistributor, \"streamWriteDistributor\");\n-        this.initialWindowSize = config.getInitialWindowSizeOrDefault();\n+        this.initialWindowSize = config.getConnectionInitialWindowSizeOrDefault();\n         // Add a flow state for the connection.\n         stateKey = connection.newKey();",
    "output": "Fix tcp connection window size split from stream connection window size for 3.3"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Constants.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Constants.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Constants.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Constants.java\n@@ -102,6 +102,7 @@ public interface Constants {\n     String H2_SETTINGS_ENABLE_PUSH_KEY = \"dubbo.rpc.tri.enable-push\";\n     String H2_SETTINGS_MAX_CONCURRENT_STREAMS_KEY = \"dubbo.rpc.tri.max-concurrent-streams\";\n     String H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY = \"dubbo.rpc.tri.initial-window-size\";\n+    String H2_SETTINGS_CONNECTION_INITIAL_WINDOW_SIZE_KEY = \"dubbo.rpc.tri.connection-initial-window-size\";\n     String H2_SETTINGS_MAX_FRAME_SIZE_KEY = \"dubbo.rpc.tri.max-frame-size\";\n     String H2_SETTINGS_MAX_HEADER_LIST_SIZE_KEY = \"dubbo.rpc.tri.max-header-list-size\";\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java\n@@ -20,6 +20,9 @@\n import org.apache.dubbo.common.config.ConfigurationUtils;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2Connection;\n import io.netty.handler.codec.http2.Http2ConnectionAdapter;\n@@ -34,9 +37,6 @@\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n-import java.util.ArrayDeque;\n-import java.util.Deque;\n-\n import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;\n import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_WEIGHT;\n import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_WEIGHT;\n@@ -49,7 +49,7 @@\n import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;\n import static java.lang.Math.max;\n import static java.lang.Math.min;\n-import static org.apache.dubbo.rpc.Constants.H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY;\n+import static org.apache.dubbo.rpc.Constants.H2_SETTINGS_CONNECTION_INITIAL_WINDOW_SIZE_KEY;\n /**\n  * This design is learning from {@see io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController} which is in Netty.\n@@ -89,7 +89,7 @@ public TriHttp2RemoteFlowController(Http2Connection connection,\n         this.connection = checkNotNull(connection, \"connection\");\n         this.streamByteDistributor = checkNotNull(streamByteDistributor, \"streamWriteDistributor\");\n         this.config = ConfigurationUtils.getGlobalConfiguration(applicationModel);\n-        this.initialWindowSize = config.getInt(H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY, DEFAULT_WINDOW_SIZE);\n+        this.initialWindowSize = config.getInt(H2_SETTINGS_CONNECTION_INITIAL_WINDOW_SIZE_KEY, DEFAULT_WINDOW_SIZE);\n         // Add a flow state for the connection.\n         stateKey = connection.newKey();",
    "output": "Fix tcp connection window size split from stream connection window size"
  },
  {
    "input": "diff --git a/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/brave/BraveAutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/brave/BraveAutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/brave/BraveAutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/brave/BraveAutoConfiguration.java\n@@ -272,6 +272,7 @@ brave.baggage.CorrelationScopeDecorator.Builder mdcCorrelationScopeDecoratorBuil\n                 prefix = ObservabilityUtils.DUBBO_TRACING_BAGGAGE_CORRELATION,\n                 name = \"enabled\",\n                 matchIfMissing = true)\n+        @ConditionalOnMissingBean\n         brave.baggage.CorrelationScopeCustomizer correlationFieldsCorrelationScopeCustomizer() {\n             return (builder) -> {\n                 List<String> correlationFields = this.dubboConfigProperties",
    "output": "Upgrade BraveAutoConfiguration.java The bean 'correlationFieldsCorrelationScopeCustomizer', defined in class path resource [org/apache/dubbo/spring/boot/observability/autoconfigure/brave/BraveAutoConfiguration$BraveBaggageConfiguration.class], could not be registered. A bean with that name has already been defined in class path resource [org/springframework/boot/actuate/autoconfigure/tracing/BravePropagationConfigurations$PropagationWithBaggage.class] and overriding is disabled"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpHeaderNames.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpHeaderNames.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpHeaderNames.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/HttpHeaderNames.java\n@@ -46,7 +46,7 @@ public enum HttpHeaderNames {\n     TE(io.netty.handler.codec.http.HttpHeaderNames.TE),\n-    ALT_SVC(io.netty.handler.codec.http.HttpHeaderNames.ALT_SVC);\n+    ALT_SVC(\"alt-svc\");\n     private final String name;\n     private final CharSequence key;",
    "output": "Fix header names for compatibility with lower versions of Netty"
  },
  {
    "input": "diff --git a/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/WinDubboProtocPluginWrapper.java b/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/WinDubboProtocPluginWrapper.java\n--- a/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/WinDubboProtocPluginWrapper.java\n+++ b/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/WinDubboProtocPluginWrapper.java\n@@ -56,7 +56,7 @@ public File createProtocPlugin(DubboProtocPlugin dubboProtocPlugin, Log log) {\n                 \"jre/bin/client/jvm.dll\",\n                 \"bin/client/jvm.dll\");\n         final File winRun4JIniFile =\n-                new File(dubboProtocPlugin.getPluginDirectory(), dubboProtocPlugin.getId() + \".ini\");\n+                new File(dubboProtocPlugin.getPluginDirectory(), \"protoc-gen-\" + dubboProtocPlugin.getId() + \".ini\");\n         if (winJvmDataModel != null) {\n             if (!(winJvmDataModel.equals(WIN_JVM_DATA_MODEL_32) || winJvmDataModel.equals(WIN_JVM_DATA_MODEL_64))) {",
    "output": "Fix dubbo-maven-plugin failed to run on windows"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LRUCache.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LRUCache.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LRUCache.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LRUCache.java\n@@ -110,6 +110,16 @@ public void clear() {\n         }\n     }\n+    @Override\n+    public V putIfAbsent(K key, V value) {\n+        lock.lock();\n+        try {\n+            return super.putIfAbsent(key, value);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n     public void lock() {\n         lock.lock();\n     }",
    "output": "Fix LRUCache.putIfAbsent concurrent issue"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java\n@@ -94,26 +94,30 @@ private class InternalDecoder extends ByteToMessageDecoder {\n         protected void decode(ChannelHandlerContext ctx, ByteBuf input, List<Object> out) throws Exception {\n             ChannelBuffer message = new NettyBackedChannelBuffer(input);\n-\n-            NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n-\n-            // decode object.\n-            do {\n-                int saveReaderIndex = message.readerIndex();\n-                Object msg = codec.decode(channel, message);\n-                if (msg == Codec2.DecodeResult.NEED_MORE_INPUT) {\n-                    message.readerIndex(saveReaderIndex);\n-                    break;\n-                } else {\n-                    // is it possible to go here ?\n-                    if (saveReaderIndex == message.readerIndex()) {\n-                        throw new IOException(\"Decode without read data.\");\n-                    }\n-                    if (msg != null) {\n-                        out.add(msg);\n+            try {\n+                NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n+\n+                // decode object.\n+                do {\n+                    int saveReaderIndex = message.readerIndex();\n+                    Object msg = codec.decode(channel, message);\n+                    if (msg == Codec2.DecodeResult.NEED_MORE_INPUT) {\n+                        message.readerIndex(saveReaderIndex);\n+                        break;\n+                    } else {\n+                        // is it possible to go here ?\n+                        if (saveReaderIndex == message.readerIndex()) {\n+                            throw new IOException(\"Decode without read data.\");\n+                        }\n+                        if (msg != null) {\n+                            out.add(msg);\n+                        }\n                     }\n-                }\n-            } while (message.readable());\n+                } while (message.readable());\n+            } catch (Throwable t) {\n+                message.skipBytes(message.readableBytes());\n+                throw t;\n+            }\n         }\n     }\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapterTest.java b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapterTest.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapterTest.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapterTest.java\n@@ -19,13 +19,26 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.remoting.ChannelHandler;\n import org.apache.dubbo.remoting.Codec2;\n+import org.apache.dubbo.remoting.Constants;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.netty.buffer.AbstractByteBufAllocator;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.embedded.EmbeddedChannel;\n import io.netty.handler.codec.ByteToMessageDecoder;\n+import io.netty.handler.codec.DecoderException;\n import io.netty.handler.codec.MessageToByteEncoder;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import org.mockito.Mockito;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+\n /**\n  * {@link NettyCodecAdapter}\n  */\n@@ -42,4 +55,30 @@ void test() {\n         Assertions.assertTrue(decoder instanceof ByteToMessageDecoder);\n         Assertions.assertTrue(encoder instanceof MessageToByteEncoder);\n     }\n+\n+    @Test\n+    void testDecodeException() throws IOException {\n+        Codec2 codec2 = Mockito.mock(Codec2.class);\n+        doThrow(new IOException(\"testDecodeIllegalPacket\")).when(codec2).decode(any(), any());\n+\n+        URL url = Mockito.mock(URL.class);\n+        doReturn(\"default\").when(url).getParameter(eq(Constants.CODEC_KEY));\n+\n+        ChannelHandler handler = Mockito.mock(ChannelHandler.class);\n+        NettyCodecAdapter nettyCodecAdapter = new NettyCodecAdapter(codec2, url, handler);\n+        io.netty.channel.ChannelHandler decoder = nettyCodecAdapter.getDecoder();\n+        EmbeddedChannel embeddedChannel = new EmbeddedChannel();\n+        embeddedChannel.pipeline().addLast(decoder);\n+\n+        // simulate illegal data packet\n+        ByteBuf input = AbstractByteBufAllocator.DEFAULT.buffer();\n+        input.writeBytes(\"testDecodeIllegalPacket\".getBytes(StandardCharsets.UTF_8));\n+\n+        DecoderException decoderException = Assertions.assertThrows(DecoderException.class, () -> {\n+            embeddedChannel.writeInbound(input);\n+        });\n+        Assertions.assertTrue(decoderException.getCause() instanceof IOException);\n+\n+        Assertions.assertEquals(0, input.refCnt());\n+    }\n }",
    "output": "Fix NettyCodecAdapter decoder memory leak * fix NettyCodecAdapter decoder memory leak * fix format * update comment"
  },
  {
    "input": "diff --git a/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/enums/DubboGenerateTypeEnum.java b/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/enums/DubboGenerateTypeEnum.java\n--- a/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/enums/DubboGenerateTypeEnum.java\n+++ b/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/enums/DubboGenerateTypeEnum.java\n@@ -17,7 +17,6 @@\n package org.apache.dubbo.maven.plugin.protoc.enums;\n public enum DubboGenerateTypeEnum {\n-    Dubbo3(\"dubbo3\", \"org.apache.dubbo.gen.dubbo.Dubbo3Generator\"),\n     Tri(\"tri\", \"org.apache.dubbo.gen.tri.Dubbo3TripleGenerator\"),\n     Tri_reactor(\"tri_reactor\", \"org.apache.dubbo.gen.tri.reactive.ReactorDubbo3TripleGenerator\"),\n     ;\ndiff --git a/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/dubbo/Dubbo3Generator.java b/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/dubbo/Dubbo3Generator.java\n--- a/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/dubbo/Dubbo3Generator.java\n+++ b/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/dubbo/Dubbo3Generator.java\n@@ -1,57 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.gen.dubbo;\n-\n-import org.apache.dubbo.gen.AbstractGenerator;\n-import org.apache.dubbo.gen.DubboGeneratorPlugin;\n-\n-public class Dubbo3Generator extends AbstractGenerator {\n-\n-    public static void main(String[] args) {\n-        DubboGeneratorPlugin.generate(new Dubbo3Generator());\n-    }\n-\n-    @Override\n-    protected String getClassPrefix() {\n-        return \"\";\n-    }\n-\n-    @Override\n-    protected String getClassSuffix() {\n-        return \"Dubbo\";\n-    }\n-\n-    @Override\n-    protected String getTemplateFileName() {\n-        return \"Dubbo3Stub.mustache\";\n-    }\n-\n-    @Override\n-    protected String getInterfaceTemplateFileName() {\n-        return \"Dubbo3InterfaceStub.mustache\";\n-    }\n-\n-    @Override\n-    protected String getSingleTemplateFileName() {\n-        return \"DubboStub3Single.mustache\";\n-    }\n-\n-    @Override\n-    protected boolean enableMultipleTemplateFiles() {\n-        return true;\n-    }\n-}",
    "output": "Remove old style Dubbo3Generator"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializationTest.java b/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializationTest.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializationTest.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializationTest.java\n@@ -206,7 +206,7 @@ void testReadEvent() throws IOException, ClassNotFoundException {\n     }\n     @Test\n-    void testReadByte() throws IOException, ClassNotFoundException {\n+    void testReadByte() throws IOException {\n         FrameworkModel frameworkModel = new FrameworkModel();\n         Serialization serialization =\n                 frameworkModel.getExtensionLoader(Serialization.class).getExtension(\"hessian2\");\n@@ -219,19 +219,6 @@ void testReadByte() throws IOException, ClassNotFoundException {\n             objectOutput.writeObject((byte) 11);\n             objectOutput.flushBuffer();\n-            byte[] bytes = outputStream.toByteArray();\n-            ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);\n-            ObjectInput objectInput = serialization.deserialize(url, inputStream);\n-            Assertions.assertEquals((byte) 11, objectInput.readObject());\n-        }\n-\n-        // write byte, read byte\n-        {\n-            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-            ObjectOutput objectOutput = serialization.serialize(url, outputStream);\n-            objectOutput.writeByte((byte) 11);\n-            objectOutput.flushBuffer();\n-\n             byte[] bytes = outputStream.toByteArray();\n             ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);\n             ObjectInput objectInput = serialization.deserialize(url, inputStream);",
    "output": "Upgrade hessian-lite from 4.0.1 to 4.0.3 * Update hessian-lite from 4.0.1 to 4.0.3 * Fix ut"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/CtrlCHandler.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/CtrlCHandler.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/CtrlCHandler.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/CtrlCHandler.java\n@@ -23,6 +23,7 @@\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.SimpleChannelInboundHandler;\n import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n public class CtrlCHandler extends SimpleChannelInboundHandler<ByteBuf> {\n     /**\n@@ -41,6 +42,10 @@ public class CtrlCHandler extends SimpleChannelInboundHandler<ByteBuf> {\n     private byte[] RESPONSE_SEQUENCE = new byte[] {(byte) 0xff, (byte) 0xfc, 0x06};\n+    public CtrlCHandler() {\n+        super(false);\n+    }\n+\n     @Override\n     protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {\n         // find ctrl+c\n@@ -63,6 +68,7 @@ protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buffer) throws Ex\n                 ctx.writeAndFlush(Unpooled.wrappedBuffer(\n                         (QosConstants.BR_STR + QosProcessHandler.PROMPT).getBytes(CharsetUtil.UTF_8)));\n+                ReferenceCountUtil.release(buffer);\n                 return;\n             }\n         }",
    "output": "Fix CtrlCHandler release ByteBuf twice"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n@@ -31,6 +31,7 @@\n import org.apache.dubbo.remoting.http12.message.MethodMetadata;\n import org.apache.dubbo.remoting.http12.message.StreamingDecoder;\n import org.apache.dubbo.rpc.RpcInvocation;\n+import org.apache.dubbo.rpc.StatusRpcException;\n import org.apache.dubbo.rpc.TriRpcStatus;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.MethodDescriptor;\n@@ -69,6 +70,9 @@ private void grpcTrailersCustomize(HttpHeaders httpHeaders, Throwable throwable)\n     private static String httpStatusToGrpcStatus(Throwable throwable) {\n         // http status code map to grpc status code\n+        if (throwable instanceof StatusRpcException) {\n+            return String.valueOf(((StatusRpcException) throwable).getStatus().code.code);\n+        }\n         return String.valueOf(TriRpcStatus.INTERNAL.code.code);\n     }",
    "output": "Fix httpStatusToGrpcStatus always return 13 https://github.com/apache/dubbo/issues/14498"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-triple-servlet/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/servlet/ServletHttpResponseAdapter.java b/dubbo-plugin/dubbo-triple-servlet/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/servlet/ServletHttpResponseAdapter.java\n--- a/dubbo-plugin/dubbo-triple-servlet/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/servlet/ServletHttpResponseAdapter.java\n+++ b/dubbo-plugin/dubbo-triple-servlet/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/servlet/ServletHttpResponseAdapter.java\n@@ -29,7 +29,10 @@\n import java.io.BufferedOutputStream;\n import java.io.IOException;\n import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.util.Collection;\n import java.util.Date;\n import java.util.Locale;\n@@ -137,7 +140,9 @@ public ServletOutputStream getOutputStream() {\n     @Override\n     public PrintWriter getWriter() {\n         if (writer == null) {\n-            writer = new PrintWriter(getOutputStream());\n+            String ce = getCharacterEncoding();\n+            Charset charset = ce == null ? StandardCharsets.UTF_8 : Charset.forName(ce);\n+            writer = new PrintWriter(new OutputStreamWriter(outputStream(), charset), true);\n         }\n         return writer;\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n@@ -117,7 +117,7 @@ public void afterUnExport() {\n                 mappingRegistry.unregister(invoker);\n                 // set service status to NOT_SERVING\n-                setServiceStatus(url, ServingStatus.NOT_SERVING);\n+                setServiceStatus(url, false);\n                 exporterMap.remove(key);\n             }\n@@ -134,7 +134,7 @@ public void afterUnExport() {\n         mappingRegistry.register(invoker);\n         // set service status to SERVING\n-        setServiceStatus(url, ServingStatus.SERVING);\n+        setServiceStatus(url, true);\n         // init server executor\n         ExecutorRepository.getInstance(url.getOrDefaultApplicationModel())\n@@ -149,8 +149,9 @@ public void afterUnExport() {\n         return exporter;\n     }\n-    private void setServiceStatus(URL url, ServingStatus status) {\n+    private void setServiceStatus(URL url, boolean serving) {\n         if (triBuiltinService.enable()) {\n+            ServingStatus status = serving ? ServingStatus.SERVING : ServingStatus.NOT_SERVING;\n             triBuiltinService.getHealthStatusManager().setStatus(url.getServiceKey(), status);\n             triBuiltinService.getHealthStatusManager().setStatus(url.getServiceInterface(), status);\n         }",
    "output": "Fix startup failure without pb jar & ServletHttpResponseAdapter not auto flush"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java\n@@ -191,7 +191,7 @@ public void sendMessage(Object message) {\n             data = requestMetadata.packableMethod.packRequest(message);\n             int compressed = Identity.MESSAGE_ENCODING.equals(requestMetadata.compressor.getMessageEncoding()) ? 0 : 1;\n             final byte[] compress = requestMetadata.compressor.compress(data);\n-            stream.sendMessage(compress, compressed, false).addListener(f -> {\n+            stream.sendMessage(compress, compressed).addListener(f -> {\n                 if (!f.isSuccess()) {\n                     cancelByLocal(f.cause());\n                 }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/AbstractTripleClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/AbstractTripleClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/AbstractTripleClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/AbstractTripleClientStream.java\n@@ -146,7 +146,7 @@ public SocketAddress remoteAddress() {\n     }\n     @Override\n-    public ChannelFuture sendMessage(byte[] message, int compressFlag, boolean eos) {\n+    public ChannelFuture sendMessage(byte[] message, int compressFlag) {\n         ChannelFuture checkResult = preCheck();\n         if (!checkResult.isSuccess()) {\n             return checkResult;\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/ClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/ClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/ClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/ClientStream.java\n@@ -62,10 +62,9 @@ default void onComplete(\n      * Send message to remote peer.\n      *\n      * @param message message to send to remote peer\n-     * @param eos     whether this is the last message\n      * @return future to callback when send message is done\n      */\n-    Future<?> sendMessage(byte[] message, int compressFlag, boolean eos);\n+    Future<?> sendMessage(byte[] message, int compressFlag);\n     /**\n      * No more data will be sent, half close this stream to wait server response.\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStreamTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStreamTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStreamTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStreamTest.java\n@@ -100,7 +100,7 @@ void progress() {\n         verify(writeQueue).enqueueFuture(any(HeaderQueueCommand.class), any(Executor.class));\n         // no other commands\n         verify(writeQueue).enqueue(any(QueuedCommand.class));\n-        stream.sendMessage(new byte[0], 0, false);\n+        stream.sendMessage(new byte[0], 0);\n         verify(writeQueue).enqueueFuture(any(DataQueueCommand.class), any(Executor.class));\n         verify(writeQueue, times(2)).enqueueFuture(any(QueuedCommand.class), any(Executor.class));\n         stream.halfClose();",
    "output": "Fix Remove invalid parameters"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ProtocolDetector.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ProtocolDetector.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ProtocolDetector.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ProtocolDetector.java\n@@ -65,6 +65,16 @@ public static Result unrecognized() {\n         public static Result needMoreData() {\n             return new Result(Flag.NEED_MORE_DATA);\n         }\n+\n+        @Override\n+        public int hashCode() {\n+            return flag.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof Result && flag == ((Result) obj).flag;\n+        }\n     }\n     enum Flag {",
    "output": "Fix unit test failure"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboDetectorTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboDetectorTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboDetectorTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboDetectorTest.java\n@@ -28,20 +28,20 @@ class DubboDetectorTest {\n     void testDetect_Recognized() {\n         DubboDetector detector = new DubboDetector();\n         ChannelBuffer in = ChannelBuffers.wrappedBuffer(new byte[] {(byte) 0xda, (byte) 0xbb});\n-        assertEquals(DubboDetector.Result.RECOGNIZED, detector.detect(in));\n+        assertEquals(DubboDetector.Result.recognized(), detector.detect(in));\n     }\n     @Test\n     void testDetect_Unrecognized() {\n         DubboDetector detector = new DubboDetector();\n         ChannelBuffer in = ChannelBuffers.wrappedBuffer(new byte[] {(byte) 0x00, (byte) 0x00});\n-        assertEquals(DubboDetector.Result.UNRECOGNIZED, detector.detect(in));\n+        assertEquals(DubboDetector.Result.unrecognized(), detector.detect(in));\n     }\n     @Test\n     void testDetect_NeedMoreData() {\n         DubboDetector detector = new DubboDetector();\n         ChannelBuffer in = ChannelBuffers.wrappedBuffer(new byte[] {(byte) 0xda});\n-        assertEquals(DubboDetector.Result.NEED_MORE_DATA, detector.detect(in));\n+        assertEquals(DubboDetector.Result.needMoreData(), detector.detect(in));\n     }\n }",
    "output": "Fix compile"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboDetectorTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboDetectorTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboDetectorTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboDetectorTest.java\n@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.dubbo.pu;\n+\n+import org.apache.dubbo.remoting.buffer.ChannelBuffer;\n+import org.apache.dubbo.remoting.buffer.ChannelBuffers;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class DubboDetectorTest {\n+    @Test\n+    void testDetect_Recognized() {\n+        DubboDetector detector = new DubboDetector();\n+        ChannelBuffer in = ChannelBuffers.wrappedBuffer(new byte[] {(byte) 0xda, (byte) 0xbb});\n+        assertEquals(DubboDetector.Result.RECOGNIZED, detector.detect(in));\n+    }\n+\n+    @Test\n+    void testDetect_Unrecognized() {\n+        DubboDetector detector = new DubboDetector();\n+        ChannelBuffer in = ChannelBuffers.wrappedBuffer(new byte[] {(byte) 0x00, (byte) 0x00});\n+        assertEquals(DubboDetector.Result.UNRECOGNIZED, detector.detect(in));\n+    }\n+\n+    @Test\n+    void testDetect_NeedMoreData() {\n+        DubboDetector detector = new DubboDetector();\n+        ChannelBuffer in = ChannelBuffers.wrappedBuffer(new byte[] {(byte) 0xda});\n+        assertEquals(DubboDetector.Result.NEED_MORE_DATA, detector.detect(in));\n+    }\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboWireProtocolTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboWireProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboWireProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/pu/DubboWireProtocolTest.java\n@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.dubbo.pu;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.remoting.ChannelHandler;\n+import org.apache.dubbo.remoting.api.pu.ChannelOperator;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.Mockito.verify;\n+\n+class DubboWireProtocolTest {\n+    @InjectMocks\n+    private DubboWireProtocol dubboWireProtocol;\n+\n+    @Mock\n+    private ChannelOperator channelOperator;\n+\n+    @BeforeEach\n+    void setUp() throws Exception {\n+        MockitoAnnotations.openMocks(this).close();\n+    }\n+\n+    @Test\n+    void testConfigServerProtocolHandler() {\n+        URL url = URL.valueOf(\"dubbo://localhost:20880\");\n+        List<ChannelHandler> handlers = new ArrayList<>();\n+\n+        dubboWireProtocol.configServerProtocolHandler(url, channelOperator);\n+\n+        verify(channelOperator).configChannelHandler(handlers);\n+    }\n+}",
    "output": "Add more test coverage for org.apache.dubbo.rpc.protocol.dubbo.pu * Add more test coverage for org.apache.dubbo.rpc.protocol.dubbo.pu * Add more test coverage for org.apache.dubbo.rpc.protocol.dubbo.pu * Add more test coverage for org.apache.dubbo.rpc.protocol.dubbo.pu * Add more test coverage for org.apache.dubbo.rpc.protocol.dubbo.pu"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n@@ -184,10 +184,9 @@ private void dumpJStack() {\n                     jstack(jStackStream);\n                 } catch (Exception t) {\n                     logger.error(COMMON_UNEXPECTED_CREATE_DUMP, \"\", \"\", \"dump jStack error\", t);\n-                } finally {\n-                    lastPrintTime = System.currentTimeMillis();\n                 }\n             });\n+            lastPrintTime = System.currentTimeMillis();\n         } finally {\n             guard.release();\n             // must shut down thread pool ,if not will lead to OOM\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReportTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReportTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReportTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReportTest.java\n@@ -17,18 +17,26 @@\n package org.apache.dubbo.common.threadpool.support;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;\n import org.apache.dubbo.common.threadpool.event.ThreadPoolExhaustedEvent;\n import org.apache.dubbo.common.threadpool.event.ThreadPoolExhaustedListener;\n import java.io.FileOutputStream;\n+import java.util.LinkedList;\n+import java.util.List;\n import java.util.UUID;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import static org.apache.dubbo.common.constants.CommonConstants.OS_NAME_KEY;\n@@ -37,6 +45,11 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n class AbortPolicyWithReportTest {\n+    @BeforeEach\n+    public void setUp() {\n+        AbortPolicyWithReport.lastPrintTime = 0;\n+    }\n+\n     @Test\n     void jStackDumpTest() {\n         URL url = URL.valueOf(\n@@ -60,6 +73,61 @@ protected void jstack(FileOutputStream jStackStream) {\n         Assertions.assertNotNull(fileOutputStream.get());\n     }\n+    @Test\n+    void jStack_ConcurrencyDump_Silence_10Min() {\n+        URL url = URL.valueOf(\n+                \"dubbo://admin:hello1234@10.20.130.230:20880/context/path?dump.directory=/tmp&version=1.0.0&application=morgan&noValue=\");\n+        AtomicInteger jStackCount = new AtomicInteger(0);\n+        AtomicInteger failureCount = new AtomicInteger(0);\n+        AtomicInteger finishedCount = new AtomicInteger(0);\n+        AtomicInteger timeoutCount = new AtomicInteger(0);\n+        AbortPolicyWithReport abortPolicyWithReport = new AbortPolicyWithReport(\"Test\", url) {\n+            @Override\n+            protected void jstack(FileOutputStream jStackStream) {\n+                jStackCount.incrementAndGet();\n+                // try to simulate the jstack cost long time, so that AbortPolicyWithReport may jstack repeatedly.\n+                long startTime = System.currentTimeMillis();\n+                await().atLeast(200, TimeUnit.MILLISECONDS).until(() -> System.currentTimeMillis() - startTime >= 300);\n+            }\n+        };\n+        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n+                4,\n+                4,\n+                0,\n+                TimeUnit.MILLISECONDS,\n+                new SynchronousQueue<>(),\n+                new NamedInternalThreadFactory(\"jStack_ConcurrencyDump_Silence_10Min\", false),\n+                abortPolicyWithReport);\n+        int runTimes = 100;\n+        List<Future<?>> futureList = new LinkedList<>();\n+        for (int i = 0; i < runTimes; i++) {\n+            try {\n+                futureList.add(threadPoolExecutor.submit(() -> {\n+                    finishedCount.incrementAndGet();\n+                    long start = System.currentTimeMillis();\n+                    // try to await 1s to make sure jstack dump thread scheduled\n+                    await().atLeast(300, TimeUnit.MILLISECONDS).until(() -> System.currentTimeMillis() - start >= 300);\n+                }));\n+            } catch (Exception ignored) {\n+                failureCount.incrementAndGet();\n+            }\n+        }\n+        futureList.forEach(f -> {\n+            try {\n+                f.get(500, TimeUnit.MILLISECONDS);\n+            } catch (Exception ignored) {\n+                timeoutCount.incrementAndGet();\n+            }\n+        });\n+\n+        System.out.printf(\n+                \"jStackCount: %d, finishedCount: %d, failureCount: %d, timeoutCount: %d %n\",\n+                jStackCount.get(), finishedCount.get(), failureCount.get(), timeoutCount.get());\n+        Assertions.assertEquals(\n+                runTimes, finishedCount.get() + failureCount.get(), \"all the test thread should be run completely\");\n+        Assertions.assertEquals(1, jStackCount.get(), \"'jstack' should be called only once in 10 minutes\");\n+    }\n+\n     @Test\n     void jStackDumpTest_dumpDirectoryNotExists_cannotBeCreatedTakeUserHome() {\n         final String dumpDirectory = dumpDirectoryCannotBeCreated();",
    "output": "Fix AbortPolicyWithReport may repeatedly jstack when threadPool is exhausted"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-multicast/src/main/java/org/apache/dubbo/registry/multicast/MulticastRegistry.java b/dubbo-registry/dubbo-registry-multicast/src/main/java/org/apache/dubbo/registry/multicast/MulticastRegistry.java\n--- a/dubbo-registry/dubbo-registry-multicast/src/main/java/org/apache/dubbo/registry/multicast/MulticastRegistry.java\n+++ b/dubbo-registry/dubbo-registry-multicast/src/main/java/org/apache/dubbo/registry/multicast/MulticastRegistry.java\n@@ -91,14 +91,13 @@ public class MulticastRegistry extends FailbackRegistry {\n     private final int cleanPeriod;\n+    private final ApplicationModel applicationModel;\n+\n     private volatile boolean admin = false;\n     public MulticastRegistry(URL url, ApplicationModel applicationModel) {\n-        this(url);\n-    }\n-\n-    public MulticastRegistry(URL url) {\n         super(url);\n+        this.applicationModel = applicationModel;\n         if (url.isAnyHost()) {\n             throw new IllegalStateException(\"registry address == null\");\n         }\n@@ -121,7 +120,7 @@ public MulticastRegistry(URL url) {\n                                 if (i > 0) {\n                                     msg = msg.substring(0, i).trim();\n                                 }\n-                                MulticastRegistry.this.receive(msg, (InetSocketAddress) recv.getSocketAddress());\n+                                receive(msg, (InetSocketAddress) recv.getSocketAddress());\n                                 Arrays.fill(buf, (byte) 0);\n                             } catch (Throwable e) {\n                                 if (!multicastSocket.isClosed()) {\n@@ -159,6 +158,10 @@ public MulticastRegistry(URL url) {\n         }\n     }\n+    public MulticastRegistry(URL url) {\n+        this(url, url.getOrDefaultApplicationModel());\n+    }\n+\n     private void checkMulticastAddress(InetAddress multicastAddress) {\n         if (!multicastAddress.isMulticastAddress()) {\n             String message = \"Invalid multicast address \" + multicastAddress;\n@@ -216,6 +219,10 @@ private void receive(String msg, InetSocketAddress remoteAddress) {\n         if (logger.isInfoEnabled()) {\n             logger.info(\"Receive multicast message: \" + msg + \" from \" + remoteAddress);\n         }\n+        if (applicationModel.isDestroyed()) {\n+            logger.info(\"The applicationModel is destroyed, skip\");\n+            return;\n+        }\n         if (msg.startsWith(REGISTER)) {\n             URL url = URL.valueOf(msg.substring(REGISTER.length()).trim());\n             registered(url);",
    "output": "Fix RegistryDirectory deadlock"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/SpringCloudServiceInstanceNotificationCustomizer.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/SpringCloudServiceInstanceNotificationCustomizer.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/SpringCloudServiceInstanceNotificationCustomizer.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/SpringCloudServiceInstanceNotificationCustomizer.java\n@@ -26,6 +26,8 @@\n import java.util.concurrent.ConcurrentHashMap;\n public class SpringCloudServiceInstanceNotificationCustomizer implements ServiceInstanceNotificationCustomizer {\n+    private static final String REST_PROTOCOL = \"rest\";\n+\n     @Override\n     public void customize(List<ServiceInstance> serviceInstance) {\n         if (serviceInstance.isEmpty()) {\n@@ -38,8 +40,8 @@ public void customize(List<ServiceInstance> serviceInstance) {\n         }\n         for (ServiceInstance instance : serviceInstance) {\n-            MetadataInfo.ServiceInfo serviceInfo =\n-                    new MetadataInfo.ServiceInfo(\"*\", \"*\", \"*\", \"rest\", instance.getPort(), \"*\", new HashMap<>());\n+            MetadataInfo.ServiceInfo serviceInfo = new MetadataInfo.ServiceInfo(\n+                    \"*\", \"*\", \"*\", REST_PROTOCOL, instance.getPort(), \"*\", new HashMap<>());\n             String revision = \"SPRING_CLOUD-\" + instance.getServiceName() + \"-\" + instance.getAddress() + \"-\"\n                     + instance.getPort();\n             MetadataInfo metadataInfo =\n@@ -49,14 +51,24 @@ public void customize(List<ServiceInstance> serviceInstance) {\n                             new ConcurrentHashMap<>(Collections.singletonMap(\"*\", serviceInfo))) {\n                         @Override\n                         public List<ServiceInfo> getMatchedServiceInfos(ProtocolServiceKey consumerProtocolServiceKey) {\n+                            String consumerProtocol = consumerProtocolServiceKey.getProtocol();\n+                            if (consumerProtocol != null && !REST_PROTOCOL.equalsIgnoreCase(consumerProtocol)) {\n+                                return Collections.emptyList();\n+                            }\n+\n+                            String protocol = consumerProtocol;\n+                            if (protocol == null) {\n+                                protocol = REST_PROTOCOL;\n+                            }\n+\n                             getServices()\n                                     .putIfAbsent(\n                                             consumerProtocolServiceKey.getServiceKeyString(),\n                                             new MetadataInfo.ServiceInfo(\n                                                     consumerProtocolServiceKey.getInterfaceName(),\n                                                     consumerProtocolServiceKey.getGroup(),\n                                                     consumerProtocolServiceKey.getVersion(),\n-                                                    consumerProtocolServiceKey.getProtocol(),\n+                                                    protocol,\n                                                     instance.getPort(),\n                                                     consumerProtocolServiceKey.getInterfaceName(),\n                                                     new HashMap<>()));",
    "output": "Fix Resolved issue where ServiceInfo with null protocol was blocking the refresh of invokers"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n@@ -157,8 +157,13 @@ public synchronized void register() throws RuntimeException {\n         }\n         boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance);\n         if (revisionUpdated) {\n-            reportMetadata(this.metadataInfo);\n-            doRegister(this.serviceInstance);\n+            try {\n+                reportMetadata(this.metadataInfo);\n+                doRegister(this.serviceInstance);\n+            } catch (Exception e) {\n+                this.serviceInstance = null;\n+                throw e;\n+            }\n         }\n     }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/ServiceDiscoveryCacheTest.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/ServiceDiscoveryCacheTest.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/ServiceDiscoveryCacheTest.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/ServiceDiscoveryCacheTest.java\n@@ -91,4 +91,35 @@ void test() throws InterruptedException {\n         applicationModel.destroy();\n     }\n+\n+    /**\n+     * to\n+     */\n+    @Test\n+    void testUpdateWhenFirstDoRegisterFail() throws InterruptedException {\n+        ApplicationModel applicationModel = FrameworkModel.defaultModel().newApplication();\n+        applicationModel.getApplicationConfigManager().setApplication(new ApplicationConfig(\"Test\"));\n+\n+        URL registryUrl = URL.valueOf(\"mock://127.0.0.1:12345\").addParameter(METADATA_INFO_CACHE_EXPIRE_KEY, 10);\n+        MockServiceDiscovery mockServiceDiscovery =\n+                Mockito.spy(new MockServiceDiscovery(applicationModel, registryUrl));\n+\n+        mockServiceDiscovery.register(URL.valueOf(\"mock://127.0.0.1:12345\")\n+                .setServiceInterface(\"org.apache.dubbo.registry.service.DemoService\"));\n+\n+        Thread.sleep(100);\n+        Mockito.doThrow(new RuntimeException())\n+                .when(mockServiceDiscovery)\n+                .doRegister(Mockito.any(ServiceInstance.class));\n+        Assertions.assertThrows(RuntimeException.class, mockServiceDiscovery::update);\n+\n+        Thread.sleep(100);\n+        Mockito.doNothing().when(mockServiceDiscovery).doRegister(Mockito.any(ServiceInstance.class));\n+        Assertions.assertDoesNotThrow(mockServiceDiscovery::update);\n+\n+        Thread.sleep(100);\n+        Assertions.assertDoesNotThrow(mockServiceDiscovery::update);\n+\n+        applicationModel.destroy();\n+    }\n }",
    "output": "Fix AbstractServiceDiscovery.update when doRegister first failed"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/GetConfig.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/GetConfig.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/GetConfig.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/GetConfig.java\n@@ -175,6 +175,8 @@ private static void appendConfigs(\n             return;\n         }\n+        id = id == null ? \"(empty)\" : id;\n+\n         plainOutput\n                 .append(type)\n                 .append(\": \")\n@@ -194,6 +196,8 @@ private static void appendConfig(\n             return;\n         }\n+        id = id == null ? \"(empty)\" : id;\n+\n         plainOutput\n                 .append(type)\n                 .append(\": \")\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/GetConfigTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/GetConfigTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/GetConfigTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/GetConfigTest.java\n@@ -74,6 +74,24 @@ void testAll() {\n         Assertions.assertNotNull(new GetConfig(frameworkModel).execute(commandContext, null));\n     }\n+    @Test\n+    void testEmptyId() {\n+        FrameworkModel frameworkModel = new FrameworkModel();\n+        ApplicationModel applicationModel1 = frameworkModel.newApplication();\n+\n+        applicationModel1.getApplicationConfigManager().setApplication(new ApplicationConfig(\"app1\"));\n+\n+        ModuleModel moduleModel = applicationModel1.newModule();\n+        ProviderConfig providerConfig1 = new ProviderConfig();\n+        providerConfig1.setThreadname(\"test\");\n+        moduleModel.getConfigManager().addProvider(providerConfig1);\n+\n+        CommandContext commandContext = new CommandContext(\"getConfig\");\n+        commandContext.setHttp(true);\n+\n+        Assertions.assertNotNull(new GetConfig(frameworkModel).execute(commandContext, null));\n+    }\n+\n     @Test\n     void testFilter1() {\n         FrameworkModel frameworkModel = new FrameworkModel();",
    "output": "Fix null key in QoS * Fix null key * Fix style"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RequestMappingRegisterTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RequestMappingRegisterTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RequestMappingRegisterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/rest/mapping/RequestMappingRegisterTest.java\n@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.tri.rest.mapping;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.utils.ClassUtils;\n+import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.Protocol;\n+import org.apache.dubbo.rpc.ProxyFactory;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.ModuleServiceRepository;\n+import org.apache.dubbo.rpc.model.ProviderModel;\n+import org.apache.dubbo.rpc.model.ServiceDescriptor;\n+import org.apache.dubbo.rpc.model.ServiceMetadata;\n+import org.apache.dubbo.rpc.protocol.tri.TripleProtocol;\n+import org.apache.dubbo.rpc.protocol.tri.support.IGreeter;\n+import org.apache.dubbo.rpc.protocol.tri.support.IGreeterImpl;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests for the RequestMapping registration process.\n+ */\n+public class RequestMappingRegisterTest {\n+    ApplicationModel applicationModel = ApplicationModel.defaultModel();\n+    Invoker<IGreeter> invoker = null;\n+\n+    /**\n+     * Setup method, initializes the testing environment.\n+     * Registers a service provider and creates an Invoker instance for subsequent tests.\n+     */\n+    @BeforeEach\n+    public void setup() {\n+        // Initialize the service implementation\n+        IGreeter serviceImpl = new IGreeterImpl();\n+\n+        // Select an available port\n+        int availablePort = NetUtils.getAvailablePort();\n+\n+        // Construct the provider's URL\n+        URL providerUrl = URL.valueOf(\"http://127.0.0.1:\" + availablePort + \"/\" + IGreeter.class.getName());\n+\n+        // Register the service\n+        ModuleServiceRepository serviceRepository =\n+                applicationModel.getDefaultModule().getServiceRepository();\n+        ServiceDescriptor serviceDescriptor = serviceRepository.registerService(IGreeter.class);\n+\n+        // Construct and register the provider model\n+        ProviderModel providerModel = new ProviderModel(\n+                providerUrl.getServiceKey(),\n+                serviceImpl,\n+                serviceDescriptor,\n+                new ServiceMetadata(),\n+                ClassUtils.getClassLoader(IGreeter.class));\n+        serviceRepository.registerProvider(providerModel);\n+        providerUrl = providerUrl.setServiceModel(providerModel);\n+\n+        // Initialize the protocol and proxy factory\n+        Protocol protocol = new TripleProtocol(providerUrl.getOrDefaultFrameworkModel());\n+        ProxyFactory proxyFactory =\n+                applicationModel.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n+        // Create and export the Invoker\n+        invoker = proxyFactory.getInvoker(serviceImpl, IGreeter.class, providerUrl);\n+        protocol.export(invoker);\n+    }\n+\n+    /**\n+     * Tests whether the service lookup mechanism is functioning properly.\n+     * Ensures that the DefaultRequestMappingRegistry instance can be obtained.\n+     */\n+    @Test\n+    public void testServiceLookup() {\n+        // Obtain the DefaultRequestMappingRegistry instance\n+        DefaultRequestMappingRegistry registry =\n+                applicationModel.getFrameworkModel().getBeanFactory().getBean(DefaultRequestMappingRegistry.class);\n+        assertNotNull(registry, \"The DefaultRequestMappingRegistry should not be null.\");\n+    }\n+}",
    "output": "Add test case"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Constants.java b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Constants.java\n--- a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Constants.java\n+++ b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Constants.java\n@@ -28,10 +28,13 @@ public interface Constants {\n     byte PROTOSTUFF_SERIALIZATION_ID = 12;\n     byte AVRO_SERIALIZATION_ID = 11;\n     byte GSON_SERIALIZATION_ID = 16;\n+    byte JACKSON_SERIALIZATION_ID = 18;\n     byte PROTOBUF_JSON_SERIALIZATION_ID = 21;\n     byte PROTOBUF_SERIALIZATION_ID = 22;\n     byte FASTJSON2_SERIALIZATION_ID = 23;\n     byte KRYO_SERIALIZATION2_ID = 25;\n+    byte MSGPACK_SERIALIZATION_ID = 27;\n+    byte FURY_SERIALIZATION_ID = 28;\n     byte CUSTOM_MESSAGE_PACK_ID = 31;\n }",
    "output": "Add constants"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReportInstance.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReportInstance.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReportInstance.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReportInstance.java\n@@ -115,6 +115,9 @@ private void init(MetadataReportConfig config, MetadataReportFactory metadataRep\n     private String getRelatedRegistryId(MetadataReportConfig config, URL url) {\n         String relatedRegistryId = config.getRegistry();\n+        if (isEmpty(relatedRegistryId)) {\n+            relatedRegistryId = config.getId();\n+        }\n         if (isEmpty(relatedRegistryId)) {\n             relatedRegistryId = DEFAULT_KEY;\n         }",
    "output": "Fix multi registries"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -1104,10 +1104,11 @@ public synchronized void unregister() {\n                                         .getConfiguration()\n                                         .convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)) {\n                                     for (ModuleModel moduleModel : applicationModel.getPubModuleModels()) {\n-                                        if (!moduleModel\n-                                                .getServiceRepository()\n-                                                .getExportedServices()\n-                                                .isEmpty()) {\n+                                        if (null != moduleModel.getServiceRepository()\n+                                                && !moduleModel\n+                                                        .getServiceRepository()\n+                                                        .getExportedServices()\n+                                                        .isEmpty()) {\n                                             moduleModel\n                                                     .getExtensionLoader(GovernanceRuleRepository.class)\n                                                     .getDefaultExtension()",
    "output": "Fix NPE in RegistryProtocol.ExporterChangeableWrapper#unregister when shutting down application * Update RegistryProtocol.java fix NPE in unregister * formating ---------"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n@@ -36,6 +36,7 @@\n import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.RpcInvocation;\n+import org.apache.dubbo.rpc.model.ConsumerModel;\n import org.apache.dubbo.rpc.model.MethodDescriptor;\n import org.apache.dubbo.rpc.model.ServiceModel;\n import org.apache.dubbo.rpc.protocol.AbstractInvoker;\n@@ -317,11 +318,18 @@ private Object rebuildValue(Invocation invocation, Invoker<?> invoker, Object or\n         }\n         Object value = originValue;\n-        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n+        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n         try {\n-            ServiceModel consumerServiceModel = getUrl().getServiceModel();\n-            if (consumerServiceModel != null) {\n-                Thread.currentThread().setContextClassLoader(consumerServiceModel.getClassLoader());\n+            // 1. By default, the classloader of the current Thread is the consumer class loader.\n+            ClassLoader consumerClassLoader = contextClassLoader;\n+            ServiceModel serviceModel = getUrl().getServiceModel();\n+            // 2. If there is a ConsumerModel in the url, the classloader of the ConsumerModel is consumerLoader\n+            if (Objects.nonNull(serviceModel) && serviceModel instanceof ConsumerModel) {\n+                consumerClassLoader = serviceModel.getClassLoader();\n+            }\n+            // 3. request result copy\n+            if (Objects.nonNull(consumerClassLoader)) {\n+                Thread.currentThread().setContextClassLoader(consumerClassLoader);\n                 Type[] returnTypes = RpcUtils.getReturnTypes(invocation);\n                 if (returnTypes == null) {\n                     return originValue;\n@@ -334,7 +342,7 @@ private Object rebuildValue(Invocation invocation, Invoker<?> invoker, Object or\n             }\n             return value;\n         } finally {\n-            Thread.currentThread().setContextClassLoader(cl);\n+            Thread.currentThread().setContextClassLoader(contextClassLoader);\n         }\n     }",
    "output": "Fix injvm invoker throws ClassCastException * fix injvm invoker throws ClassCastException * fix unit test * fix unit test * fix NPE ---------"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/exporter/zipkin/ZipkinSpanExporter.java b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/exporter/zipkin/ZipkinSpanExporter.java\n--- a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/exporter/zipkin/ZipkinSpanExporter.java\n+++ b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/exporter/zipkin/ZipkinSpanExporter.java\n@@ -20,8 +20,8 @@\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import zipkin2.Span;\n-import zipkin2.codec.BytesEncoder;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.BytesEncoder;\n+import zipkin2.reporter.SpanBytesEncoder;\n /**\n  * Zipkin span exporter for OTel.\n@@ -30,8 +30,9 @@ public class ZipkinSpanExporter {\n     public static io.opentelemetry.sdk.trace.export.SpanExporter getSpanExporter(\n             ApplicationModel applicationModel, ExporterConfig.ZipkinConfig zipkinConfig) {\n+        BytesEncoder<Span> spanBytesEncoder = getSpanBytesEncoder(applicationModel);\n         return io.opentelemetry.exporter.zipkin.ZipkinSpanExporter.builder()\n-                .setEncoder(getSpanBytesEncoder(applicationModel))\n+                .setEncoder(spanBytesEncoder)\n                 .setEndpoint(zipkinConfig.getEndpoint())\n                 .setReadTimeout(zipkinConfig.getReadTimeout())\n                 .build();\ndiff --git a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/exporter/zipkin/ZipkinSpanHandler.java b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/exporter/zipkin/ZipkinSpanHandler.java\n--- a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/exporter/zipkin/ZipkinSpanHandler.java\n+++ b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/exporter/zipkin/ZipkinSpanHandler.java\n@@ -21,9 +21,9 @@\n import brave.handler.SpanHandler;\n import zipkin2.Span;\n-import zipkin2.codec.BytesEncoder;\n-import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.AsyncReporter;\n+import zipkin2.reporter.BytesEncoder;\n+import zipkin2.reporter.SpanBytesEncoder;\n import zipkin2.reporter.urlconnection.URLConnectionSender;\n /**\n@@ -43,7 +43,8 @@ public static SpanHandler getSpanHandler(\n             sender = builder.build();\n         }\n-        AsyncReporter<Span> spanReporter = AsyncReporter.builder(sender).build(getSpanBytesEncoder(applicationModel));\n+        BytesEncoder<Span> spanBytesEncoder = getSpanBytesEncoder(applicationModel);\n+        AsyncReporter<Span> spanReporter = AsyncReporter.builder(sender).build(spanBytesEncoder);\n         return zipkin2.reporter.brave.ZipkinSpanHandler.newBuilder(spanReporter).build();\n     }",
    "output": "Upgrade opentelemetry and zipkin-reporter version *  upgrade zipkin-reporter -> 3.4.0 *  upgrade opentelemetry -> 1.39.0"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/aot/HessianReflectionTypeDescriberRegistrar.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/aot/HessianReflectionTypeDescriberRegistrar.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/aot/HessianReflectionTypeDescriberRegistrar.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/aot/HessianReflectionTypeDescriberRegistrar.java\n@@ -20,67 +20,50 @@\n import org.apache.dubbo.aot.api.ReflectionTypeDescriberRegistrar;\n import org.apache.dubbo.aot.api.TypeDescriber;\n+import java.net.URL;\n import java.sql.Date;\n import java.sql.Time;\n import java.sql.Timestamp;\n import java.util.ArrayList;\n+import java.util.Enumeration;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Properties;\n import java.util.Set;\n-import com.alibaba.com.caucho.hessian.io.BigDecimalDeserializer;\n-import com.alibaba.com.caucho.hessian.io.FileDeserializer;\n-import com.alibaba.com.caucho.hessian.io.HessianRemote;\n-import com.alibaba.com.caucho.hessian.io.LocaleSerializer;\n-import com.alibaba.com.caucho.hessian.io.ObjectNameDeserializer;\n-import com.alibaba.com.caucho.hessian.io.StringValueSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.DurationSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.InstantSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.LocalDateSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.LocalDateTimeSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.LocalTimeSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.MonthDaySerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.OffsetDateTimeSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.OffsetTimeSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.PeriodSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.YearMonthSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.YearSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.ZoneIdSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.ZoneOffsetSerializer;\n-import com.alibaba.com.caucho.hessian.io.java8.ZonedDateTimeSerializer;\n-\n public class HessianReflectionTypeDescriberRegistrar implements ReflectionTypeDescriberRegistrar {\n     @Override\n     public List<TypeDescriber> getTypeDescribers() {\n         List<TypeDescriber> typeDescribers = new ArrayList<>();\n-        typeDescribers.add(buildTypeDescriberWithDeclared(BigDecimalDeserializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(FileDeserializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(HessianRemote.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(LocaleSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(ObjectNameDeserializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(StringValueSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(DurationSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(InstantSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(LocalDateSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(LocalDateTimeSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(LocalTimeSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(MonthDaySerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(OffsetDateTimeSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(OffsetTimeSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(PeriodSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(YearMonthSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(YearSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(ZoneIdSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(ZoneOffsetSerializer.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclared(ZonedDateTimeSerializer.class));\n+\n+        loadFile(\"META-INF/dubbo/hessian/deserializers\", typeDescribers);\n+        loadFile(\"META-INF/dubbo/hessian/serializers\", typeDescribers);\n+\n         typeDescribers.add(buildTypeDescriberWithDeclared(Date.class));\n         typeDescribers.add(buildTypeDescriberWithDeclared(Time.class));\n         typeDescribers.add(buildTypeDescriberWithDeclared(Timestamp.class));\n         return typeDescribers;\n     }\n+    private void loadFile(String path, List<TypeDescriber> typeDescribers) {\n+        try {\n+            Enumeration<URL> resources = this.getClass().getClassLoader().getResources(path);\n+            while (resources.hasMoreElements()) {\n+                URL url = resources.nextElement();\n+                Properties props = new Properties();\n+                props.load(url.openStream());\n+                for (Object value : props.values()) {\n+                    String className = (String) value;\n+                    typeDescribers.add(buildTypeDescriberWithDeclared(className));\n+                }\n+            }\n+        } catch (Throwable t) {\n+            // ignore\n+        }\n+    }\n+\n     private TypeDescriber buildTypeDescriberWithDeclared(Class<?> cl) {\n         Set<MemberCategory> memberCategories = new HashSet<>();\n         memberCategories.add(MemberCategory.INVOKE_DECLARED_METHODS);",
    "output": "Upgrade hessian-lite to 4.0.1 * Update hessian-lite to 4.0.1 * Fix style"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/WrapperHttpMessageCodec.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/WrapperHttpMessageCodec.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/WrapperHttpMessageCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/WrapperHttpMessageCodec.java\n@@ -24,7 +24,9 @@\n import org.apache.dubbo.remoting.http12.exception.EncodeException;\n import org.apache.dubbo.remoting.http12.message.HttpMessageCodec;\n import org.apache.dubbo.remoting.http12.message.MediaType;\n+import org.apache.dubbo.remoting.transport.CodecSupport;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n+import org.apache.dubbo.rpc.protocol.tri.TripleConstant;\n import org.apache.dubbo.rpc.protocol.tri.TripleCustomerProtocolWapper;\n import java.io.ByteArrayInputStream;\n@@ -112,6 +114,8 @@ public Object[] decode(InputStream inputStream, Class<?>[] targetTypes, Charset\n             }\n             TripleCustomerProtocolWapper.TripleRequestWrapper wrapper =\n                     TripleCustomerProtocolWapper.TripleRequestWrapper.parseFrom(bos.toByteArray());\n+            final String serializeType = convertHessianFromWrapper(wrapper.getSerializeType());\n+            CodecSupport.checkSerialization(serializeType, url);\n             setSerializeType(wrapper.getSerializeType());\n             Object[] ret = new Object[wrapper.getArgs().size()];\n             for (int i = 0; i < wrapper.getArgs().size(); i++) {\n@@ -140,4 +144,11 @@ private static void writeLength(OutputStream outputStream, int length) throws IO\n         outputStream.write(((length >> 8) & 0xFF));\n         outputStream.write((length & 0xFF));\n     }\n+\n+    private static String convertHessianFromWrapper(String serializeType) {\n+        if (TripleConstant.HESSIAN4.equals(serializeType)) {\n+            return TripleConstant.HESSIAN2;\n+        }\n+        return serializeType;\n+    }\n }",
    "output": "Add serialization check"
  },
  {
    "input": "diff --git a/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboRelaxedBinding2AutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboRelaxedBinding2AutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboRelaxedBinding2AutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboRelaxedBinding2AutoConfiguration.java\n@@ -51,7 +51,7 @@\n  * @see DubboRelaxedBindingAutoConfiguration\n  * @since 2.7.0\n  */\n-@Configuration\n+@Configuration(proxyBeanMethods = false)\n @ConditionalOnProperty(prefix = DUBBO_PREFIX, name = \"enabled\", matchIfMissing = true)\n @ConditionalOnClass(name = \"org.springframework.boot.context.properties.bind.Binder\")\n @AutoConfigureBefore(DubboRelaxedBindingAutoConfiguration.class)\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboAutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboAutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboAutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboAutoConfiguration.java\n@@ -62,7 +62,7 @@ public class DubboAutoConfiguration {\n     @ConditionalOnProperty(prefix = DUBBO_SCAN_PREFIX, name = BASE_PACKAGES_PROPERTY_NAME)\n     @ConditionalOnBean(name = BASE_PACKAGES_BEAN_NAME)\n     @Bean\n-    public ServiceAnnotationPostProcessor serviceAnnotationBeanProcessor(\n+    public static ServiceAnnotationPostProcessor serviceAnnotationBeanProcessor(\n             @Qualifier(BASE_PACKAGES_BEAN_NAME) Set<String> packagesToScan) {\n         return new ServiceAnnotationPostProcessor(packagesToScan);\n     }",
    "output": "Fix DubboRelaxedBinding2AutoConfiguration and DubboAutoConfiguration created too early"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/util/CuratorFrameworkUtils.java b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/util/CuratorFrameworkUtils.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/util/CuratorFrameworkUtils.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/util/CuratorFrameworkUtils.java\n@@ -43,6 +43,7 @@\n import static org.apache.curator.x.discovery.ServiceInstance.builder;\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_SEPARATOR;\n+import static org.apache.dubbo.common.constants.CommonConstants.ZOOKEEPER_ENSEMBLE_TRACKER_KEY;\n import static org.apache.dubbo.registry.zookeeper.ZookeeperServiceDiscovery.DEFAULT_GROUP;\n import static org.apache.dubbo.registry.zookeeper.util.CuratorFrameworkParams.BASE_SLEEP_TIME;\n import static org.apache.dubbo.registry.zookeeper.util.CuratorFrameworkParams.BLOCK_UNTIL_CONNECTED_UNIT;\n@@ -69,8 +70,10 @@ public static ServiceDiscovery<ZookeeperInstance> buildServiceDiscovery(\n     public static CuratorFramework buildCuratorFramework(URL connectionURL, ZookeeperServiceDiscovery serviceDiscovery)\n             throws Exception {\n+        boolean ensembleTracker = connectionURL.getParameter(ZOOKEEPER_ENSEMBLE_TRACKER_KEY, true);\n         CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()\n                 .connectString(connectionURL.getBackupAddress())\n+                .ensembleTracker(ensembleTracker)\n                 .retryPolicy(buildRetryPolicy(connectionURL));\n         String userInformation = connectionURL.getUserInformation();\n         if (StringUtils.isNotEmpty(userInformation)) {",
    "output": "Fix Support disable Curator EnsembleTracker in ServiceDiscovery"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -646,4 +646,6 @@ public interface CommonConstants {\n     String DUBBO_MANUAL_REGISTER_KEY = \"dubbo.application.manual-register\";\n     String DUBBO2_COMPACT_ENABLE = \"dubbo.compact.enable\";\n+\n+    String ZOOKEEPER_ENSEMBLE_TRACKER_KEY = \"zookeeper.ensemble.tracker\";\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/zookeeper/AbstractZookeeperClient.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/zookeeper/AbstractZookeeperClient.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/zookeeper/AbstractZookeeperClient.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/zookeeper/AbstractZookeeperClient.java\n@@ -40,6 +40,7 @@ public abstract class AbstractZookeeperClient<TargetDataListener, TargetChildLis\n     // may hang up to wait name resolution up to 10s\n     protected int DEFAULT_CONNECTION_TIMEOUT_MS = 30 * 1000;\n     protected int DEFAULT_SESSION_TIMEOUT_MS = 60 * 1000;\n+    protected boolean DEFAULT_ENSEMBLE_TRACKER = true;\n     private final URL url;\ndiff --git a/dubbo-remoting/dubbo-remoting-zookeeper-curator5/src/main/java/org/apache/dubbo/remoting/zookeeper/curator5/Curator5ZookeeperClient.java b/dubbo-remoting/dubbo-remoting-zookeeper-curator5/src/main/java/org/apache/dubbo/remoting/zookeeper/curator5/Curator5ZookeeperClient.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper-curator5/src/main/java/org/apache/dubbo/remoting/zookeeper/curator5/Curator5ZookeeperClient.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper-curator5/src/main/java/org/apache/dubbo/remoting/zookeeper/curator5/Curator5ZookeeperClient.java\n@@ -55,6 +55,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.SESSION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.ZOOKEEPER_ENSEMBLE_TRACKER_KEY;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_CONNECT_REGISTRY;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_ZOOKEEPER_EXCEPTION;\n@@ -74,10 +75,12 @@ public Curator5ZookeeperClient(URL url) {\n         try {\n             int timeout = url.getParameter(TIMEOUT_KEY, DEFAULT_CONNECTION_TIMEOUT_MS);\n             int sessionExpireMs = url.getParameter(SESSION_KEY, DEFAULT_SESSION_TIMEOUT_MS);\n+            boolean ensembleTracker = url.getParameter(ZOOKEEPER_ENSEMBLE_TRACKER_KEY, DEFAULT_ENSEMBLE_TRACKER);\n             CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()\n                     .connectString(url.getBackupAddress())\n                     .retryPolicy(new RetryNTimes(1, 1000))\n                     .connectionTimeoutMs(timeout)\n+                    .ensembleTracker(ensembleTracker)\n                     .sessionTimeoutMs(sessionExpireMs);\n             String userInformation = url.getUserInformation();\n             if (userInformation != null && userInformation.length() > 0) {",
    "output": "Fix Support close the Curator EnsembleTracker"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n--- a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n+++ b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n@@ -48,13 +48,11 @@ private ReactorServerCalls() {}\n     public static <T, R> void oneToOne(T request, StreamObserver<R> responseObserver, Function<Mono<T>, Mono<R>> func) {\n         try {\n             func.apply(Mono.just(request))\n+                    .switchIfEmpty(Mono.error(TriRpcStatus.NOT_FOUND.asException()))\n                     .subscribe(\n-                            res -> {\n-                                responseObserver.onNext(res);\n-                                responseObserver.onCompleted();\n-                            },\n+                            responseObserver::onNext,\n                             throwable -> doOnResponseHasException(throwable, responseObserver),\n-                            () -> doOnResponseHasException(TriRpcStatus.NOT_FOUND.asException(), responseObserver));\n+                            responseObserver::onCompleted);\n         } catch (Throwable throwable) {\n             doOnResponseHasException(throwable, responseObserver);\n         }",
    "output": "Fix triple reactor call throws \"Too many response for unary method\" exception"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h1/Http1OutputMessage.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h1/Http1OutputMessage.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h1/Http1OutputMessage.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h1/Http1OutputMessage.java\n@@ -18,11 +18,8 @@\n import org.apache.dubbo.remoting.http12.HttpOutputMessage;\n-import java.io.IOException;\n import java.io.OutputStream;\n-import io.netty.buffer.ByteBufOutputStream;\n-\n public class Http1OutputMessage implements HttpOutputMessage {\n     private final OutputStream outputStream;\n@@ -35,12 +32,4 @@ public Http1OutputMessage(OutputStream outputStream) {\n     public OutputStream getBody() {\n         return outputStream;\n     }\n-\n-    @Override\n-    public void close() throws IOException {\n-        if (outputStream instanceof ByteBufOutputStream) {\n-            ((ByteBufOutputStream) outputStream).buffer().release();\n-        }\n-        outputStream.close();\n-    }\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2OutputMessageFrame.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2OutputMessageFrame.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2OutputMessageFrame.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2OutputMessageFrame.java\n@@ -16,11 +16,8 @@\n  */\n package org.apache.dubbo.remoting.http12.h2;\n-import java.io.IOException;\n import java.io.OutputStream;\n-import io.netty.buffer.ByteBufOutputStream;\n-\n public class Http2OutputMessageFrame implements Http2OutputMessage {\n     private final OutputStream body;\n@@ -45,14 +42,6 @@ public OutputStream getBody() {\n         return body;\n     }\n-    @Override\n-    public void close() throws IOException {\n-        if (body instanceof ByteBufOutputStream) {\n-            ((ByteBufOutputStream) body).buffer().release();\n-        }\n-        body.close();\n-    }\n-\n     @Override\n     public boolean isEndStream() {\n         return endStream;\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h1/NettyHttp1Channel.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h1/NettyHttp1Channel.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h1/NettyHttp1Channel.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h1/NettyHttp1Channel.java\n@@ -52,7 +52,7 @@ public CompletableFuture<Void> writeMessage(HttpOutputMessage httpOutputMessage)\n     @Override\n     public HttpOutputMessage newOutputMessage() {\n-        return new Http1OutputMessage(new ByteBufOutputStream(channel.alloc().buffer()));\n+        return new Http1OutputMessage(new ByteBufOutputStream(channel.alloc().buffer(), true));\n     }\n     @Override\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h2/NettyH2StreamChannel.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h2/NettyH2StreamChannel.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h2/NettyH2StreamChannel.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h2/NettyH2StreamChannel.java\n@@ -57,7 +57,7 @@ public CompletableFuture<Void> writeMessage(HttpOutputMessage httpOutputMessage)\n     @Override\n     public Http2OutputMessage newOutputMessage(boolean endStream) {\n         ByteBuf buffer = http2StreamChannel.alloc().buffer();\n-        ByteBufOutputStream outputStream = new ByteBufOutputStream(buffer);\n+        ByteBufOutputStream outputStream = new ByteBufOutputStream(buffer, true);\n         return new Http2OutputMessageFrame(outputStream, endStream);\n     }",
    "output": "Use releaseOnClose to release the ByteBuf when the output stream is closed"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java\n@@ -108,7 +108,7 @@ public AccessLogFilter() {}\n     public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {\n         String accessLogKey = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);\n         boolean isFixedPath = invoker.getUrl().getParameter(ACCESS_LOG_FIXED_PATH_KEY, true);\n-        if (StringUtils.isEmpty(accessLogKey)) {\n+        if (StringUtils.isEmpty(accessLogKey) || \"false\".equalsIgnoreCase(accessLogKey)) {\n             // Notice that disable accesslog of one service may cause the whole application to stop collecting\n             // accesslog.\n             // It's recommended to use application level configuration to enable or disable accesslog if dynamically",
    "output": "Fix Disable accesslog while the config is false"
  },
  {
    "input": "diff --git a/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/HttpSender.java b/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/HttpSender.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/HttpSender.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/HttpSender.java\n@@ -25,11 +25,11 @@\n import org.springframework.http.HttpHeaders;\n import org.springframework.util.unit.DataSize;\n-import zipkin2.Call;\n-import zipkin2.CheckResult;\n-import zipkin2.codec.Encoding;\n import zipkin2.reporter.BytesMessageEncoder;\n+import zipkin2.reporter.Call;\n+import zipkin2.reporter.CheckResult;\n import zipkin2.reporter.ClosedSenderException;\n+import zipkin2.reporter.Encoding;\n import zipkin2.reporter.Sender;\n /**\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinConfigurations.java b/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinConfigurations.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinConfigurations.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinConfigurations.java\n@@ -134,7 +134,7 @@ static class ReporterConfiguration {\n         @ConditionalOnMissingBean\n         @ConditionalOnBean(Sender.class)\n         AsyncReporter<Span> spanReporter(Sender sender, BytesEncoder<Span> encoder) {\n-            return AsyncReporter.builder(sender).build(encoder);\n+            return AsyncReporter.builder(sender).build((zipkin2.reporter.BytesEncoder<Span>) encoder);\n         }\n     }\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinRestTemplateSender.java b/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinRestTemplateSender.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinRestTemplateSender.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinRestTemplateSender.java\n@@ -19,8 +19,8 @@\n import org.springframework.http.HttpEntity;\n import org.springframework.http.HttpMethod;\n import org.springframework.web.client.RestTemplate;\n-import zipkin2.Call;\n-import zipkin2.Callback;\n+import zipkin2.reporter.Call;\n+import zipkin2.reporter.Callback;\n class ZipkinRestTemplateSender extends HttpSender {\n     private final String endpoint;\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinWebClientSender.java b/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinWebClientSender.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinWebClientSender.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-starters/observability/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinWebClientSender.java\n@@ -20,8 +20,8 @@\n import org.springframework.http.ResponseEntity;\n import org.springframework.web.reactive.function.client.WebClient;\n import reactor.core.publisher.Mono;\n-import zipkin2.Call;\n-import zipkin2.Callback;\n+import zipkin2.reporter.Call;\n+import zipkin2.reporter.Callback;\n class ZipkinWebClientSender extends HttpSender {\n     private final String endpoint;",
    "output": "Fix opentelemetry version change * fix opentelemetry version change * format code"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Ls.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Ls.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Ls.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Ls.java\n@@ -26,6 +26,8 @@\n import org.apache.dubbo.rpc.model.ProviderModel;\n import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.stream.Collectors;\n @Cmd(\n         name = \"ls\",\n@@ -53,6 +55,11 @@ public String listProvider() {\n         Collection<ProviderModel> providerModelList =\n                 frameworkModel.getServiceRepository().allProviderModels();\n+        // Fix: Originally, providers were stored in ConcurrentHashMap, Disordered display of servicekey list\n+        providerModelList = providerModelList.stream()\n+                .sorted(Comparator.comparing(ProviderModel::getServiceKey))\n+                .collect(Collectors.toList());\n+\n         TTable tTable = new TTable(new TTable.ColumnDefine[] {\n             new TTable.ColumnDefine(TTable.Align.MIDDLE), new TTable.ColumnDefine(TTable.Align.MIDDLE)\n         });\n@@ -81,6 +88,11 @@ public String listConsumer() {\n         Collection<ConsumerModel> consumerModelList =\n                 frameworkModel.getServiceRepository().allConsumerModels();\n+        // Fix: Originally, consumers were stored in ConcurrentHashMap, Disordered display of servicekey list\n+        consumerModelList = consumerModelList.stream()\n+                .sorted(Comparator.comparing(ConsumerModel::getServiceKey))\n+                .collect(Collectors.toList());\n+\n         TTable tTable = new TTable(new TTable.ColumnDefine[] {\n             new TTable.ColumnDefine(TTable.Align.MIDDLE), new TTable.ColumnDefine(TTable.Align.MIDDLE)\n         });",
    "output": "Fix telnet list command, the service list is displayed unordered fix * fix telnet list command, the service list is displayed unordered  * format code * remove useless code * remove useless code"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/annotation/param/parse/provider/ProviderParseContext.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/annotation/param/parse/provider/ProviderParseContext.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/annotation/param/parse/provider/ProviderParseContext.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/annotation/param/parse/provider/ProviderParseContext.java\n@@ -57,7 +57,6 @@ public void setRequest(Object request) {\n     public String getPathVariable(int urlSplitIndex) {\n         String[] split = getRequestFacade().getRequestURI().split(\"/\");\n-\n-        return split[urlSplitIndex];\n+        return split[urlSplitIndex].split(\"\\\\?\")[0];\n     }\n }",
    "output": "Fix when url has param with question mark,parse param wrong"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/json/impl/FastJson2Impl.java b/dubbo-common/src/main/java/org/apache/dubbo/common/json/impl/FastJson2Impl.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/json/impl/FastJson2Impl.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/json/impl/FastJson2Impl.java\n@@ -29,6 +29,7 @@ public boolean isJson(String json) {\n         JSONValidator validator = JSONValidator.from(json);\n         return validator.validate();\n     }\n+\n     @Override\n     public <T> T toJavaObject(String json, Type type) {\n         return com.alibaba.fastjson2.JSON.parseObject(json, type);\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java\n@@ -36,8 +36,8 @@ void isSupportPrometheus() {\n     void isImportPrometheus() {\n         MetricsConfig metricsConfig = new MetricsConfig();\n         metricsConfig.setProtocol(\"prometheus\");\n-        boolean importPrometheus = PROTOCOL_PROMETHEUS.equals(metricsConfig.getProtocol())\n-                && !MetricsSupportUtil.isSupportPrometheus();\n+        boolean importPrometheus =\n+                PROTOCOL_PROMETHEUS.equals(metricsConfig.getProtocol()) && !MetricsSupportUtil.isSupportPrometheus();\n         Assert.assertTrue(!importPrometheus, \" should return false\");\n     }\n }",
    "output": "Fix codestyle"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java\n@@ -37,7 +37,7 @@ void isImportPrometheus() {\n         MetricsConfig metricsConfig = new MetricsConfig();\n         metricsConfig.setProtocol(\"prometheus\");\n         boolean importPrometheus = PROTOCOL_PROMETHEUS.equals(metricsConfig.getProtocol())\n-                && !DefaultApplicationDeployer.isSupportPrometheus();\n+                && !MetricsSupportUtil.isSupportPrometheus();\n         Assert.assertTrue(!importPrometheus, \" should return false\");\n     }\n }",
    "output": "Fix dubbo-test-spring & Metrics"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -389,7 +389,7 @@ private void initMetricsReporter() {\n         Optional<MetricsConfig> configOptional = configManager.getMetrics();\n         // If no specific metrics type is configured and there is no Prometheus dependency in the dependencies.\n         MetricsConfig metricsConfig = configOptional.orElse(new MetricsConfig(applicationModel));\n-        if (PROTOCOL_PROMETHEUS.equals(metricsConfig.getProtocol()) && !isSupportPrometheus()) {\n+        if (PROTOCOL_PROMETHEUS.equals(metricsConfig.getProtocol()) && !MetricsSupportUtil.isSupportPrometheus()) {\n             return;\n         }\n         if (StringUtils.isBlank(metricsConfig.getProtocol())) {",
    "output": "Fix build error"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java b/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n--- a/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n+++ b/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n@@ -250,7 +250,8 @@ void testWrongAuthRedisMetadata() throws ClassNotFoundException {\n             if (e.getCause() instanceof JedisConnectionException\n                     && e.getCause().getCause() instanceof JedisDataException) {\n                 Assertions.assertEquals(\n-                        \"ERR invalid password\", e.getCause().getCause().getMessage());\n+                        \"WRONGPASS invalid username-password pair or user is disabled.\",\n+                        e.getCause().getCause().getMessage());\n             } else {\n                 Assertions.fail(\"no invalid password exception!\");\n             }",
    "output": "Fix embedded-redis need update version to run on macos Sonoma"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -382,6 +382,9 @@ private void initMetricsReporter() {\n         Optional<MetricsConfig> configOptional = configManager.getMetrics();\n         // If no specific metrics type is configured and there is no Prometheus dependency in the dependencies.\n         MetricsConfig metricsConfig = configOptional.orElse(new MetricsConfig(applicationModel));\n+        if (PROTOCOL_PROMETHEUS.equals(metricsConfig.getProtocol()) && !isSupportPrometheus()) {\n+            return;\n+        }\n         if (StringUtils.isBlank(metricsConfig.getProtocol())) {\n             metricsConfig.setProtocol(isSupportPrometheus() ? PROTOCOL_PROMETHEUS : PROTOCOL_DEFAULT);\n         }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployerTest.java\n@@ -17,10 +17,13 @@\n package org.apache.dubbo.config.deploy;\n import org.apache.dubbo.common.utils.Assert;\n+import org.apache.dubbo.config.MetricsConfig;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.junit.jupiter.api.Test;\n+import static org.apache.dubbo.common.constants.MetricsConstants.PROTOCOL_PROMETHEUS;\n+\n class DefaultApplicationDeployerTest {\n     @Test\n@@ -29,4 +32,13 @@ void isSupportPrometheus() {\n                 new DefaultApplicationDeployer(ApplicationModel.defaultModel()).isSupportPrometheus();\n         Assert.assertTrue(supportPrometheus, \"DefaultApplicationDeployer.isSupportPrometheus() should return true\");\n     }\n+\n+    @Test\n+    void isImportPrometheus() {\n+        MetricsConfig metricsConfig = new MetricsConfig();\n+        metricsConfig.setProtocol(\"prometheus\");\n+        boolean importPrometheus = PROTOCOL_PROMETHEUS.equals(metricsConfig.getProtocol())\n+                && !DefaultApplicationDeployer.isSupportPrometheus();\n+        Assert.assertTrue(!importPrometheus, \" should return false\");\n+    }\n }",
    "output": "Fix not initialize MetricsReporter if not support prometheus * fix: not initialize if not support prometheus * add method isImportPrometheus test ---------"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -34,7 +34,6 @@\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ScopeModelAware;\n-import org.apache.dubbo.rpc.protocol.tri.h12.HttpServerAfterUpgradeHandler;\n import org.apache.dubbo.rpc.protocol.tri.h12.TripleProtocolDetector;\n import org.apache.dubbo.rpc.protocol.tri.h12.http1.DefaultHttp11ServerTransportListenerFactory;\n import org.apache.dubbo.rpc.protocol.tri.h12.http2.GenericHttp2ServerTransportListenerFactory;\n@@ -160,7 +159,6 @@ private void configurerHttp1Handlers(URL url, List<ChannelHandler> handlers) {\n                                 ConfigurationUtils.getGlobalConfiguration(url.getOrDefaultApplicationModel());\n                         return new Http2ServerUpgradeCodec(\n                                 buildHttp2FrameCodec(config, url.getOrDefaultApplicationModel()),\n-                                new HttpServerAfterUpgradeHandler(),\n                                 new HttpWriteQueueHandler(),\n                                 new FlushConsolidationHandler(64, true),\n                                 new TripleServerConnectionHandler(),\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/HttpServerAfterUpgradeHandler.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/HttpServerAfterUpgradeHandler.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/HttpServerAfterUpgradeHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/HttpServerAfterUpgradeHandler.java\n@@ -1,69 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.rpc.protocol.tri.h12;\n-\n-import io.netty.channel.ChannelHandler.Sharable;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelInboundHandlerAdapter;\n-import io.netty.handler.codec.http.HttpServerUpgradeHandler;\n-import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n-import io.netty.handler.codec.http2.DefaultHttp2Headers;\n-import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n-import io.netty.handler.codec.http2.Http2CodecUtil;\n-import io.netty.handler.codec.http2.Http2FrameCodec;\n-import io.netty.handler.codec.http2.Http2FrameStream;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.InboundHttpToHttp2Adapter;\n-\n-import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n-\n-/**\n- * If an upgrade occurred, the program need send a simple response via HTTP/2 on stream 1 (the stream specifically reserved\n- * for cleartext HTTP upgrade). However, {@link Http2FrameCodec} send 'upgradeRequest' to upgraded channel handlers by\n- * {@link InboundHttpToHttp2Adapter} (As it noted that this may behave strangely). So we need to distinguish the 'upgradeRequest'\n- * and send the response.<br/>\n- *\n- * @see HttpServerUpgradeHandler\n- * @see Http2FrameCodec\n- * @see InboundHttpToHttp2Adapter\n- * @since 3.3.0\n- */\n-@Sharable\n-public class HttpServerAfterUpgradeHandler extends ChannelInboundHandlerAdapter {\n-\n-    @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n-        if (msg instanceof DefaultHttp2HeadersFrame) {\n-            DefaultHttp2HeadersFrame headersFrame = (DefaultHttp2HeadersFrame) msg;\n-            if (headersFrame.stream().id() == Http2CodecUtil.HTTP_UPGRADE_STREAM_ID && headersFrame.isEndStream()) {\n-                // upgradeRequest\n-                sendResponse(ctx, headersFrame.stream());\n-                return;\n-            }\n-        }\n-        super.channelRead(ctx, msg);\n-    }\n-\n-    /**\n-     * Send a frame for the response status\n-     */\n-    private static void sendResponse(ChannelHandlerContext ctx, Http2FrameStream stream) {\n-        Http2Headers headers = new DefaultHttp2Headers().status(OK.codeAsText());\n-        ctx.write(new DefaultHttp2HeadersFrame(headers).stream(stream));\n-        ctx.write(new DefaultHttp2DataFrame(true).stream(stream));\n-    }\n-}",
    "output": "Fix http GET failed cause by http1 upgrade cause"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/CancelStreamException.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/CancelStreamException.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/CancelStreamException.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/CancelStreamException.java\n@@ -0,0 +1,48 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.remoting.http12.h2;\n+\n+import org.apache.dubbo.remoting.http12.ErrorCodeHolder;\n+\n+public class CancelStreamException extends RuntimeException implements ErrorCodeHolder {\n+\n+    private final boolean cancelByRemote;\n+\n+    private final long errorCode;\n+\n+    private CancelStreamException(boolean cancelByRemote, long errorCode) {\n+        this.cancelByRemote = cancelByRemote;\n+        this.errorCode = errorCode;\n+    }\n+\n+    public boolean isCancelByRemote() {\n+        return cancelByRemote;\n+    }\n+\n+    public static CancelStreamException fromRemote(long errorCode) {\n+        return new CancelStreamException(true, errorCode);\n+    }\n+\n+    public static CancelStreamException fromLocal(long errorCode) {\n+        return new CancelStreamException(false, errorCode);\n+    }\n+\n+    @Override\n+    public long getErrorCode() {\n+        return errorCode;\n+    }\n+}\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2ServerChannelObserver.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2ServerChannelObserver.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2ServerChannelObserver.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2ServerChannelObserver.java\n@@ -37,6 +37,8 @@ public class Http2ServerChannelObserver extends AbstractServerHttpChannelObserve\n     private boolean autoRequestN = true;\n+    private boolean closed = false;\n+\n     public Http2ServerChannelObserver(H2StreamChannel h2StreamChannel) {\n         super(h2StreamChannel);\n     }\n@@ -74,12 +76,33 @@ public CancellationContext getCancellationContext() {\n     @Override\n     public void cancel(Throwable throwable) {\n+        if (throwable instanceof CancelStreamException) {\n+            if (((CancelStreamException) throwable).isCancelByRemote()) {\n+                closed = true;\n+            }\n+        }\n+        this.cancellationContext.cancel(throwable);\n         long errorCode = 0;\n         if (throwable instanceof ErrorCodeHolder) {\n             errorCode = ((ErrorCodeHolder) throwable).getErrorCode();\n         }\n         getHttpChannel().writeResetFrame(errorCode);\n-        this.cancellationContext.cancel(throwable);\n+    }\n+\n+    @Override\n+    public void doOnNext(Object data) throws Throwable {\n+        if (closed) {\n+            return;\n+        }\n+        super.doOnNext(data);\n+    }\n+\n+    @Override\n+    public void doOnError(Throwable throwable) throws Throwable {\n+        if (closed) {\n+            return;\n+        }\n+        super.doOnError(throwable);\n     }\n     @Override\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2TransportListener.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2TransportListener.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2TransportListener.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/h2/Http2TransportListener.java\n@@ -16,4 +16,7 @@\n  */\n package org.apache.dubbo.remoting.http12.h2;\n-public interface Http2TransportListener extends CancelableTransportListener<Http2Header, Http2InputMessage> {}\n+public interface Http2TransportListener extends CancelableTransportListener<Http2Header, Http2InputMessage> {\n+\n+    void onStreamClosed();\n+}\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/LengthFieldStreamingDecoder.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/LengthFieldStreamingDecoder.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/LengthFieldStreamingDecoder.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/LengthFieldStreamingDecoder.java\n@@ -95,6 +95,9 @@ private void deliver() {\n         if (inDelivery) {\n             return;\n         }\n+        if (closed) {\n+            return;\n+        }\n         inDelivery = true;\n         try {\n             // Process the uncompressed bytes.\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h2/NettyHttp2ProtocolSelectorHandler.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h2/NettyHttp2ProtocolSelectorHandler.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h2/NettyHttp2ProtocolSelectorHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h2/NettyHttp2ProtocolSelectorHandler.java\n@@ -24,6 +24,7 @@\n import org.apache.dubbo.remoting.http12.exception.UnsupportedMediaTypeException;\n import org.apache.dubbo.remoting.http12.h2.H2StreamChannel;\n import org.apache.dubbo.remoting.http12.h2.Http2ServerTransportListenerFactory;\n+import org.apache.dubbo.remoting.http12.h2.Http2TransportListener;\n import org.apache.dubbo.remoting.http12.h2.command.Http2WriteQueueChannel;\n import org.apache.dubbo.remoting.http12.netty4.HttpWriteQueueHandler;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n@@ -68,8 +69,9 @@ protected void channelRead0(ChannelHandlerContext ctx, HttpMetadata metadata) {\n             h2StreamChannel = new Http2WriteQueueChannel(h2StreamChannel, writeQueue);\n         }\n         ChannelPipeline pipeline = ctx.pipeline();\n-        pipeline.addLast(\n-                new NettyHttp2FrameHandler(h2StreamChannel, factory.newInstance(h2StreamChannel, url, frameworkModel)));\n+        Http2TransportListener http2TransportListener = factory.newInstance(h2StreamChannel, url, frameworkModel);\n+        ctx.channel().closeFuture().addListener(future -> http2TransportListener.onStreamClosed());\n+        pipeline.addLast(new NettyHttp2FrameHandler(h2StreamChannel, http2TransportListener));\n         pipeline.remove(this);\n         ctx.fireChannelRead(metadata);\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java\n@@ -20,7 +20,7 @@\n import org.apache.dubbo.common.threadpool.manager.ExecutorRepository;\n import org.apache.dubbo.common.threadpool.serial.SerializingExecutor;\n import org.apache.dubbo.remoting.http12.HttpMethods;\n-import org.apache.dubbo.remoting.http12.exception.HttpStatusException;\n+import org.apache.dubbo.remoting.http12.h2.CancelStreamException;\n import org.apache.dubbo.remoting.http12.h2.H2StreamChannel;\n import org.apache.dubbo.remoting.http12.h2.Http2Header;\n import org.apache.dubbo.remoting.http12.h2.Http2InputMessage;\n@@ -176,7 +176,7 @@ protected void onError(Throwable throwable) {\n     @Override\n     public void cancelByRemote(long errorCode) {\n-        serverChannelObserver.cancel(new HttpStatusException((int) errorCode));\n+        serverChannelObserver.cancel(CancelStreamException.fromRemote(errorCode));\n         serverCallListener.onCancel(errorCode);\n     }\n@@ -188,6 +188,12 @@ protected final Http2ServerChannelObserver getServerChannelObserver() {\n         return serverChannelObserver;\n     }\n+    @Override\n+    public void onStreamClosed() {\n+        // doing on event loop thread\n+        getStreamingDecoder().close();\n+    }\n+\n     private static class Http2StreamingDecodeListener implements ListeningDecoder.Listener {\n         private final ServerCallListener serverCallListener;",
    "output": "Fix memory leak of tri protocol * fix memory leak of tri protocol * fix memory leak of tri protocol * fix memory leak of tri protocol * fix memory leak of tri protocol * fix memory leak of tri protocol * fix memory leak of tri protocol * fixup! fix memory leak of tri protocol * fix memory leak of tri protocol * fix memory leak of tri protocol ---------"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n--- a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n+++ b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n@@ -22,7 +22,6 @@\n import org.apache.dubbo.rpc.StatusRpcException;\n import org.apache.dubbo.rpc.TriRpcStatus;\n import org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver;\n-import org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n@@ -70,8 +69,7 @@ public static <T, R> void oneToOne(T request, StreamObserver<R> responseObserver\n     public static <T, R> CompletableFuture<List<R>> oneToMany(\n             T request, StreamObserver<R> responseObserver, Function<Mono<T>, Flux<R>> func) {\n         try {\n-            CallStreamObserver<R> callStreamObserver =\n-                    (CallStreamObserver<R>) responseObserver;\n+            CallStreamObserver<R> callStreamObserver = (CallStreamObserver<R>) responseObserver;\n             Flux<R> response = func.apply(Mono.just(request));\n             ServerTripleReactorSubscriber<R> reactorSubscriber =\n                     new ServerTripleReactorSubscriber<>(callStreamObserver);",
    "output": "Fix merge style"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/AbstractTripleReactorSubscriber.java b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/AbstractTripleReactorSubscriber.java\n--- a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/AbstractTripleReactorSubscriber.java\n+++ b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/AbstractTripleReactorSubscriber.java\n@@ -53,7 +53,7 @@ public void subscribe(final CallStreamObserver<T> downstream) {\n         if (downstream == null) {\n             throw new NullPointerException();\n         }\n-        if (this.downstream == null && SUBSCRIBED.compareAndSet(false, true)) {\n+        if (SUBSCRIBED.compareAndSet(false, true)) {\n             this.downstream = downstream;\n             subscription.request(1);\n         }\ndiff --git a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/ServerTripleReactorSubscriber.java b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/ServerTripleReactorSubscriber.java\n--- a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/ServerTripleReactorSubscriber.java\n+++ b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/ServerTripleReactorSubscriber.java\n@@ -20,11 +20,31 @@\n import org.apache.dubbo.rpc.protocol.tri.CancelableStreamObserver;\n import org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n /**\n  * The Subscriber in server to passing the data produced by user publisher to responseStream.\n  */\n public class ServerTripleReactorSubscriber<T> extends AbstractTripleReactorSubscriber<T> {\n+    /**\n+     * The execution future of the current task, in order to be returned to stubInvoker\n+     */\n+    private final CompletableFuture<List<T>> executionFuture = new CompletableFuture<>();\n+    /**\n+     * The result elements collected by the current task.\n+     * This class is a flux subscriber, which usually means there will be multiple elements, so it is declared as a list type.\n+     */\n+    private final List<T> collectedData = new ArrayList<>();\n+\n+    public ServerTripleReactorSubscriber() {}\n+\n+    public ServerTripleReactorSubscriber(CallStreamObserver<T> streamObserver) {\n+        this.downstream = streamObserver;\n+    }\n+\n     @Override\n     public void subscribe(CallStreamObserver<T> downstream) {\n         super.subscribe(downstream);\n@@ -40,4 +60,26 @@ public void subscribe(CallStreamObserver<T> downstream) {\n             context.addListener(ctx -> super.cancel());\n         }\n     }\n+\n+    @Override\n+    public void onNext(T t) {\n+        super.onNext(t);\n+        collectedData.add(t);\n+    }\n+\n+    @Override\n+    public void onError(Throwable throwable) {\n+        super.onError(throwable);\n+        executionFuture.completeExceptionally(throwable);\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        super.onComplete();\n+        executionFuture.complete(this.collectedData);\n+    }\n+\n+    public CompletableFuture<List<T>> getExecutionFuture() {\n+        return executionFuture;\n+    }\n }\ndiff --git a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n--- a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n+++ b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n@@ -24,6 +24,8 @@\n import org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver;\n import org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n import java.util.function.Function;\n import reactor.core.publisher.Flux;\n@@ -65,14 +67,21 @@ public static <T, R> void oneToOne(T request, StreamObserver<R> responseObserver\n      * @param responseObserver response StreamObserver\n      * @param func service implementation\n      */\n-    public static <T, R> void oneToMany(\n+    public static <T, R> CompletableFuture<List<R>> oneToMany(\n             T request, StreamObserver<R> responseObserver, Function<Mono<T>, Flux<R>> func) {\n         try {\n+            ServerCallToObserverAdapter<R> serverCallToObserverAdapter =\n+                    (ServerCallToObserverAdapter<R>) responseObserver;\n             Flux<R> response = func.apply(Mono.just(request));\n-            ServerTripleReactorSubscriber<R> subscriber = response.subscribeWith(new ServerTripleReactorSubscriber<>());\n-            subscriber.subscribe((ServerCallToObserverAdapter<R>) responseObserver);\n+            ServerTripleReactorSubscriber<R> reactorSubscriber =\n+                    new ServerTripleReactorSubscriber<>(serverCallToObserverAdapter);\n+            response.subscribeWith(reactorSubscriber).subscribe(serverCallToObserverAdapter);\n+            return reactorSubscriber.getExecutionFuture();\n         } catch (Throwable throwable) {\n-            responseObserver.onError(throwable);\n+            doOnResponseHasException(throwable, responseObserver);\n+            CompletableFuture<List<R>> future = new CompletableFuture<>();\n+            future.completeExceptionally(throwable);\n+            return future;\n         }\n     }\ndiff --git a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/handler/OneToManyMethodHandler.java b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/handler/OneToManyMethodHandler.java\n--- a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/handler/OneToManyMethodHandler.java\n+++ b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/handler/OneToManyMethodHandler.java\n@@ -42,7 +42,6 @@ public OneToManyMethodHandler(Function<Mono<T>, Flux<R>> func) {\n     public CompletableFuture<?> invoke(Object[] arguments) {\n         T request = (T) arguments[0];\n         StreamObserver<R> responseObserver = (StreamObserver<R>) arguments[1];\n-        ReactorServerCalls.oneToMany(request, responseObserver, func);\n-        return CompletableFuture.completedFuture(null);\n+        return ReactorServerCalls.oneToMany(request, responseObserver, func);\n     }\n }",
    "output": "Fix Triple Reactor OneToMany Handler null pointer fix and DubboFilter support * ReactorDubbo3TripleStub.mustache add schema registry * Triple Reactor OneToMany Handler null pointer fix and DubboFilter support * trigger ci * Adjust the order * trigger ci * ServerTripleReactorSubscriber meaningful ---------"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotationUtils.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotationUtils.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotationUtils.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotationUtils.java\n@@ -444,21 +444,11 @@ public static Annotation tryGetMergedAnnotation(\n                 (_k) -> ClassUtils.isPresent(ANNOTATED_ELEMENT_UTILS_CLASS_NAME, classLoader))) {\n             Class<?> annotatedElementUtilsClass = resolveClassName(ANNOTATED_ELEMENT_UTILS_CLASS_NAME, classLoader);\n             // getMergedAnnotation method appears in the Spring Framework 4.2\n-            Method getMergedAnnotationMethod = findMethod(\n-                    annotatedElementUtilsClass,\n-                    \"getMergedAnnotation\",\n-                    AnnotatedElement.class,\n-                    Class.class,\n-                    boolean.class,\n-                    boolean.class);\n+            Method getMergedAnnotationMethod =\n+                    findMethod(annotatedElementUtilsClass, \"getMergedAnnotation\", AnnotatedElement.class, Class.class);\n             if (getMergedAnnotationMethod != null) {\n-                mergedAnnotation = (Annotation) invokeMethod(\n-                        getMergedAnnotationMethod,\n-                        null,\n-                        annotatedElement,\n-                        annotationType,\n-                        classValuesAsString,\n-                        nestedAnnotationsAsMap);\n+                mergedAnnotation =\n+                        (Annotation) invokeMethod(getMergedAnnotationMethod, null, annotatedElement, annotationType);\n             }\n         }",
    "output": "Fix the signature error when using reflection to access the org.springframework.core.annotation.AnnotatedElementUtils#getMergedAnnotation method Fix the problem,the method org.apache.dubbo.config.spring.util.AnnotationUtils#tryGetMergedAnnotation utilizes reflection to access org.springframework.core.annotation.AnnotatedElementUtils#getMergedAnnotation. However, there is a signature mismatch in the method's input parameters, which leads to an inability to retrieve the correct method. Consequently, this results in the failure to obtain the mergedAnnotation."
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java\n@@ -22,6 +22,7 @@\n import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.UUID;\n import java.util.concurrent.CountDownLatch;\n import javassist.ClassPool;\n@@ -184,7 +185,7 @@ void testMain() throws Exception {\n         fname.setAccessible(true);\n         ClassGenerator cg = ClassGenerator.newInstance();\n-        cg.setClassName(Bean.class.getName() + \"$Builder\");\n+        cg.setClassName(Bean.class.getName() + \"$Builder\" + UUID.randomUUID().toString());\n         cg.addInterface(Builder.class);\n         cg.addField(\"public static java.lang.reflect.Field FNAME;\");",
    "output": "Fix non-idempotent unit test"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n--- a/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n+++ b/dubbo-plugin/dubbo-reactive/src/main/java/org/apache/dubbo/reactive/calls/ReactorServerCalls.java\n@@ -19,10 +19,11 @@\n import org.apache.dubbo.common.stream.StreamObserver;\n import org.apache.dubbo.reactive.ServerTripleReactorPublisher;\n import org.apache.dubbo.reactive.ServerTripleReactorSubscriber;\n+import org.apache.dubbo.rpc.StatusRpcException;\n+import org.apache.dubbo.rpc.TriRpcStatus;\n import org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver;\n import org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;\n-import java.util.concurrent.CompletableFuture;\n import java.util.function.Function;\n import reactor.core.publisher.Flux;\n@@ -43,16 +44,18 @@ private ReactorServerCalls() {}\n      * @param func service implementation\n      */\n     public static <T, R> void oneToOne(T request, StreamObserver<R> responseObserver, Function<Mono<T>, Mono<R>> func) {\n-        func.apply(Mono.just(request)).subscribe(res -> {\n-            CompletableFuture.completedFuture(res).whenComplete((r, t) -> {\n-                if (t != null) {\n-                    responseObserver.onError(t);\n-                } else {\n-                    responseObserver.onNext(r);\n-                    responseObserver.onCompleted();\n-                }\n-            });\n-        });\n+        try {\n+            func.apply(Mono.just(request))\n+                    .subscribe(\n+                            res -> {\n+                                responseObserver.onNext(res);\n+                                responseObserver.onCompleted();\n+                            },\n+                            throwable -> doOnResponseHasException(throwable, responseObserver),\n+                            () -> doOnResponseHasException(TriRpcStatus.NOT_FOUND.asException(), responseObserver));\n+        } catch (Throwable throwable) {\n+            doOnResponseHasException(throwable, responseObserver);\n+        }\n     }\n     /**\n@@ -131,4 +134,10 @@ public static <T, R> StreamObserver<T> manyToMany(\n         return serverPublisher;\n     }\n+\n+    private static void doOnResponseHasException(Throwable throwable, StreamObserver<?> responseObserver) {\n+        StatusRpcException statusRpcException =\n+                TriRpcStatus.getStatus(throwable).asException();\n+        responseObserver.onError(statusRpcException);\n+    }\n }",
    "output": "Fix The oneToOne method of the ReactorServerCalls class will cause the request to hang when the result is Mono Empty * Fix triple reactor request hung when result is Mono Empty * code format * fix compile ---------"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n@@ -236,6 +236,13 @@ public void onConnected(Object channel) {\n             }\n             return;\n         }\n+\n+        // Close the existing channel before setting a new channel\n+        final io.netty.channel.Channel current = getNettyChannel();\n+        if (current != null) {\n+            current.close();\n+        }\n+\n         this.channel.set(nettyChannel);\n         // This indicates that the connection is available.\n         if (this.connectingPromise.get() != null) {\n@@ -254,6 +261,10 @@ public void onGoaway(Object channel) {\n         }\n         io.netty.channel.Channel nettyChannel = (io.netty.channel.Channel) channel;\n         if (this.channel.compareAndSet(nettyChannel, null)) {\n+            // Ensure the channel is closed\n+            if (nettyChannel.isOpen()) {\n+                nettyChannel.close();\n+            }\n             NettyChannel.removeChannelIfDisconnected(nettyChannel);\n             if (LOGGER.isDebugEnabled()) {\n                 LOGGER.debug(String.format(\"%s goaway\", this));",
    "output": "Fix channel leakage in onConnected and onGoaway methods"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java b/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n--- a/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n+++ b/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n@@ -259,7 +259,8 @@ void testWrongAuthRedisMetadata() throws ClassNotFoundException {\n             if (e.getCause() instanceof JedisConnectionException\n                     && e.getCause().getCause() instanceof JedisDataException) {\n                 Assertions.assertEquals(\n-                        \"ERR invalid password\", e.getCause().getCause().getMessage());\n+                        \"WRONGPASS invalid username-password pair or user is disabled.\",\n+                        e.getCause().getCause().getMessage());\n             } else {\n                 Assertions.fail(\"no invalid password exception!\");\n             }",
    "output": "Fix embedded-redis need update version to run on macos Sonoma"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java\n@@ -461,6 +461,7 @@ public void onData(ByteBuf data, boolean endStream) {\n         private void doOnData(ByteBuf data, boolean endStream) {\n             if (deframer == null) {\n+                ReferenceCountUtil.release(data);\n                 return;\n             }\n             deframer.deframe(data);",
    "output": "Fix Bytebuf resource leak"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java\n@@ -62,14 +62,18 @@ public void invoke() {\n         final long stInMillis = System.currentTimeMillis();\n         try {\n             final Result response = invoker.invoke(invocation);\n+            if (response.hasException()) {\n+                doOnResponseHasException(response.getException());\n+                return;\n+            }\n             response.whenCompleteWithContext((r, t) -> {\n                 responseObserver.setResponseAttachments(response.getObjectAttachments());\n                 if (t != null) {\n                     responseObserver.onError(t);\n                     return;\n                 }\n-                if (response.hasException()) {\n-                    doOnResponseHasException(response.getException());\n+                if (r.hasException()) {\n+                    doOnResponseHasException(r.getException());\n                     return;\n                 }\n                 final long cost = System.currentTimeMillis() - stInMillis;",
    "output": "Fix triple AbstractServerCallListener NPE * fix NPE * Optimize the handling of exceptions in response ---------"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n@@ -21,16 +21,19 @@\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.threadpool.manager.ExecutorRepository;\n+import org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository;\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.remoting.Channel;\n import org.apache.dubbo.remoting.ChannelHandler;\n import org.apache.dubbo.remoting.Client;\n import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.remoting.RemotingException;\n import org.apache.dubbo.remoting.transport.dispatcher.ChannelHandlers;\n+import org.apache.dubbo.rpc.model.FrameworkModel;\n import java.net.InetSocketAddress;\n import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n@@ -41,6 +44,11 @@\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.TRANSPORT_FAILED_CLOSE;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.TRANSPORT_FAILED_CONNECT_PROVIDER;\n import static org.apache.dubbo.config.Constants.CLIENT_THREAD_POOL_NAME;\n+import static org.apache.dubbo.remoting.Constants.HEARTBEAT_CHECK_TICK;\n+import static org.apache.dubbo.remoting.Constants.LEAST_HEARTBEAT_DURATION;\n+import static org.apache.dubbo.remoting.Constants.LEAST_RECONNECT_DURATION;\n+import static org.apache.dubbo.remoting.Constants.LEAST_RECONNECT_DURATION_KEY;\n+import static org.apache.dubbo.remoting.utils.UrlUtils.getIdleTimeout;\n /**\n  * AbstractClient\n@@ -55,13 +63,23 @@ public abstract class AbstractClient extends AbstractEndpoint implements Client\n     protected volatile ExecutorService executor;\n+    protected volatile ScheduledExecutorService connectivityExecutor;\n+\n+    private FrameworkModel frameworkModel;\n+\n+    protected long reconnectDuaration;\n+\n     public AbstractClient(URL url, ChannelHandler handler) throws RemotingException {\n         super(url, handler);\n         // set default needReconnect true when channel is not connected\n         needReconnect = url.getParameter(Constants.SEND_RECONNECT_KEY, true);\n+        frameworkModel = url.getOrDefaultFrameworkModel();\n+\n         initExecutor(url);\n+        reconnectDuaration = getReconnectDuration(url);\n+\n         try {\n             doOpen();\n         } catch (Throwable t) {\n@@ -134,6 +152,11 @@ private void initExecutor(URL url) {\n         url = url.addParameter(THREAD_NAME_KEY, CLIENT_THREAD_POOL_NAME)\n                 .addParameterIfAbsent(THREADPOOL_KEY, DEFAULT_CLIENT_THREADPOOL);\n         executor = executorRepository.createExecutorIfAbsent(url);\n+\n+        connectivityExecutor = frameworkModel\n+                .getBeanFactory()\n+                .getBean(FrameworkExecutorRepository.class)\n+                .getConnectivityScheduledExecutor();\n     }\n     protected static ChannelHandler wrapChannelHandler(URL url, ChannelHandler handler) {\n@@ -296,6 +319,25 @@ public void disconnect() {\n         }\n     }\n+    private long getReconnectDuration(URL url) {\n+        int idleTimeout = getIdleTimeout(url);\n+        long heartbeatTimeoutTick = calculateLeastDuration(idleTimeout);\n+        return calculateReconnectDuration(url, heartbeatTimeoutTick);\n+    }\n+\n+    private long calculateLeastDuration(int time) {\n+        if (time / HEARTBEAT_CHECK_TICK <= 0) {\n+            return LEAST_HEARTBEAT_DURATION;\n+        } else {\n+            return time / HEARTBEAT_CHECK_TICK;\n+        }\n+    }\n+\n+    private long calculateReconnectDuration(URL url, long tick) {\n+        long leastReconnectDuration = url.getParameter(LEAST_RECONNECT_DURATION_KEY, LEAST_RECONNECT_DURATION);\n+        return Math.max(leastReconnectDuration, tick);\n+    }\n+\n     @Override\n     public void reconnect() throws RemotingException {\n         connectLock.lock();\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n@@ -43,7 +43,6 @@\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelOption;\n import io.netty.channel.ChannelPipeline;\n-import io.netty.channel.EventLoop;\n import io.netty.channel.socket.SocketChannel;\n import io.netty.handler.ssl.SslContext;\n import io.netty.handler.timeout.IdleStateHandler;\n@@ -75,6 +74,8 @@ public class NettyConnectionClient extends AbstractConnectionClient {\n     public static final AttributeKey<AbstractConnectionClient> CONNECTION = AttributeKey.valueOf(\"connection\");\n+    private AtomicBoolean isReconnecting;\n+\n     public NettyConnectionClient(URL url, ChannelHandler handler) throws RemotingException {\n         super(url, handler);\n     }\n@@ -91,6 +92,7 @@ protected void initConnectionClient() {\n         this.closePromise = new DefaultPromise<>(GlobalEventExecutor.INSTANCE);\n         this.init = new AtomicBoolean(false);\n         this.increase();\n+        this.isReconnecting = new AtomicBoolean(false);\n     }\n     @Override\n@@ -158,6 +160,10 @@ protected void doClose() {\n     @Override\n     protected void doConnect() throws RemotingException {\n+        if (!isReconnecting.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n         if (isClosed()) {\n             if (LOGGER.isDebugEnabled()) {\n                 LOGGER.debug(\n@@ -347,6 +353,11 @@ class ConnectionListener implements ChannelFutureListener {\n         @Override\n         public void operationComplete(ChannelFuture future) {\n+\n+            if (!isReconnecting.compareAndSet(true, false)) {\n+                return;\n+            }\n+\n             if (future.isSuccess()) {\n                 return;\n             }\n@@ -364,8 +375,8 @@ public void operationComplete(ChannelFuture future) {\n                         \"%s is reconnecting, attempt=%d cause=%s\",\n                         connectionClient, 0, future.cause().getMessage()));\n             }\n-            final EventLoop loop = future.channel().eventLoop();\n-            loop.schedule(\n+\n+            connectivityExecutor.schedule(\n                     () -> {\n                         try {\n                             connectionClient.doConnect();\n@@ -377,8 +388,8 @@ public void operationComplete(ChannelFuture future) {\n                                     \"Failed to connect to server: \" + getConnectAddress());\n                         }\n                     },\n-                    1L,\n-                    TimeUnit.SECONDS);\n+                    reconnectDuaration,\n+                    TimeUnit.MILLISECONDS);\n         }\n     }\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ConnectionTest.java b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ConnectionTest.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ConnectionTest.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ConnectionTest.java\n@@ -28,6 +28,7 @@\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.ModuleModel;\n+import java.time.Duration;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n@@ -39,6 +40,7 @@\n import org.junit.jupiter.api.Test;\n import static org.apache.dubbo.common.constants.CommonConstants.EXECUTOR_MANAGEMENT_MODE_DEFAULT;\n+import static org.awaitility.Awaitility.await;\n public class ConnectionTest {\n@@ -138,6 +140,7 @@ void connectSyncTest() throws Throwable {\n         nettyPortUnificationServer.bind();\n         // auto reconnect\n+        await().atMost(Duration.ofSeconds(100)).until(() -> connectionClient.isAvailable());\n         Assertions.assertTrue(connectionClient.isAvailable());\n         connectionClient.close();",
    "output": "Use ExecutorService instead of event loop for Netty connection * Use ExecutorService instead of event loop for Netty connection This change addresses the issue of the event loop being blocked for an extended period, improving overall performance and responsiveness. * fix log getConnectAddress * applay format * applay format * applay format * applay format * applay format * Use an independent ExecutorService * Use ScheduledExecutorService for scheduling tasks * delete unnecessary files * Modify to stop ExecutorService using shutdownNow * Modify to use ScheduledExecutor managed by FrameworkExecutorRepository * Synchronize reconnectDuration with HeaderExchangeClient's reconnectDuration * get framework model directly use awaitility"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -346,6 +346,7 @@ protected synchronized void init(boolean check) {\n             if (CommonConstants.NATIVE_STUB.equals(getProxy())) {\n                 serviceDescriptor = StubSuppliers.getServiceDescriptor(interfaceName);\n                 repository.registerService(serviceDescriptor);\n+                setInterface(serviceDescriptor.getInterfaceName());\n             } else {\n                 serviceDescriptor = repository.registerService(interfaceClass);\n             }",
    "output": "Fix triple stub calling grpc server fail"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassLoaderResourceLoader.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassLoaderResourceLoader.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassLoaderResourceLoader.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassLoaderResourceLoader.java\n@@ -16,14 +16,12 @@\n  */\n package org.apache.dubbo.common.utils;\n-import org.apache.dubbo.common.aot.NativeDetector;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.resource.GlobalResourcesRepository;\n import java.io.IOException;\n import java.lang.ref.SoftReference;\n-import java.lang.reflect.Field;\n import java.net.URL;\n import java.util.Collection;\n import java.util.Collections;\n@@ -32,7 +30,6 @@\n import java.util.LinkedHashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.UUID;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n@@ -81,15 +78,9 @@ public static Set<URL> loadResources(String fileName, ClassLoader currentClassLo\n             Enumeration<URL> urls;\n             try {\n                 urls = currentClassLoader.getResources(fileName);\n-                boolean isNative = NativeDetector.inNativeImage();\n                 if (urls != null) {\n                     while (urls.hasMoreElements()) {\n                         URL url = urls.nextElement();\n-                        if (isNative) {\n-                            // In native mode, the address of each URL is the same instead of different paths, so it is\n-                            // necessary to set the ref to make it different\n-                            setRef(url);\n-                        }\n                         set.add(url);\n                     }\n                 }\n@@ -113,15 +104,6 @@ public static void destroy() {\n         }\n     }\n-    private static void setRef(URL url) {\n-        try {\n-            Field field = URL.class.getDeclaredField(\"ref\");\n-            field.setAccessible(true);\n-            field.set(url, UUID.randomUUID().toString());\n-        } catch (Throwable ignore) {\n-        }\n-    }\n-\n     // for test\n     protected static SoftReference<Map<ClassLoader, Map<String, Set<URL>>>> getClassLoaderResourcesCache() {\n         return classLoaderResourcesCache;",
    "output": "Remove url ref in native scenario"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleScopeModelInitializer.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleScopeModelInitializer.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleScopeModelInitializer.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleScopeModelInitializer.java\n@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.tri;\n+\n+import org.apache.dubbo.common.beans.factory.ScopeBeanFactory;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.FrameworkModel;\n+import org.apache.dubbo.rpc.model.ModuleModel;\n+import org.apache.dubbo.rpc.model.ScopeModelInitializer;\n+import org.apache.dubbo.rpc.protocol.tri.rest.mapping.DefaultRequestMappingRegistry;\n+import org.apache.dubbo.rpc.protocol.tri.route.DefaultRequestRouter;\n+\n+public class TripleScopeModelInitializer implements ScopeModelInitializer {\n+\n+    @Override\n+    public void initializeFrameworkModel(FrameworkModel frameworkModel) {\n+        ScopeBeanFactory beanFactory = frameworkModel.getBeanFactory();\n+        beanFactory.registerBean(DefaultRequestMappingRegistry.class);\n+        beanFactory.registerBean(DefaultRequestRouter.class);\n+    }\n+\n+    @Override\n+    public void initializeApplicationModel(ApplicationModel applicationModel) {}\n+\n+    @Override\n+    public void initializeModuleModel(ModuleModel moduleModel) {}\n+}",
    "output": "Fix the triple protocol request failed in the native scenario"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/CtrlCHandler.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/CtrlCHandler.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/CtrlCHandler.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/CtrlCHandler.java\n@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.qos.server.handler;\n+\n+import org.apache.dubbo.qos.common.QosConstants;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.util.CharsetUtil;\n+\n+public class CtrlCHandler extends SimpleChannelInboundHandler<ByteBuf> {\n+    /**\n+     * When type 'Ctrl+C', telnet client will send the following sequence:\n+     * 'FF F4 FF FD 06', it can be divided into two parts:\n+     * <p>\n+     * 1. 'FF F4' is telnet interrupt process command.\n+     * <p>\n+     * 2. 'FF FD 06' is  to suppress the output of the process that is to be\n+     *    interrupted by the  interrupt process command.\n+     * <p>\n+     * We need to response with 'FF FC 06' to ignore it and tell the client continue\n+     * display output.\n+     */\n+    private byte[] CTRLC_BYTES_SEQUENCE = new byte[] {(byte) 0xff, (byte) 0xf4, (byte) 0xff, (byte) 0xfd, (byte) 0x06};\n+\n+    private byte[] RESPONSE_SEQUENCE = new byte[] {(byte) 0xff, (byte) 0xfc, 0x06};\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {\n+        // find ctrl+c\n+        final int readerIndex = buffer.readerIndex();\n+        for (int i = readerIndex; i < buffer.writerIndex(); i++) {\n+            if (buffer.readableBytes() - i < CTRLC_BYTES_SEQUENCE.length) {\n+                break;\n+            }\n+            boolean match = true;\n+            for (int j = 0; j < CTRLC_BYTES_SEQUENCE.length; j++) {\n+                if (CTRLC_BYTES_SEQUENCE[j] != buffer.getByte(i + j)) {\n+                    match = false;\n+                    break;\n+                }\n+            }\n+\n+            if (match) {\n+                buffer.readerIndex(readerIndex + buffer.readableBytes());\n+                ctx.writeAndFlush(Unpooled.wrappedBuffer(RESPONSE_SEQUENCE));\n+                ctx.writeAndFlush(Unpooled.wrappedBuffer(\n+                        (QosConstants.BR_STR + QosProcessHandler.PROMPT).getBytes(CharsetUtil.UTF_8)));\n+\n+                return;\n+            }\n+        }\n+        ctx.fireChannelRead(buffer);\n+    }\n+}\ndiff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/QosProcessHandler.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/QosProcessHandler.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/QosProcessHandler.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/QosProcessHandler.java\n@@ -89,6 +89,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t\n             p.addLast(new HttpProcessHandler(frameworkModel, qosConfiguration));\n             p.remove(this);\n         } else {\n+            p.addLast(new CtrlCHandler());\n             p.addLast(new LineBasedFrameDecoder(2048));\n             p.addLast(new StringDecoder(CharsetUtil.UTF_8));\n             p.addLast(new StringEncoder(CharsetUtil.UTF_8));\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/server/handler/CtrlCHandlerTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/server/handler/CtrlCHandlerTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/server/handler/CtrlCHandlerTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/server/handler/CtrlCHandlerTest.java\n@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.qos.server.handler;\n+\n+import org.apache.dubbo.qos.common.QosConstants;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.CharsetUtil;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+public class CtrlCHandlerTest {\n+    private byte[] CTRLC_BYTES_SEQUENCE = new byte[] {(byte) 0xff, (byte) 0xf4, (byte) 0xff, (byte) 0xfd, (byte) 0x06};\n+\n+    private byte[] RESPONSE_SEQUENCE = new byte[] {(byte) 0xff, (byte) 0xfc, 0x06};\n+\n+    @Test\n+    void testMatchedExactly() throws Exception {\n+        ChannelHandlerContext context = mock(ChannelHandlerContext.class);\n+        CtrlCHandler ctrlCHandler = new CtrlCHandler();\n+        ctrlCHandler.channelRead(context, Unpooled.wrappedBuffer(CTRLC_BYTES_SEQUENCE));\n+        verify(context).writeAndFlush(Unpooled.wrappedBuffer(RESPONSE_SEQUENCE));\n+        verify(context)\n+                .writeAndFlush(Unpooled.wrappedBuffer(\n+                        (QosConstants.BR_STR + QosProcessHandler.PROMPT).getBytes(CharsetUtil.UTF_8)));\n+    }\n+\n+    @Test\n+    void testMatchedNotExactly() throws Exception {\n+        ChannelHandlerContext context = mock(ChannelHandlerContext.class);\n+        CtrlCHandler ctrlCHandler = new CtrlCHandler();\n+        // before 'ctrl c', user typed other command like 'help'\n+        String arbitraryCommand = \"help\";\n+        byte[] commandBytes = arbitraryCommand.getBytes(StandardCharsets.UTF_8);\n+        ctrlCHandler.channelRead(context, Unpooled.wrappedBuffer(commandBytes, CTRLC_BYTES_SEQUENCE));\n+        verify(context).writeAndFlush(Unpooled.wrappedBuffer(RESPONSE_SEQUENCE));\n+        verify(context)\n+                .writeAndFlush(Unpooled.wrappedBuffer(\n+                        (QosConstants.BR_STR + QosProcessHandler.PROMPT).getBytes(CharsetUtil.UTF_8)));\n+    }\n+\n+    @Test\n+    void testNotMatched() throws Exception {\n+        ChannelHandlerContext context = mock(ChannelHandlerContext.class);\n+        CtrlCHandler ctrlCHandler = new CtrlCHandler();\n+        String arbitraryCommand = \"help\" + QosConstants.BR_STR;\n+        byte[] commandBytes = arbitraryCommand.getBytes(StandardCharsets.UTF_8);\n+        ctrlCHandler.channelRead(context, Unpooled.wrappedBuffer(commandBytes));\n+        verify(context, never()).writeAndFlush(Unpooled.wrappedBuffer(RESPONSE_SEQUENCE));\n+        verify(context, never())\n+                .writeAndFlush(Unpooled.wrappedBuffer(\n+                        (QosConstants.BR_STR + QosProcessHandler.PROMPT).getBytes(CharsetUtil.UTF_8)));\n+    }\n+}",
    "output": "Fix telnet ctrl+c issue #13812 * Fix telnet ctrl+c issue #13812 * fix formatting issue * add unit test for CtrlCHandler.java ---------"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectInput.java b/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectInput.java\n--- a/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectInput.java\n+++ b/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectInput.java\n@@ -91,7 +91,7 @@ public String readUTF() throws IOException {\n     @Override\n     public byte[] readBytes() throws IOException {\n-        int length = is.read();\n+        int length = readLength();\n         byte[] bytes = new byte[length];\n         int read = is.read(bytes, 0, length);\n         if (read != length) {\ndiff --git a/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectOutput.java b/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectOutput.java\n--- a/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectOutput.java\n+++ b/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectOutput.java\n@@ -89,13 +89,13 @@ public void writeUTF(String v) throws IOException {\n     @Override\n     public void writeBytes(byte[] b) throws IOException {\n-        os.write(b.length);\n+        writeLength(b.length);\n         os.write(b);\n     }\n     @Override\n     public void writeBytes(byte[] b, int off, int len) throws IOException {\n-        os.write(len);\n+        writeLength(len);\n         os.write(b, off, len);\n     }",
    "output": "Fix readBytes and writeBytes methods in fastjson2"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -778,6 +778,12 @@ public Result invoke(Invocation invocation) throws RpcException {\n                     invocation instanceof RpcInvocation ? ((RpcInvocation) invocation).getInvokeMode() : null);\n             copiedInvocation.setObjectAttachment(CommonConstants.GROUP_KEY, protocolServiceKey.getGroup());\n             copiedInvocation.setObjectAttachment(CommonConstants.VERSION_KEY, protocolServiceKey.getVersion());\n+            // When there are multiple MethodDescriptors with the same method name, the return type will be wrong\n+            // same with org.apache.dubbo.rpc.stub.StubInvocationUtil.call\n+            // fix https://github.com/apache/dubbo/issues/13931\n+            if (invocation instanceof RpcInvocation) {\n+                copiedInvocation.setReturnType(((RpcInvocation) invocation).getReturnType());\n+            }\n             return originInvoker.invoke(copiedInvocation);\n         }",
    "output": "Fix async method call ClassCastException error"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n@@ -31,6 +31,7 @@\n import org.apache.dubbo.remoting.transport.netty4.ssl.SslContexts;\n import org.apache.dubbo.remoting.utils.UrlUtils;\n+import java.util.Optional;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -337,7 +338,9 @@ public void destroy() {\n     @Override\n     public String toString() {\n         return super.toString() + \" (Ref=\" + this.getCounter() + \",local=\"\n-                + (getChannel() == null ? null : getChannel().getLocalAddress()) + \",remote=\" + getRemoteAddress();\n+                + Optional.ofNullable(getChannel())\n+                        .map(Channel::getLocalAddress)\n+                        .orElse(null) + \",remote=\" + getRemoteAddress();\n     }\n     class ConnectionListener implements ChannelFutureListener {",
    "output": "Fix NPE in NettyConnectionClient.toString"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/ChangeTelnet.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/ChangeTelnet.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/ChangeTelnet.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/ChangeTelnet.java\n@@ -58,7 +58,8 @@ public String execute(CommandContext commandContext, String[] args) {\n             for (Exporter<?> exporter : dubboProtocol.getExporters()) {\n                 if (message.equals(exporter.getInvoker().getInterface().getSimpleName())\n                         || message.equals(exporter.getInvoker().getInterface().getName())\n-                        || message.equals(exporter.getInvoker().getUrl().getPath())) {\n+                        || message.equals(exporter.getInvoker().getUrl().getPath())\n+                        || message.equals(exporter.getInvoker().getUrl().getServiceKey())) {\n                     found = true;\n                     break;\n                 }\ndiff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/CountTelnet.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/CountTelnet.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/CountTelnet.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/CountTelnet.java\n@@ -85,7 +85,8 @@ public String execute(CommandContext commandContext, String[] args) {\n         for (Exporter<?> exporter : dubboProtocol.getExporters()) {\n             if (service.equals(exporter.getInvoker().getInterface().getSimpleName())\n                     || service.equals(exporter.getInvoker().getInterface().getName())\n-                    || service.equals(exporter.getInvoker().getUrl().getPath())) {\n+                    || service.equals(exporter.getInvoker().getUrl().getPath())\n+                    || service.equals(exporter.getInvoker().getUrl().getServiceKey())) {\n                 invoker = exporter.getInvoker();\n                 break;\n             }\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ChangeTelnetTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ChangeTelnetTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ChangeTelnetTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ChangeTelnetTest.java\n@@ -71,7 +71,7 @@ public void beforeEach() {\n         mockChannel.attr(ChangeTelnet.SERVICE_KEY).set(\"org.apache.dubbo.rpc.protocol.dubbo.support.DemoService\");\n         given(mockCommandContext.getRemote()).willReturn(mockChannel);\n         given(mockInvoker.getInterface()).willReturn(DemoService.class);\n-        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20884/demo\"));\n+        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20884/demo?group=g&version=1.0.0\"));\n     }\n     @AfterEach\n@@ -110,6 +110,15 @@ void testChangePath() {\n         assertEquals(\"Used the demo as default.\\r\\nYou can cancel default service by command: cd /\", result);\n     }\n+    @Test\n+    void testChangeServiceKey() {\n+        ExtensionLoader.getExtensionLoader(Protocol.class)\n+                .getExtension(DubboProtocol.NAME)\n+                .export(mockInvoker);\n+        String result = change.execute(mockCommandContext, new String[] {\"g/demo:1.0.0\"});\n+        assertEquals(\"Used the g/demo:1.0.0 as default.\\r\\nYou can cancel default service by command: cd /\", result);\n+    }\n+\n     @Test\n     void testChangeMessageNull() {\n         String result = change.execute(mockCommandContext, null);\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/CountTelnetTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/CountTelnetTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/CountTelnetTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/CountTelnetTest.java\n@@ -52,7 +52,7 @@ class CountTelnetTest {\n     private CommandContext mockCommandContext;\n     private CountDownLatch latch;\n-    private final URL url = URL.valueOf(\"dubbo://127.0.0.1:20884/demo\");\n+    private final URL url = URL.valueOf(\"dubbo://127.0.0.1:20884/demo?group=g&version=1.0.0\");\n     @BeforeEach\n     public void setUp() {\n@@ -70,12 +70,14 @@ public void setUp() {\n     public void tearDown() {\n         FrameworkModel.destroyAll();\n         mockChannel.close();\n+        RpcStatus.removeStatus(url);\n         reset(mockInvoker, mockCommandContext);\n     }\n     @Test\n     void test() throws Exception {\n         String methodName = \"sayHello\";\n+        RpcStatus.removeStatus(url, methodName);\n         String[] args = new String[] {\"org.apache.dubbo.qos.legacy.service.DemoService\", \"sayHello\", \"1\"};\n         ExtensionLoader.getExtensionLoader(Protocol.class)\n@@ -94,6 +96,28 @@ void test() throws Exception {\n         assertThat(sb.toString(), containsString(buildTable(methodName, 10, 10, \"1\", \"0\", \"0\")));\n     }\n+    @Test\n+    void testCountByServiceKey() throws Exception {\n+        String methodName = \"sayHello\";\n+        RpcStatus.removeStatus(url, methodName);\n+        String[] args = new String[] {\"g/demo:1.0.0\", \"sayHello\", \"1\"};\n+\n+        ExtensionLoader.getExtensionLoader(Protocol.class)\n+                .getExtension(DubboProtocol.NAME)\n+                .export(mockInvoker);\n+        RpcStatus.beginCount(url, methodName);\n+        RpcStatus.endCount(url, methodName, 10L, true);\n+        count.execute(mockCommandContext, args);\n+        latch.await();\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (Object o : mockChannel.getReceivedObjects()) {\n+            sb.append(o.toString());\n+        }\n+\n+        assertThat(sb.toString(), containsString(buildTable(methodName, 10, 10, \"1\", \"0\", \"0\")));\n+    }\n+\n     public static String buildTable(\n             String methodName, long averageElapsed, long maxElapsed, String total, String failed, String active) {\n         List<String> header = new LinkedList<>();",
    "output": "Add condition to match serviceKey"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n@@ -65,7 +65,7 @@ public abstract class AbstractServerTransportListener<HEADER extends RequestMeta\n     private RpcInvocationBuildContext context;\n     private HttpMessageListener httpMessageListener;\n-    public AbstractServerTransportListener(FrameworkModel frameworkModel, URL url, HttpChannel httpChannel) {\n+    protected AbstractServerTransportListener(FrameworkModel frameworkModel, URL url, HttpChannel httpChannel) {\n         this.frameworkModel = frameworkModel;\n         this.url = url;\n         this.httpChannel = httpChannel;\n@@ -211,7 +211,10 @@ protected RpcInvocation buildRpcInvocation(RpcInvocationBuildContext context) {\n         inv.setObjectAttachments(StreamUtils.toAttachments(httpMetadata.headers()));\n         inv.put(REMOTE_ADDRESS_KEY, httpChannel.remoteAddress());\n         inv.getAttributes().putAll(context.getAttributes());\n-\n+        String consumerAppName = httpMetadata.headers().getFirst(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader());\n+        if (null != consumerAppName) {\n+            inv.put(TripleHeaderEnum.CONSUMER_APP_NAME_KEY, consumerAppName);\n+        }\n         // customizer RpcInvocation\n         headerFilters.forEach(f -> f.invoke(invoker, inv));\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n@@ -34,7 +34,6 @@\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.protocol.tri.DescriptorUtils;\n import org.apache.dubbo.rpc.protocol.tri.RpcInvocationBuildContext;\n-import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n import org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\n import org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\n import org.apache.dubbo.rpc.protocol.tri.h12.HttpMessageListener;\n@@ -120,11 +119,6 @@ protected RpcInvocation onBuildRpcInvocationCompletion(RpcInvocation invocation)\n                             getContext().getServiceDescriptor().getInterfaceName(),\n                             getContext().getMethodName()));\n         }\n-        String consumerAppKey =\n-                getHttpMetadata().headers().getFirst(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader());\n-        if (null != consumerAppKey) {\n-            invocation.put(TripleHeaderEnum.CONSUMER_APP_NAME_KEY, consumerAppKey);\n-        }\n         return invocation;\n     }",
    "output": "Add application name on http1 and http2"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java b/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java\n@@ -25,11 +25,13 @@\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.resource.Disposable;\n import org.apache.dubbo.common.utils.ConcurrentHashMapUtils;\n+import org.apache.dubbo.common.utils.ConcurrentHashSet;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.rpc.model.ScopeModelAccessor;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -53,7 +55,7 @@ public class ScopeBeanFactory {\n     private final List<BeanInfo> registeredBeanInfos = new CopyOnWriteArrayList<>();\n     private InstantiationStrategy instantiationStrategy;\n     private final AtomicBoolean destroyed = new AtomicBoolean();\n-    private List<Class<?>> registeredClasses = new ArrayList<>();\n+    private final Set<Class<?>> registeredClasses = new ConcurrentHashSet<>();\n     public ScopeBeanFactory(ScopeBeanFactory parent, ExtensionAccessor extensionAccessor) {\n         this.parent = parent;\n@@ -299,7 +301,7 @@ public BeanInfo(String name, Object instance) {\n         }\n     }\n-    public List<Class<?>> getRegisteredClasses() {\n+    public Set<Class<?>> getRegisteredClasses() {\n         return registeredClasses;\n     }\n }",
    "output": "Fix memory leak in ScopeBeanFactory"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerContextFilter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerContextFilter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerContextFilter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerContextFilter.java\n@@ -19,7 +19,6 @@\n import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.utils.CollectionUtils;\n-import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.rpc.AsyncRpcResult;\n import org.apache.dubbo.rpc.Filter;\n import org.apache.dubbo.rpc.Invocation;\n@@ -63,10 +62,7 @@ public ConsumerContextFilter(ApplicationModel applicationModel) {\n     @Override\n     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n-        RpcContext.getServiceContext()\n-                .setInvoker(invoker)\n-                .setInvocation(invocation)\n-                .setLocalAddress(NetUtils.getLocalHost(), 0);\n+        RpcContext.getServiceContext().setInvoker(invoker).setInvocation(invocation);\n         RpcContext context = RpcContext.getClientAttachment();\n         context.setAttachment(REMOTE_APPLICATION_KEY, invoker.getUrl().getApplication());\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n@@ -34,6 +34,7 @@\n import org.apache.dubbo.rpc.InvokeMode;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n+import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.protocol.AbstractInvoker;\n@@ -98,6 +99,7 @@ protected Result doInvoke(final Invocation invocation) throws Throwable {\n         } else {\n             currentClient = exchangeClients.get(index.getAndIncrement() % exchangeClients.size());\n         }\n+        RpcContext.getServiceContext().setLocalAddress(currentClient.getLocalAddress());\n         try {\n             boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -155,6 +155,7 @@ protected Result doInvoke(final Invocation invocation) {\n                 isSync(methodDescriptor, invocation) ? new ThreadlessExecutor() : streamExecutor;\n         ClientCall call = new TripleClientCall(\n                 connectionClient, callbackExecutor, getUrl().getOrDefaultFrameworkModel(), writeQueue);\n+        RpcContext.getServiceContext().setLocalAddress(connectionClient.getLocalAddress());\n         AsyncRpcResult result;\n         try {\n             switch (methodDescriptor.getRpcType()) {",
    "output": "Fix RpcContext local address info get null on custom filter * fix: RpcContext local address info get null on custom filter * fix ci build failed * fix ci build failed"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerCallListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerCallListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerCallListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerCallListener.java\n@@ -31,6 +31,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.REMOTE_APPLICATION_KEY;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_TIMEOUT_SERVER;\n+import static org.apache.dubbo.rpc.protocol.tri.TripleConstant.REMOTE_ADDRESS_KEY;\n public abstract class AbstractServerCallListener implements ServerCallListener {\n@@ -56,7 +57,7 @@ public void invoke() {\n                     ((Http2CancelableStreamObserver<Object>) responseObserver).getCancellationContext());\n         }\n         InetSocketAddress remoteAddress =\n-                (InetSocketAddress) invocation.getAttributes().remove(\"tri.remote.address\");\n+                (InetSocketAddress) invocation.getAttributes().remove(REMOTE_ADDRESS_KEY);\n         RpcContext.getServiceContext().setRemoteAddress(remoteAddress);\n         String remoteApp = (String) invocation.getAttributes().remove(TripleHeaderEnum.CONSUMER_APP_NAME_KEY);\n         if (null != remoteApp) {\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n@@ -34,7 +34,6 @@\n import org.apache.dubbo.rpc.model.MethodDescriptor;\n import org.apache.dubbo.rpc.protocol.tri.DescriptorUtils;\n import org.apache.dubbo.rpc.protocol.tri.RpcInvocationBuildContext;\n-import org.apache.dubbo.rpc.protocol.tri.TripleConstant;\n import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n import org.apache.dubbo.rpc.protocol.tri.route.DefaultRequestRouter;\n import org.apache.dubbo.rpc.protocol.tri.route.RequestRouter;\n@@ -47,6 +46,7 @@\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_ERROR_USE_THREAD_POOL;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_PARSE;\n+import static org.apache.dubbo.rpc.protocol.tri.TripleConstant.REMOTE_ADDRESS_KEY;\n public abstract class AbstractServerTransportListener<HEADER extends RequestMetadata, MESSAGE extends HttpInputMessage>\n         implements HttpTransportListener<HEADER, MESSAGE> {\n@@ -209,7 +209,7 @@ protected RpcInvocation buildRpcInvocation(RpcInvocationBuildContext context) {\n         inv.setTargetServiceUniqueName(url.getServiceKey());\n         inv.setReturnTypes(methodDescriptor.getReturnTypes());\n         inv.setObjectAttachments(StreamUtils.toAttachments(httpMetadata.headers()));\n-        inv.put(TripleConstant.REMOTE_ADDRESS_KEY, httpChannel.remoteAddress());\n+        inv.put(REMOTE_ADDRESS_KEY, httpChannel.remoteAddress());\n         inv.getAttributes().putAll(context.getAttributes());\n         // customizer RpcInvocation\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n@@ -34,6 +34,7 @@\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.protocol.tri.DescriptorUtils;\n import org.apache.dubbo.rpc.protocol.tri.RpcInvocationBuildContext;\n+import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n import org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\n import org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\n import org.apache.dubbo.rpc.protocol.tri.h12.HttpMessageListener;\n@@ -119,6 +120,11 @@ protected RpcInvocation onBuildRpcInvocationCompletion(RpcInvocation invocation)\n                             getContext().getServiceDescriptor().getInterfaceName(),\n                             getContext().getMethodName()));\n         }\n+        String consumerAppKey =\n+                getHttpMetadata().headers().getFirst(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader());\n+        if (null != consumerAppKey) {\n+            invocation.put(TripleHeaderEnum.CONSUMER_APP_NAME_KEY, consumerAppKey);\n+        }\n         return invocation;\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListenerFactory.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListenerFactory.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListenerFactory.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListenerFactory.java\n@@ -21,18 +21,17 @@\n import org.apache.dubbo.remoting.http12.h2.Http2ServerTransportListenerFactory;\n import org.apache.dubbo.remoting.http12.h2.Http2TransportListener;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n+import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n public class GrpcHttp2ServerTransportListenerFactory implements Http2ServerTransportListenerFactory {\n-    public static final String CONTENT_TYPE = \"application/grpc\";\n-\n     @Override\n     public Http2TransportListener newInstance(H2StreamChannel streamChannel, URL url, FrameworkModel frameworkModel) {\n         return new GrpcHttp2ServerTransportListener(streamChannel, url, frameworkModel);\n     }\n     @Override\n     public boolean supportContentType(String contentType) {\n-        return contentType != null && contentType.startsWith(CONTENT_TYPE);\n+        return contentType != null && contentType.startsWith(TripleHeaderEnum.APPLICATION_GRPC.getHeader());\n     }\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/DefaultHttp11ServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/DefaultHttp11ServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/DefaultHttp11ServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/DefaultHttp11ServerTransportListener.java\n@@ -88,7 +88,7 @@ private ServerCallListener startListener(\n                 return new AutoCompleteUnaryServerCallListener(invocation, invoker, serverChannelObserver);\n             case SERVER_STREAM:\n                 serverChannelObserver = new Http1ServerStreamChannelObserver(httpChannel);\n-                serverChannelObserver.setHeadersCustomizer((headers) ->\n+                serverChannelObserver.setHeadersCustomizer(headers ->\n                         headers.set(HttpHeaderNames.CONTENT_TYPE.getName(), MediaType.TEXT_EVENT_STREAM.getName()));\n                 return new AutoCompleteServerStreamServerCallListener(invocation, invoker, serverChannelObserver);\n             default:\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/Http2ServerCallToObserverAdapter.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/Http2ServerCallToObserverAdapter.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/Http2ServerCallToObserverAdapter.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/Http2ServerCallToObserverAdapter.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.remoting.http12.h2.H2StreamChannel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n+import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n import org.apache.dubbo.rpc.protocol.tri.h12.ServerCallToObserverAdapter;\n public class Http2ServerCallToObserverAdapter extends Http2ServerStreamObserver\n@@ -27,9 +28,9 @@ public class Http2ServerCallToObserverAdapter extends Http2ServerStreamObserver\n     public Http2ServerCallToObserverAdapter(FrameworkModel frameworkModel, H2StreamChannel h2StreamChannel) {\n         super(frameworkModel, h2StreamChannel);\n-        setHeadersCustomizer((headers) -> {\n+        setHeadersCustomizer(headers -> {\n             if (exceptionCode != 0) {\n-                headers.set(\"tri-exception-code\", String.valueOf(exceptionCode));\n+                headers.set(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader(), String.valueOf(exceptionCode));\n             }\n         });\n     }",
    "output": "Fix obtaining remote application name on the server side"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring6/src/main/java/org/apache/dubbo/config/spring6/utils/AotUtils.java b/dubbo-config/dubbo-config-spring6/src/main/java/org/apache/dubbo/config/spring6/utils/AotUtils.java\n--- a/dubbo-config/dubbo-config-spring6/src/main/java/org/apache/dubbo/config/spring6/utils/AotUtils.java\n+++ b/dubbo-config/dubbo-config-spring6/src/main/java/org/apache/dubbo/config/spring6/utils/AotUtils.java\n@@ -59,7 +59,9 @@ private static void registerSerializationType(\n                     }\n                 }));\n-                registerSerializationType(registerType.getSuperclass(), hints, serializationTypeCache);\n+                if (registerType.getSuperclass() != null) {\n+                    registerSerializationType(registerType.getSuperclass(), hints, serializationTypeCache);\n+                }\n             }\n         }\n     }\ndiff --git a/dubbo-config/dubbo-config-spring6/src/test/java/org/apache/dubbo/config/spring6/utils/DemoService.java b/dubbo-config/dubbo-config-spring6/src/test/java/org/apache/dubbo/config/spring6/utils/DemoService.java\n--- a/dubbo-config/dubbo-config-spring6/src/test/java/org/apache/dubbo/config/spring6/utils/DemoService.java\n+++ b/dubbo-config/dubbo-config-spring6/src/test/java/org/apache/dubbo/config/spring6/utils/DemoService.java\n@@ -19,4 +19,6 @@\n public interface DemoService {\n     HelloResponse sayHello(HelloRequest request);\n+\n+    String sayHelloForSerializable(java.io.Serializable name);\n }",
    "output": "Fix AotUtils NPE"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n@@ -339,7 +339,7 @@ public static String decode(String value) {\n     }\n     static String appendDefaultPort(String address, int defaultPort) {\n-        if (address != null && address.length() > 0 && defaultPort > 0) {\n+        if (StringUtils.isNotEmpty(address) && defaultPort > 0) {\n             int i = address.indexOf(':');\n             if (i < 0) {\n                 return address + \":\" + defaultPort;\n@@ -525,7 +525,7 @@ public List<URL> getBackupUrls() {\n         List<URL> urls = new ArrayList<>();\n         urls.add(this);\n         String[] backups = getParameter(RemotingConstants.BACKUP_KEY, new String[0]);\n-        if (backups != null && backups.length > 0) {\n+        if (ArrayUtils.isNotEmpty(backups)) {\n             for (String backup : backups) {\n                 urls.add(this.setAddress(backup));\n             }\n@@ -805,7 +805,7 @@ public boolean getParameter(String key, boolean defaultValue) {\n     public boolean hasParameter(String key) {\n         String value = getParameter(key);\n-        return value != null && value.length() > 0;\n+        return StringUtils.isNotEmpty(value);\n     }\n     public String getMethodParameterAndDecoded(String method, String key) {\n@@ -1061,7 +1061,7 @@ public URL addParametersIfAbsent(Map<String, String> parameters) {\n     }\n     public URL addParameters(String... pairs) {\n-        if (pairs == null || pairs.length == 0) {\n+        if (ArrayUtils.isEmpty(pairs)) {\n             return this;\n         }\n         if (pairs.length % 2 != 0) {\n@@ -1589,9 +1589,9 @@ public Map<String, Object> getAttributes() {\n         return attributes == null ? Collections.emptyMap() : attributes;\n     }\n-    public URL addAttributes(Map<String, Object> attributes) {\n-        if (attributes != null) {\n-            attributes.putAll(attributes);\n+    public URL addAttributes(Map<String, Object> attributeMap) {\n+        if (attributeMap != null) {\n+            attributes.putAll(attributeMap);\n         }\n         return this;\n     }\n@@ -1718,7 +1718,7 @@ public boolean getServiceParameter(String service, String key, boolean defaultVa\n     public boolean hasServiceParameter(String service, String key) {\n         String value = getServiceParameter(service, key);\n-        return value != null && value.length() > 0;\n+        return StringUtils.isNotEmpty(value);\n     }\n     public float getPositiveServiceParameter(String service, String key, float defaultValue) {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.common;\n import org.apache.dubbo.common.url.component.ServiceConfigURL;\n+import org.apache.dubbo.common.utils.ArrayUtils;\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.rpc.model.ScopeModel;\n@@ -376,7 +377,7 @@ public URLBuilder addParametersIfAbsent(Map<String, String> parameters) {\n     @Override\n     public URLBuilder addParameters(String... pairs) {\n-        if (pairs == null || pairs.length == 0) {\n+        if (ArrayUtils.isEmpty(pairs)) {\n             return this;\n         }\n         if (pairs.length % 2 != 0) {\n@@ -416,7 +417,7 @@ public URLBuilder removeParameters(Collection<String> keys) {\n     @Override\n     public URLBuilder removeParameters(String... keys) {\n-        if (keys == null || keys.length == 0) {\n+        if (ArrayUtils.isEmpty(keys)) {\n             return this;\n         }\n         for (String key : keys) {\n@@ -458,7 +459,7 @@ public boolean hasMethodParameter(String method, String key) {\n             return false;\n         }\n         String value = getMethodParameter(method, key);\n-        return value != null && value.length() > 0;\n+        return StringUtils.isNotEmpty(value);\n     }\n     @Override\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceConfigURL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceConfigURL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceConfigURL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceConfigURL.java\n@@ -113,12 +113,12 @@ protected <T extends URL> T newURL(URLAddress urlAddress, URLParam urlParam) {\n     }\n     @Override\n-    public URL addAttributes(Map<String, Object> attributes) {\n+    public URL addAttributes(Map<String, Object> attributeMap) {\n         Map<String, Object> newAttributes = new HashMap<>();\n         if (this.attributes != null) {\n             newAttributes.putAll(this.attributes);\n         }\n-        newAttributes.putAll(attributes);\n+        newAttributes.putAll(attributeMap);\n         return new ServiceConfigURL(getUrlAddress(), getUrlParam(), newAttributes);\n     }\ndiff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/DelegateURL.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/DelegateURL.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/DelegateURL.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/DelegateURL.java\n@@ -854,8 +854,8 @@ public Map<String, Object> getAttributes() {\n     }\n     @Override\n-    public org.apache.dubbo.common.URL addAttributes(Map<String, Object> attributes) {\n-        return apacheUrl.addAttributes(attributes);\n+    public org.apache.dubbo.common.URL addAttributes(Map<String, Object> attributeMap) {\n+        return apacheUrl.addAttributes(attributeMap);\n     }\n     @Override",
    "output": "Fix URL issue"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java\n@@ -528,6 +528,9 @@ private AbstractBeanDefinition buildServiceBeanDefinition(\n             addPropertyReference(builder, \"executor\", executorBeanName);\n         }\n+        // service bean definition should not be lazy\n+        builder.setLazyInit(false);\n+\n         return builder.getBeanDefinition();\n     }",
    "output": "Fix lazy property of serviceBeanDefinition to false"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java\n@@ -29,8 +29,6 @@\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_UNEXPECTED_EXCEPTION;\n-\n public class ModuleEnvironment extends Environment implements ModuleExt {\n     // delegate\n@@ -94,19 +92,13 @@ public List<Map<String, String>> getConfigurationMaps(AbstractConfig config, Str\n     @Override\n     public Configuration getDynamicGlobalConfiguration() {\n         if (dynamicConfiguration == null) {\n-            return applicationDelegate.getDynamicGlobalConfiguration();\n+            CompositeConfiguration configuration = new CompositeConfiguration();\n+            configuration.addConfiguration(applicationDelegate.getDynamicGlobalConfiguration());\n+            configuration.addConfiguration(orderedPropertiesConfiguration);\n+            return configuration;\n         }\n+\n         if (dynamicGlobalConfiguration == null) {\n-            if (dynamicConfiguration == null) {\n-                if (logger.isWarnEnabled()) {\n-                    logger.warn(\n-                            COMMON_UNEXPECTED_EXCEPTION,\n-                            \"\",\n-                            \"\",\n-                            \"dynamicConfiguration is null , return globalConfiguration.\");\n-                }\n-                return getConfiguration();\n-            }\n             dynamicGlobalConfiguration = new CompositeConfiguration();\n             dynamicGlobalConfiguration.addConfiguration(dynamicConfiguration);\n             dynamicGlobalConfiguration.addConfiguration(getConfiguration());\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/config/OrderedPropertiesConfigurationTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/config/OrderedPropertiesConfigurationTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/config/OrderedPropertiesConfigurationTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/config/OrderedPropertiesConfigurationTest.java\n@@ -17,6 +17,8 @@\n package org.apache.dubbo.common.config;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.FrameworkModel;\n+import org.apache.dubbo.rpc.model.ModuleModel;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n@@ -32,4 +34,18 @@ void testOrderPropertiesProviders() {\n                 ApplicationModel.defaultModel().getDefaultModule());\n         Assertions.assertEquals(\"999\", configuration.getInternalProperty(\"testKey\"));\n     }\n+\n+    @Test\n+    void testGetPropertyFromOrderedPropertiesConfiguration() {\n+        FrameworkModel frameworkModel = new FrameworkModel();\n+\n+        ApplicationModel applicationModel = frameworkModel.newApplication();\n+\n+        ModuleModel moduleModel = applicationModel.newModule();\n+        ModuleEnvironment moduleEnvironment = moduleModel.modelEnvironment();\n+\n+        Configuration configuration = moduleEnvironment.getDynamicGlobalConfiguration();\n+        // MockOrderedPropertiesProvider2  initProperties\n+        Assertions.assertEquals(\"999\", configuration.getString(\"testKey\"));\n+    }\n }",
    "output": "Fix ModuleEnvironment#getDynamicGlobalConfiguration * Update ModuleEnvironment#getDynamicGlobalConfiguration * add unit test * update"
  },
  {
    "input": "diff --git a/dubbo-demo/dubbo-demo-interface/src/main/java/org/apache/dubbo/demo/RestDemoService.java b/dubbo-demo/dubbo-demo-interface/src/main/java/org/apache/dubbo/demo/RestDemoService.java\n--- a/dubbo-demo/dubbo-demo-interface/src/main/java/org/apache/dubbo/demo/RestDemoService.java\n+++ b/dubbo-demo/dubbo-demo-interface/src/main/java/org/apache/dubbo/demo/RestDemoService.java\n@@ -65,7 +65,7 @@ public interface RestDemoService {\n     Boolean testBody2(Boolean b);\n     @POST\n-    @Path(\"/testBody3\")\n+    @Path(\"/testBody4\")\n     @Consumes({MediaType.TEXT_PLAIN})\n     TestPO testBody2(TestPO b);\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/ResteasyContext.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/ResteasyContext.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/ResteasyContext.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/ResteasyContext.java\n@@ -169,10 +169,13 @@ default void addResponseHeaders(NettyHttpResponse response, MultivaluedMap<Strin\n         for (Map.Entry<String, List<Object>> entry : headers.entrySet()) {\n             String key = entry.getKey();\n-            if (entry.getValue() == null) {\n+            List<Object> value = entry.getValue();\n+            if (value == null || value.isEmpty()) {\n                 continue;\n             }\n-            response.addOutputHeaders(key, entry.getValue().toString());\n+            for (Object tmp : value) {\n+                response.addOutputHeaders(key, tmp.toString());\n+            }\n         }\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/filter/ResteasyNettyHttpResponse.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/filter/ResteasyNettyHttpResponse.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/filter/ResteasyNettyHttpResponse.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/filter/ResteasyNettyHttpResponse.java\n@@ -42,7 +42,14 @@ public ResteasyNettyHttpResponse(NettyHttpResponse response) {\n         for (Map.Entry<String, List<String>> headers : outputHeaders.entrySet()) {\n             String key = headers.getKey();\n             List<String> value = headers.getValue();\n-            multivaluedMap.add(key, value);\n+\n+            if (value == null || value.isEmpty()) {\n+                continue;\n+            }\n+\n+            for (String val : value) {\n+                multivaluedMap.add(key, val);\n+            }\n         }\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/message/codec/JsonCodec.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/message/codec/JsonCodec.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/message/codec/JsonCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/message/codec/JsonCodec.java\n@@ -33,13 +33,12 @@\n /**\n  * body is json\n  */\n-@Activate(\"json\")\n+@Activate(value = \"json\", order = 100)\n public class JsonCodec implements HttpMessageCodec<byte[], OutputStream> {\n     private static final Set<Class> unSupportClasses = new HashSet<>();\n     static {\n         unSupportClasses.add(byte[].class);\n-        unSupportClasses.add(String.class);\n     }\n     public static void addUnSupportClass(Class<?> unSupportClass) {\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/message/codec/StringCodec.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/message/codec/StringCodec.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/message/codec/StringCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/message/codec/StringCodec.java\n@@ -28,7 +28,7 @@\n /**\n  *  body is string\n  */\n-@Activate(\"string\")\n+@Activate(value = \"string\", order = 200)\n public class StringCodec implements HttpMessageCodec<byte[], OutputStream> {\n     @Override\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/NettyHttpResponse.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/NettyHttpResponse.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/NettyHttpResponse.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/NettyHttpResponse.java\n@@ -190,6 +190,10 @@ public void addOutputHeaders(String name, String value) {\n             outputHeaders.put(name, values);\n         }\n+        if (values.contains(value)) {\n+            return;\n+        }\n+\n         values.add(value);\n     }",
    "output": "Fix incorrect rest response header and demo double path error * fix dubbo demo xml double path error * fix restEasy response headers formate * fix content-type judge * remove unused code"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/codec/YamlCodec.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/codec/YamlCodec.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/codec/YamlCodec.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/codec/YamlCodec.java\n@@ -36,12 +36,13 @@\n import org.yaml.snakeyaml.constructor.Constructor;\n import org.yaml.snakeyaml.representer.Representer;\n+@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n public class YamlCodec implements HttpMessageCodec {\n     @Override\n     public Object decode(InputStream is, Class<?> targetType, Charset charset) throws DecodeException {\n         try (InputStreamReader reader = new InputStreamReader(is, charset)) {\n-            return createYaml().loadAs(reader, targetType);\n+            return createYaml().loadAs(reader, (Class) targetType);\n         } catch (Throwable t) {\n             throw new DecodeException(\"Error decoding yaml\", t);\n         }\n@@ -57,7 +58,7 @@ public Object[] decode(InputStream is, Class<?>[] targetTypes, Charset charset)\n             for (int i = 0; i < len; i++) {\n                 if (iterator.hasNext()) {\n                     Object result = iterator.next();\n-                    Class<?> targetType = targetTypes[i];\n+                    Class targetType = targetTypes[i];\n                     if (targetType.isInstance(result)) {\n                         results[i] = result;\n                     } else {",
    "output": "Fix compilation error of YamlCodec in jdk1.8"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-rest-jaxrs/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/jaxrs/JaxrsRestToolKit.java b/dubbo-plugin/dubbo-rest-jaxrs/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/jaxrs/JaxrsRestToolKit.java\n--- a/dubbo-plugin/dubbo-rest-jaxrs/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/jaxrs/JaxrsRestToolKit.java\n+++ b/dubbo-plugin/dubbo-rest-jaxrs/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/jaxrs/JaxrsRestToolKit.java\n@@ -23,6 +23,9 @@\n import org.apache.dubbo.rpc.protocol.tri.rest.mapping.meta.ParameterMeta;\n import org.apache.dubbo.rpc.protocol.tri.rest.util.DefaultRestToolKit;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n final class JaxrsRestToolKit extends DefaultRestToolKit {\n     private final BeanArgumentBinder binder;\n@@ -32,6 +35,17 @@ public JaxrsRestToolKit(FrameworkModel frameworkModel) {\n         binder = new BeanArgumentBinder(frameworkModel);\n     }\n+    @Override\n+    public Object convert(Object value, ParameterMeta parameter) {\n+        if (MultivaluedMap.class.isAssignableFrom(parameter.getType())) {\n+            if (value instanceof MultivaluedMap) {\n+                return value;\n+            }\n+            return typeConverter.convert(value, MultivaluedHashMap.class);\n+        }\n+        return super.convert(value, parameter);\n+    }\n+\n     @Override\n     public int getDialect() {\n         return RestConstants.DIALECT_JAXRS;\ndiff --git a/dubbo-plugin/dubbo-rest-jaxrs/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/jaxrs/MultivaluedMapCreationConverter.java b/dubbo-plugin/dubbo-rest-jaxrs/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/jaxrs/MultivaluedMapCreationConverter.java\n--- a/dubbo-plugin/dubbo-rest-jaxrs/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/jaxrs/MultivaluedMapCreationConverter.java\n+++ b/dubbo-plugin/dubbo-rest-jaxrs/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/support/jaxrs/MultivaluedMapCreationConverter.java\n@@ -1,31 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.rpc.protocol.tri.rest.support.jaxrs;\n-\n-import org.apache.dubbo.common.convert.Converter;\n-\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-@SuppressWarnings(\"rawtypes\")\n-public class MultivaluedMapCreationConverter implements Converter<Integer, MultivaluedMap> {\n-\n-    @Override\n-    public MultivaluedMap<?, ?> convert(Integer source) {\n-        return new MultivaluedHashMap<>(source);\n-    }\n-}\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/argument/GeneralTypeConverter.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/argument/GeneralTypeConverter.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/argument/GeneralTypeConverter.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/rest/argument/GeneralTypeConverter.java\n@@ -730,11 +730,11 @@ protected Object customConvert(Object source, Type targetType) {\n     }\n     protected Collection customCreateCollection(Class targetClass, int size) {\n-        return null;\n+        return converterUtil == null ? null : (Collection) converterUtil.convertIfPossible(size, targetClass);\n     }\n-    private Map customCreateMap(Class targetClass, int size) {\n-        return null;\n+    protected Map customCreateMap(Class targetClass, int size) {\n+        return converterUtil == null ? null : (Map) converterUtil.convertIfPossible(size, targetClass);\n     }\n     private Collection createCollection(Class targetClass, int size) {\n@@ -792,10 +792,6 @@ private Collection createCollection(Class targetClass, int size) {\n         if (collection != null) {\n             return collection;\n         }\n-        collection = (Collection) converterUtil.convertIfPossible(size, targetClass);\n-        if (collection != null) {\n-            return collection;\n-        }\n         if (targetClass.isAssignableFrom(ArrayList.class)) {\n             return new ArrayList<>(size);\n         }\n@@ -934,10 +930,6 @@ private Map createMap(Class targetClass, int size) {\n         if (map != null) {\n             return map;\n         }\n-        map = (Map) converterUtil.convertIfPossible(size, targetClass);\n-        if (map != null) {\n-            return map;\n-        }\n         if (targetClass.isAssignableFrom(LinkedHashMap.class)) {\n             return CollectionUtils.newLinkedHashMap(size);\n         }",
    "output": "Fix(rest): Fix rest convert error"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/api/EmptyWireProtocol.java b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/api/EmptyWireProtocol.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/api/EmptyWireProtocol.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/api/EmptyWireProtocol.java\n@@ -17,11 +17,13 @@\n package org.apache.dubbo.remoting.transport.netty4.api;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.remoting.api.ProtocolDetector;\n import org.apache.dubbo.remoting.api.WireProtocol;\n import org.apache.dubbo.remoting.api.pu.ChannelOperator;\n import org.apache.dubbo.remoting.api.ssl.ContextOperator;\n+@Activate\n public class EmptyWireProtocol implements WireProtocol {\n     @Override\n     public ProtocolDetector detector() {",
    "output": "Fix ut failure"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -55,7 +55,6 @@\n import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_NO_METHOD_FOUND;\n-import static org.apache.dubbo.common.constants.MetricsConstants.PROTOCOL_PROMETHEUS;\n import static org.apache.dubbo.config.Constants.DEFAULT_NATIVE_PROXY;\n /**\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n@@ -18,14 +18,13 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.remoting.ChannelHandler;\n import org.apache.dubbo.remoting.RemotingException;\n import org.apache.dubbo.remoting.api.WireProtocol;\n import org.apache.dubbo.remoting.transport.AbstractServer;\n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.function.Function;\n@@ -57,8 +56,8 @@ public abstract class AbstractPortUnificationServer extends AbstractServer {\n     public AbstractPortUnificationServer(URL url, ChannelHandler handler) throws RemotingException {\n         super(url, handler);\n         ExtensionLoader<WireProtocol> loader = url.getOrDefaultFrameworkModel().getExtensionLoader(WireProtocol.class);\n-        Map<String, WireProtocol> protocols = extensionLoader.getActivateExtension(url, new String[0]).stream()\n-                .collect(Collectors.toConcurrentMap(extensionLoader::getExtensionName, Function.identity()))\n+        Map<String, WireProtocol> protocols = loader.getActivateExtension(url, new String[0]).stream()\n+                .collect(Collectors.toConcurrentMap(loader::getExtensionName, Function.identity()));\n         // load extra protocols\n         String extraProtocols = url.getParameter(EXT_PROTOCOL);\n         if (StringUtils.isNotEmpty(extraProtocols)) {",
    "output": "Fix style"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/builder/DefaultTypeBuilder.java b/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/builder/DefaultTypeBuilder.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/builder/DefaultTypeBuilder.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/builder/DefaultTypeBuilder.java\n@@ -32,15 +32,18 @@\n public final class DefaultTypeBuilder {\n     public static TypeDefinition build(Class<?> clazz, Map<String, TypeDefinition> typeCache) {\n-        final String canonicalName = clazz.getCanonicalName();\n+        String className = clazz.getCanonicalName();\n+        if (className == null) {\n+            className = clazz.getName();\n+        }\n         // Try to get a cached definition\n-        TypeDefinition td = typeCache.get(canonicalName);\n+        TypeDefinition td = typeCache.get(className);\n         if (td != null) {\n             return td;\n         }\n-        td = new TypeDefinition(canonicalName);\n-        typeCache.put(canonicalName, td);\n+        td = new TypeDefinition(className);\n+        typeCache.put(className, td);\n         // Primitive type\n         if (!JaketConfigurationUtils.needAnalyzing(clazz)) {\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/metadata/definition/DefaultTypeBuilderTest.java b/dubbo-common/src/test/java/org/apache/dubbo/metadata/definition/DefaultTypeBuilderTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/metadata/definition/DefaultTypeBuilderTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/metadata/definition/DefaultTypeBuilderTest.java\n@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.metadata.definition;\n+\n+import org.apache.dubbo.metadata.definition.builder.DefaultTypeBuilder;\n+import org.apache.dubbo.rpc.model.FrameworkModel;\n+\n+import java.util.HashMap;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+public class DefaultTypeBuilderTest {\n+    @Test\n+    void testInnerClass() {\n+        TypeDefinitionBuilder.initBuilders(FrameworkModel.defaultModel());\n+\n+        Assertions.assertEquals(\n+                String.class.getName(),\n+                DefaultTypeBuilder.build(String.class, new HashMap<>()).getType());\n+\n+        DefaultTypeBuilderTest innerObject = new DefaultTypeBuilderTest() {};\n+        Assertions.assertEquals(\n+                DefaultTypeBuilderTest.class.getName() + \"$1\",\n+                DefaultTypeBuilder.build(innerObject.getClass(), new HashMap<>())\n+                        .getType());\n+\n+        TypeDefinitionBuilder.BUILDERS = null;\n+    }\n+}",
    "output": "Fix NPE in DefaultTypeBuilder * Fix NPE in DefaultTypeBuilder * Fix style"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java\n@@ -17,17 +17,23 @@\n package org.apache.dubbo.remoting.api.pu;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.remoting.ChannelHandler;\n import org.apache.dubbo.remoting.RemotingException;\n import org.apache.dubbo.remoting.api.WireProtocol;\n import org.apache.dubbo.remoting.transport.AbstractServer;\n-import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n public abstract class AbstractPortUnificationServer extends AbstractServer {\n-    private final List<WireProtocol> protocols;\n+\n+    /**\n+     * extension name -> activate WireProtocol\n+     */\n+    private final Map<String, WireProtocol> protocols;\n     /*\n     protocol name --> URL object\n@@ -44,12 +50,13 @@ public abstract class AbstractPortUnificationServer extends AbstractServer {\n     public AbstractPortUnificationServer(URL url, ChannelHandler handler) throws RemotingException {\n         super(url, handler);\n-        this.protocols = url.getOrDefaultFrameworkModel()\n-                .getExtensionLoader(WireProtocol.class)\n-                .getActivateExtension(url, new String[0]);\n+        ExtensionLoader<WireProtocol> extensionLoader =\n+                url.getOrDefaultFrameworkModel().getExtensionLoader(WireProtocol.class);\n+        this.protocols = extensionLoader.getActivateExtension(url, new String[0]).stream()\n+                .collect(Collectors.toConcurrentMap(extensionLoader::getExtensionName, Function.identity()));\n     }\n-    public List<WireProtocol> getProtocols() {\n+    public Map<String, WireProtocol> getProtocols() {\n         return protocols;\n     }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyPortUnificationServer.java b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyPortUnificationServer.java\n--- a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyPortUnificationServer.java\n+++ b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyPortUnificationServer.java\n@@ -156,7 +156,7 @@ protected void doClose() {\n         } catch (Throwable e) {\n             logger.warn(TRANSPORT_FAILED_CLOSE, \"\", \"\", e.getMessage(), e);\n         }\n-        for (WireProtocol protocol : getProtocols()) {\n+        for (WireProtocol protocol : getProtocols().values()) {\n             protocol.close();\n         }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java\n@@ -200,7 +200,7 @@ public void doClose() {\n             logger.warn(TRANSPORT_FAILED_CLOSE, \"\", \"\", e.getMessage(), e);\n         }\n-        for (WireProtocol protocol : getProtocols()) {\n+        for (WireProtocol protocol : getProtocols().values()) {\n             protocol.close();\n         }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java\n@@ -30,6 +30,7 @@\n import javax.net.ssl.SSLSession;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -51,14 +52,14 @@ public class NettyPortUnificationServerHandler extends ByteToMessageDecoder {\n     private final URL url;\n     private final ChannelHandler handler;\n     private final boolean detectSsl;\n-    private final List<WireProtocol> protocols;\n+    private final Map<String, WireProtocol> protocols;\n     private final Map<String, URL> urlMapper;\n     private final Map<String, ChannelHandler> handlerMapper;\n     public NettyPortUnificationServerHandler(\n             URL url,\n             boolean detectSsl,\n-            List<WireProtocol> protocols,\n+            Map<String, WireProtocol> protocols,\n             ChannelHandler handler,\n             Map<String, URL> urlMapper,\n             Map<String, ChannelHandler> handlerMapper) {\n@@ -118,7 +119,11 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t\n         if (providerConnectionConfig != null && isSsl(in)) {\n             enableSsl(ctx, providerConnectionConfig);\n         } else {\n-            for (final WireProtocol protocol : protocols) {\n+            Set<String> supportedProtocolNames = new HashSet<>(protocols.keySet());\n+            supportedProtocolNames.retainAll(urlMapper.keySet());\n+\n+            for (final String name : supportedProtocolNames) {\n+                WireProtocol protocol = protocols.get(name);\n                 in.markReaderIndex();\n                 ChannelBuffer buf = new NettyBackedChannelBuffer(in);\n                 final ProtocolDetector.Result result = protocol.detector().detect(buf);\n@@ -127,11 +132,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t\n                     case UNRECOGNIZED:\n                         continue;\n                     case RECOGNIZED:\n-                        String protocolName = url.getOrDefaultFrameworkModel()\n-                                .getExtensionLoader(WireProtocol.class)\n-                                .getExtensionName(protocol);\n-                        ChannelHandler localHandler = this.handlerMapper.getOrDefault(protocolName, handler);\n-                        URL localURL = this.urlMapper.getOrDefault(protocolName, url);\n+                        ChannelHandler localHandler = this.handlerMapper.getOrDefault(name, handler);\n+                        URL localURL = this.urlMapper.getOrDefault(name, url);\n                         channel.setUrl(localURL);\n                         NettyConfigOperator operator = new NettyConfigOperator(channel, localHandler);\n                         protocol.configServerProtocolHandler(url, operator);",
    "output": "Fix port unification issue in triple and dubbo protocol * Fix issue of tri Portunification * style fix"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h1/NettyHttp1ConnectionHandler.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h1/NettyHttp1ConnectionHandler.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h1/NettyHttp1ConnectionHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/netty4/h1/NettyHttp1ConnectionHandler.java\n@@ -56,7 +56,7 @@ public NettyHttp1ConnectionHandler(URL url, FrameworkModel frameworkModel) {\n                 .getExtensionLoader(ThreadPool.class)\n                 .getAdaptiveExtension()\n                 .getExecutor(url);\n-        this.codecUtils = frameworkModel.getBeanFactory().getBean(CodecUtils.class);\n+        this.codecUtils = frameworkModel.getBeanFactory().getOrRegisterBean(CodecUtils.class);\n     }\n     public NettyHttp1ConnectionHandler(\n@@ -69,7 +69,7 @@ public NettyHttp1ConnectionHandler(\n                 .getExtensionLoader(ThreadPool.class)\n                 .getAdaptiveExtension()\n                 .getExecutor(url);\n-        this.codecUtils = frameworkModel.getBeanFactory().getBean(CodecUtils.class);\n+        this.codecUtils = frameworkModel.getBeanFactory().getOrRegisterBean(CodecUtils.class);\n         this.http1ServerTransportListenerFactory = http1ServerTransportListenerFactory;\n     }",
    "output": "Fix potential npe of CodecUtils"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n@@ -38,8 +38,11 @@ class URLStrParserTest {\n         testCases.add(\"dubbo://192.168.1.1\");\n         testCases.add(\"dubbo://192.168.1.1?\");\n         testCases.add(\"dubbo://127.0.0.1?test=\");\n-        testCases.add(\n-                \"dubbo://admin:admin123@192.168.1.41:28113/org.test.api.DemoService$Iface?anyhost=true&application=demo-service&dubbo=2.6.1&generic=false&interface=org.test.api.DemoService$Iface&methods=orbCompare,checkText,checkPicture&pid=65557&revision=1.4.17&service.filter=bootMetrics&side=provider&status=server&threads=200&timestamp=1583136298859&version=1.0.0\");\n+        testCases.add(\"dubbo://admin:admin123@192.168.1.41:28113/org.test.api\"\n+                + \".DemoService$Iface?anyhost=true&application=demo-service&dubbo=2.6.1&generic=false&interface=org\"\n+                + \".test.api.DemoService$Iface&methods=orbCompare,checkText,checkPicture&pid=65557&revision=1.4\"\n+                + \".17&service.filter=bootMetrics&side=provider&status=server&threads=200&timestamp=1583136298859\"\n+                + \"&version=1.0.0\");\n         // super long text test\n         testCases.add(\"dubbo://192.168.1.1/\" + RandomString.make(10240));\n         testCases.add(\"file:/path/to/file.txt\");\n@@ -57,8 +60,8 @@ class URLStrParserTest {\n         errorEncodedCases.add(\"dubbo%3a192.168.1.1%3fabc%3dabc\");\n         errorEncodedCases.add(\"%3a%2f%2f192.168.1.1%3fabc%3dabc\");\n         errorEncodedCases.add(\"%3a%2f192.168.1.1%3fabc%3dabc\");\n-        errorEncodedCases.add(\n-                \"dubbo%3a%2f%2f127.0.0.1%3ftest%3d%e2%96%b2%e2%96%bc%e2%97%80%e2%96%b6%e2%86%90%e2%86%91%e2%86%92%e2%86%93%e2%86%94%e2%86%95%e2%88%9e%c2%b1%e9%be%98%e9%9d%90%e9%bd%89%9%d%b\");\n+        errorEncodedCases.add(\"dubbo%3a%2f%2f127.0.0.1%3ftest%3d%e2%96%b2%e2%96%bc%e2%97%80%e2%96%b6%e2%86%90%e2%86\"\n+                + \"%91%e2%86%92%e2%86%93%e2%86%94%e2%86%95%e2%88%9e%c2%b1%e9%be%98%e9%9d%90%e9%bd%89%9%d%b\");\n     }\n     @Test\n@@ -93,4 +96,17 @@ void testDefault() {\n         assertThat(url2.getParameter(\"timeout\"), equalTo(\"5678\"));\n         assertThat(url2.getParameter(\"default.timeout\"), equalTo(\"5678\"));\n     }\n+\n+    @Test\n+    void testPond() {\n+        String str = \"https://a#@b\";\n+\n+        URL url1 = URL.valueOf(str);\n+        URL url2 = URLStrParser.parseDecodedStr(str);\n+\n+        Assertions.assertEquals(\"https\", url1.getProtocol());\n+        Assertions.assertEquals(\"https\", url2.getProtocol());\n+        Assertions.assertEquals(\"a\", url1.getHost());\n+        Assertions.assertEquals(\"a\", url2.getHost());\n+    }\n }",
    "output": "Add pond test cases"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n@@ -18,12 +18,15 @@\n import org.apache.dubbo.common.url.component.ServiceConfigURL;\n import org.apache.dubbo.common.url.component.URLItemCache;\n+import org.apache.dubbo.common.utils.StringUtils;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY_PREFIX;\n+import static org.apache.dubbo.common.constants.CommonConstants.PASSWORD_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.USERNAME_KEY;\n import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;\n import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;\n import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n@@ -42,8 +45,8 @@ private URLStrParser() {\n     }\n     /**\n-     * @param decodedURLStr : after {@link URL#decode} string\n-     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     * @param decodedURLStr : after {@link URL#decode} string decodedURLStr format:\n+     *                      protocol://username:password@host:port/path?k1=v1&k2=v2\n      *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n      */\n     public static URL parseDecodedStr(String decodedURLStr) {\n@@ -103,6 +106,7 @@ private static URL parseURLBody(String fullURLStr, String decodedBody, Map<Strin\n         int starIdx = 0, endIdx = decodedBody.length();\n         // ignore the url content following '#'\n         int poundIndex = decodedBody.indexOf('#');\n+\n         if (poundIndex != -1) {\n             endIdx = poundIndex;\n         }\n@@ -147,6 +151,15 @@ private static URL parseURLBody(String fullURLStr, String decodedBody, Map<Strin\n             }\n             starIdx = pwdEndIdx + 1;\n         }\n+        if (username == null && parameters != null && StringUtils.isNotEmpty(parameters.get(USERNAME_KEY))) {\n+            username = parameters.get(USERNAME_KEY);\n+            parameters.remove(USERNAME_KEY);\n+        }\n+\n+        if (password == null && parameters != null && StringUtils.isNotEmpty(parameters.get(PASSWORD_KEY))) {\n+            password = parameters.get(PASSWORD_KEY);\n+            parameters.remove(PASSWORD_KEY);\n+        }\n         String host = null;\n         int port = 0;\n@@ -203,8 +216,8 @@ public static Map<String, String> parseParams(String rawParams, boolean encoded)\n     }\n     /**\n-     * @param encodedURLStr : after {@link URL#encode(String)} string\n-     *                      encodedURLStr after decode format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     * @param encodedURLStr : after {@link URL#encode(String)} string encodedURLStr after decode format:\n+     *                      protocol://username:password@host:port/path?k1=v1&k2=v2\n      *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n      */\n     public static URL parseEncodedStr(String encodedURLStr) {\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n@@ -48,6 +48,7 @@ class URLStrParserTest {\n         testCases.add(\"nacos://192.168.1.1:8848?username=&password=\");\n         testCases.add(\"dubbo://127.0.0.1?timeout=1234&default.timeout=5678\");\n         testCases.add(\"dubbo://127.0.0.1?default.timeout=5678\");\n+        testCases.add(\"zookeeper://test10.301.216.302:2181?username=t1#&password=t2#\");\n         errorDecodedCases.add(\"dubbo:192.168.1.1\");\n         errorDecodedCases.add(\"://192.168.1.1\");",
    "output": "Fix URL parse pwd failed when the pwd contains '#' * Fix URL parse pwd failed when the pwd contains #"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java b/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java\n--- a/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java\n+++ b/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java\n@@ -124,8 +124,9 @@ protected void initReferenceRegistry(URL url, Map<String, Registry> registryMap)\n                 referenceRegistries.put(tmpUrl, registryMap.get(tmpUrl));\n                 continue;\n             }\n-            final URL registryUrl =\n-                    URL.valueOf(tmpUrl).addParameterIfAbsent(CHECK_KEY, url.getParameter(CHECK_KEY, \"true\"));\n+            final URL registryUrl = URL.valueOf(tmpUrl)\n+                    .addParametersIfAbsent(url.getParameters())\n+                    .addParameterIfAbsent(CHECK_KEY, url.getParameter(CHECK_KEY, \"true\"));\n             Registry registry = registryFactory.getRegistry(registryUrl);\n             registryMap.put(tmpUrl, registry);\n             referenceRegistries.put(tmpUrl, registry);",
    "output": "Add registryUrl parameters from multipleRegistryUrl #13603"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-registry/src/main/java/org/apache/dubbo/metrics/registry/collector/RegistryMetricsCollector.java b/dubbo-metrics/dubbo-metrics-registry/src/main/java/org/apache/dubbo/metrics/registry/collector/RegistryMetricsCollector.java\n--- a/dubbo-metrics/dubbo-metrics-registry/src/main/java/org/apache/dubbo/metrics/registry/collector/RegistryMetricsCollector.java\n+++ b/dubbo-metrics/dubbo-metrics-registry/src/main/java/org/apache/dubbo/metrics/registry/collector/RegistryMetricsCollector.java\n@@ -54,7 +54,7 @@\n @Activate\n public class RegistryMetricsCollector extends CombMetricsCollector<RegistryEvent> {\n-    private Boolean collectEnabled = null;\n+    private Boolean collectEnabled = false;\n     private final ApplicationModel applicationModel;\n     private final RegistryStatComposite internalStat;",
    "output": "Add test ci"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n@@ -156,13 +156,13 @@ private void dumpJStack() {\n         if (!guard.tryAcquire()) {\n             return;\n         }\n-        // To avoid multiple dump, check again\n-        if (System.currentTimeMillis() - lastPrintTime < TEN_MINUTES_MILLS) {\n-            return;\n-        }\n-\n-        ExecutorService pool = Executors.newSingleThreadExecutor();\n+        ExecutorService pool = null;\n         try {\n+            // To avoid multiple dump, check again\n+            if (System.currentTimeMillis() - lastPrintTime < TEN_MINUTES_MILLS) {\n+                return;\n+            }\n+            pool = Executors.newSingleThreadExecutor();\n             pool.execute(() -> {\n                 String dumpPath = getDumpPath();\n@@ -186,12 +186,14 @@ private void dumpJStack() {\n                     logger.error(COMMON_UNEXPECTED_CREATE_DUMP, \"\", \"\", \"dump jStack error\", t);\n                 } finally {\n                     lastPrintTime = System.currentTimeMillis();\n-                    guard.release();\n                 }\n             });\n         } finally {\n+            guard.release();\n             // must shutdown thread pool ,if not will lead to OOM\n-            pool.shutdown();\n+            if (pool != null) {\n+                pool.shutdown();\n+            }\n         }\n     }",
    "output": "Fix AbortPolicyWithReport Semaphore lock not released"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/DefaultParamDeepCopyUtil.java b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/DefaultParamDeepCopyUtil.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/DefaultParamDeepCopyUtil.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/DefaultParamDeepCopyUtil.java\n@@ -22,6 +22,7 @@\n import org.apache.dubbo.common.serialize.ObjectInput;\n import org.apache.dubbo.common.serialize.ObjectOutput;\n import org.apache.dubbo.common.serialize.Serialization;\n+import org.apache.dubbo.common.utils.ProtobufUtils;\n import org.apache.dubbo.remoting.utils.UrlUtils;\n import java.io.ByteArrayInputStream;\n@@ -40,6 +41,10 @@ public class DefaultParamDeepCopyUtil implements ParamDeepCopyUtil {\n     @Override\n     @SuppressWarnings({\"unchecked\"})\n     public <T> T copy(URL url, Object src, Class<T> targetClass, Type type) {\n+        // TODO: maybe we have better way to do this\n+        if (src != null && ProtobufUtils.isProtobufClass(src.getClass())) {\n+            return (T) src;\n+        }\n         Serialization serialization = url.getOrDefaultFrameworkModel()\n                 .getExtensionLoader(Serialization.class)\n                 .getExtension(UrlUtils.serializationOrDefault(url));",
    "output": "Fix triple injvm deep copy issue"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.rpc.cluster.support;\n+import org.apache.dubbo.common.constants.LoggerCodeConstants;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.ConfigUtils;\n@@ -69,8 +70,10 @@ protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, Load\n                         return invokeWithContext(invoker, invocation);\n                     } catch (RpcException e) {\n                         if (e.isNoInvokerAvailableAfterFilter()) {\n-                            log.debug(\"No available provider for service\" + getUrl().getServiceKey() + \" on group \"\n-                                    + invoker.getUrl().getGroup() + \", will continue to try another group.\");\n+                            log.debug(\n+                                    \"No available provider for service\" + getUrl().getServiceKey() + \" on group \"\n+                                            + invoker.getUrl().getGroup() + \", will continue to try another group.\",\n+                                    e);\n                         } else {\n                             throw e;\n                         }\n@@ -93,7 +96,21 @@ protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, Load\n         for (final Invoker<T> invoker : invokers) {\n             RpcInvocation subInvocation = new RpcInvocation(invocation, invoker);\n             subInvocation.setAttachment(ASYNC_KEY, \"true\");\n-            results.put(invoker.getUrl().getServiceKey(), invokeWithContext(invoker, subInvocation));\n+            try {\n+                results.put(invoker.getUrl().getServiceKey(), invokeWithContext(invoker, subInvocation));\n+            } catch (RpcException e) {\n+                if (e.isNoInvokerAvailableAfterFilter()) {\n+                    log.warn(\n+                            LoggerCodeConstants.CLUSTER_NO_VALID_PROVIDER,\n+                            e.getCause().getMessage(),\n+                            \"\",\n+                            \"No available provider for service\" + getUrl().getServiceKey() + \" on group \"\n+                                    + invoker.getUrl().getGroup() + \", will continue to try another group.\",\n+                            e);\n+                } else {\n+                    throw e;\n+                }\n+            }\n         }\n         Object result;",
    "output": "Fix MergeableClusterInvoker log issue * Fix MergeableClusterInvoker log issue * Code style fix * Update log level * Update log level * Update log level * Add exception stacktrace"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n@@ -32,7 +32,6 @@\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.common.utils.UrlUtils;\n import org.apache.dubbo.registry.NotifyListener;\n-import org.apache.dubbo.registry.ProviderFirstParams;\n import org.apache.dubbo.rpc.model.ScopeModel;\n import java.util.ArrayList;\n@@ -41,7 +40,6 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ScheduledExecutorService;\n@@ -319,20 +317,6 @@ protected ServiceAddressURL createServiceURL(URLAddress address, URLParam param,\n         return new DubboServiceAddressURL(address, param, consumerURL, null);\n     }\n-    protected URL removeParamsFromConsumer(URL consumer) {\n-        Set<ProviderFirstParams> providerFirstParams = consumer.getOrDefaultApplicationModel()\n-                .getExtensionLoader(ProviderFirstParams.class)\n-                .getSupportedExtensionInstances();\n-        if (CollectionUtils.isEmpty(providerFirstParams)) {\n-            return consumer;\n-        }\n-\n-        for (ProviderFirstParams paramsFilter : providerFirstParams) {\n-            consumer = consumer.removeParameters(paramsFilter.params());\n-        }\n-        return consumer;\n-    }\n-\n     private String stripOffVariableKeys(String rawProvider) {\n         String[] keys = getVariableKeys();\n         if (keys == null || keys.length == 0) {\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.NamedThreadFactory;\n import org.apache.dubbo.registry.NotifyListener;\n+import org.apache.dubbo.registry.ProviderFirstParams;\n import org.apache.dubbo.registry.retry.FailedRegisteredTask;\n import org.apache.dubbo.registry.retry.FailedSubscribedTask;\n import org.apache.dubbo.registry.retry.FailedUnregisteredTask;\n@@ -177,6 +178,20 @@ private void removeFailedUnsubscribed(URL url, NotifyListener listener) {\n         }\n     }\n+    protected URL removeParamsFromConsumer(URL consumer) {\n+        Set<ProviderFirstParams> providerFirstParams = consumer.getOrDefaultApplicationModel()\n+                .getExtensionLoader(ProviderFirstParams.class)\n+                .getSupportedExtensionInstances();\n+        if (CollectionUtils.isEmpty(providerFirstParams)) {\n+            return consumer;\n+        }\n+\n+        for (ProviderFirstParams paramsFilter : providerFirstParams) {\n+            consumer = consumer.removeParameters(paramsFilter.params());\n+        }\n+        return consumer;\n+    }\n+\n     ConcurrentMap<URL, FailedRegisteredTask> getFailedRegistered() {\n         return failedRegistered;\n     }\ndiff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n@@ -573,6 +573,7 @@ public void destroy() {\n     }\n     private List<URL> toUrlWithEmpty(URL consumerURL, Collection<Instance> instances) {\n+        consumerURL = removeParamsFromConsumer(consumerURL);\n         List<URL> urls = buildURLs(consumerURL, instances);\n         // Nacos does not support configurators and routers from registry, so all notifications are of providers type.\n         if (urls.size() == 0 && !getUrl().getParameter(ENABLE_EMPTY_PROTECTION_KEY, DEFAULT_ENABLE_EMPTY_PROTECTION)) {",
    "output": "Fix dubbo.tag override by consumer.tag in NacosRegistry"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n@@ -488,6 +488,9 @@ private void registerServiceInternal(ServiceConfigBase sc) {\n         if (!sc.isExported()) {\n             return;\n         }\n+        if (sc.shouldDelay()) {\n+            return;\n+        }\n         sc.register(true);\n     }",
    "output": "Fix delay publish deadlock"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java\n@@ -160,7 +160,9 @@ private List<Action> calServiceRtActions(Invocation invocation, String registryO\n     public void calcMethodKeyRt(Invocation invocation, String registryOpType, Long responseTime) {\n         List<Action> actions;\n-        if (invocation.getServiceModel() != null && invocation.getServiceModel().getServiceMetadata() != null) {\n+        if (getServiceLevel()\n+                && invocation.getServiceModel() != null\n+                && invocation.getServiceModel().getServiceMetadata() != null) {\n             Map<String, Object> attributeMap =\n                     invocation.getServiceModel().getServiceMetadata().getAttributeMap();\n             Map<String, List<Action>> cache = (Map<String, List<Action>>) attributeMap.get(\"MethodKeyRt\");\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/sample/GaugeMetricSample.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/sample/GaugeMetricSample.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/sample/GaugeMetricSample.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/sample/GaugeMetricSample.java\n@@ -16,18 +16,25 @@\n  */\n package org.apache.dubbo.metrics.model.sample;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.metrics.model.MetricsCategory;\n import org.apache.dubbo.metrics.model.key.MetricsKey;\n import org.apache.dubbo.metrics.model.key.MetricsKeyWrapper;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.ToDoubleFunction;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_METRICS_COLLECTOR_EXCEPTION;\n+\n /**\n  * GaugeMetricSample.\n  */\n public class GaugeMetricSample<T> extends MetricSample {\n+    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(GaugeMetricSample.class);\n+    private final AtomicBoolean warned = new AtomicBoolean(false);\n     private final T value;\n@@ -71,7 +78,22 @@ public GaugeMetricSample(\n             ToDoubleFunction<T> apply) {\n         super(name, description, tags, Type.GAUGE, category, baseUnit);\n         this.value = Objects.requireNonNull(value, \"The GaugeMetricSample value cannot be null\");\n-        this.apply = Objects.requireNonNull(apply, \"The GaugeMetricSample apply cannot be null\");\n+        Objects.requireNonNull(apply, \"The GaugeMetricSample apply cannot be null\");\n+        this.apply = (e) -> {\n+            try {\n+                return apply.applyAsDouble(e);\n+            } catch (Throwable t) {\n+                if (warned.compareAndSet(false, true)) {\n+                    logger.error(\n+                            COMMON_METRICS_COLLECTOR_EXCEPTION,\n+                            \"\",\n+                            \"\",\n+                            \"Unexpected error occurred when applying the GaugeMetricSample\",\n+                            t);\n+                }\n+                return 0;\n+            }\n+        };\n     }\n     public T getValue() {",
    "output": "Fix MethodKeyRt override & Error enhance"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java\n@@ -28,7 +28,6 @@\n public class StubMethodDescriptor implements MethodDescriptor, PackableMethod {\n     private static final Logger logger = LoggerFactory.getLogger(StubMethodDescriptor.class);\n-    private final ServiceDescriptor serviceDescriptor;\n     private final ConcurrentMap<String, Object> attributeMap = new ConcurrentHashMap<>();\n     private final String methodName;\n     private final String[] compatibleParamSignatures;\n@@ -46,14 +45,12 @@ public StubMethodDescriptor(\n             String methodName,\n             Class<?> requestClass,\n             Class<?> responseClass,\n-            StubServiceDescriptor serviceDescriptor,\n             RpcType rpcType,\n             Pack requestPack,\n             Pack responsePack,\n             UnPack requestUnpack,\n             UnPack responseUnpack) {\n         this.methodName = methodName;\n-        this.serviceDescriptor = serviceDescriptor;\n         this.rpcType = rpcType;\n         this.requestPack = requestPack;\n         this.responsePack = responsePack;\n@@ -65,7 +62,6 @@ public StubMethodDescriptor(\n         this.compatibleParamSignatures =\n                 Stream.of(parameterClasses).map(Class::getName).toArray(String[]::new);\n         this.returnTypes = new Type[] {responseClass, responseClass};\n-        serviceDescriptor.addMethod(this);\n     }\n     @Override",
    "output": "Fix StubMethodDescriptor generate issue * Refactor StubMethodDescriptor generate * Refactor StubMethodDescriptor generate * Refactor StubMethodDescriptor generate * Refactor * Add missing ';'"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n@@ -155,6 +155,12 @@ public abstract class AbstractServiceConfig extends AbstractInterfaceConfig {\n      */\n     private Integer payload;\n+    /**\n+     * Whether to use java_package in IDL as path. Default use package.\n+     * This param only available when service using native stub.\n+     */\n+    private Boolean useJavaPackageAsPath;\n+\n     public AbstractServiceConfig() {}\n     public AbstractServiceConfig(ModuleModel moduleModel) {\n@@ -170,7 +176,9 @@ protected void checkDefault() {\n         if (dynamic == null) {\n             dynamic = true;\n         }\n-\n+        if (useJavaPackageAsPath == null) {\n+            useJavaPackageAsPath = false;\n+        }\n         if (StringUtils.isBlank(preferSerialization)) {\n             preferSerialization = serialization;\n         }\n@@ -388,4 +396,13 @@ public Integer getPayload() {\n     public void setPayload(Integer payload) {\n         this.payload = payload;\n     }\n+\n+    public Boolean getUseJavaPackageAsPath() {\n+        return useJavaPackageAsPath;\n+    }\n+\n+    @Parameter(excluded = true)\n+    public void setUseJavaPackageAsPath(Boolean useJavaPackageAsPath) {\n+        this.useJavaPackageAsPath = useJavaPackageAsPath;\n+    }\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -548,6 +548,10 @@ private void doExportUrls(RegisterTypeEnum registerType) {\n         final boolean serverService = ref instanceof ServerService;\n         if (serverService) {\n             serviceDescriptor = ((ServerService) ref).getServiceDescriptor();\n+            if (!this.provider.getUseJavaPackageAsPath()) {\n+                // for stub service, path always interface name or IDL package name\n+                this.path = serviceDescriptor.getInterfaceName();\n+            }\n             repository.registerService(serviceDescriptor);\n         } else {\n             serviceDescriptor = repository.registerService(getInterfaceClass());",
    "output": "Fix proto `package` and ` java_package` issue * Fix pb package issue * Codestyle fix * Fix npe in test * Fix npe in test * Fix test * Codestyle fix * Simplify config * Update ServiceConfig.java"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n@@ -150,7 +150,9 @@ protected void doClose() {\n                 current.close();\n             }\n             this.channel.set(null);\n-            closePromise.setSuccess(null);\n+            if (!closePromise.isDone()) {\n+                closePromise.setSuccess(null);\n+            }\n         }\n     }",
    "output": "Fix complete already * fix complete already * fix complete already"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.config.spring;\n+import org.apache.dubbo.common.aot.NativeDetector;\n import org.apache.dubbo.common.bytecode.Proxy;\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n@@ -364,7 +365,12 @@ private void createLazyProxy() {\n             }\n         }\n-        if (StringUtils.isEmpty(this.proxy) || CommonConstants.DEFAULT_PROXY.equalsIgnoreCase(this.proxy)) {\n+        if (NativeDetector.inNativeImage()) {\n+            generateFromJdk(interfaces);\n+        }\n+\n+        if (this.lazyProxy == null\n+                && (StringUtils.isEmpty(this.proxy) || CommonConstants.DEFAULT_PROXY.equalsIgnoreCase(this.proxy))) {\n             generateFromJavassistFirst(interfaces);\n         }",
    "output": "Fix reference bean create proxy with javassist in native"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2FactoryManager.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2FactoryManager.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2FactoryManager.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2FactoryManager.java\n@@ -23,6 +23,7 @@\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n+import java.util.Objects;\n import java.util.concurrent.ConcurrentHashMap;\n import com.alibaba.com.caucho.hessian.io.SerializerFactory;\n@@ -46,7 +47,7 @@ public Hessian2FactoryManager(FrameworkModel frameworkModel) {\n     public SerializerFactory getSerializerFactory(ClassLoader classLoader) {\n         SerializerFactory sticky = stickySerializerFactory;\n-        if (sticky != null && sticky.getClassLoader().equals(classLoader)) {\n+        if (sticky != null && Objects.equals(sticky.getClassLoader(), classLoader)) {\n             return sticky;\n         }",
    "output": "Fix potential NPE"
  },
  {
    "input": "diff --git a/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboRelaxedBinding2AutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboRelaxedBinding2AutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboRelaxedBinding2AutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboRelaxedBinding2AutoConfiguration.java\n@@ -51,7 +51,7 @@\n  * @see DubboRelaxedBindingAutoConfiguration\n  * @since 2.7.0\n  */\n-@Configuration\n+@Configuration(proxyBeanMethods = false)\n @ConditionalOnProperty(prefix = DUBBO_PREFIX, name = \"enabled\", matchIfMissing = true)\n @ConditionalOnClass(name = \"org.springframework.boot.context.properties.bind.Binder\")\n @AutoConfigureBefore(DubboRelaxedBindingAutoConfiguration.class)\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboAutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboAutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboAutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/autoconfigure/DubboAutoConfiguration.java\n@@ -62,7 +62,7 @@ public class DubboAutoConfiguration {\n     @ConditionalOnProperty(prefix = DUBBO_SCAN_PREFIX, name = BASE_PACKAGES_PROPERTY_NAME)\n     @ConditionalOnBean(name = BASE_PACKAGES_BEAN_NAME)\n     @Bean\n-    public ServiceAnnotationPostProcessor serviceAnnotationBeanProcessor(\n+    public static ServiceAnnotationPostProcessor serviceAnnotationBeanProcessor(\n             @Qualifier(BASE_PACKAGES_BEAN_NAME) Set<String> packagesToScan) {\n         ServiceAnnotationPostProcessor serviceAnnotationPostProcessor;\n         try {",
    "output": "Fix DubboAutoConfiguration and DubboRelaxedBinding2AutoConfiguration init too early, can not be processed AOT in spring native image scenario"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -27,6 +27,7 @@\n import org.apache.dubbo.common.utils.ClassUtils;\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.ConfigUtils;\n+import org.apache.dubbo.common.utils.JsonUtils;\n import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.support.Parameter;\n@@ -758,6 +759,16 @@ public void setMethods(List<? extends MethodConfig> methods) {\n         this.methods = (methods != null) ? new ArrayList<>(methods) : null;\n     }\n+    public void setMethodsJson(List<String> methodsJson) {\n+        if (methodsJson != null) {\n+            this.methods = new ArrayList<>();\n+            methodsJson.forEach(\n+                    (methodConfigJson) -> methods.add(JsonUtils.toJavaObject(methodConfigJson, MethodConfig.class)));\n+        } else {\n+            this.methods = null;\n+        }\n+    }\n+\n     public void addMethod(MethodConfig methodConfig) {\n         if (this.methods == null) {\n             this.methods = new ArrayList<>();\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/MethodConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/MethodConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/MethodConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/MethodConfig.java\n@@ -217,9 +217,8 @@ public List<String> getPrefixes() {\n             List<String> prefixes = new ArrayList<>();\n             prefixes.add(parentPrefix + \".\" + this.getName());\n             return prefixes;\n-        } else {\n-            throw new IllegalStateException(\"The parent prefix of MethodConfig is null\");\n         }\n+        return null;\n     }\n     @Override\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/aot/AotWithSpringDetector.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/aot/AotWithSpringDetector.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/aot/AotWithSpringDetector.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/aot/AotWithSpringDetector.java\n@@ -30,6 +30,8 @@ public abstract class AotWithSpringDetector {\n      */\n     public static final String AOT_ENABLED = \"spring.aot.enabled\";\n+    private static final String AOT_PROCESSING = \"spring.aot.processing\";\n+\n     /**\n      * Determine whether AOT optimizations must be considered at runtime. This\n      * is mandatory in a native image but can be triggered on the JVM using\n@@ -40,4 +42,8 @@ public abstract class AotWithSpringDetector {\n     public static boolean useGeneratedArtifacts() {\n         return (NativeDetector.inNativeImage() || SpringProperties.getFlag(AOT_ENABLED));\n     }\n+\n+    public static boolean isAotProcessing() {\n+        return (NativeDetector.inNativeImage() || SpringProperties.getFlag(AOT_PROCESSING));\n+    }\n }\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.AnnotationUtils;\n import org.apache.dubbo.common.utils.ClassUtils;\n+import org.apache.dubbo.common.utils.JsonUtils;\n import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.Constants;\n@@ -486,7 +487,13 @@ private AbstractBeanDefinition buildServiceBeanDefinition(\n         // Add methods parameters\n         List<MethodConfig> methodConfigs = convertMethodConfigs(serviceAnnotationAttributes.get(\"methods\"));\n         if (!methodConfigs.isEmpty()) {\n-            builder.addPropertyValue(\"methods\", methodConfigs);\n+            if (AotWithSpringDetector.isAotProcessing()) {\n+                List<String> methodsJson = new ArrayList<>();\n+                methodConfigs.forEach(methodConfig -> methodsJson.add(JsonUtils.toJson(methodConfig)));\n+                builder.addPropertyValue(\"methodsJson\", methodsJson);\n+            } else {\n+                builder.addPropertyValue(\"methods\", methodConfigs);\n+            }\n         }\n         // convert provider to providerIds",
    "output": "Fix method annotation compile failed in native"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n@@ -33,6 +33,7 @@\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.stream.Stream;\n@@ -73,18 +74,18 @@ public ReflectionPackableMethod(\n             case CLIENT_STREAM:\n             case BI_STREAM:\n                 actualRequestTypes = new Class<?>[] {\n-                    (Class<?>)\n-                            ((ParameterizedType) method.getMethod().getGenericReturnType()).getActualTypeArguments()[0]\n+                    obtainActualTypeInStreamObserver(\n+                            ((ParameterizedType) method.getMethod().getGenericReturnType()).getActualTypeArguments()[0])\n                 };\n-                actualResponseType =\n-                        (Class<?>) ((ParameterizedType) method.getMethod().getGenericParameterTypes()[0])\n-                                .getActualTypeArguments()[0];\n+                actualResponseType = obtainActualTypeInStreamObserver(\n+                        ((ParameterizedType) method.getMethod().getGenericParameterTypes()[0])\n+                                .getActualTypeArguments()[0]);\n                 break;\n             case SERVER_STREAM:\n                 actualRequestTypes = method.getMethod().getParameterTypes();\n-                actualResponseType =\n-                        (Class<?>) ((ParameterizedType) method.getMethod().getGenericParameterTypes()[1])\n-                                .getActualTypeArguments()[0];\n+                actualResponseType = obtainActualTypeInStreamObserver(\n+                        ((ParameterizedType) method.getMethod().getGenericParameterTypes()[1])\n+                                .getActualTypeArguments()[0]);\n                 break;\n             case UNARY:\n                 actualRequestTypes = method.getParameterClasses();\n@@ -290,6 +291,13 @@ private static String convertHessianFromWrapper(String serializeType) {\n         return serializeType;\n     }\n+    static Class<?> obtainActualTypeInStreamObserver(Type typeInStreamObserver) {\n+        return (Class<?>)\n+                (typeInStreamObserver instanceof ParameterizedType\n+                        ? ((ParameterizedType) typeInStreamObserver).getRawType()\n+                        : typeInStreamObserver);\n+    }\n+\n     @Override\n     public Pack getRequestPack() {\n         return requestPack;\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DataWrapper.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DataWrapper.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DataWrapper.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DataWrapper.java\n@@ -0,0 +1,21 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.tri;\n+\n+public class DataWrapper<T> {\n+    public T data;\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DescriptorService.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DescriptorService.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DescriptorService.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DescriptorService.java\n@@ -68,6 +68,17 @@ public interface DescriptorService {\n     void sayHelloServerStream2(Object request, StreamObserver<Object> reply);\n+    /**\n+     * obtain actual type in streamObserver\n+     */\n+    void serverStream1(Object request, StreamObserver<String> streamObserver);\n+\n+    void serverStream2(Object request, StreamObserver<DataWrapper<String>> streamObserver);\n+\n+    StreamObserver<String> biStream1(StreamObserver<String> streamObserver);\n+\n+    StreamObserver<DataWrapper<String>> biStream2(StreamObserver<DataWrapper<String>> streamObserver);\n+\n     /***********************grpc******************************/\n     java.util.Iterator<HelloReply> iteratorServerStream(HelloReply request);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethodTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethodTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethodTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethodTest.java\n@@ -124,6 +124,38 @@ void testIsServerStream() throws NoSuchMethodException {\n         Assertions.assertTrue(needWrap(descriptor2));\n     }\n+    @Test\n+    void testObtainActualType() throws NoSuchMethodException {\n+\n+        Method method1 = DescriptorService.class.getMethod(\"serverStream1\", Object.class, StreamObserver.class);\n+        Class<?> clazz1 = ReflectionPackableMethod.obtainActualTypeInStreamObserver(\n+                ((ParameterizedType) method1.getGenericParameterTypes()[1]).getActualTypeArguments()[0]);\n+        Assertions.assertEquals(clazz1.getName(), String.class.getName());\n+\n+        Method method2 = DescriptorService.class.getMethod(\"serverStream2\", Object.class, StreamObserver.class);\n+        Class<?> clazz2 = ReflectionPackableMethod.obtainActualTypeInStreamObserver(\n+                ((ParameterizedType) method2.getGenericParameterTypes()[1]).getActualTypeArguments()[0]);\n+        Assertions.assertEquals(clazz2.getName(), DataWrapper.class.getName());\n+\n+        Method method3 = DescriptorService.class.getMethod(\"biStream1\", StreamObserver.class);\n+        Class<?> clazz31 = ReflectionPackableMethod.obtainActualTypeInStreamObserver(\n+                ((ParameterizedType) method3.getGenericReturnType()).getActualTypeArguments()[0]);\n+        Assertions.assertEquals(clazz31.getName(), String.class.getName());\n+\n+        Class<?> clazz32 = ReflectionPackableMethod.obtainActualTypeInStreamObserver(\n+                ((ParameterizedType) method3.getGenericParameterTypes()[0]).getActualTypeArguments()[0]);\n+        Assertions.assertEquals(clazz32.getName(), String.class.getName());\n+\n+        Method method4 = DescriptorService.class.getMethod(\"biStream2\", StreamObserver.class);\n+        Class<?> clazz41 = ReflectionPackableMethod.obtainActualTypeInStreamObserver(\n+                ((ParameterizedType) method4.getGenericReturnType()).getActualTypeArguments()[0]);\n+        Assertions.assertEquals(clazz41.getName(), DataWrapper.class.getName());\n+\n+        Class<?> clazz42 = ReflectionPackableMethod.obtainActualTypeInStreamObserver(\n+                ((ParameterizedType) method4.getGenericParameterTypes()[0]).getActualTypeArguments()[0]);\n+        Assertions.assertEquals(clazz42.getName(), DataWrapper.class.getName());\n+    }\n+\n     @Test\n     void testIsNeedWrap() throws NoSuchMethodException {\n         Method method = DescriptorService.class.getMethod(\"noParameterMethod\");",
    "output": "Fix streamobserver actual type * fix:obtain actual type in StreamObserver. * format code ---------"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/SpringMvcRestProtocolTest.java b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/SpringMvcRestProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/SpringMvcRestProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/SpringMvcRestProtocolTest.java\n@@ -411,7 +411,7 @@ void testProxyDoubleCheck() {\n         Object proxy = aopProxy.getProxy();\n         SpringRestDemoService server = (SpringRestDemoService) proxy;\n-        URL nettyUrl = this.registerProvider(exportUrl, server, SpringRestDemoService.class);\n+        URL nettyUrl = this.registerProvider(getUrl(), server, SpringRestDemoService.class);\n         Exporter<SpringRestDemoService> exporter = getExport(nettyUrl, server);",
    "output": "Fix SpringMvcRestProtocolTest"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -24,7 +24,6 @@\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.stream.StreamObserver;\n import org.apache.dubbo.common.threadpool.ThreadlessExecutor;\n-import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.common.utils.SystemPropertyConfigUtils;\n import org.apache.dubbo.remoting.api.connection.AbstractConnectionClient;\n import org.apache.dubbo.rpc.AppResponse;",
    "output": "Remove unused import"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/TriRpcStatus.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/TriRpcStatus.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/TriRpcStatus.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/TriRpcStatus.java\n@@ -19,6 +19,8 @@\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.remoting.TimeoutException;\n+import java.io.Serializable;\n+\n import io.netty.handler.codec.http.HttpResponseStatus;\n import io.netty.handler.codec.http.QueryStringDecoder;\n import io.netty.handler.codec.http.QueryStringEncoder;\n@@ -35,7 +37,7 @@\n /**\n  * See https://github.com/grpc/grpc/blob/master/doc/statuscodes.md\n  */\n-public class TriRpcStatus {\n+public class TriRpcStatus implements Serializable {\n     public static final TriRpcStatus OK = fromCode(Code.OK);\n     public static final TriRpcStatus UNKNOWN = fromCode(Code.UNKNOWN);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/TriRpcStatusTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/TriRpcStatusTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/TriRpcStatusTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/TriRpcStatusTest.java\n@@ -19,6 +19,8 @@\n import org.apache.dubbo.remoting.TimeoutException;\n import org.apache.dubbo.rpc.TriRpcStatus.Code;\n+import java.io.Serializable;\n+\n import io.netty.handler.codec.http.HttpResponseStatus;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n@@ -214,4 +216,11 @@ void triCodeToDubboCode() {\n         Assertions.assertEquals(METHOD_NOT_FOUND, TriRpcStatus.triCodeToDubboCode(Code.UNIMPLEMENTED));\n         Assertions.assertEquals(UNKNOWN_EXCEPTION, TriRpcStatus.triCodeToDubboCode(Code.UNKNOWN));\n     }\n+\n+    @Test\n+    void testSerializable() {\n+        TriRpcStatus status = TriRpcStatus.INTERNAL.withDescription(\"test\");\n+        Assertions.assertInstanceOf(Serializable.class, status.asException());\n+        Assertions.assertInstanceOf(Serializable.class, status.asException().getStatus());\n+    }\n }",
    "output": "Fix TriRpcStatus not implements Serializable * Fix TriRpcStatus not implements Serializable * Fix TriRpcStatus not implements Serializable"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/MethodStatComposite.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/MethodStatComposite.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/MethodStatComposite.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/MethodStatComposite.java\n@@ -41,13 +41,11 @@\n  * the key will not be displayed when exporting (to be optimized)\n  */\n public class MethodStatComposite extends AbstractMetricsExport {\n-    private boolean serviceLevel;\n     private final AtomicBoolean samplesChanged = new AtomicBoolean(true);\n     public MethodStatComposite(ApplicationModel applicationModel) {\n         super(applicationModel);\n-        this.serviceLevel = MethodMetric.isServiceLevel(getApplicationModel());\n     }\n     private final Map<MetricsKeyWrapper, Map<MethodMetric, AtomicLong>> methodNumStats = new ConcurrentHashMap<>();\n@@ -70,7 +68,8 @@ public void initMethodKey(MetricsKeyWrapper wrapper, Invocation invocation) {\n         methodNumStats\n                 .get(wrapper)\n                 .computeIfAbsent(\n-                        new MethodMetric(getApplicationModel(), invocation, serviceLevel), k -> new AtomicLong(0L));\n+                        new MethodMetric(getApplicationModel(), invocation, getServiceLevel()),\n+                        k -> new AtomicLong(0L));\n         samplesChanged.set(true);\n     }\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java\n@@ -50,13 +50,11 @@\n  */\n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public class RtStatComposite extends AbstractMetricsExport {\n-    private boolean serviceLevel;\n     private final AtomicBoolean samplesChanged = new AtomicBoolean(true);\n     public RtStatComposite(ApplicationModel applicationModel) {\n         super(applicationModel);\n-        this.serviceLevel = MethodMetric.isServiceLevel(getApplicationModel());\n     }\n     private final Map<String, List<LongContainer<? extends Number>>> rtStats = new ConcurrentHashMap<>();\n@@ -190,7 +188,7 @@ private List<Action> calMethodRtActions(Invocation invocation, String registryOp\n         List<Action> actions;\n         actions = new LinkedList<>();\n         for (LongContainer container : rtStats.get(registryOpType)) {\n-            MethodMetric key = new MethodMetric(getApplicationModel(), invocation, serviceLevel);\n+            MethodMetric key = new MethodMetric(getApplicationModel(), invocation, getServiceLevel());\n             Number current = (Number) container.get(key);\n             if (current == null) {\n                 container.putIfAbsent(key, container.getInitFunc().apply(key));\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/report/AbstractMetricsExport.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/report/AbstractMetricsExport.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/report/AbstractMetricsExport.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/report/AbstractMetricsExport.java\n@@ -16,13 +16,16 @@\n  */\n package org.apache.dubbo.metrics.report;\n+import org.apache.dubbo.metrics.model.MethodMetric;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n /**\n  * Store public information such as application\n  */\n public abstract class AbstractMetricsExport implements MetricsExport {\n+    private volatile Boolean serviceLevel;\n+\n     private final ApplicationModel applicationModel;\n     public AbstractMetricsExport(ApplicationModel applicationModel) {\n@@ -36,4 +39,19 @@ public ApplicationModel getApplicationModel() {\n     public String getAppName() {\n         return getApplicationModel().getApplicationName();\n     }\n+\n+    protected boolean getServiceLevel() {\n+        initServiceLevelConfig();\n+        return this.serviceLevel;\n+    }\n+\n+    private void initServiceLevelConfig() {\n+        if (serviceLevel == null) {\n+            synchronized (this) {\n+                if (serviceLevel == null) {\n+                    this.serviceLevel = MethodMetric.isServiceLevel(getApplicationModel());\n+                }\n+            }\n+        }\n+    }\n }",
    "output": "Fix metrics servce level config bug * :bug: fix metrics servce level config bug * :bug: fix metrics servce level config bug * :bug: fix metrics servce level config bug * :bug: fix metrics servce level config bug"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -24,7 +24,6 @@\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.stream.StreamObserver;\n import org.apache.dubbo.common.threadpool.ThreadlessExecutor;\n-import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.remoting.api.connection.AbstractConnectionClient;\n import org.apache.dubbo.rpc.AppResponse;\n import org.apache.dubbo.rpc.AsyncRpcResult;\n@@ -143,12 +142,12 @@ protected Result doInvoke(final Invocation invocation) {\n         ConsumerModel consumerModel = (ConsumerModel)\n                 (invocation.getServiceModel() != null ? invocation.getServiceModel() : getUrl().getServiceModel());\n         ServiceDescriptor serviceDescriptor = consumerModel.getServiceModel();\n-        final MethodDescriptor methodDescriptor;\n-        boolean genericCall = RpcUtils.isGenericCall(\n-                ReflectUtils.getDesc(invocation.getParameterTypes()), invocation.getMethodName());\n-        if (!genericCall) {\n-            methodDescriptor = serviceDescriptor.getMethod(invocation.getMethodName(), invocation.getParameterTypes());\n-        } else {\n+        MethodDescriptor methodDescriptor =\n+                serviceDescriptor.getMethod(invocation.getMethodName(), invocation.getParameterTypes());\n+        if (methodDescriptor == null\n+                && RpcUtils.isGenericCall(\n+                        ((RpcInvocation) invocation).getParameterTypesDesc(), invocation.getMethodName())) {\n+            // Only reach when server generic\n             methodDescriptor = ServiceDescriptorInternalCache.genericService()\n                     .getMethod(invocation.getMethodName(), invocation.getParameterTypes());\n         }\n@@ -261,17 +260,7 @@ AsyncRpcResult invokeUnary(\n         if (methodDescriptor instanceof StubMethodDescriptor) {\n             pureArgument = invocation.getArguments()[0];\n         } else {\n-            if (methodDescriptor.isGeneric()) {\n-                Object[] args = new Object[3];\n-                args[0] = RpcUtils.getMethodName(invocation);\n-                args[1] = Arrays.stream(RpcUtils.getParameterTypes(invocation))\n-                        .map(Class::getName)\n-                        .toArray(String[]::new);\n-                args[2] = RpcUtils.getArguments(invocation);\n-                pureArgument = args;\n-            } else {\n-                pureArgument = invocation.getArguments();\n-            }\n+            pureArgument = invocation.getArguments();\n         }\n         result = new AsyncRpcResult(future, invocation);\n         if (setFutureWhenSync || ((RpcInvocation) invocation).getInvokeMode() != InvokeMode.SYNC) {",
    "output": "Fix generic invoke failed for triple"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataConstants.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataConstants.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataConstants.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataConstants.java\n@@ -28,4 +28,6 @@ public interface MetadataConstants {\n     String REPORT_CONSUMER_URL_KEY = \"report-consumer-definition\";\n     String PATH_SEPARATOR = \"/\";\n+\n+    String NAMESPACE_KEY = \"namespace\";\n }\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReportInstance.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReportInstance.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReportInstance.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReportInstance.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.URLBuilder;\n import org.apache.dubbo.common.resource.Disposable;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.MetadataReportConfig;\n import org.apache.dubbo.metadata.report.support.NopMetadataReport;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n@@ -35,6 +36,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.PORT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.REGISTRY_LOCAL_FILE_CACHE_ENABLED;\n import static org.apache.dubbo.common.utils.StringUtils.isEmpty;\n+import static org.apache.dubbo.metadata.MetadataConstants.NAMESPACE_KEY;\n import static org.apache.dubbo.metadata.report.support.Constants.METADATA_REPORT_KEY;\n /**\n@@ -102,16 +104,24 @@ private void init(MetadataReportConfig config, MetadataReportFactory metadataRep\n         url = url.addParameterIfAbsent(\n                 REGISTRY_LOCAL_FILE_CACHE_ENABLED,\n                 String.valueOf(applicationModel.getCurrentConfig().getEnableFileCache()));\n-        String relatedRegistryId = isEmpty(config.getRegistry())\n-                ? (isEmpty(config.getId()) ? DEFAULT_KEY : config.getId())\n-                : config.getRegistry();\n         //        RegistryConfig registryConfig = applicationModel.getConfigManager().getRegistry(relatedRegistryId)\n         //                .orElseThrow(() -> new IllegalStateException(\"Registry id \" + relatedRegistryId + \" does not\n         // exist.\"));\n         MetadataReport metadataReport = metadataReportFactory.getMetadataReport(url);\n         if (metadataReport != null) {\n-            metadataReports.put(relatedRegistryId, metadataReport);\n+            metadataReports.put(getRelatedRegistryId(config, url), metadataReport);\n+        }\n+    }\n+\n+    private String getRelatedRegistryId(MetadataReportConfig config, URL url) {\n+        String relatedRegistryId = isEmpty(config.getRegistry())\n+                ? (isEmpty(config.getId()) ? DEFAULT_KEY : config.getId())\n+                : config.getRegistry();\n+        String namespace = url.getParameter(NAMESPACE_KEY);\n+        if (!StringUtils.isEmpty(namespace)) {\n+            relatedRegistryId += \":\" + namespace;\n         }\n+        return relatedRegistryId;\n     }\n     public Map<String, MetadataReport> getMetadataReports(boolean checked) {\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReportFactory.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReportFactory.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReportFactory.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReportFactory.java\n@@ -50,7 +50,7 @@ public abstract class AbstractMetadataReportFactory implements MetadataReportFac\n     @Override\n     public MetadataReport getMetadataReport(URL url) {\n         url = url.setPath(MetadataReport.class.getName()).removeParameters(EXPORT_KEY, REFER_KEY);\n-        String key = url.toServiceString();\n+        String key = toMetadataReportKey(url);\n         MetadataReport metadataReport = serviceStoreMap.get(key);\n         if (metadataReport != null) {\n@@ -88,6 +88,10 @@ public MetadataReport getMetadataReport(URL url) {\n         }\n     }\n+    protected String toMetadataReportKey(URL url) {\n+        return url.toServiceString();\n+    }\n+\n     @Override\n     public void destroy() {\n         lock.lock();\ndiff --git a/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReportFactory.java b/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReportFactory.java\n--- a/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReportFactory.java\n+++ b/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReportFactory.java\n@@ -17,9 +17,12 @@\n package org.apache.dubbo.metadata.store.nacos;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.metadata.report.MetadataReport;\n import org.apache.dubbo.metadata.report.support.AbstractMetadataReportFactory;\n+import static org.apache.dubbo.metadata.MetadataConstants.NAMESPACE_KEY;\n+\n /**\n  * metadata report factory impl for nacos\n  */\n@@ -28,4 +31,15 @@ public class NacosMetadataReportFactory extends AbstractMetadataReportFactory {\n     protected MetadataReport createMetadataReport(URL url) {\n         return new NacosMetadataReport(url);\n     }\n+\n+    @Override\n+    protected String toMetadataReportKey(URL url) {\n+        String namespace = url.getParameter(NAMESPACE_KEY);\n+        if (!StringUtils.isEmpty(namespace)) {\n+            return URL.valueOf(url.toServiceString())\n+                    .addParameter(NAMESPACE_KEY, namespace)\n+                    .toString();\n+        }\n+        return super.toMetadataReportKey(url);\n+    }\n }",
    "output": "Fix issue of metadata only registred to one nacos namespace (3.2.x) * Fix nacos metadata namespace * Fix code style ---------"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/tracer/otel/OpenTelemetryProvider.java b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/tracer/otel/OpenTelemetryProvider.java\n--- a/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/tracer/otel/OpenTelemetryProvider.java\n+++ b/dubbo-metrics/dubbo-tracing/src/main/java/org/apache/dubbo/tracing/tracer/otel/OpenTelemetryProvider.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.lang.Nullable;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.ClassUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.ApplicationConfig;\n import org.apache.dubbo.config.TracingConfig;\n@@ -46,6 +47,7 @@\n import io.micrometer.tracing.otel.bridge.Slf4JBaggageEventListener;\n import io.micrometer.tracing.otel.bridge.Slf4JEventListener;\n import io.micrometer.tracing.otel.propagation.BaggageTextMapPropagator;\n+import io.opentelemetry.api.common.AttributeKey;\n import static org.apache.dubbo.tracing.utils.ObservationConstants.DEFAULT_APPLICATION_NAME;\n@@ -81,14 +83,30 @@ public Tracer getTracer() {\n         // [Micrometer Tracing component] A Micrometer Tracing wrapper for OTel\n         this.otelCurrentTraceContext = createCurrentTraceContext();\n+        // Due to https://github.com/micrometer-metrics/tracing/issues/343\n+        String RESOURCE_ATTRIBUTES_CLASS_NAME = \"io.opentelemetry.semconv.ResourceAttributes\";\n+        boolean isLowVersion = !ClassUtils.isPresent(\n+                RESOURCE_ATTRIBUTES_CLASS_NAME, Thread.currentThread().getContextClassLoader());\n+        AttributeKey<String> serviceNameAttributeKey = AttributeKey.stringKey(\"service.name\");\n+        String SERVICE_NAME = \"SERVICE_NAME\";\n+\n+        if (isLowVersion) {\n+            RESOURCE_ATTRIBUTES_CLASS_NAME = \"io.opentelemetry.semconv.resource.attributes.ResourceAttributes\";\n+        }\n+        try {\n+            serviceNameAttributeKey = (AttributeKey<String>) ClassUtils.resolveClass(\n+                            RESOURCE_ATTRIBUTES_CLASS_NAME,\n+                            Thread.currentThread().getContextClassLoader())\n+                    .getDeclaredField(SERVICE_NAME)\n+                    .get(null);\n+        } catch (Throwable ignored) {\n+        }\n         // [OTel component] SdkTracerProvider is an SDK implementation for TracerProvider\n         io.opentelemetry.sdk.trace.SdkTracerProvider sdkTracerProvider =\n                 io.opentelemetry.sdk.trace.SdkTracerProvider.builder()\n                         .setSampler(getSampler())\n                         .setResource(io.opentelemetry.sdk.resources.Resource.create(\n-                                io.opentelemetry.api.common.Attributes.of(\n-                                        io.opentelemetry.semconv.resource.attributes.ResourceAttributes.SERVICE_NAME,\n-                                        applicationName)))\n+                                io.opentelemetry.api.common.Attributes.of(serviceNameAttributeKey, applicationName)))\n                         .addSpanProcessor(io.opentelemetry.sdk.trace.export.BatchSpanProcessor.builder(\n                                         new CompositeSpanExporter(spanExporters, null, null, null))\n                                 .build())",
    "output": "Fix compile"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosAggregateListener.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosAggregateListener.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosAggregateListener.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosAggregateListener.java\n@@ -98,6 +98,6 @@ public boolean equals(Object o) {\n     @Override\n     public int hashCode() {\n-        return Objects.hash(notifyListener, serviceNames, serviceInstances);\n+        return Objects.hash(notifyListener);\n     }\n }",
    "output": "Fix listener hash code error"
  },
  {
    "input": "diff --git a/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/aot/DubboProcessAotMojo.java b/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/aot/DubboProcessAotMojo.java\n--- a/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/aot/DubboProcessAotMojo.java\n+++ b/dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/aot/DubboProcessAotMojo.java\n@@ -85,7 +85,7 @@ protected void executeAot() throws Exception {\n     private String[] getAotArguments(String applicationClass) {\n         List<String> aotArguments = new ArrayList<>();\n-        aotArguments.add(applicationClass);\n+        aotArguments.add(applicationClass != null ? applicationClass : \"\");\n         aotArguments.add(this.generatedSources.toString());\n         aotArguments.add(this.generatedResources.toString());\n         aotArguments.add(this.generatedClasses.toString());",
    "output": "Fix native image build error when mainClass is null,add an empty string placeholder"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n@@ -801,6 +801,9 @@ public void refresh() {\n         if (StringUtils.isEmpty(getName())) {\n             this.setName(DEFAULT_APP_NAME);\n             LOGGER.warn(\n+                    COMMON_UNEXPECTED_EXCEPTION,\n+                    \"\",\n+                    \"\",\n                     \"No application name was set, '\" + DEFAULT_APP_NAME\n                             + \"' will be used as the default application name,\"\n                             + \" it's highly recommended to set a unique and customized name for it can be critical for some service governance features.\");\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n@@ -63,6 +63,7 @@\n import java.util.function.Supplier;\n import static org.apache.dubbo.common.constants.CommonConstants.HEADER_FILTER_KEY;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_ERROR_USE_THREAD_POOL;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_PARSE;\n@@ -122,20 +123,20 @@ public void onMetadata(HEADER metadata) {\n         try {\n             this.executor = initializeExecutor(metadata);\n         } catch (Throwable throwable) {\n-            LOGGER.error(\"initialize executor fail.\", throwable);\n+            LOGGER.error(COMMON_ERROR_USE_THREAD_POOL, \"\", \"\", \"initialize executor fail.\", throwable);\n             onError(throwable);\n             return;\n         }\n         if (this.executor == null) {\n-            LOGGER.error(\"executor must be not null.\");\n+            LOGGER.error(INTERNAL_ERROR, \"\", \"\", \"executor must be not null.\");\n             onError(new NullPointerException(\"initializeExecutor return null\"));\n             return;\n         }\n         executor.execute(() -> {\n             try {\n                 doOnMetadata(metadata);\n             } catch (Throwable throwable) {\n-                LOGGER.error(\"server internal error\", throwable);\n+                LOGGER.error(INTERNAL_ERROR, \"\", \"\", \"server internal error\", throwable);\n                 onError(throwable);\n             }\n         });\n@@ -182,7 +183,7 @@ public void onData(MESSAGE message) {\n             try {\n                 doOnData(message);\n             } catch (Throwable e) {\n-                LOGGER.error(\"server internal error\", e);\n+                LOGGER.error(INTERNAL_ERROR, \"\", \"\", \"server internal error\", e);\n                 onError(e);\n             }\n         });",
    "output": "Fix missing error code"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java\n@@ -899,10 +899,6 @@ private static Class<?>[] desc2classArray(ClassLoader cl, String desc) throws Cl\n     @Deprecated\n     public static Method findMethodByMethodSignature(Class<?> clazz, String methodName, String[] parameterTypes)\n             throws NoSuchMethodException, ClassNotFoundException {\n-        String signature = clazz.getName() + \".\" + methodName;\n-        if (parameterTypes != null && parameterTypes.length > 0) {\n-            signature += StringUtils.join(parameterTypes);\n-        }\n         Method method;\n         if (parameterTypes == null) {\n             List<Method> finded = new ArrayList<>();",
    "output": "Upgrade ReflectUtils.java Remove useless code"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/DefaultParamDeepCopyUtil.java b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/DefaultParamDeepCopyUtil.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/DefaultParamDeepCopyUtil.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/DefaultParamDeepCopyUtil.java\n@@ -27,6 +27,7 @@\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.lang.reflect.Type;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_ERROR_DESERIALIZE;\n@@ -38,7 +39,7 @@ public class DefaultParamDeepCopyUtil implements ParamDeepCopyUtil {\n     @Override\n     @SuppressWarnings({\"unchecked\"})\n-    public <T> T copy(URL url, Object src, Class<T> targetClass) {\n+    public <T> T copy(URL url, Object src, Class<T> targetClass, Type type) {\n         Serialization serialization = url.getOrDefaultFrameworkModel()\n                 .getExtensionLoader(Serialization.class)\n                 .getExtension(UrlUtils.serializationOrDefault(url));\n@@ -50,7 +51,11 @@ public <T> T copy(URL url, Object src, Class<T> targetClass) {\n             try (ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray())) {\n                 ObjectInput objectInput = serialization.deserialize(url, inputStream);\n-                return objectInput.readObject(targetClass);\n+                if (type != null) {\n+                    return objectInput.readObject(targetClass, type);\n+                } else {\n+                    return objectInput.readObject(targetClass);\n+                }\n             } catch (ClassNotFoundException | IOException e) {\n                 logger.error(PROTOCOL_ERROR_DESERIALIZE, \"\", \"\", \"Unable to deep copy parameter to target class.\", e);\n             }\ndiff --git a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n@@ -152,7 +152,7 @@ public Result doInvoke(Invocation invocation) throws Throwable {\n                                 appResponse.setObjectAttachments(new HashMap<>(result.getObjectAttachments()));\n                                 return appResponse;\n                             } else {\n-                                rebuildValue(invocation, desc, result);\n+                                rebuildValue(invocation, invoker, result);\n                                 AppResponse appResponse = new AppResponse(result.getValue());\n                                 appResponse.setObjectAttachments(new HashMap<>(result.getObjectAttachments()));\n                                 return appResponse;\n@@ -190,7 +190,7 @@ public Result doInvoke(Invocation invocation) throws Throwable {\n                         if (r.hasException()) {\n                             rpcResult.setException(r.getException());\n                         } else {\n-                            Object rebuildValue = rebuildValue(invocation, desc, r.getValue());\n+                            Object rebuildValue = rebuildValue(invocation, invoker, r.getValue());\n                             rpcResult.setValue(rebuildValue);\n                         }\n                     }\n@@ -201,7 +201,7 @@ public Result doInvoke(Invocation invocation) throws Throwable {\n                 if (result.hasException()) {\n                     rpcResult.setException(result.getException());\n                 } else {\n-                    Object rebuildValue = rebuildValue(invocation, desc, result.getValue());\n+                    Object rebuildValue = rebuildValue(invocation, invoker, result.getValue());\n                     rpcResult.setValue(rebuildValue);\n                 }\n                 rpcResult.setObjectAttachments(new HashMap<>(result.getObjectAttachments()));\n@@ -232,11 +232,7 @@ private Invocation recreateInvocation(Invocation invocation, Invoker<?> invoker,\n         }\n         String methodName = invocation.getMethodName();\n-        ServiceModel consumerServiceModel = invocation.getServiceModel();\n-        boolean shouldSkip = shouldIgnoreSameModule\n-                && consumerServiceModel != null\n-                && Objects.equals(providerServiceModel.getModuleModel(), consumerServiceModel.getModuleModel());\n-        if (CommonConstants.$INVOKE.equals(methodName) || shouldSkip) {\n+        if (isSkipCopy(invocation, invoker)) {\n             // generic invoke, skip copy arguments\n             RpcInvocation copiedInvocation = new RpcInvocation(\n                     invocation.getTargetServiceUniqueName(),\n@@ -297,16 +293,43 @@ private Invocation recreateInvocation(Invocation invocation, Invoker<?> invoker,\n         }\n     }\n-    private Object rebuildValue(Invocation invocation, String desc, Object originValue) {\n+    private boolean isSkipCopy(Invocation invocation, Invoker<?> invoker) {\n+        ServiceModel providerServiceModel = invoker.getUrl().getServiceModel();\n+\n+        if (providerServiceModel == null) {\n+            return true;\n+        }\n+        String methodName = invocation.getMethodName();\n+\n+        ServiceModel consumerServiceModel = invocation.getServiceModel();\n+        boolean shouldSkip = shouldIgnoreSameModule\n+                && consumerServiceModel != null\n+                && Objects.equals(providerServiceModel.getModuleModel(), consumerServiceModel.getModuleModel());\n+\n+        return CommonConstants.$INVOKE.equals(methodName)\n+                || CommonConstants.$INVOKE_ASYNC.equals(methodName)\n+                || shouldSkip;\n+    }\n+\n+    private Object rebuildValue(Invocation invocation, Invoker<?> invoker, Object originValue) {\n+        if (isSkipCopy(invocation, invoker)) {\n+            return originValue;\n+        }\n+\n         Object value = originValue;\n         ClassLoader cl = Thread.currentThread().getContextClassLoader();\n         try {\n             ServiceModel consumerServiceModel = getUrl().getServiceModel();\n             if (consumerServiceModel != null) {\n-                Class<?> returnType = getReturnType(consumerServiceModel, invocation.getMethodName(), desc);\n-                if (returnType != null) {\n-                    Thread.currentThread().setContextClassLoader(consumerServiceModel.getClassLoader());\n-                    value = paramDeepCopyUtil.copy(consumerUrl, originValue, returnType);\n+                Thread.currentThread().setContextClassLoader(consumerServiceModel.getClassLoader());\n+                Type[] returnTypes = RpcUtils.getReturnTypes(invocation);\n+                if (returnTypes == null) {\n+                    return originValue;\n+                }\n+                if (returnTypes.length == 1) {\n+                    value = paramDeepCopyUtil.copy(consumerUrl, originValue, (Class<?>) returnTypes[0]);\n+                } else if (returnTypes.length == 2) {\n+                    value = paramDeepCopyUtil.copy(consumerUrl, originValue, (Class<?>) returnTypes[0], returnTypes[1]);\n                 }\n             }\n             return value;\ndiff --git a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/ParamDeepCopyUtil.java b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/ParamDeepCopyUtil.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/ParamDeepCopyUtil.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/ParamDeepCopyUtil.java\n@@ -20,8 +20,14 @@\n import org.apache.dubbo.common.extension.ExtensionScope;\n import org.apache.dubbo.common.extension.SPI;\n+import java.lang.reflect.Type;\n+\n @SPI(scope = ExtensionScope.FRAMEWORK)\n public interface ParamDeepCopyUtil {\n-    <T> T copy(URL url, Object src, Class<T> targetClass);\n+    default <T> T copy(URL url, Object src, Class<T> targetClass) {\n+        return copy(url, src, targetClass, null);\n+    }\n+\n+    <T> T copy(URL url, Object src, Class<T> targetClass, Type type);\n }",
    "output": "Fix generic type result copy in InjvmInvoker"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -167,8 +167,8 @@ public void configClientPipeline(URL url, ChannelOperator operator, ContextOpera\n         List<ChannelHandler> handlers = new ArrayList<>();\n         handlers.add(new ChannelHandlerPretender(codec));\n         handlers.add(new ChannelHandlerPretender(new Http2MultiplexHandler(new ChannelDuplexHandler())));\n-        handlers.add(new ChannelHandlerPretender(new TripleGoAwayHandler()));\n         handlers.add(new ChannelHandlerPretender(new TriplePingPongHandler(UrlUtils.getCloseTimeout(url))));\n+        handlers.add(new ChannelHandlerPretender(new TripleGoAwayHandler()));\n         handlers.add(new ChannelHandlerPretender(new TripleTailHandler()));\n         operator.configChannelHandler(handlers);\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java\n@@ -42,7 +42,9 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n                         + ctx.channel().remoteAddress() + \" and will reconnect later.\");\n             }\n             connectionHandler.onGoAway(ctx.channel());\n+            ReferenceCountUtil.release(msg);\n+            return;\n         }\n-        ReferenceCountUtil.release(msg);\n+        super.channelRead(ctx, msg);\n     }\n }",
    "output": "Fix go away handler"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n@@ -130,15 +130,12 @@ private static boolean isAttachInvocationId(URL url, Invocation invocation) {\n         if (value == null) {\n             // add invocationid in async operation by default\n             return isAsync(url, invocation);\n-        } else if (Boolean.TRUE.toString().equalsIgnoreCase(value)) {\n-            return true;\n-        } else {\n-            return false;\n         }\n+        return Boolean.TRUE.toString().equalsIgnoreCase(value);\n     }\n     public static String getMethodName(Invocation invocation) {\n-        if ($INVOKE.equals(invocation.getMethodName())\n+        if (($INVOKE.equals(invocation.getMethodName()) || $INVOKE_ASYNC.equals(invocation.getMethodName()))\n                 && invocation.getArguments() != null\n                 && invocation.getArguments().length > 0\n                 && invocation.getArguments()[0] instanceof String) {\n@@ -148,7 +145,7 @@ public static String getMethodName(Invocation invocation) {\n     }\n     public static Object[] getArguments(Invocation invocation) {\n-        if ($INVOKE.equals(invocation.getMethodName())\n+        if (($INVOKE.equals(invocation.getMethodName()) || $INVOKE_ASYNC.equals(invocation.getMethodName()))\n                 && invocation.getArguments() != null\n                 && invocation.getArguments().length > 2\n                 && invocation.getArguments()[2] instanceof Object[]) {\n@@ -158,7 +155,7 @@ public static Object[] getArguments(Invocation invocation) {\n     }\n     public static Class<?>[] getParameterTypes(Invocation invocation) {\n-        if ($INVOKE.equals(invocation.getMethodName())\n+        if (($INVOKE.equals(invocation.getMethodName()) || $INVOKE_ASYNC.equals(invocation.getMethodName()))\n                 && invocation.getArguments() != null\n                 && invocation.getArguments().length > 1\n                 && invocation.getArguments()[1] instanceof String[]) {\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RpcUtilsTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RpcUtilsTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RpcUtilsTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RpcUtilsTest.java\n@@ -401,6 +401,32 @@ void testGetParameterTypes() {\n         Assertions.assertEquals(Object.class, parameterTypes5[2]);\n     }\n+    @Test\n+    void testGet_$invokeAsync_ParameterTypes() {\n+        Object[] args = new Object[] {\"hello\", true, 520};\n+        Class<?> demoServiceClass = DemoService.class;\n+        String serviceName = demoServiceClass.getName();\n+        Invoker invoker = createMockInvoker();\n+\n+        RpcInvocation inv = new RpcInvocation(\n+                \"$invokeAsync\",\n+                serviceName,\n+                \"\",\n+                new Class<?>[] {String.class, String[].class, Object[].class},\n+                new Object[] {\n+                    \"method\", new String[] {\"java.lang.String\", \"java.lang.Boolean\", \"java.lang.Integer\"}, args\n+                },\n+                null,\n+                invoker,\n+                null);\n+\n+        Class<?>[] parameterTypes = RpcUtils.getParameterTypes(inv);\n+        for (int i = 0; i < args.length; i++) {\n+            Assertions.assertNotNull(parameterTypes[i]);\n+            Assertions.assertEquals(args[i].getClass(), parameterTypes[i]);\n+        }\n+    }\n+\n     @ParameterizedTest\n     @CsvSource({\"echo\", \"stringLength\", \"testReturnType\"})\n     public void testGetMethodName(String methodName) {\n@@ -436,6 +462,27 @@ public void testGetMethodName(String methodName) {\n         Assertions.assertEquals(method, actual);\n     }\n+    @ParameterizedTest\n+    @CsvSource({\"hello\", \"apache\", \"dubbo\"})\n+    public void testGet_$invokeAsync_MethodName(String method) {\n+        Class<?> demoServiceClass = DemoService.class;\n+        String serviceName = demoServiceClass.getName();\n+        Invoker invoker = createMockInvoker();\n+\n+        RpcInvocation inv = new RpcInvocation(\n+                \"$invokeAsync\",\n+                serviceName,\n+                \"\",\n+                new Class<?>[] {String.class, String[].class},\n+                new Object[] {method, new String[] {\"java.lang.String\", \"void\", \"java.lang.Object\"}},\n+                null,\n+                invoker,\n+                null);\n+        String actual = RpcUtils.getMethodName(inv);\n+        Assertions.assertNotNull(actual);\n+        Assertions.assertEquals(method, actual);\n+    }\n+\n     @Test\n     void testGet_$invoke_Arguments() {\n         Object[] args = new Object[] {\"hello\", \"dubbo\", 520};\n@@ -462,6 +509,32 @@ public void testGetMethodName(String methodName) {\n         }\n     }\n+    @Test\n+    void testGet_$invokeAsync_Arguments() {\n+        Object[] args = new Object[] {\"hello\", \"dubbo\", 520};\n+        Class<?> demoServiceClass = DemoService.class;\n+        String serviceName = demoServiceClass.getName();\n+        Invoker invoker = createMockInvoker();\n+\n+        RpcInvocation inv = new RpcInvocation(\n+                \"$invokeAsync\",\n+                serviceName,\n+                \"\",\n+                new Class<?>[] {String.class, String[].class, Object[].class},\n+                new Object[] {\"method\", new String[] {}, args},\n+                null,\n+                invoker,\n+                null);\n+\n+        Object[] arguments = RpcUtils.getArguments(inv);\n+        for (int i = 0; i < args.length; i++) {\n+            Assertions.assertNotNull(arguments[i]);\n+            Assertions.assertEquals(\n+                    args[i].getClass().getName(), arguments[i].getClass().getName());\n+            Assertions.assertEquals(args[i], arguments[i]);\n+        }\n+    }\n+\n     @Test\n     void testIsAsync() {\n         Object[] args = new Object[] {\"hello\", \"dubbo\", 520};",
    "output": "Fix async generic method"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n@@ -237,7 +237,7 @@ void testConstructionWithIndex() throws Exception {\n         nextIndexField.setAccessible(true);\n         AtomicInteger nextIndex = (AtomicInteger) nextIndexField.get(AtomicInteger.class);\n         int arrayListCapacityMaxSize = InternalThreadLocalMap.ARRAY_LIST_CAPACITY_MAX_SIZE;\n-        int nextIndex_before = nextIndex.get();\n+        int nextIndex_before = nextIndex.incrementAndGet();\n         nextIndex.set(0);\n         final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();\n         try {",
    "output": "Fix order dependent tests in `InternalThreadLocalTest` * Fix order dependent tests in InternalThreadLocalTest * Fix order dependent tests in InternalThreadLocalTest"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/AbstractGenerator.java b/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/AbstractGenerator.java\n--- a/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/AbstractGenerator.java\n+++ b/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/AbstractGenerator.java\n@@ -99,6 +99,9 @@ private List<ServiceContext> findServices(List<FileDescriptorProto> protos, Prot\n                 serviceContext.packageName = extractPackageName(fileProto);\n                 if (!Strings.isNullOrEmpty(fileProto.getOptions().getJavaOuterClassname())) {\n                     serviceContext.outerClassName = fileProto.getOptions().getJavaOuterClassname();\n+                } else {\n+                    serviceContext.outerClassName =\n+                            ProtoTypeMap.getJavaOuterClassname(fileProto, fileProto.getOptions());\n                 }\n                 serviceContext.commonPackageName = extractCommonPackageName(fileProto);\n                 serviceContext.multipleFiles = fileProto.getOptions().getJavaMultipleFiles();\n@@ -128,7 +131,6 @@ private ServiceContext buildServiceContext(\n         ServiceContext serviceContext = new ServiceContext();\n         serviceContext.fileName = getClassPrefix() + serviceProto.getName() + getClassSuffix() + \".java\";\n         serviceContext.className = getClassPrefix() + serviceProto.getName() + getClassSuffix();\n-        serviceContext.outerClassName = serviceProto.getName() + \"OuterClass\";\n         serviceContext.interfaceFileName = serviceProto.getName() + \".java\";\n         serviceContext.interfaceClassName = serviceProto.getName();\n         serviceContext.serviceName = serviceProto.getName();\ndiff --git a/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/utils/ProtoTypeMap.java b/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/utils/ProtoTypeMap.java\n--- a/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/utils/ProtoTypeMap.java\n+++ b/dubbo-plugin/dubbo-compiler/src/main/java/org/apache/dubbo/gen/utils/ProtoTypeMap.java\n@@ -62,7 +62,7 @@ public String toJavaTypeName(@Nonnull String protoTypeName) {\n         return (String)this.types.get(protoTypeName);\n     }\n-    private static String getJavaOuterClassname(DescriptorProtos.FileDescriptorProto fileDescriptor, DescriptorProtos.FileOptions fileOptions) {\n+    public static String getJavaOuterClassname(DescriptorProtos.FileDescriptorProto fileDescriptor, DescriptorProtos.FileOptions fileOptions) {\n         if (fileOptions.hasJavaOuterClassname()) {\n             return fileOptions.getJavaOuterClassname();\n         } else {",
    "output": "Fix Dubbo3TripleGenerator use OuterClassName error * fix:Dubbo3TripleGenerator use OuterClassName error * fix:spotless style apply ---------"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n@@ -27,14 +27,15 @@\n import java.util.concurrent.atomic.AtomicInteger;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_DELAY_EXECUTE_TIMES;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_FAILED_NOTIFY_EVENT;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_FAILED_NOTIFY_EVENT;\n public abstract class RegistryNotifier {\n     private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(RegistryNotifier.class);\n     private volatile long lastExecuteTime;\n     private volatile long lastEventTime;\n-\n+    private final URL url;\n     private Object rawAddresses;\n     private long delayTime;\n@@ -50,6 +51,7 @@ public RegistryNotifier(URL registryUrl, long delayTime) {\n     }\n     public RegistryNotifier(URL registryUrl, long delayTime, ScheduledExecutorService scheduler) {\n+        this.url = registryUrl;\n         this.delayTime = delayTime;\n         if (scheduler == null) {\n             this.scheduler = registryUrl.getOrDefaultFrameworkModel().getBeanFactory()\n@@ -68,7 +70,13 @@ public synchronized void notify(Object rawAddresses) {\n         // more than 10 calls && next execute time is in the future\n         boolean delay = shouldDelay.get() && delta < 0;\n-        if (delay) {\n+        // when the scheduler is shutdown, no notification is sent\n+        if (scheduler.isShutdown()) {\n+            if (logger.isWarnEnabled()) {\n+                logger.warn(COMMON_FAILED_NOTIFY_EVENT, \"\", \"\", \"Notification scheduler is off, no notifications are sent. Registry URL:  \" + url);\n+            }\n+            return;\n+        } else if (delay) {\n             scheduler.schedule(new NotificationTask(this, notifyTime), -delta, TimeUnit.MILLISECONDS);\n         } else {\n             // check if more than 10 calls",
    "output": "Add scheduler closure check during RegistryNotifier notify. * Added scheduler closure check during RegistryNotifier notify. * Added logs. * Updated logs. * Updated logs. * Updated logs. * Add URL"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n@@ -17,7 +17,6 @@\n package org.apache.dubbo.rpc.protocol.tri;\n-import com.google.protobuf.Message;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.serialize.MultipleSerialization;",
    "output": "Fix import for compile"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -17,18 +17,6 @@\n package org.apache.dubbo.rpc.protocol.tri;\n-import io.netty.channel.ChannelInitializer;\n-import io.netty.channel.ChannelPipeline;\n-import io.netty.handler.codec.http.HttpObjectAggregator;\n-import io.netty.handler.codec.http.HttpServerCodec;\n-import io.netty.handler.codec.http2.Http2FrameCodec;\n-import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n-import io.netty.handler.codec.http2.Http2FrameLogger;\n-import io.netty.handler.codec.http2.Http2MultiplexHandler;\n-import io.netty.handler.codec.http2.Http2Settings;\n-import io.netty.handler.codec.http2.Http2StreamChannel;\n-import io.netty.handler.flush.FlushConsolidationHandler;\n-import io.netty.handler.logging.LogLevel;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.config.Configuration;\n import org.apache.dubbo.common.config.ConfigurationUtils;\n@@ -51,11 +39,24 @@\n import org.apache.dubbo.rpc.protocol.tri.h12.TripleProtocolDetector;\n import org.apache.dubbo.rpc.protocol.tri.h12.http1.DefaultHttp11ServerTransportListenerFactory;\n import org.apache.dubbo.rpc.protocol.tri.h12.http2.GenericHttp2ServerTransportListenerFactory;\n-import org.apache.dubbo.rpc.protocol.tri.transport.TripleClientHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleGoAwayHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleServerConnectionHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleTailHandler;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http2.Http2FrameCodec;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2FrameLogger;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.codec.http2.Http2StreamChannel;\n+import io.netty.handler.flush.FlushConsolidationHandler;\n+import io.netty.handler.logging.LogLevel;\n+\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -120,11 +121,11 @@ public void configClientPipeline(URL url, ChannelOperator operator, ContextOpera\n             .frameLogger(CLIENT_LOGGER)\n             .build();\n //        codec.connection().local().flowController().frameWriter(codec.encoder().frameWriter());\n-        final Http2MultiplexHandler handler = new Http2MultiplexHandler(\n-            new TripleClientHandler(frameworkModel));\n         List<ChannelHandler> handlers = new ArrayList<>();\n         handlers.add(new ChannelHandlerPretender(codec));\n-        handlers.add(new ChannelHandlerPretender(handler));\n+        handlers.add(new ChannelHandlerPretender(new Http2MultiplexHandler(new ChannelDuplexHandler())));\n+        handlers.add(new ChannelHandlerPretender(new TripleGoAwayHandler()));\n+        handlers.add(new ChannelHandlerPretender(new TriplePingPongHandler(UrlUtils.getCloseTimeout(url))));\n         handlers.add(new ChannelHandlerPretender(new TripleTailHandler()));\n         operator.configChannelHandler(handlers);\n     }\n@@ -189,8 +190,6 @@ protected void initChannel(Http2StreamChannel ch) {\n             });\n         handlers.add(new ChannelHandlerPretender(new HttpWriteQueueHandler()));\n         handlers.add(new ChannelHandlerPretender(codec));\n-        handlers.add(new ChannelHandlerPretender(new TripleGoAwayHandler()));\n-        handlers.add(new ChannelHandlerPretender(new TriplePingPongHandler(UrlUtils.getCloseTimeout(url))));\n         handlers.add(new ChannelHandlerPretender(new FlushConsolidationHandler(64, true)));\n         handlers.add(new ChannelHandlerPretender(new TripleServerConnectionHandler()));\n         handlers.add(new ChannelHandlerPretender(handler));",
    "output": "Fix conflicts"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java b/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java\n@@ -155,11 +155,6 @@ public <T> T getOrRegisterBean(String name, Class<T> type, Function<? super Clas\n         return bean;\n     }\n-    public <T> T initializeBean(T bean) {\n-        this.initializeBean(null, bean);\n-        return bean;\n-    }\n-\n     private void initializeBean(String name, Object bean) {\n         checkDestroyed();\n         try {",
    "output": "Remove unused method in ScopeBeanFactory.java"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/filter/DubboContainerResponseContextImpl.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/filter/DubboContainerResponseContextImpl.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/filter/DubboContainerResponseContextImpl.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/filter/DubboContainerResponseContextImpl.java\n@@ -124,9 +124,10 @@ public Type getEntityType() {\n     @Override\n     public void setEntity(Object entity) {\n-        //if (entity != null) logger.info(\"*** setEntity(Object) \" + entity.toString());\n         if (entity != null && jaxrsResponse.getEntity() != null) {\n-            logger.info(\"Dubbo container response context filter set entity ,before entity is: \" + jaxrsResponse.getEntity() + \"and after entity is: \" + entity);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Dubbo container response context filter set entity ,before entity is: \" + jaxrsResponse.getEntity() + \"and after entity is: \" + entity);\n+            }\n         }\n         jaxrsResponse.setEntity(entity);\n@@ -138,9 +139,10 @@ public void setEntity(Object entity) {\n     @Override\n     public void setEntity(Object entity, Annotation[] annotations, MediaType mediaType) {\n-        //if (entity != null) logger.info(\"*** setEntity(Object, Annotation[], MediaType) \" + entity.toString() + \", \" + mediaType);\n         if (entity != null && jaxrsResponse.getEntity() != null) {\n-            logger.info(\"Dubbo container response context filter set entity ,before entity is: \" + jaxrsResponse.getEntity() + \"and after entity is: \" + entity);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Dubbo container response context filter set entity ,before entity is: \" + jaxrsResponse.getEntity() + \"and after entity is: \" + entity);\n+            }\n         }\n         jaxrsResponse.setEntity(entity);\n         jaxrsResponse.setAnnotations(annotations);",
    "output": "Change the log level when the rest entity is changed * Change the log level when the rest entity is changed"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n@@ -22,6 +22,7 @@\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.ConcurrentHashMapUtils;\n+import org.apache.dubbo.common.utils.ConcurrentHashSet;\n import org.apache.dubbo.metadata.AbstractServiceNameMapping;\n import org.apache.dubbo.metadata.MappingChangedEvent;\n import org.apache.dubbo.metadata.MappingListener;\n@@ -37,11 +38,13 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n@@ -79,7 +82,7 @@ public class ServiceDiscoveryRegistry extends FailbackRegistry {\n     /* apps - listener */\n     private final Map<String, ServiceInstancesChangedListener> serviceListeners = new ConcurrentHashMap<>();\n-    private final Map<String, MappingListener> mappingListeners = new ConcurrentHashMap<>();\n+    private final Map<String, Set<MappingListener>> mappingListeners = new ConcurrentHashMap<>();\n     /* This lock has the same scope and lifecycle as its corresponding instance listener.\n     It's used to make sure that only one interface mapping to the same app list can do subscribe or unsubscribe at the same moment.\n     And the lock should be destroyed when listener destroying its corresponding instance listener.\n@@ -112,7 +115,7 @@ public ServiceDiscovery getServiceDiscovery() {\n      */\n     protected ServiceDiscovery createServiceDiscovery(URL registryURL) {\n         return getServiceDiscovery(registryURL.addParameter(INTERFACE_KEY, ServiceDiscovery.class.getName())\n-                .removeParameter(REGISTRY_TYPE_KEY));\n+            .removeParameter(REGISTRY_TYPE_KEY));\n     }\n     /**\n@@ -206,7 +209,10 @@ public void doSubscribe(URL url, NotifyListener listener) {\n                 try {\n                     MappingListener mappingListener = new DefaultMappingListener(url, mappingByUrl, listener);\n                     mappingByUrl = serviceNameMapping.getAndListen(this.getUrl(), url, mappingListener);\n-                    mappingListeners.put(url.getProtocolServiceKey(), mappingListener);\n+                    synchronized (mappingListeners) {\n+                        mappingListeners.computeIfAbsent(url.getProtocolServiceKey(), (k) -> new ConcurrentHashSet<>())\n+                            .add(mappingListener);\n+                    }\n                 } catch (Exception e) {\n                     logger.warn(INTERNAL_ERROR, \"\", \"\", \"Cannot find app mapping for service \" + url.getServiceInterface() + \", will not migrate.\", e);\n                 }\n@@ -248,8 +254,23 @@ public void doUnsubscribe(URL url, NotifyListener listener) {\n         serviceDiscovery.unsubscribe(url, listener);\n         String protocolServiceKey = url.getProtocolServiceKey();\n         Set<String> serviceNames = serviceNameMapping.getMapping(url);\n-        if (mappingListeners.get(protocolServiceKey) != null) {\n-            serviceNameMapping.stopListen(url, mappingListeners.remove(protocolServiceKey));\n+\n+        synchronized (mappingListeners) {\n+            Set<MappingListener> keyedListeners = mappingListeners.get(protocolServiceKey);\n+            if (keyedListeners != null) {\n+                List<MappingListener> matched = keyedListeners.stream()\n+                    .filter(mappingListener ->\n+                        mappingListener instanceof DefaultMappingListener\n+                            && (Objects.equals(((DefaultMappingListener) mappingListener).getListener(), listener)))\n+                    .collect(Collectors.toList());\n+                for (MappingListener mappingListener : matched) {\n+                    serviceNameMapping.stopListen(url, mappingListener);\n+                    keyedListeners.remove(mappingListener);\n+                }\n+                if (keyedListeners.isEmpty()) {\n+                    mappingListeners.remove(protocolServiceKey, Collections.emptySet());\n+                }\n+            }\n         }\n         if (CollectionUtils.isNotEmpty(serviceNames)) {\n             String serviceNamesKey = toStringKeys(serviceNames);\n@@ -430,6 +451,10 @@ public synchronized void onEvent(MappingChangedEvent event) {\n             }\n         }\n+        protected NotifyListener getListener() {\n+            return listener;\n+        }\n+\n         @Override\n         public void stop() {\n             stopped = true;",
    "output": "Fix MappingListener override in ServiceDiscoveryRegistry"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n@@ -258,7 +258,7 @@ public void doUnsubscribe(URL url, NotifyListener listener) {\n                 appSubscriptionLock.lock();\n                 ServiceInstancesChangedListener instancesChangedListener = serviceListeners.get(serviceNamesKey);\n                 if (instancesChangedListener != null) {\n-                    instancesChangedListener.removeListener(protocolServiceKey, listener);\n+                    instancesChangedListener.removeListener(url.getServiceKey(), listener);\n                     if (!instancesChangedListener.hasListeners()) {\n                         instancesChangedListener.destroy();\n                         serviceListeners.remove(serviceNamesKey);",
    "output": "Fix service key params when remove service instance listener"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/model/MigrationRule.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/model/MigrationRule.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/model/MigrationRule.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/model/MigrationRule.java\n@@ -166,9 +166,8 @@ public MigrationStep getStep(URL consumerURL) {\n          */\n         if (step == null) {\n             // initial step : APPLICATION_FIRST\n-            step = MigrationStep.APPLICATION_FIRST;\n-            step = Enum.valueOf(MigrationStep.class,\n-                consumerURL.getParameter(MIGRATION_STEP_KEY, getDefaultStep(consumerURL, step.name())));\n+            return Enum.valueOf(MigrationStep.class,\n+                consumerURL.getParameter(MIGRATION_STEP_KEY, getDefaultStep(consumerURL, MigrationStep.APPLICATION_FIRST.name())));\n         }\n         return step;",
    "output": "Fix MigrationRule changing when load consumer default value"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ArgumentCallbackTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ArgumentCallbackTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ArgumentCallbackTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ArgumentCallbackTest.java\n@@ -123,7 +123,7 @@ void TestCallbackNormalWithBindPort() throws Exception {\n         demoProxy.xxx(new IDemoCallback() {\n             public String yyy(String msg) {\n-                System.out.println(\"Recived callback: \" + msg);\n+                System.out.println(\"Received callback: \" + msg);\n                 count.incrementAndGet();\n                 return \"ok\";\n             }\n@@ -143,7 +143,7 @@ void TestCallbackNormal() throws Exception {\n         demoProxy.xxx(new IDemoCallback() {\n             public String yyy(String msg) {\n-                System.out.println(\"Recived callback: \" + msg);\n+                System.out.println(\"Received callback: \" + msg);\n                 count.incrementAndGet();\n                 return \"ok\";\n             }\n@@ -215,15 +215,15 @@ void TestCallbackConsumerLimit() {\n             final AtomicInteger count = new AtomicInteger(0);\n             demoProxy.xxx(new IDemoCallback() {\n                 public String yyy(String msg) {\n-                    System.out.println(\"Recived callback: \" + msg);\n+                    System.out.println(\"Received callback: \" + msg);\n                     count.incrementAndGet();\n                     return \"ok\";\n                 }\n             }, \"other custom args\", 10, 100);\n             demoProxy.xxx(new IDemoCallback() {\n                 public String yyy(String msg) {\n-                    System.out.println(\"Recived callback: \" + msg);\n+                    System.out.println(\"Received callback: \" + msg);\n                     count.incrementAndGet();\n                     return \"ok\";\n                 }\n@@ -243,15 +243,15 @@ void TestCallbackProviderLimit() {\n             final AtomicInteger count = new AtomicInteger(0);\n             demoProxy.xxx(new IDemoCallback() {\n                 public String yyy(String msg) {\n-                    System.out.println(\"Recived callback: \" + msg);\n+                    System.out.println(\"Received callback: \" + msg);\n                     count.incrementAndGet();\n                     return \"ok\";\n                 }\n             }, \"other custom args\", 10, 100);\n             demoProxy.xxx(new IDemoCallback() {\n                 public String yyy(String msg) {\n-                    System.out.println(\"Recived callback: \" + msg);\n+                    System.out.println(\"Received callback: \" + msg);\n                     count.incrementAndGet();\n                     return \"ok\";\n                 }",
    "output": "Fix typo in ArgumentCallbackTest"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/aot/TripleReflectionTypeDescriberRegistrar.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/aot/TripleReflectionTypeDescriberRegistrar.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/aot/TripleReflectionTypeDescriberRegistrar.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/aot/TripleReflectionTypeDescriberRegistrar.java\n@@ -19,7 +19,7 @@\n import org.apache.dubbo.aot.api.MemberCategory;\n import org.apache.dubbo.aot.api.ReflectionTypeDescriberRegistrar;\n import org.apache.dubbo.aot.api.TypeDescriber;\n-import org.apache.dubbo.rpc.protocol.tri.transport.TripleClientHandler;\n+import org.apache.dubbo.rpc.protocol.tri.transport.TripleGoAwayHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2FrameServerHandler;\n@@ -39,7 +39,7 @@ public List<TypeDescriber> getTypeDescribers() {\n         typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleCommandOutBoundHandler.class));\n         typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleTailHandler.class));\n         typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleServerConnectionHandler.class));\n-        typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleClientHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleGoAwayHandler.class));\n         typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleHttp2ClientResponseHandler.class));\n         return typeDescribers;\n     }",
    "output": "Fix TripleReflectionTypeDescriberRegistrar Compilation Failure"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/LazyTargetInvocationHandler.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/LazyTargetInvocationHandler.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/LazyTargetInvocationHandler.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/LazyTargetInvocationHandler.java\n@@ -47,11 +47,7 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl\n         }\n         if (target == null) {\n-            synchronized (this) {\n-                if (target == null) {\n-                    target = lazyTargetSource.getTarget();\n-                }\n-            }\n+            target = lazyTargetSource.getTarget();\n         }\n         if (method.getDeclaringClass().isInstance(target)) {\n             try {",
    "output": "Remove sync lock for lazy target"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java\n@@ -178,4 +178,7 @@ public interface Constants {\n     String CONTENT_LENGTH_KEY = \"content-length\";\n     String USE_SECURE_RANDOM_ID = \"dubbo.application.use-secure-random-request-id\";\n+\n+    String CONNECTION_HANDLER_NAME = \"connectionHandler\";\n+\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n@@ -23,6 +23,7 @@\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.remoting.Channel;\n import org.apache.dubbo.remoting.ChannelHandler;\n+import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.remoting.RemotingException;\n import org.apache.dubbo.remoting.api.WireProtocol;\n import org.apache.dubbo.remoting.api.connection.AbstractConnectionClient;\n@@ -123,7 +124,7 @@ protected void initChannel(SocketChannel ch) {\n                 int heartbeat = UrlUtils.getHeartbeat(getUrl());\n                 pipeline.addLast(\"client-idle-handler\", new IdleStateHandler(heartbeat, 0, 0, MILLISECONDS));\n-                pipeline.addLast(\"connectionHandler\", connectionHandler);\n+                pipeline.addLast(Constants.CONNECTION_HANDLER_NAME, connectionHandler);\n                 NettyConfigOperator operator = new NettyConfigOperator(nettyChannel, getChannelHandler());\n                 protocol.configClientPipeline(getUrl(), operator, nettySslContextOperator);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -17,15 +17,6 @@\n package org.apache.dubbo.rpc.protocol.tri;\n-import io.netty.channel.ChannelInitializer;\n-import io.netty.channel.ChannelPipeline;\n-import io.netty.handler.codec.http2.Http2FrameCodec;\n-import io.netty.handler.codec.http2.Http2FrameLogger;\n-import io.netty.handler.codec.http2.Http2MultiplexHandler;\n-import io.netty.handler.codec.http2.Http2Settings;\n-import io.netty.handler.codec.http2.Http2StreamChannel;\n-import io.netty.handler.flush.FlushConsolidationHandler;\n-import io.netty.handler.logging.LogLevel;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.config.Configuration;\n import org.apache.dubbo.common.config.ConfigurationUtils;\n@@ -42,13 +33,24 @@\n import org.apache.dubbo.rpc.executor.ExecutorSupport;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ScopeModelAware;\n-import org.apache.dubbo.rpc.protocol.tri.transport.TripleClientHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\n+import org.apache.dubbo.rpc.protocol.tri.transport.TripleGoAwayHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2FrameServerHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleServerConnectionHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleTailHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.handler.codec.http2.Http2FrameCodec;\n+import io.netty.handler.codec.http2.Http2FrameLogger;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.codec.http2.Http2StreamChannel;\n+import io.netty.handler.flush.FlushConsolidationHandler;\n+import io.netty.handler.logging.LogLevel;\n+\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -161,11 +163,10 @@ public void configClientPipeline(URL url, ChannelOperator operator, ContextOpera\n             .frameLogger(CLIENT_LOGGER)\n             .build();\n         codec.connection().local().flowController().frameWriter(codec.encoder().frameWriter());\n-        final Http2MultiplexHandler handler = new Http2MultiplexHandler(\n-            new TripleClientHandler(frameworkModel));\n         List<ChannelHandler> handlers = new ArrayList<>();\n         handlers.add(new ChannelHandlerPretender(codec));\n-        handlers.add(new ChannelHandlerPretender(handler));\n+        handlers.add(new ChannelHandlerPretender(new Http2MultiplexHandler(new ChannelDuplexHandler())));\n+        handlers.add(new ChannelHandlerPretender(new TripleGoAwayHandler()));\n         handlers.add(new ChannelHandlerPretender(new TriplePingPongHandler(UrlUtils.getCloseTimeout(url))));\n         handlers.add(new ChannelHandlerPretender(new TripleTailHandler()));\n         operator.configChannelHandler(handlers);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java\n@@ -17,28 +17,24 @@\n package org.apache.dubbo.rpc.protocol.tri.transport;\n+import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.remoting.api.connection.ConnectionHandler;\n-import org.apache.dubbo.rpc.model.FrameworkModel;\n import io.netty.channel.ChannelDuplexHandler;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2GoAwayFrame;\n import io.netty.util.ReferenceCountUtil;\n-public class TripleClientHandler extends ChannelDuplexHandler {\n+public class TripleGoAwayHandler extends ChannelDuplexHandler {\n-    private final FrameworkModel frameworkModel;\n-    private static final String CONNECTION_HANDLER_NAME = \"connectionHandler\";\n-\n-    public TripleClientHandler(FrameworkModel frameworkModel) {\n-        this.frameworkModel = frameworkModel;\n+    public TripleGoAwayHandler() {\n     }\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n         if (msg instanceof Http2GoAwayFrame) {\n-            final ConnectionHandler connectionHandler = (ConnectionHandler) ctx.pipeline().get(CONNECTION_HANDLER_NAME);\n+            final ConnectionHandler connectionHandler = (ConnectionHandler) ctx.pipeline().get(Constants.CONNECTION_HANDLER_NAME);\n             connectionHandler.onGoAway(ctx.channel());\n         }\n         ReferenceCountUtil.release(msg);",
    "output": "Fix unable to receive go away frame * Fix unable to receive go away frame * Rename * rename"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java\n@@ -63,7 +63,7 @@ public StubMethodDescriptor(String methodName,\n         this.returnClass = responseClass;\n         this.paramDesc = ReflectUtils.getDesc(parameterClasses);\n         this.compatibleParamSignatures = Stream.of(parameterClasses).map(Class::getName).toArray(String[]::new);\n-        this.returnTypes = new Type[]{requestClass, requestClass};\n+        this.returnTypes = new Type[]{responseClass, responseClass};\n         serviceDescriptor.addMethod(this);\n     }",
    "output": "Fix wrong returnTypes for StubMethodDescriptor"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/StubMethodDescriptor.java\n@@ -63,7 +63,7 @@ public StubMethodDescriptor(String methodName,\n         this.returnClass = responseClass;\n         this.paramDesc = ReflectUtils.getDesc(parameterClasses);\n         this.compatibleParamSignatures = Stream.of(parameterClasses).map(Class::getName).toArray(String[]::new);\n-        this.returnTypes = new Type[]{requestClass, requestClass};\n+        this.returnTypes = new Type[]{responseClass, responseClass};\n         serviceDescriptor.addMethod(this);\n     }",
    "output": "Fix wrong return types for StubMethodDescriptor"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/EchoFilterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/EchoFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/EchoFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/EchoFilterTest.java\n@@ -38,20 +38,9 @@ class EchoFilterTest {\n     @SuppressWarnings(\"unchecked\")\n     @Test\n     void testEcho() {\n-        Invocation invocation = mock(RpcInvocation.class);\n+        Invocation invocation = createMockRpcInvocation();\n+        Invoker<DemoService> invoker = createMockInvoker(invocation);\n         given(invocation.getMethodName()).willReturn(\"$echo\");\n-        given(invocation.getParameterTypes()).willReturn(new Class<?>[]{Enum.class});\n-        given(invocation.getArguments()).willReturn(new Object[]{\"hello\"});\n-        given(invocation.getObjectAttachments()).willReturn(null);\n-\n-        Invoker<DemoService> invoker = mock(Invoker.class);\n-        given(invoker.isAvailable()).willReturn(true);\n-        given(invoker.getInterface()).willReturn(DemoService.class);\n-        AppResponse result = new AppResponse();\n-        result.setValue(\"High\");\n-        given(invoker.invoke(invocation)).willReturn(result);\n-        URL url = URL.valueOf(\"test://test:11/test?group=dubbo&version=1.1\");\n-        given(invoker.getUrl()).willReturn(url);\n         Result filterResult = echoFilter.invoke(invoker, invocation);\n         assertEquals(\"hello\", filterResult.getValue());\n@@ -60,22 +49,31 @@ void testEcho() {\n     @SuppressWarnings(\"unchecked\")\n     @Test\n     void testNonEcho() {\n-        Invocation invocation = mock(Invocation.class);\n+        Invocation invocation = createMockRpcInvocation();\n+        Invoker<DemoService> invoker = createMockInvoker(invocation);\n         given(invocation.getMethodName()).willReturn(\"echo\");\n+\n+        Result filterResult = echoFilter.invoke(invoker, invocation);\n+        assertEquals(\"High\", filterResult.getValue());\n+    }\n+\n+    Invocation createMockRpcInvocation() {\n+        Invocation invocation = mock(RpcInvocation.class);\n         given(invocation.getParameterTypes()).willReturn(new Class<?>[]{Enum.class});\n         given(invocation.getArguments()).willReturn(new Object[]{\"hello\"});\n         given(invocation.getObjectAttachments()).willReturn(null);\n-\n+        return invocation;\n+    }\n+    Invoker<DemoService> createMockInvoker(Invocation invocation){\n         Invoker<DemoService> invoker = mock(Invoker.class);\n         given(invoker.isAvailable()).willReturn(true);\n         given(invoker.getInterface()).willReturn(DemoService.class);\n+\n         AppResponse result = new AppResponse();\n         result.setValue(\"High\");\n         given(invoker.invoke(invocation)).willReturn(result);\n         URL url = URL.valueOf(\"test://test:11/test?group=dubbo&version=1.1\");\n         given(invoker.getUrl()).willReturn(url);\n-\n-        Result filterResult = echoFilter.invoke(invoker, invocation);\n-        assertEquals(\"High\", filterResult.getValue());\n+        return invoker;\n     }\n }",
    "output": "Upgrade EchoFilterTest.java"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java\n@@ -26,6 +26,7 @@\n import org.apache.dubbo.common.threadlocal.InternalThreadLocalMap;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_ERROR_RUN_THREAD_TASK;\n+import static org.apache.dubbo.common.utils.ExecutorUtil.isShutdown;\n /**\n  * Executor ensuring that all {@link Runnable} tasks submitted are executed in order\n@@ -68,8 +69,10 @@ private void schedule(Runnable removable) {\n         if (atomicBoolean.compareAndSet(false, true)) {\n             boolean success = false;\n             try {\n-                executor.execute(this);\n-                success = true;\n+                if (!isShutdown(executor)) {\n+                    executor.execute(this);\n+                    success = true;\n+                }\n             } finally {\n                 // It is possible that at this point that there are still tasks in\n                 // the queue, it would be nice to keep trying but the error may not\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ExecutorUtil.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ExecutorUtil.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ExecutorUtil.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ExecutorUtil.java\n@@ -38,12 +38,17 @@ public class ExecutorUtil {\n         new NamedThreadFactory(\"Close-ExecutorService-Timer\", true));\n     public static boolean isTerminated(Executor executor) {\n-        if (executor instanceof ExecutorService) {\n-            if (((ExecutorService) executor).isTerminated()) {\n-                return true;\n-            }\n+        if (!(executor instanceof ExecutorService)) {\n+            return false;\n+        }\n+        return ((ExecutorService) executor).isTerminated();\n+    }\n+\n+    public static boolean isShutdown(Executor executor) {\n+        if (!(executor instanceof ExecutorService)) {\n+            return false;\n         }\n-        return false;\n+        return ((ExecutorService) executor).isShutdown();\n     }\n     /**\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/executor/AbstractIsolationExecutorSupport.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/executor/AbstractIsolationExecutorSupport.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/executor/AbstractIsolationExecutorSupport.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/executor/AbstractIsolationExecutorSupport.java\n@@ -36,6 +36,7 @@ public AbstractIsolationExecutorSupport(URL url) {\n         this.frameworkServiceRepository = url.getOrDefaultFrameworkModel().getServiceRepository();\n     }\n+    @Override\n     public Executor getExecutor(Object data) {\n         ProviderModel providerModel = getProviderModel(data);\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/executor/DefaultExecutorSupport.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/executor/DefaultExecutorSupport.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/executor/DefaultExecutorSupport.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/executor/DefaultExecutorSupport.java\n@@ -30,6 +30,7 @@ public DefaultExecutorSupport(URL url) {\n         this.executorRepository = ExecutorRepository.getInstance(url.getOrDefaultApplicationModel());\n     }\n+    @Override\n     public Executor getExecutor(Object data) {\n         return executorRepository.getExecutor(url);\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java\n@@ -180,7 +180,7 @@ public Result getAppResponse() {\n      */\n     @Override\n     public Result get() throws InterruptedException, ExecutionException {\n-        if (executor != null && executor instanceof ThreadlessExecutor) {\n+        if (executor instanceof ThreadlessExecutor) {\n             ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;\n             try {\n                 while (!responseFuture.isDone() && !threadlessExecutor.isShutdown()) {\n@@ -196,7 +196,7 @@ public Result get() throws InterruptedException, ExecutionException {\n     @Override\n     public Result get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n         long deadline = System.nanoTime() + unit.toNanos(timeout);\n-        if (executor != null && executor instanceof ThreadlessExecutor) {\n+        if (executor instanceof ThreadlessExecutor) {\n             ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;\n             try {\n                 while (!responseFuture.isDone() && !threadlessExecutor.isShutdown()) {\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java\n@@ -47,6 +47,9 @@ public class DeadlineFuture extends CompletableFuture<AppResponse> {\n     private final List<Runnable> timeoutListeners = new ArrayList<>();\n     private final Timeout timeoutTask;\n     private ExecutorService executor;\n+    private static final GlobalResourceInitializer<Timer> TIME_OUT_TIMER = new GlobalResourceInitializer<>(\n+        () -> new HashedWheelTimer(new NamedThreadFactory(\"dubbo-future-timeout\", true), 30,\n+            TimeUnit.MILLISECONDS), DeadlineFuture::destroy);\n     private DeadlineFuture(String serviceName, String methodName, String address, int timeout) {\n         this.serviceName = serviceName;\n@@ -76,20 +79,15 @@ public static DeadlineFuture newFuture(String serviceName, String methodName, St\n     }\n     public void received(TriRpcStatus status, AppResponse appResponse) {\n-        if (status.code != TriRpcStatus.Code.DEADLINE_EXCEEDED) {\n-            // decrease Time\n-            if (!timeoutTask.isCancelled()) {\n-                timeoutTask.cancel();\n-            }\n+        if (status.code != TriRpcStatus.Code.DEADLINE_EXCEEDED && !timeoutTask.isCancelled()) {\n+            timeoutTask.cancel();\n         }\n         if (getExecutor() != null) {\n             getExecutor().execute(() -> doReceived(status, appResponse));\n         } else {\n             doReceived(status, appResponse);\n         }\n-    }    private static final GlobalResourceInitializer<Timer> TIME_OUT_TIMER = new GlobalResourceInitializer<>(\n-        () -> new HashedWheelTimer(new NamedThreadFactory(\"dubbo-future-timeout\", true), 30,\n-            TimeUnit.MILLISECONDS), DeadlineFuture::destroy);\n+    }\n     public void addTimeoutListener(Runnable runnable) {\n         timeoutListeners.add(runnable);",
    "output": "Fix RejectException * fix RejectException null * fix reference * use isTerminated judge Executor * use isShutdown judge Executor ---------"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n@@ -40,15 +40,18 @@\n import io.netty.channel.EventLoop;\n import io.netty.channel.socket.SocketChannel;\n import io.netty.handler.ssl.SslContext;\n+import io.netty.handler.timeout.IdleStateHandler;\n import io.netty.util.AttributeKey;\n import io.netty.util.concurrent.DefaultPromise;\n import io.netty.util.concurrent.GlobalEventExecutor;\n import io.netty.util.concurrent.Promise;\n+import org.apache.dubbo.remoting.utils.UrlUtils;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_CLIENT_THREADPOOL;\n import static org.apache.dubbo.common.constants.CommonConstants.THREADPOOL_KEY;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.TRANSPORT_CLIENT_CONNECT_TIMEOUT;\n@@ -122,12 +125,15 @@ protected void initChannel(SocketChannel ch) {\n                 }\n //                pipeline.addLast(\"logging\", new LoggingHandler(LogLevel.INFO)); //for debug\n-                // TODO support IDLE\n-//                int heartbeatInterval = UrlUtils.getHeartbeat(getUrl());\n+\n+                int heartbeat = UrlUtils.getHeartbeat(getUrl());\n+                pipeline.addLast(\"client-idle-handler\", new IdleStateHandler(heartbeat, 0, 0, MILLISECONDS));\n+\n                 pipeline.addLast(\"connectionHandler\", connectionHandler);\n                 NettyConfigOperator operator = new NettyConfigOperator(nettyChannel, getChannelHandler());\n                 protocol.configClientPipeline(getUrl(), operator, nettySslContextOperator);\n+                ch.closeFuture().addListener(channelFuture -> doClose());\n                 // TODO support Socks5\n             }\n         });\n@@ -271,7 +277,7 @@ public boolean isAvailable() {\n             try {\n                 doConnect();\n             } catch (RemotingException e) {\n-                LOGGER.error(TRANSPORT_FAILED_RECONNECT, \"\", \"\",  \"Failed to connect to server: \" + getConnectAddress());\n+                LOGGER.error(TRANSPORT_FAILED_RECONNECT, \"\", \"\", \"Failed to connect to server: \" + getConnectAddress());\n             }\n         }\n@@ -349,7 +355,7 @@ public void operationComplete(ChannelFuture future) {\n                 try {\n                     connectionClient.doConnect();\n                 } catch (RemotingException e) {\n-                    LOGGER.error(TRANSPORT_FAILED_RECONNECT, \"\", \"\",  \"Failed to connect to server: \" + getConnectAddress());\n+                    LOGGER.error(TRANSPORT_FAILED_RECONNECT, \"\", \"\", \"Failed to connect to server: \" + getConnectAddress());\n                 }\n             }, 1L, TimeUnit.SECONDS);\n         }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -37,6 +37,7 @@\n import org.apache.dubbo.remoting.api.pu.ChannelHandlerPretender;\n import org.apache.dubbo.remoting.api.pu.ChannelOperator;\n import org.apache.dubbo.remoting.api.ssl.ContextOperator;\n+import org.apache.dubbo.remoting.utils.UrlUtils;\n import org.apache.dubbo.rpc.HeaderFilter;\n import org.apache.dubbo.rpc.executor.ExecutorSupport;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n@@ -165,6 +166,7 @@ public void configClientPipeline(URL url, ChannelOperator operator, ContextOpera\n         List<ChannelHandler> handlers = new ArrayList<>();\n         handlers.add(new ChannelHandlerPretender(codec));\n         handlers.add(new ChannelHandlerPretender(handler));\n+        handlers.add(new ChannelHandlerPretender(new TriplePingPongHandler(UrlUtils.getCloseTimeout(url))));\n         handlers.add(new ChannelHandlerPretender(new TripleTailHandler()));\n         operator.configChannelHandler(handlers);\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriplePingPongHandler.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriplePingPongHandler.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriplePingPongHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriplePingPongHandler.java\n@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.tri;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+public class TriplePingPongHandler extends ChannelDuplexHandler {\n+\n+    private final long pingAckTimeout;\n+\n+    private ScheduledFuture<?> pingAckTimeoutFuture;\n+\n+    public TriplePingPongHandler(long pingAckTimeout) {\n+        this.pingAckTimeout = pingAckTimeout;\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        if (!(msg instanceof Http2PingFrame) || pingAckTimeoutFuture == null) {\n+            super.channelRead(ctx, msg);\n+            return;\n+        }\n+        //cancel task when read anything, include http2 ping ack\n+        pingAckTimeoutFuture.cancel(true);\n+        pingAckTimeoutFuture = null;\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        if (!(evt instanceof IdleStateEvent)) {\n+            ctx.fireUserEventTriggered(evt);\n+            return;\n+        }\n+        ctx.writeAndFlush(new DefaultHttp2PingFrame(0));\n+        if (pingAckTimeoutFuture == null) {\n+            pingAckTimeoutFuture = ctx.executor().schedule(new CloseChannelTask(ctx), pingAckTimeout, TimeUnit.MILLISECONDS);\n+        }\n+        //not null means last ping ack not received\n+    }\n+\n+    private static class CloseChannelTask implements Runnable {\n+\n+        private final ChannelHandlerContext ctx;\n+\n+        public CloseChannelTask(ChannelHandlerContext ctx) {\n+            this.ctx = ctx;\n+        }\n+\n+        @Override\n+        public void run() {\n+            ctx.close();\n+        }\n+    }\n+\n+}",
    "output": "Add ping pong for tri protocol * add ping pong for tri protocol * add ping pong for tri protocol * add ping pong for tri protocol * add ping pong for tri protocol"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/MetricsNameCountSampler.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/MetricsNameCountSampler.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/MetricsNameCountSampler.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/MetricsNameCountSampler.java\n@@ -27,12 +27,15 @@\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n public abstract class MetricsNameCountSampler<S, K, M extends Metric> extends SimpleMetricsCountSampler<S, K, M> {\n     protected final DefaultMetricsCollector collector;\n+    private final AtomicBoolean samplesChanged = new AtomicBoolean(true);\n+\n     protected final Set<K> metricNames = new ConcurrentHashSet<>();\n     protected final MetricsCategory metricsCategory;\n@@ -48,6 +51,7 @@ public MetricsNameCountSampler(DefaultMetricsCollector collector,MetricsCategory\n     public void addMetricName(K name) {\n         this.metricNames.add(name);\n+        this.samplesChanged.set(true);\n     }\n     @Override\n@@ -66,4 +70,9 @@ private void collect(List<MetricSample> samples, K metricName) {\n     protected abstract MetricSample provideMetricsSample(M metric,AtomicLong count,MetricsKey metricsKey,MetricsCategory metricsCategory);\n+    @Override\n+    public boolean calSamplesChanged() {\n+        // CAS to get and reset the flag in an atomic operation\n+        return samplesChanged.compareAndSet(true, false);\n+    }\n }\ndiff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadPoolMetricsSampler.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadPoolMetricsSampler.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadPoolMetricsSampler.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadPoolMetricsSampler.java\n@@ -55,6 +55,8 @@ public class ThreadPoolMetricsSampler implements MetricsSampler {\n     private DataStore dataStore;\n     private final Map<String, ThreadPoolExecutor> sampleThreadPoolExecutor = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, ThreadPoolMetric> threadPoolMetricMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean samplesChanged = new AtomicBoolean(true);\n+\n     public ThreadPoolMetricsSampler(DefaultMetricsCollector collector) {\n         this.collector = collector;\ndiff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadRejectMetricsCountSampler.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadRejectMetricsCountSampler.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadRejectMetricsCountSampler.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadRejectMetricsCountSampler.java\n@@ -23,18 +23,13 @@\n import org.apache.dubbo.metrics.model.key.MetricsKey;\n import org.apache.dubbo.metrics.model.sample.GaugeMetricSample;\n import org.apache.dubbo.metrics.model.sample.MetricSample;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+\n import java.util.concurrent.atomic.AtomicLong;\n import static org.apache.dubbo.metrics.model.MetricsCategory.THREAD_POOL;\n public class ThreadRejectMetricsCountSampler extends MetricsNameCountSampler<String, String, ThreadPoolRejectMetric> {\n-    private final AtomicBoolean samplesChanged = new AtomicBoolean(true);\n-\n     public ThreadRejectMetricsCountSampler(DefaultMetricsCollector collector) {\n         super(collector, THREAD_POOL,MetricsKey.THREAD_POOL_THREAD_REJECT_COUNT);\n     }\n@@ -54,10 +49,4 @@ protected MetricSample provideMetricsSample(ThreadPoolRejectMetric metric, Atomi\n     protected void countConfigure(MetricsCountSampleConfigurer<String, String, ThreadPoolRejectMetric> sampleConfigure) {\n         sampleConfigure.configureMetrics(configure -> new ThreadPoolRejectMetric(collector.getApplicationName(),configure.getSource()));\n     }\n-\n-    @Override\n-    public boolean calSamplesChanged() {\n-        // CAS to get and reset the flag in an atomic operation\n-        return samplesChanged.compareAndSet(true, false);\n-    }\n }\ndiff --git a/dubbo-metrics/dubbo-metrics-netty/src/main/java/org/apache/dubbo/metrics/registry/collector/NettyMetricsCollector.java b/dubbo-metrics/dubbo-metrics-netty/src/main/java/org/apache/dubbo/metrics/registry/collector/NettyMetricsCollector.java\n--- a/dubbo-metrics/dubbo-metrics-netty/src/main/java/org/apache/dubbo/metrics/registry/collector/NettyMetricsCollector.java\n+++ b/dubbo-metrics/dubbo-metrics-netty/src/main/java/org/apache/dubbo/metrics/registry/collector/NettyMetricsCollector.java\n@@ -94,4 +94,8 @@ public List<MetricSample> collect() {\n         return list;\n     }\n+    @Override\n+    public boolean calSamplesChanged() {\n+        return stats.calSamplesChanged();\n+    }\n }",
    "output": "Fix conflicts"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistry2S2RTest.java b/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistry2S2RTest.java\n--- a/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistry2S2RTest.java\n+++ b/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistry2S2RTest.java\n@@ -21,7 +21,7 @@\n import org.apache.dubbo.registry.Registry;\n import org.apache.dubbo.registry.zookeeper.ZookeeperRegistry;\n import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;\n-import org.apache.dubbo.remoting.zookeeper.curator.CuratorZookeeperClient;\n+import org.apache.dubbo.remoting.zookeeper.curator5.Curator5ZookeeperClient;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Assumptions;\n@@ -61,9 +61,9 @@ public static void beforeAll() {\n         multipleRegistry = (MultipleRegistry) new MultipleRegistryFactory().createRegistry(url);\n         // for test validation\n-        zookeeperClient = new CuratorZookeeperClient(URL.valueOf(zookeeperConnectionAddress1));\n+        zookeeperClient = new Curator5ZookeeperClient(URL.valueOf(zookeeperConnectionAddress1));\n         zookeeperRegistry = MultipleRegistryTestUtil.getZookeeperRegistry(multipleRegistry.getServiceRegistries().values());\n-        zookeeperClient2 = new CuratorZookeeperClient(URL.valueOf(zookeeperConnectionAddress2));\n+        zookeeperClient2 = new Curator5ZookeeperClient(URL.valueOf(zookeeperConnectionAddress2));\n         zookeeperRegistry2 = MultipleRegistryTestUtil.getZookeeperRegistry(multipleRegistry.getServiceRegistries().values());\n     }",
    "output": "Upgrade zookeeper registry dependencies * Update zookeeper registry dependencies * Fix compile * Update zookeeper registry dependencies"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/report/AbstractMetricsReporterFactory.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/report/AbstractMetricsReporterFactory.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/report/AbstractMetricsReporterFactory.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/report/AbstractMetricsReporterFactory.java\n@@ -1,36 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.dubbo.metrics.report;\n-\n-import org.apache.dubbo.rpc.model.ApplicationModel;\n-\n-/**\n- * AbstractMetricsReporterFactory.\n- */\n-public abstract class AbstractMetricsReporterFactory implements MetricsReporterFactory {\n-\n-    private final ApplicationModel applicationModel;\n-\n-    public AbstractMetricsReporterFactory(ApplicationModel applicationModel) {\n-        this.applicationModel = applicationModel;\n-    }\n-\n-    protected ApplicationModel getApplicationModel() {\n-        return applicationModel;\n-    }\n-}",
    "output": "Remove duplicated class"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptor.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptor.java\n@@ -75,7 +75,18 @@ private void initMethods() {\n         methods.forEach((methodName, methodList) -> {\n             Map<String, MethodDescriptor> descMap = descToMethods.computeIfAbsent(methodName, k -> new HashMap<>());\n-            methodList.forEach(methodModel -> descMap.put(methodModel.getParamDesc(), methodModel));\n+            // not support BI_STREAM and SERVER_STREAM at the same time, for example,\n+            // void foo(Request, StreamObserver<Response>)  ---> SERVER_STREAM\n+            // StreamObserver<Response> foo(StreamObserver<Request>)   ---> BI_STREAM\n+            long streamMethodCount =  methodList.stream()\n+                .peek(methodModel -> descMap.put(methodModel.getParamDesc(), methodModel))\n+                .map(MethodDescriptor::getRpcType)\n+                .filter(rpcType -> rpcType == MethodDescriptor.RpcType.SERVER_STREAM\n+                    || rpcType == MethodDescriptor.RpcType.BI_STREAM)\n+                .count();\n+            if (streamMethodCount > 1L)\n+                throw new IllegalStateException(\"Stream method could not be overloaded.There are \" + streamMethodCount\n+                    +\" stream method signatures. method(\" + methodName + \")\");\n         });\n     }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptorTest.java b/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptorTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptorTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptorTest.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.metadata.definition.TypeDefinitionBuilder;\n import org.apache.dubbo.rpc.support.DemoService;\n+import org.apache.dubbo.rpc.support.DemoService1;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import org.mockito.Mockito;\n@@ -42,6 +43,16 @@ void addMethod() {\n         Assertions.assertEquals(1, service2.getMethods(\"sayHello2\").size());\n     }\n+    @Test\n+    void testStreamRpcTypeException() {\n+        try {\n+            new ReflectionServiceDescriptor(DemoService1.class);\n+        } catch (IllegalStateException e) {\n+            Assertions.assertTrue(e.getMessage()\n+                .contains(\"Stream method could not be overloaded.\"));\n+        }\n+    }\n+\n     @Test\n     void getFullServiceDefinition() {\n         TypeDefinitionBuilder.initBuilders(new FrameworkModel());\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/rpc/support/DemoService1.java b/dubbo-common/src/test/java/org/apache/dubbo/rpc/support/DemoService1.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/rpc/support/DemoService1.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/rpc/support/DemoService1.java\n@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.support;\n+\n+import org.apache.dubbo.common.stream.StreamObserver;\n+\n+public interface DemoService1 {\n+    StreamObserver<String> sayHello(StreamObserver<String> request);\n+\n+    void sayHello(String msg, StreamObserver<String> request);\n+}\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/rpc/support/DemoService1Impl.java b/dubbo-common/src/test/java/org/apache/dubbo/rpc/support/DemoService1Impl.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/rpc/support/DemoService1Impl.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/rpc/support/DemoService1Impl.java\n@@ -0,0 +1,34 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.support;\n+\n+import org.apache.dubbo.common.stream.StreamObserver;\n+\n+public class DemoService1Impl implements DemoService1{\n+    @Override\n+    public StreamObserver<String> sayHello(StreamObserver<String> request) {\n+        request.onNext(\"BI_STREAM\");\n+        return request;\n+    }\n+\n+    @Override\n+    public void sayHello(String msg, StreamObserver<String> request) {\n+        request.onNext(msg);\n+        request.onNext(\"SERVER_STREAM\");\n+        request.onCompleted();\n+    }\n+}",
    "output": "Fix onnext callback method would be invalid when the provider method with triple protocol is overloaded. * For the same method, rpcType.BI_STREAM and rpcType.SERVER_STREAM cannot exist at the same time. * remove unused imported item. * add exception test. * add licence comment. ---------"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/PortUnificationServerTest.java b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/PortUnificationServerTest.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/PortUnificationServerTest.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/PortUnificationServerTest.java\n@@ -30,6 +30,7 @@\n import org.junit.jupiter.api.Test;\n import static org.apache.dubbo.common.constants.CommonConstants.EXECUTOR_MANAGEMENT_MODE_DEFAULT;\n+import static org.apache.dubbo.common.constants.CommonConstants.EXT_PROTOCOL;\n class PortUnificationServerTest {",
    "output": "Fix conflicts"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java\n@@ -67,7 +67,7 @@ public void startServer() throws RemotingException {\n         ReplierDispatcher dispatcher = new ReplierDispatcher();\n         dispatcher.addReplier(RpcMessage.class, new RpcMessageHandler());\n         dispatcher.addReplier(Data.class, (channel, msg) -> new StringMessage(\"hello world\"));\n-        URL url = URL.valueOf(\"exchange://localhost:\" + port + \"?\" + CommonConstants.TIMEOUT_KEY + \"=60000\");\n+        URL url = URL.valueOf(\"exchange://localhost:\" + port + \"?\" + CommonConstants.TIMEOUT_KEY + \"=60000&threadpool=cached\");\n         ApplicationModel applicationModel = ApplicationModel.defaultModel();\n         ApplicationConfig applicationConfig = new ApplicationConfig(\"provider-app\");\n         applicationConfig.setExecutorManagementMode(EXECUTOR_MANAGEMENT_MODE_DEFAULT);",
    "output": "Fix ReplierDispatcherTest test case in Windows platform"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java\n@@ -109,7 +109,7 @@ void testMultiThread() throws Exception {\n                 try {\n                     clientExchangeInfo(port);\n                 } catch (Exception e) {\n-                    fail();\n+                    fail(e);\n                 }\n             }));\n         for (Future<?> future : futureList) {\n@@ -120,7 +120,7 @@ void testMultiThread() throws Exception {\n     }\n     void clientExchangeInfo(int port) throws Exception {\n-        ExchangeChannel client = Exchangers.connect(URL.valueOf(\"exchange://localhost:\" + port + \"?\" + CommonConstants.TIMEOUT_KEY + \"=5000\"));\n+        ExchangeChannel client = Exchangers.connect(URL.valueOf(\"exchange://localhost:\" + port + \"?\" + CommonConstants.TIMEOUT_KEY + \"=60000\"));\n         clients.put(Thread.currentThread().getName(), client);\n         MockResult result = (MockResult) client.request(new RpcMessage(DemoService.class.getName(), \"plus\", new Class<?>[]{int.class, int.class}, new Object[]{55, 25})).get();\n         Assertions.assertEquals(result.getResult(), 80);",
    "output": "Upgrade ReplierDispatcherTest test case"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ReferenceCountInvokerWrapper.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ReferenceCountInvokerWrapper.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ReferenceCountInvokerWrapper.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ReferenceCountInvokerWrapper.java\n@@ -66,7 +66,14 @@ public void destroy() {\n         } catch (InterruptedException e) {\n             Thread.currentThread().interrupt();\n         } finally {\n-            lock.writeLock().unlock();\n+            try {\n+                lock.writeLock().unlock();\n+            } catch (IllegalMonitorStateException ignore) {\n+                // ignore if lock failed, maybe in a long invoke\n+            } catch (Throwable t) {\n+                logger.warn(LoggerCodeConstants.PROTOCOL_CLOSED_SERVER, \"\", \"\",\n+                    \"Unexpected error occurred when releasing write lock, cause: \" + t.getMessage(), t);\n+            }\n         }\n         invoker.destroy();\n     }",
    "output": "Fix invoker ignored to destroy when unlock failed * Fix invoker ignored to destroy when unlock failed * update code"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2FactoryManager.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2FactoryManager.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2FactoryManager.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2FactoryManager.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.common.serialize.hessian2;\n+import org.apache.dubbo.common.utils.ConcurrentHashMapUtils;\n import org.apache.dubbo.common.utils.DefaultSerializeClassChecker;\n import org.apache.dubbo.common.utils.SerializeCheckStatus;\n import org.apache.dubbo.common.utils.SerializeSecurityManager;\n@@ -24,7 +25,6 @@\n import com.alibaba.com.caucho.hessian.io.SerializerFactory;\n-import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -34,7 +34,7 @@ public class Hessian2FactoryManager {\n     String DENY = \"dubbo.application.hessian2.deny\";\n     private volatile SerializerFactory SYSTEM_SERIALIZER_FACTORY;\n     private volatile SerializerFactory stickySerializerFactory = null;\n-    private final Map<ClassLoader, SerializerFactory> CL_2_SERIALIZER_FACTORY = new ConcurrentHashMap<>();\n+    private final ConcurrentHashMap<ClassLoader, SerializerFactory> CL_2_SERIALIZER_FACTORY = new ConcurrentHashMap<>();\n     private final SerializeSecurityManager serializeSecurityManager;\n     private final DefaultSerializeClassChecker defaultSerializeClassChecker;\n@@ -55,47 +55,38 @@ public SerializerFactory getSerializerFactory(ClassLoader classLoader) {\n             if (SYSTEM_SERIALIZER_FACTORY == null) {\n                 synchronized (this) {\n                     if (SYSTEM_SERIALIZER_FACTORY == null) {\n-                        SYSTEM_SERIALIZER_FACTORY = createSerializerFactory();\n+                        SYSTEM_SERIALIZER_FACTORY = createSerializerFactory(null);\n                     }\n                 }\n             }\n             stickySerializerFactory = SYSTEM_SERIALIZER_FACTORY;\n             return SYSTEM_SERIALIZER_FACTORY;\n         }\n-        SerializerFactory factory = CL_2_SERIALIZER_FACTORY.get(classLoader);\n-        if (factory == null) {\n-            synchronized (this) {\n-                if (!CL_2_SERIALIZER_FACTORY.containsKey(classLoader)) {\n-                    SerializerFactory serializerFactory = createSerializerFactory();\n-                    CL_2_SERIALIZER_FACTORY.put(classLoader, serializerFactory);\n-                    stickySerializerFactory = serializerFactory;\n-                    return serializerFactory;\n-                }\n-            }\n-        }\n+        SerializerFactory factory = ConcurrentHashMapUtils.computeIfAbsent(CL_2_SERIALIZER_FACTORY,\n+            classLoader, this::createSerializerFactory);\n         stickySerializerFactory = factory;\n         return factory;\n     }\n-    private SerializerFactory createSerializerFactory() {\n+    private SerializerFactory createSerializerFactory(ClassLoader classLoader) {\n         String whitelist = System.getProperty(WHITELIST);\n         if (StringUtils.isNotEmpty(whitelist)) {\n-            return createWhiteListSerializerFactory();\n+            return createWhiteListSerializerFactory(classLoader);\n         }\n-        return createDefaultSerializerFactory();\n+        return createDefaultSerializerFactory(classLoader);\n     }\n-    private SerializerFactory createDefaultSerializerFactory() {\n-        Hessian2SerializerFactory hessian2SerializerFactory = new Hessian2SerializerFactory(defaultSerializeClassChecker);\n+    private SerializerFactory createDefaultSerializerFactory(ClassLoader classLoader) {\n+        Hessian2SerializerFactory hessian2SerializerFactory = new Hessian2SerializerFactory(classLoader, defaultSerializeClassChecker);\n         hessian2SerializerFactory.setAllowNonSerializable(Boolean.parseBoolean(System.getProperty(\"dubbo.hessian.allowNonSerializable\", \"false\")));\n         hessian2SerializerFactory.getClassFactory().allow(\"org.apache.dubbo.*\");\n         return hessian2SerializerFactory;\n     }\n-    public SerializerFactory createWhiteListSerializerFactory() {\n-        SerializerFactory serializerFactory = new Hessian2SerializerFactory(defaultSerializeClassChecker);\n+    public SerializerFactory createWhiteListSerializerFactory(ClassLoader classLoader) {\n+        SerializerFactory serializerFactory = new Hessian2SerializerFactory(classLoader, defaultSerializeClassChecker);\n         String whiteList = System.getProperty(WHITELIST);\n         if (\"true\".equals(whiteList)) {\n             serializerFactory.getClassFactory().setWhitelist(true);\ndiff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n@@ -30,7 +30,9 @@ public class Hessian2SerializerFactory extends SerializerFactory {\n     private final DefaultSerializeClassChecker defaultSerializeClassChecker;\n-    public Hessian2SerializerFactory(DefaultSerializeClassChecker defaultSerializeClassChecker) {\n+\n+    public Hessian2SerializerFactory(ClassLoader classLoader, DefaultSerializeClassChecker defaultSerializeClassChecker) {\n+        super(classLoader);\n         this.defaultSerializeClassChecker = defaultSerializeClassChecker;\n     }",
    "output": "Fix Hessian Serializer Factory concurrent issue"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java\n@@ -92,10 +92,15 @@ public static ClassPool getClassPool(ClassLoader loader) {\n         ClassPool pool = POOL_MAP.get(loader);\n         if (pool == null) {\n-            pool = new ClassPool(true);\n-            pool.insertClassPath(new LoaderClassPath(loader));\n-            pool.insertClassPath(new DubboLoaderClassPath());\n-            POOL_MAP.put(loader, pool);\n+            synchronized (POOL_MAP) {\n+                pool = POOL_MAP.get(loader);\n+                if (pool == null) {\n+                    pool = new ClassPool(true);\n+                    pool.insertClassPath(new LoaderClassPath(loader));\n+                    pool.insertClassPath(new DubboLoaderClassPath());\n+                    POOL_MAP.put(loader, pool);\n+                }\n+            }\n         }\n         return pool;\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n@@ -22,8 +22,6 @@\n import javassist.ClassPool;\n import javassist.CtMethod;\n-import javassist.LoaderClassPath;\n-\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n@@ -158,9 +156,7 @@ private static Wrapper makeWrapper(Class<?> c) {\n             pts.put(fn, ft);\n         }\n-        final ClassPool classPool = new ClassPool(ClassPool.getDefault());\n-        classPool.insertClassPath(new LoaderClassPath(cl));\n-        classPool.insertClassPath(new DubboLoaderClassPath());\n+        final ClassPool classPool = ClassGenerator.getClassPool(cl);\n         List<String> allMethod = new ArrayList<>();\n         try {\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/ClassGeneratorTest.java\n@@ -16,13 +16,17 @@\n  */\n package org.apache.dubbo.common.bytecode;\n+import javassist.ClassPool;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n interface Builder<T> {\n     T getName(Bean bean);\n@@ -197,6 +201,35 @@ void testMain0() throws Exception {\n         builder.setName(b, \"ok\");\n         System.out.println(b.getName());\n     }\n+\n+    @Test\n+    public void test_getClassPool() throws InterruptedException {\n+        int threadCount = 5;\n+        CountDownLatch LATCH = new CountDownLatch(threadCount);\n+        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+        List<Integer> hashCodeList = new ArrayList<>();\n+        for (int i = 0; i < threadCount; i++) {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ClassPool classPool = ClassGenerator.getClassPool(loader);\n+                    int currentHashCode = classPool.hashCode();\n+                    hashCodeList.add(currentHashCode);\n+                    System.out.println(currentHashCode);\n+                    LATCH.countDown();\n+                }\n+            }).start();\n+        }\n+        LATCH.await();\n+        Integer firstHashCode = null;\n+        for (Integer currentHashCode : hashCodeList) {\n+            if (firstHashCode == null) {\n+                firstHashCode = currentHashCode;\n+                continue;\n+            }\n+            Assertions.assertTrue(firstHashCode.intValue() == currentHashCode.intValue());\n+        }\n+    }\n }\n class Bean {",
    "output": "Fix ClassPool issue when multi-classloader"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/param/DynamicParamTable.java b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/param/DynamicParamTable.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/param/DynamicParamTable.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/param/DynamicParamTable.java\n@@ -18,7 +18,6 @@\n import org.apache.dubbo.rpc.model.FrameworkModel;\n-import java.util.Arrays;\n import java.util.Comparator;\n import java.util.HashMap;\n import java.util.LinkedList;\n@@ -31,10 +30,6 @@\n  * Not support method parameters\n  */\n public final class DynamicParamTable {\n-    /**\n-     * Keys array, value is key's identity hashcode ( assume key is in constant pool )\n-     */\n-    private static int[] KEYS;\n     /**\n      * Keys array, value is string\n      */\n@@ -54,13 +49,6 @@ public static int getKeyIndex(boolean enabled, String key) {\n         if (!enabled) {\n             return -1;\n         }\n-        // assume key is in constant pool\n-        int identityHashCode = System.identityHashCode(key);\n-        int index = Arrays.binarySearch(KEYS, identityHashCode);\n-        if (index >= 0) {\n-            return index;\n-        }\n-        // fallback to key2index map\n         Integer indexFromMap = KEY2INDEX.get(key);\n         return indexFromMap == null ? -1 : indexFromMap;\n     }\n@@ -97,13 +85,6 @@ private static void init() {\n             resultMap.put(keys.get(i), values.get(i));\n         }\n-        // assume key is in constant pool, store identity hashCode as index\n-        KEYS = resultMap.keySet()\n-            .stream()\n-            .map(System::identityHashCode)\n-            .mapToInt(x -> x)\n-            .toArray();\n-\n         ORIGIN_KEYS = resultMap.keySet().toArray(new String[0]);\n         VALUES = resultMap.values().toArray(new ParamValue[0]);\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/listener/AbstractMetricsListener.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/listener/AbstractMetricsListener.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/listener/AbstractMetricsListener.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/listener/AbstractMetricsListener.java\n@@ -25,17 +25,14 @@\n public abstract class AbstractMetricsListener<E extends MetricsEvent> implements MetricsListener<E> {\n-    private final Map<Integer, Boolean> eventMatchCache = new ConcurrentHashMap<>();\n+    private final Map<Class<?>, Boolean> eventMatchCache = new ConcurrentHashMap<>();\n     /**\n-     * Only interested in events of the current listener's generic parameter type\n+     * Whether to support the general determination of event points depends on the event type\n      */\n     public boolean isSupport(MetricsEvent event) {\n-        Boolean eventMatch = eventMatchCache.get(System.identityHashCode(event.getClass()));\n-        if (eventMatch == null) {\n-            eventMatch = ReflectionUtils.match(getClass(), AbstractMetricsListener.class, event);\n-            eventMatchCache.put(System.identityHashCode(event.getClass()), eventMatch);\n-        }\n+        Boolean eventMatch = eventMatchCache.computeIfAbsent(event.getClass(),\n+            clazz -> ReflectionUtils.match(getClass(), AbstractMetricsListener.class, event));\n         return event.isAvailable() && eventMatch;\n     }",
    "output": "Remove identity hash code usage"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java\n@@ -158,9 +158,10 @@ public Object decode(Channel channel, InputStream input) throws IOException {\n                 pts = drawPts(path, version, desc, pts);\n                 if (pts == DubboCodec.EMPTY_CLASS_ARRAY) {\n                     if (RpcUtils.isGenericCall(desc, getMethodName())) {\n-                        pts = DubboCodec.GENERIC_PTS_ARRAY;\n+                        // Should recreate here for each invocation because the parameterTypes may be changed by user.\n+                        pts = new Class<?>[]{String.class, String[].class, Object[].class};\n                     } else if (RpcUtils.isEcho(desc, getMethodName())) {\n-                        pts = DubboCodec.ECHO_PTS_ARRAY;\n+                        pts = new Class<?>[]{Object.class};\n                     } else {\n                         throw new IllegalArgumentException(\"Service not found:\" + path + \", \" + getMethodName());\n                     }\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n@@ -69,8 +69,6 @@ public class DubboCodec extends ExchangeCodec {\n     public static final byte RESPONSE_NULL_VALUE_WITH_ATTACHMENTS = 5;\n     public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n     public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];\n-    public static final Class<?>[] GENERIC_PTS_ARRAY = new Class<?>[]{String.class, String[].class, Object[].class};\n-    public static final Class<?>[] ECHO_PTS_ARRAY = new Class<?>[]{Object.class};\n     private static final ErrorTypeAwareLogger log = LoggerFactory.getErrorTypeAwareLogger(DubboCodec.class);\n     private static final AtomicBoolean decodeInUserThreadLogged = new AtomicBoolean(false);",
    "output": "Fix generic array being changed"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java\n@@ -277,7 +277,7 @@ private static <V extends Object> Map<String, V> getSubProperties(Map<String, V>\n             for (Map.Entry<String, V> entry : copy.entrySet()) {\n                 String key = entry.getKey();\n                 V val = entry.getValue();\n-                if (StringUtils.startsWithIgnoreCase(key, prefix)\n+                if ((StringUtils.startsWithIgnoreCase(key, prefix) || StringUtils.startsWithIgnoreCase(key, StringUtils.toOSStyleKey(prefix)))\n                     && key.length() > prefix.length()\n                     && !ConfigurationUtils.isEmptyValue(val)) {\n@@ -317,7 +317,7 @@ public static <V extends Object> boolean hasSubProperties(Map<String, V> configM\n         }\n         for (Map.Entry<String, V> entry : copy.entrySet()) {\n             String key = entry.getKey();\n-            if (StringUtils.startsWithIgnoreCase(key, prefix)\n+            if ((StringUtils.startsWithIgnoreCase(key, prefix) || StringUtils.startsWithIgnoreCase(key, StringUtils.toOSStyleKey(prefix)))\n                 && key.length() > prefix.length()\n                 && !ConfigurationUtils.isEmptyValue(entry.getValue())) {\n                 return true;\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -187,7 +187,7 @@ private void unRegisterShutdownHook() {\n      * by default is false.\n      */\n     private boolean isRegisterConsumerInstance() {\n-        Boolean registerConsumer = getApplication().getRegisterConsumer();\n+        Boolean registerConsumer = getApplicationOrElseThrow().getRegisterConsumer();\n         if (registerConsumer == null) {\n             return false;\n         }\n@@ -310,7 +310,7 @@ private void startMetadataCenter() {\n         useRegistryAsMetadataCenterIfNecessary();\n-        ApplicationConfig applicationConfig = getApplication();\n+        ApplicationConfig applicationConfig = getApplicationOrElseThrow();\n         String metadataType = applicationConfig.getMetadataType();\n         // FIXME, multiple metadata config support.\n@@ -858,14 +858,18 @@ private DynamicConfiguration prepareEnvironment(ConfigCenterConfig configCenter)\n                 if (StringUtils.isNotEmpty(configContent)) {\n                     logger.info(String.format(\"Got global remote configuration from config center with key-%s and group-%s: \\n %s\", configCenter.getConfigFile(), configCenter.getGroup(), configContent));\n                 }\n-                String appGroup = getApplication().getName();\n+                String appGroup = \"\";\n                 String appConfigContent = null;\n                 String appConfigFile = null;\n-                if (isNotEmpty(appGroup)) {\n-                    appConfigFile = isNotEmpty(configCenter.getAppConfigFile()) ? configCenter.getAppConfigFile() : configCenter.getConfigFile();\n-                    appConfigContent = dynamicConfiguration.getProperties(appConfigFile, appGroup);\n-                    if (StringUtils.isNotEmpty(appConfigContent)) {\n-                        logger.info(String.format(\"Got application specific remote configuration from config center with key %s and group %s: \\n %s\", appConfigFile, appGroup, appConfigContent));\n+                Optional<ApplicationConfig> applicationOptional = getApplication();\n+                if (applicationOptional.isPresent()) {\n+                    appGroup = applicationOptional.get().getName();\n+                    if (isNotEmpty(appGroup)) {\n+                        appConfigFile = isNotEmpty(configCenter.getAppConfigFile()) ? configCenter.getAppConfigFile() : configCenter.getConfigFile();\n+                        appConfigContent = dynamicConfiguration.getProperties(appConfigFile, appGroup);\n+                        if (StringUtils.isNotEmpty(appConfigContent)) {\n+                            logger.info(String.format(\"Got application specific remote configuration from config center with key %s and group %s: \\n %s\", appConfigFile, appGroup, appConfigContent));\n+                        }\n                     }\n                 }\n                 try {\n@@ -1322,9 +1326,12 @@ private void destroyMetadataReports() {\n         }\n     }\n-    private ApplicationConfig getApplication() {\n+    private ApplicationConfig getApplicationOrElseThrow() {\n         return configManager.getApplicationOrElseThrow();\n     }\n+    private Optional<ApplicationConfig> getApplication() {\n+        return configManager.getApplication();\n+    }\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -917,7 +917,7 @@ private class ProviderConfigurationListener extends AbstractConfiguratorListener\n         public ProviderConfigurationListener(ModuleModel moduleModel) {\n             super(moduleModel);\n             this.moduleModel = moduleModel;\n-            if (moduleModel.modelEnvironment().getConfiguration().convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)) {\n+            if (moduleModel.modelEnvironment().getConfiguration().getBoolean(ENABLE_CONFIGURATION_LISTEN, true)) {\n                 this.initWith(moduleModel.getApplicationModel().getApplicationName() + CONFIGURATORS_SUFFIX);\n             }\n         }\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/NoAnnotationRestProtocolTest.java b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/NoAnnotationRestProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/NoAnnotationRestProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/NoAnnotationRestProtocolTest.java\n@@ -21,7 +21,6 @@\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.utils.JsonUtils;\n import org.apache.dubbo.common.utils.NetUtils;\n-\n import org.apache.dubbo.rpc.Exporter;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Protocol;\n@@ -31,13 +30,11 @@\n import org.apache.dubbo.rpc.model.ModuleServiceRepository;\n import org.apache.dubbo.rpc.model.ProviderModel;\n import org.apache.dubbo.rpc.model.ServiceDescriptor;\n-\n import org.apache.dubbo.rpc.protocol.rest.noannotation.NoAnnotationDemoService;\n import org.apache.dubbo.rpc.protocol.rest.noannotation.NoAnnotationDemoServiceImpl;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n-\n import org.junit.jupiter.api.Test;\n import java.util.Arrays;\n@@ -53,6 +50,12 @@ class NoAnnotationRestProtocolTest {\n     public void tearDown() {\n         protocol.destroy();\n         FrameworkModel.destroyAll();\n+        new JsonUtils() {\n+            public void clearJson() {\n+                setJson(null);\n+            }\n+        }.clearJson();\n+        System.clearProperty(CommonConstants.PREFER_JSON_FRAMEWORK_NAME);\n     }\n     @Test",
    "output": "Fix loading process cannot load environment variables"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/SlidingWindowTest.java b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/SlidingWindowTest.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/SlidingWindowTest.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/SlidingWindowTest.java\n@@ -18,6 +18,7 @@\n package org.apache.dubbo.metrics.aggregate;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.RepeatedTest;\n import org.junit.jupiter.api.Test;\n import java.util.concurrent.atomic.LongAdder;\n@@ -40,15 +41,15 @@ void setup() {\n         window = new TestSlidingWindow(paneCount, intervalInMs);\n     }\n-    @Test\n+    @RepeatedTest(1000)\n     void testCurrentPane() {\n         assertNull(window.currentPane(/* invalid time*/-1L));\n         long timeInMs = System.currentTimeMillis();\n         Pane<LongAdder> currentPane = window.currentPane(timeInMs);\n         assertNotNull(currentPane);\n         // reuse test\n         assertEquals(currentPane,\n-            window.currentPane(1 + timeInMs + window.getPaneIntervalInMs() * paneCount));\n+            window.currentPane(timeInMs + window.getPaneIntervalInMs() * paneCount));\n     }\n     @Test",
    "output": "Fix uts on 3.2"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n@@ -151,34 +151,37 @@ private void dumpJStack() {\n         }\n         ExecutorService pool = Executors.newSingleThreadExecutor();\n-        pool.execute(() -> {\n-            String dumpPath = getDumpPath();\n-\n-            SimpleDateFormat sdf;\n-\n-            String os = System.getProperty(OS_NAME_KEY).toLowerCase();\n-\n-            // window system don't support \":\" in file name\n-            if (os.contains(OS_WIN_PREFIX)) {\n-                sdf = new SimpleDateFormat(WIN_DATETIME_FORMAT);\n-            } else {\n-                sdf = new SimpleDateFormat(DEFAULT_DATETIME_FORMAT);\n-            }\n-\n-            String dateStr = sdf.format(new Date());\n-            //try-with-resources\n-            try (FileOutputStream jStackStream = new FileOutputStream(\n-                new File(dumpPath, \"Dubbo_JStack.log\" + \".\" + dateStr))) {\n-                jstack(jStackStream);\n-            } catch (Exception t) {\n-                logger.error(COMMON_UNEXPECTED_CREATE_DUMP, \"\", \"\", \"dump jStack error\", t);\n-            } finally {\n-                lastPrintTime = System.currentTimeMillis();\n-                guard.release();\n-            }\n-        });\n-        //must shutdown thread pool ,if not will lead to OOM\n-        pool.shutdown();\n+        try {\n+            pool.execute(() -> {\n+                String dumpPath = getDumpPath();\n+\n+                SimpleDateFormat sdf;\n+\n+                String os = System.getProperty(OS_NAME_KEY).toLowerCase();\n+\n+                // window system don't support \":\" in file name\n+                if (os.contains(OS_WIN_PREFIX)) {\n+                    sdf = new SimpleDateFormat(WIN_DATETIME_FORMAT);\n+                } else {\n+                    sdf = new SimpleDateFormat(DEFAULT_DATETIME_FORMAT);\n+                }\n+\n+                String dateStr = sdf.format(new Date());\n+                //try-with-resources\n+                try (FileOutputStream jStackStream = new FileOutputStream(\n+                    new File(dumpPath, \"Dubbo_JStack.log\" + \".\" + dateStr))) {\n+                    jstack(jStackStream);\n+                } catch (Exception t) {\n+                    logger.error(COMMON_UNEXPECTED_CREATE_DUMP, \"\", \"\", \"dump jStack error\", t);\n+                } finally {\n+                    lastPrintTime = System.currentTimeMillis();\n+                    guard.release();\n+                }\n+            });\n+        } finally {\n+            //must shutdown thread pool ,if not will lead to OOM\n+            pool.shutdown();\n+        }\n     }",
    "output": "Fix code style"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/NoAnnotationRestProtocolTest.java b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/NoAnnotationRestProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/NoAnnotationRestProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/NoAnnotationRestProtocolTest.java\n@@ -21,7 +21,6 @@\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.utils.JsonUtils;\n import org.apache.dubbo.common.utils.NetUtils;\n-\n import org.apache.dubbo.rpc.Exporter;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Protocol;\n@@ -31,13 +30,11 @@\n import org.apache.dubbo.rpc.model.ModuleServiceRepository;\n import org.apache.dubbo.rpc.model.ProviderModel;\n import org.apache.dubbo.rpc.model.ServiceDescriptor;\n-\n import org.apache.dubbo.rpc.protocol.rest.noannotation.NoAnnotationDemoService;\n import org.apache.dubbo.rpc.protocol.rest.noannotation.NoAnnotationDemoServiceImpl;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n-\n import org.junit.jupiter.api.Test;\n import java.util.Arrays;\n@@ -53,6 +50,12 @@ class NoAnnotationRestProtocolTest {\n     public void tearDown() {\n         protocol.destroy();\n         FrameworkModel.destroyAll();\n+        new JsonUtils() {\n+            public void clearJson() {\n+                setJson(null);\n+            }\n+        }.clearJson();\n+        System.clearProperty(CommonConstants.PREFER_JSON_FRAMEWORK_NAME);\n     }\n     @Test",
    "output": "Fix uts on 3.3"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n@@ -229,6 +229,9 @@ public final void onMessage(byte[] message, boolean isReturnTriException) {\n     @Override\n     public final void onCancelByRemote(TriRpcStatus status) {\n         closed = true;\n+        if (listener == null) {\n+            return;\n+        }\n         cancellationContext.cancel(status.cause);\n         listener.onCancel(status);\n     }",
    "output": "Fix concurrency problem when receive ResetFrame and HeadFrame"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java\n@@ -87,7 +87,7 @@ public abstract class AbstractInvoker<T> implements Invoker<T> {\n     /**\n      * {@link Node} destroy\n      */\n-    private boolean destroyed = false;\n+    private volatile boolean destroyed = false;\n     /**\n      * Whether set future to Thread Local when invocation mode is sync",
    "output": "Add volatile on destroyed filed ensure visibility"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/TimeWindowCounter.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/TimeWindowCounter.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/TimeWindowCounter.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/TimeWindowCounter.java\n@@ -28,7 +28,7 @@ public class TimeWindowCounter {\n     private final LongAdderSlidingWindow slidingWindow;\n-    public TimeWindowCounter(int bucketNum, int timeWindowSeconds) {\n+    public TimeWindowCounter(int bucketNum, long timeWindowSeconds) {\n         this.slidingWindow = new LongAdderSlidingWindow(bucketNum, TimeUnit.SECONDS.toMillis(timeWindowSeconds));\n     }\ndiff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n@@ -43,6 +43,7 @@\n import java.util.Optional;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n@@ -127,7 +128,7 @@ public void onEvent(RequestEvent event) {\n         if (enableQps) {\n             MethodMetric metric = calcWindowCounter(event, MetricsKey.METRIC_REQUESTS);\n             TimeWindowCounter qpsCounter = ConcurrentHashMapUtils.computeIfAbsent(qps, metric,\n-                methodMetric -> new TimeWindowCounter(bucketNum, qpsTimeWindowMillSeconds));\n+                methodMetric -> new TimeWindowCounter(bucketNum, TimeUnit.MILLISECONDS.toSeconds(qpsTimeWindowMillSeconds)));\n             qpsCounter.increment();\n         }\n     }",
    "output": "Fix qps time window unit"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java\n@@ -21,10 +21,10 @@\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcContext;\n+import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.cluster.Directory;\n import org.apache.dubbo.rpc.cluster.filter.DemoService;\n-import org.apache.dubbo.rpc.RpcException;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n@@ -56,6 +56,7 @@ class FailSafeClusterInvokerTest {\n     @BeforeEach\n     public void setUp() throws Exception {\n+        RpcContext.removeServiceContext();\n         dic = mock(Directory.class);\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvokerTest.java\n@@ -24,10 +24,10 @@\n import org.apache.dubbo.rpc.AppResponse;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n-import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.RpcContext;\n-import org.apache.dubbo.rpc.cluster.Directory;\n import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.RpcInvocation;\n+import org.apache.dubbo.rpc.cluster.Directory;\n import org.apache.log4j.Level;\n import org.junit.jupiter.api.AfterEach;\n@@ -38,7 +38,6 @@\n import org.junit.jupiter.api.Order;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.TestMethodOrder;\n-import org.junit.jupiter.api.function.Executable;\n import java.lang.reflect.Field;\n import java.util.ArrayList;\n@@ -47,7 +46,7 @@\n import java.util.concurrent.TimeUnit;\n import static org.apache.dubbo.common.constants.CommonConstants.RETRIES_KEY;\n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.mockito.BDDMockito.given;\n import static org.mockito.Mockito.mock;\n@@ -72,6 +71,7 @@ class FailbackClusterInvokerTest {\n     @BeforeEach\n     public void setUp() throws Exception {\n+        RpcContext.removeServiceContext();\n         dic = mock(Directory.class);\n         given(dic.getUrl()).willReturn(url);",
    "output": "Fix unit test cases"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/aot/QosReflectionTypeDescriberRegistrar.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/aot/QosReflectionTypeDescriberRegistrar.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/aot/QosReflectionTypeDescriberRegistrar.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/aot/QosReflectionTypeDescriberRegistrar.java\n@@ -19,6 +19,9 @@\n import org.apache.dubbo.aot.api.MemberCategory;\n import org.apache.dubbo.aot.api.ReflectionTypeDescriberRegistrar;\n import org.apache.dubbo.aot.api.TypeDescriber;\n+import org.apache.dubbo.qos.server.handler.ForeignHostPermitHandler;\n+import org.apache.dubbo.qos.server.handler.QosProcessHandler;\n+import org.apache.dubbo.qos.server.handler.TelnetIdleEventHandler;\n import java.nio.channels.spi.SelectorProvider;\n import java.util.ArrayList;\n@@ -33,6 +36,9 @@ public class QosReflectionTypeDescriberRegistrar implements ReflectionTypeDescri\n     public List<TypeDescriber> getTypeDescribers() {\n         List<TypeDescriber> typeDescribers = new ArrayList<>();\n         typeDescribers.add(buildTypeDescriberWithPublicMethod(SelectorProvider.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(ForeignHostPermitHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(QosProcessHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(TelnetIdleEventHandler.class));\n         return typeDescribers;\n     }",
    "output": "Upgrade qos native-image reflect config"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n@@ -145,6 +145,10 @@ private void dumpJStack() {\n         if (!guard.tryAcquire()) {\n             return;\n         }\n+        // To avoid multiple dump, check again\n+        if (System.currentTimeMillis() - lastPrintTime < TEN_MINUTES_MILLS) {\n+            return;\n+        }\n         ExecutorService pool = Executors.newSingleThreadExecutor();\n         pool.execute(() -> {\n@@ -169,9 +173,9 @@ private void dumpJStack() {\n             } catch (Exception t) {\n                 logger.error(COMMON_UNEXPECTED_CREATE_DUMP, \"\", \"\", \"dump jStack error\", t);\n             } finally {\n+                lastPrintTime = System.currentTimeMillis();\n                 guard.release();\n             }\n-            lastPrintTime = System.currentTimeMillis();\n         });\n         //must shutdown thread pool ,if not will lead to OOM\n         pool.shutdown();",
    "output": "Fix AbortPolicyWithReport concurrency issues https://github.com/apache/dubbo/issues/13042"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/EmptyEvent.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/EmptyEvent.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/EmptyEvent.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/EmptyEvent.java\n@@ -1,36 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.dubbo.metrics.event;\n-\n-import org.apache.dubbo.rpc.model.ApplicationModel;\n-\n-/**\n- * EmptyEvent, do nothing.\n- */\n-public class EmptyEvent extends MetricsEvent {\n-\n-    private static final EmptyEvent empty = new EmptyEvent(null);\n-\n-    private EmptyEvent(ApplicationModel source) {\n-        super(source, null);\n-    }\n-\n-    public static EmptyEvent instance() {\n-        return empty;\n-    }\n-}\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/SimpleMetricsEventMulticaster.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/SimpleMetricsEventMulticaster.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/SimpleMetricsEventMulticaster.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/SimpleMetricsEventMulticaster.java\n@@ -40,10 +40,6 @@ public void addListener(MetricsListener<?> listener) {\n     @Override\n     @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n     public void publishEvent(MetricsEvent event) {\n-        if (event instanceof EmptyEvent) {\n-            return;\n-        }\n-\n         if (validateIfApplicationConfigExist(event)) return;\n         for (MetricsListener listener : listeners) {\n             if (listener.isSupport(event)) {\n@@ -75,9 +71,6 @@ public void publishErrorEvent(TimeCounterEvent event) {\n     @SuppressWarnings({\"rawtypes\"})\n     private void publishTimeEvent(MetricsEvent event, Consumer<MetricsLifeListener> consumer) {\n         if (validateIfApplicationConfigExist(event)) return;\n-        if (event instanceof EmptyEvent) {\n-            return;\n-        }\n         if (event instanceof TimeCounterEvent) {\n             ((TimeCounterEvent) event).getTimePair().end();\n         }\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/event/SimpleMetricsEventMulticasterTest.java b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/event/SimpleMetricsEventMulticasterTest.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/event/SimpleMetricsEventMulticasterTest.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/event/SimpleMetricsEventMulticasterTest.java\n@@ -58,16 +58,6 @@ public void onEvent(MetricsEvent event) {\n     }\n-    @Test\n-    void testPublishEvent() {\n-\n-        // emptyEvent do nothing\n-        MetricsEvent emptyEvent = EmptyEvent.instance();\n-        eventMulticaster.publishEvent(emptyEvent);\n-        Assertions.assertSame(obj, objects[0]);\n-\n-    }\n-\n     @Test\n     void testPublishFinishEvent() {",
    "output": "Remove unuse code"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java\n@@ -276,7 +276,7 @@ private void doSent() {\n     private String getTimeoutMessage(boolean scan) {\n         long nowTimestamp = System.currentTimeMillis();\n-        return (sent > 0 ? \"Waiting server-side response timeout\" : \"Sending request timeout in client-side\")\n+        return (sent > 0 && sent - start < timeout ? \"Waiting server-side response timeout\" : \"Sending request timeout in client-side\")\n             + (scan ? \" by scan timer\" : \"\") + \". start time: \"\n             + (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date(start))) + \", end time: \"\n             + (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date(nowTimestamp))) + \",\"\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java\n@@ -86,6 +86,43 @@ public void timeoutNotSend() throws Exception {\n         }\n     }\n+    /**\n+     * for example, it will print like this:\n+     * before a future is created, time is : 2023-09-03 18:20:14.535\n+     * after a future is timeout, time is : 2023-09-03 18:20:14.669\n+     * <p>\n+     * The exception info print like:\n+     * Sending request timeout in client-side by scan timer.\n+     * start time: 2023-09-03 18:20:14.544, end time: 2023-09-03 18:20:14.598...\n+     */\n+    @Test\n+    public void clientTimeoutSend() throws Exception {\n+        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSS\");\n+        System.out.println(\"before a future is create , time is : \" + LocalDateTime.now().format(formatter));\n+        // timeout after 5 milliseconds.\n+        Channel channel = new MockedChannel();\n+        Request request = new Request(10);\n+        DefaultFuture f = DefaultFuture.newFuture(channel, request, 5, null);\n+        System.gc(); // events such as Full GC will increase the time required to send messages.\n+\n+        // mark the future is sent\n+        DefaultFuture.sent(channel, request);\n+        while (!f.isDone()) {\n+            // spin\n+            Thread.sleep(100);\n+        }\n+        System.out.println(\"after a future is timeout , time is : \" + LocalDateTime.now().format(formatter));\n+\n+        // get operate will throw a timeout exception, because the future is timeout.\n+        try {\n+            f.get();\n+        } catch (Exception e) {\n+            Assertions.assertTrue(e.getCause() instanceof TimeoutException, \"catch exception is not timeout exception!\");\n+            System.out.println(e.getMessage());\n+            Assertions.assertTrue(e.getMessage().startsWith(e.getCause().getClass().getCanonicalName() + \": Sending request timeout in client-side\"));\n+        }\n+    }\n+\n     /**\n      * for example, it will print like this:\n      * before a future is create , time is : 2018-06-21 15:11:31",
    "output": "Fix incorrect timeout message * Fix incorrect timeout message * Remove @Disabled annotation to enable unit test"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -67,7 +67,6 @@\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.locks.ReentrantLock;\n-import java.util.stream.Collectors;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_PACKABLE_METHOD_FACTORY;\n@@ -249,7 +248,7 @@ AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocat\n             if (methodDescriptor.isGeneric()) {\n                 Object[] args = new Object[3];\n                 args[0] = RpcUtils.getMethodName(invocation);\n-                args[1] = Arrays.stream(RpcUtils.getParameterTypes(invocation)).map(Class::getName).collect(Collectors.toList());\n+                args[1] = Arrays.stream(RpcUtils.getParameterTypes(invocation)).map(Class::getName).toArray(String[]::new);\n                 args[2] = RpcUtils.getArguments(invocation);\n                 pureArgument = args;\n             } else {",
    "output": "Fix triple generic invoke"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonCodec.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonCodec.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonCodec.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonCodec.java\n@@ -93,9 +93,6 @@ public Object[] decode(InputStream dataInputStream, Class<?>[] targetTypes) thro\n         List<Object> result = new ArrayList<>();\n         try {\n             try {\n-                if (targetTypes.length == 1) {\n-                    return new Object[]{this.decode(dataInputStream, targetTypes[0])};\n-                }\n                 int len;\n                 byte[] data = new byte[4096];\n                 StringBuilder builder = new StringBuilder(4096);\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonPbCodec.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonPbCodec.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonPbCodec.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonPbCodec.java\n@@ -89,13 +89,30 @@ public Object decode(InputStream body, Class<?> targetType) throws DecodeExcepti\n     @Override\n     public Object[] decode(InputStream dataInputStream, Class<?>[] targetTypes) throws DecodeException {\n+        try {\n+            if (hasProtobuf(targetTypes)) {\n+                //protobuf only support one parameter\n+                return new Object[]{decode(dataInputStream, targetTypes[0])};\n+            }\n+        } catch (Throwable e) {\n+            throw new DecodeException(e);\n+        }\n         return jsonCodec.decode(dataInputStream, targetTypes);\n     }\n-    private boolean isProtobuf(Class<?> targetType) {\n+    private static boolean isProtobuf(Class<?> targetType) {\n         if (targetType == null) {\n             return false;\n         }\n         return Message.class.isAssignableFrom(targetType);\n     }\n+\n+    private static boolean hasProtobuf(Class<?>[] classes){\n+        for (Class<?> clazz : classes) {\n+            if (isProtobuf(clazz)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcCompositeCodec.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcCompositeCodec.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcCompositeCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcCompositeCodec.java\n@@ -27,6 +27,8 @@\n import java.io.InputStream;\n import java.io.OutputStream;\n+import static org.apache.dubbo.common.constants.CommonConstants.PROTOBUF_MESSAGE_CLASS_NAME;\n+\n /**\n  * compatible low version.\n  * version < 3.3\n@@ -64,11 +66,8 @@ public void encode(OutputStream outputStream, Object data) throws EncodeExceptio\n         try {\n             int compressed = 0;\n             outputStream.write(compressed);\n-            if (data instanceof Message) {\n-                int serializedSize = ((Message) data).getSerializedSize();\n-                //write length\n-                writeLength(outputStream, serializedSize);\n-                protobufHttpMessageCodec.encode(outputStream, data);\n+            if (isProtobuf(data)) {\n+                ProtobufWriter.write(protobufHttpMessageCodec, outputStream, data);\n                 return;\n             }\n             //wrapper\n@@ -80,7 +79,7 @@ public void encode(OutputStream outputStream, Object data) throws EncodeExceptio\n     @Override\n     public Object decode(InputStream inputStream, Class<?> targetType) throws DecodeException {\n-        if (isProtobuf(targetType)) {\n+        if (isProtoClass(targetType)) {\n             return protobufHttpMessageCodec.decode(inputStream, targetType);\n         }\n         return wrapperHttpMessageCodec.decode(inputStream, targetType);\n@@ -94,13 +93,6 @@ public Object[] decode(InputStream inputStream, Class<?>[] targetTypes) throws D\n         return HttpMessageCodec.super.decode(inputStream, targetTypes);\n     }\n-    private boolean isProtobuf(Class<?> targetType) {\n-        if (targetType == null) {\n-            return false;\n-        }\n-        return Message.class.isAssignableFrom(targetType);\n-    }\n-\n     private static void writeLength(OutputStream outputStream, int length) {\n         try {\n             outputStream.write(((length >> 24) & 0xFF));\n@@ -121,4 +113,40 @@ public MediaType contentType() {\n     public boolean support(String contentType) {\n         return contentType.startsWith(MEDIA_TYPE.getName());\n     }\n+\n+    private static boolean isProtobuf(Object data) {\n+        if (data == null) {\n+            return false;\n+        }\n+        return isProtoClass(data.getClass());\n+    }\n+\n+    private static boolean isProtoClass(Class<?> clazz) {\n+        while (clazz != Object.class && clazz != null) {\n+            Class<?>[] interfaces = clazz.getInterfaces();\n+            if (interfaces.length > 0) {\n+                for (Class<?> clazzInterface : interfaces) {\n+                    if (PROTOBUF_MESSAGE_CLASS_NAME.equalsIgnoreCase(clazzInterface.getName())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            clazz = clazz.getSuperclass();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * lazy init protobuf class\n+     */\n+    private static class ProtobufWriter {\n+\n+        private static void write(HttpMessageCodec codec, OutputStream outputStream, Object data) {\n+            int serializedSize = ((Message) data).getSerializedSize();\n+            //write length\n+            writeLength(outputStream, serializedSize);\n+            codec.encode(outputStream, data);\n+        }\n+\n+    }\n }",
    "output": "Fix hard dependency on protobuf on pojo mode"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/restclient/HttpClientRestClient.java b/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/restclient/HttpClientRestClient.java\n--- a/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/restclient/HttpClientRestClient.java\n+++ b/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/restclient/HttpClientRestClient.java\n@@ -93,7 +93,8 @@ public CompletableFuture<RestResult> send(RequestTemplate requestTemplate) {\n             future.complete(new RestResult() {\n                 @Override\n                 public String getContentType() {\n-                    return response.getFirstHeader(\"Content-Type\").getValue();\n+                    Header header = response.getFirstHeader(\"Content-Type\");\n+                    return header == null ? null : header.getValue();\n                 }\n                 @Override",
    "output": "Fix rest protocol NPE when using apache-http-client"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonCodec.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonCodec.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonCodec.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/JsonCodec.java\n@@ -17,8 +17,11 @@\n package org.apache.dubbo.remoting.http12.message;\n import com.alibaba.fastjson2.JSONObject;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.common.utils.JsonUtils;\n+import org.apache.dubbo.common.utils.MethodUtils;\n import org.apache.dubbo.remoting.http12.exception.DecodeException;\n import org.apache.dubbo.remoting.http12.exception.EncodeException;\n@@ -45,6 +48,11 @@ public MediaType contentType() {\n     public void encode(OutputStream outputStream, Object unSerializedBody) throws EncodeException {\n         try {\n             try {\n+                if (unSerializedBody instanceof Message) {\n+                    String jsonString = JsonFormat.printer().print((Message) unSerializedBody);\n+                    outputStream.write(jsonString.getBytes(StandardCharsets.UTF_8));\n+                    return;\n+                }\n                 String jsonString = JsonUtils.toJson(unSerializedBody);\n                 outputStream.write(jsonString.getBytes(StandardCharsets.UTF_8));\n             } finally {\n@@ -79,6 +87,11 @@ public Object decode(InputStream body, Class<?> targetType) throws DecodeExcepti\n                 while ((len = body.read(data)) != -1) {\n                     builder.append(new String(data, 0, len));\n                 }\n+                if (isProtobuf(targetType)) {\n+                    Message.Builder newBuilder = (Message.Builder) MethodUtils.findMethod(targetType, \"newBuilder\").invoke(null);\n+                    JsonFormat.parser().ignoringUnknownFields().merge(builder.toString(), newBuilder);\n+                    return newBuilder.build();\n+                }\n                 return JsonUtils.toJavaObject(builder.toString(), targetType);\n             } finally {\n                 body.close();\n@@ -124,4 +137,11 @@ public Object[] decode(InputStream dataInputStream, Class<?>[] targetTypes) thro\n         }\n     }\n+    private boolean isProtobuf(Class<?> targetType) {\n+        if (targetType == null) {\n+            return false;\n+        }\n+        return Message.class.isAssignableFrom(targetType);\n+    }\n+\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/NoOpStreamingDecoder.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/NoOpStreamingDecoder.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/NoOpStreamingDecoder.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/NoOpStreamingDecoder.java\n@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.remoting.http12.message;\n+\n+import org.apache.dubbo.remoting.http12.exception.DecodeException;\n+\n+import java.io.InputStream;\n+\n+public class NoOpStreamingDecoder implements StreamingDecoder {\n+\n+    private FragmentListener listener;\n+\n+    @Override\n+    public void request(int numMessages) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void decode(InputStream inputStream) throws DecodeException {\n+        listener.onFragmentMessage(inputStream);\n+    }\n+\n+    @Override\n+    public void close() {\n+        this.listener.onClose();\n+    }\n+\n+    @Override\n+    public void setFragmentListener(FragmentListener listener) {\n+        this.listener = listener;\n+    }\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n@@ -118,17 +118,20 @@ public void onMetadata(HEADER metadata) {\n         try {\n             this.executor = initializeExecutor(metadata);\n         } catch (Throwable throwable) {\n+            LOGGER.error(\"initialize executor fail.\", throwable);\n             onError(throwable);\n             return;\n         }\n         if (this.executor == null) {\n+            LOGGER.error(\"executor must be not null.\");\n             onError(new NullPointerException(\"initializeExecutor return null\"));\n             return;\n         }\n         executor.execute(() -> {\n             try {\n                 doOnMetadata(metadata);\n             } catch (Throwable throwable) {\n+                LOGGER.error(\"server internal error\", throwable);\n                 onError(throwable);\n             }\n         });\n@@ -174,6 +177,7 @@ public void onData(MESSAGE message) {\n             try {\n                 doOnData(message);\n             } catch (Throwable e) {\n+                LOGGER.error(\"server internal error\", e);\n                 onError(e);\n             }\n         });\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java\n@@ -28,9 +28,9 @@\n import org.apache.dubbo.remoting.http12.h2.Http2TransportListener;\n import org.apache.dubbo.remoting.http12.message.DefaultListeningDecoder;\n import org.apache.dubbo.remoting.http12.message.JsonCodec;\n-import org.apache.dubbo.remoting.http12.message.LengthFieldStreamingDecoder;\n import org.apache.dubbo.remoting.http12.message.ListeningDecoder;\n import org.apache.dubbo.remoting.http12.message.MethodMetadata;\n+import org.apache.dubbo.remoting.http12.message.NoOpStreamingDecoder;\n import org.apache.dubbo.remoting.http12.message.StreamingDecoder;\n import org.apache.dubbo.rpc.CancellationContext;\n import org.apache.dubbo.rpc.Invoker;\n@@ -116,8 +116,8 @@ public void cancelByRemote(long errorCode) {\n     }\n     protected StreamingDecoder newStreamingDecoder() {\n-        //default lengthFieldLength = 4\n-        return new LengthFieldStreamingDecoder();\n+        //default no op\n+        return new NoOpStreamingDecoder();\n     }\n     protected void doOnMetadata(Http2Header metadata) {",
    "output": "Add protobuf json format support for triple"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/NoOpStreamingDecoder.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/NoOpStreamingDecoder.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/NoOpStreamingDecoder.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/message/NoOpStreamingDecoder.java\n@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.remoting.http12.message;\n+\n+import org.apache.dubbo.remoting.http12.exception.DecodeException;\n+\n+import java.io.InputStream;\n+\n+public class NoOpStreamingDecoder implements StreamingDecoder {\n+\n+    private FragmentListener listener;\n+\n+    @Override\n+    public void request(int numMessages) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void decode(InputStream inputStream) throws DecodeException {\n+        listener.onFragmentMessage(inputStream);\n+    }\n+\n+    @Override\n+    public void close() {\n+        this.listener.onClose();\n+    }\n+\n+    @Override\n+    public void setFragmentListener(FragmentListener listener) {\n+        this.listener = listener;\n+    }\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http2/GenericHttp2ServerTransportListener.java\n@@ -28,9 +28,9 @@\n import org.apache.dubbo.remoting.http12.h2.Http2TransportListener;\n import org.apache.dubbo.remoting.http12.message.DefaultListeningDecoder;\n import org.apache.dubbo.remoting.http12.message.JsonCodec;\n-import org.apache.dubbo.remoting.http12.message.LengthFieldStreamingDecoder;\n import org.apache.dubbo.remoting.http12.message.ListeningDecoder;\n import org.apache.dubbo.remoting.http12.message.MethodMetadata;\n+import org.apache.dubbo.remoting.http12.message.NoOpStreamingDecoder;\n import org.apache.dubbo.remoting.http12.message.StreamingDecoder;\n import org.apache.dubbo.rpc.CancellationContext;\n import org.apache.dubbo.rpc.Invoker;\n@@ -116,8 +116,8 @@ public void cancelByRemote(long errorCode) {\n     }\n     protected StreamingDecoder newStreamingDecoder() {\n-        //default lengthFieldLength = 4\n-        return new LengthFieldStreamingDecoder();\n+        //default no op\n+        return new NoOpStreamingDecoder();\n     }\n     protected void doOnMetadata(Http2Header metadata) {",
    "output": "Fix h2 curl error"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java\n--- a/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java\n+++ b/dubbo-remoting/dubbo-remoting-http12/src/main/java/org/apache/dubbo/remoting/http12/AbstractServerHttpChannelObserver.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.remoting.http12;\n+import org.apache.dubbo.remoting.http12.exception.EncodeException;\n import org.apache.dubbo.remoting.http12.exception.HttpStatusException;\n import org.apache.dubbo.remoting.http12.message.HttpMessageCodec;\n@@ -119,6 +120,8 @@ public void onError(Throwable throwable) {\n             HttpOutputMessage httpOutputMessage = encodeHttpOutputMessage(errorResponse);\n             this.httpMessageCodec.encode(httpOutputMessage.getBody(), errorResponse);\n             getHttpChannel().writeMessage(httpOutputMessage);\n+        } catch (Throwable ex) {\n+            throwable = new EncodeException(ex);\n         } finally {\n             doOnCompleted(throwable);\n         }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/AbstractServerTransportListener.java\n@@ -161,7 +161,7 @@ protected void doOnMetadata(HEADER metadata) {\n             throw new UnsupportedMediaTypeException(contentType);\n         }\n         this.httpMessageCodec = httpMessageCodec;\n-        this.serviceDescriptor = findServiceDescriptor(invoker, serviceName, hasStub);\n+        setServiceDescriptor(findServiceDescriptor(invoker, serviceName, hasStub));\n         setHttpMessageListener(newHttpMessageListener());\n         onMetadataCompletion(metadata);\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/grpc/GrpcHttp2ServerTransportListener.java\n@@ -29,6 +29,7 @@\n import org.apache.dubbo.remoting.http12.message.StreamingDecoder;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.RpcInvocation;\n+import org.apache.dubbo.rpc.TriRpcStatus;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.MethodDescriptor;\n import org.apache.dubbo.rpc.model.ServiceDescriptor;\n@@ -66,10 +67,16 @@ private void initialize() {\n     private void grpcTrailersCustomize(HttpHeaders httpHeaders, Throwable throwable) {\n         httpHeaders.set(GrpcHeaderNames.GRPC_STATUS.getName(), \"0\");\n         if (throwable != null) {\n+            httpHeaders.set(GrpcHeaderNames.GRPC_STATUS.getName(), httpStatusToGrpcStatus(throwable));\n             httpHeaders.set(GrpcHeaderNames.GRPC_MESSAGE.getName(), throwable.getMessage());\n         }\n     }\n+    private static String httpStatusToGrpcStatus(Throwable throwable) {\n+        //http status code map to grpc status code\n+        return String.valueOf(TriRpcStatus.INTERNAL.code.code);\n+    }\n+\n     @Override\n     protected RpcInvocation buildRpcInvocation(Invoker<?> invoker, ServiceDescriptor serviceDescriptor, MethodDescriptor methodDescriptor) {\n         RpcInvocation rpcInvocation = super.buildRpcInvocation(invoker, serviceDescriptor, methodDescriptor);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/DefaultHttp11ServerTransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/DefaultHttp11ServerTransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/DefaultHttp11ServerTransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/h12/http1/DefaultHttp11ServerTransportListener.java\n@@ -81,6 +81,8 @@ protected HttpMessageListener newHttpMessageListener() {\n         MethodDescriptor methodDescriptor = findMethodDescriptor(getServiceDescriptor(), originalMethodName, hasStub);\n         MethodMetadata methodMetadata = MethodMetadata.fromMethodDescriptor(methodDescriptor);\n         RpcInvocation rpcInvocation = buildRpcInvocation(getInvoker(), getServiceDescriptor(), methodDescriptor);\n+        setMethodDescriptor(methodDescriptor);\n+        setMethodMetadata(methodMetadata);\n         setRpcInvocation(rpcInvocation);\n         HttpMessageCodec httpMessageCodec = getHttpMessageCodec();\n         ListeningDecoder listeningDecoder = newListeningDecoder(httpMessageCodec, methodMetadata.getActualRequestTypes());",
    "output": "Fix h1 and grpc status code"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java\n@@ -27,11 +27,12 @@\n import org.apache.dubbo.rpc.cluster.SingleRouterChain;\n import org.apache.dubbo.rpc.cluster.router.state.BitList;\n-import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CLUSTER_FAILED_SITE_SELECTION;\n+import static org.apache.dubbo.common.constants.RegistryConstants.REGISTER_MODE_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_KEY;\n /**\n@@ -130,6 +131,9 @@ protected List<Invoker<T>> doList(SingleRouterChain<T> singleRouterChain, BitLis\n     @Override\n     protected Map<String, String> getDirectoryMeta() {\n-        return Collections.singletonMap(REGISTRY_KEY, \"static\");\n+        Map<String, String> metas = new HashMap<>();\n+        metas.put(REGISTRY_KEY, \"static\");\n+        metas.put(REGISTER_MODE_KEY, \"static\");\n+        return metas;\n     }\n }",
    "output": "Fix static directory metrics label * Fix static directory metrics label * Fix import"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java\n@@ -248,8 +248,8 @@ private long calculateReconnectDuration(URL url, long tick) {\n         return Math.max(leastReconnectDuration, tick);\n     }\n-    private boolean shouldReconnect(URL url) {\n-        return url.getParameter(Constants.RECONNECT_KEY, true);\n+    protected boolean shouldReconnect(URL url) {\n+        return !Boolean.FALSE.toString().equalsIgnoreCase(url.getParameter(Constants.RECONNECT_KEY));\n     }\n     @Override\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClientTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClientTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClientTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClientTest.java\n@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.remoting.exchange.support.header;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.remoting.Client;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+public class HeaderExchangeClientTest {\n+    @Test\n+    void testReconnect() {\n+        HeaderExchangeClient headerExchangeClient = new HeaderExchangeClient(Mockito.mock(Client.class), false);\n+\n+        Assertions.assertTrue(headerExchangeClient.shouldReconnect(URL.valueOf(\"localhost\")));\n+        Assertions.assertTrue(headerExchangeClient.shouldReconnect(URL.valueOf(\"localhost?reconnect=true\")));\n+        Assertions.assertTrue(headerExchangeClient.shouldReconnect(URL.valueOf(\"localhost?reconnect=tRue\")));\n+        Assertions.assertTrue(headerExchangeClient.shouldReconnect(URL.valueOf(\"localhost?reconnect=30000\")));\n+        Assertions.assertTrue(headerExchangeClient.shouldReconnect(URL.valueOf(\"localhost?reconnect=0\")));\n+        Assertions.assertTrue(headerExchangeClient.shouldReconnect(URL.valueOf(\"localhost?reconnect=-1\")));\n+        Assertions.assertFalse(headerExchangeClient.shouldReconnect(URL.valueOf(\"localhost?reconnect=false\")));\n+        Assertions.assertFalse(headerExchangeClient.shouldReconnect(URL.valueOf(\"localhost?reconnect=FALSE\")));\n+    }\n+}",
    "output": "Fix shouldReconnect check"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.threadlocal.InternalThreadLocalMap;\n import org.apache.dubbo.common.threadpool.manager.ExecutorRepository;\n+import org.apache.dubbo.common.url.component.DubboServiceAddressURL;\n import org.apache.dubbo.common.utils.ArrayUtils;\n import org.apache.dubbo.common.utils.ExecutorUtil;\n import org.apache.dubbo.common.utils.ReflectUtils;\n@@ -62,6 +63,9 @@ public class InjvmInvoker<T> extends AbstractInvoker<T> {\n     private final Map<String, Exporter<?>> exporterMap;\n+    private volatile Exporter<?> exporter = null;\n+    private volatile URL consumerUrl = null;\n+\n     private final ExecutorRepository executorRepository;\n     private final ParamDeepCopyUtil paramDeepCopyUtil;\n@@ -92,9 +96,11 @@ public boolean isAvailable() {\n     @Override\n     public Result doInvoke(Invocation invocation) throws Throwable {\n-        Exporter<?> exporter = InjvmProtocol.getExporter(exporterMap, getUrl());\n         if (exporter == null) {\n-            throw new RpcException(\"Service [\" + key + \"] not found.\");\n+            exporter = InjvmProtocol.getExporter(exporterMap, getUrl());\n+            if (exporter == null) {\n+                throw new RpcException(\"Service [\" + key + \"] not found.\");\n+            }\n         }\n         // Solve local exposure, the server opens the token, and the client call fails.\n         Invoker<?> invoker = exporter.getInvoker();\n@@ -103,8 +109,12 @@ public Result doInvoke(Invocation invocation) throws Throwable {\n         if (serverHasToken) {\n             invocation.setAttachment(Constants.TOKEN_KEY, serverURL.getParameter(Constants.TOKEN_KEY));\n         }\n+        if (consumerUrl == null) {\n+            // no need to sync, multi-objects is acceptable and will be gc-ed.\n+            consumerUrl = new DubboServiceAddressURL(serverURL.getUrlAddress(), serverURL.getUrlParam(), getUrl(), null);\n+        }\n-        int timeout = RpcUtils.calculateTimeout(getUrl(), invocation, RpcUtils.getMethodName(invocation), DEFAULT_TIMEOUT);\n+        int timeout = RpcUtils.calculateTimeout(consumerUrl, invocation, RpcUtils.getMethodName(invocation), DEFAULT_TIMEOUT);\n         if (timeout <= 0) {\n             return AsyncRpcResult.newDefaultAsyncResult(new RpcException(RpcException.TIMEOUT_TERMINATE,\n                 \"No time left for making the following call: \" + invocation.getServiceName() + \".\"\n@@ -242,7 +252,7 @@ private Invocation recreateInvocation(Invocation invocation, Invoker<?> invoker,\n                 if (pts != null && args != null && pts.length == args.length) {\n                     realArgument = new Object[pts.length];\n                     for (int i = 0; i < pts.length; i++) {\n-                        realArgument[i] = paramDeepCopyUtil.copy(getUrl(), args[i], pts[i]);\n+                        realArgument[i] = paramDeepCopyUtil.copy(consumerUrl, args[i], pts[i]);\n                     }\n                 }\n                 if (realArgument == null) {\n@@ -273,7 +283,7 @@ private Object rebuildValue(Invocation invocation, String desc, Object originVal\n                 Class<?> returnType = getReturnType(consumerServiceModel, invocation.getMethodName(), desc);\n                 if (returnType != null) {\n                     Thread.currentThread().setContextClassLoader(consumerServiceModel.getClassLoader());\n-                    value = paramDeepCopyUtil.copy(getUrl(), originValue, returnType);\n+                    value = paramDeepCopyUtil.copy(consumerUrl, originValue, returnType);\n                 }\n             }\n             return value;",
    "output": "Fix injvm params error"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-plugin-context/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/CallbackConsumerContextFilter.java b/dubbo-plugin/dubbo-plugin-context/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/CallbackConsumerContextFilter.java\n--- a/dubbo-plugin/dubbo-plugin-context/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/CallbackConsumerContextFilter.java\n+++ b/dubbo-plugin/dubbo-plugin-context/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/CallbackConsumerContextFilter.java\n@@ -14,11 +14,10 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.dubbo.monitor.support;\n+package org.apache.dubbo.rpc.cluster.filter.support;\n import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.rpc.Filter;\n-import org.apache.dubbo.rpc.cluster.filter.support.ConsumerContextFilter;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import static org.apache.dubbo.common.constants.CommonConstants.CALLBACK;\n@@ -30,7 +29,7 @@\n  */\n @Activate(group = CALLBACK, order = Integer.MIN_VALUE)\n public class CallbackConsumerContextFilter extends ConsumerContextFilter implements Filter {\n-\n+\n     public CallbackConsumerContextFilter(ApplicationModel applicationModel) {\n         super(applicationModel);\n     }",
    "output": "Fix callback consumer context package"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/ChunkOutputStream.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/ChunkOutputStream.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/ChunkOutputStream.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/ChunkOutputStream.java\n@@ -21,6 +21,7 @@\n import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http.DefaultHttpContent;\n+import org.apache.dubbo.remoting.transport.ExceedPayloadLimitException;\n import java.io.IOException;\n import java.io.OutputStream;\n@@ -29,27 +30,32 @@ public class ChunkOutputStream extends OutputStream {\n     final ByteBuf buffer;\n     final ChannelHandlerContext ctx;\n     final NettyHttpResponse response;\n+    int chunkSize = 0;\n-    ChunkOutputStream(final NettyHttpResponse response, final ChannelHandlerContext ctx, final int chunksize) {\n+    ChunkOutputStream(final NettyHttpResponse response, final ChannelHandlerContext ctx, final int chunkSize) {\n         this.response = response;\n-        if (chunksize < 1) {\n+        if (chunkSize < 1) {\n             throw new IllegalArgumentException();\n         }\n-        // TODO  buffer pool\n-        this.buffer = Unpooled.buffer(0, chunksize);\n+        this.buffer = Unpooled.buffer(0, chunkSize);\n+        this.chunkSize = chunkSize;\n         this.ctx = ctx;\n     }\n     @Override\n     public void write(int b) throws IOException {\n         if (buffer.maxWritableBytes() < 1) {\n-            flush();\n+            throwExceedPayloadLimitException(buffer.readableBytes() + 1);\n         }\n         buffer.writeByte(b);\n     }\n-    public void reset()\n-    {\n+    private void throwExceedPayloadLimitException(int dataSize) throws ExceedPayloadLimitException {\n+        throw new ExceedPayloadLimitException(\n+            \"Data length too large: \" + dataSize + \", max payload: \" + chunkSize);\n+    }\n+\n+    public void reset() {\n         if (response.isCommitted()) throw new IllegalStateException();\n         buffer.clear();\n     }\n@@ -65,16 +71,10 @@ public void close() throws IOException {\n     public void write(byte[] b, int off, int len) throws IOException {\n         int dataLengthLeftToWrite = len;\n         int dataToWriteOffset = off;\n-        int spaceLeftInCurrentChunk;\n-        while ((spaceLeftInCurrentChunk = buffer.maxWritableBytes()) < dataLengthLeftToWrite) {\n-            buffer.writeBytes(b, dataToWriteOffset, spaceLeftInCurrentChunk);\n-            dataToWriteOffset = dataToWriteOffset + spaceLeftInCurrentChunk;\n-            dataLengthLeftToWrite = dataLengthLeftToWrite - spaceLeftInCurrentChunk;\n-            flush();\n-        }\n-        if (dataLengthLeftToWrite > 0) {\n-            buffer.writeBytes(b, dataToWriteOffset, dataLengthLeftToWrite);\n+        if (buffer.maxWritableBytes() < dataLengthLeftToWrite) {\n+            throwExceedPayloadLimitException(buffer.readableBytes() + len);\n         }\n+        buffer.writeBytes(b, dataToWriteOffset, dataLengthLeftToWrite);\n     }\n     @Override\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/NettyHttpResponse.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/NettyHttpResponse.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/NettyHttpResponse.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/NettyHttpResponse.java\n@@ -27,7 +27,9 @@\n import io.netty.handler.codec.http.HttpMethod;\n import io.netty.handler.codec.http.HttpResponseStatus;\n import io.netty.handler.codec.http.LastHttpContent;\n+import org.apache.dubbo.common.URL;\n import org.apache.dubbo.metadata.rest.media.MediaType;\n+import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.rpc.protocol.rest.RestHeaderEnum;\n@@ -59,15 +61,14 @@ public class NettyHttpResponse implements HttpResponse {\n     // raw response class\n     private Class<?> entityClass;\n-    public NettyHttpResponse(final ChannelHandlerContext ctx, final boolean keepAlive) {\n-        this(ctx, keepAlive, null);\n+    public NettyHttpResponse(final ChannelHandlerContext ctx, final boolean keepAlive, URL url) {\n+        this(ctx, keepAlive, null, url);\n     }\n-    public NettyHttpResponse(final ChannelHandlerContext ctx, final boolean keepAlive, final HttpMethod method) {\n+    public NettyHttpResponse(final ChannelHandlerContext ctx, final boolean keepAlive,  HttpMethod method, URL url) {\n         outputHeaders = new HashMap<>();\n         this.method = method;\n-        // TODO chunk size to config\n-        os = new ChunkOutputStream(this, ctx, 1000);\n+        os = new ChunkOutputStream(this, ctx, url.getParameter(Constants.PAYLOAD_KEY, Constants.DEFAULT_PAYLOAD));\n         this.ctx = ctx;\n         this.keepAlive = keepAlive;\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java\n@@ -60,7 +60,7 @@ public RestHttpRequestDecoder(URL url, ServiceDeployer serviceDeployer) {\n     protected void decode(ChannelHandlerContext ctx, io.netty.handler.codec.http.FullHttpRequest request, List<Object> out) throws Exception {\n         boolean keepAlive = HttpHeaders.isKeepAlive(request);\n-        NettyHttpResponse nettyHttpResponse = new NettyHttpResponse(ctx, keepAlive);\n+        NettyHttpResponse nettyHttpResponse = new NettyHttpResponse(ctx, keepAlive,url);\n         NettyRequestFacade requestFacade = new NettyRequestFacade(request, ctx,serviceDeployer);\n         executor.execute(() -> {\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/JaxrsRestProtocolTest.java b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/JaxrsRestProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/JaxrsRestProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/JaxrsRestProtocolTest.java\n@@ -63,6 +63,7 @@\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import static org.apache.dubbo.remoting.Constants.SERVER_KEY;\n@@ -743,6 +744,35 @@ void testReExport() {\n         exporter.unexport();\n     }\n+    @Test\n+    void testBody() {\n+\n+\n+        Assertions.assertThrowsExactly(RpcException.class, () -> {\n+            DemoService server = new DemoServiceImpl();\n+\n+            URL url = this.registerProvider(exportUrl, server, DemoService.class);\n+\n+            URL nettyUrl = url.addParameter(org.apache.dubbo.remoting.Constants.PAYLOAD_KEY,  1024);\n+\n+            Exporter<DemoService> exporter = protocol.export(proxy.getInvoker(server, DemoService.class, nettyUrl));\n+\n+\n+            DemoService demoService = this.proxy.getProxy(protocol.refer(DemoService.class, nettyUrl));\n+\n+            List<User> users = new ArrayList<>();\n+            for (int i = 0; i < 10000; i++) {\n+                users.add(User.getInstance());\n+\n+            }\n+\n+            demoService.list(users);\n+\n+            exporter.unexport();\n+        });\n+\n+    }\n+\n     private URL registerProvider(URL url, Object impl, Class<?> interfaceClass) {\n         ServiceDescriptor serviceDescriptor = repository.registerService(interfaceClass);\n         ProviderModel providerModel = new ProviderModel(",
    "output": "Fix chunkoutputstream chunksize exception"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -25,6 +25,7 @@\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.stream.StreamObserver;\n import org.apache.dubbo.common.threadpool.ThreadlessExecutor;\n+import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.remoting.api.connection.AbstractConnectionClient;\n import org.apache.dubbo.rpc.AppResponse;\n import org.apache.dubbo.rpc.AsyncRpcResult;\n@@ -55,6 +56,7 @@\n import org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\n import org.apache.dubbo.rpc.protocol.tri.observer.ClientCallToObserverAdapter;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n+import org.apache.dubbo.rpc.service.ServiceDescriptorInternalCache;\n import org.apache.dubbo.rpc.support.RpcUtils;\n import io.netty.util.AsciiString;\n@@ -65,6 +67,7 @@\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_PACKABLE_METHOD_FACTORY;\n@@ -131,9 +134,13 @@ protected Result doInvoke(final Invocation invocation) {\n         ConsumerModel consumerModel = (ConsumerModel) (invocation.getServiceModel() != null\n             ? invocation.getServiceModel() : getUrl().getServiceModel());\n         ServiceDescriptor serviceDescriptor = consumerModel.getServiceModel();\n-        final MethodDescriptor methodDescriptor = serviceDescriptor.getMethod(\n-            invocation.getMethodName(),\n-            invocation.getParameterTypes());\n+        final MethodDescriptor methodDescriptor;\n+        boolean genericCall = RpcUtils.isGenericCall(ReflectUtils.getDesc(invocation.getParameterTypes()), invocation.getMethodName());\n+        if (!genericCall) {\n+            methodDescriptor = serviceDescriptor.getMethod(invocation.getMethodName(), invocation.getParameterTypes());\n+        } else {\n+            methodDescriptor = ServiceDescriptorInternalCache.genericService().getMethod(invocation.getMethodName(), invocation.getParameterTypes());\n+        }\n         ExecutorService callbackExecutor = isSync(methodDescriptor, invocation) ? new ThreadlessExecutor() : streamExecutor;\n         ClientCall call = new TripleClientCall(connectionClient, callbackExecutor,\n             getUrl().getOrDefaultFrameworkModel(), writeQueue);\n@@ -239,7 +246,15 @@ AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocat\n         if (methodDescriptor instanceof StubMethodDescriptor) {\n             pureArgument = invocation.getArguments()[0];\n         } else {\n-            pureArgument = invocation.getArguments();\n+            if (methodDescriptor.isGeneric()) {\n+                Object[] args = new Object[3];\n+                args[0] = RpcUtils.getMethodName(invocation);\n+                args[1] = Arrays.stream(RpcUtils.getParameterTypes(invocation)).map(Class::getName).collect(Collectors.toList());\n+                args[2] = RpcUtils.getArguments(invocation);\n+                pureArgument = args;\n+            } else {\n+                pureArgument = invocation.getArguments();\n+            }\n         }\n         result = new AsyncRpcResult(future, invocation);\n         if (setFutureWhenSync || ((RpcInvocation) invocation).getInvokeMode() != InvokeMode.SYNC) {",
    "output": "Fix triple npe"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java\n@@ -18,11 +18,12 @@\n package org.apache.dubbo.metrics.aggregate;\n+import org.apache.dubbo.metrics.exception.MetricsNeverHappenException;\n+\n import com.tdunning.math.stats.Centroid;\n import com.tdunning.math.stats.ScaleFunction;\n import com.tdunning.math.stats.Sort;\n import com.tdunning.math.stats.TDigest;\n-import org.apache.dubbo.metrics.exception.MetricsNeverHappenException;\n import java.nio.ByteBuffer;\n import java.util.AbstractCollection;\n@@ -285,16 +286,17 @@ private void add(double x, int w, List<Double> history) {\n             throw new IllegalArgumentException(\"Cannot add NaN to t-digest\");\n         }\n+        int where;\n         synchronized (this) {\n             // There is a small probability of entering here\n             if (tempUsed.get() >= tempWeight.length - lastUsedCell.get() - 1) {\n                 mergeNewValues();\n             }\n+            where = tempUsed.getAndIncrement();\n+            tempWeight[where] = w;\n+            tempMean[where] = x;\n+            unmergedWeight.addAndGet(w);\n         }\n-        int where = tempUsed.getAndIncrement();\n-        tempWeight[where] = w;\n-        tempMean[where] = x;\n-        unmergedWeight.addAndGet(w);\n         if (x < min) {\n             min = x;\n         }\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java\n@@ -18,6 +18,7 @@\n package org.apache.dubbo.metrics.aggregate;\n import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.RepeatedTest;\n import org.junit.jupiter.api.Test;\n import java.util.concurrent.ExecutorService;\n@@ -37,6 +38,7 @@ void test() {\n     }\n     @Test\n+    @RepeatedTest(100)\n     void testMulti() {\n         ExecutorService executorService = Executors.newFixedThreadPool(200);\n@@ -51,12 +53,14 @@ void testMulti() {\n                     quantile.add(finalI));\n             }\n             index++;\n-            try {\n-                Thread.sleep(100);\n-            } catch (InterruptedException e) {\n-                e.printStackTrace();\n-            }\n+//            try {\n+//                Thread.sleep(1);\n+//            } catch (InterruptedException e) {\n+//                e.printStackTrace();\n+//            }\n         }\n+\n+        executorService.shutdown();\n     }\n }",
    "output": "Fix DubboMergingDigest concurrent issue"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -190,7 +190,7 @@ public boolean isUnexported() {\n     }\n     @Override\n-    public void unexport() {\n+    public synchronized void unexport() {\n         if (!exported) {\n             return;\n         }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n@@ -335,6 +335,13 @@ private void onModuleStarted() {\n     private void onModuleFailed(String msg, Throwable ex) {\n         try {\n+            try {\n+                // un-export all services if start failure\n+                unexportServices();\n+            } catch (Throwable t) {\n+                logger.info(\"Failed to un-export services after module failed.\", t);\n+            }\n+\n             setFailed(ex);\n             logger.error(CONFIG_FAILED_START_MODEL, \"\", \"\", \"Model start failed: \" + msg, ex);\n             applicationDeployer.notifyModuleChanged(moduleModel, DeployState.FAILED);\n@@ -450,8 +457,8 @@ private void unexportServices() {\n             try {\n                 configManager.removeConfig(sc);\n                 sc.unexport();\n-            } catch (Exception ignored) {\n-                // ignored\n+            } catch (Throwable t) {\n+                logger.info(\"Failed to un-export service. Service Key: \" + sc.getUniqueServiceName(), t);\n             }\n         });\n         exportedServices.clear();\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java\n@@ -182,7 +182,7 @@ private void onContextClosedEvent(ContextClosedEvent event) {\n     @Override\n     public int getOrder() {\n-        return HIGHEST_PRECEDENCE;\n+        return LOWEST_PRECEDENCE;\n     }\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -1015,16 +1015,19 @@ public void register() {\n         @Override\n         public synchronized void unregister() {\n             if (registered.compareAndSet(true, false)) {\n-                Registry registry = RegistryProtocol.this.getRegistry(getRegistryUrl(originInvoker));\n+                URL registryUrl = getRegistryUrl(originInvoker);\n+                Registry registry = RegistryProtocol.this.getRegistry(registryUrl);\n                 ProviderModel providerModel = frameworkModel.getServiceRepository()\n                     .lookupExportedService(getRegisterUrl().getServiceKey());\n-                List<ProviderModel.RegisterStatedURL> statedUrls = providerModel.getStatedUrl();\n-                if (statedUrls.stream()\n-                    .filter(u -> u.getRegistryUrl().equals(getRegisterUrl())\n-                        && u.getProviderUrl().getProtocol().equals(getRegisterUrl().getProtocol()))\n-                    .anyMatch(ProviderModel.RegisterStatedURL::isRegistered)) {\n+                List<ProviderModel.RegisterStatedURL> statedURLs =\n+                    providerModel.getStatedUrl()\n+                        .stream()\n+                        .filter(u -> u.getRegistryUrl().equals(registryUrl)\n+                            && u.getProviderUrl().getProtocol().equals(getRegisterUrl().getProtocol()))\n+                        .collect(Collectors.toList());\n+                if (statedURLs.isEmpty() || statedURLs.stream().anyMatch(ProviderModel.RegisterStatedURL::isRegistered)) {\n                     try {\n                         registry.unregister(registerUrl);\n                     } catch (Throwable t) {",
    "output": "Fix Spring Listener order"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DefaultSerializeClassChecker.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DefaultSerializeClassChecker.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DefaultSerializeClassChecker.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DefaultSerializeClassChecker.java\n@@ -159,7 +159,7 @@ private Class<?> loadClass0(ClassLoader classLoader, String className) throws Cl\n                     \"Current mode is `WARN`, will disallow to deserialize it by default. \" +\n                     \"Please add it into security/serialize.allowlist or follow FAQ to configure it.\";\n                 if (serializeSecurityManager.getWarnedClasses().add(className)) {\n-                    logger.error(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\", msg);\n+                    logger.warn(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\", msg);\n                 }\n                 throw new IllegalArgumentException(msg);\n@@ -180,7 +180,7 @@ private Class<?> loadClass0(ClassLoader classLoader, String className) throws Cl\n                     \"Current mode is `WARN`, will disallow to deserialize it by default. \" +\n                     \"Please add it into security/serialize.allowlist or follow FAQ to configure it.\";\n                 if (serializeSecurityManager.getWarnedClasses().add(className)) {\n-                    logger.error(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\", msg);\n+                    logger.warn(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\", msg);\n                 }\n                 throw new IllegalArgumentException(msg);\n@@ -189,7 +189,7 @@ private Class<?> loadClass0(ClassLoader classLoader, String className) throws Cl\n         Class<?> clazz = ClassUtils.forName(className, classLoader);\n         if (serializeSecurityManager.getWarnedClasses().add(className)) {\n-            logger.error(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\",\n+            logger.warn(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\",\n                 \"[Serialization Security] Serialized class \" + className + \" is not in allow list. \" +\n                     \"Current mode is `WARN`, will allow to deserialize it by default. \" +\n                     \"Dubbo will set to `STRICT` mode by default in the future. \" +\ndiff --git a/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2SecurityManager.java b/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2SecurityManager.java\n--- a/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2SecurityManager.java\n+++ b/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/Fastjson2SecurityManager.java\n@@ -122,7 +122,7 @@ public Class<?> apply(String typeName, Class<?> expectClass, long features) {\n             Class<?> localClass = loadClassDirectly(typeName);\n             if (localClass != null) {\n                 if (status == SerializeCheckStatus.WARN && serializeSecurityManager.getWarnedClasses().add(typeName)) {\n-                    logger.error(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\",\n+                    logger.warn(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\",\n                         \"[Serialization Security] Serialized class \" + localClass.getName() + \" is not in allow list. \" +\n                             \"Current mode is `WARN`, will allow to deserialize it by default. \" +\n                             \"Dubbo will set to `STRICT` mode by default in the future. \" +\n@@ -152,7 +152,7 @@ public Class<?> loadClassDirectly(String typeName) {\n                     \"Current mode is `WARN`, will disallow to deserialize it by default. \" +\n                     \"Please add it into security/serialize.allowlist or follow FAQ to configure it.\";\n                 if (serializeSecurityManager.getWarnedClasses().add(typeName)) {\n-                    logger.error(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\", msg);\n+                    logger.warn(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\", msg);\n                 }\n             }",
    "output": "Upgrade log level for serialization check"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -462,7 +462,7 @@ private T createProxy(Map<String, String> referenceParameters) {\n         if (logger.isInfoEnabled()) {\n             logger.info(\"Referred dubbo service: [\" + referenceParameters.get(INTERFACE_KEY) + \"].\" +\n-                    (Boolean.parseBoolean(referenceParameters.get(GENERIC_KEY)) ?\n+                    (ProtocolUtils.isGeneric(referenceParameters.get(GENERIC_KEY)) ?\n                             \" it's GenericService reference\" : \" it's not GenericService reference\"));\n         }",
    "output": "Use ProtocolUtils.isGeneric judge generic type"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/identifier/MetadataIdentifier.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/identifier/MetadataIdentifier.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/identifier/MetadataIdentifier.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/identifier/MetadataIdentifier.java\n@@ -101,4 +101,14 @@ public String getUniqueServiceName() {\n         return serviceInterface != null ? URL.buildKey(serviceInterface, getGroup(), getVersion()) : null;\n     }\n+    @Override\n+    public String toString() {\n+        return \"MetadataIdentifier{\" +\n+            \"application='\" + application + '\\'' +\n+            \", serviceInterface='\" + serviceInterface + '\\'' +\n+            \", version='\" + version + '\\'' +\n+            \", group='\" + group + '\\'' +\n+            \", side='\" + side + '\\'' +\n+            '}';\n+    }\n }",
    "output": "Add toString"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java\n@@ -28,12 +28,15 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.threadpool.ThreadPool;\n+import org.apache.dubbo.common.threadpool.manager.ExecutorRepository;\n+import org.apache.dubbo.common.utils.ExecutorUtil;\n import org.apache.dubbo.rpc.protocol.rest.RestHeaderEnum;\n import org.apache.dubbo.rpc.protocol.rest.deploy.ServiceDeployer;\n import org.apache.dubbo.rpc.protocol.rest.handler.NettyHttpHandler;\n import org.apache.dubbo.rpc.protocol.rest.request.NettyRequestFacade;\n+import static org.apache.dubbo.config.Constants.SERVER_THREAD_POOL_NAME;\n+\n public class RestHttpRequestDecoder extends MessageToMessageDecoder<io.netty.handler.codec.http.FullHttpRequest> {\n     private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(getClass());\n@@ -48,7 +51,7 @@ public RestHttpRequestDecoder(URL url, ServiceDeployer serviceDeployer) {\n         this.url = url;\n         this.serviceDeployer = serviceDeployer;\n-        executor = url.getOrDefaultFrameworkModel().getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url);\n+        executor = ExecutorRepository.getInstance(url.getOrDefaultApplicationModel()).createExecutorIfAbsent(ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME));\n         nettyHttpHandler = new NettyHttpHandler(serviceDeployer, url);\n     }",
    "output": "Fix rest thread memory leak"
  },
  {
    "input": "diff --git a/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java b/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n--- a/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n+++ b/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n@@ -45,6 +45,7 @@ class FileTest {\n     static {\n         ignoredModules.add(Pattern.compile(\"dubbo-apache-release\"));\n+        ignoredModules.add(Pattern.compile(\"dubbo-all-shaded\"));\n         ignoredModules.add(Pattern.compile(\"dubbo-build-tools\"));\n         ignoredModules.add(Pattern.compile(\"dubbo-dependencies-all\"));\n         ignoredModules.add(Pattern.compile(\"dubbo-parent\"));\n@@ -57,6 +58,7 @@ class FileTest {\n         ignoredArtifacts.add(Pattern.compile(\"dubbo-annotation-processor\"));\n         ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo\"));\n+        ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo-all-shaded\"));\n         ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo-bom\"));\n         ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo-compiler\"));\n         ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo-dependencies.*\"));",
    "output": "Add module dubbo-all-shaded to avoid netty version conflict"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/TriDecoder.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/TriDecoder.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/TriDecoder.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/TriDecoder.java\n@@ -17,12 +17,11 @@\n package org.apache.dubbo.rpc.protocol.tri.frame;\n-import org.apache.dubbo.rpc.RpcException;\n-import org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\n-\n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.CompositeByteBuf;\n import io.netty.buffer.Unpooled;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\n public class TriDecoder implements Deframer {\n@@ -152,6 +151,7 @@ private byte[] getCompressedBody() {\n     private byte[] getUncompressedBody() {\n         byte[] data = new byte[requiredLength];\n         accumulate.readBytes(data);\n+        accumulate.discardReadComponents();\n         return data;\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStreamTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStreamTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStreamTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStreamTest.java\n@@ -17,8 +17,15 @@\n package org.apache.dubbo.rpc.protocol.tri.stream;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpScheme;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n import io.netty.handler.codec.http2.Http2StreamChannel;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.rpc.TriRpcStatus;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n@@ -38,21 +45,12 @@\n import org.apache.dubbo.rpc.protocol.tri.support.IGreeter;\n import org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.embedded.EmbeddedChannel;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpScheme;\n-import io.netty.handler.codec.http2.DefaultHttp2Headers;\n-import io.netty.util.concurrent.ImmediateEventExecutor;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import java.util.concurrent.Executor;\n import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n@@ -121,7 +119,6 @@ void progress() {\n         byte[] data = new byte[]{0, 0, 0, 0, 1, 1};\n         final ByteBuf buf = Unpooled.wrappedBuffer(data);\n         transportListener.onData(buf, false);\n-        buf.release();\n         Assertions.assertEquals(1, listener.message.length);\n     }\n }",
    "output": "Fix memory leak * fix memory leak * fix ut"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java\n@@ -188,7 +188,7 @@ public void sendMessage(Object message) {\n         } catch (Throwable t) {\n             LOGGER.error(PROTOCOL_FAILED_SERIALIZE_TRIPLE, \"\", \"\", String.format(\"Serialize triple request failed, service=%s method=%s\",\n                 requestMetadata.service,\n-                requestMetadata.method), t);\n+                requestMetadata.method.getMethodName()), t);\n             cancelByLocal(t);\n             listener.onClose(TriRpcStatus.INTERNAL.withDescription(\"Serialize request failed\")\n                 .withCause(t), null, false);",
    "output": "Make sure method name when sendMessage error"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboContextPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboContextPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboContextPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboContextPostProcessor.java\n@@ -23,6 +23,7 @@\n import org.apache.dubbo.config.spring.util.EnvironmentUtils;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.ModuleModel;\n+\n import org.springframework.beans.BeansException;\n import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n@@ -59,7 +60,7 @@ public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)\n         // Extract dubbo props from Spring env and put them to app config\n         ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();\n         SortedMap<String, String> dubboProperties = EnvironmentUtils.filterDubboProperties(environment);\n-        applicationModel.getModelEnvironment().setAppConfigMap(dubboProperties);\n+        applicationModel.getModelEnvironment().getAppConfigMap().putAll(dubboProperties);\n         // register ConfigManager singleton\n         beanFactory.registerSingleton(ConfigManager.BEAN_NAME, applicationModel.getApplicationConfigManager());",
    "output": "Fix conflicts"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n@@ -132,11 +132,13 @@ public synchronized void register() throws RuntimeException {\n         if (isDestroy) {\n             return;\n         }\n-        ServiceInstance serviceInstance = createServiceInstance(this.metadataInfo);\n-        if (!isValidInstance(serviceInstance)) {\n-            return;\n+        if (this.serviceInstance == null) {\n+            ServiceInstance serviceInstance = createServiceInstance(this.metadataInfo);\n+            if (!isValidInstance(serviceInstance)) {\n+                return;\n+            }\n+            this.serviceInstance = serviceInstance;\n         }\n-        this.serviceInstance = serviceInstance;\n         boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance);\n         if (revisionUpdated) {\n             reportMetadata(this.metadataInfo);",
    "output": "Fix register failed if re-register service discovery"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2LoggerAdapter.java b/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2LoggerAdapter.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2LoggerAdapter.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2LoggerAdapter.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.common.logger.LoggerAdapter;\n import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.config.Configurator;\n import java.io.File;\n@@ -30,6 +31,12 @@ public class Log4j2LoggerAdapter implements LoggerAdapter {\n     private Level level;\n     public Log4j2LoggerAdapter() {\n+        try {\n+            org.apache.logging.log4j.Logger logger = LogManager.getRootLogger();\n+            this.level = fromLog4j2Level(logger.getLevel());\n+        } catch (Exception t) {\n+            // ignore\n+        }\n     }\n     private static org.apache.logging.log4j.Level toLog4j2Level(Level level) {\n@@ -94,6 +101,7 @@ public Level getLevel() {\n     @Override\n     public void setLevel(Level level) {\n         this.level = level;\n+        Configurator.setLevel(LogManager.getRootLogger(), toLog4j2Level(level));\n     }\n     @Override\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java b/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.common.logger.slf4j;\n+import org.apache.dubbo.common.logger.Level;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.support.FailsafeLogger;\n@@ -198,4 +199,27 @@ public boolean isErrorEnabled() {\n         return logger.isErrorEnabled();\n     }\n+    public static Level getLevel(org.slf4j.Logger logger) {\n+        if (logger.isTraceEnabled()) {\n+            return Level.TRACE;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            return Level.DEBUG;\n+        }\n+        if (logger.isInfoEnabled()) {\n+            return Level.INFO;\n+        }\n+        if (logger.isWarnEnabled()) {\n+            return Level.WARN;\n+        }\n+        if (logger.isErrorEnabled()) {\n+            return Level.ERROR;\n+        }\n+        return Level.OFF;\n+    }\n+\n+    public Level getLevel() {\n+        return getLevel(logger);\n+    }\n+\n }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLoggerAdapter.java b/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLoggerAdapter.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLoggerAdapter.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLoggerAdapter.java\n@@ -20,14 +20,21 @@\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerAdapter;\n import org.apache.dubbo.common.utils.ClassUtils;\n-\n+import org.slf4j.LoggerFactory;\n import java.io.File;\n public class Slf4jLoggerAdapter implements LoggerAdapter {\n     public static final String NAME = \"slf4j\";\n+\n     private Level level;\n     private File file;\n+    private static final org.slf4j.Logger ROOT_LOGGER = LoggerFactory.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);\n+\n+    public Slf4jLoggerAdapter() {\n+        this.level = Slf4jLogger.getLevel(ROOT_LOGGER);\n+    }\n+\n     @Override\n     public Logger getLogger(String key) {\n         return new Slf4jLogger(org.slf4j.LoggerFactory.getLogger(key));\n@@ -45,6 +52,7 @@ public Level getLevel() {\n     @Override\n     public void setLevel(Level level) {\n+        System.err.printf(\"The level of slf4j logger current can not be set, using the default level: %s \\n\", Slf4jLogger.getLevel(ROOT_LOGGER));\n         this.level = level;\n     }",
    "output": "Fix log level is null in Slf4j and fix not valid in Log4j2 * fix log level is null in Slf4j and fix not valid in Log4j2 * format logger code * format logger code * format logger code * format logger code * fix npe"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -640,4 +640,5 @@ public interface CommonConstants {\n     String SERVICE_DEPLOYER_ATTRIBUTE_KEY = \"serviceDeployer\";\n     String RESTEASY_NETTY_HTTP_REQUEST_ATTRIBUTE_KEY = \"resteasyNettyHttpRequest\";\n+    String DUBBO_MANUAL_REGISTER_KEY = \"dubbo.application.manual-register\";\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -310,7 +310,9 @@ public void export(RegisterTypeEnum registerType) {\n                 if (shouldDelay()) {\n                     // should register if delay export\n                     doDelayExport();\n-                } else if (Integer.valueOf(-1).equals(getDelay())) {\n+                } else if (\n+                    Boolean.parseBoolean(ConfigurationUtils.getProperty(\n+                        getScopeModel(), CommonConstants.DUBBO_MANUAL_REGISTER_KEY, \"false\"))) {\n                     // should not register by default\n                     doExport(RegisterTypeEnum.MANUAL_REGISTER);\n                 } else {",
    "output": "Remove -1 delay usage"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -642,4 +642,5 @@ public interface CommonConstants {\n     String SERVICE_DEPLOYER_ATTRIBUTE_KEY = \"serviceDeployer\";\n     String RESTEASY_NETTY_HTTP_REQUEST_ATTRIBUTE_KEY = \"resteasyNettyHttpRequest\";\n+    String DUBBO_MANUAL_REGISTER_KEY = \"dubbo.application.manual-register\";\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -310,7 +310,9 @@ public void export(RegisterTypeEnum registerType) {\n                 if (shouldDelay()) {\n                     // should register if delay export\n                     doDelayExport();\n-                } else if (Integer.valueOf(-1).equals(getDelay())) {\n+                } else if (\n+                    Boolean.parseBoolean(ConfigurationUtils.getProperty(\n+                        getScopeModel(), CommonConstants.DUBBO_MANUAL_REGISTER_KEY, \"false\"))) {\n                     // should not register by default\n                     doExport(RegisterTypeEnum.MANUAL_REGISTER);\n                 } else {",
    "output": "Remove -1 delay usage"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n@@ -188,6 +188,9 @@ private MethodMetric calcWindowCounter(RequestEvent event, MetricsKey targetKey)\n     @Override\n     public List<MetricSample> collect() {\n         List<MetricSample> list = new ArrayList<>();\n+        if (!isCollectEnabled()){\n+            return list;\n+        }\n         collectRequests(list);\n         collectQPS(list);\n         collectRT(list);",
    "output": "Add enable collect judgment * add Enable Collect Judgment * add Enable Collect Judgment"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n@@ -51,6 +51,7 @@\n import java.nio.charset.StandardCharsets;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n@@ -481,13 +482,14 @@ public void process(WatchedEvent event) throws Exception {\n             }\n             if (childListener != null) {\n-                Runnable task = () -> {\n-                    try {\n-                        childListener.childChanged(path, client.getChildren().usingWatcher(CuratorWatcherImpl.this).forPath(path));\n-                    } catch (Exception e) {\n-                        logger.warn(REGISTRY_ZOOKEEPER_EXCEPTION, \"\", \"\", \"client get children error\", e);\n-                    }\n-                };\n+                Runnable task = () -> Optional.ofNullable(childListener)\n+                    .ifPresent(c -> {\n+                        try {\n+                            c.childChanged(path, client.getChildren().usingWatcher(CuratorWatcherImpl.this).forPath(path));\n+                        } catch (Exception e) {\n+                            logger.warn(REGISTRY_ZOOKEEPER_EXCEPTION, \"\", \"\", \"client get children error\", e);\n+                        }\n+                    });\n                 initExecutorIfNecessary();\n                 if (!closed && CURATOR_WATCHER_EXECUTOR_SERVICE != null) {\n                     CURATOR_WATCHER_EXECUTOR_SERVICE.execute(task);",
    "output": "Fix CuratorWatch unwatch , childListener is null"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n@@ -31,6 +31,7 @@\n import org.apache.dubbo.config.spring.schema.DubboBeanDefinitionParser;\n import org.apache.dubbo.config.spring.util.LazyTargetInvocationHandler;\n import org.apache.dubbo.config.spring.util.LazyTargetSource;\n+import org.apache.dubbo.config.spring.util.LockUtils;\n import org.apache.dubbo.config.support.Parameter;\n import org.apache.dubbo.rpc.proxy.AbstractProxyFactory;\n@@ -43,7 +44,6 @@\n import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\n import org.springframework.beans.factory.config.BeanDefinition;\n import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n-import org.springframework.beans.factory.support.DefaultSingletonBeanRegistry;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationContextAware;\n@@ -396,7 +396,7 @@ private Object getCallProxy() throws Exception {\n         if (referenceConfig.configInitialized()) {\n             return referenceConfig.get();\n         }\n-        synchronized (((DefaultSingletonBeanRegistry)getBeanFactory()).getSingletonMutex()) {\n+        synchronized (LockUtils.getSingletonMutex(applicationContext)) {\n             return referenceConfig.get();\n         }\n     }\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java\n@@ -25,12 +25,12 @@\n import org.apache.dubbo.config.spring.context.event.DubboApplicationStateEvent;\n import org.apache.dubbo.config.spring.context.event.DubboModuleStateEvent;\n import org.apache.dubbo.config.spring.util.DubboBeanUtils;\n+import org.apache.dubbo.config.spring.util.LockUtils;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.ModelConstants;\n import org.apache.dubbo.rpc.model.ModuleModel;\n import org.springframework.beans.BeansException;\n-import org.springframework.beans.factory.support.DefaultSingletonBeanRegistry;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationContextAware;\n import org.springframework.context.ApplicationListener;\n@@ -147,7 +147,7 @@ public void onApplicationEvent(ApplicationContextEvent event) {\n     private void onContextRefreshedEvent(ContextRefreshedEvent event) {\n         ModuleDeployer deployer = moduleModel.getDeployer();\n         Assert.notNull(deployer, \"Module deployer is null\");\n-        Object singletonMutex = ((DefaultSingletonBeanRegistry) applicationContext.getAutowireCapableBeanFactory()).getSingletonMutex();\n+        Object singletonMutex = LockUtils.getSingletonMutex(applicationContext);\n         // start module\n         Future future = null;\n         synchronized (singletonMutex) {\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/LockUtils.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/LockUtils.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/LockUtils.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/LockUtils.java\n@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.config.spring.util;\n+\n+import org.springframework.beans.factory.support.DefaultSingletonBeanRegistry;\n+import org.springframework.context.ApplicationContext;\n+\n+import java.lang.reflect.Method;\n+\n+public class LockUtils {\n+\n+    private static final String DUBBO_SINGLETON_MUTEX_KEY = \"DUBBO_SINGLETON_MUTEX\";\n+\n+    /**\n+     * Get the mutex to lock the singleton in the specified {@link ApplicationContext}\n+     */\n+    public static synchronized Object getSingletonMutex(ApplicationContext applicationContext) {\n+        DefaultSingletonBeanRegistry autowireCapableBeanFactory = (DefaultSingletonBeanRegistry) applicationContext.getAutowireCapableBeanFactory();\n+        try {\n+            return autowireCapableBeanFactory.getSingletonMutex();\n+        } catch (Throwable t1) {\n+            try {\n+                // try protected\n+                Method method = DefaultSingletonBeanRegistry.class.getDeclaredMethod(\"getSingletonMutex\");\n+                method.setAccessible(true);\n+                return method.invoke(autowireCapableBeanFactory);\n+            } catch (Throwable t2) {\n+                // Before Spring 4.2, there is no getSingletonMutex method\n+                if (!autowireCapableBeanFactory.containsSingleton(DUBBO_SINGLETON_MUTEX_KEY)) {\n+                    autowireCapableBeanFactory.registerSingleton(DUBBO_SINGLETON_MUTEX_KEY, new Object());\n+                }\n+                return autowireCapableBeanFactory.getSingleton(DUBBO_SINGLETON_MUTEX_KEY);\n+            }\n+        }\n+    }\n+}",
    "output": "Fix compact with spring 3.2.x"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/AbstractConnectionClient.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/AbstractConnectionClient.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/AbstractConnectionClient.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/AbstractConnectionClient.java\n@@ -49,6 +49,9 @@ public abstract class AbstractConnectionClient extends AbstractClient {\n     protected AbstractConnectionClient(URL url, ChannelHandler handler) throws RemotingException {\n         super(url, handler);\n+    }\n+\n+    public final void increase() {\n         COUNTER_UPDATER.set(this, 1L);\n     }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java\n@@ -89,6 +89,7 @@ protected void initConnectionClient() {\n         this.channel = new AtomicReference<>();\n         this.closePromise = new DefaultPromise<>(GlobalEventExecutor.INSTANCE);\n         this.init = new AtomicBoolean(false);\n+        this.increase();\n     }\n     @Override",
    "output": "Fix netty close when init count is 0"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -64,7 +64,6 @@\n import static org.apache.dubbo.common.constants.CommonConstants.ENABLED_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_INIT_SERIALIZATION_OPTIMIZER;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REFER_INVOKER;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_UNSUPPORTED;\n@@ -131,7 +130,7 @@ public void subscribe(URL url) {\n         }\n         ApplicationModel applicationModel = url.getApplicationModel();\n-        MetricsEventBus.post(RegistryEvent.toSubscribeEvent(applicationModel),() ->\n+        MetricsEventBus.post(RegistryEvent.toSubscribeEvent(applicationModel), () ->\n             {\n                 super.subscribe(url);\n                 return null;\n@@ -503,7 +502,7 @@ private URL mergeUrl(URL providerUrl) {\n         // FIXME, kept for mock\n         if (providerUrl.hasParameter(MOCK_KEY) || providerUrl.getAnyMethodParameter(MOCK_KEY) != null) {\n-            providerUrl = providerUrl.removeParameter(TAG_KEY);\n+            providerUrl = providerUrl.removeParameter(MOCK_KEY);\n         }\n         if ((providerUrl.getPath() == null || providerUrl.getPath()",
    "output": "Fix tag key been deleted"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n@@ -555,6 +555,16 @@ public URL addConsumerParams(String protocolServiceKey, Map<String, String> para\n      */\n     @Override\n     public String getAnyMethodParameter(String key) {\n+        if (consumerParamFirst(key)) {\n+            URL consumerUrl = RpcContext.getServiceContext().getConsumerUrl();\n+            if (consumerUrl != null) {\n+                String v = consumerUrl.getAnyMethodParameter(key);\n+                if (StringUtils.isNotEmpty(v)) {\n+                    return v;\n+                }\n+            }\n+        }\n+\n         String suffix = \".\" + key;\n         String protocolServiceKey = getProtocolServiceKey();\n         if (StringUtils.isNotEmpty(protocolServiceKey)) {",
    "output": "Fix anyMethodParameter using consumer first"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java\n@@ -30,6 +30,7 @@\n import org.apache.dubbo.rpc.model.ModuleModel;\n import org.springframework.beans.BeansException;\n+import org.springframework.beans.factory.support.DefaultSingletonBeanRegistry;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationContextAware;\n import org.springframework.context.ApplicationListener;\n@@ -146,8 +147,12 @@ public void onApplicationEvent(ApplicationContextEvent event) {\n     private void onContextRefreshedEvent(ContextRefreshedEvent event) {\n         ModuleDeployer deployer = moduleModel.getDeployer();\n         Assert.notNull(deployer, \"Module deployer is null\");\n+        Object singletonMutex = ((DefaultSingletonBeanRegistry) applicationContext.getAutowireCapableBeanFactory()).getSingletonMutex();\n         // start module\n-        Future future = deployer.start();\n+        Future future = null;\n+        synchronized (singletonMutex) {\n+            future = deployer.start();\n+        }\n         // if the module does not start in background, await finish\n         if (!deployer.isBackground()) {\n@@ -177,7 +182,7 @@ private void onContextClosedEvent(ContextClosedEvent event) {\n     @Override\n     public int getOrder() {\n-        return LOWEST_PRECEDENCE;\n+        return HIGHEST_PRECEDENCE;\n     }\n }",
    "output": "Fix deadlock when starting"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java\n@@ -119,8 +119,6 @@ public class DubboMergingDigest extends DubboAbstractTDigest {\n     // weight limits.\n     public static boolean useWeightLimit = true;\n-    private volatile boolean merging = false;\n-\n     /**\n      * Allocates a buffer merging t-digest.  This is the normally used constructor that\n      * allocates default sized internal arrays.  Other versions are available, but should\n@@ -286,16 +284,13 @@ private void add(double x, int w, List<Double> history) {\n         if (Double.isNaN(x)) {\n             throw new IllegalArgumentException(\"Cannot add NaN to t-digest\");\n         }\n-        while (merging) {\n-            try {\n-                Thread.sleep(10);\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n+\n+        synchronized (this) {\n+            // There is a small probability of entering here\n+            if (tempUsed.get() >= tempWeight.length - lastUsedCell.get() - 1) {\n+                mergeNewValues();\n             }\n         }\n-        if (tempUsed.get() >= tempWeight.length - lastUsedCell.get() - 1) {\n-            mergeNewValues();\n-        }\n         int where = tempUsed.getAndIncrement();\n         tempWeight[where] = w;\n         tempMean[where] = x;\n@@ -326,13 +321,8 @@ public void add(List<? extends TDigest> others) {\n         throw new MetricsNeverHappenException(\"Method not used\");\n     }\n-    private synchronized void mergeNewValues() {\n-        merging = true;\n-        try {\n-            mergeNewValues(false, compression);\n-        } finally {\n-            merging = false;\n-        }\n+    private void mergeNewValues() {\n+        mergeNewValues(false, compression);\n     }\n     private void mergeNewValues(boolean force, double compression) {\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java\n@@ -46,8 +46,9 @@ void testMulti() {\n         while (index < 100) {\n             for (int i = 0; i < 100; i++) {\n                 int finalI = i;\n+                Assertions.assertDoesNotThrow(() -> quantile.add(finalI));\n                 executorService.execute(() ->\n-                    Assertions.assertDoesNotThrow(() -> quantile.add(finalI)));\n+                    quantile.add(finalI));\n             }\n             index++;\n             try {",
    "output": "Fix digest thread_safe bug * fix thread_safe bug * fix thread_safe bug * remove unused * add comment"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.utils.StringUtils;\n+import java.security.SecureRandom;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -28,7 +29,7 @@\n  */\n public class Request {\n-    private static final AtomicLong INVOKE_ID = new AtomicLong(ThreadLocalRandom.current().nextLong());\n+    private static final AtomicLong INVOKE_ID;\n     private final long mId;\n@@ -50,6 +51,16 @@ public Request(long id) {\n         mId = id;\n     }\n+    static {\n+        long startID = ThreadLocalRandom.current().nextLong();\n+        try {\n+            SecureRandom rand = new SecureRandom(SecureRandom.getSeed(20));\n+            startID = rand.nextLong();\n+        } catch (Throwable ignore) {\n+        }\n+        INVOKE_ID = new AtomicLong(startID);\n+    }\n+\n     private static long newId() {\n         // getAndIncrement() When it grows to MAX_VALUE, it will grow to MIN_VALUE, and the negative can be used as ID\n         return INVOKE_ID.getAndIncrement();",
    "output": "Use secure random"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanManager.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanManager.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanManager.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanManager.java\n@@ -189,6 +189,7 @@ private synchronized void initReferenceBean(ReferenceBean referenceBean) throws\n             // register ReferenceConfig\n             moduleModel.getConfigManager().addReference(referenceConfig);\n+            moduleModel.getDeployer().setPending();\n         }\n         // associate referenceConfig to referenceBean",
    "output": "Fix reference bean has not been init if deployer is early started"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.utils.StringUtils;\n+import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.atomic.AtomicLong;\n import static org.apache.dubbo.common.constants.CommonConstants.HEARTBEAT_EVENT;\n@@ -27,7 +28,7 @@\n  */\n public class Request {\n-    private static final AtomicLong INVOKE_ID = new AtomicLong(0);\n+    private static final AtomicLong INVOKE_ID = new AtomicLong(ThreadLocalRandom.current().nextLong());\n     private final long mId;\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/RequestTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/RequestTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/RequestTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/RequestTest.java\n@@ -23,6 +23,8 @@ class RequestTest {\n     @Test\n     void test() {\n+        Request requestStart = new Request();\n+\n         Request request = new Request();\n         request.setTwoWay(true);\n         request.setBroken(true);\n@@ -35,7 +37,7 @@ void test() {\n         Assertions.assertTrue(request.isEvent());\n         Assertions.assertEquals(request.getVersion(), \"1.0.0\");\n         Assertions.assertEquals(request.getData(), \"data\");\n-        Assertions.assertTrue(request.getId() >= 0);\n+        Assertions.assertEquals(requestStart.getId() + 1, request.getId());\n         request.setHeartbeat(true);\n         Assertions.assertTrue(request.isHeartbeat());",
    "output": "Use random id * Use random id * Fix uts"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java\n@@ -33,7 +33,7 @@\n import java.util.Date;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n import java.util.concurrent.TimeUnit;\n public class DeadlineFuture extends CompletableFuture<AppResponse> {\n@@ -46,7 +46,7 @@ public class DeadlineFuture extends CompletableFuture<AppResponse> {\n     private final long start = System.currentTimeMillis();\n     private final List<Runnable> timeoutListeners = new ArrayList<>();\n     private final Timeout timeoutTask;\n-    private Executor executor;\n+    private ExecutorService executor;\n     private DeadlineFuture(String serviceName, String methodName, String address, int timeout) {\n         this.serviceName = serviceName;\n@@ -69,7 +69,7 @@ public static void destroy() {\n      * @return a new DeadlineFuture\n      */\n     public static DeadlineFuture newFuture(String serviceName, String methodName, String address,\n-        int timeout, Executor executor) {\n+        int timeout, ExecutorService executor) {\n         final DeadlineFuture future = new DeadlineFuture(serviceName, methodName, address, timeout);\n         future.setExecutor(executor);\n         return future;\n@@ -99,11 +99,11 @@ public List<Runnable> getTimeoutListeners() {\n         return timeoutListeners;\n     }\n-    public Executor getExecutor() {\n+    public ExecutorService getExecutor() {\n         return executor;\n     }\n-    public void setExecutor(Executor executor) {\n+    public void setExecutor(ExecutorService executor) {\n         this.executor = executor;\n     }\n@@ -149,8 +149,9 @@ public void run(Timeout timeout) {\n                 return;\n             }\n-            if (getExecutor() != null) {\n-                getExecutor().execute(() -> {\n+            ExecutorService executor = getExecutor();\n+            if (executor != null && !executor.isShutdown()) {\n+                executor.execute(() -> {\n                     notifyTimeout();\n                     for (Runnable timeoutListener : getTimeoutListeners()) {\n                         timeoutListener.run();\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -63,7 +63,6 @@\n import java.util.Objects;\n import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.locks.ReentrantLock;\n@@ -135,7 +134,7 @@ protected Result doInvoke(final Invocation invocation) {\n         final MethodDescriptor methodDescriptor = serviceDescriptor.getMethod(\n             invocation.getMethodName(),\n             invocation.getParameterTypes());\n-        Executor callbackExecutor = isSync(methodDescriptor, invocation) ? new ThreadlessExecutor() : streamExecutor;\n+        ExecutorService callbackExecutor = isSync(methodDescriptor, invocation) ? new ThreadlessExecutor() : streamExecutor;\n         ClientCall call = new TripleClientCall(connectionClient, callbackExecutor,\n             getUrl().getOrDefaultFrameworkModel(), writeQueue);\n         AsyncRpcResult result;\n@@ -219,7 +218,7 @@ StreamObserver<Object> streamCall(ClientCall call,\n     }\n     AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocation,\n-                               ClientCall call, Executor callbackExecutor) {\n+                               ClientCall call, ExecutorService callbackExecutor) {\n         int timeout = RpcUtils.calculateTimeout(getUrl(), invocation, RpcUtils.getMethodName(invocation), 3000);\n         if (timeout <= 0) {",
    "output": "Fix throw RejectedExecutionException * fix throw RejectedExecutionException * fix throw RejectedExecutionException when ThreadlessExecutor has been shutdown"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java\n@@ -146,16 +146,19 @@ public static int getServerShutdownTimeout(ScopeModel scopeModel) {\n         return timeout;\n     }\n-    public static int reCalShutdownTime(int expectedShutdownTime) {\n+    public static int reCalShutdownTime(int expected) {\n+        // already timeout\n         if (expectedShutdownTime < System.currentTimeMillis()) {\n             return 1;\n         }\n-        if (expectedShutdownTime - System.currentTimeMillis() < expectedShutdownTime) {\n+        if (expectedShutdownTime - System.currentTimeMillis() < expected) {\n+            // the shutdown time rest is less than expected\n             return (int) Math.max(1, expectedShutdownTime - System.currentTimeMillis());\n         }\n-        return expectedShutdownTime;\n+        // return the expected\n+        return expected;\n     }\n     public static void setExpectedShutdownTime(long expectedShutdownTime) {",
    "output": "Fix shutdown timeout override"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java\n@@ -63,6 +63,13 @@ public interface Constants {\n      */\n     long LEAST_HEARTBEAT_DURATION = 1000;\n+    /**\n+     * the least reconnect during is 60000 ms.\n+     */\n+    long LEAST_RECONNECT_DURATION = 60000;\n+\n+    String LEAST_RECONNECT_DURATION_KEY = \"dubbo.application.least-reconnect-duration\";\n+\n     /**\n      * ticks per wheel.\n      */\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java\n@@ -37,6 +37,8 @@\n import static org.apache.dubbo.remoting.Constants.HEARTBEAT_CHECK_TICK;\n import static org.apache.dubbo.remoting.Constants.LEAST_HEARTBEAT_DURATION;\n+import static org.apache.dubbo.remoting.Constants.LEAST_RECONNECT_DURATION;\n+import static org.apache.dubbo.remoting.Constants.LEAST_RECONNECT_DURATION_KEY;\n import static org.apache.dubbo.remoting.Constants.TICKS_PER_WHEEL;\n import static org.apache.dubbo.remoting.utils.UrlUtils.getHeartbeat;\n import static org.apache.dubbo.remoting.utils.UrlUtils.getIdleTimeout;\n@@ -214,7 +216,8 @@ private void startHeartBeatTask(URL url) {\n     private void startReconnectTask(URL url) {\n         if (shouldReconnect(url)) {\n             long heartbeatTimeoutTick = calculateLeastDuration(idleTimeout);\n-            reconnectTimerTask = new ReconnectTimerTask(() -> Collections.singleton(this), IDLE_CHECK_TIMER.get(), heartbeatTimeoutTick, idleTimeout);\n+            reconnectTimerTask = new ReconnectTimerTask(() -> Collections.singleton(this), IDLE_CHECK_TIMER.get(),\n+                calculateReconnectDuration(url, heartbeatTimeoutTick), idleTimeout);\n         }\n     }\n@@ -240,6 +243,11 @@ private long calculateLeastDuration(int time) {\n         }\n     }\n+    private long calculateReconnectDuration(URL url, long tick) {\n+        long leastReconnectDuration = url.getParameter(LEAST_RECONNECT_DURATION_KEY, LEAST_RECONNECT_DURATION);\n+        return Math.max(leastReconnectDuration, tick);\n+    }\n+\n     private boolean shouldReconnect(URL url) {\n         return url.getParameter(Constants.RECONNECT_KEY, true);\n     }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty/src/test/java/org/apache/dubbo/remoting/transport/netty/ClientReconnectTest.java b/dubbo-remoting/dubbo-remoting-netty/src/test/java/org/apache/dubbo/remoting/transport/netty/ClientReconnectTest.java\n--- a/dubbo-remoting/dubbo-remoting-netty/src/test/java/org/apache/dubbo/remoting/transport/netty/ClientReconnectTest.java\n+++ b/dubbo-remoting/dubbo-remoting-netty/src/test/java/org/apache/dubbo/remoting/transport/netty/ClientReconnectTest.java\n@@ -29,11 +29,13 @@\n import org.apache.dubbo.remoting.exchange.support.ExchangeHandlerAdapter;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n+\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import static org.apache.dubbo.common.constants.CommonConstants.EXECUTOR_MANAGEMENT_MODE_DEFAULT;\n+import static org.apache.dubbo.remoting.Constants.LEAST_RECONNECT_DURATION_KEY;\n /**\n  * Client reconnect test\n@@ -76,7 +78,7 @@ void testReconnect() throws RemotingException, InterruptedException {\n     public Client startClient(int port, int heartbeat) throws RemotingException {\n         URL url = URL.valueOf(\"exchange://127.0.0.1:\" + port + \"/client.reconnect.test?check=false&codec=exchange&client=netty3&\" +\n-            Constants.HEARTBEAT_KEY + \"=\" + heartbeat);\n+            Constants.HEARTBEAT_KEY + \"=\" + heartbeat + \"&\" + LEAST_RECONNECT_DURATION_KEY + \"=0\");\n         ApplicationModel applicationModel = ApplicationModel.defaultModel();\n         ApplicationConfig applicationConfig = new ApplicationConfig(\"provider-app\");\n         applicationConfig.setExecutorManagementMode(EXECUTOR_MANAGEMENT_MODE_DEFAULT);\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ClientReconnectTest.java b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ClientReconnectTest.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ClientReconnectTest.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ClientReconnectTest.java\n@@ -32,11 +32,13 @@\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ModuleModel;\n+\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import static org.apache.dubbo.common.constants.CommonConstants.EXECUTOR_MANAGEMENT_MODE_DEFAULT;\n+import static org.apache.dubbo.remoting.Constants.LEAST_RECONNECT_DURATION_KEY;\n /**\n  * Client reconnect test\n@@ -81,7 +83,8 @@ void testReconnect() throws RemotingException, InterruptedException {\n     public Client startClient(int port, int heartbeat) throws RemotingException {\n-        URL url = URL.valueOf(\"exchange://127.0.0.1:\" + port + \"/client.reconnect.test?client=netty4&check=false&\" + Constants.HEARTBEAT_KEY + \"=\" + heartbeat);\n+        URL url = URL.valueOf(\"exchange://127.0.0.1:\" + port + \"/client.reconnect.test?client=netty4&check=false&\" +\n+            Constants.HEARTBEAT_KEY + \"=\" + heartbeat + \"&\" + LEAST_RECONNECT_DURATION_KEY + \"=0\");\n         FrameworkModel frameworkModel = new FrameworkModel();\n         ApplicationModel applicationModel = frameworkModel.newApplication();\n         ApplicationConfig applicationConfig = new ApplicationConfig(\"provider-app\");",
    "output": "Upgrade minimal reconnect period"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalance.java\n@@ -110,7 +110,7 @@ private int getTimeout(Invoker<?> invoker, Invocation invocation) {\n     private <T> Invoker<T> chooseLowLoadInvoker(Invoker<T> invoker1,Invoker<T> invoker2,Invocation invocation){\n         int weight1 = getWeight(invoker1, invocation);\n         int weight2 = getWeight(invoker2, invocation);\n-        int timeout1 = getTimeout(invoker2, invocation);\n+        int timeout1 = getTimeout(invoker1, invocation);\n         int timeout2 = getTimeout(invoker2, invocation);\n         long load1 = Double.doubleToLongBits(adaptiveMetrics.getLoad(getServiceKey(invoker1,invocation),weight1,timeout1 ));\n         long load2 = Double.doubleToLongBits(adaptiveMetrics.getLoad(getServiceKey(invoker2,invocation),weight2,timeout2 ));",
    "output": "Upgrade AdaptiveLoadBalance.java fix getTimeout bug"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n@@ -379,7 +379,7 @@ protected Result invokeWithContext(Invoker<T> invoker, Invocation invocation) {\n             if (ProfilerSwitch.isEnableSimpleProfiler()) {\n                 InvocationProfilerUtils.enterProfiler(invocation, \"Invoker invoke. Target Address: \" + invoker.getUrl().getAddress());\n             }\n-            invocation.addInvokedInvoker(invoker);\n+            setRemote(invoker, invocation);\n             result = invoker.invoke(invocation);\n         } finally {\n             clearContext(originInvoker);\n@@ -388,6 +388,17 @@ protected Result invokeWithContext(Invoker<T> invoker, Invocation invocation) {\n         return result;\n     }\n+    /**\n+     * Set the remoteAddress and remoteApplicationName so that filter can get them.\n+     *\n+     */\n+    private void setRemote(Invoker<?> invoker, Invocation invocation) {\n+        invocation.addInvokedInvoker(invoker);\n+        RpcServiceContext serviceContext = RpcContext.getServiceContext();\n+        serviceContext.setRemoteAddress(invoker.getUrl().toInetSocketAddress());\n+        serviceContext.setRemoteApplicationName(invoker.getUrl().getRemoteApplication());\n+    }\n+\n     /**\n      * When using a thread pool to fork a child thread, ThreadLocal cannot be passed.\n      * In this scenario, please use the invokeWithContextAsync method.\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n@@ -34,7 +34,6 @@\n import org.apache.dubbo.rpc.InvokeMode;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n-import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.protocol.AbstractInvoker;\n@@ -111,8 +110,6 @@ protected Result doInvoke(final Invocation invocation) throws Throwable {\n             invocation.setAttachment(TIMEOUT_KEY, String.valueOf(timeout));\n-            RpcContext.getServiceContext().setRemoteAddress(currentClient.getRemoteAddress());\n-\n             Integer payload = getUrl().getParameter(PAYLOAD, Integer.class);\n             Request request = new Request();",
    "output": "Fix the consumer remoteApplication is null * fix the consumer remoteApplication is null * fix the consumer remoteApplication is null * fix the consumer remoteApplication is null * fix the consumer remoteApplication is null"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -425,9 +425,6 @@ public final void setScopeModel(ScopeModel scopeModel) {\n     }\n     protected void checkScopeModel(ScopeModel scopeModel) {\n-        if (scopeModel == null) {\n-            throw new IllegalArgumentException(\"scopeModel cannot be null\");\n-        }\n         if (!(scopeModel instanceof ApplicationModel)) {\n             throw new IllegalArgumentException(\"Invalid scope model, expect to be a ApplicationModel but got: \" + scopeModel);\n         }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractMethodConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractMethodConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractMethodConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractMethodConfig.java\n@@ -103,7 +103,7 @@ public abstract class AbstractMethodConfig extends AbstractConfig {\n     protected Integer forks;\n     public AbstractMethodConfig() {\n-        super();\n+\n     }\n     public AbstractMethodConfig(ModuleModel moduleModel) {\n@@ -124,9 +124,6 @@ protected ScopeModel getDefaultModel() {\n     @Override\n     protected void checkScopeModel(ScopeModel scopeModel) {\n-        if (scopeModel == null) {\n-            throw new IllegalArgumentException(\"scopeModel cannot be null\");\n-        }\n         if (!(scopeModel instanceof ModuleModel)) {\n             throw new IllegalArgumentException(\"Invalid scope model, expect to be a ModuleModel but got: \" + scopeModel);\n         }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ModuleConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ModuleConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ModuleConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ModuleConfig.java\n@@ -127,9 +127,6 @@ protected void checkDefault() {\n     @Override\n     protected void checkScopeModel(ScopeModel scopeModel) {\n-        if (scopeModel == null) {\n-            throw new IllegalArgumentException(\"scopeModel cannot be null\");\n-        }\n         if (!(scopeModel instanceof ModuleModel)) {\n             throw new IllegalArgumentException(\"Invalid scope model, expect to be a ModuleModel but got: \" + scopeModel);\n         }",
    "output": "Remove unnecessary code"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -632,6 +632,8 @@ public interface CommonConstants {\n     String DUBBO_PACKABLE_METHOD_FACTORY = \"dubbo.application.parameters.\" + PACKABLE_METHOD_FACTORY_KEY;\n+    String DUBBO_TAG_HEADER = \"dubbo-tag\";\n+\n     String REST_SERVICE_DEPLOYER_URL_ATTRIBUTE_KEY = \"restServiceDeployerAttributeKey\";\n }\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-interceptor/src/main/java/org/apache/dubbo/spring/boot/interceptor/DubboTagCookieInterceptor.java b/dubbo-spring-boot/dubbo-spring-boot-interceptor/src/main/java/org/apache/dubbo/spring/boot/interceptor/DubboTagCookieInterceptor.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-interceptor/src/main/java/org/apache/dubbo/spring/boot/interceptor/DubboTagCookieInterceptor.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-interceptor/src/main/java/org/apache/dubbo/spring/boot/interceptor/DubboTagCookieInterceptor.java\n@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.spring.boot.interceptor;\n+\n+import org.apache.dubbo.common.constants.CommonConstants;\n+import org.apache.dubbo.rpc.RpcContext;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+public class DubboTagCookieInterceptor implements HandlerInterceptor {\n+\n+    @Override\n+    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n+        String tag = getSingleCookieValue(request.getCookies(), CommonConstants.TAG_KEY);\n+        RpcContext.getClientAttachment().setAttachment(CommonConstants.TAG_KEY,tag);\n+        return true;\n+    }\n+\n+    @Override\n+    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n+        RpcContext.getClientAttachment().removeAttachment(CommonConstants.TAG_KEY);\n+    }\n+\n+    private static String getSingleCookieValue(Cookie[] cookies, String name){\n+        if (cookies == null || cookies.length == 0) {\n+            return null;\n+        }\n+        for (Cookie cookie: cookies) {\n+            if (name.equals(cookie.getName())) {\n+                return cookie.getValue();\n+            }\n+        }\n+        return null;\n+    }\n+\n+}\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-interceptor/src/main/java/org/apache/dubbo/spring/boot/interceptor/DubboTagHeaderOrParameterInterceptor.java b/dubbo-spring-boot/dubbo-spring-boot-interceptor/src/main/java/org/apache/dubbo/spring/boot/interceptor/DubboTagHeaderOrParameterInterceptor.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-interceptor/src/main/java/org/apache/dubbo/spring/boot/interceptor/DubboTagHeaderOrParameterInterceptor.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-interceptor/src/main/java/org/apache/dubbo/spring/boot/interceptor/DubboTagHeaderOrParameterInterceptor.java\n@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.spring.boot.interceptor;\n+\n+import org.apache.dubbo.common.constants.CommonConstants;\n+import org.apache.dubbo.rpc.RpcContext;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+public class DubboTagHeaderOrParameterInterceptor implements HandlerInterceptor {\n+\n+    @Override\n+    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n+        String tag = request.getHeader(CommonConstants.DUBBO_TAG_HEADER);\n+        if (tag == null) {\n+            tag = request.getParameter(CommonConstants.TAG_KEY);\n+        }\n+        if (tag != null) {\n+            RpcContext.getClientAttachment().setAttachment(CommonConstants.TAG_KEY, tag);\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n+        RpcContext.getClientAttachment().removeAttachment(CommonConstants.TAG_KEY);\n+    }\n+\n+}",
    "output": "Add spring boot interceptor to copy header(dubbo-tag)/cookie(dubbo.tag) * add spring boot interceptor to copy header(dubbo-tag)/cookie(dubbo.tag) * copy dubbo.tag in urlParameter * copy dubbo.tag in urlParameter * remove dubbo.tag in interceptor * add dubbo-spring-boot-interceptor to dubbo-dependencies-all/.artifacts/dubbo-bom ---------"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/Constants.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/Constants.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/Constants.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/Constants.java\n@@ -66,9 +66,9 @@ public interface Constants {\n     int DEFAULT_SESSION_TIMEOUT = 60 * 1000;\n     /**\n-     * Default value for the times of retry: 3\n+     * Default value for the times of retry: -1 (forever)\n      */\n-    int DEFAULT_REGISTRY_RETRY_TIMES = 3;\n+    int DEFAULT_REGISTRY_RETRY_TIMES = -1;\n     int DEFAULT_REGISTRY_RECONNECT_PERIOD = 3 * 1000;\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/AbstractRetryTask.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/AbstractRetryTask.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/AbstractRetryTask.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/AbstractRetryTask.java\n@@ -113,7 +113,7 @@ public void run(Timeout timeout) throws Exception {\n             // other thread cancel this timeout or stop the timer.\n             return;\n         }\n-        if (times > retryTimes) {\n+        if (retryTimes > 0 && times > retryTimes) {\n             // 1-13 - failed to execute the retrying task.\n             logger.warn(",
    "output": "Change retry times to forever"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/identifier/MetadataIdentifier.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/identifier/MetadataIdentifier.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/identifier/MetadataIdentifier.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/identifier/MetadataIdentifier.java\n@@ -97,4 +97,8 @@ public void setApplication(String application) {\n         this.application = application;\n     }\n+    public String getUniqueServiceName() {\n+        return serviceInterface != null ? URL.buildKey(serviceInterface, getGroup(), getVersion()) : null;\n+    }\n+\n }\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java\n@@ -279,7 +279,7 @@ public void storeProviderMetadata(MetadataIdentifier providerMetadataIdentifier,\n     private void storeProviderMetadataTask(MetadataIdentifier providerMetadataIdentifier, ServiceDefinition serviceDefinition) {\n-        MetadataEvent metadataEvent = MetadataEvent.toServiceSubscribeEvent(applicationModel, serviceDefinition.getCanonicalName());\n+        MetadataEvent metadataEvent = MetadataEvent.toServiceSubscribeEvent(applicationModel, providerMetadataIdentifier.getUniqueServiceName());\n         MetricsEventBus.post(metadataEvent, () ->\n             {\n                 boolean result = true;",
    "output": "Use serviceKey when to metadata ServiceSubscribeEvent"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n@@ -21,6 +21,8 @@\n import org.apache.dubbo.rpc.model.ModuleModel;\n import org.apache.dubbo.rpc.support.ProtocolUtils;\n+import java.beans.Transient;\n+\n import static org.apache.dubbo.common.constants.CommonConstants.INVOKER_LISTENER_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.REFERENCE_FILTER_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.REFER_ASYNC_KEY;\n@@ -184,6 +186,7 @@ public void setGeneric(String generic) {\n     }\n     @Override\n+    @Transient\n     protected boolean isNeedCheckMethod() {\n         return StringUtils.isEmpty(getGeneric());\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ModuleConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ModuleConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ModuleConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ModuleConfig.java\n@@ -22,6 +22,7 @@\n import org.apache.dubbo.rpc.model.ModuleModel;\n import org.apache.dubbo.rpc.model.ScopeModel;\n+import java.beans.Transient;\n import java.util.ArrayList;\n import java.util.List;\n@@ -135,11 +136,13 @@ protected void checkScopeModel(ScopeModel scopeModel) {\n     }\n     @Override\n+    @Transient\n     public ModuleModel getScopeModel() {\n         return (ModuleModel) super.getScopeModel();\n     }\n     @Override\n+    @Transient\n     protected ScopeModel getDefaultModel() {\n         return ApplicationModel.defaultModel().getDefaultModule();\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n@@ -150,6 +150,7 @@ public List<String> getPrefixes() {\n     }\n     @Override\n+    @Transient\n     public Map<String, String> getMetaData() {\n         return getMetaData(null);\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n@@ -180,6 +180,7 @@ protected void preProcessRefresh() {\n     }\n     @Override\n+    @Transient\n     public Map<String, String> getMetaData() {\n         return getMetaData(null);\n     }\ndiff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java\n@@ -17,14 +17,15 @@\n package com.alibaba.dubbo.rpc;\n+import org.apache.dubbo.rpc.model.ServiceModel;\n+\n+import java.beans.Transient;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.function.Consumer;\n-import org.apache.dubbo.rpc.model.ServiceModel;\n-\n @Deprecated\n public interface Invocation extends org.apache.dubbo.rpc.Invocation {\n@@ -184,6 +185,7 @@ public String getAttachment(String key, String defaultValue) {\n         }\n         @Override\n+        @Transient\n         public Invoker<?> getInvoker() {\n             return new Invoker.CompatibleInvoker(delegate.getInvoker());\n         }\ndiff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n@@ -17,16 +17,17 @@\n package com.alibaba.dubbo.rpc;\n+import com.alibaba.dubbo.common.Constants;\n+import com.alibaba.dubbo.common.URL;\n+\n+import java.beans.Transient;\n import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import com.alibaba.dubbo.common.Constants;\n-import com.alibaba.dubbo.common.URL;\n-\n public class RpcInvocation implements Invocation, Serializable {\n     private static final long serialVersionUID = -4355285085441097045L;\n@@ -101,6 +102,7 @@ public RpcInvocation(String methodName, Class<?>[] parameterTypes, Object[] argu\n         this.invoker = invoker;\n     }\n+    @Transient\n     public Invoker<?> getInvoker() {\n         return invoker;\n     }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceInstance.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceInstance.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceInstance.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceInstance.java\n@@ -103,6 +103,7 @@ default boolean isHealthy() {\n     void setApplicationModel(ApplicationModel applicationModel);\n+    @Transient\n     ApplicationModel getApplicationModel();\n     @Transient\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Invocation.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Invocation.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Invocation.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Invocation.java\n@@ -16,16 +16,17 @@\n  */\n package org.apache.dubbo.rpc;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n-\n import org.apache.dubbo.common.Experimental;\n import org.apache.dubbo.rpc.model.ModuleModel;\n import org.apache.dubbo.rpc.model.ScopeModelUtil;\n import org.apache.dubbo.rpc.model.ServiceModel;\n+import java.beans.Transient;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n /**\n  * Invocation. (API, Prototype, NonThreadSafe)\n  *\n@@ -148,6 +149,7 @@ default Object getObjectAttachmentWithoutConvert(String key) {\n      * @return invoker.\n      * @transient\n      */\n+    @Transient\n     Invoker<?> getInvoker();\n     void setServiceModel(ServiceModel serviceModel);",
    "output": "Add transient to some overrided field"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n@@ -94,7 +94,6 @@ public Result doInvoke(Invocation invocation) throws Throwable {\n         if (exporter == null) {\n             throw new RpcException(\"Service [\" + key + \"] not found.\");\n         }\n-        RpcContext.getServiceContext().setRemoteAddress(LOCALHOST_VALUE, 0);\n         // Solve local exposure, the server opens the token, and the client call fails.\n         Invoker<?> invoker = exporter.getInvoker();\n         URL serverURL = invoker.getUrl();\n@@ -122,16 +121,24 @@ public Result doInvoke(Invocation invocation) throws Throwable {\n             // use consumer executor\n             ExecutorService executor = executorRepository.createExecutorIfAbsent(ExecutorUtil.setThreadName(getUrl(), SERVER_THREAD_POOL_NAME));\n             CompletableFuture<AppResponse> appResponseFuture = CompletableFuture.supplyAsync(() -> {\n-                Result result = invoker.invoke(copiedInvocation);\n-                if (result.hasException()) {\n-                    AppResponse appResponse = new AppResponse(result.getException());\n-                    appResponse.setObjectAttachments(new HashMap<>(result.getObjectAttachments()));\n-                    return appResponse;\n-                } else {\n-                    rebuildValue(invocation, desc, result);\n-                    AppResponse appResponse = new AppResponse(result.getValue());\n-                    appResponse.setObjectAttachments(new HashMap<>(result.getObjectAttachments()));\n-                    return appResponse;\n+                // clear thread local before child invocation, prevent context pollution\n+                InternalThreadLocalMap originTL = InternalThreadLocalMap.getAndRemove();\n+                try {\n+                    RpcContext.getServiceContext().setRemoteAddress(LOCALHOST_VALUE, 0);\n+                    RpcContext.getServiceContext().setRemoteApplicationName(getUrl().getApplication());\n+                    Result result = invoker.invoke(copiedInvocation);\n+                    if (result.hasException()) {\n+                        AppResponse appResponse = new AppResponse(result.getException());\n+                        appResponse.setObjectAttachments(new HashMap<>(result.getObjectAttachments()));\n+                        return appResponse;\n+                    } else {\n+                        rebuildValue(invocation, desc, result);\n+                        AppResponse appResponse = new AppResponse(result.getValue());\n+                        appResponse.setObjectAttachments(new HashMap<>(result.getObjectAttachments()));\n+                        return appResponse;\n+                    }\n+                } finally {\n+                    InternalThreadLocalMap.set(originTL);\n                 }\n             }, executor);\n             // save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter\n@@ -144,6 +151,8 @@ public Result doInvoke(Invocation invocation) throws Throwable {\n             // clear thread local before child invocation, prevent context pollution\n             InternalThreadLocalMap originTL = InternalThreadLocalMap.getAndRemove();\n             try {\n+                RpcContext.getServiceContext().setRemoteAddress(LOCALHOST_VALUE, 0);\n+                RpcContext.getServiceContext().setRemoteApplicationName(getUrl().getApplication());\n                 result = invoker.invoke(copiedInvocation);\n             } finally {\n                 InternalThreadLocalMap.set(originTL);\ndiff --git a/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/DemoService.java b/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/DemoService.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/DemoService.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/DemoService.java\n@@ -40,4 +40,8 @@ public interface DemoService {\n     Type enumlength(Type... types);\n     String getAsyncResult();\n+\n+    String getApplication();\n+\n+    String getRemoteAddress();\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/DemoServiceImpl.java b/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/DemoServiceImpl.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/DemoServiceImpl.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/DemoServiceImpl.java\n@@ -80,4 +80,13 @@ public String getAsyncResult() {\n         return \"DONE\";\n     }\n+    @Override\n+    public String getApplication() {\n+        return RpcContext.getServiceContext().getRemoteApplicationName();\n+    }\n+\n+    @Override\n+    public String getRemoteAddress() {\n+        return RpcContext.getServiceContext().getRemoteAddressString();\n+    }\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocolTest.java b/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocolTest.java\n@@ -19,10 +19,13 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.rpc.Exporter;\n+import org.apache.dubbo.rpc.FutureContext;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Protocol;\n import org.apache.dubbo.rpc.ProxyFactory;\n+import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n@@ -32,7 +35,9 @@\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n@@ -129,7 +134,7 @@ void testIsInjvmRefer() {\n     }\n     @Test\n-    void testLocalProtocolAsync() {\n+    void testLocalProtocolAsync() throws ExecutionException, InterruptedException {\n         DemoService service = new DemoServiceImpl();\n         URL url = URL.valueOf(\"injvm://127.0.0.1/TestService\")\n             .addParameter(ASYNC_KEY, true)\n@@ -141,6 +146,39 @@ void testLocalProtocolAsync() {\n         exporters.add(exporter);\n         service = proxy.getProxy(protocol.refer(DemoService.class, url));\n         assertNull(service.getAsyncResult());\n+        assertEquals(\"DONE\", FutureContext.getContext().getCompletableFuture().get());\n+    }\n+\n+    @Test\n+    void testApplication() {\n+        DemoService service = new DemoServiceImpl();\n+        URL url = URL.valueOf(\"injvm://127.0.0.1/TestService\")\n+            .addParameter(INTERFACE_KEY, DemoService.class.getName()).addParameter(\"application\", \"consumer\")\n+            .addParameter(APPLICATION_KEY, \"test-app\")\n+            .setScopeModel(ApplicationModel.defaultModel().getDefaultModule());\n+        Invoker<?> invoker = proxy.getInvoker(service, DemoService.class, url);\n+        assertTrue(invoker.isAvailable());\n+        Exporter<?> exporter = protocol.export(invoker);\n+        exporters.add(exporter);\n+        service = proxy.getProxy(protocol.refer(DemoService.class, url));\n+        assertEquals(\"test-app\", service.getApplication());\n+        assertTrue(StringUtils.isEmpty(RpcContext.getServiceContext().getRemoteApplicationName()));\n+    }\n+\n+    @Test\n+    void testRemoteAddress() {\n+        DemoService service = new DemoServiceImpl();\n+        URL url = URL.valueOf(\"injvm://127.0.0.1/TestService\")\n+            .addParameter(INTERFACE_KEY, DemoService.class.getName()).addParameter(\"application\", \"consumer\")\n+            .addParameter(APPLICATION_KEY, \"test-app\")\n+            .setScopeModel(ApplicationModel.defaultModel().getDefaultModule());\n+        Invoker<?> invoker = proxy.getInvoker(service, DemoService.class, url);\n+        assertTrue(invoker.isAvailable());\n+        Exporter<?> exporter = protocol.export(invoker);\n+        exporters.add(exporter);\n+        service = proxy.getProxy(protocol.refer(DemoService.class, url));\n+        assertEquals(\"127.0.0.1:0\", service.getRemoteAddress());\n+        assertNull(RpcContext.getServiceContext().getRemoteAddress());\n     }\n }",
    "output": "Fix unable to getAppName in InjvmInvoker"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/aot/Netty4ReflectionTypeDescriberRegistrar.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/aot/Netty4ReflectionTypeDescriberRegistrar.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/aot/Netty4ReflectionTypeDescriberRegistrar.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/aot/Netty4ReflectionTypeDescriberRegistrar.java\n@@ -19,11 +19,15 @@\n import org.apache.dubbo.aot.api.MemberCategory;\n import org.apache.dubbo.aot.api.ReflectionTypeDescriberRegistrar;\n import org.apache.dubbo.aot.api.TypeDescriber;\n+import org.apache.dubbo.remoting.transport.netty4.NettyChannelHandler;\n import org.apache.dubbo.remoting.transport.netty4.NettyClientHandler;\n+import org.apache.dubbo.remoting.transport.netty4.NettyConnectionHandler;\n+import org.apache.dubbo.remoting.transport.netty4.NettyPortUnificationServerHandler;\n import org.apache.dubbo.remoting.transport.netty4.NettyServerHandler;\n import org.apache.dubbo.remoting.transport.netty4.ssl.SslClientTlsHandler;\n import org.apache.dubbo.remoting.transport.netty4.ssl.SslServerTlsHandler;\n+import java.nio.channels.spi.SelectorProvider;\n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n@@ -35,16 +39,20 @@ public class Netty4ReflectionTypeDescriberRegistrar implements ReflectionTypeDes\n     @Override\n     public List<TypeDescriber> getTypeDescribers() {\n         List<TypeDescriber> typeDescribers = new ArrayList<>();\n-        typeDescribers.add(buildTypeDescriberWithDeclaredMethods(NettyServerHandler.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclaredMethods(SslServerTlsHandler.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclaredMethods(NettyClientHandler.class));\n-        typeDescribers.add(buildTypeDescriberWithDeclaredMethods(SslClientTlsHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(NettyServerHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(SslServerTlsHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(NettyClientHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(SslClientTlsHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(SelectorProvider.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(NettyPortUnificationServerHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(NettyChannelHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(NettyConnectionHandler.class));\n         return typeDescribers;\n     }\n-    private TypeDescriber buildTypeDescriberWithDeclaredMethods(Class<?> c){\n+    private TypeDescriber buildTypeDescriberWithPublicMethod(Class<?> cl) {\n         Set<MemberCategory> memberCategories = new HashSet<>();\n-        memberCategories.add(MemberCategory.INVOKE_DECLARED_METHODS);\n-        return new TypeDescriber(c.getName(), null, new HashSet<>(), new HashSet<>(), new HashSet<>(), memberCategories);\n+        memberCategories.add(MemberCategory.INVOKE_PUBLIC_METHODS);\n+        return new TypeDescriber(cl.getName(), null, new HashSet<>(), new HashSet<>(), new HashSet<>(), memberCategories);\n     }\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/aot/TripleReflectionTypeDescriberRegistrar.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/aot/TripleReflectionTypeDescriberRegistrar.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/aot/TripleReflectionTypeDescriberRegistrar.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/aot/TripleReflectionTypeDescriberRegistrar.java\n@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.tri.aot;\n+\n+import org.apache.dubbo.aot.api.MemberCategory;\n+import org.apache.dubbo.aot.api.ReflectionTypeDescriberRegistrar;\n+import org.apache.dubbo.aot.api.TypeDescriber;\n+import org.apache.dubbo.rpc.protocol.tri.transport.TripleClientHandler;\n+import org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\n+import org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\n+import org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2FrameServerHandler;\n+import org.apache.dubbo.rpc.protocol.tri.transport.TripleServerConnectionHandler;\n+import org.apache.dubbo.rpc.protocol.tri.transport.TripleTailHandler;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class TripleReflectionTypeDescriberRegistrar implements ReflectionTypeDescriberRegistrar {\n+    @Override\n+    public List<TypeDescriber> getTypeDescribers() {\n+        List<TypeDescriber> typeDescribers = new ArrayList<>();\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleHttp2FrameServerHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleCommandOutBoundHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleTailHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleServerConnectionHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleClientHandler.class));\n+        typeDescribers.add(buildTypeDescriberWithPublicMethod(TripleHttp2ClientResponseHandler.class));\n+        return typeDescribers;\n+    }\n+\n+    private TypeDescriber buildTypeDescriberWithPublicMethod(Class<?> c) {\n+        Set<MemberCategory> memberCategories = new HashSet<>();\n+        memberCategories.add(MemberCategory.INVOKE_PUBLIC_METHODS);\n+        return new TypeDescriber(c.getName(), null, new HashSet<>(), new HashSet<>(), new HashSet<>(), memberCategories);\n+    }\n+}",
    "output": "Add tri native image support"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.url.component.DubboServiceAddressURL;\n import org.apache.dubbo.common.url.component.ServiceConfigURL;\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.rpc.Exporter;\n@@ -179,7 +180,7 @@ public void onExporterChangeExport(Exporter<?> exporter) {\n         }\n         if (getUrl().getServiceKey().equals(exporter.getInvoker().getUrl().getServiceKey())\n             && exporter.getInvoker().getUrl().getProtocol().equalsIgnoreCase(LOCAL_PROTOCOL)) {\n-            createInjvmInvoker();\n+            createInjvmInvoker(exporter);\n             isExported.compareAndSet(false, true);\n         }\n     }\n@@ -275,14 +276,19 @@ private boolean isForceLocal() {\n     /**\n      * Creates a new Invoker for the current ScopeClusterInvoker and exports it to the local JVM.\n      */\n-    private void createInjvmInvoker() {\n+    private void createInjvmInvoker(Exporter<?> exporter) {\n         if (injvmInvoker == null) {\n             synchronized (createLock) {\n                 if (injvmInvoker == null) {\n-                    URL url = new ServiceConfigURL(LOCAL_PROTOCOL, NetUtils.getLocalHost(), getUrl().getPort(), getInterface().getName(), getUrl().getParameters());\n+                    URL url = new ServiceConfigURL(LOCAL_PROTOCOL, NetUtils.getLocalHost(), getUrl().getPort(),\n+                        getInterface().getName(), getUrl().getParameters());\n                     url = url.setScopeModel(getUrl().getScopeModel());\n                     url = url.setServiceModel(getUrl().getServiceModel());\n-                    Invoker<?> invoker = protocolSPI.refer(getInterface(), url);\n+\n+                    DubboServiceAddressURL consumerUrl = new DubboServiceAddressURL(url.getUrlAddress(), url.getUrlParam(),\n+                        exporter.getInvoker().getUrl(), null);\n+\n+                    Invoker<?> invoker = protocolSPI.refer(getInterface(), consumerUrl);\n                     List<Invoker<?>> invokers = new ArrayList<>();\n                     invokers.add(invoker);\n                     injvmInvoker = Cluster.getCluster(url.getScopeModel(), Cluster.DEFAULT, false).join(new StaticDirectory(url, invokers), true);\ndiff --git a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java\n@@ -229,7 +229,7 @@ private Invocation recreateInvocation(Invocation invocation, Invoker<?> invoker,\n                 if (pts != null && args != null && pts.length == args.length) {\n                     realArgument = new Object[pts.length];\n                     for (int i = 0; i < pts.length; i++) {\n-                        realArgument[i] = paramDeepCopyUtil.copy(invoker.getUrl(), args[i], pts[i]);\n+                        realArgument[i] = paramDeepCopyUtil.copy(getUrl(), args[i], pts[i]);\n                     }\n                 }\n                 if (realArgument == null) {",
    "output": "Fix local invoke consumer url override"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java\n@@ -44,7 +44,6 @@\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_SERVER_SHUTDOWN_TIMEOUT;\n import static org.apache.dubbo.common.constants.CommonConstants.SHUTDOWN_WAIT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SHUTDOWN_WAIT_SECONDS_KEY;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_UNEXPECTED_EXCEPTION;\n /**\n  * Utilities for manipulating configurations from different sources\n@@ -174,7 +173,7 @@ public static int get(ScopeModel scopeModel, String property, int defaultValue)\n     public static Map<String, String> parseProperties(String content) throws IOException {\n         Map<String, String> map = new HashMap<>();\n         if (StringUtils.isEmpty(content)) {\n-            logger.warn(COMMON_UNEXPECTED_EXCEPTION, \"\", \"\", \"Config center was specified, but no config item found.\");\n+            logger.info(\"Config center was specified, but no config item found.\");\n         } else {\n             Properties properties = new Properties();\n             properties.load(new StringReader(content));",
    "output": "Fix config center properties log level"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n@@ -77,6 +77,14 @@ public synchronized void notify(Object rawAddresses) {\n             }\n             scheduler.submit(new NotificationTask(this, notifyTime));\n         }\n+        try {\n+            while (this.lastEventTime == System.currentTimeMillis()) {\n+                // wait to let event time refresh\n+                Thread.sleep(1);\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n     }\n     public long getDelayTime() {",
    "output": "Fix Registry Notification use same event time"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -57,7 +57,7 @@\n import java.beans.Transient;\n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Comparator;\n+import java.util.TreeSet;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -409,9 +409,7 @@ private Map<String, String> appendConfig() {\n                 logger.warn(CONFIG_NO_METHOD_FOUND, \"\", \"\", \"No method found in service interface: \" + interfaceClass.getName());\n                 map.put(METHODS_KEY, ANY_VALUE);\n             } else {\n-                List<String> copyOfMethods = new ArrayList<>(Arrays.asList(methods));\n-                copyOfMethods.sort(Comparator.naturalOrder());\n-                map.put(METHODS_KEY, String.join(COMMA_SEPARATOR, copyOfMethods));\n+                map.put(METHODS_KEY, StringUtils.join(new TreeSet<>(Arrays.asList(methods)), COMMA_SEPARATOR));\n             }\n         }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -57,7 +57,7 @@\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Comparator;\n+import java.util.TreeSet;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -584,9 +584,7 @@ private Map<String, String> buildAttributes(ProtocolConfig protocolConfig) {\n                 logger.warn(CONFIG_NO_METHOD_FOUND, \"\", \"\", \"No method found in service interface: \" + interfaceClass.getName());\n                 map.put(METHODS_KEY, ANY_VALUE);\n             } else {\n-                List<String> copyOfMethods = new ArrayList<>(Arrays.asList(methods));\n-                copyOfMethods.sort(Comparator.naturalOrder());\n-                map.put(METHODS_KEY, String.join(COMMA_SEPARATOR, copyOfMethods));\n+                map.put(METHODS_KEY, StringUtils.join(new TreeSet<>(Arrays.asList(methods)), COMMA_SEPARATOR));\n             }\n         }",
    "output": "Fix https://github.com/apache/dubbo/issues/12526"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n@@ -26,6 +26,7 @@\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n import java.util.concurrent.locks.LockSupport;\n /**\n@@ -46,7 +47,7 @@ public class ThreadlessExecutor extends AbstractExecutorService {\n     /**\n      * Wait thread. It must be visible to other threads and does not need to be thread-safe\n      */\n-    private volatile Object waiter;\n+    private final AtomicReference<Object> waiter = new AtomicReference<>();\n     /**\n      * Waits until there is a task, executes the task and all queued tasks (if there're any). The task is either a normal\n@@ -56,22 +57,25 @@ public void waitAndDrain(long deadline) throws InterruptedException {\n         throwIfInterrupted();\n         Runnable runnable = queue.poll();\n         if (runnable == null) {\n-            waiter = Thread.currentThread();\n-            try {\n-                while ((runnable = queue.poll()) == null) {\n-                    long restTime = deadline - System.nanoTime();\n-                    if (restTime <= 0) {\n-                        return;\n+            if (waiter.compareAndSet(null, Thread.currentThread())) {\n+                try {\n+                    while ((runnable = queue.poll()) == null && waiter.get() == Thread.currentThread()) {\n+                        long restTime = deadline - System.nanoTime();\n+                        if (restTime <= 0) {\n+                            return;\n+                        }\n+                        LockSupport.parkNanos(this, restTime);\n+                        throwIfInterrupted();\n                     }\n-                    LockSupport.parkNanos(this, restTime);\n-                    throwIfInterrupted();\n+                } finally {\n+                    waiter.compareAndSet(Thread.currentThread(), null);\n                 }\n-            } finally {\n-                waiter = null;\n             }\n         }\n         do {\n-            runnable.run();\n+            if (runnable != null) {\n+                runnable.run();\n+            }\n         } while ((runnable = queue.poll()) != null);\n     }\n@@ -91,8 +95,8 @@ private static void throwIfInterrupted() throws InterruptedException {\n     public void execute(Runnable runnable) {\n         RunnableWrapper run = new RunnableWrapper(runnable);\n         queue.add(run);\n-        if (waiter != SHUTDOWN) {\n-            LockSupport.unpark((Thread) waiter);\n+        if (waiter.get() != SHUTDOWN) {\n+            LockSupport.unpark((Thread) waiter.get());\n         } else if (queue.remove(run)) {\n             throw new RejectedExecutionException();\n         }\n@@ -109,7 +113,10 @@ public void shutdown() {\n     @Override\n     public List<Runnable> shutdownNow() {\n-        waiter = SHUTDOWN;\n+        if (waiter.get() != SHUTDOWN) {\n+            LockSupport.unpark((Thread) waiter.get());\n+        }\n+        waiter.set(SHUTDOWN);\n         Runnable runnable;\n         while ((runnable = queue.poll()) != null) {\n             runnable.run();\n@@ -119,7 +126,7 @@ public List<Runnable> shutdownNow() {\n     @Override\n     public boolean isShutdown() {\n-        return waiter == SHUTDOWN;\n+        return waiter.get() == SHUTDOWN;\n     }\n     @Override\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.resource.GlobalResourceInitializer;\n import org.apache.dubbo.common.serialize.SerializationException;\n+import org.apache.dubbo.common.threadpool.ThreadlessExecutor;\n import org.apache.dubbo.common.timer.HashedWheelTimer;\n import org.apache.dubbo.common.timer.Timeout;\n import org.apache.dubbo.common.timer.Timer;\n@@ -197,6 +198,7 @@ public static void received(Channel channel, Response response, boolean timeout)\n                     t.cancel();\n                 }\n                 future.doReceived(response);\n+                shutdownExecutorIfNeeded(future);\n             } else {\n                 logger.warn(PROTOCOL_TIMEOUT_SERVER, \"\", \"\", \"The timeout response finally returned at \"\n                     + (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date()))\n@@ -215,12 +217,20 @@ public boolean cancel(boolean mayInterruptIfRunning) {\n         errorResult.setStatus(Response.CLIENT_ERROR);\n         errorResult.setErrorMessage(\"request future has been canceled.\");\n         this.doReceived(errorResult);\n-        FUTURES.remove(id);\n+        DefaultFuture future = FUTURES.remove(id);\n+        shutdownExecutorIfNeeded(future);\n         CHANNELS.remove(id);\n         timeoutCheckTask.cancel();\n         return true;\n     }\n+    private static void shutdownExecutorIfNeeded(DefaultFuture future) {\n+        ExecutorService executor = future.getExecutor();\n+        if (executor instanceof ThreadlessExecutor && !executor.isShutdown()) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n     public void cancel() {\n         this.cancel(true);\n     }\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java\n@@ -161,7 +161,7 @@ void interruptSend() throws Exception {\n     }\n     @Test\n-    void testClose() {\n+    void testClose1() {\n         Channel channel = new MockedChannel();\n         Request request = new Request(123);\n         ExecutorService executor = ExtensionLoader.getExtensionLoader(ExecutorRepository.class)\n@@ -171,6 +171,16 @@ void testClose() {\n         Assertions.assertFalse(executor.isTerminated());\n     }\n+    @Test\n+    void testClose2() {\n+        Channel channel = new MockedChannel();\n+        Request request = new Request(123);\n+        ThreadlessExecutor threadlessExecutor = new ThreadlessExecutor();\n+        DefaultFuture.newFuture(channel, request, 1000, threadlessExecutor);\n+        DefaultFuture.closeChannel(channel, 0);\n+        Assertions.assertTrue(threadlessExecutor.isTerminated());\n+    }\n+\n     /**\n      * mock a default future\n      */\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java\n@@ -183,7 +183,7 @@ public Result get() throws InterruptedException, ExecutionException {\n         if (executor != null && executor instanceof ThreadlessExecutor) {\n             ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;\n             try {\n-                while (!responseFuture.isDone()) {\n+                while (!responseFuture.isDone() && !threadlessExecutor.isShutdown()) {\n                     threadlessExecutor.waitAndDrain(Long.MAX_VALUE);\n                 }\n             } finally {\n@@ -199,7 +199,7 @@ public Result get(long timeout, TimeUnit unit) throws InterruptedException, Exec\n         if (executor != null && executor instanceof ThreadlessExecutor) {\n             ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;\n             try {\n-                while (!responseFuture.isDone()) {\n+                while (!responseFuture.isDone() && !threadlessExecutor.isShutdown()) {\n                     long restTime = deadline - System.nanoTime();\n                     if (restTime > 0) {\n                         threadlessExecutor.waitAndDrain(deadline);",
    "output": "Fix channel close event cause hanging thread * Fix channel close event cause hanging thread * Fix check * fix npe * fix ut * fix check * fix uts * fix testing"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ToStringUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ToStringUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ToStringUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ToStringUtils.java\n@@ -16,7 +16,11 @@\n  */\n package org.apache.dubbo.common.utils;\n+import org.apache.dubbo.config.AbstractConfig;\n+\n import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n public class ToStringUtils {\n@@ -36,4 +40,63 @@ public static String printToString(Object obj) {\n             return obj.toString();\n         }\n     }\n+\n+    public static String toString(Object obj) {\n+        if (obj == null) {\n+            return \"null\";\n+        }\n+        if (ClassUtils.isSimpleType(obj.getClass())) {\n+            return obj.toString();\n+        }\n+        if (obj.getClass().isPrimitive()) {\n+            return obj.toString();\n+        }\n+        if (obj instanceof Object[]) {\n+            StringBuilder stringBuilder = new StringBuilder();\n+            stringBuilder.append(\"[\");\n+            Object[] objects = (Object[]) obj;\n+            for (int i = 0; i < objects.length; i++) {\n+                stringBuilder.append(toString(objects[i]));\n+                if (i != objects.length - 1) {\n+                    stringBuilder.append(\", \");\n+                }\n+            }\n+            stringBuilder.append(\"]\");\n+            return stringBuilder.toString();\n+        }\n+        if (obj instanceof List) {\n+            StringBuilder stringBuilder = new StringBuilder();\n+            stringBuilder.append(\"[\");\n+            List list = (List) obj;\n+            for (int i = 0; i < list.size(); i++) {\n+                stringBuilder.append(toString(list.get(i)));\n+                if (i != list.size() - 1) {\n+                    stringBuilder.append(\", \");\n+                }\n+            }\n+            stringBuilder.append(\"]\");\n+            return stringBuilder.toString();\n+        }\n+        if (obj instanceof Map) {\n+            StringBuilder stringBuilder = new StringBuilder();\n+            stringBuilder.append(\"{\");\n+            Map map = (Map) obj;\n+            int i = 0;\n+            for (Object key : map.keySet()) {\n+                stringBuilder.append(toString(key));\n+                stringBuilder.append(\"=\");\n+                stringBuilder.append(toString(map.get(key)));\n+                if (i != map.size() - 1) {\n+                    stringBuilder.append(\", \");\n+                }\n+                i++;\n+            }\n+            stringBuilder.append(\"}\");\n+            return stringBuilder.toString();\n+        }\n+        if (obj instanceof AbstractConfig) {\n+            return obj.toString();\n+        }\n+        return obj.getClass() + \"@\" + Integer.toHexString(System.identityHashCode(obj));\n+    }\n }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -31,6 +31,7 @@\n import org.apache.dubbo.common.utils.MethodUtils;\n import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.common.utils.ToStringUtils;\n import org.apache.dubbo.config.context.ConfigManager;\n import org.apache.dubbo.config.context.ConfigMode;\n import org.apache.dubbo.config.support.Nested;\n@@ -967,7 +968,7 @@ public String toString() {\n                         buf.append(' ');\n                         buf.append(key);\n                         buf.append(\"=\\\"\");\n-                        buf.append(key.equals(\"password\") ? \"******\" : value);\n+                        buf.append(key.equals(\"password\") ? \"******\" : ToStringUtils.toString(value));\n                         buf.append('\\\"');\n                     }\n                 } catch (Exception e) {\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n@@ -683,4 +683,20 @@ public Set<String> removeCachedMapping(String serviceKey) {\n         scheduledExecutorService.shutdown();\n     }\n+\n+    @Test\n+    void testToString() {\n+        ServiceConfig<DemoService> serviceConfig = new ServiceConfig<>();\n+        service.setRef(new DemoServiceImpl() {\n+            @Override\n+            public String toString() {\n+                throw new IllegalStateException();\n+            }\n+        });\n+        try {\n+            serviceConfig.toString();\n+        } catch (Throwable t) {\n+            Assertions.fail(t);\n+        }\n+    }\n }",
    "output": "Fix ServiceConfig Ref unable to toString"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java\n@@ -42,7 +42,6 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n@@ -63,7 +62,7 @@ public abstract class AbstractProtocol implements Protocol, ScopeModelAware {\n     /**\n      * <host:port, ProtocolServer>\n      */\n-    protected final ConcurrentMap<String, ProtocolServer> serverMap = new ConcurrentHashMap<>();\n+    protected final Map<String, ProtocolServer> serverMap = new ConcurrentHashMap<>();\n     // TODO SoftReference\n     protected final Set<Invoker<?>> invokers = new ConcurrentHashSet<>();\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProxyProtocol.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProxyProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProxyProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProxyProtocol.java\n@@ -19,9 +19,11 @@\n import org.apache.dubbo.common.Parameters;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.remoting.Channel;\n import org.apache.dubbo.remoting.ChannelHandler;\n+import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.remoting.RemotingException;\n import org.apache.dubbo.remoting.RemotingServer;\n import org.apache.dubbo.rpc.Exporter;\n@@ -30,7 +32,6 @@\n import org.apache.dubbo.rpc.ProtocolServer;\n import org.apache.dubbo.rpc.ProxyFactory;\n import org.apache.dubbo.rpc.Result;\n-import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcException;\n import java.net.InetSocketAddress;\n@@ -41,14 +42,16 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CopyOnWriteArrayList;\n+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_UNSUPPORTED;\n /**\n  * AbstractProxyProtocol\n  */\n public abstract class AbstractProxyProtocol extends AbstractProtocol {\n-    protected final List<Class<?>> rpcExceptions = new CopyOnWriteArrayList<Class<?>>();\n+    private final List<Class<?>> rpcExceptions = new CopyOnWriteArrayList<Class<?>>();\n     protected ProxyFactory proxyFactory;\n@@ -84,35 +87,7 @@ public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {\n                 return exporter;\n             }\n         }\n-        final Runnable runnable = doExport(proxyFactory.getProxy(\n-                new Invoker<T>() {\n-                    @Override\n-                    public Class<T> getInterface() {\n-                        return invoker.getInterface();\n-                    }\n-\n-                    @Override\n-                    public Result invoke(Invocation invocation) throws RpcException {\n-                        RpcContext.getServiceContext().getObjectAttachments().forEach(invocation::setObjectAttachment);\n-                        return invoker.invoke(invocation);\n-                    }\n-\n-                    @Override\n-                    public URL getUrl() {\n-                        return invoker.getUrl();\n-                    }\n-\n-                    @Override\n-                    public boolean isAvailable() {\n-                        return invoker.isAvailable();\n-                    }\n-\n-                    @Override\n-                    public void destroy() {\n-                        invoker.destroy();\n-                    }\n-                }, true), invoker.getInterface(),\n-            invoker.getUrl());\n+        final Runnable runnable = doExport(proxyFactory.getProxy(invoker, true), invoker.getInterface(), invoker.getUrl());\n         exporter = new AbstractExporter<T>(invoker) {\n             @Override\n             public void afterUnExport() {\n@@ -130,6 +105,46 @@ public void afterUnExport() {\n         return exporter;\n     }\n+    @Override\n+    protected <T> Invoker<T> protocolBindingRefer(final Class<T> type, final URL url) throws RpcException {\n+        final Invoker<T> target = proxyFactory.getInvoker(doRefer(type, url), type, url);\n+        Invoker<T> invoker = new AbstractInvoker<T>(type, url) {\n+            @Override\n+            protected Result doInvoke(Invocation invocation) throws Throwable {\n+                try {\n+                    Result result = target.invoke(invocation);\n+                    // FIXME result is an AsyncRpcResult instance.\n+                    Throwable e = result.getException();\n+                    if (e != null) {\n+                        for (Class<?> rpcException : rpcExceptions) {\n+                            if (rpcException.isAssignableFrom(e.getClass())) {\n+                                throw getRpcException(type, url, invocation, e);\n+                            }\n+                        }\n+                    }\n+                    return result;\n+                } catch (RpcException e) {\n+                    if (e.getCode() == RpcException.UNKNOWN_EXCEPTION) {\n+                        e.setCode(getErrorCode(e.getCause()));\n+                    }\n+                    throw e;\n+                } catch (Throwable e) {\n+                    throw getRpcException(type, url, invocation, e);\n+                }\n+            }\n+\n+            @Override\n+            public void destroy() {\n+                super.destroy();\n+                target.destroy();\n+                invokers.remove(this);\n+                AbstractProxyProtocol.this.destroyInternal(url);\n+            }\n+        };\n+        invokers.add(invoker);\n+        return invoker;\n+    }\n+\n     // used to destroy unused clients and other resource\n     protected void destroyInternal(URL url) {\n         // subclass override\n@@ -142,12 +157,22 @@ protected RpcException getRpcException(Class<?> type, URL url, Invocation invoca\n         return re;\n     }\n+    protected String getAddr(URL url) {\n+        String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());\n+        if (url.getParameter(ANYHOST_KEY, false)) {\n+            bindIp = ANYHOST_VALUE;\n+        }\n+        return NetUtils.getIpByHost(bindIp) + \":\" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());\n+    }\n+\n     protected int getErrorCode(Throwable e) {\n         return RpcException.UNKNOWN_EXCEPTION;\n     }\n     protected abstract <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException;\n+    protected abstract <T> T doRefer(Class<T> type, URL url) throws RpcException;\n+\n     protected class ProxyProtocolServer implements ProtocolServer {\n         private RemotingServer server;\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java\n@@ -31,7 +31,6 @@\n import org.apache.dubbo.rpc.protocol.rest.annotation.consumer.HttpConnectionPreBuildIntercept;\n import org.apache.dubbo.rpc.protocol.rest.annotation.metadata.MetadataResolver;\n-\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n@@ -91,12 +90,14 @@ public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {\n         // TODO add Extension filter\n         // create rest server\n-        RestProtocolServer server = (RestProtocolServer) ConcurrentHashMapUtils.computeIfAbsent(serverMap, getAddr(url), restServer -> {\n-            RestProtocolServer s = serverFactory.createServer(url.getParameter(SERVER_KEY, DEFAULT_SERVER));\n-            s.setAddress(url.getAddress());\n-            s.start(url);\n-            return s;\n-        });\n+        RestProtocolServer server = (RestProtocolServer) ConcurrentHashMapUtils.computeIfAbsent(\n+            (ConcurrentMap<? super String, ? super RestProtocolServer>) serverMap,\n+            getAddr(url), restServer -> {\n+                RestProtocolServer s = serverFactory.createServer(url.getParameter(SERVER_KEY, DEFAULT_SERVER));\n+                s.setAddress(url.getAddress());\n+                s.start(url);\n+                return s;\n+            });\n         server.deploy(serviceRestMetadata, invoker);",
    "output": "Fix AbstractProxyProtocol compatibility"
  },
  {
    "input": "diff --git a/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java b/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n--- a/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n+++ b/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n@@ -61,7 +61,7 @@ class FileTest {\n         ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo-distribution\"));\n         ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo-metadata-processor\"));\n         ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo-native.*\"));\n-        ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo-spring-boot.*\"));\n+        ignoredModulesInDubboAll.add(Pattern.compile(\".*spring-boot.*\"));\n         ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo-maven-plugin\"));\n     }",
    "output": "Fix dependency check"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java b/dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java\n--- a/dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java\n+++ b/dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java\n@@ -17,11 +17,6 @@\n package org.apache.dubbo.configcenter.support.nacos;\n-import com.alibaba.nacos.api.NacosFactory;\n-import com.alibaba.nacos.api.PropertyKeyConst;\n-import com.alibaba.nacos.api.config.ConfigService;\n-import com.alibaba.nacos.api.config.listener.AbstractSharedListener;\n-import com.alibaba.nacos.api.exception.NacosException;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.config.configcenter.ConfigChangeType;\n import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;\n@@ -38,6 +33,12 @@\n import org.apache.dubbo.metrics.event.MetricsEventBus;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import com.alibaba.nacos.api.NacosFactory;\n+import com.alibaba.nacos.api.PropertyKeyConst;\n+import com.alibaba.nacos.api.config.ConfigService;\n+import com.alibaba.nacos.api.config.listener.AbstractSharedListener;\n+import com.alibaba.nacos.api.exception.NacosException;\n+\n import java.util.Map;\n import java.util.Properties;\n import java.util.Set;\n@@ -107,11 +108,15 @@ private NacosConfigServiceWrapper buildConfigService(URL url) {\n         try {\n             for (int i = 0; i < retryTimes + 1; i++) {\n                 tmpConfigServices = NacosFactory.createConfigService(nacosProperties);\n-                if (!check || (UP.equals(tmpConfigServices.getServerStatus()) && testConfigService(tmpConfigServices))) {\n+                String serverStatus = tmpConfigServices.getServerStatus();\n+                boolean configServiceAvailable = testConfigService(tmpConfigServices);\n+                if (!check || (UP.equals(serverStatus) && configServiceAvailable)) {\n                     break;\n                 } else {\n                     logger.warn(LoggerCodeConstants.CONFIG_ERROR_NACOS, \"\", \"\",\n                         \"Failed to connect to nacos config server. \" +\n+                            \"Server status: \" + serverStatus + \". \" +\n+                            \"Config Service Available: \" + configServiceAvailable + \". \" +\n                             (i < retryTimes ? \"Dubbo will try to retry in \" + sleepMsBetweenRetries + \". \" : \"Exceed retry max times.\") +\n                             \"Try times: \" + (i + 1));\n                 }\ndiff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosConnectionManager.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosConnectionManager.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosConnectionManager.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosConnectionManager.java\n@@ -121,11 +121,15 @@ protected NamingService createNamingService() {\n         try {\n             for (int i = 0; i < retryTimes + 1; i++) {\n                 namingService = NacosFactory.createNamingService(nacosProperties);\n-                if (!check || (UP.equals(namingService.getServerStatus()) && testNamingService(namingService))) {\n+                String serverStatus = namingService.getServerStatus();\n+                boolean namingServiceAvailable = testNamingService(namingService);\n+                if (!check || (UP.equals(serverStatus) && namingServiceAvailable)) {\n                     break;\n                 } else {\n                     logger.warn(LoggerCodeConstants.REGISTRY_NACOS_EXCEPTION, \"\", \"\",\n                         \"Failed to connect to nacos naming server. \" +\n+                            \"Server status: \" + serverStatus + \". \" +\n+                            \"Naming Service Available: \" + namingServiceAvailable + \". \" +\n                             (i < retryTimes ? \"Dubbo will try to retry in \" + sleepMsBetweenRetries + \". \" : \"Exceed retry max times.\") +\n                             \"Try times: \" + (i + 1));\n                 }",
    "output": "Add some nacos connection logs"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n@@ -52,14 +52,18 @@ public class ThreadlessExecutor extends AbstractExecutorService {\n      * Waits until there is a task, executes the task and all queued tasks (if there're any). The task is either a normal\n      * response or a timeout response.\n      */\n-    public void waitAndDrain() throws InterruptedException {\n+    public void waitAndDrain(long deadline) throws InterruptedException {\n         throwIfInterrupted();\n         Runnable runnable = queue.poll();\n         if (runnable == null) {\n             waiter = Thread.currentThread();\n             try {\n                 while ((runnable = queue.poll()) == null) {\n-                    LockSupport.park(this);\n+                    long restTime = deadline - System.nanoTime();\n+                    if (restTime <= 0) {\n+                        return;\n+                    }\n+                    LockSupport.parkNanos(this, restTime);\n                     throwIfInterrupted();\n                 }\n             } finally {\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/ThreadlessExecutorTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/ThreadlessExecutorTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/ThreadlessExecutorTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/ThreadlessExecutorTest.java\n@@ -16,10 +16,11 @@\n  */\n package org.apache.dubbo.common.threadpool;\n-import org.apache.dubbo.common.URL;\n-\n+import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n class ThreadlessExecutorTest {\n     private static final ThreadlessExecutor executor;\n@@ -33,11 +34,13 @@ void test() throws InterruptedException {\n             executor.execute(()->{throw new RuntimeException(\"test\");});\n         }\n-        executor.waitAndDrain();\n+        executor.waitAndDrain(123);\n-        executor.execute(()->{});\n+        AtomicBoolean invoked = new AtomicBoolean(false);\n+        executor.execute(()->{invoked.set(true);});\n-        executor.waitAndDrain();\n+        executor.waitAndDrain(123);\n+        Assertions.assertTrue(invoked.get());\n         executor.shutdown();\n     }\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java\n@@ -142,7 +142,7 @@ void interruptSend() throws Exception {\n         try {\n             new InterruptThread(Thread.currentThread()).start();\n             while (!f. isDone()){\n-                executor.waitAndDrain();\n+                executor.waitAndDrain(Long.MAX_VALUE);\n             }\n             f.get();\n         } catch (Exception e) {\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java\n@@ -184,7 +184,7 @@ public Result get() throws InterruptedException, ExecutionException {\n             ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;\n             try {\n                 while (!responseFuture.isDone()) {\n-                    threadlessExecutor.waitAndDrain();\n+                    threadlessExecutor.waitAndDrain(Long.MAX_VALUE);\n                 }\n             } finally {\n                 threadlessExecutor.shutdown();\n@@ -195,17 +195,27 @@ public Result get() throws InterruptedException, ExecutionException {\n     @Override\n     public Result get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n+        long deadline = System.nanoTime() + unit.toNanos(timeout);\n         if (executor != null && executor instanceof ThreadlessExecutor) {\n             ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;\n             try {\n                 while (!responseFuture.isDone()) {\n-                    threadlessExecutor.waitAndDrain();\n+                    long restTime = deadline - System.nanoTime();\n+                    if (restTime > 0) {\n+                        threadlessExecutor.waitAndDrain(deadline);\n+                    } else {\n+                        throw new TimeoutException(\"Timeout after \" + unit.toMillis(timeout) + \"ms waiting for result.\");\n+                    }\n                 }\n             } finally {\n                 threadlessExecutor.shutdown();\n             }\n         }\n-        return responseFuture.get(timeout, unit);\n+        long restTime = deadline - System.nanoTime();\n+        if (!responseFuture.isDone() && restTime < 0) {\n+            throw new TimeoutException(\"Timeout after \" + unit.toMillis(timeout) + \"ms waiting for result.\");\n+        }\n+        return responseFuture.get(restTime, TimeUnit.NANOSECONDS);\n     }\n     @Override",
    "output": "Fix long time await in ThreadlessExecutor * Fix long time await in ThreadlessExecutor * Fix uts"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invoker.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invoker.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invoker.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invoker.java\n@@ -95,5 +95,21 @@ public void destroy() {\n         public org.apache.dubbo.rpc.Invoker<T> getOriginal() {\n             return invoker;\n         }\n+\n+        @Override\n+        public int hashCode() {\n+            return invoker.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (!(o instanceof CompatibleInvoker)) {\n+                return false;\n+            }\n+            return invoker.equals(o);\n+        }\n     }\n }",
    "output": "Fix hashCode change in 2.6 DIY ConsistentHashLoadBalance * Fix hashCode change in 2.6 DIY ConsistentHashLoadBalance When using 2.6.x DIY ConsistentHashLoadBalance, Invoker will wrap to CompatibleInvoker. Then invokers.hashCode() will return different hashCode event original Invokers not change. This will cause many duplicate Object like ConsistentHashSelector in jvm Eden space, and young gc will be very frequently. * add override equals * Add object and class check equals"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java\n@@ -40,14 +40,14 @@\n import java.util.List;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import static org.apache.dubbo.common.constants.CommonConstants.BROADCAST_CLUSTER;\n import static org.apache.dubbo.common.constants.CommonConstants.CLUSTER_KEY;\n import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;\n import static org.apache.dubbo.rpc.Constants.LOCAL_PROTOCOL;\n import static org.apache.dubbo.rpc.Constants.SCOPE_KEY;\n-import static org.apache.dubbo.rpc.Constants.SCOPE_REMOTE;\n import static org.apache.dubbo.rpc.Constants.SCOPE_LOCAL;\n+import static org.apache.dubbo.rpc.Constants.SCOPE_REMOTE;\n import static org.apache.dubbo.rpc.cluster.Constants.PEER_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.BROADCAST_CLUSTER;\n /**\n  * ScopeClusterInvoker is a cluster invoker which handles the invocation logic of a single service in a specific scope.\n@@ -100,7 +100,19 @@ public boolean isDestroyed() {\n     @Override\n     public boolean isAvailable() {\n-        return isExported.get() || directory.isAvailable();\n+        if (peerFlag || isBroadcast()) {\n+            // If it's a point-to-point direct connection or broadcasting, it should be called remotely.\n+            return invoker.isAvailable();\n+        }\n+        if (injvmFlag && isForceLocal()) {\n+            // If it's a local call, it should be called locally.\n+            return isExported.get();\n+        }\n+        if (injvmFlag && isExported.get()) {\n+            // If allow local call, check if local exported first\n+            return true;\n+        }\n+        return invoker.isAvailable();\n     }\n     @Override\n@@ -128,7 +140,7 @@ public Class<T> getInterface() {\n     @Override\n     public Result invoke(Invocation invocation) throws RpcException {\n         // When broadcasting, it should be called remotely.\n-        if (BROADCAST_CLUSTER.equalsIgnoreCase(getUrl().getParameter(CLUSTER_KEY))) {\n+        if (isBroadcast()) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Performing broadcast call for method: \" + invocation.getMethodName() + \" of service: \" + getUrl().getServiceKey());\n             }\n@@ -155,6 +167,10 @@ public Result invoke(Invocation invocation) throws RpcException {\n         return invoker.invoke(invocation);\n     }\n+    private boolean isBroadcast() {\n+        return BROADCAST_CLUSTER.equalsIgnoreCase(getUrl().getParameter(CLUSTER_KEY));\n+    }\n+\n     @Override\n     public void onExporterChangeExport(Exporter<?> exporter) {\n         if (isExported.get()) {\n@@ -230,9 +246,9 @@ private boolean isNotRemoteOrGeneric() {\n     private boolean isInjvmExported() {\n         Boolean localInvoke = RpcContext.getServiceContext().getLocalInvoke();\n         boolean isExportedValue = isExported.get();\n-        boolean local = (localInvoke != null && localInvoke);\n+        boolean localOnce = (localInvoke != null && localInvoke);\n         // Determine whether this call is local\n-        if (isExportedValue && local) {\n+        if (isExportedValue && localOnce) {\n             return true;\n         }\n@@ -242,15 +258,19 @@ private boolean isInjvmExported() {\n         }\n         // When calling locally, determine whether it does not meet the requirements\n-        if (!isExportedValue && (SCOPE_LOCAL.equalsIgnoreCase(getUrl().getParameter(SCOPE_KEY)) ||\n-            Boolean.TRUE.toString().equalsIgnoreCase(getUrl().getParameter(LOCAL_PROTOCOL)) || local)) {\n+        if (!isExportedValue && (isForceLocal() || localOnce)) {\n             // If it's supposed to be exported to the local JVM ,but it's not, throw an exception\n             throw new RpcException(\"Local service for \" + getUrl().getServiceInterface() + \" has not been exposed yet!\");\n         }\n         return isExportedValue && injvmFlag;\n     }\n+    private boolean isForceLocal() {\n+        return SCOPE_LOCAL.equalsIgnoreCase(getUrl().getParameter(SCOPE_KEY)) ||\n+            Boolean.TRUE.toString().equalsIgnoreCase(getUrl().getParameter(LOCAL_PROTOCOL));\n+    }\n+\n     /**\n      * Creates a new Invoker for the current ScopeClusterInvoker and exports it to the local JVM.\n      */\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvokerTest.java\n@@ -19,7 +19,6 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n-\n import org.apache.dubbo.metrics.event.MetricsDispatcher;\n import org.apache.dubbo.rpc.Exporter;\n import org.apache.dubbo.rpc.Invocation;\n@@ -165,7 +164,7 @@ void testScopeLocalInvoke() {\n         RpcInvocation invocation = new RpcInvocation();\n         invocation.setMethodName(\"doSomething4\");\n         invocation.setParameterTypes(new Class[]{});\n-        Assertions.assertTrue(cluster.isAvailable(), \"\");\n+        Assertions.assertFalse(cluster.isAvailable(), \"\");\n         RpcInvocation finalInvocation = invocation;\n         Assertions.assertThrows(RpcException.class, () -> cluster.invoke(finalInvocation));",
    "output": "Fix injvm invoker check * Fix injvm invoker check * Fix injvm invoker check * Fix injvm invoker check"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/MetricsConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/MetricsConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/MetricsConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/MetricsConfig.java\n@@ -92,6 +92,7 @@ public class MetricsConfig extends AbstractConfig {\n      */\n     private Boolean useGlobalRegistry;\n+    private Boolean enableRpc;\n     public MetricsConfig() {\n     }\n@@ -214,4 +215,12 @@ public Boolean getUseGlobalRegistry() {\n     public void setUseGlobalRegistry(Boolean useGlobalRegistry) {\n         this.useGlobalRegistry = useGlobalRegistry;\n     }\n+\n+    public Boolean getEnableRpc() {\n+        return enableRpc;\n+    }\n+\n+    public void setEnableRpc(Boolean enableRpc) {\n+        this.enableRpc = enableRpc;\n+    }\n }\ndiff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.config.MetricsConfig;\n import org.apache.dubbo.metrics.event.MetricsEventBus;\n import org.apache.dubbo.metrics.event.RequestEvent;\n import org.apache.dubbo.rpc.BaseFilter;\n@@ -40,20 +41,24 @@\n public class MetricsFilter implements Filter, BaseFilter.Listener, ScopeModelAware {\n     private ApplicationModel applicationModel;\n-    private final static ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(MetricsFilter.class);\n+    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(MetricsFilter.class);\n+    private boolean rpcMetricsEnable;\n     @Override\n     public void setApplicationModel(ApplicationModel applicationModel) {\n         this.applicationModel = applicationModel;\n+        this.rpcMetricsEnable = applicationModel.getApplicationConfigManager().getMetrics().map(MetricsConfig::getEnableRpc).orElse(true);\n     }\n     @Override\n     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n-        try {\n-            RequestEvent requestEvent = RequestEvent.toRequestEvent(applicationModel, invocation);\n-            MetricsEventBus.before(requestEvent, () -> invocation.put(METRIC_FILTER_EVENT, requestEvent));\n-        } catch (Throwable t) {\n-            LOGGER.warn(INTERNAL_ERROR, \"\", \"\", \"Error occurred when invoke.\", t);\n+        if (rpcMetricsEnable) {\n+            try {\n+                RequestEvent requestEvent = RequestEvent.toRequestEvent(applicationModel, invocation);\n+                MetricsEventBus.before(requestEvent, () -> invocation.put(METRIC_FILTER_EVENT, requestEvent));\n+            } catch (Throwable t) {\n+                LOGGER.warn(INTERNAL_ERROR, \"\", \"\", \"Error occurred when invoke.\", t);\n+            }\n         }\n         return invoker.invoke(invocation);\n     }\n@@ -84,6 +89,4 @@ public void onError(Throwable t, Invoker<?> invoker, Invocation invocation) {\n         }\n     }\n-\n-\n }\ndiff --git a/dubbo-metrics/dubbo-metrics-default/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java b/dubbo-metrics/dubbo-metrics-default/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java\n@@ -82,7 +82,6 @@ public void setup() {\n         config.setName(\"MockMetrics\");\n         applicationModel = ApplicationModel.defaultModel();\n         applicationModel.getApplicationConfigManager().setApplication(config);\n-\n         invocation = new RpcInvocation();\n         filter = new MetricsFilter();",
    "output": "Add metrics enable switch * add metrics enable switch * default false * default false * set default true and fix unit test * xsd set default true * rename enabled to enableRpc * make enableRpc default value to true * fix camel name * remove default value ---------"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -496,11 +496,6 @@ public interface CommonConstants {\n      */\n     String URL_MERGE_PROCESSOR_KEY = \"url-merge-processor\";\n-    /**\n-     * use native image to compile dubbo's identifier\n-     */\n-    String NATIVE = \"native\";\n-\n     String DUBBO_MONITOR_ADDRESS = \"dubbo.monitor.address\";\n     String SERVICE_NAME_MAPPING_KEY = \"service-name-mapping\";\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NativeUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NativeUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NativeUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NativeUtils.java\n@@ -1,28 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.dubbo.common.utils;\n-\n-import static org.apache.dubbo.common.constants.CommonConstants.NATIVE;\n-\n-public abstract class NativeUtils {\n-\n-    public static boolean isNative() {\n-        return Boolean.parseBoolean(System.getProperty(NATIVE, \"false\"));\n-    }\n-\n-}",
    "output": "Remove NativeUtils"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ToStringUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ToStringUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ToStringUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ToStringUtils.java\n@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common.utils;\n+\n+import java.util.Arrays;\n+\n+public class ToStringUtils {\n+\n+    private ToStringUtils() {\n+    }\n+\n+    public static String printToString(Object obj) {\n+        if (obj == null) {\n+            return \"null\";\n+        }\n+        try {\n+            return JsonUtils.toJson(obj);\n+        } catch (Throwable throwable) {\n+            if (obj instanceof Object[]) {\n+                return Arrays.toString((Object[]) obj);\n+            }\n+            return obj.toString();\n+        }\n+    }\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/AccessLogData.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/AccessLogData.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/AccessLogData.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/AccessLogData.java\n@@ -17,8 +17,8 @@\n package org.apache.dubbo.rpc.support;\n-import org.apache.dubbo.common.utils.JsonUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.common.utils.ToStringUtils;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.RpcContext;\n@@ -248,7 +248,7 @@ public String getLogMessage() {\n         Object[] args = get(ARGUMENTS) != null ? (Object[]) get(ARGUMENTS) : null;\n         if (args != null && args.length > 0) {\n-            sn.append(JsonUtils.toJson(args));\n+            sn.append(ToStringUtils.printToString(args));\n         }\n         return sn.toString();",
    "output": "Fix build string error * fix build string error * Update dubbo-common/src/main/java/org/apache/dubbo/common/utils/ToStringUtils.java"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n@@ -16,11 +16,6 @@\n  */\n package org.apache.dubbo.rpc.cluster.support;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.Version;\n import org.apache.dubbo.common.config.Configuration;\n@@ -37,13 +32,19 @@\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.RpcServiceContext;\n import org.apache.dubbo.rpc.cluster.ClusterInvoker;\n import org.apache.dubbo.rpc.cluster.Directory;\n import org.apache.dubbo.rpc.cluster.LoadBalance;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.ScopeModelUtil;\n import org.apache.dubbo.rpc.support.RpcUtils;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_LOADBALANCE;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_RESELECT_COUNT;\n import static org.apache.dubbo.common.constants.CommonConstants.ENABLE_CONNECTIVITY_VALIDATION;\n@@ -372,7 +373,7 @@ protected void checkInvokers(List<Invoker<T>> invokers, Invocation invocation) {\n     }\n     protected Result invokeWithContext(Invoker<T> invoker, Invocation invocation) {\n-        setContext(invoker);\n+        Invoker<T> originInvoker = setContext(invoker);\n         Result result;\n         try {\n             if (ProfilerSwitch.isEnableSimpleProfiler()) {\n@@ -381,7 +382,7 @@ protected Result invokeWithContext(Invoker<T> invoker, Invocation invocation) {\n             invocation.addInvokedInvoker(invoker);\n             result = invoker.invoke(invocation);\n         } finally {\n-            clearContext(invoker);\n+            clearContext(originInvoker);\n             InvocationProfilerUtils.releaseSimpleProfiler(invocation);\n         }\n         return result;\n@@ -394,12 +395,12 @@ protected Result invokeWithContext(Invoker<T> invoker, Invocation invocation) {\n      * @return\n      */\n     protected Result invokeWithContextAsync(Invoker<T> invoker, Invocation invocation, URL consumerUrl) {\n-        setContext(invoker, consumerUrl);\n+        Invoker<T> originInvoker = setContext(invoker, consumerUrl);\n         Result result;\n         try {\n             result = invoker.invoke(invocation);\n         } finally {\n-            clearContext(invoker);\n+            clearContext(originInvoker);\n         }\n         return result;\n     }\n@@ -436,19 +437,21 @@ protected LoadBalance initLoadBalance(List<Invoker<T>> invokers, Invocation invo\n     }\n-    private void setContext(Invoker<T> invoker) {\n-        setContext(invoker, null);\n+    private Invoker<T> setContext(Invoker<T> invoker) {\n+        return setContext(invoker, null);\n     }\n-    private void setContext(Invoker<T> invoker, URL consumerUrl) {\n-        RpcContext context = RpcContext.getServiceContext();\n+    private Invoker<T> setContext(Invoker<T> invoker, URL consumerUrl) {\n+        RpcServiceContext context = RpcContext.getServiceContext();\n+        Invoker<?> originInvoker = context.getInvoker();\n         context.setInvoker(invoker)\n             .setConsumerUrl(null != consumerUrl ? consumerUrl : RpcContext.getServiceContext().getConsumerUrl());\n+        return (Invoker<T>) originInvoker;\n     }\n     private void clearContext(Invoker<T> invoker) {\n         // do nothing\n         RpcContext context = RpcContext.getServiceContext();\n-        context.setInvoker(null);\n+        context.setInvoker(invoker);\n     }\n }",
    "output": "Fix invoker recovery"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -277,9 +277,10 @@ public static void appendRuntimeParameters(Map<String, String> map) {\n     protected void appendMetricsCompatible(Map<String, String> map) {\n         MetricsConfig metricsConfig = getConfigManager().getMetrics().orElse(null);\n         if (metricsConfig != null) {\n-            if (metricsConfig.getProtocol() != null && !StringUtils.isEquals(metricsConfig.getProtocol(), PROTOCOL_PROMETHEUS)) {\n+            String protocol = Optional.ofNullable(metricsConfig.getProtocol()).orElse(PROTOCOL_PROMETHEUS);\n+            if (!StringUtils.isEquals(protocol, PROTOCOL_PROMETHEUS)) {\n                 Assert.notEmptyString(metricsConfig.getPort(), \"Metrics port cannot be null\");\n-                map.put(\"metrics.protocol\", metricsConfig.getProtocol());\n+                map.put(\"metrics.protocol\", protocol);\n                 map.put(\"metrics.port\", metricsConfig.getPort());\n             }\n         }\n@@ -376,8 +377,9 @@ protected void processExtraRefresh(String preferredPrefix, InmemoryConfiguration\n     }\n     /**\n-     *  it is used for skipping the check of interface since dubbo 3.2\n-     *  rest protocol allow the service is implement class\n+     * it is used for skipping the check of interface since dubbo 3.2\n+     * rest protocol allow the service is implement class\n+     *\n      * @return\n      */\n     protected boolean canSkipInterfaceCheck() {\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultMetricsServiceExporter.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultMetricsServiceExporter.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultMetricsServiceExporter.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultMetricsServiceExporter.java\n@@ -54,10 +54,11 @@ private void initialize() {\n         MetricsConfig metricsConfig = applicationModel.getApplicationConfigManager().getMetrics().orElse(null);\n         // TODO compatible with old usage of metrics, remove protocol check after new metrics is ready for use.\n         if (metricsConfig != null &&  metricsService == null) {\n-            if (PROTOCOL_PROMETHEUS.equals(metricsConfig.getProtocol()) ) {\n+            String protocol = Optional.ofNullable(metricsConfig.getProtocol()).orElse(PROTOCOL_PROMETHEUS);\n+            if (PROTOCOL_PROMETHEUS.equals(protocol) ) {\n                 this.metricsService  = applicationModel.getExtensionLoader(MetricsService.class).getDefaultExtension();\n             } else {\n-                logger.warn(COMMON_METRICS_COLLECTOR_EXCEPTION, \"\", \"\", \"Protocol \" + metricsConfig.getProtocol() + \" not support for new metrics mechanism. \" +\n+                logger.warn(COMMON_METRICS_COLLECTOR_EXCEPTION, \"\", \"\", \"Protocol \" + protocol + \" not support for new metrics mechanism. \" +\n                     \"Using old metrics mechanism instead.\");\n             }\n         }\ndiff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/HistogramMetricsCollector.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/HistogramMetricsCollector.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/HistogramMetricsCollector.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/HistogramMetricsCollector.java\n@@ -53,10 +53,16 @@ public HistogramMetricsCollector(ApplicationModel applicationModel) {\n         ConfigManager configManager = applicationModel.getApplicationConfigManager();\n         MetricsConfig config = configManager.getMetrics().orElse(null);\n-        if (config != null && config.getHistogram() != null && Boolean.TRUE.equals(config.getHistogram().getEnabled())) {\n+        if (config == null || config.getHistogram() == null || config.getHistogram().getEnabled() == null || Boolean.TRUE.equals(config.getHistogram().getEnabled())) {\n             registerListener();\n-            HistogramConfig histogram = config.getHistogram();\n+            HistogramConfig histogram;\n+            if (config == null || config.getHistogram() == null) {\n+                histogram = new HistogramConfig();\n+            } else {\n+                histogram = config.getHistogram();\n+            }\n+\n             if (!Boolean.TRUE.equals(histogram.getEnabledPercentiles()) && histogram.getBucketsMs() == null) {\n                 histogram.setBucketsMs(DEFAULT_BUCKETS_MS);\n             }",
    "output": "Add default enable for protocol and histogram * fix default enable for agg and histogram * fix default enable for agg and histogram * add default protocol * fix ci * fix ci * fix ci * fix ci * fix ci ---------"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Filter.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Filter.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Filter.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Filter.java\n@@ -18,6 +18,9 @@\n package com.alibaba.dubbo.rpc;\n import org.apache.dubbo.rpc.AsyncRpcResult;\n+import org.apache.dubbo.rpc.AttachmentsAdapter;\n+\n+import java.util.Map;\n @Deprecated\n public interface Filter extends org.apache.dubbo.rpc.Filter {\n@@ -27,7 +30,7 @@ public interface Filter extends org.apache.dubbo.rpc.Filter {\n     @Override\n     default org.apache.dubbo.rpc.Result invoke(org.apache.dubbo.rpc.Invoker<?> invoker,\n                                                org.apache.dubbo.rpc.Invocation invocation)\n-            throws org.apache.dubbo.rpc.RpcException {\n+        throws org.apache.dubbo.rpc.RpcException {\n         Result invokeResult = invoke(new Invoker.CompatibleInvoker<>(invoker),\n             new Invocation.CompatibleInvocation(invocation));\n@@ -38,6 +41,10 @@ default org.apache.dubbo.rpc.Result invoke(org.apache.dubbo.rpc.Invoker<?> invok\n         AsyncRpcResult asyncRpcResult = AsyncRpcResult.newDefaultAsyncResult(invocation);\n         asyncRpcResult.setValue(invokeResult.getValue());\n         asyncRpcResult.setException(invokeResult.getException());\n+        Map<String, String> attachments = invokeResult.getAttachments();\n+        if (!(attachments instanceof AttachmentsAdapter.ObjectToStringMap)) {\n+            asyncRpcResult.setAttachments(attachments);\n+        }\n         asyncRpcResult.setObjectAttachments(invokeResult.getObjectAttachments());\n         return asyncRpcResult;\ndiff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Result.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Result.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Result.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Result.java\n@@ -64,6 +64,16 @@ default Object getObjectAttachment(String key, Object defaultValue) {\n         return null;\n     }\n+\n+    /**\n+     * @see com.alibaba.dubbo.rpc.Result#getValue()\n+     * @deprecated Replace to getValue()\n+     */\n+    @Deprecated\n+    default Object getResult() {\n+        return getValue();\n+    }\n+\n     class CompatibleResult implements Result {\n         private org.apache.dubbo.rpc.Result delegate;",
    "output": "Fix alibaba Filter / Result Compact"
  },
  {
    "input": "diff --git a/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/annotation/ConditionalOnDubboTracingEnable.java b/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/annotation/ConditionalOnDubboTracingEnable.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/annotation/ConditionalOnDubboTracingEnable.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/annotation/ConditionalOnDubboTracingEnable.java\n@@ -38,6 +38,6 @@\n @Retention(RetentionPolicy.RUNTIME)\n @Inherited\n @Documented\n-@ConditionalOnProperty(prefix = ObservabilityUtils.DUBBO_TRACING_PREFIX, name = \"enabled\", matchIfMissing = true)\n+@ConditionalOnProperty(prefix = ObservabilityUtils.DUBBO_TRACING_PREFIX, name = \"enabled\")\n public @interface ConditionalOnDubboTracingEnable {\n }\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java\n@@ -36,7 +36,6 @@\n import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.Sender;\n-import static org.apache.dubbo.spring.boot.observability.autoconfigure.ObservabilityUtils.DUBBO_TRACING_PREFIX;\n import static org.apache.dubbo.spring.boot.observability.autoconfigure.ObservabilityUtils.DUBBO_TRACING_ZIPKIN_CONFIG_PREFIX;\n@@ -54,7 +53,6 @@\n @Import({SenderConfiguration.class,\n         ReporterConfiguration.class, BraveConfiguration.class,\n         OpenTelemetryConfiguration.class})\n-@ConditionalOnProperty(prefix = DUBBO_TRACING_PREFIX, name = \"enabled\", havingValue = \"true\")\n @ConditionalOnDubboTracingEnable\n public class ZipkinAutoConfiguration {\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/test/java/org/apache/dubbo/spring/boot/observability/autoconfigure/observability/DubboMicrometerTracingAutoConfigurationTests.java b/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/test/java/org/apache/dubbo/spring/boot/observability/autoconfigure/observability/DubboMicrometerTracingAutoConfigurationTests.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/test/java/org/apache/dubbo/spring/boot/observability/autoconfigure/observability/DubboMicrometerTracingAutoConfigurationTests.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-observability-starters/autoconfigure/src/test/java/org/apache/dubbo/spring/boot/observability/autoconfigure/observability/DubboMicrometerTracingAutoConfigurationTests.java\n@@ -44,7 +44,8 @@\n class DubboMicrometerTracingAutoConfigurationTests {\n     private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()\n-            .withConfiguration(AutoConfigurations.of(DubboMicrometerTracingAutoConfiguration.class));\n+            .withConfiguration(AutoConfigurations.of(DubboMicrometerTracingAutoConfiguration.class))\n+            .withPropertyValues(\"dubbo.tracing.enabled=true\");\n     @Test\n     void shouldSupplyBeans() {",
    "output": "Fix remove ConditionalOnDubboTracingEnable matchIfMissing * chore: remove ConditionalOnDubboTracingEnable matchIfMissing * fix: fix missing property in test ---------"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/RtStatComposite.java\n@@ -94,7 +94,7 @@ public void calcServiceKeyRt(String serviceKey, String registryOpType, Long resp\n     public void calcMethodKeyRt(Invocation invocation, String registryOpType, Long responseTime) {\n         for (LongContainer container : rtStats.stream().filter(longContainer -> longContainer.specifyType(registryOpType)).collect(Collectors.toList())) {\n-            Number current = (Number) ConcurrentHashMapUtils.computeIfAbsent(container, invocation.getServiceName() + \"_\" + invocation.getMethodName(), container.getInitFunc());\n+            Number current = (Number) ConcurrentHashMapUtils.computeIfAbsent(container, invocation.getTargetServiceUniqueName() + \"_\" + invocation.getMethodName(), container.getInitFunc());\n             container.getConsumerFunc().accept(responseTime, current);\n         }\n     }",
    "output": "Fix invocation.getServiceKey maybe null"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcContext.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcContext.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcContext.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcContext.java\n@@ -305,6 +305,10 @@ public Object get(String key) {\n         return newRpcContext.get(key);\n     }\n+    public Invocation getInvocation() {\n+        return new Invocation.CompatibleInvocation(newRpcContext.getInvocation());\n+    }\n+\n     @Deprecated\n     public boolean isServerSide() {\n         return isProviderSide();",
    "output": "Add alibaba RpcContext getInvocation compact"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n@@ -50,6 +50,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Optional;\n import java.util.Properties;\n import java.util.TreeMap;\n import java.util.WeakHashMap;\n@@ -539,7 +540,11 @@ private static Object realize1(Object pojo, Class<?> type, Type genericType, fin\n                                 if (!method.isAccessible()) {\n                                     method.setAccessible(true);\n                                 }\n-                                Type containType = mapGeneric.get(field.getGenericType().getTypeName());\n+                                Type containType = Optional.ofNullable(field)\n+                                    .map(Field::getGenericType)\n+                                    .map(Type::getTypeName)\n+                                    .map(mapGeneric::get)\n+                                    .orElse(null);\n                                 if (containType != null) {\n                                     //is generic\n                                     if (containType instanceof ParameterizedType) {\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n@@ -16,6 +16,25 @@\n  */\n package org.apache.dubbo.common.utils;\n+import org.apache.dubbo.common.model.Person;\n+import org.apache.dubbo.common.model.SerializablePerson;\n+import org.apache.dubbo.common.model.User;\n+import org.apache.dubbo.common.model.person.Ageneric;\n+import org.apache.dubbo.common.model.person.Bgeneric;\n+import org.apache.dubbo.common.model.person.BigPerson;\n+import org.apache.dubbo.common.model.person.Cgeneric;\n+import org.apache.dubbo.common.model.person.Dgeneric;\n+import org.apache.dubbo.common.model.person.FullAddress;\n+import org.apache.dubbo.common.model.person.PersonInfo;\n+import org.apache.dubbo.common.model.person.PersonMap;\n+import org.apache.dubbo.common.model.person.PersonStatus;\n+import org.apache.dubbo.common.model.person.Phone;\n+\n+import com.alibaba.fastjson.JSON;\n+import com.alibaba.fastjson.JSONObject;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n@@ -32,27 +51,9 @@\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.UUID;\n-import com.alibaba.fastjson.JSON;\n-import org.apache.dubbo.common.model.Person;\n-import org.apache.dubbo.common.model.SerializablePerson;\n-import org.apache.dubbo.common.model.User;\n-import org.apache.dubbo.common.model.person.Bgeneric;\n-import org.apache.dubbo.common.model.person.BigPerson;\n-import org.apache.dubbo.common.model.person.Cgeneric;\n-import org.apache.dubbo.common.model.person.Dgeneric;\n-import org.apache.dubbo.common.model.person.FullAddress;\n-import org.apache.dubbo.common.model.person.Ageneric;\n-import org.apache.dubbo.common.model.person.PersonInfo;\n-import org.apache.dubbo.common.model.person.PersonMap;\n-import org.apache.dubbo.common.model.person.PersonStatus;\n-import org.apache.dubbo.common.model.person.Phone;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import com.alibaba.fastjson.JSONObject;\n-\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n@@ -998,6 +999,63 @@ public void testPojoGeneric4() throws NoSuchMethodException {\n         }\n     }\n+    @Test\n+    void testNameNotMatch() {\n+        NameNotMatch origin = new NameNotMatch();\n+        origin.setNameA(\"test123\");\n+        origin.setNameB(\"test234\");\n+\n+        Object generalized = PojoUtils.generalize(origin);\n+\n+        Assertions.assertInstanceOf(Map.class, generalized);\n+        Assertions.assertEquals(\"test123\", ((Map)generalized).get(\"nameA\"));\n+        Assertions.assertEquals(\"test234\", ((Map)generalized).get(\"nameB\"));\n+\n+        NameNotMatch target1 = (NameNotMatch) PojoUtils.realize(PojoUtils.generalize(origin), NameNotMatch.class, NameNotMatch.class);\n+        Assertions.assertEquals(origin, target1);\n+\n+        Map<String, String> map = new HashMap<>();\n+        map.put(\"nameA\", \"test123\");\n+        map.put(\"nameB\", \"test234\");\n+\n+        NameNotMatch target2 = (NameNotMatch) PojoUtils.realize(map, NameNotMatch.class, NameNotMatch.class);\n+        Assertions.assertEquals(origin, target2);\n+    }\n+\n+    class NameNotMatch implements Serializable {\n+        private String NameA;\n+        private String NameAbsent;\n+\n+        public void setNameA(String nameA) {\n+            this.NameA = nameA;\n+        }\n+\n+        public String getNameA() {\n+            return NameA;\n+        }\n+\n+        public void setNameB(String nameB) {\n+            this.NameAbsent = nameB;\n+        }\n+\n+        public String getNameB() {\n+            return NameAbsent;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            NameNotMatch that = (NameNotMatch) o;\n+            return Objects.equals(NameA, that.NameA) && Objects.equals(NameAbsent, that.NameAbsent);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(NameA, NameAbsent);\n+        }\n+    }\n+\n     public enum Day {\n         SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY\n     }",
    "output": "Fix NPE if name not match in PojoUtils"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n@@ -26,7 +26,7 @@\n import java.util.List;\n @Deprecated\n-public abstract class AbstractLoadBalance extends org.apache.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance implements LoadBalance {\n+public abstract class AbstractLoadBalance implements LoadBalance {\n     @Override\n     public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {",
    "output": "Fix alibaba AbstractLoadBalance compact"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n@@ -17,6 +17,45 @@\n package com.alibaba.dubbo.rpc.cluster.loadbalance;\n+import com.alibaba.dubbo.common.Constants;\n+import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.rpc.Invocation;\n+import com.alibaba.dubbo.rpc.Invoker;\n+import com.alibaba.dubbo.rpc.cluster.LoadBalance;\n+\n+import java.util.List;\n+\n @Deprecated\n-public abstract class AbstractLoadBalance extends org.apache.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance {\n+public abstract class AbstractLoadBalance extends org.apache.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance implements LoadBalance {\n+\n+    @Override\n+    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n+        if (invokers == null || invokers.size() == 0)\n+            return null;\n+        if (invokers.size() == 1)\n+            return invokers.get(0);\n+        return doSelect(invokers, url, invocation);\n+    }\n+\n+    protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);\n+\n+    protected int getWeight(Invoker<?> invoker, Invocation invocation) {\n+        int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\n+        if (weight > 0) {\n+            long timestamp = invoker.getUrl().getParameter(Constants.TIMESTAMP_KEY, 0L);\n+            if (timestamp > 0L) {\n+                int uptime = (int) (System.currentTimeMillis() - timestamp);\n+                int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);\n+                if (uptime > 0 && uptime < warmup) {\n+                    weight = calculateWarmupWeight(uptime, warmup, weight);\n+                }\n+            }\n+        }\n+        return weight;\n+    }\n+\n+    static int calculateWarmupWeight(int uptime, int warmup, int weight) {\n+        int ww = (int) ( (float) uptime / ( (float) warmup / (float) weight ) );\n+        return ww < 1 ? 1 : (ww > weight ? weight : ww);\n+    }\n }",
    "output": "Fix alibaba AbstractLoadBalance compact"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n@@ -359,11 +359,11 @@ private static Object realize1(Object pojo, Class<?> type, Type genericType, fin\n         Map<String, Type> mapGeneric = new HashMap<>(8);\n         mapGeneric.putAll(mapParent);\n         TypeVariable<? extends Class<?>>[] typeParameters = type.getTypeParameters();\n-        if(genericType instanceof ParameterizedType && typeParameters.length > 0) {\n-            ParameterizedType parameterizedType = (ParameterizedType)genericType;\n+        if (genericType instanceof ParameterizedType && typeParameters.length > 0) {\n+            ParameterizedType parameterizedType = (ParameterizedType) genericType;\n             Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n             for (int i = 0; i < typeParameters.length; i++) {\n-                if(!(actualTypeArguments[i] instanceof TypeVariable)) {\n+                if (!(actualTypeArguments[i] instanceof TypeVariable)) {\n                     mapGeneric.put(typeParameters[i].getTypeName(), actualTypeArguments[i]);\n                 }\n             }\n@@ -534,26 +534,23 @@ private static Object realize1(Object pojo, Class<?> type, Type genericType, fin\n                         Object value = entry.getValue();\n                         if (value != null) {\n                             Method method = getSetterMethod(dest.getClass(), name, value.getClass());\n-                            Field field = getField(dest.getClass(), name);\n+                            Field field = getAndCacheField(dest.getClass(), name);\n                             if (method != null) {\n                                 if (!method.isAccessible()) {\n                                     method.setAccessible(true);\n                                 }\n                                 Type containType = mapGeneric.get(field.getGenericType().getTypeName());\n-                                if(containType != null) {\n+                                if (containType != null) {\n                                     //is generic\n-                                    if(containType instanceof ParameterizedType) {\n-                                        value = realize1(value, (Class<?>) ((ParameterizedType)containType).getRawType(), containType, mapGeneric, history);\n-                                    }\n-                                    else if (containType instanceof Class){\n+                                    if (containType instanceof ParameterizedType) {\n+                                        value = realize1(value, (Class<?>) ((ParameterizedType) containType).getRawType(), containType, mapGeneric, history);\n+                                    } else if (containType instanceof Class) {\n                                         value = realize1(value, (Class<?>) containType, containType, mapGeneric, history);\n-                                    }\n-                                    else {\n+                                    } else {\n                                         Type ptype = method.getGenericParameterTypes()[0];\n                                         value = realize1(value, method.getParameterTypes()[0], ptype, mapGeneric, history);\n                                     }\n-                                }\n-                                else {\n+                                } else {\n                                     Type ptype = method.getGenericParameterTypes()[0];\n                                     value = realize1(value, method.getParameterTypes()[0], ptype, mapGeneric, history);\n                                 }\n@@ -626,15 +623,15 @@ private static Object newThrowableInstance(Class<?> cls, String message) {\n         try {\n             Constructor<?> messagedConstructor = cls.getDeclaredConstructor(String.class);\n             return messagedConstructor.newInstance(message);\n-        } catch (Throwable t) {\n+        } catch (Exception t) {\n             return newInstance(cls);\n         }\n     }\n     private static Object newInstance(Class<?> cls) {\n         try {\n             return cls.getDeclaredConstructor().newInstance();\n-        } catch (Throwable t) {\n+        } catch (Exception t) {\n             Constructor<?>[] constructors = cls.getDeclaredConstructors();\n             /*\n               From Javadoc java.lang.Class#getDeclaredConstructors\n@@ -653,7 +650,7 @@ declared by the class represented by this Class object.\n                     constructor.setAccessible(true);\n                     Object[] parameters = Arrays.stream(constructor.getParameterTypes()).map(PojoUtils::getDefaultValue).toArray();\n                     return constructor.newInstance(parameters);\n-                } catch (Throwable e) {\n+                } catch (Exception e) {\n                     lastError = e;\n                 }\n             }\n@@ -704,12 +701,24 @@ private static Method getSetterMethod(Class<?> cls, String property, Class<?> va\n         return method;\n     }\n-    private static Field getField(Class<?> cls, String fieldName) {\n-        Field result = null;\n+    private static Field getAndCacheField(Class<?> cls, String fieldName) {\n+        Field result;\n         if (CLASS_FIELD_CACHE.containsKey(cls) && CLASS_FIELD_CACHE.get(cls).containsKey(fieldName)) {\n             return CLASS_FIELD_CACHE.get(cls).get(fieldName);\n         }\n-        for(Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n+\n+        result = getField(cls, fieldName);\n+\n+        if (result != null) {\n+            ConcurrentMap<String, Field> fields = CLASS_FIELD_CACHE.computeIfAbsent(cls, k -> new ConcurrentHashMap<>());\n+            fields.putIfAbsent(fieldName, result);\n+        }\n+        return result;\n+    }\n+\n+    private static Field getField(Class<?> cls, String fieldName) {\n+        Field result = null;\n+        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n             try {\n                 result = acls.getDeclaredField(fieldName);\n                 if (!Modifier.isPublic(result.getModifiers())) {\n@@ -718,19 +727,14 @@ private static Field getField(Class<?> cls, String fieldName) {\n             } catch (NoSuchFieldException e) {\n             }\n         }\n-        if(result == null) {\n+        if (result == null && cls != null) {\n             for (Field field : cls.getFields()) {\n                 if (fieldName.equals(field.getName()) && ReflectUtils.isPublicInstanceField(field)) {\n                     result = field;\n                     break;\n                 }\n             }\n         }\n-\n-        if (result != null) {\n-            ConcurrentMap<String, Field> fields = CLASS_FIELD_CACHE.computeIfAbsent(cls, k -> new ConcurrentHashMap<>());\n-            fields.putIfAbsent(fieldName, result);\n-        }\n         return result;\n     }",
    "output": "Fix PojoUtils NPE problem * Fix PojoUtils NPE problem"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java\n@@ -136,14 +136,13 @@ protected void initServerBootstrap(NettyServerHandler nettyServerHandler) {\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n-                    // FIXME: should we use getTimeout()?\n-                    int idleTimeout = UrlUtils.getIdleTimeout(getUrl());\n+                    int closeTimeout = UrlUtils.getCloseTimeout(getUrl());\n                     NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);\n                     ch.pipeline().addLast(\"negotiation\", new SslServerTlsHandler(getUrl()));\n                     ch.pipeline()\n                         .addLast(\"decoder\", adapter.getDecoder())\n                         .addLast(\"encoder\", adapter.getEncoder())\n-                        .addLast(\"server-idle-handler\", new IdleStateHandler(0, 0, idleTimeout, MILLISECONDS))\n+                        .addLast(\"server-idle-handler\", new IdleStateHandler(0, 0, closeTimeout, MILLISECONDS))\n                         .addLast(\"handler\", nettyServerHandler);\n                 }\n             });",
    "output": "Fix netty4 server close timeout"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java\n@@ -72,7 +72,7 @@ final class NettyChannel extends AbstractChannel {\n     private final Netty4BatchWriteQueue writeQueue;\n-    private final Codec2 codec;\n+    private Codec2 codec;\n     private final boolean encodeInIOThread;\n@@ -365,4 +365,8 @@ private static Codec2 getChannelCodec(URL url) {\n             return frameworkModel.getExtensionLoader(Codec2.class).getExtension(\"default\");\n         }\n     }\n+\n+    public void setCodec(Codec2 codec) {\n+        this.codec = codec;\n+    }\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConfigOperator.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConfigOperator.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConfigOperator.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConfigOperator.java\n@@ -60,6 +60,7 @@ public void configChannelHandler(List<ChannelHandler> handlerList) {\n         }\n         if (!(codec2 instanceof DefaultCodec)){\n+            ((NettyChannel) channel).setCodec(codec2);\n             NettyCodecAdapter codec = new NettyCodecAdapter(codec2, channel.getUrl(), handler);\n             ((NettyChannel) channel).getNioChannel().pipeline().addLast(\n                 codec.getDecoder()",
    "output": "Fix PortUnification+encodeInIOThread=false cause server response empty buffer"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/AnnotationUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/AnnotationUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/AnnotationUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/AnnotationUtils.java\n@@ -418,7 +418,7 @@ static boolean isAnnotationPresent(Class<?> type, Class<? extends Annotation> an\n     static boolean isAnnotationPresent(AnnotatedElement annotatedElement, String annotationClassName) {\n         ClassLoader classLoader = annotatedElement.getClass().getClassLoader();\n         Class<?> resolvedType = resolveClass(annotationClassName, classLoader);\n-        if (!Annotation.class.isAssignableFrom(resolvedType)) {\n+        if (resolvedType == null || !Annotation.class.isAssignableFrom(resolvedType)) {\n             return false;\n         }\n         return isAnnotationPresent(annotatedElement, (Class<? extends Annotation>) resolvedType);",
    "output": "Fix NPE issue#12292 Fix NPE issue#12292"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java\n@@ -18,6 +18,8 @@\n package org.apache.dubbo.rpc.cluster.support.wrapper;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.url.component.ServiceConfigURL;\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.rpc.Exporter;\n@@ -38,12 +40,14 @@\n import java.util.List;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import static org.apache.dubbo.common.constants.CommonConstants.CLUSTER_KEY;\n import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;\n import static org.apache.dubbo.rpc.Constants.LOCAL_PROTOCOL;\n import static org.apache.dubbo.rpc.Constants.SCOPE_KEY;\n import static org.apache.dubbo.rpc.Constants.SCOPE_REMOTE;\n import static org.apache.dubbo.rpc.Constants.SCOPE_LOCAL;\n import static org.apache.dubbo.rpc.cluster.Constants.PEER_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.BROADCAST_CLUSTER;\n /**\n  * ScopeClusterInvoker is a cluster invoker which handles the invocation logic of a single service in a specific scope.\n@@ -53,6 +57,10 @@\n  * @param <T> the type of service interface\n  */\n public class ScopeClusterInvoker<T> implements ClusterInvoker<T>, ExporterChangeListener {\n+\n+    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(ScopeClusterInvoker.class);\n+\n+\n     private final Object createLock = new Object();\n     private Protocol protocolSPI;\n     private final Directory<T> directory;\n@@ -119,14 +127,30 @@ public Class<T> getInterface() {\n      */\n     @Override\n     public Result invoke(Invocation invocation) throws RpcException {\n+        // When broadcasting, it should be called remotely.\n+        if (BROADCAST_CLUSTER.equalsIgnoreCase(getUrl().getParameter(CLUSTER_KEY))) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Performing broadcast call for method: \" + invocation.getMethodName() + \" of service: \" + getUrl().getServiceKey());\n+            }\n+            return invoker.invoke(invocation);\n+        }\n         if (peerFlag) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Performing point-to-point call for method: \" + invocation.getMethodName() + \" of service: \" + getUrl().getServiceKey());\n+            }\n             // If it's a point-to-point direct connection, invoke the original Invoker\n             return invoker.invoke(invocation);\n         }\n         if (isInjvmExported()) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Performing local JVM call for method: \" + invocation.getMethodName() + \" of service: \" + getUrl().getServiceKey());\n+            }\n             // If it's exported to the local JVM, invoke the corresponding Invoker\n             return injvmInvoker.invoke(invocation);\n         }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Performing remote call for method: \" + invocation.getMethodName() + \" of service: \" + getUrl().getServiceKey());\n+        }\n         // Otherwise, delegate the invocation to the original Invoker\n         return invoker.invoke(invocation);\n     }\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvokerTest.java\n@@ -320,6 +320,24 @@ void testDynamicInvoke() {\n         Assertions.assertEquals(\"doSomething8\", ret3.getValue());\n     }\n+    @Test\n+    void testBroadcast() {\n+        URL url = URL.valueOf(\"remote://1.2.3.4/\" + DemoService.class.getName());\n+        url = url.addParameter(REFER_KEY,\n+            URL.encode(PATH_KEY + \"=\" + DemoService.class.getName()));\n+        url = url.addParameter(\"cluster\",\"broadcast\");\n+        url = url.setScopeModel(ApplicationModel.defaultModel().getDefaultModule());\n+        Invoker<DemoService> cluster = getClusterInvoker(url);\n+\n+        invokers.add(cluster);\n+\n+        RpcInvocation invocation = new RpcInvocation();\n+        invocation.setMethodName(\"doSomething8\");\n+        invocation.setParameterTypes(new Class[]{});\n+        Result ret = cluster.invoke(invocation);\n+        Assertions.assertEquals(\"doSomething8\", ret.getValue());\n+    }\n+\n     private Invoker<DemoService> getClusterInvoker(URL url) {\n         final URL durl = url.addParameter(\"proxy\", \"jdk\");\n         invokers.clear();",
    "output": "Fix issue #12334.provide broadcast rules to adapt the calling mode. * Fix issue #12334.provide broadcast rules to adapt the calling mode. * add isDebugEnabled"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n@@ -316,7 +316,7 @@ private void onModuleFailed(String msg, Throwable ex) {\n         try {\n             setFailed(ex);\n             logger.error(CONFIG_FAILED_START_MODEL, \"\", \"\", \"Model start failed: \" + msg, ex);\n-            applicationDeployer.notifyModuleChanged(moduleModel, DeployState.STARTED);\n+            applicationDeployer.notifyModuleChanged(moduleModel, DeployState.FAILED);\n         } finally {\n             completeStartFuture(false);\n         }",
    "output": "Fix DefaultModuleDeployer start fail, but export MetadataService"
  },
  {
    "input": "diff --git a/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/util/KubernetesConfigUtils.java b/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/util/KubernetesConfigUtils.java\n--- a/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/util/KubernetesConfigUtils.java\n+++ b/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/util/KubernetesConfigUtils.java\n@@ -89,7 +89,7 @@ public static Config createKubernetesConfig(URL url) {\n                 .withLoggingInterval(url.getParameter(LOGGING_INTERVAL, base.getLoggingInterval())) //\n                 .withTrustCerts(url.getParameter(TRUST_CERTS, base.isTrustCerts())) //\n-                .withHttp2Disable(url.getParameter(HTTP2_DISABLE, base.isTrustCerts())) //\n+                .withHttp2Disable(url.getParameter(HTTP2_DISABLE, base.isHttp2Disable())) //\n                 .withHttpProxy(url.getParameter(HTTP_PROXY, base.getHttpProxy())) //\n                 .withHttpsProxy(url.getParameter(HTTPS_PROXY, base.getHttpsProxy())) //",
    "output": "Fix k8s client http2Disable default value is wrong"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/key/MetricsKey.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/key/MetricsKey.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/key/MetricsKey.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/key/MetricsKey.java\n@@ -55,6 +55,8 @@ public enum MetricsKey {\n     METRIC_RT_AVG(\"dubbo.%s.rt.milliseconds.avg\", \"Average Response Time\"),\n     METRIC_RT_P99(\"dubbo.%s.rt.milliseconds.p99\", \"Response Time P99\"),\n     METRIC_RT_P95(\"dubbo.%s.rt.milliseconds.p95\", \"Response Time P95\"),\n+    METRIC_RT_P90(\"dubbo.%s.rt.milliseconds.p90\", \"Response Time P90\"),\n+    METRIC_RT_P50(\"dubbo.%s.rt.milliseconds.p50\", \"Response Time P50\"),\n     // register metrics key\ndiff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n@@ -198,7 +198,11 @@ private void collectRT(List<MetricSample> list) {\n             list.add(new GaugeMetricSample<>(MetricsKey.METRIC_RT_P99.getNameByType(k.getSide()),\n                 MetricsKey.METRIC_RT_P99.getDescription(), k.getTags(), RT, v, value -> value.quantile(0.99)));\n             list.add(new GaugeMetricSample<>(MetricsKey.METRIC_RT_P95.getNameByType(k.getSide()),\n-                MetricsKey.METRIC_RT_P99.getDescription(), k.getTags(), RT, v, value -> value.quantile(0.95)));\n+                MetricsKey.METRIC_RT_P95.getDescription(), k.getTags(), RT, v, value -> value.quantile(0.95)));\n+            list.add(new GaugeMetricSample<>(MetricsKey.METRIC_RT_P90.getNameByType(k.getSide()),\n+                MetricsKey.METRIC_RT_P90.getDescription(), k.getTags(), RT, v, value -> value.quantile(0.90)));\n+            list.add(new GaugeMetricSample<>(MetricsKey.METRIC_RT_P50.getNameByType(k.getSide()),\n+                MetricsKey.METRIC_RT_P50.getDescription(), k.getTags(), RT, v, value -> value.quantile(0.50)));\n         });\n     }",
    "output": "Add P50 and P90 RT metrics"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n@@ -51,10 +51,7 @@ protected Serializer getDefaultSerializer(Class cl) {\n             // ignore\n         }\n-        if (!Serializable.class.isAssignableFrom(cl)\n-            && (!isAllowNonSerializable() || defaultSerializeClassChecker.isCheckSerializable())) {\n-            throw new IllegalStateException(\"Serialized class \" + cl.getName() + \" must implement java.io.Serializable\");\n-        }\n+        checkSerializable(cl);\n         return new JavaSerializer(cl, getClassLoader());\n     }\n@@ -68,11 +65,20 @@ protected Deserializer getDefaultDeserializer(Class cl) {\n             // ignore\n         }\n+        checkSerializable(cl);\n+\n+        return new JavaDeserializer(cl);\n+    }\n+\n+    private void checkSerializable(Class<?> cl) {\n+        // If class is Serializable => ok\n+        // If class has not implement Serializable\n+        //      If hessian check serializable => fail\n+        //      If dubbo class checker check serializable => fail\n+        //      If both hessian and dubbo class checker allow non-serializable => ok\n         if (!Serializable.class.isAssignableFrom(cl)\n-            && (!isAllowNonSerializable() || !defaultSerializeClassChecker.isCheckSerializable())) {\n+            && (!isAllowNonSerializable() || defaultSerializeClassChecker.isCheckSerializable())) {\n             throw new IllegalStateException(\"Serialized class \" + cl.getName() + \" must implement java.io.Serializable\");\n         }\n-\n-        return new JavaDeserializer(cl);\n     }\n }",
    "output": "Fix allow non-serializable check * Fix allow non-serializable check * opt code * opt code ---------"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/isolation/api/ApiIsolationTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/isolation/api/ApiIsolationTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/isolation/api/ApiIsolationTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/isolation/api/ApiIsolationTest.java\n@@ -32,9 +32,11 @@\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.test.check.registrycenter.config.ZookeeperRegistryCenterConfig;\n+\n import org.junit.jupiter.api.AfterAll;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n import java.util.concurrent.ExecutorService;\n@@ -64,6 +66,7 @@ public static void afterAll() throws Exception {\n     @Test\n+    @Disabled\n     public void test() throws Exception {",
    "output": "Upgrade zk version * Update zk version * tmp disable * Update build-and-test-pr.yml"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n@@ -148,16 +148,23 @@ protected Object decodeBody(Channel channel, InputStream is, byte[] header) thro\n                     if (CodecSupport.isHeartBeat(eventPayload, proto)) {\n                         // heart beat response data is always null;\n                         req = new HeartBeatRequest(id);\n+                        req.setVersion(Version.getProtocolVersion());\n+                        req.setTwoWay((flag & FLAG_TWOWAY) != 0);\n                         ((HeartBeatRequest) req).setProto(proto);\n                         data = null;\n                     } else {\n                         req = new Request(id);\n+                        req.setVersion(Version.getProtocolVersion());\n+                        req.setTwoWay((flag & FLAG_TWOWAY) != 0);\n+\n                         ObjectInput in = CodecSupport.deserialize(channel.getUrl(), new ByteArrayInputStream(eventPayload), proto);\n                         data = decodeEventData(channel, in, eventPayload);\n                     }\n                     req.setEvent(true);\n                 } else {\n                     req = new Request(id);\n+                    req.setVersion(Version.getProtocolVersion());\n+                    req.setTwoWay((flag & FLAG_TWOWAY) != 0);\n                     // get data length.\n                     int len = Bytes.bytes2int(header, 12);\n@@ -192,8 +199,6 @@ protected Object decodeBody(Channel channel, InputStream is, byte[] header) thro\n                 req.setBroken(true);\n                 req.setData(t);\n             }\n-            req.setVersion(Version.getProtocolVersion());\n-            req.setTwoWay((flag & FLAG_TWOWAY) != 0);\n             return req;\n         }",
    "output": "Fix version detect"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/exception/mapper/ExceptionMapper.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/exception/mapper/ExceptionMapper.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/exception/mapper/ExceptionMapper.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/exception/mapper/ExceptionMapper.java\n@@ -38,18 +38,31 @@ public class ExceptionMapper {\n     private final Map<Class<?>, ExceptionHandler> exceptionHandlerMap = new ConcurrentHashMap<>();\n     public Object exceptionToResult(Object throwable) {\n-        if (!hasExceptionMapper(throwable)) {\n+        ExceptionHandler exceptionHandler = getExceptionHandler(throwable.getClass());\n+        if (exceptionHandler == null) {\n             return throwable;\n         }\n+        return exceptionHandler.result((Throwable) throwable);\n+    }\n-        return exceptionHandlerMap.get(throwable.getClass()).result((Throwable) throwable);\n+    public ExceptionHandler getExceptionHandler(Class causeClass) {\n+        ExceptionHandler exceptionHandler = null;\n+        while (causeClass != null) {\n+            exceptionHandler = exceptionHandlerMap.get(causeClass);\n+            if (exceptionHandler != null) {\n+                break;\n+            }\n+            // When the exception handling class cannot be obtained, it should recursively search the base class\n+            causeClass = causeClass.getSuperclass();\n+        }\n+        return exceptionHandler;\n     }\n     public boolean hasExceptionMapper(Object throwable) {\n         if (throwable == null) {\n             return false;\n         }\n-        return exceptionHandlerMap.containsKey(throwable.getClass());\n+        return getExceptionHandler(throwable.getClass()) != null;\n     }",
    "output": "Fix When the exception handling class cannot be obtained, it should recursively search the base class"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java\n@@ -88,7 +88,7 @@ public static class Single {\n             @EnableConfigurationBeanBinding(prefix = \"dubbo.config-centers\", type = ConfigCenterBean.class, multiple = true),\n             @EnableConfigurationBeanBinding(prefix = \"dubbo.metadata-reports\", type = MetadataReportConfig.class, multiple = true),\n             @EnableConfigurationBeanBinding(prefix = \"dubbo.metricses\", type = MetricsConfig.class, multiple = true),\n-            @EnableConfigurationBeanBinding(prefix = \"dubbo.tracing\", type = TracingConfig.class)\n+            @EnableConfigurationBeanBinding(prefix = \"dubbo.tracings\", type = TracingConfig.class, multiple = true)\n     })\n     public static class Multiple {",
    "output": "Fix mutiple tracing config"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedUnsubscribedTask.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedUnsubscribedTask.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedUnsubscribedTask.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedUnsubscribedTask.java\n@@ -41,7 +41,7 @@ public FailedUnsubscribedTask(URL url, FailbackRegistry registry, NotifyListener\n     @Override\n     protected void doRetry(URL url, FailbackRegistry registry, Timeout timeout) {\n-        registry.unsubscribe(url, listener);\n+        registry.doUnsubscribe(url, listener);\n         registry.removeFailedUnsubscribedTask(url, listener);\n     }\n }",
    "output": "Fix inappropriate invoke in unsubscribe retry task"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedUnsubscribedTask.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedUnsubscribedTask.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedUnsubscribedTask.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedUnsubscribedTask.java\n@@ -41,7 +41,7 @@ public FailedUnsubscribedTask(URL url, FailbackRegistry registry, NotifyListener\n     @Override\n     protected void doRetry(URL url, FailbackRegistry registry, Timeout timeout) {\n-        registry.unsubscribe(url, listener);\n+        registry.doUnsubscribe(url, listener);\n         registry.removeFailedUnsubscribedTask(url, listener);\n     }\n }",
    "output": "Fix inappropriate invoke in unsubscribe retry task"
  },
  {
    "input": "diff --git a/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java b/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n--- a/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n+++ b/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n@@ -54,7 +54,6 @@ class FileTest {\n         ignoredArtifacts.add(Pattern.compile(\"dubbo-demo.*\"));\n         ignoredArtifacts.add(Pattern.compile(\"dubbo-test.*\"));\n-        ignoredArtifacts.add(Pattern.compile(\"dubbo-config-spring6.*\"));\n         ignoredArtifacts.add(Pattern.compile(\"dubbo-annotation-processor\"));\n         ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo\"));",
    "output": "Fix the dubbo-config-spring6 module is lost"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -688,7 +688,7 @@ public RegistryConfig getRegistry() {\n     }\n     public void setRegistry(RegistryConfig registry) {\n-        List<RegistryConfig> registries = new ArrayList<RegistryConfig>(1);\n+        List<RegistryConfig> registries = new ArrayList<>(1);\n         registries.add(registry);\n         setRegistries(registries);\n     }\n@@ -716,7 +716,6 @@ public List<MethodConfig> getMethods() {\n         return methods;\n     }\n-    @SuppressWarnings(\"unchecked\")\n     public void setMethods(List<? extends MethodConfig> methods) {\n         this.methods = (methods != null) ? new ArrayList<>(methods) : null;\n     }\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanSupport.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanSupport.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanSupport.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanSupport.java\n@@ -51,7 +51,7 @@\n public class ReferenceBeanSupport {\n-    private static List<String> IGNORED_ATTRS = Arrays.asList(ReferenceAttributes.ID, ReferenceAttributes.GROUP,\n+    private static final List<String> IGNORED_ATTRS = Arrays.asList(ReferenceAttributes.ID, ReferenceAttributes.GROUP,\n         ReferenceAttributes.VERSION, ReferenceAttributes.INTERFACE, ReferenceAttributes.INTERFACE_NAME,\n         ReferenceAttributes.INTERFACE_CLASS);\n@@ -65,7 +65,7 @@ public static void convertReferenceProps(Map<String, Object> attributes, Class d\n         if (interfaceName == null) {\n             Object interfaceClassValue = attributes.get(ReferenceAttributes.INTERFACE_CLASS);\n             if (interfaceClassValue instanceof Class) {\n-                interfaceName = ((Class) interfaceClassValue).getName();\n+                interfaceName = ((Class<?>) interfaceClassValue).getName();\n             } else if (interfaceClassValue instanceof String) {\n                 if (interfaceClassValue.equals(\"void\")) {\n                     attributes.remove(ReferenceAttributes.INTERFACE_CLASS);\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n@@ -175,7 +175,10 @@ private static RootBeanDefinition parse(Element element, ParserContext parserCon\n                     if (\"registry\".equals(property) && RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) {\n                         RegistryConfig registryConfig = new RegistryConfig();\n                         registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);\n-                        beanDefinition.getPropertyValues().addPropertyValue(beanProperty, registryConfig);\n+                        // see AbstractInterfaceConfig#registries, It will be invoker setRegistries method when BeanDefinition is registered,\n+                        beanDefinition.getPropertyValues().addPropertyValue(\"registries\", registryConfig);\n+                        // If registry is N/A, don't init it until the reference is invoked\n+                        beanDefinition.setLazyInit(true);\n                     } else if (\"provider\".equals(property) || \"registry\".equals(property) || (\"protocol\".equals(property) && AbstractServiceConfig.class.isAssignableFrom(beanClass))) {\n                         /**\n                          * For 'provider' 'protocol' 'registry', keep literal value (should be id/name) and set the value to 'registryIds' 'providerIds' protocolIds'\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/registryNA/consumer/DubboXmlConsumerTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/registryNA/consumer/DubboXmlConsumerTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/registryNA/consumer/DubboXmlConsumerTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/registryNA/consumer/DubboXmlConsumerTest.java\n@@ -0,0 +1,36 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.config.spring.reference.registryNA.consumer;\n+\n+import org.apache.dubbo.config.spring.api.HelloService;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.context.support.ClassPathXmlApplicationContext;\n+\n+class DubboXmlConsumerTest {\n+\n+\n+    @Test\n+    void testConsumer() {\n+        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:/org/apache/dubbo/config/spring/reference/registryNA/consumer/dubbo-registryNA-consumer.xml\");\n+        context.start();\n+        HelloService helloService = context.getBean(\"helloService\", HelloService.class);\n+        IllegalStateException exception = Assertions.assertThrows(IllegalStateException.class, () -> helloService.sayHello(\"dubbo\"));\n+        Assertions.assertTrue(exception.getMessage().contains(\"No such any registry to reference org.apache.dubbo.config.spring.api.HelloService\"));\n+    }\n+\n+}\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/registryNA/provider/DubboXmlProviderTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/registryNA/provider/DubboXmlProviderTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/registryNA/provider/DubboXmlProviderTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/registryNA/provider/DubboXmlProviderTest.java\n@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.config.spring.reference.registryNA.provider;\n+\n+import org.apache.dubbo.config.spring.api.HelloService;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.context.support.ClassPathXmlApplicationContext;\n+\n+/**\n+ * @author <a href = \"mailto:kamtohung@gmail.com\">KamTo Hung</a>\n+ */\n+public class DubboXmlProviderTest {\n+\n+    @Test\n+    void testProvider() {\n+        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:/org/apache/dubbo/config/spring/reference/registryNA/provider/dubbo-provider.xml\");\n+        context.start();\n+        Object bean = context.getBean(\"helloService\");\n+        Assertions.assertNotNull(bean);\n+    }\n+\n+    @Test\n+    void testProvider2() {\n+        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:/org/apache/dubbo/config/spring/reference/registryNA/provider/dubbo-provider.xml\");\n+        context.start();\n+        Assertions.assertNotNull(context.getBean(\"helloService\"));\n+        ClassPathXmlApplicationContext context2 = new ClassPathXmlApplicationContext(\"classpath:/org/apache/dubbo/config/spring/reference/registryNA/consumer/dubbo-consumer.xml\");\n+        context2.start();\n+        HelloService helloService = context2.getBean(\"helloService\", HelloService.class);\n+        Assertions.assertNotNull(helloService);\n+        RpcException exception = Assertions.assertThrows(RpcException.class, () -> helloService.sayHello(\"dubbo\"));\n+        Assertions.assertTrue(exception.getMessage().contains(\"Failed to invoke the method sayHello in the service org.apache.dubbo.config.spring.api.HelloService. No provider available for the service org.apache.dubbo.config.spring.api.HelloService\"));\n+    }\n+\n+}",
    "output": "Fix consumer startup failure * * * add UT *"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannelHandler.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannelHandler.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannelHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannelHandler.java\n@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.remoting.transport.netty4;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.remoting.Channel;\n+import org.apache.dubbo.remoting.ChannelHandler;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Map;\n+\n+public class NettyChannelHandler extends ChannelInboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(NettyChannelHandler.class);\n+\n+    private final Map<String, Channel> dubboChannels;\n+\n+    private final URL url;\n+    private final ChannelHandler handler;\n+\n+    public NettyChannelHandler(Map<String, Channel> dubboChannels, URL url, ChannelHandler handler) {\n+        this.dubboChannels = dubboChannels;\n+        this.url = url;\n+        this.handler = handler;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        super.channelActive(ctx);\n+        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n+        if (channel != null) {\n+            dubboChannels.put(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()), channel);\n+            handler.connected(channel);\n+\n+            if (logger.isInfoEnabled()) {\n+                logger.info(\"The connection of \" + channel.getRemoteAddress() + \" -> \" + channel.getLocalAddress() + \" is established.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        super.channelInactive(ctx);\n+        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n+        try {\n+            dubboChannels.remove(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()));\n+            if (channel != null) {\n+                handler.disconnected(channel);\n+                if (logger.isInfoEnabled()) {\n+                    logger.info(\"The connection of \" + channel.getRemoteAddress() + \" -> \" + channel.getLocalAddress() + \" is disconnected.\");\n+                }\n+            }\n+        } finally {\n+            NettyChannel.removeChannel(ctx.channel());\n+        }\n+    }\n+\n+}\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java\n@@ -122,10 +122,11 @@ public void doOpen() {\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     // Do not add idle state handler here, because it should be added in the protocol handler.\n                     final ChannelPipeline p = ch.pipeline();\n-                    final NettyPortUnificationServerHandler puHandler;\n-                    puHandler = new NettyPortUnificationServerHandler(getUrl(), true, getProtocols(),\n-                        NettyPortUnificationServer.this, NettyPortUnificationServer.this.dubboChannels,\n+                    NettyChannelHandler nettyChannelHandler = new NettyChannelHandler(dubboChannels, getUrl(), NettyPortUnificationServer.this);\n+                    NettyPortUnificationServerHandler puHandler = new NettyPortUnificationServerHandler(getUrl(), true, getProtocols(),\n+                        NettyPortUnificationServer.this,\n                         getSupportedUrls(), getSupportedHandlers());\n+                    p.addLast(\"channel-handler\", nettyChannelHandler);\n                     p.addLast(\"negotiation-protocol\", puHandler);\n                 }\n             });\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java\n@@ -22,8 +22,6 @@\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.ssl.CertManager;\n import org.apache.dubbo.common.ssl.ProviderCert;\n-import org.apache.dubbo.common.utils.NetUtils;\n-import org.apache.dubbo.remoting.Channel;\n import org.apache.dubbo.remoting.ChannelHandler;\n import org.apache.dubbo.remoting.api.ProtocolDetector;\n import org.apache.dubbo.remoting.api.WireProtocol;\n@@ -39,7 +37,6 @@\n import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n import javax.net.ssl.SSLSession;\n-import java.net.InetSocketAddress;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -54,19 +51,17 @@ public class NettyPortUnificationServerHandler extends ByteToMessageDecoder {\n     private final ChannelHandler handler;\n     private final boolean detectSsl;\n     private final List<WireProtocol> protocols;\n-    private final Map<String, Channel> dubboChannels;\n     private final Map<String, URL> urlMapper;\n     private final Map<String, ChannelHandler> handlerMapper;\n     public NettyPortUnificationServerHandler(URL url, boolean detectSsl,\n                                              List<WireProtocol> protocols, ChannelHandler handler,\n-                                             Map<String, Channel> dubboChannels, Map<String, URL> urlMapper, Map<String, ChannelHandler> handlerMapper) {\n+                                             Map<String, URL> urlMapper, Map<String, ChannelHandler> handlerMapper) {\n         this.url = url;\n         this.protocols = protocols;\n         this.detectSsl = detectSsl;\n         this.handler = handler;\n-        this.dubboChannels = dubboChannels;\n         this.urlMapper = urlMapper;\n         this.handlerMapper = handlerMapper;\n     }\n@@ -76,16 +71,6 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E\n         LOGGER.error(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"Unexpected exception from downstream before protocol detected.\", cause);\n     }\n-    @Override\n-    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n-        super.channelActive(ctx);\n-        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n-        if (channel != null) {\n-            // this is needed by some test cases\n-            dubboChannels.put(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()), channel);\n-        }\n-    }\n-\n     @Override\n     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n         if (evt instanceof SslHandshakeCompletionEvent) {\n@@ -162,7 +147,7 @@ private void enableSsl(ChannelHandlerContext ctx, ProviderCert providerConnectio\n         p.addLast(\"ssl\", sslContext.newHandler(ctx.alloc()));\n         p.addLast(\"unificationA\",\n             new NettyPortUnificationServerHandler(url, false, protocols,\n-                handler, dubboChannels, urlMapper, handlerMapper));\n+                handler, urlMapper, handlerMapper));\n         p.remove(this);\n     }",
    "output": "Fix port unification channel leak"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n@@ -124,7 +124,14 @@ public void decode() throws Exception {\n         if (!hasDecoded && channel != null && inputStream != null) {\n             try {\n                 if (invocation != null) {\n-                    Configuration systemConfiguration = ConfigurationUtils.getSystemConfiguration(channel.getUrl().getScopeModel());\n+                    Configuration systemConfiguration = null;\n+                    try {\n+                        systemConfiguration = ConfigurationUtils.getSystemConfiguration(channel.getUrl().getScopeModel());\n+                    } catch (Exception e) {\n+                        // Because the Environment may be destroyed during the offline process, the configuration cannot be obtained.\n+                        // Exceptions are ignored here, and normal decoding is guaranteed.\n+                    }\n+\n                     if (systemConfiguration == null || systemConfiguration.getBoolean(SERIALIZATION_SECURITY_CHECK_KEY, true)) {\n                         Object serializationTypeObj = invocation.get(SERIALIZATION_ID_KEY);\n                         if (serializationTypeObj != null) {",
    "output": "Fix npe occurs during client graceful offline."
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-metadata/src/test/java/org/apache/dubbo/metrics/metadata/MetadataMetricsCollectorTest.java b/dubbo-metrics/dubbo-metrics-metadata/src/test/java/org/apache/dubbo/metrics/metadata/MetadataMetricsCollectorTest.java\n--- a/dubbo-metrics/dubbo-metrics-metadata/src/test/java/org/apache/dubbo/metrics/metadata/MetadataMetricsCollectorTest.java\n+++ b/dubbo-metrics/dubbo-metrics-metadata/src/test/java/org/apache/dubbo/metrics/metadata/MetadataMetricsCollectorTest.java\n@@ -22,34 +22,34 @@\n import org.apache.dubbo.metrics.event.MetricsEventBus;\n import org.apache.dubbo.metrics.metadata.collector.MetadataMetricsCollector;\n import org.apache.dubbo.metrics.metadata.event.MetadataEvent;\n+import org.apache.dubbo.metrics.model.TimePair;\n import org.apache.dubbo.metrics.model.key.MetricsKey;\n import org.apache.dubbo.metrics.model.key.MetricsKeyWrapper;\n-import org.apache.dubbo.metrics.model.TimePair;\n import org.apache.dubbo.metrics.model.sample.GaugeMetricSample;\n import org.apache.dubbo.metrics.model.sample.MetricSample;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n-\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import java.util.List;\n import java.util.Map;\n+import java.util.NoSuchElementException;\n import java.util.Objects;\n import java.util.stream.Collectors;\n import static org.apache.dubbo.common.constants.MetricsConstants.TAG_APPLICATION_NAME;\n-import static org.apache.dubbo.metrics.metadata.MetadataMetricsConstants.OP_TYPE_PUSH;\n-import static org.apache.dubbo.metrics.metadata.MetadataMetricsConstants.OP_TYPE_STORE_PROVIDER_INTERFACE;\n-import static org.apache.dubbo.metrics.metadata.MetadataMetricsConstants.OP_TYPE_SUBSCRIBE;\n+import static org.apache.dubbo.metrics.metadata.MetadataMetricsConstants.*;\n class MetadataMetricsCollectorTest {\n     private ApplicationModel applicationModel;\n+    private MetadataMetricsCollector collector;\n+\n     @BeforeEach\n     public void setup() {\n         FrameworkModel frameworkModel = FrameworkModel.defaultModel();\n@@ -58,7 +58,10 @@ public void setup() {\n         config.setName(\"MockMetrics\");\n         applicationModel.getApplicationConfigManager().setApplication(config);\n+        applicationModel.getBeanFactory().getOrRegisterBean(MetricsDispatcher.class);\n+        collector = applicationModel.getBeanFactory().getOrRegisterBean(MetadataMetricsCollector.class);\n+        collector.setCollectEnabled(true);\n     }\n     @AfterEach\n@@ -68,10 +71,7 @@ public void teardown() {\n     @Test\n     void testPushMetrics() {\n-\n-        applicationModel.getBeanFactory().getOrRegisterBean(MetricsDispatcher.class);\n-        MetadataMetricsCollector collector = applicationModel.getBeanFactory().getOrRegisterBean(MetadataMetricsCollector.class);\n-        collector.setCollectEnabled(true);\n+//        MetadataMetricsCollector collector = getCollector();\n         MetadataEvent pushEvent = MetadataEvent.toPushEvent(applicationModel);\n         MetricsEventBus.post(pushEvent,\n@@ -129,10 +129,7 @@ void testPushMetrics() {\n     @Test\n     void testSubscribeMetrics() {\n-\n-        applicationModel.getBeanFactory().getOrRegisterBean(MetricsDispatcher.class);\n-        MetadataMetricsCollector collector = applicationModel.getBeanFactory().getOrRegisterBean(MetadataMetricsCollector.class);\n-        collector.setCollectEnabled(true);\n+//        MetadataMetricsCollector collector = getCollector();\n         MetadataEvent subscribeEvent = MetadataEvent.toSubscribeEvent(applicationModel);\n         MetricsEventBus.post(subscribeEvent,\n@@ -191,10 +188,7 @@ void testSubscribeMetrics() {\n     @Test\n     void testStoreProviderMetadataMetrics() {\n-\n-        applicationModel.getBeanFactory().getOrRegisterBean(MetricsDispatcher.class);\n-        MetadataMetricsCollector collector = applicationModel.getBeanFactory().getOrRegisterBean(MetadataMetricsCollector.class);\n-        collector.setCollectEnabled(true);\n+//        MetadataMetricsCollector collector = getCollector();\n         String serviceKey = \"store.provider.test\";\n         MetadataEvent metadataEvent = MetadataEvent.toServiceSubscribeEvent(applicationModel, serviceKey);\n@@ -252,4 +246,54 @@ void testStoreProviderMetadataMetrics() {\n         Assertions.assertEquals(sampleMap.get(new MetricsKeyWrapper(MetricsKey.METRIC_RT_SUM, OP_TYPE_STORE_PROVIDER_INTERFACE).targetKey()), c1 + c2);\n     }\n+    @Test\n+    void testMetadataPushNum() {\n+\n+        for (int i = 0; i < 10; i++) {\n+            MetadataEvent event = MetadataEvent.toPushEvent(applicationModel);\n+            if(i %2 ==0 ) {\n+                MetricsEventBus.post(event,() -> true, r -> r);\n+            }else {\n+                MetricsEventBus.post(event,() -> false, r -> r);\n+            }\n+        }\n+\n+        List<MetricSample> samples = collector.collect();\n+\n+        GaugeMetricSample<?> totalNum = getSample(MetricsKey.METADATA_PUSH_METRIC_NUM.getName(), samples);\n+        GaugeMetricSample<?> succeedNum = getSample(MetricsKey.METADATA_PUSH_METRIC_NUM_SUCCEED.getName(), samples);\n+        GaugeMetricSample<?> failedNum = getSample(MetricsKey.METADATA_PUSH_METRIC_NUM_FAILED.getName(), samples);\n+\n+        Assertions.assertEquals(10,totalNum.applyAsLong());\n+        Assertions.assertEquals(5,succeedNum.applyAsLong());\n+        Assertions.assertEquals(5,failedNum.applyAsLong());\n+    }\n+\n+    @Test\n+    void testSubscribeSum(){\n+\n+        for (int i = 0; i < 10; i++) {\n+            MetadataEvent event = MetadataEvent.toSubscribeEvent(applicationModel);\n+            if(i %2 ==0 ) {\n+                MetricsEventBus.post(event,() -> true, r -> r);\n+            }else {\n+                MetricsEventBus.post(event,() -> false, r -> r);\n+            }\n+        }\n+\n+        List<MetricSample> samples = collector.collect();\n+\n+        GaugeMetricSample<?> totalNum = getSample(MetricsKey.METADATA_SUBSCRIBE_METRIC_NUM.getName(), samples);\n+        GaugeMetricSample<?> succeedNum = getSample(MetricsKey.METADATA_SUBSCRIBE_METRIC_NUM_SUCCEED.getName(), samples);\n+        GaugeMetricSample<?> failedNum = getSample(MetricsKey.METADATA_SUBSCRIBE_METRIC_NUM_FAILED.getName(), samples);\n+\n+        Assertions.assertEquals(10,totalNum.applyAsLong());\n+        Assertions.assertEquals(5,succeedNum.applyAsLong());\n+        Assertions.assertEquals(5,failedNum.applyAsLong());\n+    }\n+\n+    GaugeMetricSample<?> getSample(String name, List<MetricSample> samples) {\n+        return (GaugeMetricSample<?>) samples.stream().filter(metricSample -> metricSample.getName().equals(name)).findFirst().orElseThrow(NoSuchElementException::new);\n+    }\n+\n }",
    "output": "Add test for metadata metrics"
  },
  {
    "input": "diff --git a/dubbo-spring-boot/dubbo-spring-boot-observability-starters/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-observability-starters/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-observability-starters/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-observability-starters/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java\n@@ -44,10 +44,12 @@\n  * {@link EnableAutoConfiguration Auto-configuration} for Zipkin.\n  * <p>\n  * It uses imports on {@link ZipkinConfigurations} to guarantee the correct configuration ordering.\n+ * Create Zipkin sender and exporter when you are using Boot < 3.0 or you are not using spring-boot-starter-actuator.\n+ * When you use SpringBoot 3.*, priority should be given to loading S3 related configurations. Dubbo related zipkin configurations are invalid.\n  *\n  * @since 3.2.1\n  */\n-@AutoConfiguration(after = RestTemplateAutoConfiguration.class)\n+@AutoConfiguration(after = RestTemplateAutoConfiguration.class, afterName = \"org.springframework.boot.actuate.autoconfigure.tracing.zipkin\")\n @ConditionalOnClass(Sender.class)\n @Import({SenderConfiguration.class,\n         ReporterConfiguration.class, BraveConfiguration.class,",
    "output": "Fix load zipkin after springboot3"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MethodMetricsInterceptor.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MethodMetricsInterceptor.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MethodMetricsInterceptor.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MethodMetricsInterceptor.java\n@@ -46,27 +46,28 @@ public void beforeMethod(Invocation invocation) {\n     private String getSide(Invocation invocation) {\n         Optional<? extends Invoker<?>> invoker = Optional.ofNullable(invocation.getInvoker());\n-        String side = invoker.isPresent() ? invoker.get().getUrl().getSide() : PROVIDER_SIDE;\n-        return side;\n+        return invoker.isPresent() ? invoker.get().getUrl().getSide() : PROVIDER_SIDE;\n     }\n     public void afterMethod(Invocation invocation, Result result) {\n         if (result.hasException()) {\n-            handleMethodException(invocation, result.getException());\n+            handleMethodException(invocation, result.getException(), true);\n         } else {\n             sampler.incOnEvent(invocation, MetricsEvent.Type.SUCCEED.getNameByType(getSide(invocation)));\n             onCompleted(invocation);\n         }\n     }\n-    public void handleMethodException(Invocation invocation, Throwable throwable) {\n+    public void handleMethodException(Invocation invocation, Throwable throwable, boolean isBusiness) {\n         if (throwable == null) {\n             return;\n         }\n         String side = getSide(invocation);\n         MetricsEvent.Type eventType = MetricsEvent.Type.UNKNOWN_FAILED;\n-        if (throwable instanceof RpcException) {\n+        if (isBusiness) {\n+            eventType = MetricsEvent.Type.BUSINESS_FAILED;\n+        } else if (throwable instanceof RpcException) {\n             RpcException e = (RpcException) throwable;\n             if (e.isTimeout()) {\n@@ -85,6 +86,7 @@ public void handleMethodException(Invocation invocation, Throwable throwable) {\n                 eventType = MetricsEvent.Type.NETWORK_EXCEPTION;\n             }\n         }\n+\n         sampler.incOnEvent(invocation, eventType.getNameByType(side));\n         onCompleted(invocation);\n         sampler.incOnEvent(invocation, MetricsEvent.Type.TOTAL_FAILED.getNameByType(side));\ndiff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java\n@@ -17,6 +17,8 @@\n package org.apache.dubbo.metrics.filter;\n import org.apache.dubbo.common.extension.Activate;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.metrics.collector.DefaultMetricsCollector;\n import org.apache.dubbo.rpc.BaseFilter;\n import org.apache.dubbo.rpc.Filter;\n@@ -29,10 +31,13 @@\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n @Activate(group = {CONSUMER, PROVIDER}, order = -1)\n public class MetricsFilter implements Filter, BaseFilter.Listener, ScopeModelAware {\n+    private final static ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(MetricsFilter.class);\n+\n     private DefaultMetricsCollector collector = null;\n     private MethodMetricsInterceptor metricsInterceptor;\n@@ -51,7 +56,11 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept\n             return invoker.invoke(invocation);\n         }\n-        metricsInterceptor.beforeMethod(invocation);\n+        try {\n+            metricsInterceptor.beforeMethod(invocation);\n+        } catch (Throwable t) {\n+            LOGGER.warn(INTERNAL_ERROR, \"\", \"\", \"Error occurred when beforeMethod.\", t);\n+        }\n         return invoker.invoke(invocation);\n     }\n@@ -61,15 +70,23 @@ public void onResponse(Result result, Invoker<?> invoker, Invocation invocation)\n         if (collector == null || !collector.isCollectEnabled()) {\n             return;\n         }\n-        metricsInterceptor.afterMethod(invocation, result);\n+        try {\n+            metricsInterceptor.afterMethod(invocation, result);\n+        } catch (Throwable t) {\n+            LOGGER.warn(INTERNAL_ERROR, \"\", \"\", \"Error occurred when afterMethod.\", t);\n+        }\n     }\n     @Override\n     public void onError(Throwable t, Invoker<?> invoker, Invocation invocation) {\n         if (collector == null || !collector.isCollectEnabled()) {\n             return;\n         }\n-        metricsInterceptor.handleMethodException(invocation, t);\n+        try {\n+            metricsInterceptor.handleMethodException(invocation, t, false);\n+        } catch (Throwable t1) {\n+            LOGGER.warn(INTERNAL_ERROR, \"\", \"\", \"Error occurred when handleMethodException.\", t1);\n+        }\n     }\n }",
    "output": "Fix business exception * Fix business exception * opt * opt * Catch exception"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtils.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtils.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtils.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtils.java\n@@ -100,10 +100,13 @@ public static void convertAttachment(DefaultHttp2Headers headers,\n             if (TripleHeaderEnum.containsExcludeAttachments(key)) {\n                 continue;\n             }\n+            final Object v = entry.getValue();\n+            if (v == null) {\n+                continue;\n+            }\n             if (needConvertHeaderKey && !key.equals(entry.getKey())) {\n                 needConvertKey.put(key, entry.getKey());\n             }\n-            final Object v = entry.getValue();\n             convertSingleAttachment(headers, key, v);\n         }\n         if (!needConvertKey.isEmpty()) {",
    "output": "Fix npe"
  },
  {
    "input": "diff --git a/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/ObservabilityUtils.java b/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/ObservabilityUtils.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/ObservabilityUtils.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/ObservabilityUtils.java\n@@ -36,4 +36,6 @@ public class ObservabilityUtils {\n     public static final String DUBBO_TRACING_BAGGAGE_ENABLED = DUBBO_TRACING_BAGGAGE + PROPERTY_NAME_SEPARATOR + \"enabled\";\n+    public static final String DUBBO_TRACING_ZIPKIN_CONFIG_PREFIX = DUBBO_TRACING_PREFIX + PROPERTY_NAME_SEPARATOR + \"tracing-exporter.zipkin-config\";\n+\n }\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinAutoConfiguration.java\n@@ -27,6 +27,7 @@\n import org.springframework.boot.autoconfigure.EnableAutoConfiguration;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n import org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Import;\n@@ -35,23 +36,28 @@\n import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.Sender;\n+import static org.apache.dubbo.spring.boot.observability.autoconfigure.ObservabilityUtils.DUBBO_TRACING_PREFIX;\n+import static org.apache.dubbo.spring.boot.observability.autoconfigure.ObservabilityUtils.DUBBO_TRACING_ZIPKIN_CONFIG_PREFIX;\n+\n /**\n  * {@link EnableAutoConfiguration Auto-configuration} for Zipkin.\n  * <p>\n  * It uses imports on {@link ZipkinConfigurations} to guarantee the correct configuration ordering.\n  *\n- * @since 3.2.0\n+ * @since 3.2.1\n  */\n @AutoConfiguration(after = RestTemplateAutoConfiguration.class)\n @ConditionalOnClass(Sender.class)\n @Import({SenderConfiguration.class,\n         ReporterConfiguration.class, BraveConfiguration.class,\n         OpenTelemetryConfiguration.class})\n+@ConditionalOnProperty(prefix = DUBBO_TRACING_PREFIX, name = \"enabled\", havingValue = \"true\")\n @ConditionalOnDubboTracingEnable\n public class ZipkinAutoConfiguration {\n     @Bean\n+    @ConditionalOnProperty(prefix = DUBBO_TRACING_ZIPKIN_CONFIG_PREFIX, name = \"endpoint\")\n     @ConditionalOnMissingBean\n     public BytesEncoder<Span> spanBytesEncoder() {\n         return SpanBytesEncoder.JSON_V2;\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinConfigurations.java b/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinConfigurations.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinConfigurations.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-observability-starter/dubbo-spring-boot-observability-autoconfigure/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/exporter/zipkin/ZipkinConfigurations.java\n@@ -27,6 +27,7 @@\n import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n import org.springframework.boot.context.properties.EnableConfigurationProperties;\n import org.springframework.boot.web.client.RestTemplateBuilder;\n import org.springframework.context.annotation.Bean;\n@@ -44,12 +45,15 @@\n import java.util.concurrent.atomic.AtomicReference;\n+import static org.apache.dubbo.spring.boot.observability.autoconfigure.ObservabilityUtils.DUBBO_TRACING_ZIPKIN_CONFIG_PREFIX;\n+\n /**\n  * Configurations for Zipkin. Those are imported by {@link ZipkinAutoConfiguration}.\n  */\n class ZipkinConfigurations {\n     @Configuration(proxyBeanMethods = false)\n+    @ConditionalOnProperty(prefix = DUBBO_TRACING_ZIPKIN_CONFIG_PREFIX, name = \"endpoint\")\n     @Import({UrlConnectionSenderConfiguration.class, WebClientSenderConfiguration.class,\n             RestTemplateSenderConfiguration.class})\n     static class SenderConfiguration {\n@@ -147,6 +151,7 @@ ZipkinSpanHandler zipkinSpanHandler(Reporter<Span> spanReporter) {\n     @Configuration(proxyBeanMethods = false)\n     @ConditionalOnClass(ZipkinSpanExporter.class)\n+    @ConditionalOnProperty(prefix = DUBBO_TRACING_ZIPKIN_CONFIG_PREFIX, name = \"endpoint\")\n     @EnableConfigurationProperties(DubboConfigurationProperties.class)\n     static class OpenTelemetryConfiguration {",
    "output": "Fix bugfix of tracing zipkin npe when start * fix: bugfix of tracing zipkin npe when start * fix: fix tracing.enabled=false ---------"
  },
  {
    "input": "diff --git a/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java b/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n--- a/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n+++ b/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n@@ -54,6 +54,7 @@ class FileTest {\n         ignoredArtifacts.add(Pattern.compile(\"dubbo-demo.*\"));\n         ignoredArtifacts.add(Pattern.compile(\"dubbo-test.*\"));\n+        ignoredArtifacts.add(Pattern.compile(\"dubbo-annotation-processor\"));\n         ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo\"));\n         ignoredModulesInDubboAll.add(Pattern.compile(\"dubbo-bom\"));",
    "output": "Add ignorance of FileTest.java"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/stub/UnaryStubMethodHandler.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/stub/UnaryStubMethodHandler.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/stub/UnaryStubMethodHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/stub/UnaryStubMethodHandler.java\n@@ -34,7 +34,11 @@ public CompletableFuture<R> invoke(Object[] arguments) {\n         T request = (T) arguments[0];\n         CompletableFuture<R> future = new CompletableFuture<>();\n         StreamObserver<R> responseObserver = new FutureToObserverAdaptor<>(future);\n-        func.accept(request, responseObserver);\n+        try {\n+            func.accept(request, responseObserver);\n+        } catch (Throwable e) {\n+            future.completeExceptionally(e);\n+        }\n         return future;\n     }\n }",
    "output": "Fix tri stub exception * fix tri stub exception * fix"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -1129,6 +1129,7 @@ private void onStarted() {\n                 return;\n             }\n             setStarted();\n+            startMetricsCollector();\n             if (logger.isInfoEnabled()) {\n                 logger.info(getIdentifier() + \" is ready.\");\n             }\n@@ -1146,7 +1147,12 @@ private void onStarted() {\n         }\n     }\n-\n+    private void startMetricsCollector() {\n+        DefaultMetricsCollector collector = applicationModel.getBeanFactory().getBean(DefaultMetricsCollector.class);\n+        if (Objects.nonNull(collector) && collector.isThreadpoolCollectEnabled()) {\n+            collector.registryDefaultSample();\n+        }\n+    }\n     private void completeStartFuture(boolean success) {\n         if (startFuture != null) {\n             startFuture.complete(success);",
    "output": "Fix the observable collection thread pool indicator"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/HeaderFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/HeaderFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/HeaderFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/HeaderFilter.java\n@@ -16,9 +16,10 @@\n  */\n package org.apache.dubbo.rpc;\n+import org.apache.dubbo.common.extension.ExtensionScope;\n import org.apache.dubbo.common.extension.SPI;\n-@SPI\n+@SPI(scope = ExtensionScope.FRAMEWORK)\n public interface HeaderFilter {\n     RpcInvocation invoke(Invoker<?> invoker, RpcInvocation invocation) throws RpcException;\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -17,6 +17,16 @@\n package org.apache.dubbo.rpc.protocol.tri;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.handler.codec.http2.Http2FrameCodec;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2FrameLogger;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.ssl.SslContext;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.config.Configuration;\n import org.apache.dubbo.common.config.ConfigurationUtils;\n@@ -28,7 +38,6 @@\n import org.apache.dubbo.remoting.api.pu.ChannelHandlerPretender;\n import org.apache.dubbo.remoting.api.pu.ChannelOperator;\n import org.apache.dubbo.rpc.HeaderFilter;\n-import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ScopeModelAware;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleClientHandler;\n@@ -37,17 +46,6 @@\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleServerConnectionHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleTailHandler;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelInitializer;\n-import io.netty.channel.ChannelPipeline;\n-import io.netty.handler.codec.http2.Http2FrameCodec;\n-import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n-import io.netty.handler.codec.http2.Http2FrameLogger;\n-import io.netty.handler.codec.http2.Http2MultiplexHandler;\n-import io.netty.handler.codec.http2.Http2Settings;\n-import io.netty.handler.logging.LogLevel;\n-import io.netty.handler.ssl.SslContext;\n-\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -79,8 +77,6 @@ public class TripleHttp2Protocol extends AbstractWireProtocol implements ScopeMo\n     private ExtensionLoader<HeaderFilter> filtersLoader;\n     private FrameworkModel frameworkModel;\n-    private Configuration config = ConfigurationUtils.getGlobalConfiguration(\n-        ApplicationModel.defaultModel());\n     public TripleHttp2Protocol() {\n         super(new Http2ProtocolDetector());\n@@ -89,12 +85,7 @@ public TripleHttp2Protocol() {\n     @Override\n     public void setFrameworkModel(FrameworkModel frameworkModel) {\n         this.frameworkModel = frameworkModel;\n-    }\n-\n-    @Override\n-    public void setApplicationModel(ApplicationModel applicationModel) {\n-        this.config = ConfigurationUtils.getGlobalConfiguration(applicationModel);\n-        this.filtersLoader = applicationModel.getExtensionLoader(HeaderFilter.class);\n+        this.filtersLoader = frameworkModel.getExtensionLoader(HeaderFilter.class);\n     }\n     @Override\n@@ -104,11 +95,10 @@ public void close() {\n     @Override\n     public void configServerProtocolHandler(URL url, ChannelOperator operator) {\n-\n+        Configuration config = ConfigurationUtils.getGlobalConfiguration(url.getOrDefaultApplicationModel());\n         final List<HeaderFilter> headFilters;\n         if (filtersLoader != null) {\n-            headFilters = filtersLoader.getActivateExtension(url,\n-                HEADER_FILTER_KEY);\n+            headFilters = filtersLoader.getActivateExtension(url, HEADER_FILTER_KEY);\n         } else {\n             headFilters = Collections.emptyList();\n         }\n@@ -154,6 +144,7 @@ private Executor lookupExecutor(URL url) {\n     @Override\n     public void configClientPipeline(URL url, ChannelPipeline pipeline, SslContext sslContext) {\n+        Configuration config = ConfigurationUtils.getGlobalConfiguration(url.getOrDefaultApplicationModel());\n         final Http2FrameCodec codec = Http2FrameCodecBuilder.forClient()\n             .gracefulShutdownTimeoutMillis(10000)\n             .initialSettings(new Http2Settings().headerTableSize(",
    "output": "Fix tri headerfilter 3.1 * change headerfilter scope * fix tri header filter"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java\n@@ -79,7 +79,6 @@ private void onResetRead(ChannelHandlerContext ctx, Http2ResetFrame resetFrame)\n     @Override\n     public void channelInactive(ChannelHandlerContext ctx) {\n-        transportListener.cancelByRemote(Http2Error.NO_ERROR.code());\n         ctx.close();\n     }",
    "output": "Remove unused code"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/GetAddress.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/GetAddress.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/GetAddress.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/GetAddress.java\n@@ -70,7 +70,7 @@ public String execute(CommandContext commandContext, String[] args) {\n         }\n         if (commandContext.isHttp()) {\n-            return JsonUtils.getJson().toJson(jsonOutput);\n+            return JsonUtils.toJson(jsonOutput);\n         } else {\n             return plainOutput.toString();\n         }",
    "output": "Fix compile"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/HeaderFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/HeaderFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/HeaderFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/HeaderFilter.java\n@@ -16,9 +16,10 @@\n  */\n package org.apache.dubbo.rpc;\n+import org.apache.dubbo.common.extension.ExtensionScope;\n import org.apache.dubbo.common.extension.SPI;\n-@SPI\n+@SPI(scope = ExtensionScope.FRAMEWORK)\n public interface HeaderFilter {\n     RpcInvocation invoke(Invoker<?> invoker, RpcInvocation invocation) throws RpcException;\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -17,6 +17,15 @@\n package org.apache.dubbo.rpc.protocol.tri;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.handler.codec.http2.Http2FrameCodec;\n+import io.netty.handler.codec.http2.Http2FrameLogger;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.codec.http2.Http2StreamChannel;\n+import io.netty.handler.flush.FlushConsolidationHandler;\n+import io.netty.handler.logging.LogLevel;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.config.Configuration;\n import org.apache.dubbo.common.config.ConfigurationUtils;\n@@ -30,7 +39,6 @@\n import org.apache.dubbo.remoting.api.ssl.ContextOperator;\n import org.apache.dubbo.rpc.HeaderFilter;\n import org.apache.dubbo.rpc.executor.ExecutorSupport;\n-import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ScopeModelAware;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleClientHandler;\n@@ -40,16 +48,6 @@\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleTailHandler;\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n-import io.netty.channel.ChannelInitializer;\n-import io.netty.channel.ChannelPipeline;\n-import io.netty.handler.codec.http2.Http2FrameCodec;\n-import io.netty.handler.codec.http2.Http2FrameLogger;\n-import io.netty.handler.codec.http2.Http2MultiplexHandler;\n-import io.netty.handler.codec.http2.Http2Settings;\n-import io.netty.handler.codec.http2.Http2StreamChannel;\n-import io.netty.handler.flush.FlushConsolidationHandler;\n-import io.netty.handler.logging.LogLevel;\n-\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -80,8 +78,6 @@ public class TripleHttp2Protocol extends AbstractWireProtocol implements ScopeMo\n     private ExtensionLoader<HeaderFilter> filtersLoader;\n     private FrameworkModel frameworkModel;\n-    private Configuration config = ConfigurationUtils.getGlobalConfiguration(\n-        ApplicationModel.defaultModel());\n     public TripleHttp2Protocol() {\n         super(new Http2ProtocolDetector());\n@@ -90,12 +86,7 @@ public TripleHttp2Protocol() {\n     @Override\n     public void setFrameworkModel(FrameworkModel frameworkModel) {\n         this.frameworkModel = frameworkModel;\n-    }\n-\n-    @Override\n-    public void setApplicationModel(ApplicationModel applicationModel) {\n-        this.config = ConfigurationUtils.getGlobalConfiguration(applicationModel);\n-        this.filtersLoader = applicationModel.getExtensionLoader(HeaderFilter.class);\n+        this.filtersLoader = frameworkModel.getExtensionLoader(HeaderFilter.class);\n     }\n     @Override\n@@ -105,11 +96,10 @@ public void close() {\n     @Override\n     public void configServerProtocolHandler(URL url, ChannelOperator operator) {\n-\n+        Configuration config = ConfigurationUtils.getGlobalConfiguration(url.getOrDefaultApplicationModel());\n         final List<HeaderFilter> headFilters;\n         if (filtersLoader != null) {\n-            headFilters = filtersLoader.getActivateExtension(url,\n-                HEADER_FILTER_KEY);\n+            headFilters = filtersLoader.getActivateExtension(url, HEADER_FILTER_KEY);\n         } else {\n             headFilters = Collections.emptyList();\n         }\n@@ -153,6 +143,7 @@ protected void initChannel(Http2StreamChannel ch) {\n     @Override\n     public void configClientPipeline(URL url, ChannelOperator operator, ContextOperator contextOperator) {\n+        Configuration config = ConfigurationUtils.getGlobalConfiguration(url.getOrDefaultApplicationModel());\n         final Http2FrameCodec codec = TripleHttp2FrameCodecBuilder.forClient()\n             .customizeConnection((connection) -> connection.remote().flowController(new TriHttp2RemoteFlowController(connection, url.getOrDefaultApplicationModel())))\n             .gracefulShutdownTimeoutMillis(10000)",
    "output": "Change headerfilter scope * change headerfilter scope * fix * fix import"
  },
  {
    "input": "diff --git a/dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/DubboObservationAutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/DubboObservationAutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/DubboObservationAutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/DubboObservationAutoConfiguration.java\n@@ -18,7 +18,6 @@\n import io.micrometer.core.instrument.MeterRegistry;\n-import io.micrometer.tracing.Tracer;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.qos.protocol.QosProtocolWrapper;\n@@ -83,9 +82,9 @@ public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n     @Override\n     public void afterSingletonsInstantiated() {\n-\n         try {\n-            Tracer bean = beanFactory.getBean(Tracer.class);\n+            applicationModel.getBeanFactory().registerBean(beanFactory.getBean(io.micrometer.observation.ObservationRegistry.class));\n+            io.micrometer.tracing.Tracer bean = beanFactory.getBean(io.micrometer.tracing.Tracer.class);\n             applicationModel.getBeanFactory().registerBean(bean);\n         } catch (NoSuchBeanDefinitionException e) {\n             logger.info(\"Please use a version of micrometer higher than 1.10.0 {}\" + e.getMessage());\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/otel/OpenTelemetryAutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/otel/OpenTelemetryAutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/otel/OpenTelemetryAutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/otel/OpenTelemetryAutoConfiguration.java\n@@ -42,7 +42,7 @@\n @AutoConfiguration(before = DubboMicrometerTracingAutoConfiguration.class, afterName = \"org.springframework.boot.actuate.autoconfigure.tracing.OpenTelemetryAutoConfiguration\")\n @ConditionalOnDubboTracingEnable\n @ConditionalOnClass(name = {\"io.micrometer.tracing.otel.bridge.OtelTracer\",\n-    \"io.opentelemetry.sdk.trace.SdkTracerProvider\", \"e io.opentelemetry.api.OpenTelemetry\"\n+    \"io.opentelemetry.sdk.trace.SdkTracerProvider\", \"io.opentelemetry.api.OpenTelemetry\"\n     , \"io.micrometer.tracing.SpanCustomizer\"})\n @EnableConfigurationProperties(DubboConfigurationProperties.class)\n public class OpenTelemetryAutoConfiguration {",
    "output": "Fix observ-starter some bugs"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n@@ -49,6 +49,7 @@\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_NACOS_EXCEPTION;\n import static org.apache.dubbo.common.function.ThrowableConsumer.execute;\n import static org.apache.dubbo.metadata.RevisionResolver.EMPTY_REVISION;\n+import static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.EXPORTED_SERVICES_REVISION_PROPERTY_NAME;\n import static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.getExportedServicesRevision;\n import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.createNamingService;\n import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.getGroup;\n@@ -78,7 +79,7 @@ public NacosServiceDiscovery(ApplicationModel applicationModel, URL registryURL)\n         this.namingService = createNamingService(registryURL);\n         // backward compatibility for 3.0.x\n         this.group = Boolean.parseBoolean(ConfigurationUtils.getProperty(applicationModel, NACOS_SD_USE_DEFAULT_GROUP_KEY, \"false\")) ?\n-            DEFAULT_GROUP : getGroup(registryURL);\n+                DEFAULT_GROUP : getGroup(registryURL);\n     }\n     @Override\n@@ -105,14 +106,15 @@ public void doUnregister(ServiceInstance serviceInstance) throws RuntimeExceptio\n     @Override\n     protected void doUpdate(ServiceInstance oldServiceInstance, ServiceInstance newServiceInstance) throws RuntimeException {\n-        if (EMPTY_REVISION.equals(getExportedServicesRevision(newServiceInstance))) {\n+        if (EMPTY_REVISION.equals(getExportedServicesRevision(newServiceInstance))\n+                || EMPTY_REVISION.equals(oldServiceInstance.getMetadata().get(EXPORTED_SERVICES_REVISION_PROPERTY_NAME))) {\n             super.doUpdate(oldServiceInstance, newServiceInstance);\n             return;\n         }\n         if (!Objects.equals(oldServiceInstance.getServiceName(), newServiceInstance.getServiceName()) ||\n-            !Objects.equals(oldServiceInstance.getAddress(), newServiceInstance.getAddress()) ||\n-            !Objects.equals(oldServiceInstance.getPort(), newServiceInstance.getPort())) {\n+                !Objects.equals(oldServiceInstance.getAddress(), newServiceInstance.getAddress()) ||\n+                !Objects.equals(oldServiceInstance.getPort(), newServiceInstance.getPort())) {\n             // Ignore if host-ip changed. Should unregister first.\n             super.doUpdate(oldServiceInstance, newServiceInstance);\n             return;\n@@ -140,15 +142,15 @@ public Set<String> getServices() {\n     @Override\n     public List<ServiceInstance> getInstances(String serviceName) throws NullPointerException {\n         return ThrowableFunction.execute(namingService, service ->\n-            service.selectInstances(serviceName, group, true)\n-                .stream().map((i) -> NacosNamingServiceUtils.toServiceInstance(registryURL, i))\n-                .collect(Collectors.toList())\n+                service.selectInstances(serviceName, group, true)\n+                        .stream().map((i) -> NacosNamingServiceUtils.toServiceInstance(registryURL, i))\n+                        .collect(Collectors.toList())\n         );\n     }\n     @Override\n     public void addServiceInstancesChangedListener(ServiceInstancesChangedListener listener)\n-        throws NullPointerException, IllegalArgumentException {\n+            throws NullPointerException, IllegalArgumentException {\n         // check if listener has already been added through another interface/service\n         if (!instanceListeners.add(listener)) {\n             return;\n@@ -225,9 +227,9 @@ public URL getUrl() {\n     private void handleEvent(NamingEvent event, ServiceInstancesChangedListener listener) {\n         String serviceName = event.getServiceName();\n         List<ServiceInstance> serviceInstances = event.getInstances()\n-            .stream()\n-            .map((i) -> NacosNamingServiceUtils.toServiceInstance(registryURL, i))\n-            .collect(Collectors.toList());\n+                .stream()\n+                .map((i) -> NacosNamingServiceUtils.toServiceInstance(registryURL, i))\n+                .collect(Collectors.toList());\n         listener.onEvent(new ServiceInstancesChangedEvent(serviceName, serviceInstances));\n     }\n }\ndiff --git a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n@@ -28,6 +28,7 @@\n import org.apache.curator.framework.CuratorFramework;\n import org.apache.curator.framework.api.CuratorWatcher;\n import org.apache.curator.x.discovery.ServiceCache;\n+\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.function.ThrowableConsumer;\n import org.apache.dubbo.common.function.ThrowableFunction;\n@@ -44,6 +45,7 @@\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_ZOOKEEPER_EXCEPTION;\n import static org.apache.dubbo.common.function.ThrowableFunction.execute;\n import static org.apache.dubbo.metadata.RevisionResolver.EMPTY_REVISION;\n+import static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.EXPORTED_SERVICES_REVISION_PROPERTY_NAME;\n import static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.getExportedServicesRevision;\n import static org.apache.dubbo.registry.zookeeper.util.CuratorFrameworkUtils.build;\n import static org.apache.dubbo.registry.zookeeper.util.CuratorFrameworkUtils.buildCuratorFramework;\n@@ -111,15 +113,16 @@ public void doUnregister(ServiceInstance serviceInstance) throws RuntimeExceptio\n     @Override\n     protected void doUpdate(ServiceInstance oldServiceInstance, ServiceInstance newServiceInstance) throws RuntimeException {\n-        if (EMPTY_REVISION.equals(getExportedServicesRevision(newServiceInstance))) {\n+        if (EMPTY_REVISION.equals(getExportedServicesRevision(newServiceInstance))\n+                || EMPTY_REVISION.equals(oldServiceInstance.getMetadata().get(EXPORTED_SERVICES_REVISION_PROPERTY_NAME))) {\n             super.doUpdate(oldServiceInstance, newServiceInstance);\n             return;\n         }\n         org.apache.curator.x.discovery.ServiceInstance<ZookeeperInstance> oldInstance = build(oldServiceInstance);\n         org.apache.curator.x.discovery.ServiceInstance<ZookeeperInstance> newInstance = build(newServiceInstance);\n         if (!Objects.equals(newInstance.getName(), oldInstance.getName()) ||\n-            !Objects.equals(newInstance.getId(), oldInstance.getId())) {\n+                !Objects.equals(newInstance.getId(), oldInstance.getId())) {\n             // Ignore if id changed. Should unregister first.\n             super.doUpdate(oldServiceInstance, newServiceInstance);\n             return;\n@@ -146,7 +149,7 @@ public List<ServiceInstance> getInstances(String serviceName) throws NullPointer\n     @Override\n     public void addServiceInstancesChangedListener(ServiceInstancesChangedListener listener)\n-        throws NullPointerException, IllegalArgumentException {\n+            throws NullPointerException, IllegalArgumentException {\n         // check if listener has already been added through another interface/service\n         if (!instanceListeners.add(listener)) {\n             return;\n@@ -169,7 +172,7 @@ public void removeServiceInstancesChangedListener(ServiceInstancesChangedListene\n                         watcher.getCacheInstance().close();\n                     } catch (IOException e) {\n                         logger.error(REGISTRY_ZOOKEEPER_EXCEPTION, \"curator stop watch failed\", \"\",\n-                            \"Curator Stop service discovery watch failed. Service Name: \" + serviceName);\n+                                \"Curator Stop service discovery watch failed. Service Name: \" + serviceName);\n                     }\n                 }\n             }\n@@ -190,8 +193,8 @@ protected void registerServiceWatcher(String serviceName, ServiceInstancesChange\n         ZookeeperServiceDiscoveryChangeWatcher watcher = watcherCaches.computeIfAbsent(serviceName, name -> {\n             ServiceCache<ZookeeperInstance> serviceCache = serviceDiscovery.serviceCacheBuilder()\n-                .name(name)\n-                .build();\n+                    .name(name)\n+                    .build();\n             ZookeeperServiceDiscoveryChangeWatcher newer = new ZookeeperServiceDiscoveryChangeWatcher(this, serviceCache, name, latch);\n             serviceCache.addListener(newer);",
    "output": "Fix after offline and online error"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n@@ -49,7 +49,6 @@\n import static org.apache.dubbo.common.constants.CommonConstants.REGISTRY_LOCAL_FILE_CACHE_ENABLED;\n import static org.apache.dubbo.common.constants.CommonConstants.REMOTE_METADATA_STORAGE_TYPE;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_FAILED_FETCH_INSTANCE;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_FAILED_LOAD_METADATA;\n import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_CLUSTER_KEY;\n import static org.apache.dubbo.metadata.RevisionResolver.EMPTY_REVISION;\n@@ -97,32 +96,32 @@ private AbstractServiceDiscovery(ApplicationModel applicationModel, String servi\n         this.metadataInfo = new MetadataInfo(serviceName);\n         boolean localCacheEnabled = registryURL.getParameter(REGISTRY_LOCAL_FILE_CACHE_ENABLED, true);\n         this.metaCacheManager = new MetaCacheManager(localCacheEnabled, getCacheNameSuffix(),\n-            applicationModel.getFrameworkModel().getBeanFactory()\n-                .getBean(FrameworkExecutorRepository.class).getCacheRefreshingScheduledExecutor());\n+                applicationModel.getFrameworkModel().getBeanFactory()\n+                        .getBean(FrameworkExecutorRepository.class).getCacheRefreshingScheduledExecutor());\n         int metadataInfoCacheExpireTime = registryURL.getParameter(METADATA_INFO_CACHE_EXPIRE_KEY, DEFAULT_METADATA_INFO_CACHE_EXPIRE);\n         int metadataInfoCacheSize = registryURL.getParameter(METADATA_INFO_CACHE_SIZE_KEY, DEFAULT_METADATA_INFO_CACHE_SIZE);\n         this.refreshCacheFuture = applicationModel.getFrameworkModel().getBeanFactory()\n-            .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor()\n-            .scheduleAtFixedRate(() -> {\n-                try {\n-                    while (metadataInfos.size() > metadataInfoCacheSize) {\n-                        AtomicReference<String> oldestRevision = new AtomicReference<>();\n-                        AtomicReference<MetadataInfoStat> oldestStat = new AtomicReference<>();\n-                        metadataInfos.forEach((k, v) -> {\n-                            if (System.currentTimeMillis() - v.getUpdateTime() > metadataInfoCacheExpireTime &&\n-                                (oldestStat.get() == null || oldestStat.get().getUpdateTime() > v.getUpdateTime())) {\n-                                oldestRevision.set(k);\n-                                oldestStat.set(v);\n+                .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor()\n+                .scheduleAtFixedRate(() -> {\n+                    try {\n+                        while (metadataInfos.size() > metadataInfoCacheSize) {\n+                            AtomicReference<String> oldestRevision = new AtomicReference<>();\n+                            AtomicReference<MetadataInfoStat> oldestStat = new AtomicReference<>();\n+                            metadataInfos.forEach((k, v) -> {\n+                                if (System.currentTimeMillis() - v.getUpdateTime() > metadataInfoCacheExpireTime &&\n+                                        (oldestStat.get() == null || oldestStat.get().getUpdateTime() > v.getUpdateTime())) {\n+                                    oldestRevision.set(k);\n+                                    oldestStat.set(v);\n+                                }\n+                            });\n+                            if (oldestStat.get() != null) {\n+                                metadataInfos.remove(oldestRevision.get(), oldestStat.get());\n                             }\n-                        });\n-                        if (oldestStat.get() != null) {\n-                            metadataInfos.remove(oldestRevision.get(), oldestStat.get());\n                         }\n+                    } catch (Throwable t) {\n+                        logger.error(INTERNAL_ERROR, \"\", \"\", \"Error occurred when clean up metadata info cache.\", t);\n                     }\n-                } catch (Throwable t) {\n-                    logger.error(INTERNAL_ERROR, \"\", \"\", \"Error occurred when clean up metadata info cache.\", t);\n-                }\n-            }, metadataInfoCacheExpireTime / 2, metadataInfoCacheExpireTime / 2, TimeUnit.MILLISECONDS);\n+                }, metadataInfoCacheExpireTime / 2, metadataInfoCacheExpireTime / 2, TimeUnit.MILLISECONDS);\n     }\n@@ -131,12 +130,11 @@ public synchronized void register() throws RuntimeException {\n         if (isDestroy) {\n             return;\n         }\n-        this.serviceInstance = createServiceInstance(this.metadataInfo);\n-        if (!isValidInstance(this.serviceInstance)) {\n-            logger.warn(REGISTRY_FAILED_FETCH_INSTANCE, \"\", \"\", \"No valid instance found, stop registering instance address to registry.\");\n+        ServiceInstance serviceInstance = createServiceInstance(this.metadataInfo);\n+        if (!isValidInstance(serviceInstance)) {\n             return;\n         }\n-\n+        this.serviceInstance = serviceInstance;\n         boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance);\n         if (revisionUpdated) {\n             reportMetadata(this.metadataInfo);\n@@ -156,15 +154,12 @@ public synchronized void update() throws RuntimeException {\n         }\n         if (this.serviceInstance == null) {\n-            this.serviceInstance = createServiceInstance(this.metadataInfo);\n-        } else if (!isValidInstance(this.serviceInstance)) {\n-            ServiceInstanceMetadataUtils.customizeInstance(this.serviceInstance, this.applicationModel);\n+            register();\n         }\n         if (!isValidInstance(this.serviceInstance)) {\n             return;\n         }\n-\n         ServiceInstance oldServiceInstance = this.serviceInstance;\n         DefaultServiceInstance newServiceInstance = new DefaultServiceInstance((DefaultServiceInstance) oldServiceInstance);\n         boolean revisionUpdated = calOrUpdateInstanceRevision(newServiceInstance);\n@@ -301,7 +296,7 @@ public List<URL> lookup(URL url) {\n      * Can be override if registry support update instance directly.\n      * <br/>\n      * NOTICE: Remind to update {@link AbstractServiceDiscovery#serviceInstance}'s reference if updated\n-     *         and report metadata by {@link AbstractServiceDiscovery#reportMetadata(MetadataInfo)}\n+     * and report metadata by {@link AbstractServiceDiscovery#reportMetadata(MetadataInfo)}\n      *\n      * @param oldServiceInstance origin service instance\n      * @param newServiceInstance new service instance",
    "output": "Fix abstractServiceDiscovery update exception caused by loading order * 1fix abstractServiceDiscovery update exception caused by loading order * 1delete registry status and replace it with serviceInstance * 1.fix code style"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionHandler.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionHandler.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionHandler.java\n@@ -77,6 +77,10 @@ public void reconnect(Object channel) {\n             LOGGER.debug(String.format(\"Connection %s is reconnecting, attempt=%d\", connectionClient, 1));\n         }\n         final EventLoop eventLoop = nettyChannel.eventLoop();\n+        if (connectionClient.isClosed()) {\n+            LOGGER.info(\"The client has been closed and will not reconnect. \");\n+            return;\n+        }\n         eventLoop.schedule(() -> {\n             try {\n                 connectionClient.doConnect();",
    "output": "Fix the bug of reconnect"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/listener/InjvmExporterListener.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/listener/InjvmExporterListener.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/listener/InjvmExporterListener.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/listener/InjvmExporterListener.java\n@@ -122,6 +122,9 @@ public synchronized void addExporterChangeListener(ExporterChangeListener listen\n      */\n     public synchronized void removeExporterChangeListener(ExporterChangeListener listener, String listenerKey) {\n         Set<ExporterChangeListener> listeners = exporterChangeListeners.get(listenerKey);\n+        if (CollectionUtils.isEmpty(listeners)) {\n+            return;\n+        }\n         listeners.remove(listener);\n         if (CollectionUtils.isEmpty(listeners)) {\n             exporterChangeListeners.remove(listenerKey);",
    "output": "Fix removeExporterChangeListener NPE"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLParam.java b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLParam.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLParam.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLParam.java\n@@ -994,7 +994,13 @@ public static URLParam parse(Map<String, String> params, String rawParam) {\n             Map<String, Map<String, String>> methodParameters = new HashMap<>(capacity);\n             for (Map.Entry<String, String> entry : params.entrySet()) {\n-                addParameter(keyBit, valueMap, extraParam, methodParameters, entry.getKey(), entry.getValue(), false);\n+                String key = entry.getKey();\n+                String value = entry.getValue();\n+                addParameter(keyBit, valueMap, extraParam, methodParameters, key, value, false);\n+                // compatible with lower versions registering \"default.\" keys\n+                if (key.startsWith(DEFAULT_KEY_PREFIX)) {\n+                    addParameter(keyBit, valueMap, extraParam, methodParameters, key.substring(DEFAULT_KEY_PREFIX.length()), value, true);\n+                }\n             }\n             return new URLParam(keyBit, valueMap, extraParam, methodParameters, rawParam);\n         } else {\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.common;\n+import org.apache.dubbo.common.url.component.ServiceConfigURL;\n import org.apache.dubbo.common.utils.NetUtils;\n import org.junit.jupiter.api.Test;\n@@ -47,6 +48,24 @@ void shouldAddParameter() {\n         assertThat(url2.getVersion(), equalTo(\"1\"));\n     }\n+    @Test\n+    void testDefault() {\n+        ServiceConfigURL url1 = URLBuilder.from(URL.valueOf(\"\"))\n+            .addParameter(\"timeout\", \"1234\")\n+            .addParameter(\"default.timeout\", \"5678\")\n+            .build();\n+\n+        assertThat(url1.getParameter(\"timeout\"), equalTo(\"1234\"));\n+        assertThat(url1.getParameter(\"default.timeout\"), equalTo(\"5678\"));\n+\n+        ServiceConfigURL url2 = URLBuilder.from(URL.valueOf(\"\"))\n+            .addParameter(\"default.timeout\", \"5678\")\n+            .build();\n+\n+        assertThat(url2.getParameter(\"timeout\"), equalTo(\"5678\"));\n+        assertThat(url2.getParameter(\"default.timeout\"), equalTo(\"5678\"));\n+    }\n+\n     @Test\n     void shouldSet() {\n         URL url1 = URL.valueOf(\"dubbo://admin:hello1234@10.20.130.230:20880/context/path?version=1.0.0&application=morgan\");\n@@ -145,4 +164,4 @@ void shouldAddParametersIfAbsent() {\n         assertThat(url2.getParameter(\"version\"), equalTo(\"1.0.0\"));\n         assertThat(url2.getParameter(\"absentKey\"), equalTo(\"absentValue\"));\n     }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n@@ -45,6 +45,8 @@ class URLStrParserTest {\n         testCases.add(\"dubbo://fe80:0:0:0:894:aeec:f37d:23e1%en0/path?abc=abc\");\n         testCases.add(\"dubbo://[fe80:0:0:0:894:aeec:f37d:23e1]:20880/path?abc=abc\");\n         testCases.add(\"nacos://192.168.1.1:8848?username=&password=\");\n+        testCases.add(\"dubbo://127.0.0.1?timeout=1234&default.timeout=5678\");\n+        testCases.add(\"dubbo://127.0.0.1?default.timeout=5678\");\n         errorDecodedCases.add(\"dubbo:192.168.1.1\");\n         errorDecodedCases.add(\"://192.168.1.1\");\n@@ -81,4 +83,15 @@ void testDecoded() {\n         });\n     }\n+    @Test\n+    void testDefault() {\n+        URL url1 = URLStrParser.parseEncodedStr(URL.encode(\"dubbo://127.0.0.1?timeout=1234&default.timeout=5678\"));\n+        assertThat(url1.getParameter(\"timeout\"), equalTo(\"1234\"));\n+        assertThat(url1.getParameter(\"default.timeout\"), equalTo(\"5678\"));\n+\n+        URL url2 = URLStrParser.parseEncodedStr(URL.encode(\"dubbo://127.0.0.1?default.timeout=5678\"));\n+        assertThat(url2.getParameter(\"timeout\"), equalTo(\"5678\"));\n+        assertThat(url2.getParameter(\"default.timeout\"), equalTo(\"5678\"));\n+    }\n+\n }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n@@ -59,6 +59,17 @@ void test_ignore_pond() {\n         assertEquals(\"org.apache.dubbo.config.RegistryConfig#0\", url.getParameter(\"id\"));\n     }\n+    @Test\n+    void testDefault() {\n+        URL url1 = URL.valueOf(\"dubbo://127.0.0.1:12345?timeout=1234&default.timeout=5678\");\n+        assertEquals(1234, url1.getParameter(\"timeout\", 0));\n+        assertEquals(5678, url1.getParameter(\"default.timeout\", 0));\n+\n+        URL url2 = URL.valueOf(\"dubbo://127.0.0.1:12345?default.timeout=5678\");\n+        assertEquals(5678, url2.getParameter(\"timeout\", 0));\n+        assertEquals(5678, url2.getParameter(\"default.timeout\", 0));\n+    }\n+\n     @Test\n     void test_valueOf_noProtocolAndHost() throws Exception {\n         URL url = URL.valueOf(\"/context/path?version=1.0.0&application=morgan\");\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/url/URLParamTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/url/URLParamTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/url/URLParamTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/url/URLParamTest.java\n@@ -81,6 +81,33 @@ void testParseWithMap() {\n         Assertions.assertEquals(urlParam3, URLParam.parse(urlParam3.getRawParam()));\n     }\n+    @Test\n+    void testDefault() {\n+        Map<String, String> map = new HashMap<>();\n+        map.put(\"aaa\", \"aaa\");\n+        map.put(\"bbb\", \"bbb\");\n+        map.put(\"version\", \"2.0\");\n+        map.put(\"timeout\", \"1234\");\n+        map.put(\"default.timeout\", \"5678\");\n+\n+        URLParam urlParam1 = URLParam.parse(map);\n+        Assertions.assertEquals(\"1234\", urlParam1.getParameter(\"timeout\"));\n+        Assertions.assertEquals(\"5678\", urlParam1.getParameter(\"default.timeout\"));\n+\n+        map.remove(\"timeout\");\n+        URLParam urlParam2 = URLParam.parse(map);\n+        Assertions.assertEquals(\"5678\", urlParam2.getParameter(\"timeout\"));\n+        Assertions.assertEquals(\"5678\", urlParam2.getParameter(\"default.timeout\"));\n+\n+        URLParam urlParam3 = URLParam.parse(\"timeout=1234&default.timeout=5678\");\n+        Assertions.assertEquals(\"1234\", urlParam3.getParameter(\"timeout\"));\n+        Assertions.assertEquals(\"5678\", urlParam3.getParameter(\"default.timeout\"));\n+\n+        URLParam urlParam4 = URLParam.parse(\"default.timeout=5678\");\n+        Assertions.assertEquals(\"5678\", urlParam4.getParameter(\"timeout\"));\n+        Assertions.assertEquals(\"5678\", urlParam4.getParameter(\"default.timeout\"));\n+    }\n+\n     @Test\n     void testGetParameter() {\n         URLParam urlParam1 = URLParam.parse(\"aaa=aaa&bbb&version=1.0&default.ccc=123\");\n@@ -270,4 +297,4 @@ void testMethodParameters() {\n         Assertions.assertEquals(\"aaa\",urlParam2.getAnyMethodParameter(\"method1\"));\n         Assertions.assertNull(urlParam2.getAnyMethodParameter(\"method2\"));\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Fix URLParam decode default value * Fix URLParam decode default value * Add test cases"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n@@ -228,7 +228,7 @@ public MetadataInfo getRemoteMetadata(String revision, List<ServiceInstance> ins\n             int triedTimes = 0;\n             while (triedTimes < 3) {\n-                metadata = MetricsEventBus.post(new MetadataEvent.PushEvent(applicationModel),\n+                metadata = MetricsEventBus.post(new MetadataEvent.SubscribeEvent(applicationModel),\n                     () -> MetadataUtils.getRemoteMetadata(revision, instances, metadataReport),\n                     result -> result != MetadataInfo.EMPTY\n                 );",
    "output": "Fix"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/ApplicationDeployListener.java b/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/ApplicationDeployListener.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/ApplicationDeployListener.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/ApplicationDeployListener.java\n@@ -25,6 +25,7 @@\n  */\n @SPI(scope = ExtensionScope.APPLICATION)\n public interface ApplicationDeployListener extends DeployListener<ApplicationModel> {\n+\n     default void onModuleStarted(ApplicationModel applicationModel) {\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/DeployListener.java b/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/DeployListener.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/DeployListener.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/DeployListener.java\n@@ -19,6 +19,10 @@\n import org.apache.dubbo.rpc.model.ScopeModel;\n public interface DeployListener<E extends ScopeModel> {\n+    /**\n+     * Useful to inject some configuration like MetricsConfig, RegistryConfig, etc.\n+     */\n+    void onInitialize(E scopeModel);\n     void onStarting(E scopeModel);\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/DeployListenerAdapter.java b/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/DeployListenerAdapter.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/DeployListenerAdapter.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/DeployListenerAdapter.java\n@@ -19,6 +19,11 @@\n import org.apache.dubbo.rpc.model.ScopeModel;\n public class DeployListenerAdapter<E extends ScopeModel> implements DeployListener<E>{\n+    @Override\n+    public void onInitialize(E scopeModel) {\n+\n+    }\n+\n     @Override\n     public void onStarting(E scopeModel) {\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -201,6 +201,8 @@ public void initialize() {\n             if (initialized) {\n                 return;\n             }\n+            onInitialize();\n+\n             // register shutdown hook\n             registerShutdownHook();\n@@ -1082,6 +1084,16 @@ private DeployState calculateState() {\n         return newState;\n     }\n+    private void onInitialize() {\n+        for (DeployListener<ApplicationModel> listener : listeners) {\n+            try {\n+                listener.onInitialize(applicationModel);\n+            } catch (Throwable e) {\n+                logger.error(CONFIG_FAILED_START_MODEL, \"\", \"\", getIdentifier() + \" an exception occurred when handle initialize event\", e);\n+            }\n+        }\n+    }\n+\n     private void exportMetadataService() {\n         if (!isStarting()) {\n             return;\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.config.ReferenceCache;\n import org.apache.dubbo.common.deploy.AbstractDeployer;\n import org.apache.dubbo.common.deploy.ApplicationDeployer;\n+import org.apache.dubbo.common.deploy.DeployListener;\n import org.apache.dubbo.common.deploy.DeployState;\n import org.apache.dubbo.common.deploy.ModuleDeployListener;\n import org.apache.dubbo.common.deploy.ModuleDeployer;\n@@ -46,12 +47,12 @@\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_START_MODEL;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_UNABLE_DESTROY_MODEL;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_REFERENCE_MODEL;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_EXPORT_SERVICE;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_WAIT_EXPORT_REFER;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_REFERENCE_MODEL;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_REFER_SERVICE;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_START_MODEL;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_WAIT_EXPORT_REFER;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_UNABLE_DESTROY_MODEL;\n /**\n  * Export/refer services of module\n@@ -110,6 +111,8 @@ public void initialize() throws IllegalStateException {\n             if (initialized) {\n                 return;\n             }\n+            onInitialize();\n+\n             loadConfigs();\n             // read ModuleConfig\n@@ -249,6 +252,16 @@ public synchronized void postDestroy() throws IllegalStateException {\n         onModuleStopped();\n     }\n+    private void onInitialize() {\n+        for (DeployListener<ModuleModel> listener : listeners) {\n+            try {\n+                listener.onInitialize(moduleModel);\n+            } catch (Throwable e) {\n+                logger.error(CONFIG_FAILED_START_MODEL, \"\", \"\", getIdentifier() + \" an exception occurred when handle initialize event\", e);\n+            }\n+        }\n+    }\n+\n     private void onModuleStarting() {\n         setStarting();\n         startFuture = new CompletableFuture();\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ExporterDeployListener.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ExporterDeployListener.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ExporterDeployListener.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ExporterDeployListener.java\n@@ -28,6 +28,11 @@\n public class ExporterDeployListener implements ApplicationDeployListener, Prioritized {\n     protected volatile ConfigurableMetadataServiceExporter metadataServiceExporter;\n+    @Override\n+    public void onInitialize(ApplicationModel scopeModel) {\n+\n+    }\n+\n     @Override\n     public void onStarting(ApplicationModel scopeModel) {\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n@@ -896,6 +896,11 @@ public DeployEventHandler(ModuleModel moduleModel) {\n             this.moduleModel = moduleModel;\n         }\n+        @Override\n+        public void onInitialize(ModuleModel scopeModel) {\n+            Assertions.assertEquals(moduleModel, scopeModel);\n+        }\n+\n         @Override\n         public void onStarting(ModuleModel scopeModel) {\n             Assertions.assertEquals(moduleModel, scopeModel);\ndiff --git a/dubbo-plugin/dubbo-security/src/main/java/org/apache/dubbo/security/cert/CertDeployerListener.java b/dubbo-plugin/dubbo-security/src/main/java/org/apache/dubbo/security/cert/CertDeployerListener.java\n--- a/dubbo-plugin/dubbo-security/src/main/java/org/apache/dubbo/security/cert/CertDeployerListener.java\n+++ b/dubbo-plugin/dubbo-security/src/main/java/org/apache/dubbo/security/cert/CertDeployerListener.java\n@@ -30,6 +30,11 @@ public CertDeployerListener(FrameworkModel frameworkModel) {\n         dubboCertManager = frameworkModel.getBeanFactory().getBean(DubboCertManager.class);\n     }\n+    @Override\n+    public void onInitialize(ApplicationModel scopeModel) {\n+\n+    }\n+\n     @Override\n     public void onStarting(ApplicationModel scopeModel) {\n         scopeModel.getApplicationConfigManager().getSsl().ifPresent(sslConfig -> {",
    "output": "Add onInitialize Support * Add onInitialize Support * Fix compile"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/BatchExecutorQueue.java b/dubbo-common/src/main/java/org/apache/dubbo/common/BatchExecutorQueue.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/BatchExecutorQueue.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/BatchExecutorQueue.java\n@@ -62,7 +62,7 @@ private void run(Executor executor) {\n             boolean flushedOnce = false;\n             while ((item = snapshot.poll()) != null) {\n                 if (snapshot.size() == 0) {\n-                    i = 0;\n+                    flushedOnce = false;\n                     break;\n                 }\n                 if (i == chunkSize) {\n@@ -74,7 +74,7 @@ private void run(Executor executor) {\n                     i++;\n                 }\n             }\n-            if ((i != 0 || !flushedOnce) && item != null) {\n+            if (!flushedOnce && item != null) {\n                 flush(item);\n             }\n         } finally {",
    "output": "Fix BatchExecutorQueue bug"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-prometheus/src/main/java/org/apache/dubbo/metrics/prometheus/NopPrometheusMetricsReporter.java b/dubbo-metrics/dubbo-metrics-prometheus/src/main/java/org/apache/dubbo/metrics/prometheus/NopPrometheusMetricsReporter.java\n--- a/dubbo-metrics/dubbo-metrics-prometheus/src/main/java/org/apache/dubbo/metrics/prometheus/NopPrometheusMetricsReporter.java\n+++ b/dubbo-metrics/dubbo-metrics-prometheus/src/main/java/org/apache/dubbo/metrics/prometheus/NopPrometheusMetricsReporter.java\n@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.metrics.prometheus;\n+\n+import org.apache.dubbo.metrics.report.MetricsReporter;\n+\n+/**\n+ * NopMetricsReporter is a trivial implementation of MetricsReporter\n+ * which do nothing when micro-meter package is not exist.\n+ */\n+public class NopPrometheusMetricsReporter implements MetricsReporter {\n+\n+    @Override\n+    public void init() {\n+\n+    }\n+\n+    @Override\n+    public void refreshData() {\n+\n+    }\n+\n+    @Override\n+    public String getResponse() {\n+        return \"\";\n+    }\n+}\ndiff --git a/dubbo-metrics/dubbo-metrics-prometheus/src/main/java/org/apache/dubbo/metrics/prometheus/PrometheusMetricsReporterFactory.java b/dubbo-metrics/dubbo-metrics-prometheus/src/main/java/org/apache/dubbo/metrics/prometheus/PrometheusMetricsReporterFactory.java\n--- a/dubbo-metrics/dubbo-metrics-prometheus/src/main/java/org/apache/dubbo/metrics/prometheus/PrometheusMetricsReporterFactory.java\n+++ b/dubbo-metrics/dubbo-metrics-prometheus/src/main/java/org/apache/dubbo/metrics/prometheus/PrometheusMetricsReporterFactory.java\n@@ -18,21 +18,50 @@\n package org.apache.dubbo.metrics.prometheus;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.metrics.report.MetricsReporter;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.metrics.report.AbstractMetricsReporterFactory;\n+import org.apache.dubbo.metrics.report.MetricsReporter;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n+\n /**\n  * MetricsReporterFactory to create PrometheusMetricsReporter.\n  */\n public class PrometheusMetricsReporterFactory extends AbstractMetricsReporterFactory {\n+    private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(PrometheusMetricsReporterFactory.class);\n+\n     public PrometheusMetricsReporterFactory(ApplicationModel applicationModel) {\n         super(applicationModel);\n     }\n     @Override\n     public MetricsReporter createMetricsReporter(URL url) {\n-        return new PrometheusMetricsReporter(url, getApplicationModel());\n+        try {\n+            return new PrometheusMetricsReporter(url, getApplicationModel());\n+        } catch (NoClassDefFoundError ncde) {\n+            String msg = ncde.getMessage();\n+            if (dependenciesNotFound(msg)) {\n+                logger.error(INTERNAL_ERROR, \"\", \"\", \"Failed to load class \\\"org.apache.dubbo.metrics.prometheus.PrometheusMetricsReporter\\\".\", ncde);\n+                logger.error(INTERNAL_ERROR, \"\", \"\", \"Defaulting to no-operation (NOP) metricsReporter implementation\", ncde);\n+                logger.error(INTERNAL_ERROR, \"\", \"\", \"Introduce the micrometer-core package to use the ability of metrics\", ncde);\n+                return new NopPrometheusMetricsReporter();\n+            } else {\n+                logger.error(INTERNAL_ERROR, \"\", \"\", \"Failed to instantiate PrometheusMetricsReporter\", ncde);\n+                throw ncde;\n+            }\n+        }\n+    }\n+\n+    private static boolean dependenciesNotFound(String msg) {\n+        if (msg == null) {\n+            return false;\n+        }\n+        if (msg.contains(\"io/micrometer/core/instrument/composite/CompositeMeterRegistry\")) {\n+            return true;\n+        }\n+        return msg.contains(\"io.micrometer.core.instrument.composite.CompositeMeterRegistry\");\n     }\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryTest.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryTest.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryTest.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryTest.java\n@@ -138,6 +138,7 @@ void testDoSubscribe() {\n         }\n //        // when check = true\n         URL checkURL = url.addParameter(CHECK_KEY, true);\n+        checkURL.setScopeModel(url.getApplicationModel());\n //        Exception exceptionShouldHappen = null;\n //        try {\n //            serviceDiscoveryRegistry.doSubscribe(checkURL, testServiceListener);",
    "output": "Add nop for prometheus metrics"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/SlidingWindow.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/SlidingWindow.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/SlidingWindow.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/SlidingWindow.java\n@@ -18,7 +18,6 @@\n package org.apache.dubbo.metrics.aggregate;\n import org.apache.dubbo.common.utils.Assert;\n-import org.apache.dubbo.common.utils.TimeUtils;\n import java.util.ArrayList;\n import java.util.List;\n@@ -77,7 +76,7 @@ protected SlidingWindow(int paneCount, long intervalInMs) {\n      * @return the pane at current timestamp.\n      */\n     public Pane<T> currentPane() {\n-        return currentPane(TimeUtils.currentTimeMillis());\n+        return currentPane(System.currentTimeMillis());\n     }\n     /**\n@@ -197,7 +196,7 @@ protected long calculatePaneStart(long timeMillis) {\n      * @return true if the pane is deprecated; otherwise false.\n      */\n     public boolean isPaneDeprecated(final Pane<T> pane) {\n-        return isPaneDeprecated(TimeUtils.currentTimeMillis(), pane);\n+        return isPaneDeprecated(System.currentTimeMillis(), pane);\n     }\n     /**\n@@ -219,7 +218,7 @@ public boolean isPaneDeprecated(long timeMillis, final Pane<T> pane) {\n      * @return valid pane list for entire sliding window.\n      */\n     public List<Pane<T>> list() {\n-        return list(TimeUtils.currentTimeMillis());\n+        return list(System.currentTimeMillis());\n     }\n     /**\n@@ -254,7 +253,7 @@ public List<Pane<T>> list(long timeMillis) {\n      * @return aggregated value list for entire sliding window.\n      */\n     public List<T> values() {\n-        return values(TimeUtils.currentTimeMillis());\n+        return values(System.currentTimeMillis());\n     }\n     /**\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowCounterTest.java b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowCounterTest.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowCounterTest.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowCounterTest.java\n@@ -23,15 +23,15 @@\n class TimeWindowCounterTest {\n     @Test\n-    void test() throws Exception {\n+    void test() {\n         TimeWindowCounter counter = new TimeWindowCounter(10, 1);\n         counter.increment();\n-        Assertions.assertEquals(counter.get(), 1);\n+        Assertions.assertEquals(1, counter.get());\n         counter.decrement();\n-        Assertions.assertEquals(counter.get(), 0);\n+        Assertions.assertEquals(0, counter.get());\n         counter.increment();\n-        Thread.sleep(1000);\n-        Assertions.assertEquals(counter.get(), 0);\n-        Assertions.assertTrue(counter.bucketLivedSeconds() < 1);\n+        counter.increment();\n+        Assertions.assertEquals(2, counter.get());\n+        Assertions.assertTrue(counter.bucketLivedSeconds() <= 1);\n     }\n }\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/aggregate/TimeWindowQuantileTest.java\n@@ -23,15 +23,13 @@\n class TimeWindowQuantileTest {\n     @Test\n-    void test() throws Exception {\n+    void test() {\n         TimeWindowQuantile quantile = new TimeWindowQuantile(100, 10, 1);\n         for (int i = 1; i <= 100; i++) {\n             quantile.add(i);\n         }\n         Assertions.assertEquals(quantile.quantile(0.01), 2);\n         Assertions.assertEquals(quantile.quantile(0.99), 100);\n-        Thread.sleep(1000);\n-        Assertions.assertEquals(quantile.quantile(0.99), Double.NaN);\n     }\n }",
    "output": "Fix SlidingWindow test case bug * Fix SlidingWindow test case bug * Fix test case * Fix test case"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/RegistryConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/RegistryConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/RegistryConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/RegistryConfig.java\n@@ -553,4 +553,10 @@ public boolean isValid() {\n         // empty protocol will default to 'dubbo'\n         return !StringUtils.isEmpty(address) || !StringUtils.isEmpty(protocol);\n     }\n+\n+    @Override\n+    @Parameter(excluded = true)\n+    public Boolean isDefault() {\n+        return isDefault;\n+    }\n }",
    "output": "Fix issue 11844"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n@@ -29,6 +29,7 @@\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n+import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.protocol.AbstractInvoker;\n@@ -103,6 +104,9 @@ protected Result doInvoke(final Invocation invocation) throws Throwable {\n             }\n             invocation.setAttachment(TIMEOUT_KEY, String.valueOf(timeout));\n+\n+            RpcContext.getServiceContext().setRemoteAddress(currentClient.getRemoteAddress());\n+\n             if (isOneway) {\n                 boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);\n                 currentClient.send(inv, isSent);",
    "output": "Fix issue #11790"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/ApplicationMetric.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/ApplicationMetric.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/ApplicationMetric.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/ApplicationMetric.java\n@@ -22,16 +22,17 @@\n import java.util.HashMap;\n import java.util.Map;\n-import static org.apache.dubbo.common.constants.MetricsConstants.TAG_APPLICATION_NAME;\n-import static org.apache.dubbo.common.constants.MetricsConstants.TAG_APPLICATION_VERSION_KEY;\n import static org.apache.dubbo.common.constants.MetricsConstants.TAG_HOSTNAME;\n import static org.apache.dubbo.common.constants.MetricsConstants.TAG_IP;\n+import static org.apache.dubbo.common.constants.MetricsConstants.TAG_APPLICATION_NAME;\n+import static org.apache.dubbo.common.constants.MetricsConstants.TAG_APPLICATION_VERSION_KEY;\n import static org.apache.dubbo.common.utils.NetUtils.getLocalHost;\n import static org.apache.dubbo.common.utils.NetUtils.getLocalHostName;\n public class ApplicationMetric implements Metric {\n     private final String applicationName;\n     private static final String version = Version.getVersion();\n+    private static final String commitId = Version.getLastCommitId();\n     public ApplicationMetric(String applicationName) {\n         this.applicationName = applicationName;\n@@ -56,6 +57,7 @@ public static Map<String, String> getTagsByName(String applicationName) {\n         tags.put(TAG_HOSTNAME, getLocalHostName());\n         tags.put(TAG_APPLICATION_NAME, applicationName);\n         tags.put(TAG_APPLICATION_VERSION_KEY, version);\n+        tags.put(MetricsKey.METADATA_GIT_COMMITID_METRIC.getName(), commitId);\n         return tags;\n     }\n }\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsKey.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsKey.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsKey.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsKey.java\n@@ -91,7 +91,7 @@ public enum MetricsKey {\n     METADATA_SUBSCRIBE_METRIC_NUM(\"dubbo.metadata.subscribe.num.total\", \"Total Metadata Subscribe Num\"),\n     METADATA_SUBSCRIBE_METRIC_NUM_SUCCEED(\"dubbo.metadata.subscribe.num.succeed.total\", \"Succeed Metadata Subscribe Num\"),\n     METADATA_SUBSCRIBE_METRIC_NUM_FAILED(\"dubbo.metadata.subscribe.num.failed.total\", \"Failed Metadata Subscribe Num\"),\n-\n+    METADATA_GIT_COMMITID_METRIC(\"git.commit.id\",\"Git Commit Id Metrics\");\n     // consumer metrics key\n     ;",
    "output": "Add commit id metrics * add commit id metrics * reslove * problem ---------"
  },
  {
    "input": "diff --git a/dubbo-native/src/main/java/org/apache/dubbo/aot/generate/ReflectConfigMetadataRepository.java b/dubbo-native/src/main/java/org/apache/dubbo/aot/generate/ReflectConfigMetadataRepository.java\n--- a/dubbo-native/src/main/java/org/apache/dubbo/aot/generate/ReflectConfigMetadataRepository.java\n+++ b/dubbo-native/src/main/java/org/apache/dubbo/aot/generate/ReflectConfigMetadataRepository.java\n@@ -20,6 +20,7 @@\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Collectors;\n@@ -34,22 +35,22 @@ public ReflectConfigMetadataRepository() {\n     }\n     public ReflectConfigMetadataRepository registerSpiExtensionType(List<Class<?>> classes) {\n-        types.addAll(classes.stream().map(this::buildTypeDescriberWithConstructor).collect(Collectors.toList()));\n+        types.addAll(classes.stream().filter(Objects::nonNull).map(this::buildTypeDescriberWithConstructor).collect(Collectors.toList()));\n         return this;\n     }\n     public ReflectConfigMetadataRepository registerAdaptiveType(List<Class<?>> classes) {\n-        types.addAll(classes.stream().map(this::buildTypeDescriberWithConstructor).collect(Collectors.toList()));\n+        types.addAll(classes.stream().filter(Objects::nonNull).map(this::buildTypeDescriberWithConstructor).collect(Collectors.toList()));\n         return this;\n     }\n     public ReflectConfigMetadataRepository registerBeanType(List<Class<?>> classes) {\n-        types.addAll(classes.stream().map(this::buildTypeDescriberWithConstructor).collect(Collectors.toList()));\n+        types.addAll(classes.stream().filter(Objects::nonNull).map(this::buildTypeDescriberWithConstructor).collect(Collectors.toList()));\n         return this;\n     }\n     public ReflectConfigMetadataRepository registerConfigType(List<Class<?>> classes) {\n-        types.addAll(classes.stream().map(this::buildTypeDescriberWithConstructor).collect(Collectors.toList()));\n+        types.addAll(classes.stream().filter(Objects::nonNull).map(this::buildTypeDescriberWithConstructor).collect(Collectors.toList()));\n         return this;\n     }",
    "output": "Fix npe in the native compilation phase"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n@@ -178,6 +178,11 @@ public final void onComplete() {\n             // It will enter here when there is an error in the header\n             return;\n         }\n+        //Both 'onError' and 'onComplete' are termination operators.\n+        // The stream will be closed when 'onError' was called, and 'onComplete' is not allowed to be called again.\n+        if (isClosed()) {\n+            return;\n+        }\n         listener.onComplete();\n     }",
    "output": "Fix npe * fix npe * fix npe"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -228,11 +228,7 @@ public T get() {\n             // ensure start module, compatible with old api usage\n             getScopeModel().getDeployer().start();\n-            synchronized (this) {\n-                if (ref == null) {\n-                    init();\n-                }\n-            }\n+            init();\n         }\n         return ref;",
    "output": "Remove redundant synchronized"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n@@ -39,7 +39,6 @@\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n-import static org.apache.dubbo.common.constants.CommonConstants.CHECK_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n@@ -192,8 +191,6 @@ public void doSubscribe(URL url, NotifyListener listener) {\n         serviceDiscovery.subscribe(url, listener);\n-        boolean check = url.getParameter(CHECK_KEY, false);\n-\n         Set<String> mappingByUrl = ServiceNameMapping.getMappingByUrl(url);\n         String key = ServiceNameMapping.buildMappingKey(url);",
    "output": "Fix remove unused param * fix remove unused param * fix remove unused param"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ScopeModelUtilTest.java b/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ScopeModelUtilTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ScopeModelUtilTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ScopeModelUtilTest.java\n@@ -25,6 +25,8 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import java.util.concurrent.locks.Lock;\n+\n /**\n  * {@link ScopeModelUtil}\n  */\n@@ -109,6 +111,11 @@ protected void onDestroy() {\n         public Environment getModelEnvironment() {\n             return null;\n         }\n+\n+        @Override\n+        protected Lock acquireDestroyLock() {\n+            return null;\n+        }\n     }\n }",
    "output": "Fix uts"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n@@ -36,6 +36,7 @@\n import java.util.Set;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n /**\n  * {@link ExtensionLoader}, {@code DubboBootstrap} and this class are at present designed to be\n@@ -345,6 +346,11 @@ public void setDeployer(ApplicationDeployer deployer) {\n         this.deployer = deployer;\n     }\n+    @Override\n+    protected Lock acquireDestroyLock() {\n+        return frameworkModel.acquireDestroyLock();\n+    }\n+\n     // =============================== Deprecated Methods Start =======================================\n     /**\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n@@ -33,6 +33,8 @@\n import java.util.Set;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.stream.Collectors;\n /**\n@@ -48,7 +50,7 @@ public class FrameworkModel extends ScopeModel {\n     private static final AtomicLong index = new AtomicLong(1);\n     private static final Object globalLock = new Object();\n-\n+\n     private volatile static FrameworkModel defaultInstance;\n     private static final List<FrameworkModel> allInstances = new CopyOnWriteArrayList<>();\n@@ -68,6 +70,8 @@ public class FrameworkModel extends ScopeModel {\n     private final ApplicationModel internalApplicationModel;\n+    private final ReentrantLock destroyLock = new ReentrantLock();\n+\n     /**\n      * Use {@link FrameworkModel#newModel()} to create a new model\n      */\n@@ -356,6 +360,12 @@ public FrameworkServiceRepository getServiceRepository() {\n         return serviceRepository;\n     }\n+\n+    @Override\n+    protected Lock acquireDestroyLock() {\n+        return destroyLock;\n+    }\n+\n     @Override\n     public Environment getModelEnvironment() {\n         throw new UnsupportedOperationException(\"Environment is inaccessible for FrameworkModel\");\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n@@ -32,6 +32,7 @@\n import java.util.HashMap;\n import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n /**\n  * Model of a service module\n@@ -172,6 +173,11 @@ public void setDeployer(ModuleDeployer deployer) {\n         this.deployer = deployer;\n     }\n+    @Override\n+    protected Lock acquireDestroyLock() {\n+        return getApplicationModel().getFrameworkModel().acquireDestroyLock();\n+    }\n+\n     /**\n      * for ut only\n      */\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java\n@@ -34,6 +34,7 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.Lock;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_UNABLE_DESTROY_MODEL;\n@@ -109,8 +110,12 @@ protected void initialize() {\n         }\n     }\n+    protected abstract Lock acquireDestroyLock();\n+\n     public void destroy() {\n-        synchronized (instLock) {\n+        Lock lock = acquireDestroyLock();\n+        try {\n+            lock.lock();\n             if (destroyed.compareAndSet(false, true)) {\n                 try {\n                     onDestroy();\n@@ -128,6 +133,8 @@ public void destroy() {\n                     LOGGER.error(CONFIG_UNABLE_DESTROY_MODEL, \"\", \"\", \"Error happened when destroying ScopeModel.\", t);\n                 }\n             }\n+        } finally {\n+            lock.unlock();\n         }\n     }",
    "output": "Fix lock acquire blocked"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n@@ -28,6 +28,7 @@\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.metrics.event.GlobalMetricsEventMulticaster;\n+import org.apache.dubbo.metrics.event.MetricsEvent;\n import org.apache.dubbo.metrics.registry.event.RegistryEvent;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n@@ -387,9 +388,15 @@ private void refreshInvokers(BitList<Invoker<T>> targetInvokers, Collection<Invo\n         invokersToRemove.removeAll(needToRemove);\n     }\n+    private void publishMetricsEvent(MetricsEvent event) {\n+        if (eventMulticaster != null) {\n+            eventMulticaster.publishEvent(event);\n+        }\n+    }\n+\n     @Override\n     public void addDisabledInvoker(Invoker<T> invoker) {\n-        eventMulticaster.publishEvent(new RegistryEvent.MetricsDirectoryEvent(applicationModel, RegistryEvent.Type.D_DISABLE));\n+        publishMetricsEvent(new RegistryEvent.MetricsDirectoryEvent(applicationModel, RegistryEvent.Type.D_DISABLE));\n         if (invokers.contains(invoker)) {\n             disabledInvokers.add(invoker);\n             removeValidInvoker(invoker);\n@@ -399,7 +406,7 @@ public void addDisabledInvoker(Invoker<T> invoker) {\n     @Override\n     public void recoverDisabledInvoker(Invoker<T> invoker) {\n-        eventMulticaster.publishEvent(new RegistryEvent.MetricsDirectoryEvent(applicationModel, RegistryEvent.Type.D_RECOVER_DISABLE));\n+        publishMetricsEvent(new RegistryEvent.MetricsDirectoryEvent(applicationModel, RegistryEvent.Type.D_RECOVER_DISABLE));\n         if (disabledInvokers.remove(invoker)) {\n             try {\n                 addValidInvoker(invoker);\n@@ -463,7 +470,7 @@ protected void setInvokers(BitList<Invoker<T>> invokers) {\n         this.invokers = invokers;\n         refreshInvokerInternal();\n         this.invokersInitialized = true;\n-        eventMulticaster.publishEvent(new RegistryEvent.MetricsDirectoryEvent(applicationModel, RegistryEvent.Type.D_CURRENT, invokers.size()));\n+        publishMetricsEvent(new RegistryEvent.MetricsDirectoryEvent(applicationModel, RegistryEvent.Type.D_CURRENT, invokers.size()));\n     }\n     protected void destroyInvokers() {\n@@ -474,14 +481,14 @@ protected void destroyInvokers() {\n     }\n     private boolean addValidInvoker(Invoker<T> invoker) {\n-        eventMulticaster.publishEvent(new RegistryEvent.MetricsDirectoryEvent(applicationModel, RegistryEvent.Type.D_VALID));\n+        publishMetricsEvent(new RegistryEvent.MetricsDirectoryEvent(applicationModel, RegistryEvent.Type.D_VALID));\n         synchronized (this.validInvokers) {\n             return this.validInvokers.add(invoker);\n         }\n     }\n     private boolean removeValidInvoker(Invoker<T> invoker) {\n-        eventMulticaster.publishEvent(new RegistryEvent.MetricsDirectoryEvent(applicationModel, RegistryEvent.Type.D_UN_VALID));\n+        publishMetricsEvent(new RegistryEvent.MetricsDirectoryEvent(applicationModel, RegistryEvent.Type.D_UN_VALID));\n         synchronized (this.validInvokers) {\n             return this.validInvokers.remove(invoker);\n         }",
    "output": "Fix metrics publisher NPE"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -483,7 +483,6 @@ void testCreateInvokerForLocalRefer() {\n         Assertions.assertTrue(referenceConfig.getInvoker() instanceof MockClusterInvoker);\n         Invoker<?> withCount = ((MockClusterInvoker<?>) referenceConfig.getInvoker()).getDirectory().getAllInvokers().get(0);\n         Assertions.assertTrue(withCount instanceof ReferenceCountInvokerWrapper);\n-        Assertions.assertTrue(((ReferenceCountInvokerWrapper<?>) withCount).getInvoker() instanceof ListenerInvokerWrapper);\n         Invoker<?> withFilter = ((ReferenceCountInvokerWrapper<?>) withCount).getInvoker();\n         Assertions.assertTrue(withFilter instanceof ListenerInvokerWrapper\n             || withFilter instanceof FilterChainBuilder.CallbackRegistrationInvoker);",
    "output": "Fix ut"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n@@ -278,7 +278,7 @@ private static boolean addParam(String str, boolean isEncoded, int nameStart, in\n             String name = decodeComponent(str, nameStart, valueStart - 3, false, tempBuf);\n             String value;\n             if (valueStart >= valueEnd) {\n-                value = name;\n+                value = \"\";\n             } else {\n                 value = decodeComponent(str, valueStart, valueEnd, false, tempBuf);\n             }\n@@ -291,7 +291,7 @@ private static boolean addParam(String str, boolean isEncoded, int nameStart, in\n             String name = str.substring(nameStart, valueStart - 1);\n             String value;\n             if (valueStart >= valueEnd) {\n-                value = name;\n+                value = \"\";\n             } else {\n                 value = str.substring(valueStart, valueEnd);\n             }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/URLStrParserTest.java\n@@ -44,6 +44,7 @@ class URLStrParserTest {\n         testCases.add(\"file:/path/to/file.txt\");\n         testCases.add(\"dubbo://fe80:0:0:0:894:aeec:f37d:23e1%en0/path?abc=abc\");\n         testCases.add(\"dubbo://[fe80:0:0:0:894:aeec:f37d:23e1]:20880/path?abc=abc\");\n+        testCases.add(\"nacos://192.168.1.1:8848?username=&password=\");\n         errorDecodedCases.add(\"dubbo:192.168.1.1\");\n         errorDecodedCases.add(\"://192.168.1.1\");\n@@ -80,4 +81,4 @@ void testDecoded() {\n         });\n     }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n@@ -308,7 +308,7 @@ void test_valueOf_WithProtocolHost() throws Exception {\n         assertEquals(3, url.getParameters().size());\n         assertEquals(\"1.0.0\", url.getVersion());\n         assertEquals(\"morgan\", url.getParameter(\"application\"));\n-        assertEquals(\"noValue\", url.getParameter(\"noValue\"));\n+        assertEquals(\"\", url.getParameter(\"noValue\"));\n     }\n     // TODO Do not want to use spaces? See: DUBBO-502, URL class handles special conventions for special characters.\n@@ -325,10 +325,10 @@ void test_noValueKey() throws Exception {\n         URL url = URL.valueOf(\"http://1.2.3.4:8080/path?k0=&k1=v1\");\n         assertURLStrDecoder(url);\n-        assertTrue(url.hasParameter(\"k0\"));\n+        assertFalse(url.hasParameter(\"k0\"));\n-        // If a Key has no corresponding Value, then the Key also used as the Value.\n-        assertEquals(\"k0\", url.getParameter(\"k0\"));\n+        // If a Key has no corresponding Value, then empty string used as the Value.\n+        assertEquals(\"\", url.getParameter(\"k0\"));\n     }\n     @Test\n@@ -1047,7 +1047,7 @@ void testParameterContainPound() {\n     @Test\n     void test_valueOfHasNameWithoutValue() throws Exception {\n         URL url = URL.valueOf(\"dubbo://admin:hello1234@10.20.130.230:20880/context/path?version=1.0.0&application=morgan&noValue\");\n-        Assertions.assertEquals(\"noValue\", url.getParameter(\"noValue\"));\n+        Assertions.assertEquals(\"\", url.getParameter(\"noValue\"));\n     }\n     @Test",
    "output": "Fix bug #11767"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -483,7 +483,9 @@ void testCreateInvokerForLocalRefer() {\n         Assertions.assertTrue(referenceConfig.getInvoker() instanceof MockClusterInvoker);\n         Invoker<?> withCount = ((MockClusterInvoker<?>) referenceConfig.getInvoker()).getDirectory().getAllInvokers().get(0);\n         Assertions.assertTrue(withCount instanceof ReferenceCountInvokerWrapper);\n-        Assertions.assertTrue(((ReferenceCountInvokerWrapper<?>) withCount).getInvoker() instanceof ListenerInvokerWrapper\n+        Assertions.assertTrue(((ReferenceCountInvokerWrapper<?>) withCount).getInvoker() instanceof ListenerInvokerWrapper);\n+        Invoker<?> withFilter = ((ReferenceCountInvokerWrapper<?>) withCount).getInvoker();\n+        Assertions.assertTrue(withFilter instanceof ListenerInvokerWrapper\n             || withFilter instanceof FilterChainBuilder.CallbackRegistrationInvoker);\n         if (withFilter instanceof ListenerInvokerWrapper) {\n             Assertions.assertTrue(((ListenerInvokerWrapper<?>)(((ReferenceCountInvokerWrapper<?>) withCount).getInvoker())).getInvoker() instanceof InjvmInvoker);",
    "output": "Fix uts"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -42,6 +42,7 @@\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ModuleModel;\n import org.apache.dubbo.rpc.model.ServiceMetadata;\n+import org.apache.dubbo.rpc.protocol.ReferenceCountInvokerWrapper;\n import org.apache.dubbo.rpc.protocol.injvm.InjvmInvoker;\n import org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol;\n import org.apache.dubbo.rpc.service.GenericService;\n@@ -479,10 +480,11 @@ void testCreateInvokerForLocalRefer() {\n         referenceConfig.init();\n         Assertions.assertTrue(referenceConfig.getInvoker() instanceof MockClusterInvoker);\n-        Invoker<?> withFilter = ((MockClusterInvoker<?>) referenceConfig.getInvoker()).getDirectory().getAllInvokers().get(0);\n-        Assertions.assertTrue(withFilter instanceof ListenerInvokerWrapper);\n-        Assertions.assertTrue(((ListenerInvokerWrapper<?>) withFilter).getInvoker() instanceof InjvmInvoker);\n-        URL url = withFilter.getUrl();\n+        Invoker<?> withCount = ((MockClusterInvoker<?>) referenceConfig.getInvoker()).getDirectory().getAllInvokers().get(0);\n+        Assertions.assertTrue(withCount instanceof ReferenceCountInvokerWrapper);\n+        Assertions.assertTrue(((ReferenceCountInvokerWrapper<?>) withCount).getInvoker() instanceof ListenerInvokerWrapper);\n+        Assertions.assertTrue(((ListenerInvokerWrapper<?>)(((ReferenceCountInvokerWrapper<?>) withCount).getInvoker())).getInvoker() instanceof InjvmInvoker);\n+        URL url = withCount.getUrl();\n         Assertions.assertEquals(\"application1\", url.getParameter(\"application\"));\n         Assertions.assertEquals(\"value1\", url.getParameter(\"key1\"));\n         Assertions.assertEquals(\"value2\", url.getParameter(\"key2\"));\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/InvokerCountWrapper.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/InvokerCountWrapper.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/InvokerCountWrapper.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/InvokerCountWrapper.java\n@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.Activate;\n+import org.apache.dubbo.common.utils.UrlUtils;\n+import org.apache.dubbo.rpc.Exporter;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.Protocol;\n+import org.apache.dubbo.rpc.RpcException;\n+\n+@Activate(order = Integer.MIN_VALUE + 1000)\n+public class InvokerCountWrapper implements Protocol {\n+    private final Protocol protocol;\n+\n+    public InvokerCountWrapper(Protocol protocol) {\n+        this.protocol = protocol;\n+    }\n+\n+    @Override\n+    public int getDefaultPort() {\n+        return protocol.getDefaultPort();\n+    }\n+\n+    @Override\n+    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n+        return protocol.export(invoker);\n+    }\n+\n+    @Override\n+    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n+        if (UrlUtils.isRegistry(url)) {\n+            return protocol.refer(type, url);\n+        }\n+        return new ReferenceCountInvokerWrapper<>(protocol.refer(type, url));\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        protocol.destroy();\n+    }\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ReferenceCountInvokerWrapper.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ReferenceCountInvokerWrapper.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ReferenceCountInvokerWrapper.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ReferenceCountInvokerWrapper.java\n@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.constants.LoggerCodeConstants;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.Result;\n+import org.apache.dubbo.rpc.RpcException;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class ReferenceCountInvokerWrapper<T> implements Invoker<T> {\n+    private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(ReferenceCountInvokerWrapper.class);\n+    private final Invoker<T> invoker;\n+\n+    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n+    private final AtomicBoolean destroyed = new AtomicBoolean(false);\n+\n+    public ReferenceCountInvokerWrapper(Invoker<T> invoker) {\n+        this.invoker = invoker;\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return invoker.getUrl();\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+        return !destroyed.get() && invoker.isAvailable();\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        try {\n+            lock.writeLock().lock();\n+            destroyed.set(true);\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+        invoker.destroy();\n+    }\n+\n+    @Override\n+    public Class<T> getInterface() {\n+        return invoker.getInterface();\n+    }\n+\n+    @Override\n+    public Result invoke(Invocation invocation) throws RpcException {\n+        try {\n+            lock.readLock().lock();\n+            if (destroyed.get()) {\n+                logger.warn(LoggerCodeConstants.PROTOCOL_CLOSED_SERVER, \"\", \"\",\n+                    \"Remote invoker has been destroyed, and unable to invoke anymore.\");\n+                throw new RpcException(\"This invoker has been destroyed!\");\n+            }\n+            return invoker.invoke(invocation);\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+    }\n+\n+    public Invoker<T> getInvoker() {\n+        return invoker;\n+    }\n+}",
    "output": "Fix recreate client after destroy * Fix recreate client after destroy * Fix uts"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n@@ -108,7 +108,6 @@ public synchronized ExecutorService createExecutorIfAbsent(URL url) {\n             executor = createExecutor(url);\n             executors.put(executorCacheKey, executor);\n         }\n-\n         dataStore.put(executorKey, executorCacheKey, executor);\n         return executor;\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/Constants.java b/dubbo-common/src/main/java/org/apache/dubbo/config/Constants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/Constants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/Constants.java\n@@ -149,5 +149,5 @@ public interface Constants {\n     String SERVER_THREAD_POOL_NAME = \"DubboServerHandler\";\n-\n+    String CLIENT_THREAD_POOL_NAME = \"DubboClientHandler\";\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -1088,6 +1088,7 @@ private void onStarted() {\n                 return;\n             }\n             setStarted();\n+            startMetricsCollector();\n             if (logger.isInfoEnabled()) {\n                 logger.info(getIdentifier() + \" is ready.\");\n             }\n@@ -1105,6 +1106,11 @@ private void onStarted() {\n         }\n     }\n+    private void startMetricsCollector(){\n+        DefaultMetricsCollector collector = applicationModel.getBeanFactory().getBean(DefaultMetricsCollector.class);\n+        collector.registryDefaultSample();\n+    }\n+\n     private void completeStartFuture(boolean success) {\n         if (startFuture != null) {\n             startFuture.complete(success);\ndiff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/DefaultMetricsCollector.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/DefaultMetricsCollector.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/DefaultMetricsCollector.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/DefaultMetricsCollector.java\n@@ -95,6 +95,10 @@ public void collectApplication(ApplicationModel applicationModel) {\n         applicationSampler.inc(applicationName, MetricsEvent.Type.APPLICATION_INFO);\n     }\n+    public void registryDefaultSample(){\n+        this.threadPoolSampler.registryDefaultSampleThreadPoolExecutor();\n+    }\n+\n     @Override\n     public List<MetricSample> collect() {\n         List<MetricSample> list = new ArrayList<>();\ndiff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadPoolMetricsSampler.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadPoolMetricsSampler.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadPoolMetricsSampler.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadPoolMetricsSampler.java\n@@ -37,9 +37,12 @@\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.ThreadPoolExecutor;\n+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SHARED_EXECUTOR_SERVICE_COMPONENT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.EXECUTOR_SERVICE_COMPONENT_KEY;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_METRICS_COLLECTOR_EXCEPTION;\n+import static org.apache.dubbo.config.Constants.CLIENT_THREAD_POOL_NAME;\n+import static org.apache.dubbo.config.Constants.SERVER_THREAD_POOL_NAME;\n import static org.apache.dubbo.metrics.model.MetricsCategory.THREAD_POOL;\n public class ThreadPoolMetricsSampler implements MetricsSampler {\n@@ -53,7 +56,6 @@ public class ThreadPoolMetricsSampler implements MetricsSampler {\n     public ThreadPoolMetricsSampler(DefaultMetricsCollector collector) {\n         this.collector = collector;\n-        this.registryDefaultSampleThreadPoolExecutor();\n     }\n     public void addExecutors(String name, ExecutorService executorService) {\n@@ -87,7 +89,7 @@ private List<MetricSample> createMetricsSample(String name, ThreadPoolExecutor e\n         return list;\n     }\n-    private void registryDefaultSampleThreadPoolExecutor() {\n+    public void registryDefaultSampleThreadPoolExecutor() {\n         ApplicationModel applicationModel = collector.getApplicationModel();\n         if (applicationModel == null) {\n             return;\n@@ -103,20 +105,26 @@ private void registryDefaultSampleThreadPoolExecutor() {\n         if (this.dataStore == null) {\n             this.dataStore = collector.getApplicationModel().getExtensionLoader(DataStore.class).getDefaultExtension();\n         }\n+\n         if (dataStore != null) {\n             Map<String, Object> executors = dataStore.get(EXECUTOR_SERVICE_COMPONENT_KEY);\n             for (Map.Entry<String, Object> entry : executors.entrySet()) {\n                 ExecutorService executor = (ExecutorService) entry.getValue();\n                 if (executor instanceof ThreadPoolExecutor) {\n-                    this.addExecutors(entry.getKey(), executor);\n+                    this.addExecutors( SERVER_THREAD_POOL_NAME + \"-\" + entry.getKey(), executor);\n+                }\n+            }\n+            executors = dataStore.get(CONSUMER_SHARED_EXECUTOR_SERVICE_COMPONENT_KEY);\n+            for (Map.Entry<String, Object> entry : executors.entrySet()) {\n+                ExecutorService executor = (ExecutorService) entry.getValue();\n+                if (executor instanceof ThreadPoolExecutor) {\n+                    this.addExecutors(CLIENT_THREAD_POOL_NAME + \"-\" + entry.getKey(), executor);\n                 }\n             }\n         }\n         if (this.frameworkExecutorRepository != null) {\n             this.addExecutors(\"sharedExecutor\", frameworkExecutorRepository.getSharedExecutor());\n-            this.addExecutors(\"mappingRefreshingExecutor\", frameworkExecutorRepository.getMappingRefreshingExecutor());\n-            this.addExecutors(\"poolRouterExecutor\", frameworkExecutorRepository.getPoolRouterExecutor());\n-        }\n+           }\n     }\n }",
    "output": "Fix the issue where core thread metrics were in effect * Fixed the issue where core thread metrics were in effect * Fixed the issue where core thread metrics were in effect * fix: add core thread metrics name * fix: remove useless dependencies ---------"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n@@ -137,7 +137,7 @@ public static ProxyHolder referProxy(ServiceInstance instance) {\n         ModuleModel internalModel = applicationModel.getInternalModule();\n         ConsumerModel consumerModel = applicationModel.getInternalModule().registerInternalConsumer(MetadataService.class, url);\n-        Protocol protocol = applicationModel.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n+        Protocol protocol = applicationModel.getExtensionLoader(Protocol.class).getExtension(url.getProtocol(), false);\n         url = url.setServiceModel(consumerModel);",
    "output": "Fix metadata proxy load filter"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java\n@@ -60,7 +60,6 @@ public class NacosNamingServiceWrapper {\n     private final ConcurrentMap<InstanceId, InstancesInfo> registerStatus = new ConcurrentHashMap<>();\n     private final ConcurrentMap<SubscribeInfo, NamingService> subscribeStatus = new ConcurrentHashMap<>();\n-    private final Lock mapLock = new ReentrantLock();\n     public NacosNamingServiceWrapper(NacosConnectionManager nacosConnectionManager, int retryTimes, int sleepMsBetweenRetries) {\n         this.nacosConnectionManager = nacosConnectionManager;\n@@ -108,13 +107,7 @@ public List<Instance> getAllInstances(String serviceName, String group) throws N\n     public void registerInstance(String serviceName, String group, Instance instance) throws NacosException {\n         String nacosServiceName = handleInnerSymbol(serviceName);\n-        InstancesInfo instancesInfo;\n-        try {\n-            mapLock.lock();\n-            instancesInfo = ConcurrentHashMapUtils.computeIfAbsent(registerStatus, new InstanceId(nacosServiceName, group), id -> new InstancesInfo());\n-        } finally {\n-            mapLock.unlock();\n-        }\n+        InstancesInfo instancesInfo = ConcurrentHashMapUtils.computeIfAbsent(registerStatus, new InstanceId(nacosServiceName, group), id -> new InstancesInfo());\n         try {\n             instancesInfo.lock();\n@@ -176,13 +169,7 @@ public void registerInstance(String serviceName, String group, Instance instance\n     public void updateInstance(String serviceName, String group, Instance oldInstance, Instance newInstance) throws NacosException {\n         String nacosServiceName = handleInnerSymbol(serviceName);\n-        InstancesInfo instancesInfo;\n-        try {\n-            mapLock.lock();\n-            instancesInfo = ConcurrentHashMapUtils.computeIfAbsent(registerStatus, new InstanceId(nacosServiceName, group), id -> new InstancesInfo());\n-        } finally {\n-            mapLock.unlock();\n-        }\n+        InstancesInfo instancesInfo = ConcurrentHashMapUtils.computeIfAbsent(registerStatus, new InstanceId(nacosServiceName, group), id -> new InstancesInfo());\n         try {\n             instancesInfo.lock();\n@@ -222,13 +209,7 @@ public void updateInstance(String serviceName, String group, Instance oldInstanc\n     public void deregisterInstance(String serviceName, String group, String ip, int port) throws NacosException {\n         String nacosServiceName = handleInnerSymbol(serviceName);\n-        InstancesInfo instancesInfo;\n-        try {\n-            mapLock.lock();\n-            instancesInfo = ConcurrentHashMapUtils.computeIfAbsent(registerStatus, new InstanceId(nacosServiceName, group), id -> new InstancesInfo());\n-        } finally {\n-            mapLock.unlock();\n-        }\n+        InstancesInfo instancesInfo = ConcurrentHashMapUtils.computeIfAbsent(registerStatus, new InstanceId(nacosServiceName, group), id -> new InstancesInfo());\n         try {\n             instancesInfo.lock();\n@@ -249,13 +230,7 @@ public void deregisterInstance(String serviceName, String group, String ip, int\n     public void deregisterInstance(String serviceName, String group, Instance instance) throws NacosException {\n         String nacosServiceName = handleInnerSymbol(serviceName);\n-        InstancesInfo instancesInfo;\n-        try {\n-            mapLock.lock();\n-            instancesInfo = ConcurrentHashMapUtils.computeIfAbsent(registerStatus, new InstanceId(nacosServiceName, group), id -> new InstancesInfo());\n-        } finally {\n-            mapLock.unlock();\n-        }\n+        InstancesInfo instancesInfo = ConcurrentHashMapUtils.computeIfAbsent(registerStatus, new InstanceId(nacosServiceName, group), id -> new InstancesInfo());\n         try {\n             instancesInfo.lock();\n@@ -269,14 +244,9 @@ public void deregisterInstance(String serviceName, String group, Instance instan\n             InstanceInfo instanceInfo = optional.get();\n             instancesInfo.getInstances().remove(instanceInfo);\n-            try {\n-                mapLock.lock();\n-                if (instancesInfo.getInstances().isEmpty()) {\n-                    registerStatus.remove(new InstanceId(nacosServiceName, group));\n-                    instancesInfo.setValid(false);\n-                }\n-            } finally {\n-                mapLock.unlock();\n+            if (instancesInfo.getInstances().isEmpty()) {\n+                registerStatus.remove(new InstanceId(nacosServiceName, group));\n+                instancesInfo.setValid(false);\n             }\n             // only one registered",
    "output": "Improve NacosNamingServiceWrapper performance"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.ArrayUtils;\n import org.apache.dubbo.common.utils.Assert;\n import org.apache.dubbo.common.utils.ClassUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n@@ -399,8 +400,22 @@ public String registerReferenceBean(String propertyName, Class<?> injectedType,\n         }\n         //check bean definition\n-        if (beanDefinitionRegistry.containsBeanDefinition(referenceBeanName)) {\n-            BeanDefinition prevBeanDefinition = beanDefinitionRegistry.getBeanDefinition(referenceBeanName);\n+        boolean isContains;\n+        if ((isContains = beanDefinitionRegistry.containsBeanDefinition(referenceBeanName)) || beanDefinitionRegistry.isAlias(referenceBeanName)) {\n+            String preReferenceBeanName = referenceBeanName;\n+            if (!isContains){\n+                // Look in the alias for the origin bean name\n+                String[] aliases = beanDefinitionRegistry.getAliases(referenceBeanName);\n+                if (ArrayUtils.isNotEmpty(aliases)) {\n+                    for (String alias : aliases) {\n+                        if (beanDefinitionRegistry.containsBeanDefinition(alias)) {\n+                            preReferenceBeanName = alias;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            BeanDefinition prevBeanDefinition = beanDefinitionRegistry.getBeanDefinition(preReferenceBeanName);\n             String prevBeanType = prevBeanDefinition.getBeanClassName();\n             String prevBeanDesc = referenceBeanName + \"[\" + prevBeanType + \"]\";\n             String newBeanDesc = referenceBeanName + \"[\" + referenceKey + \"]\";\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessorTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessorTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessorTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessorTest.java\n@@ -128,15 +128,30 @@ public Object aroundHelloService(ProceedingJoinPoint pjp) throws Throwable {\n     @DubboReference(version = \"2\", url = \"dubbo://127.0.0.1:12345?version=2\", tag = \"demo_tag\")\n     private HelloService helloService2;\n-    // #7 ReferenceBean (Method Injection #3)\n+    // #7 ReferenceBean (Field Injection #5)\n+    // The HelloService is the same as above service(#6 ReferenceBean (Field Injection #4)), helloService3 will be registered as an alias of helloService2\n+    @DubboReference(version = \"2\", url = \"dubbo://127.0.0.1:12345?version=2\", tag = \"demo_tag\")\n+    private HelloService helloService3;\n+\n+    // #8 ReferenceBean (Method Injection #3)\n     @DubboReference(version = \"3\", url = \"dubbo://127.0.0.1:12345?version=2\", tag = \"demo_tag\")\n     public void setHelloService2(HelloService helloService2) {\n         // The helloService2 beanName is the same as above(#6 ReferenceBean (Field Injection #4)), and this will rename to helloService2#2\n         renamedHelloService2 = helloService2;\n     }\n+    // #9 ReferenceBean (Method Injection #4)\n+    @DubboReference(version = \"4\", url = \"dubbo://127.0.0.1:12345?version=2\")\n+    public void setHelloService3(DemoService helloService3){\n+        // The helloService3 beanName is the same as above(#7 ReferenceBean (Field Injection #5) is an alias),\n+        // The current beanName(helloService3) is not registered in the beanDefinitionMap, but it is already an alias. so this will rename to helloService3#2\n+        this.renamedHelloService3 = helloService3;\n+    }\n+\n     private HelloService renamedHelloService2;\n+    private DemoService renamedHelloService3;\n+\n     @Test\n     void testAop() throws Exception {\n@@ -150,7 +165,7 @@ void testAop() throws Exception {\n         Assertions.assertNotNull(testBean.getDemoServiceFromParent());\n         Assertions.assertNotNull(testBean.getDemoService());\n         Assertions.assertNotNull(testBean.myDemoService);\n-        Assertions.assertEquals(2, demoServicesMap.size());\n+        Assertions.assertEquals(3, demoServicesMap.size());\n         Assertions.assertNotNull(context.getBean(\"demoServiceImpl\"));\n         Assertions.assertNotNull(context.getBean(\"myDemoService\"));\n@@ -189,12 +204,13 @@ void testGetInjectedFieldReferenceBeanMap() {\n         Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> referenceBeanMap =\n                 beanPostProcessor.getInjectedFieldReferenceBeanMap();\n-        Assertions.assertEquals(4, referenceBeanMap.size());\n+        Assertions.assertEquals(5, referenceBeanMap.size());\n         Map<String, Integer> checkingFieldNames = new HashMap<>();\n         checkingFieldNames.put(\"private org.apache.dubbo.config.spring.api.HelloService org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessorTest$MyConfiguration.helloService\", 0);\n         checkingFieldNames.put(\"private org.apache.dubbo.config.spring.api.HelloService org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessorTest.helloService\", 0);\n         checkingFieldNames.put(\"private org.apache.dubbo.config.spring.api.HelloService org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessorTest.helloService2\", 0);\n+        checkingFieldNames.put(\"private org.apache.dubbo.config.spring.api.HelloService org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessorTest.helloService3\", 0);\n         checkingFieldNames.put(\"private org.apache.dubbo.config.spring.api.DemoService org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessorTest$ParentBean.demoServiceFromParent\", 0);\n         for (Map.Entry<InjectionMetadata.InjectedElement, ReferenceBean<?>> entry : referenceBeanMap.entrySet()) {\n@@ -222,12 +238,13 @@ void testGetInjectedMethodReferenceBeanMap() {\n         Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> referenceBeanMap =\n                 beanPostProcessor.getInjectedMethodReferenceBeanMap();\n-        Assertions.assertEquals(3, referenceBeanMap.size());\n+        Assertions.assertEquals(4, referenceBeanMap.size());\n         Map<String, Integer> checkingMethodNames = new HashMap<>();\n         checkingMethodNames.put(\"setDemoServiceFromAncestor\", 0);\n         checkingMethodNames.put(\"setDemoService\", 0);\n         checkingMethodNames.put(\"setHelloService2\", 0);\n+        checkingMethodNames.put(\"setHelloService3\", 0);\n         for (Map.Entry<InjectionMetadata.InjectedElement, ReferenceBean<?>> entry : referenceBeanMap.entrySet()) {\n@@ -252,7 +269,7 @@ void testReferenceBeansMethodAnnotation() {\n         Collection<ReferenceBean> referenceBeans = referenceBeanManager.getReferences();\n-        Assertions.assertEquals(4, referenceBeans.size());\n+        Assertions.assertEquals(5, referenceBeans.size());\n         for (ReferenceBean referenceBean : referenceBeans) {\n             ReferenceConfig referenceConfig = referenceBean.getReferenceConfig();\n@@ -350,4 +367,4 @@ public TestBean testBean() {\n         }\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Fix reference bean name conflicts * fix reference bean name conflicts * add ut case"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/pu/TelnetDetector.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/pu/TelnetDetector.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/pu/TelnetDetector.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/pu/TelnetDetector.java\n@@ -32,7 +32,7 @@\n public class TelnetDetector implements ProtocolDetector {\n-    private FrameworkModel frameworkModel;\n+    private final FrameworkModel frameworkModel;\n     private final int MaxSize = 2048;\n     private final ChannelBuffer AytPreface = new HeapChannelBuffer(new byte[]{(byte) 0xff, (byte) 0xf6});\n@@ -46,7 +46,7 @@ public Result detect(ChannelBuffer in) {\n             return Result.UNRECOGNIZED;\n         }\n         Result resCommand = commandDetect(in);\n-        if (resCommand.equals(Result.RECOGNIZED)){\n+        if (resCommand.equals(Result.RECOGNIZED)) {\n             return resCommand;\n         }\n         Result resAyt = telnetAytDetect(in);\n@@ -62,14 +62,19 @@ public Result detect(ChannelBuffer in) {\n     private Result commandDetect(ChannelBuffer in) {\n         // detect if remote channel send a qos command to server\n         ChannelBuffer back = in.copy();\n-        byte[] backBytes = new byte[back.readableBytes()];\n-        back.getBytes(back.readerIndex(), backBytes);\n+        byte[] backBytes;\n+        try {\n+            backBytes = new byte[back.readableBytes()];\n+            back.getBytes(back.readerIndex(), backBytes);\n+        } finally {\n+            back.release();\n+        }\n         String s = new String(backBytes, CharsetUtil.UTF_8);\n         // trim /r/n to let parser work for input\n         s = s.trim();\n         CommandContext commandContext = TelnetCommandDecoder.decode(s);\n-        if(frameworkModel.getExtensionLoader(BaseCommand.class).hasExtension(commandContext.getCommandName())){\n+        if (frameworkModel.getExtensionLoader(BaseCommand.class).hasExtension(commandContext.getCommandName())) {\n             return Result.RECOGNIZED;\n         }\n         return Result.UNRECOGNIZED;\n@@ -79,10 +84,10 @@ private Result telnetAytDetect(ChannelBuffer in) {\n         // detect if remote channel send a telnet ayt command to server\n         int prefaceLen = AytPreface.readableBytes();\n         int bytesRead = min(in.readableBytes(), prefaceLen);\n-        if(bytesRead == 0 || !ChannelBuffers.prefixEquals(in, AytPreface, bytesRead)) {\n+        if (bytesRead == 0 || !ChannelBuffers.prefixEquals(in, AytPreface, bytesRead)) {\n             return Result.UNRECOGNIZED;\n         }\n-        if(bytesRead == prefaceLen) {\n+        if (bytesRead == prefaceLen) {\n             // we need to consume preface because it's not a qos command\n             // consume and remember to mark, pu server handler reset reader index\n             in.readBytes(AytPreface.readableBytes());\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBuffer.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBuffer.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBuffer.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBuffer.java\n@@ -948,4 +948,12 @@ public interface ChannelBuffer extends Comparable<ChannelBuffer> {\n      *                                       array\n      */\n     int arrayOffset();\n+\n+    /**\n+     * If this buffer is backed by an NIO direct buffer,\n+     * in some scenarios it may be necessary to manually release.\n+     */\n+    default void release() {\n+\n+    }\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/DynamicChannelBuffer.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/DynamicChannelBuffer.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/DynamicChannelBuffer.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/DynamicChannelBuffer.java\n@@ -200,4 +200,9 @@ public boolean hasArray() {\n     public int arrayOffset() {\n         return buffer.arrayOffset();\n     }\n+\n+    @Override\n+    public void release() {\n+        buffer.release();\n+    }\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java\n@@ -22,6 +22,7 @@\n import org.apache.dubbo.remoting.buffer.ChannelBuffers;\n import io.netty.buffer.ByteBuf;\n+import io.netty.util.ReferenceCountUtil;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -447,4 +448,9 @@ public void writerIndex(int writerIndex) {\n     public int compareTo(ChannelBuffer o) {\n         return ChannelBuffers.compare(this, o);\n     }\n+\n+    @Override\n+    public void release() {\n+        ReferenceCountUtil.safeRelease(buffer);\n+    }\n }",
    "output": "Fix issue 11708"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.ArrayUtils;\n import org.apache.dubbo.common.utils.Assert;\n import org.apache.dubbo.common.utils.ClassUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n@@ -413,8 +414,22 @@ public String registerReferenceBean(String propertyName, Class<?> injectedType,\n         }\n         //check bean definition\n-        if (beanDefinitionRegistry.containsBeanDefinition(referenceBeanName)) {\n-            BeanDefinition prevBeanDefinition = beanDefinitionRegistry.getBeanDefinition(referenceBeanName);\n+        boolean isContains;\n+        if ((isContains = beanDefinitionRegistry.containsBeanDefinition(referenceBeanName)) || beanDefinitionRegistry.isAlias(referenceBeanName)) {\n+            String preReferenceBeanName = referenceBeanName;\n+            if (!isContains){\n+                // Look in the alias for the origin bean name\n+                String[] aliases = beanDefinitionRegistry.getAliases(referenceBeanName);\n+                if (ArrayUtils.isNotEmpty(aliases)) {\n+                    for (String alias : aliases) {\n+                        if (beanDefinitionRegistry.containsBeanDefinition(alias)) {\n+                            preReferenceBeanName = alias;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            BeanDefinition prevBeanDefinition = beanDefinitionRegistry.getBeanDefinition(preReferenceBeanName);\n             String prevBeanType = prevBeanDefinition.getBeanClassName();\n             String prevBeanDesc = referenceBeanName + \"[\" + prevBeanType + \"]\";\n             String newBeanDesc = referenceBeanName + \"[\" + referenceKey + \"]\";\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessorTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessorTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessorTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessorTest.java\n@@ -128,15 +128,30 @@ public Object aroundHelloService(ProceedingJoinPoint pjp) throws Throwable {\n     @DubboReference(version = \"2\", url = \"dubbo://127.0.0.1:12345?version=2\", tag = \"demo_tag\")\n     private HelloService helloService2;\n-    // #7 ReferenceBean (Method Injection #3)\n+    // #7 ReferenceBean (Field Injection #5)\n+    // The HelloService is the same as above service(#6 ReferenceBean (Field Injection #4)), helloService3 will be registered as an alias of helloService2\n+    @DubboReference(version = \"2\", url = \"dubbo://127.0.0.1:12345?version=2\", tag = \"demo_tag\")\n+    private HelloService helloService3;\n+\n+    // #8 ReferenceBean (Method Injection #3)\n     @DubboReference(version = \"3\", url = \"dubbo://127.0.0.1:12345?version=2\", tag = \"demo_tag\")\n     public void setHelloService2(HelloService helloService2) {\n         // The helloService2 beanName is the same as above(#6 ReferenceBean (Field Injection #4)), and this will rename to helloService2#2\n         renamedHelloService2 = helloService2;\n     }\n+    // #9 ReferenceBean (Method Injection #4)\n+    @DubboReference(version = \"4\", url = \"dubbo://127.0.0.1:12345?version=2\")\n+    public void setHelloService3(DemoService helloService3){\n+        // The helloService3 beanName is the same as above(#7 ReferenceBean (Field Injection #5) is an alias),\n+        // The current beanName(helloService3) is not registered in the beanDefinitionMap, but it is already an alias. so this will rename to helloService3#2\n+        this.renamedHelloService3 = helloService3;\n+    }\n+\n     private HelloService renamedHelloService2;\n+    private DemoService renamedHelloService3;\n+\n     @Test\n     void testAop() throws Exception {\n@@ -150,7 +165,7 @@ void testAop() throws Exception {\n         Assertions.assertNotNull(testBean.getDemoServiceFromParent());\n         Assertions.assertNotNull(testBean.getDemoService());\n         Assertions.assertNotNull(testBean.myDemoService);\n-        Assertions.assertEquals(2, demoServicesMap.size());\n+        Assertions.assertEquals(3, demoServicesMap.size());\n         Assertions.assertNotNull(context.getBean(\"demoServiceImpl\"));\n         Assertions.assertNotNull(context.getBean(\"myDemoService\"));\n@@ -189,12 +204,13 @@ void testGetInjectedFieldReferenceBeanMap() {\n         Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> referenceBeanMap =\n                 beanPostProcessor.getInjectedFieldReferenceBeanMap();\n-        Assertions.assertEquals(4, referenceBeanMap.size());\n+        Assertions.assertEquals(5, referenceBeanMap.size());\n         Map<String, Integer> checkingFieldNames = new HashMap<>();\n         checkingFieldNames.put(\"private org.apache.dubbo.config.spring.api.HelloService org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessorTest$MyConfiguration.helloService\", 0);\n         checkingFieldNames.put(\"private org.apache.dubbo.config.spring.api.HelloService org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessorTest.helloService\", 0);\n         checkingFieldNames.put(\"private org.apache.dubbo.config.spring.api.HelloService org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessorTest.helloService2\", 0);\n+        checkingFieldNames.put(\"private org.apache.dubbo.config.spring.api.HelloService org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessorTest.helloService3\", 0);\n         checkingFieldNames.put(\"private org.apache.dubbo.config.spring.api.DemoService org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessorTest$ParentBean.demoServiceFromParent\", 0);\n         for (Map.Entry<InjectionMetadata.InjectedElement, ReferenceBean<?>> entry : referenceBeanMap.entrySet()) {\n@@ -222,12 +238,13 @@ void testGetInjectedMethodReferenceBeanMap() {\n         Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> referenceBeanMap =\n                 beanPostProcessor.getInjectedMethodReferenceBeanMap();\n-        Assertions.assertEquals(3, referenceBeanMap.size());\n+        Assertions.assertEquals(4, referenceBeanMap.size());\n         Map<String, Integer> checkingMethodNames = new HashMap<>();\n         checkingMethodNames.put(\"setDemoServiceFromAncestor\", 0);\n         checkingMethodNames.put(\"setDemoService\", 0);\n         checkingMethodNames.put(\"setHelloService2\", 0);\n+        checkingMethodNames.put(\"setHelloService3\", 0);\n         for (Map.Entry<InjectionMetadata.InjectedElement, ReferenceBean<?>> entry : referenceBeanMap.entrySet()) {\n@@ -252,7 +269,7 @@ void testReferenceBeansMethodAnnotation() {\n         Collection<ReferenceBean> referenceBeans = referenceBeanManager.getReferences();\n-        Assertions.assertEquals(4, referenceBeans.size());\n+        Assertions.assertEquals(5, referenceBeans.size());\n         for (ReferenceBean referenceBean : referenceBeans) {\n             ReferenceConfig referenceConfig = referenceBean.getReferenceConfig();\n@@ -350,4 +367,4 @@ public TestBean testBean() {\n         }\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Fix reference bean name conflicts * fix reference bean name conflicts * add ut case"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/observation/ObservationReceiverFilter.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/observation/ObservationReceiverFilter.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/observation/ObservationReceiverFilter.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/observation/ObservationReceiverFilter.java\n@@ -18,6 +18,7 @@\n import io.micrometer.observation.Observation;\n import io.micrometer.observation.ObservationRegistry;\n+\n import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.metrics.filter.observation.DefaultDubboServerObservationConvention;\n import org.apache.dubbo.metrics.filter.observation.DubboObservation;\n@@ -37,7 +38,7 @@\n /**\n  * A {@link Filter} that creates an {@link Observation} around the incoming message.\n  */\n-@Activate(group = PROVIDER, order = -1,onClass = \"io.micrometer.observation.NoopObservationRegistry\")\n+@Activate(group = PROVIDER, order = -1, onClass = \"io.micrometer.observation.NoopObservationRegistry\")\n public class ObservationReceiverFilter implements Filter, BaseFilter.Listener, ScopeModelAware {\n     private final ObservationRegistry observationRegistry;\ndiff --git a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/observation/ObservationSenderFilter.java b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/observation/ObservationSenderFilter.java\n--- a/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/observation/ObservationSenderFilter.java\n+++ b/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/observation/ObservationSenderFilter.java\n@@ -18,6 +18,7 @@\n import io.micrometer.observation.Observation;\n import io.micrometer.observation.ObservationRegistry;\n+\n import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.metrics.filter.observation.DefaultDubboClientObservationConvention;\n import org.apache.dubbo.metrics.filter.observation.DubboClientContext;\n@@ -38,7 +39,7 @@\n /**\n  * A {@link Filter} that creates an {@link Observation} around the outgoing message.\n  */\n-@Activate(group = CONSUMER, order = -1,onClass = \"io.micrometer.observation.NoopObservationRegistry\")\n+@Activate(group = CONSUMER, order = -1, onClass = \"io.micrometer.observation.NoopObservationRegistry\")\n public class ObservationSenderFilter implements ClusterFilter, BaseFilter.Listener, ScopeModelAware {\n     private final ObservationRegistry observationRegistry;",
    "output": "Fix observation spi config * fix: fix observation spi config * fix: fix ObservationFilter style"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n@@ -360,6 +360,7 @@ private static class WrapRequestPack implements Pack {\n         private final String serialize;\n         private final MultipleSerialization multipleSerialization;\n         private final String[] argumentsType;\n+        private final Class<?>[] actualRequestTypes;\n         private final URL url;\n         private final boolean singleArgument;\n@@ -371,6 +372,7 @@ private WrapRequestPack(MultipleSerialization multipleSerialization,\n             this.url = url;\n             this.serialize = convertHessianToWrapper(serialize);\n             this.multipleSerialization = multipleSerialization;\n+            this.actualRequestTypes = actualRequestTypes;\n             this.argumentsType = Stream.of(actualRequestTypes).map(Class::getName).toArray(String[]::new);\n             this.singleArgument = singleArgument;\n         }\n@@ -388,9 +390,10 @@ public byte[] pack(Object obj) throws IOException {\n             for (String type : argumentsType) {\n                 builder.addArgTypes(type);\n             }\n-            for (Object argument : arguments) {\n+            for (int i = 0; i < arguments.length; i++) {\n+                Object argument = arguments[i];\n                 ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-                multipleSerialization.serialize(url, serialize, argument.getClass(), argument, bos);\n+                multipleSerialization.serialize(url, serialize, actualRequestTypes[i], argument, bos);\n                 builder.addArgs(bos.toByteArray());\n             }\n             return builder.build().toByteArray();",
    "output": "Fix tri wrapper pack npe"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2FrameCodecBuilder.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2FrameCodecBuilder.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2FrameCodecBuilder.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2FrameCodecBuilder.java\n@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.rpc.protocol.tri;\n+\n+import io.netty.handler.codec.http2.DefaultHttp2Connection;\n+import io.netty.handler.codec.http2.Http2CodecUtil;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2LocalFlowController;\n+import io.netty.handler.codec.http2.Http2RemoteFlowController;\n+import org.apache.dubbo.common.utils.Assert;\n+\n+import java.util.function.Consumer;\n+\n+public class TripleHttp2FrameCodecBuilder extends Http2FrameCodecBuilder {\n+\n+    TripleHttp2FrameCodecBuilder(Http2Connection connection) {\n+        connection(connection);\n+    }\n+\n+    public static TripleHttp2FrameCodecBuilder fromConnection(Http2Connection connection) {\n+        return new TripleHttp2FrameCodecBuilder(connection);\n+    }\n+\n+    public static TripleHttp2FrameCodecBuilder forClient() {\n+        return forClient(Http2CodecUtil.SMALLEST_MAX_CONCURRENT_STREAMS);\n+    }\n+\n+    public static TripleHttp2FrameCodecBuilder forClient(int maxReservedStreams) {\n+        return fromConnection(new DefaultHttp2Connection(false, maxReservedStreams));\n+    }\n+\n+    public static TripleHttp2FrameCodecBuilder forServer() {\n+        return forServer(Http2CodecUtil.SMALLEST_MAX_CONCURRENT_STREAMS);\n+    }\n+\n+    public static TripleHttp2FrameCodecBuilder forServer(int maxReservedStreams) {\n+        return fromConnection(new DefaultHttp2Connection(true, maxReservedStreams));\n+    }\n+\n+    public TripleHttp2FrameCodecBuilder customizeConnection(Consumer<Http2Connection> connectionCustomizer) {\n+        Http2Connection connection = this.connection();\n+        Assert.notNull(connection, \"connection cannot be null.\");\n+        connectionCustomizer.accept(connection);\n+        return this;\n+    }\n+\n+    public TripleHttp2FrameCodecBuilder remoteFlowController(Http2RemoteFlowController remoteFlowController) {\n+        return this.customizeConnection((connection) -> connection.remote().flowController(remoteFlowController));\n+    }\n+\n+    public TripleHttp2FrameCodecBuilder localFlowController(Http2LocalFlowController localFlowController) {\n+        return this.customizeConnection((connection) -> connection.local().flowController(localFlowController));\n+    }\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -43,7 +43,6 @@\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelPipeline;\n import io.netty.handler.codec.http2.Http2FrameCodec;\n-import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n import io.netty.handler.codec.http2.Http2FrameLogger;\n import io.netty.handler.codec.http2.Http2MultiplexHandler;\n import io.netty.handler.codec.http2.Http2Settings;\n@@ -113,7 +112,8 @@ public void configServerProtocolHandler(URL url, ChannelOperator operator) {\n         } else {\n             headFilters = Collections.emptyList();\n         }\n-        final Http2FrameCodec codec = Http2FrameCodecBuilder.forServer()\n+        final Http2FrameCodec codec = TripleHttp2FrameCodecBuilder.forServer()\n+            .customizeConnection((connection) -> connection.remote().flowController(new TriHttp2RemoteFlowController(connection, url.getOrDefaultApplicationModel())))\n             .gracefulShutdownTimeoutMillis(10000)\n             .initialSettings(new Http2Settings().headerTableSize(\n                     config.getInt(H2_SETTINGS_HEADER_TABLE_SIZE_KEY, DEFAULT_SETTING_HEADER_LIST_SIZE))\n@@ -127,7 +127,6 @@ public void configServerProtocolHandler(URL url, ChannelOperator operator) {\n             .frameLogger(SERVER_LOGGER)\n             .build();\n         ExecutorSupport executorSupport = ExecutorRepository.getInstance(url.getOrDefaultApplicationModel()).getExecutorSupport(url);\n-        codec.connection().remote().flowController(new TriHttp2RemoteFlowController(codec.connection(), url.getOrDefaultApplicationModel()));\n         codec.connection().local().flowController().frameWriter(codec.encoder().frameWriter());\n         TripleWriteQueue writeQueue = new TripleWriteQueue();\n         final Http2MultiplexHandler handler = new Http2MultiplexHandler(\n@@ -152,7 +151,8 @@ protected void initChannel(Http2StreamChannel ch) {\n     @Override\n     public void configClientPipeline(URL url, ChannelOperator operator, ContextOperator contextOperator) {\n-        final Http2FrameCodec codec = Http2FrameCodecBuilder.forClient()\n+        final Http2FrameCodec codec = TripleHttp2FrameCodecBuilder.forClient()\n+            .customizeConnection((connection) -> connection.remote().flowController(new TriHttp2RemoteFlowController(connection, url.getOrDefaultApplicationModel())))\n             .gracefulShutdownTimeoutMillis(10000)\n             .initialSettings(new Http2Settings().headerTableSize(\n                     config.getInt(H2_SETTINGS_HEADER_TABLE_SIZE_KEY, DEFAULT_SETTING_HEADER_LIST_SIZE))\n@@ -166,7 +166,6 @@ public void configClientPipeline(URL url, ChannelOperator operator, ContextOpera\n                     DEFAULT_MAX_HEADER_LIST_SIZE)))\n             .frameLogger(CLIENT_LOGGER)\n             .build();\n-        codec.connection().remote().flowController(new TriHttp2RemoteFlowController(codec.connection(), url.getOrDefaultApplicationModel()));\n         codec.connection().local().flowController().frameWriter(codec.encoder().frameWriter());\n         final Http2MultiplexHandler handler = new Http2MultiplexHandler(\n             new TripleClientHandler(frameworkModel));",
    "output": "Remove duplicate flowcontroller listener * remove duplicate flowcontroller listener * remove duplicate flowcontroller listener"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n@@ -16,12 +16,6 @@\n  */\n package org.apache.dubbo.registry.client.metadata;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ThreadLocalRandom;\n-\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.config.ConfigurationUtils;\n import org.apache.dubbo.common.config.configcenter.ConfigItem;\n@@ -37,6 +31,12 @@\n import org.apache.dubbo.registry.client.RegistryClusterIdentifier;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SEPARATOR;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_PROPERTY_TYPE_MISMATCH;\n@@ -92,17 +92,23 @@ public boolean map(URL url) {\n                     continue;\n                 }\n-                boolean succeeded;\n+                boolean succeeded = false;\n                 int currentRetryTimes = 1;\n                 String newConfigContent = appName;\n                 do {\n                     ConfigItem configItem = metadataReport.getConfigItem(serviceInterface, DEFAULT_MAPPING_GROUP);\n                     String oldConfigContent = configItem.getContent();\n                     if (StringUtils.isNotEmpty(oldConfigContent)) {\n-                        boolean contains = StringUtils.isContains(oldConfigContent, appName);\n-                        if (contains) {\n-                            // From the user's perspective, it means successful when the oldConfigContent has contained the current appName. So we should not throw an Exception to user, it will confuse the user.\n-                            succeeded = true;\n+                        String[] oldAppNames = oldConfigContent.split(\",\");\n+                        if (oldAppNames.length > 0) {\n+                            for (String oldAppName : oldAppNames) {\n+                                if (oldAppName.equals(appName)) {\n+                                    succeeded = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        if (succeeded) {\n                             break;\n                         }\n                         newConfigContent = oldConfigContent + COMMA_SEPARATOR + appName;\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n@@ -143,7 +143,7 @@ private void doSendMessage(Object message) {\n         final byte[] data;\n         try {\n             data = packableMethod.packResponse(message);\n-        } catch (Throwable e) {\n+        } catch (Exception e) {\n             close(TriRpcStatus.INTERNAL.withDescription(\"Serialize response failed\")\n                 .withCause(e), null);\n             LOGGER.error(PROTOCOL_FAILED_SERIALIZE_TRIPLE,\"\",\"\",String.format(\"Serialize triple response failed, service=%s method=%s\",\n@@ -188,12 +188,12 @@ public final void onMessage(byte[] message) {\n         try {\n             Object instance = parseSingleMessage(message);\n             listener.onMessage(instance);\n-        } catch (Throwable t) {\n+        } catch (Exception e) {\n             final TriRpcStatus status = TriRpcStatus.UNKNOWN.withDescription(\"Server error\")\n-                .withCause(t);\n+                .withCause(e);\n             close(status, null);\n             LOGGER.error(PROTOCOL_FAILED_REQUEST,\"\",\"\",\"Process request failed. service=\" + serviceName +\n-                \" method=\" + methodName, t);\n+                \" method=\" + methodName, e);\n         } finally {\n             ClassLoadUtil.switchContextLoader(tccl);\n         }\n@@ -391,10 +391,10 @@ protected ServerCall.Listener startInternalCall(\n                     throw new IllegalStateException(\"Can not reach here\");\n             }\n             return listener;\n-        } catch (Throwable t) {\n-            LOGGER.error(PROTOCOL_FAILED_CREATE_STREAM_TRIPLE, \"\", \"\", \"Create triple stream failed\", t);\n+        } catch (Exception e) {\n+            LOGGER.error(PROTOCOL_FAILED_CREATE_STREAM_TRIPLE, \"\", \"\", \"Create triple stream failed\", e);\n             responseErr(TriRpcStatus.INTERNAL.withDescription(\"Create stream failed\")\n-                .withCause(t));\n+                .withCause(e));\n         }\n         return null;\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java\n@@ -85,8 +85,8 @@ public void invoke() {\n                 }\n                 onReturn(r.getValue());\n             });\n-        } catch (Throwable t) {\n-            responseObserver.onError(t);\n+        } catch (Exception e) {\n+            responseObserver.onError(e);\n         } finally {\n             RpcContext.removeCancellationContext();\n             RpcContext.removeContext();",
    "output": "Fix service name mapping check failed"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n@@ -31,7 +31,6 @@\n import org.apache.dubbo.config.ProviderConfig;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.ModuleModel;\n-import org.apache.dubbo.rpc.model.ServiceDescriptor;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -47,7 +46,6 @@\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_PROTOCOL;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_REFER_THREAD_NUM;\n import static org.apache.dubbo.common.constants.CommonConstants.EXECUTOR_SERVICE_COMPONENT_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.INTERNAL_EXECUTOR_SERVICE_COMPONENT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.THREADS_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.THREAD_NAME_KEY;\n@@ -122,18 +120,10 @@ public synchronized ExecutorService createExecutorIfAbsent(URL url) {\n      * @return\n      */\n     private String getExecutorKey(URL url) {\n-        String executorKey = INTERNAL_EXECUTOR_SERVICE_COMPONENT_KEY;\n-        ServiceDescriptor serviceDescriptor = applicationModel.getInternalModule().getServiceRepository().lookupService(url.getServiceInterface());\n-        // if not found in internal service repository, then it's biz service defined by user.\n-        if (serviceDescriptor == null) {\n-            executorKey = EXECUTOR_SERVICE_COMPONENT_KEY;\n-\n-        }\n-\n         if (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))) {\n-            executorKey = CONSUMER_SHARED_EXECUTOR_SERVICE_COMPONENT_KEY;\n+            return CONSUMER_SHARED_EXECUTOR_SERVICE_COMPONENT_KEY;\n         }\n-        return executorKey;\n+        return EXECUTOR_SERVICE_COMPONENT_KEY;\n     }\n     private ExecutorService createExecutor(URL url) {",
    "output": "Fix executor"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/DubboShutdownHookTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/DubboShutdownHookTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/DubboShutdownHookTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/DubboShutdownHookTest.java\n@@ -39,7 +39,7 @@ public class DubboShutdownHookTest {\n     public void init() {\n         SysProps.setProperty(CommonConstants.IGNORE_LISTEN_SHUTDOWN_HOOK, \"false\");\n         FrameworkModel frameworkModel = new FrameworkModel();\n-        applicationModel = new ApplicationModel(frameworkModel);\n+        applicationModel = frameworkModel.newApplication();\n         ModuleModel moduleModel = applicationModel.newModule();\n         dubboShutdownHook = new DubboShutdownHook(applicationModel);\n     }",
    "output": "Fix compile"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java\n@@ -220,7 +220,7 @@ public String getLocalMigrationRule() {\n     }\n     @Override\n-    public void refreshClassLoaders() {\n+    public synchronized void refreshClassLoaders() {\n         orderedPropertiesConfiguration.refresh();\n         applicationDelegate.refreshClassLoaders();\n     }",
    "output": "Fix synchronized in ModelEnvironment"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeSecurityConfigurator.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeSecurityConfigurator.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeSecurityConfigurator.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeSecurityConfigurator.java\n@@ -16,6 +16,14 @@\n  */\n package org.apache.dubbo.common.utils;\n+import org.apache.dubbo.common.constants.CommonConstants;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.config.ApplicationConfig;\n+import org.apache.dubbo.rpc.model.FrameworkModel;\n+import org.apache.dubbo.rpc.model.ModuleModel;\n+import org.apache.dubbo.rpc.model.ScopeClassLoaderListener;\n+\n import java.io.IOException;\n import java.lang.reflect.Field;\n import java.lang.reflect.GenericArrayType;\n@@ -32,14 +40,6 @@\n import java.util.Set;\n import java.util.stream.Collectors;\n-import org.apache.dubbo.common.constants.CommonConstants;\n-import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.config.ApplicationConfig;\n-import org.apache.dubbo.rpc.model.FrameworkModel;\n-import org.apache.dubbo.rpc.model.ModuleModel;\n-import org.apache.dubbo.rpc.model.ScopeClassLoaderListener;\n-\n import static org.apache.dubbo.common.constants.CommonConstants.CLASS_DESERIALIZE_ALLOWED_LIST;\n import static org.apache.dubbo.common.constants.CommonConstants.CLASS_DESERIALIZE_BLOCKED_LIST;\n import static org.apache.dubbo.common.constants.CommonConstants.CLASS_DESERIALIZE_BLOCK_ALL;\n@@ -185,8 +185,9 @@ public synchronized void registerInterface(Class<?> clazz) {\n             return;\n         }\n-        Set<Class<?>> markedClass = new HashSet<>();\n+        Set<Type> markedClass = new HashSet<>();\n         markedClass.add(clazz);\n+        checkClass(markedClass, clazz);\n         addToAllow(clazz.getName());\n@@ -221,10 +222,17 @@ public synchronized void registerInterface(Class<?> clazz) {\n         }\n     }\n-    private void checkType(Set<Class<?>> markedClass, Type type) {\n+    private void checkType(Set<Type> markedClass, Type type) {\n         if (type instanceof Class) {\n             checkClass(markedClass, (Class<?>) type);\n-        } else if (type instanceof ParameterizedType) {\n+            return;\n+        }\n+\n+        if (!markedClass.add(type)) {\n+            return;\n+        }\n+\n+        if (type instanceof ParameterizedType) {\n             ParameterizedType parameterizedType = (ParameterizedType) type;\n             checkClass(markedClass, (Class<?>) parameterizedType.getRawType());\n             for (Type actualTypeArgument : parameterizedType.getActualTypeArguments()) {\n@@ -249,13 +257,11 @@ private void checkType(Set<Class<?>> markedClass, Type type) {\n         }\n     }\n-    private void checkClass(Set<Class<?>> markedClass, Class<?> clazz) {\n-        if (markedClass.contains(clazz)) {\n+    private void checkClass(Set<Type> markedClass, Class<?> clazz) {\n+        if (!markedClass.add(clazz)) {\n             return;\n         }\n-        markedClass.add(clazz);\n-\n         addToAllow(clazz.getName());\n         Class<?>[] interfaces = clazz.getInterfaces();\ndiff --git a/dubbo-common/src/test/java/com/service/DemoService4.java b/dubbo-common/src/test/java/com/service/DemoService4.java\n--- a/dubbo-common/src/test/java/com/service/DemoService4.java\n+++ b/dubbo-common/src/test/java/com/service/DemoService4.java\n@@ -0,0 +1,27 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.service;\n+\n+public abstract class DemoService4<T, R, Param extends DemoService5<T, R, Param>> {\n+    public DemoService4() {\n+    }\n+\n+    public DemoService5<T, R, Param> getWrapper() {\n+        return null;\n+    }\n+\n+}\ndiff --git a/dubbo-common/src/test/java/com/service/DemoService5.java b/dubbo-common/src/test/java/com/service/DemoService5.java\n--- a/dubbo-common/src/test/java/com/service/DemoService5.java\n+++ b/dubbo-common/src/test/java/com/service/DemoService5.java\n@@ -0,0 +1,20 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.service;\n+\n+public abstract class DemoService5<T, R, Children extends DemoService5<T, R, Children>> {\n+}\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/SerializeSecurityConfiguratorTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/SerializeSecurityConfiguratorTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/SerializeSecurityConfiguratorTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/SerializeSecurityConfiguratorTest.java\n@@ -16,24 +16,25 @@\n  */\n package org.apache.dubbo.common.utils;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.Vector;\n-\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.config.ApplicationConfig;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ModuleModel;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n import com.service.DemoService1;\n import com.service.DemoService2;\n+import com.service.DemoService4;\n import com.service.deep1.deep2.deep3.DemoService3;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Vector;\n import static org.apache.dubbo.common.constants.CommonConstants.CLASS_DESERIALIZE_ALLOWED_LIST;\n import static org.apache.dubbo.common.constants.CommonConstants.CLASS_DESERIALIZE_BLOCKED_LIST;\n@@ -252,6 +253,22 @@ void testSerializable2() {\n     }\n+    @Test\n+    void testGeneric() {\n+        FrameworkModel frameworkModel = new FrameworkModel();\n+        ApplicationModel applicationModel = frameworkModel.newApplication();\n+        ModuleModel moduleModel = applicationModel.newModule();\n+\n+        SerializeSecurityManager ssm = frameworkModel.getBeanFactory().getBean(SerializeSecurityManager.class);\n+\n+        SerializeSecurityConfigurator serializeSecurityConfigurator = new SerializeSecurityConfigurator(moduleModel);\n+        serializeSecurityConfigurator.onAddClassLoader(moduleModel, Thread.currentThread().getContextClassLoader());\n+\n+        serializeSecurityConfigurator.registerInterface(DemoService4.class);\n+        Assertions.assertTrue(ssm.getAllowedPrefix().contains(\"com.service.DemoService4\"));\n+\n+        frameworkModel.destroy();\n+    }\n     @Test\n     void testRegister1() {\n         FrameworkModel frameworkModel = new FrameworkModel();",
    "output": "Fix stackoverflow in SerializeSecurityConfigurator * Fix stackoverflow in SerializeSecurityConfigurator * Fix uts"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2SerializerFactory.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.dubbo.common.serialize.hessian2;\n-import java.io.Serializable;\n-\n import org.apache.dubbo.common.utils.DefaultSerializeClassChecker;\n import com.alibaba.com.caucho.hessian.io.Deserializer;\n@@ -26,6 +24,8 @@\n import com.alibaba.com.caucho.hessian.io.Serializer;\n import com.alibaba.com.caucho.hessian.io.SerializerFactory;\n+import java.io.Serializable;\n+\n public class Hessian2SerializerFactory extends SerializerFactory {\n     private final DefaultSerializeClassChecker defaultSerializeClassChecker;\n@@ -44,9 +44,15 @@ protected Serializer getDefaultSerializer(Class cl) {\n         if (_defaultSerializer != null)\n             return _defaultSerializer;\n+        try {\n+            // pre-check if class is allow\n+            defaultSerializeClassChecker.loadClass(getClassLoader(), cl.getName());\n+        } catch (ClassNotFoundException e) {\n+            // ignore\n+        }\n+\n         if (!Serializable.class.isAssignableFrom(cl)\n-            && !isAllowNonSerializable()\n-            && !defaultSerializeClassChecker.isCheckSerializable()) {\n+            && (!isAllowNonSerializable() || !defaultSerializeClassChecker.isCheckSerializable())) {\n             throw new IllegalStateException(\"Serialized class \" + cl.getName() + \" must implement java.io.Serializable\");\n         }\n@@ -55,9 +61,15 @@ protected Serializer getDefaultSerializer(Class cl) {\n     @Override\n     protected Deserializer getDefaultDeserializer(Class cl) {\n+        try {\n+            // pre-check if class is allow\n+            defaultSerializeClassChecker.loadClass(getClassLoader(), cl.getName());\n+        } catch (ClassNotFoundException e) {\n+            // ignore\n+        }\n+\n         if (!Serializable.class.isAssignableFrom(cl)\n-            && !isAllowNonSerializable()\n-            && !defaultSerializeClassChecker.isCheckSerializable()) {\n+            && (!isAllowNonSerializable() || !defaultSerializeClassChecker.isCheckSerializable())) {\n             throw new IllegalStateException(\"Serialized class \" + cl.getName() + \" must implement java.io.Serializable\");\n         }",
    "output": "Fix hessian2 serializable check"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -16,6 +16,27 @@\n  */\n package org.apache.dubbo.config;\n+import java.beans.BeanInfo;\n+import java.beans.IntrospectionException;\n+import java.beans.Introspector;\n+import java.beans.MethodDescriptor;\n+import java.beans.PropertyDescriptor;\n+import java.io.Serializable;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.config.ConfigurationUtils;\n import org.apache.dubbo.common.config.Environment;\n@@ -39,27 +60,6 @@\n import org.apache.dubbo.rpc.model.ScopeModel;\n import org.apache.dubbo.rpc.model.ScopeModelUtil;\n-import java.beans.BeanInfo;\n-import java.beans.IntrospectionException;\n-import java.beans.Introspector;\n-import java.beans.MethodDescriptor;\n-import java.beans.PropertyDescriptor;\n-import java.io.Serializable;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_FAILED_OVERRIDE_FIELD;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_REFLECTIVE_OPERATION_FAILED;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_UNEXPECTED_EXCEPTION;\n@@ -606,7 +606,7 @@ public void overrideWithConfig(AbstractConfig newOne, boolean overrideAll) {\n                 try {\n                     String propertyName = extractPropertyName(method.getName());\n                     String getterName = calculatePropertyToGetter(propertyName);\n-                    getterMethod = this.getClass().getDeclaredMethod(getterName);\n+                    getterMethod = this.getClass().getMethod(getterName);\n                 } catch (Exception ignore) {\n                     continue;\n                 }\n@@ -734,13 +734,12 @@ private void assignProperties(Object obj, Environment environment, Map<String, S\n         // loop methods, get override value and set the new value back to method\n         List<Method> methods = MethodUtils.getMethods(obj.getClass(), method -> method.getDeclaringClass() != Object.class);\n-        Method[] methodsList = this.getClass().getDeclaredMethods();\n         for (Method method : methods) {\n             if (MethodUtils.isSetter(method)) {\n                 String propertyName = extractPropertyName(method.getName());\n                 // if config mode is OVERRIDE_IF_ABSENT and property has set, skip\n-                if (overrideIfAbsent && isPropertySet(methodsList, propertyName)) {\n+                if (overrideIfAbsent && isPropertySet(methods, propertyName)) {\n                     continue;\n                 }\n@@ -786,7 +785,7 @@ private void assignProperties(Object obj, Environment environment, Map<String, S\n                 Map<String, String> oldMap = null;\n                 try {\n                     String getterName = calculatePropertyToGetter(propertyName);\n-                    Method getterMethod = this.getClass().getDeclaredMethod(getterName);\n+                    Method getterMethod = this.getClass().getMethod(getterName);\n                     Object oldOne = getterMethod.invoke(this);\n                     if (oldOne instanceof Map) {\n                         oldMap = (Map) oldOne;\n@@ -827,7 +826,7 @@ private void assignProperties(Object obj, Environment environment, Map<String, S\n         }\n     }\n-    private boolean isPropertySet(Method[] methods, String propertyName) {\n+    private boolean isPropertySet(List<Method> methods, String propertyName) {\n         try {\n             String getterName = calculatePropertyToGetter(propertyName);\n             Method getterMethod = findGetMethod(methods, getterName);\n@@ -844,7 +843,7 @@ private boolean isPropertySet(Method[] methods, String propertyName) {\n         return false;\n     }\n-    private Method findGetMethod(Method[] methods, String methodName) {\n+    private Method findGetMethod(List<Method> methods, String methodName) {\n         for (Method method : methods) {\n             if (method.getName().equals(methodName) && method.getParameterCount() == 0) {\n                 return method;\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n@@ -539,6 +539,18 @@ void testMethodConfigWithInvalidArgumentIndex() {\n         });\n     }\n+    @Test\n+    void testOverride() {\n+        System.setProperty(\"dubbo.service.version\", \"TEST\");\n+        ServiceConfig<DemoService> serviceConfig = new ServiceConfig<>();\n+        serviceConfig.setInterface(DemoService.class);\n+        serviceConfig.setRef(new DemoServiceImpl());\n+        serviceConfig.setVersion(\"1.0.0\");\n+        serviceConfig.refresh();\n+        Assertions.assertEquals(\"1.0.0\", serviceConfig.getVersion());\n+        System.clearProperty(\"dubbo.service.version\");\n+    }\n+\n     @Test\n     void testMappingRetry() {\n         FrameworkModel frameworkModel = new FrameworkModel();",
    "output": "Fix config absent when refresh"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LFUCache.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LFUCache.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LFUCache.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LFUCache.java\n@@ -85,12 +85,12 @@ public V put(final K key, final V value) {\n                 freqTable[0].addLastNode(node);\n                 map.put(key, node);\n             } else {\n-                node = freqTable[0].addLast(key, value);\n-                map.put(key, node);\n                 curSize++;\n                 if (curSize > capacity) {\n                     proceedEviction();\n                 }\n+                node = freqTable[0].addLast(key, value);\n+                map.put(key, node);\n             }\n         } finally {\n             lock.unlock();",
    "output": "Fix the bug in LFUCache#put() method We should not adopt the scheme of \"first put new elements, then judge the capacity, and if it is full, trigger the proceedEviction() method\".Instead, we should adopt the scheme of \"first determine the capacity, then trigger the proceedEviction() method if it is full, and finally put in new elements\""
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -714,6 +714,7 @@ public void prepareInternalModule() {\n                 // wait for internal module startup\n                 try {\n                     future.get(5, TimeUnit.SECONDS);\n+                    hasPreparedInternalModule = true;\n                 } catch (Exception e) {\n                     logger.warn(CONFIG_FAILED_START_MODEL, \"\", \"\", \"wait for internal module startup failed: \" + e.getMessage(), e);\n                 }\n@@ -770,7 +771,7 @@ private DynamicConfiguration prepareEnvironment(ConfigCenterConfig configCenter)\n                 dynamicConfiguration = getDynamicConfiguration(configCenter.toUrl());\n             } catch (Exception e) {\n                 if (!configCenter.isCheck()) {\n-                    logger.warn(CONFIG_FAILED_INIT_CONFIG_CENTER, \"\", \"\",\"The configuration center failed to initialize\", e);\n+                    logger.warn(CONFIG_FAILED_INIT_CONFIG_CENTER, \"\", \"\", \"The configuration center failed to initialize\", e);\n                     configCenter.setInitialized(false);\n                     return null;\n                 } else {",
    "output": "Fix hasPreparedInternalModule is always false. * Fix hasPreparedInternalModule is always false. * Fix hasPreparedInternalModule is always false"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -909,23 +909,25 @@ public void unexport() {\n                 if (subscribeUrl != null) {\n                     Map<URL, Set<NotifyListener>> overrideListeners = getProviderConfigurationListener(subscribeUrl).getOverrideListeners();\n                     Set<NotifyListener> listeners = overrideListeners.get(subscribeUrl);\n-                    if (listeners.remove(notifyListener)) {\n-                        if (!registry.isServiceDiscovery()) {\n-                            registry.unsubscribe(subscribeUrl, notifyListener);\n-                        }\n-                        ApplicationModel applicationModel = getApplicationModel(registerUrl.getScopeModel());\n-                        if (applicationModel.getModelEnvironment().getConfiguration().convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)) {\n-                            for (ModuleModel moduleModel : applicationModel.getPubModuleModels()) {\n-                                if (moduleModel.getServiceRepository().getExportedServices().size() > 0) {\n-                                    moduleModel.getExtensionLoader(GovernanceRuleRepository.class).getDefaultExtension()\n-                                        .removeListener(subscribeUrl.getServiceKey() + CONFIGURATORS_SUFFIX,\n-                                            serviceConfigurationListeners.remove(subscribeUrl.getServiceKey()));\n+                    if(listeners != null){\n+                        if (listeners.remove(notifyListener)) {\n+                            if (!registry.isServiceDiscovery()) {\n+                                registry.unsubscribe(subscribeUrl, notifyListener);\n+                            }\n+                            ApplicationModel applicationModel = getApplicationModel(registerUrl.getScopeModel());\n+                            if (applicationModel.getModelEnvironment().getConfiguration().convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)) {\n+                                for (ModuleModel moduleModel : applicationModel.getPubModuleModels()) {\n+                                    if (moduleModel.getServiceRepository().getExportedServices().size() > 0) {\n+                                        moduleModel.getExtensionLoader(GovernanceRuleRepository.class).getDefaultExtension()\n+                                            .removeListener(subscribeUrl.getServiceKey() + CONFIGURATORS_SUFFIX,\n+                                                serviceConfigurationListeners.remove(subscribeUrl.getServiceKey()));\n+                                    }\n                                 }\n                             }\n                         }\n-                    }\n-                    if (listeners.isEmpty()) {\n-                        overrideListeners.remove(subscribeUrl);\n+                        if (listeners.isEmpty()) {\n+                            overrideListeners.remove(subscribeUrl);\n+                        }\n                     }\n                 }\n             } catch (Throwable t) {",
    "output": "Fix NPE when removing registry"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n@@ -24,6 +24,7 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;",
    "output": "Fix import"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n@@ -39,8 +39,8 @@\n import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SEPARATOR;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_PROPERTY_TYPE_MISMATCH;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_ADDRESS_INVALID;\n import static org.apache.dubbo.registry.Constants.CAS_RETRY_TIMES_KEY;\n import static org.apache.dubbo.registry.Constants.CAS_RETRY_WAIT_TIME_KEY;\n import static org.apache.dubbo.registry.Constants.DEFAULT_CAS_RETRY_TIMES;\n@@ -69,7 +69,7 @@ public MetadataServiceNameMapping(ApplicationModel applicationModel) {\n     @Override\n     public boolean map(URL url) {\n         if (CollectionUtils.isEmpty(applicationModel.getApplicationConfigManager().getMetadataConfigs())) {\n-            logger.warn(REGISTRY_ADDRESS_INVALID, \"\", \"\", \"No valid metadata config center found for mapping report.\");\n+            logger.warn(COMMON_PROPERTY_TYPE_MISMATCH, \"\", \"\", \"No valid metadata config center found for mapping report.\");\n             return false;\n         }\n         String serviceInterface = url.getServiceInterface();\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n@@ -16,6 +16,18 @@\n  */\n package org.apache.dubbo.registry.support;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.URLBuilder;\n import org.apache.dubbo.common.URLStrParser;\n@@ -34,18 +46,6 @@\n import org.apache.dubbo.registry.ProviderFirstParams;\n import org.apache.dubbo.rpc.model.ScopeModel;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.Semaphore;\n-import java.util.concurrent.TimeUnit;\n-\n import static org.apache.dubbo.common.URLStrParser.ENCODED_AND_MARK;\n import static org.apache.dubbo.common.URLStrParser.ENCODED_PID_KEY;\n import static org.apache.dubbo.common.URLStrParser.ENCODED_QUESTION_MARK;\n@@ -56,12 +56,11 @@\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO;\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_SEPARATOR;\n import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_SEPARATOR_ENCODED;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_ADDRESS_INVALID;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_PROPERTY_TYPE_MISMATCH;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_EMPTY_ADDRESS;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_FAILED_CLEAR_CACHED_URLS;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_FAILED_URL_EVICTING;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_PROPERTY_TYPE_MISMATCH;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_NO_PARAMETERS_URL;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_FAILED_CLEAR_CACHED_URLS;\n import static org.apache.dubbo.common.constants.RegistryConstants.CATEGORY_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.EMPTY_PROTOCOL;\n import static org.apache.dubbo.common.constants.RegistryConstants.ENABLE_EMPTY_PROTECTION_KEY;\n@@ -177,10 +176,6 @@ protected List<URL> toUrlsWithoutEmpty(URL consumer, Collection<String> provider\n                 // create DubboServiceAddress object using provider url, consumer url, and extra parameters.\n                 ServiceAddressURL cachedURL = createURL(rawProvider, copyOfConsumer, getExtraParameters());\n                 if (cachedURL == null) {\n-                    // 1-1: Address invalid.\n-                    logger.warn(REGISTRY_ADDRESS_INVALID, \"mismatch of service group and version settings\", \"\",\n-                        \"Invalid address, failed to parse into URL \" + rawProvider);\n-\n                     continue;\n                 }\n                 newURLs.put(rawProvider, cachedURL);\n@@ -193,9 +188,6 @@ protected List<URL> toUrlsWithoutEmpty(URL consumer, Collection<String> provider\n                 if (cachedURL == null) {\n                     cachedURL = createURL(rawProvider, copyOfConsumer, getExtraParameters());\n                     if (cachedURL == null) {\n-                        logger.warn(REGISTRY_ADDRESS_INVALID, \"mismatch of service group and version settings\", \"\",\n-                            \"Invalid address, failed to parse into URL \" + rawProvider);\n-\n                         continue;\n                     }\n                 }",
    "output": "Remove address invalid check * Remove address invalid check * change code"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n@@ -17,14 +17,6 @@\n package org.apache.dubbo.rpc.protocol.tri;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.lang.reflect.ParameterizedType;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.serialize.MultipleSerialization;\n@@ -37,6 +29,14 @@\n import com.google.protobuf.Message;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.lang.reflect.ParameterizedType;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n import static org.apache.dubbo.common.constants.CommonConstants.$ECHO;\n import static org.apache.dubbo.common.constants.CommonConstants.PROTOBUF_MESSAGE_CLASS_NAME;\n import static org.apache.dubbo.remoting.Constants.SERIALIZATION_KEY;\n@@ -75,7 +75,7 @@ public ReflectionPackableMethod(MethodDescriptor method, URL url, String seriali\n                 break;\n             case UNARY:\n                 actualRequestTypes = method.getParameterClasses();\n-                actualResponseType = method.getReturnClass();\n+                actualResponseType = (Class<?>) method.getReturnTypes()[0];\n                 break;\n             default:\n                 throw new IllegalStateException(\"Can not reach here\");\n@@ -478,7 +478,7 @@ private static Class<?> getClassFromCache(String className, Map<String, Class<?>\n         if (clz == null) {\n             try {\n                 clz = ClassUtils.forName(className);\n-            } catch (Throwable e) {\n+            } catch (Exception e) {\n                 // To catch IllegalStateException, LinkageError, ClassNotFoundException\n                 clz = expectedClass;\n             }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n@@ -174,6 +174,10 @@ private void doSendMessage(Object message) {\n     @Override\n     public final void onComplete() {\n+        if (listener == null) {\n+            // It will enter here when there is an error in the header\n+            return;\n+        }\n         listener.onComplete();\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DescriptorService.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DescriptorService.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DescriptorService.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DescriptorService.java\n@@ -18,8 +18,13 @@\n import org.apache.dubbo.common.stream.StreamObserver;\n+import java.util.concurrent.CompletableFuture;\n+\n public interface DescriptorService {\n+\n+    CompletableFuture<String> unaryFuture();\n+\n     void noParameterMethod();\n     /**\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethodTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethodTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethodTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethodTest.java\n@@ -27,6 +27,7 @@\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.util.concurrent.CompletableFuture;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -35,6 +36,16 @@\n import static org.junit.jupiter.api.Assertions.assertTrue;\n class ReflectionPackableMethodTest {\n+\n+\n+    @Test\n+    void testUnaryFuture() throws Exception {\n+        Method method = DescriptorService.class.getMethod(\"unaryFuture\");\n+        MethodDescriptor descriptor = new ReflectionMethodDescriptor(method);\n+        assertEquals(CompletableFuture.class, descriptor.getReturnClass());\n+        assertEquals(String.class, descriptor.getReturnTypes()[0]);\n+    }\n+\n     @Test\n     void testMethodWithNoParameters() throws Exception {\n         Method method = DescriptorService.class.getMethod(\"noParameterMethod\");\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionServerCallTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionServerCallTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionServerCallTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionServerCallTest.java\n@@ -20,7 +20,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n-import org.apache.dubbo.rpc.model.MethodDescriptor.RpcType;\n+import org.apache.dubbo.rpc.model.MethodDescriptor;\n import org.apache.dubbo.rpc.model.ProviderModel;\n import org.apache.dubbo.rpc.model.ReflectionMethodDescriptor;\n import org.apache.dubbo.rpc.model.ServiceDescriptor;\n@@ -46,8 +46,8 @@ void doStartCall() throws NoSuchMethodException {\n         Invoker<?> invoker = Mockito.mock(Invoker.class);\n         TripleServerStream serverStream = Mockito.mock(TripleServerStream.class);\n         ProviderModel providerModel = Mockito.mock(ProviderModel.class);\n-        ReflectionMethodDescriptor methodDescriptor = Mockito.mock(\n-            ReflectionMethodDescriptor.class);\n+        Method method = DescriptorService.class.getMethod(\"sayHello\", HelloReply.class);\n+        MethodDescriptor methodDescriptor = new ReflectionMethodDescriptor(method);\n         URL url = Mockito.mock(URL.class);\n         when(invoker.getUrl())\n             .thenReturn(url);\n@@ -68,19 +68,11 @@ void doStartCall() throws NoSuchMethodException {\n         }\n         ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n-        when(providerModel.getServiceModel())\n-            .thenReturn(serviceDescriptor);\n         when(serviceDescriptor.getMethods(anyString()))\n             .thenReturn(Collections.singletonList(methodDescriptor));\n-        when(methodDescriptor.getRpcType())\n-            .thenReturn(RpcType.UNARY);\n-        Method method = DescriptorService.class.getMethod(\"sayHello\", HelloReply.class);\n-        when(methodDescriptor.getMethod())\n-            .thenReturn(method);\n-        when(methodDescriptor.getParameterClasses())\n-            .thenReturn(method.getParameterTypes());\n-        when(methodDescriptor.getReturnClass())\n-            .thenAnswer(invocation -> method.getReturnType());\n+\n+        when(providerModel.getServiceModel())\n+            .thenReturn(serviceDescriptor);\n         ReflectionAbstractServerCall call2 = new ReflectionAbstractServerCall(invoker, serverStream,\n             new FrameworkModel(), \"\",",
    "output": "Fix tri future * fix tri return future * fix ut * fix npe * fix sonar"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DefaultSerializeClassChecker.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DefaultSerializeClassChecker.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DefaultSerializeClassChecker.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DefaultSerializeClassChecker.java\n@@ -117,7 +117,7 @@ public Class<?> loadClass(ClassLoader classLoader, String className) throws Clas\n     private Class<?> loadClass0(ClassLoader classLoader, String className) throws ClassNotFoundException {\n         if (checkStatus == SerializeCheckStatus.DISABLE) {\n-            return Class.forName(className, false, classLoader);\n+            return ClassUtils.forName(className, classLoader);\n         }\n         long hash = MAGIC_HASH_CODE;\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericImplFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericImplFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericImplFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericImplFilter.java\n@@ -16,13 +16,19 @@\n  */\n package org.apache.dubbo.rpc.filter;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+\n import org.apache.dubbo.common.beanutil.JavaBeanAccessor;\n import org.apache.dubbo.common.beanutil.JavaBeanDescriptor;\n import org.apache.dubbo.common.beanutil.JavaBeanSerializeUtil;\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.DefaultSerializeClassChecker;\n import org.apache.dubbo.common.utils.PojoUtils;\n import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.rpc.Constants;\n@@ -32,15 +38,11 @@\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.RpcInvocation;\n+import org.apache.dubbo.rpc.model.ModuleModel;\n import org.apache.dubbo.rpc.service.GenericService;\n import org.apache.dubbo.rpc.support.ProtocolUtils;\n import org.apache.dubbo.rpc.support.RpcUtils;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-\n import static org.apache.dubbo.common.constants.CommonConstants.$INVOKE;\n import static org.apache.dubbo.common.constants.CommonConstants.$INVOKE_ASYNC;\n import static org.apache.dubbo.common.constants.CommonConstants.GENERIC_PARAMETER_DESC;\n@@ -59,6 +61,12 @@ public class GenericImplFilter implements Filter, Filter.Listener {\n     private static final String GENERIC_IMPL_MARKER = \"GENERIC_IMPL\";\n+    private final ModuleModel moduleModel;\n+\n+    public GenericImplFilter(ModuleModel moduleModel) {\n+        this.moduleModel = moduleModel;\n+    }\n+\n     @Override\n     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n         String generic = invoker.getUrl().getParameter(GENERIC_KEY);\n@@ -172,7 +180,9 @@ public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invoca\n                 com.alibaba.dubbo.rpc.service.GenericException exception = (com.alibaba.dubbo.rpc.service.GenericException) appResponse.getException();\n                 try {\n                     String className = exception.getExceptionClass();\n-                    Class<?> clazz = ReflectUtils.forName(className);\n+                    DefaultSerializeClassChecker classChecker = moduleModel.getApplicationModel()\n+                        .getFrameworkModel().getBeanFactory().getBean(DefaultSerializeClassChecker.class);\n+                    Class<?> clazz = classChecker.loadClass(Thread.currentThread().getContextClassLoader(), className);\n                     Throwable targetException = null;\n                     Throwable lastException = null;\n                     try {\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericImplFilterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericImplFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericImplFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericImplFilterTest.java\n@@ -16,25 +16,26 @@\n  */\n package org.apache.dubbo.rpc.filter;\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.rpc.AppResponse;\n import org.apache.dubbo.rpc.AsyncRpcResult;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcInvocation;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.service.GenericService;\n import org.apache.dubbo.rpc.support.DemoService;\n import org.apache.dubbo.rpc.support.Person;\n-\n-import com.alibaba.dubbo.rpc.service.GenericException;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import org.mockito.Mockito;\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.Map;\n+import com.alibaba.dubbo.rpc.service.GenericException;\n import static org.apache.dubbo.common.constants.CommonConstants.$INVOKE;\n import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;\n@@ -43,7 +44,7 @@\n class GenericImplFilterTest {\n-    private GenericImplFilter genericImplFilter = new GenericImplFilter();\n+    private GenericImplFilter genericImplFilter = new GenericImplFilter(ApplicationModel.defaultModel().getDefaultModule());\n     @Test\n     void testInvoke() throws Exception {",
    "output": "Fix Class Check"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/DefaultSerializeClassCheckerTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/DefaultSerializeClassCheckerTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/DefaultSerializeClassCheckerTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/DefaultSerializeClassCheckerTest.java\n@@ -41,6 +41,7 @@ void tearDown() {\n     @Test\n     void testCommon() throws ClassNotFoundException {\n+        FrameworkModel.defaultModel().getBeanFactory().getBean(SerializeSecurityManager.class).setCheckStatus(SerializeCheckStatus.WARN);\n         DefaultSerializeClassChecker defaultSerializeClassChecker = DefaultSerializeClassChecker.getInstance();\n         for (int i = 0; i < 10; i++) {",
    "output": "Fix uts"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java\n@@ -16,15 +16,15 @@\n package org.apache.dubbo.common.threadpool.serial;\n-import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.threadlocal.InternalThreadLocal;\n-\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.Executor;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.threadlocal.InternalThreadLocalMap;\n+\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_ERROR_RUN_THREAD_TASK;\n /**\n@@ -97,13 +97,13 @@ public void run() {\n         Runnable r;\n         try {\n             while ((r = runQueue.poll()) != null) {\n+                InternalThreadLocalMap internalThreadLocalMap = InternalThreadLocalMap.getAndRemove();\n                 try {\n-                    InternalThreadLocal.removeAll();\n                     r.run();\n                 } catch (RuntimeException e) {\n                     LOGGER.error(COMMON_ERROR_RUN_THREAD_TASK, \"\", \"\", \"Exception while executing runnable \" + r, e);\n                 } finally {\n-                    InternalThreadLocal.removeAll();\n+                    InternalThreadLocalMap.set(internalThreadLocalMap);\n                 }\n             }\n         } finally {\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java\n@@ -18,7 +18,7 @@\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.threadlocal.InternalThreadLocal;\n+import org.apache.dubbo.common.threadlocal.InternalThreadLocalMap;\n import org.apache.dubbo.remoting.Channel;\n import org.apache.dubbo.remoting.ChannelHandler;\n@@ -55,51 +55,54 @@ public ChannelEventRunnable(Channel channel, ChannelHandler handler, ChannelStat\n     @Override\n     public void run() {\n-        InternalThreadLocal.removeAll();\n-        if (state == ChannelState.RECEIVED) {\n-            try {\n-                handler.received(channel, message);\n-            } catch (Exception e) {\n-                logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel\n-                    + \", message is \" + message, e);\n-            }\n-        } else {\n-            switch (state) {\n-                case CONNECTED:\n-                    try {\n-                        handler.connected(channel);\n-                    } catch (Exception e) {\n-                        logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel, e);\n-                    }\n-                    break;\n-                case DISCONNECTED:\n-                    try {\n-                        handler.disconnected(channel);\n-                    } catch (Exception e) {\n-                        logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel, e);\n-                    }\n-                    break;\n-                case SENT:\n-                    try {\n-                        handler.sent(channel, message);\n-                    } catch (Exception e) {\n-                        logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel\n-                            + \", message is \" + message, e);\n-                    }\n-                    break;\n-                case CAUGHT:\n-                    try {\n-                        handler.caught(channel, exception);\n-                    } catch (Exception e) {\n-                        logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel\n-                            + \", message is: \" + message + \", exception is \" + exception, e);\n-                    }\n-                    break;\n-                default:\n-                    logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"unknown state: \" + state + \", message is \" + message);\n+        InternalThreadLocalMap internalThreadLocalMap = InternalThreadLocalMap.getAndRemove();\n+        try {\n+            if (state == ChannelState.RECEIVED) {\n+                try {\n+                    handler.received(channel, message);\n+                } catch (Exception e) {\n+                    logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel\n+                        + \", message is \" + message, e);\n+                }\n+            } else {\n+                switch (state) {\n+                    case CONNECTED:\n+                        try {\n+                            handler.connected(channel);\n+                        } catch (Exception e) {\n+                            logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel, e);\n+                        }\n+                        break;\n+                    case DISCONNECTED:\n+                        try {\n+                            handler.disconnected(channel);\n+                        } catch (Exception e) {\n+                            logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel, e);\n+                        }\n+                        break;\n+                    case SENT:\n+                        try {\n+                            handler.sent(channel, message);\n+                        } catch (Exception e) {\n+                            logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel\n+                                + \", message is \" + message, e);\n+                        }\n+                        break;\n+                    case CAUGHT:\n+                        try {\n+                            handler.caught(channel, exception);\n+                        } catch (Exception e) {\n+                            logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel\n+                                + \", message is: \" + message + \", exception is \" + exception, e);\n+                        }\n+                        break;\n+                    default:\n+                        logger.warn(INTERNAL_ERROR, \"unknown error in remoting module\", \"\", \"unknown state: \" + state + \", message is \" + message);\n+                }\n             }\n+        } finally {\n+            InternalThreadLocalMap.set(internalThreadLocalMap);\n         }\n-        InternalThreadLocal.removeAll();\n     }\n     /**",
    "output": "Fix ThreadLocal Remove"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConcurrentHashMapUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConcurrentHashMapUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConcurrentHashMapUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConcurrentHashMapUtils.java\n@@ -26,24 +26,13 @@\n public class ConcurrentHashMapUtils {\n-    private static boolean IS_JAVA8;\n-\n-    static {\n-        try {\n-            IS_JAVA8 = System.getProperty(\"java.version\").startsWith(\"1.8.\");\n-        } catch (Exception ignore) {\n-            // exception is ignored\n-            IS_JAVA8 = true;\n-        }\n-    }\n-\n     /**\n      * A temporary workaround for Java 8 ConcurrentHashMap#computeIfAbsent specific performance issue: JDK-8161372.</br>\n      * @see <a href=\"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n      *\n      */\n     public static <K, V> V computeIfAbsent(ConcurrentMap<K, V> map, K key, Function<? super K, ? extends V> func) {\n-        if (IS_JAVA8) {\n+        if (JRE.JAVA_8.isCurrentVersion()) {\n             V v = map.get(key);\n             if (null == v) {\n                 v = map.computeIfAbsent(key, func);\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/JRE.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/JRE.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/JRE.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/JRE.java\n@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.common.utils;\n+\n+\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+\n+\n+/**\n+ * JRE version\n+ */\n+public enum JRE {\n+\n+    JAVA_8,\n+\n+    JAVA_9,\n+\n+    JAVA_10,\n+\n+    JAVA_11,\n+\n+    JAVA_12,\n+\n+    JAVA_13,\n+\n+    JAVA_14,\n+\n+    JAVA_15,\n+\n+    JAVA_16,\n+\n+    JAVA_17,\n+\n+    JAVA_18,\n+\n+    JAVA_19,\n+\n+    OTHER;\n+\n+    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(JRE.class);\n+\n+    private static final JRE VERSION = getJre();\n+\n+    /**\n+     * get current JRE version\n+     *\n+     * @return JRE version\n+     */\n+    public static JRE currentVersion() {\n+        return VERSION;\n+    }\n+\n+    /**\n+     * is current version\n+     *\n+     * @return true if current version\n+     */\n+    public boolean isCurrentVersion() {\n+        return this == VERSION;\n+    }\n+\n+    private static JRE getJre() {\n+        // get java version from system property\n+        String version = System.getProperty(\"java.version\");\n+        boolean isBlank = StringUtils.isBlank(version);\n+        if (isBlank) {\n+            logger.debug(\"java.version is blank\");\n+        }\n+        // if start with 1.8 return java 8\n+        if (!isBlank && version.startsWith(\"1.8\")) {\n+            return JAVA_8;\n+        }\n+        // if JRE version is 9 or above, we can get version from java.lang.Runtime.version()\n+        try {\n+            Object javaRunTimeVersion = MethodUtils.invokeMethod(Runtime.getRuntime(), \"version\");\n+            int majorVersion = MethodUtils.invokeMethod(javaRunTimeVersion, \"major\");\n+            switch (majorVersion) {\n+                case 9:\n+                    return JAVA_9;\n+                case 10:\n+                    return JAVA_10;\n+                case 11:\n+                    return JAVA_11;\n+                case 12:\n+                    return JAVA_12;\n+                case 13:\n+                    return JAVA_13;\n+                case 14:\n+                    return JAVA_14;\n+                case 15:\n+                    return JAVA_15;\n+                case 16:\n+                    return JAVA_16;\n+                case 17:\n+                    return JAVA_17;\n+                case 18:\n+                    return JAVA_18;\n+                case 19:\n+                    return JAVA_19;\n+                default:\n+                    return OTHER;\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"can't determine current JRE version, if JRE version is 8 but java.version is null\", e);\n+        }\n+        // default java 8\n+        return JAVA_8;\n+    }\n+\n+}\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/JRETest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/JRETest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/JRETest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/JRETest.java\n@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.common.utils;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+\n+class JRETest {\n+\n+    @Test\n+    @Disabled\n+    void blankSystemVersion() {\n+        System.setProperty(\"java.version\", \"\");\n+        JRE jre = JRE.currentVersion();\n+        Assertions.assertEquals(JRE.JAVA_8, jre);\n+    }\n+\n+    @Test\n+    @Disabled\n+    void java8Version() {\n+        JRE jre = JRE.currentVersion();\n+        Assertions.assertEquals(JRE.JAVA_8, jre);\n+    }\n+\n+    @Test\n+    @Disabled\n+    void java19Version() {\n+        JRE jre = JRE.currentVersion();\n+        Assertions.assertNotEquals(JRE.JAVA_19, jre);\n+    }\n+\n+}",
    "output": "Add JRE utils * Add JRE utils * Add JRE utils * Add license * Remove junit"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/cache/FileCacheStore.java b/dubbo-common/src/main/java/org/apache/dubbo/common/cache/FileCacheStore.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/cache/FileCacheStore.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/cache/FileCacheStore.java\n@@ -218,12 +218,12 @@ public static Empty getInstance(String cacheFilePath) {\n         }\n         @Override\n-        public Map<String, String> loadCache(int entrySize) throws IOException {\n+        public synchronized Map<String, String> loadCache(int entrySize) throws IOException {\n             return Collections.emptyMap();\n         }\n         @Override\n-        public void refreshCache(Map<String, String> properties, String comment, long maxFileSize) {\n+        public synchronized void refreshCache(Map<String, String> properties, String comment, long maxFileSize) {\n             // No-op.\n         }\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java\n@@ -94,13 +94,13 @@ public boolean markSupported() {\n             }\n             @Override\n-            public void mark(int readlimit) {\n+            public synchronized void mark(int readlimit) {\n                 is.mark(readlimit);\n                 mMark = mPosition;\n             }\n             @Override\n-            public void reset() throws IOException {\n+            public synchronized void reset() throws IOException {\n                 is.reset();\n                 mPosition = mMark;\n             }\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBufferInputStream.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBufferInputStream.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBufferInputStream.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBufferInputStream.java\n@@ -57,7 +57,7 @@ public int available() throws IOException {\n     }\n     @Override\n-    public void mark(int readLimit) {\n+    public synchronized void mark(int readLimit) {\n         buffer.markReaderIndex();\n     }\n@@ -87,7 +87,7 @@ public int read(byte[] b, int off, int len) throws IOException {\n     }\n     @Override\n-    public void reset() throws IOException {\n+    public synchronized void reset() throws IOException {\n         buffer.resetReaderIndex();\n     }",
    "output": "Make methods synchronized to match parent declaration"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/ChannelHandlerDispatcher.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/ChannelHandlerDispatcher.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/ChannelHandlerDispatcher.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/ChannelHandlerDispatcher.java\n@@ -24,7 +24,9 @@\n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.Objects;\n import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n@@ -41,12 +43,15 @@ public ChannelHandlerDispatcher() {\n     }\n     public ChannelHandlerDispatcher(ChannelHandler... handlers) {\n+        // if varargs is used, the type of handlers is ChannelHandler[] and it is not null\n+        // so we should filter the null object\n         this(handlers == null ? null : Arrays.asList(handlers));\n     }\n     public ChannelHandlerDispatcher(Collection<ChannelHandler> handlers) {\n         if (CollectionUtils.isNotEmpty(handlers)) {\n-            this.channelHandlers.addAll(handlers);\n+            // filter null object\n+            this.channelHandlers.addAll(handlers.stream().filter(Objects::nonNull).collect(Collectors.toSet()));\n         }\n     }\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/transport/ChannelHandlerDispatcherTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/transport/ChannelHandlerDispatcherTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/transport/ChannelHandlerDispatcherTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/transport/ChannelHandlerDispatcherTest.java\n@@ -19,12 +19,13 @@\n import org.apache.dubbo.remoting.Channel;\n import org.apache.dubbo.remoting.ChannelHandler;\n import org.apache.dubbo.remoting.RemotingException;\n-\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import org.mockito.Mockito;\n import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n class ChannelHandlerDispatcherTest {\n@@ -57,6 +58,23 @@ void test() {\n     }\n+    @Test\n+    void constructorNullObjectTest() {\n+        ChannelHandlerDispatcher channelHandlerDispatcher = new ChannelHandlerDispatcher(null, null);\n+        Assertions.assertEquals(0, channelHandlerDispatcher.getChannelHandlers().size());\n+        ChannelHandlerDispatcher channelHandlerDispatcher1 = new ChannelHandlerDispatcher((MockChannelHandler) null);\n+        Assertions.assertEquals(0, channelHandlerDispatcher1.getChannelHandlers().size());\n+        ChannelHandlerDispatcher channelHandlerDispatcher2 = new ChannelHandlerDispatcher(null, new MockChannelHandler());\n+        Assertions.assertEquals(1, channelHandlerDispatcher2.getChannelHandlers().size());\n+        ChannelHandlerDispatcher channelHandlerDispatcher3 = new ChannelHandlerDispatcher(Collections.singleton(new MockChannelHandler()));\n+        Assertions.assertEquals(1, channelHandlerDispatcher3.getChannelHandlers().size());\n+        Collection<ChannelHandler> mockChannelHandlers = new HashSet<>();\n+        mockChannelHandlers.add(new MockChannelHandler());\n+        mockChannelHandlers.add(null);\n+        ChannelHandlerDispatcher channelHandlerDispatcher4 = new ChannelHandlerDispatcher(mockChannelHandlers);\n+        Assertions.assertEquals(1, channelHandlerDispatcher4.getChannelHandlers().size());\n+    }\n+\n }\n class MockChannelHandler extends ChannelHandlerAdapter {",
    "output": "Fix channelHandlers has null object"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java\n@@ -140,7 +140,7 @@ public List<MetricSample> collect() {\n     private void collectRequests(List<MetricSample> list) {\n         doExecute(RequestEvent.Type.TOTAL, MetricsStatHandler::get).filter(e->!e.isEmpty())\n-            .ifPresent(map-> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_REQUESTS_TOTAL, k.getTags(), REQUESTS, v::get))));\n+            .ifPresent(map-> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_REQUESTS, k.getTags(), REQUESTS, v::get))));\n         doExecute(RequestEvent.Type.SUCCEED, MetricsStatHandler::get).filter(e->!e.isEmpty())\n             .ifPresent(map-> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_REQUESTS_SUCCEED, k.getTags(), REQUESTS, v::get))));\n@@ -171,7 +171,7 @@ private void collectRT(List<MetricSample> list) {\n         this.stats.getMaxRT().forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_RT_MAX, k.getTags(), RT, v::get)));\n         this.stats.getTotalRT().forEach((k, v) -> {\n-            list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_RT_TOTAL, k.getTags(), RT, v::get));\n+            list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_RT_SUM, k.getTags(), RT, v::get));\n             AtomicLong avg = this.stats.getAvgRT().get(k);\n             AtomicLong count = this.stats.getRtCount().get(k);\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/model/MetricsKey.java b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/model/MetricsKey.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/model/MetricsKey.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/model/MetricsKey.java\n@@ -20,10 +20,10 @@\n public enum MetricsKey {\n     // provider metrics key\n-    PROVIDER_METRIC_REQUESTS_TOTAL(\"dubbo.provider.requests.total\", \"Total Requests\"),\n-    PROVIDER_METRIC_REQUESTS_SUCCEED(\"dubbo.provider.requests.succeed\", \"Succeed Requests\"),\n-    PROVIDER_METRIC_REQUESTS_FAILED(\"dubbo.provider.requests.failed\", \"Failed Requests\"),\n-    PROVIDER_METRIC_REQUEST_BUSINESS_FAILED(\"dubbo.provider.requests.business.failed\",\"Failed Business Requests\"),\n+    PROVIDER_METRIC_REQUESTS(\"dubbo.provider.requests.total\", \"Total Requests\"),\n+    PROVIDER_METRIC_REQUESTS_SUCCEED(\"dubbo.provider.requests.succeed.total\", \"Succeed Requests\"),\n+    PROVIDER_METRIC_REQUESTS_FAILED(\"dubbo.provider.requests.failed.total\", \"Failed Requests\"),\n+    PROVIDER_METRIC_REQUEST_BUSINESS_FAILED(\"dubbo.provider.requests.business.failed.total\",\"Failed Business Requests\"),\n     PROVIDER_METRIC_REQUESTS_PROCESSING(\"dubbo.provider.requests.processing\", \"Processing Requests\"),\n     PROVIDER_METRIC_REQUESTS_TOTAL_AGG(\"dubbo.provider.requests.total.aggregate\", \"Aggregated Total Requests\"),\n@@ -33,14 +33,15 @@ public enum MetricsKey {\n     PROVIDER_METRIC_REQUESTS_TIMEOUT_AGG(\"dubbo.provider.requests.timeout.failed.aggregate\", \"Aggregated timeout Failed Requests\"),\n     PROVIDER_METRIC_REQUESTS_LIMIT_AGG(\"dubbo.provider.requests.limit.aggregate\", \"Aggregated limit Requests\"),\n     PROVIDER_METRIC_REQUESTS_TOTAL_FAILED_AGG(\"dubbo.provider.requests.failed.total.aggregate\", \"Aggregated failed total Requests\"),\n-    PROVIDER_METRIC_QPS(\"dubbo.provider.qps\", \"Query Per Seconds\"),\n-    PROVIDER_METRIC_RT_LAST(\"dubbo.provider.rt.last\", \"Last Response Time\"),\n-    PROVIDER_METRIC_RT_MIN(\"dubbo.provider.rt.min\", \"Min Response Time\"),\n-    PROVIDER_METRIC_RT_MAX(\"dubbo.provider.rt.max\", \"Max Response Time\"),\n-    PROVIDER_METRIC_RT_TOTAL(\"dubbo.provider.rt.total\", \"Total Response Time\"),\n-    PROVIDER_METRIC_RT_AVG(\"dubbo.provider.rt.avg\", \"Average Response Time\"),\n-    PROVIDER_METRIC_RT_P99(\"dubbo.provider.rt.p99\", \"Response Time P99\"),\n-    PROVIDER_METRIC_RT_P95(\"dubbo.provider.rt.p95\", \"Response Time P95\"),\n+\n+    PROVIDER_METRIC_QPS(\"dubbo.provider.qps.seconds\", \"Query Per Seconds\"),\n+    PROVIDER_METRIC_RT_LAST(\"dubbo.provider.rt.seconds.last\", \"Last Response Time\"),\n+    PROVIDER_METRIC_RT_MIN(\"dubbo.provider.rt.seconds.min\", \"Min Response Time\"),\n+    PROVIDER_METRIC_RT_MAX(\"dubbo.provider.rt.seconds.max\", \"Max Response Time\"),\n+    PROVIDER_METRIC_RT_SUM(\"dubbo.provider.rt.seconds.sum\", \"Sum Response Time\"),\n+    PROVIDER_METRIC_RT_AVG(\"dubbo.provider.rt.seconds.avg\", \"Average Response Time\"),\n+    PROVIDER_METRIC_RT_P99(\"dubbo.provider.rt.seconds.p99\", \"Response Time P99\"),\n+    PROVIDER_METRIC_RT_P95(\"dubbo.provider.rt.seconds.p95\", \"Response Time P95\"),\n     // consumer metrics key\n     ;\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollectorTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollectorTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollectorTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollectorTest.java\n@@ -129,7 +129,7 @@ void testRTMetrics() {\n         Assertions.assertEquals(sampleMap.get(MetricsKey.PROVIDER_METRIC_RT_MIN.getName()), 0L);\n         Assertions.assertEquals(sampleMap.get(MetricsKey.PROVIDER_METRIC_RT_MAX.getName()), 10L);\n         Assertions.assertEquals(sampleMap.get(MetricsKey.PROVIDER_METRIC_RT_AVG.getName()), 5L);\n-        Assertions.assertEquals(sampleMap.get(MetricsKey.PROVIDER_METRIC_RT_TOTAL.getName()), 10L);\n+        Assertions.assertEquals(sampleMap.get(MetricsKey.PROVIDER_METRIC_RT_SUM.getName()), 10L);\n     }\n     @Test",
    "output": "Change the name according to the naming convention"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java\n@@ -119,6 +119,12 @@ public void decreaseProcessingRequests(String interfaceName, String methodName,\n         });\n     }\n+    public void totalFailedRequests(String interfaceName, String methodName, String group, String version) {\n+        doExecute(RequestEvent.Type.TOTAL_FAILED,statHandler-> {\n+            statHandler.increase(interfaceName, methodName, group, version);\n+        });\n+    }\n+\n     public void addRT(String interfaceName, String methodName, String group, String version, Long responseTime) {\n         stats.addRT(interfaceName, methodName, group, version, responseTime);\n     }\n@@ -153,6 +159,10 @@ private void collectRequests(List<MetricSample> list) {\n         doExecute(RequestEvent.Type.REQUEST_LIMIT, MetricsStatHandler::get).filter(e->!e.isEmpty())\n             .ifPresent(map-> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_REQUESTS_LIMIT_AGG, k.getTags(), REQUESTS, v::get))));\n+\n+        doExecute(RequestEvent.Type.TOTAL_FAILED, MetricsStatHandler::get).filter(e->!e.isEmpty())\n+            .ifPresent(map-> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_REQUESTS_TOTAL_FAILED_AGG, k.getTags(), REQUESTS, v::get))));\n+\n     }\n     private void collectRT(List<MetricSample> list) {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/stat/MetricsStatComposite.java b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/stat/MetricsStatComposite.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/stat/MetricsStatComposite.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/stat/MetricsStatComposite.java\n@@ -142,6 +142,13 @@ public void doNotify(MethodMetric metric) {\n                 publishEvent(new RequestEvent(metric, RequestEvent.Type.REQUEST_TIMEOUT));\n             }\n         });\n+\n+        stats.put(RequestEvent.Type.TOTAL_FAILED, new DefaultMetricsStatHandler(applicationName) {\n+            @Override\n+            public void doNotify(MethodMetric metric) {\n+                publishEvent(new RequestEvent(metric, RequestEvent.Type.TOTAL_FAILED));\n+            }\n+        });\n     }\n     private void publishEvent(MetricsEvent event) {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/event/RequestEvent.java b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/event/RequestEvent.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/event/RequestEvent.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/event/RequestEvent.java\n@@ -43,6 +43,7 @@ public enum Type {\n         BUSINESS_FAILED,\n         REQUEST_TIMEOUT,\n         REQUEST_LIMIT,\n-        PROCESSING\n+        PROCESSING,\n+        TOTAL_FAILED\n     }\n }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/model/MetricsKey.java b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/model/MetricsKey.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/model/MetricsKey.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/model/MetricsKey.java\n@@ -32,7 +32,7 @@ public enum MetricsKey {\n     PROVIDER_METRIC_REQUESTS_BUSINESS_FAILED_AGG(\"dubbo.provider.requests.business.failed.aggregate\", \"Aggregated Business Failed Requests\"),\n     PROVIDER_METRIC_REQUESTS_TIMEOUT_AGG(\"dubbo.provider.requests.timeout.failed.aggregate\", \"Aggregated timeout Failed Requests\"),\n     PROVIDER_METRIC_REQUESTS_LIMIT_AGG(\"dubbo.provider.requests.limit.aggregate\", \"Aggregated limit Requests\"),\n-\n+    PROVIDER_METRIC_REQUESTS_TOTAL_FAILED_AGG(\"dubbo.provider.requests.failed.total.aggregate\", \"Aggregated failed total Requests\"),\n     PROVIDER_METRIC_QPS(\"dubbo.provider.qps\", \"Query Per Seconds\"),\n     PROVIDER_METRIC_RT_LAST(\"dubbo.provider.rt.last\", \"Last Response Time\"),\n     PROVIDER_METRIC_RT_MIN(\"dubbo.provider.rt.min\", \"Min Response Time\"),\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java\n@@ -57,6 +57,7 @@ public class AggregateMetricsCollector implements MetricsCollector, MetricsListe\n     private final Map<MethodMetric, TimeWindowCounter> businessFailedRequests = new ConcurrentHashMap<>();\n     private final Map<MethodMetric, TimeWindowCounter> timeoutRequests = new ConcurrentHashMap<>();\n     private final Map<MethodMetric, TimeWindowCounter> limitRequests = new ConcurrentHashMap<>();\n+    private final Map<MethodMetric, TimeWindowCounter> totalFailedRequests = new ConcurrentHashMap<>();\n     private final Map<MethodMetric, TimeWindowCounter> qps = new ConcurrentHashMap<>();\n     private final Map<MethodMetric, TimeWindowQuantile> rt = new ConcurrentHashMap<>();\n@@ -128,6 +129,10 @@ private void onRequestEvent(RequestEvent event) {\n                 counter = limitRequests.computeIfAbsent(metric, k -> new TimeWindowCounter(bucketNum, timeWindowSeconds));\n                 break;\n+            case TOTAL_FAILED:\n+                counter = totalFailedRequests.computeIfAbsent(metric, k -> new TimeWindowCounter(bucketNum, timeWindowSeconds));\n+                break;\n+\n             default:\n                 break;\n         }\n@@ -154,6 +159,8 @@ private void collectRequests(List<MetricSample> list) {\n         businessFailedRequests.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_REQUESTS_BUSINESS_FAILED_AGG, k.getTags(), REQUESTS, v::get)));\n         timeoutRequests.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_REQUESTS_TIMEOUT_AGG, k.getTags(), REQUESTS, v::get)));\n         limitRequests.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_REQUESTS_LIMIT_AGG, k.getTags(), REQUESTS, v::get)));\n+        totalFailedRequests.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.PROVIDER_METRIC_REQUESTS_TOTAL_FAILED_AGG, k.getTags(), REQUESTS, v::get)));\n+\n     }\n     private void collectQPS(List<MetricSample> list) {\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java\n@@ -82,6 +82,9 @@ public void throwExecute(Throwable throwable){\n                     collector.increaseFailedRequests(interfaceName, methodName, group, version);\n             }\n         }\n+\n+        collector.totalFailedRequests(interfaceName, methodName, group, version);\n+\n         endExecute(()-> throwable instanceof RpcException && ((RpcException) throwable).isBiz());\n     }\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java\n@@ -146,7 +146,7 @@ void testBusinessFailedRequests() {\n     @Test\n-    void testTimeoutRequests() {\n+    void testTimeoutAndFailedRequests() {\n         collector.setCollectEnabled(true);\n         given(invoker.invoke(invocation)).willThrow(new RpcException(RpcException.TIMEOUT_EXCEPTION));\n@@ -164,10 +164,13 @@ void testTimeoutRequests() {\n         }\n         Map<String, MetricSample> metricsMap = getMetricsMap();\n         Assertions.assertTrue(metricsMap.containsKey(MetricsKey.PROVIDER_METRIC_REQUESTS_TIMEOUT_AGG.getName()));\n+        Assertions.assertTrue(metricsMap.containsKey(MetricsKey.PROVIDER_METRIC_REQUESTS_TOTAL_FAILED_AGG.getName()));\n-        MetricSample sample = metricsMap.get(MetricsKey.PROVIDER_METRIC_REQUESTS_TIMEOUT_AGG.getName());\n+        MetricSample timeoutSample = metricsMap.get(MetricsKey.PROVIDER_METRIC_REQUESTS_TIMEOUT_AGG.getName());\n+        Assertions.assertSame(((GaugeMetricSample) timeoutSample).getSupplier().get().longValue(), count);\n-        Assertions.assertSame(((GaugeMetricSample) sample).getSupplier().get().longValue(), count);\n+        GaugeMetricSample failedSample = (GaugeMetricSample)metricsMap.get(MetricsKey.PROVIDER_METRIC_REQUESTS_TOTAL_FAILED_AGG.getName());\n+        Assertions.assertSame(failedSample.getSupplier().get().longValue(), count);\n     }\n     @Test",
    "output": "Add metrics for failed request total"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionAbstractServerCall.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionAbstractServerCall.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionAbstractServerCall.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionAbstractServerCall.java\n@@ -46,13 +46,13 @@ public class ReflectionAbstractServerCall extends AbstractServerCall {\n     private List<MethodDescriptor> methodDescriptors;\n     public ReflectionAbstractServerCall(Invoker<?> invoker,\n-        ServerStream serverStream,\n-        FrameworkModel frameworkModel,\n-        String acceptEncoding,\n-        String serviceName,\n-        String methodName,\n-        List<HeaderFilter> headerFilters,\n-        Executor executor) {\n+                                        ServerStream serverStream,\n+                                        FrameworkModel frameworkModel,\n+                                        String acceptEncoding,\n+                                        String serviceName,\n+                                        String methodName,\n+                                        List<HeaderFilter> headerFilters,\n+                                        Executor executor) {\n         super(invoker, serverStream, frameworkModel,\n             getServiceDescriptor(invoker.getUrl()),\n             acceptEncoding, serviceName, methodName,\n@@ -155,10 +155,8 @@ protected Object parseSingleMessage(byte[] data)\n         if (isClosed()) {\n             return null;\n         }\n-        if (serviceDescriptor != null) {\n-            ClassLoadUtil.switchContextLoader(\n-                serviceDescriptor.getServiceInterfaceClass().getClassLoader());\n-        }\n+        ClassLoadUtil.switchContextLoader(\n+            invoker.getUrl().getServiceModel().getClassLoader());\n         return packableMethod.getRequestUnpack().unpack(data);\n     }",
    "output": "Change class loader"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n@@ -309,8 +309,9 @@ public List<URL> lookup(URL url) {\n     protected void doUpdate(ServiceInstance oldServiceInstance, ServiceInstance newServiceInstance) {\n         this.doUnregister(oldServiceInstance);\n-        if (!EMPTY_REVISION.equals(getExportedServicesRevision(serviceInstance))) {\n-            this.serviceInstance = newServiceInstance;\n+        this.serviceInstance = newServiceInstance;\n+\n+        if (!EMPTY_REVISION.equals(getExportedServicesRevision(newServiceInstance))) {\n             reportMetadata(newServiceInstance.getServiceMetadata());\n             this.doRegister(newServiceInstance);\n         }",
    "output": "Fix instance revision check"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosConnectionManager.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosConnectionManager.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosConnectionManager.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosConnectionManager.java\n@@ -122,7 +122,7 @@ protected NamingService createNamingService() {\n         try {\n             for (int i = 0; i < retryTimes + 1; i++) {\n                 namingService = NacosFactory.createNamingService(nacosProperties);\n-                if (!check || UP.equals(namingService.getServerStatus())) {\n+                if (!check || (UP.equals(namingService.getServerStatus()) && testNamingService(namingService))) {\n                     break;\n                 } else {\n                     logger.warn(LoggerCodeConstants.REGISTRY_NACOS_EXCEPTION, \"\", \"\",\n@@ -152,6 +152,16 @@ protected NamingService createNamingService() {\n         return namingService;\n     }\n+    private boolean testNamingService(NamingService namingService) {\n+        try {\n+            namingService.getAllInstances(\"Dubbo-Nacos-Test\", false);\n+            return true;\n+        } catch (NacosException e) {\n+            return false;\n+        }\n+    }\n+\n+\n     private Properties buildNacosProperties(URL url) {\n         Properties properties = new Properties();\n         setServerAddr(url, properties);\ndiff --git a/dubbo-registry/dubbo-registry-nacos/src/test/java/org/apache/dubbo/registry/nacos/NacosConnectionsManagerTest.java b/dubbo-registry/dubbo-registry-nacos/src/test/java/org/apache/dubbo/registry/nacos/NacosConnectionsManagerTest.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/test/java/org/apache/dubbo/registry/nacos/NacosConnectionsManagerTest.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/test/java/org/apache/dubbo/registry/nacos/NacosConnectionsManagerTest.java\n@@ -32,6 +32,7 @@\n import com.alibaba.nacos.api.NacosFactory;\n import com.alibaba.nacos.api.exception.NacosException;\n import com.alibaba.nacos.api.naming.NamingService;\n+import com.alibaba.nacos.api.naming.pojo.Instance;\n import static com.alibaba.nacos.client.constant.Constants.HealthCheck.DOWN;\n import static com.alibaba.nacos.client.constant.Constants.HealthCheck.UP;\n@@ -133,4 +134,63 @@ public String getServerStatus() {\n             }\n         }\n     }\n+\n+    @Test\n+    void testDisable() {\n+        try (MockedStatic<NacosFactory> nacosFactoryMockedStatic = Mockito.mockStatic(NacosFactory.class)) {\n+            NamingService mock = new MockNamingService() {\n+                @Override\n+                public String getServerStatus() {\n+                    return DOWN;\n+                }\n+            };\n+            nacosFactoryMockedStatic.when(() -> NacosFactory.createNamingService((Properties) any())).thenReturn(mock);\n+\n+\n+            URL url = URL.valueOf(\"nacos://127.0.0.1:8848\")\n+                .addParameter(\"nacos.retry\", 5)\n+                .addParameter(\"nacos.retry-wait\", 10)\n+                .addParameter(\"nacos.check\", \"false\");\n+            try {\n+                new NacosConnectionManager(url, false, 5, 10);\n+            } catch (Throwable t) {\n+                Assertions.fail(t);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testRequest() {\n+        try (MockedStatic<NacosFactory> nacosFactoryMockedStatic = Mockito.mockStatic(NacosFactory.class)) {\n+            AtomicInteger atomicInteger = new AtomicInteger(0);\n+            NamingService mock = new MockNamingService() {\n+                @Override\n+                public List<Instance> getAllInstances(String serviceName, boolean subscribe) throws NacosException {\n+                    if (atomicInteger.incrementAndGet() > 10) {\n+                        return null;\n+                    } else {\n+                        throw new NacosException();\n+                    }\n+                }\n+\n+                @Override\n+                public String getServerStatus() {\n+                    return UP;\n+                }\n+            };\n+            nacosFactoryMockedStatic.when(() -> NacosFactory.createNamingService((Properties) any())).thenReturn(mock);\n+\n+\n+            URL url = URL.valueOf(\"nacos://127.0.0.1:8848\")\n+                .addParameter(\"nacos.retry\", 5)\n+                .addParameter(\"nacos.retry-wait\", 10);\n+            Assertions.assertThrows(IllegalStateException.class, () -> new NacosConnectionManager(url, true, 5, 10));\n+\n+            try {\n+                new NacosConnectionManager(url, true, 5, 10);\n+            } catch (Throwable t) {\n+                Assertions.fail(t);\n+            }\n+        }\n+    }\n }",
    "output": "Fix Nacos sub try test conflict"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -36,7 +36,6 @@\n import org.apache.dubbo.common.utils.ConfigUtils;\n import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n-import org.apache.dubbo.config.context.ConfigManager;\n import org.apache.dubbo.config.support.Parameter;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.ModuleModel;",
    "output": "Fix import"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -431,6 +431,8 @@ public interface CommonConstants {\n     String SERIALIZE_ALLOW_LIST_FILE_PATH = \"security/serialize.allowlist\";\n+    String SERIALIZE_CHECK_STATUS_KEY = \"dubbo.application.serialize-check-status\";\n+\n     String QOS_LIVE_PROBE_EXTENSION = \"dubbo.application.liveness-probe\";\n     String QOS_READY_PROBE_EXTENSION = \"dubbo.application.readiness-probe\";\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeSecurityManager.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeSecurityManager.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeSecurityManager.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeSecurityManager.java\n@@ -37,6 +37,7 @@\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import static org.apache.dubbo.common.constants.CommonConstants.SERIALIZE_ALLOW_LIST_FILE_PATH;\n+import static org.apache.dubbo.common.constants.CommonConstants.SERIALIZE_CHECK_STATUS_KEY;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_IO_EXCEPTION;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_INTERRUPTED;\n@@ -74,6 +75,9 @@ public SerializeSecurityManager(FrameworkModel frameworkModel) {\n                     logger.error(COMMON_IO_EXCEPTION, \"\", \"\",  \"Failed to load allow class list! Will ignore allow lis from \" + u, e);\n                 }\n             }\n+\n+            this.checkStatus = SerializeCheckStatus.valueOf(System.getProperty(SERIALIZE_CHECK_STATUS_KEY, AllowClassNotifyListener.DEFAULT_STATUS.name()));\n+            logger.info(\"Serialize check level: \" + checkStatus.name());\n         } catch (InterruptedException e) {\n             logger.error(INTERNAL_INTERRUPTED, \"\", \"\",  \"Failed to load allow class list! Will ignore allow list from configuration.\", e);\n             Thread.currentThread().interrupt();",
    "output": "Add check status option"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -17,7 +17,13 @@\n package org.apache.dubbo.rpc.protocol.tri;\n-import io.netty.util.AsciiString;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n@@ -33,7 +39,6 @@\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcException;\n-import org.apache.dubbo.rpc.TimeoutCountDown;\n import org.apache.dubbo.rpc.TriRpcStatus;\n import org.apache.dubbo.rpc.model.ConsumerModel;\n import org.apache.dubbo.rpc.model.MethodDescriptor;\n@@ -50,20 +55,11 @@\n import org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n import org.apache.dubbo.rpc.support.RpcUtils;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.ReentrantLock;\n+import io.netty.util.AsciiString;\n-import static org.apache.dubbo.common.constants.CommonConstants.ENABLE_TIMEOUT_COUNTDOWN_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_ATTACHMENT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_DESTROY_INVOKER;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\n import static org.apache.dubbo.rpc.Constants.TOKEN_KEY;",
    "output": "Fix conflicts"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n@@ -557,8 +557,8 @@ public boolean map(URL url) {\n             }\n             @Override\n-            public void initInterfaceAppMapping(URL subscribedURL) {\n-\n+            public Set<String> getMapping(URL consumerURL) {\n+                return null;\n             }\n             @Override\n@@ -576,26 +576,11 @@ public void putCachedMapping(String serviceKey, Set<String> apps) {\n             }\n-            @Override\n-            public Set<String> getCachedMapping(String mappingKey) {\n-                return null;\n-            }\n-\n-            @Override\n-            public Set<String> getCachedMapping(URL consumerURL) {\n-                return null;\n-            }\n-\n             @Override\n             public Set<String> getRemoteMapping(URL consumerURL) {\n                 return null;\n             }\n-            @Override\n-            public Map<String, Set<String>> getCachedMapping() {\n-                return null;\n-            }\n-\n             @Override\n             public Set<String> removeCachedMapping(String serviceKey) {\n                 return null;",
    "output": "Fix test conflict"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n@@ -69,24 +69,6 @@\n import static org.apache.dubbo.config.Constants.PRODUCTION_ENVIRONMENT;\n import static org.apache.dubbo.config.Constants.TEST_ENVIRONMENT;\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.apache.dubbo.common.compiler.support.AdaptiveCompiler;\n-import org.apache.dubbo.common.infra.InfraAdapter;\n-import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.CollectionUtils;\n-import org.apache.dubbo.common.utils.StringUtils;\n-import org.apache.dubbo.config.support.Parameter;\n-import org.apache.dubbo.rpc.model.ApplicationModel;\n-\n-\n /**\n  * The application info\n  *",
    "output": "Fix conflict"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n@@ -544,6 +544,7 @@ void testMappingRetry() {\n         FrameworkModel frameworkModel = new FrameworkModel();\n         ApplicationModel applicationModel = frameworkModel.newApplication();\n         ServiceConfig<DemoService> serviceConfig = new ServiceConfig<>(applicationModel.newModule());\n+        serviceConfig.exported();\n         ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);\n         AtomicInteger count = new AtomicInteger(0);\n         ServiceNameMapping serviceNameMapping = new ServiceNameMapping() {",
    "output": "Fix test cases for service name mapping"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n@@ -412,9 +412,11 @@ private static Inet6Address getLocalAddress0V6() {\n             while (addresses.hasMoreElements()) {\n                 InetAddress address = addresses.nextElement();\n                 if (address instanceof Inet6Address) {\n-                    if (!address.isLoopbackAddress() //filter 127.x.x.x\n-                        && !address.isAnyLocalAddress() // filter 0.0.0.0\n-                        && !address.isLinkLocalAddress() //filter 169.254.0.0/16\n+                    if (!address.isLoopbackAddress() //filter ::1\n+                        && !address.isAnyLocalAddress() // filter ::/128\n+                        && !address.isLinkLocalAddress() //filter fe80::/10\n+                        && !address.isSiteLocalAddress()// filter fec0::/10\n+                        && !isUniqueLocalAddress(address) //filter fd00::/8\n                         && address.getHostAddress().contains(\":\")) {//filter IPv6\n                         return (Inet6Address) address;\n                     }\n@@ -427,6 +429,17 @@ private static Inet6Address getLocalAddress0V6() {\n         return null;\n     }\n+    /**\n+     * If the address is Unique Local Address.\n+     *\n+     * @param address {@link InetAddress}\n+     * @return {@code true} if the address is Unique Local Address,otherwise {@code false}\n+     */\n+    private static boolean isUniqueLocalAddress(InetAddress address) {\n+        byte[] ip = address.getAddress();\n+        return (ip[0] & 0xff) == 0xfd;\n+    }\n+\n     /**\n      * Returns {@code true} if the specified {@link NetworkInterface} should be ignored with the given conditions.\n      *",
    "output": "Upgrade IPv6 annotation and filter invalid IPv6"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -16,6 +16,28 @@\n  */\n package org.apache.dubbo.config;\n+import java.beans.BeanInfo;\n+import java.beans.IntrospectionException;\n+import java.beans.Introspector;\n+import java.beans.MethodDescriptor;\n+import java.beans.PropertyDescriptor;\n+import java.beans.Transient;\n+import java.io.Serializable;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.config.ConfigurationUtils;\n import org.apache.dubbo.common.config.Environment;\n@@ -39,27 +61,6 @@\n import org.apache.dubbo.rpc.model.ScopeModel;\n import org.apache.dubbo.rpc.model.ScopeModelUtil;\n-import java.beans.BeanInfo;\n-import java.beans.IntrospectionException;\n-import java.beans.Introspector;\n-import java.beans.MethodDescriptor;\n-import java.beans.PropertyDescriptor;\n-import java.io.Serializable;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_FAILED_OVERRIDE_FIELD;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_REFLECTIVE_OPERATION_FAILED;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_UNEXPECTED_EXCEPTION;\n@@ -110,7 +111,7 @@ public abstract class AbstractConfig implements Serializable {\n      * <b>NOTE:</b> the model maybe changed during config processing,\n      * the extension spi instance needs to be reinitialized after changing the model!\n      */\n-    private volatile ScopeModel scopeModel;\n+    private transient volatile ScopeModel scopeModel;\n     public AbstractConfig() {\n         this(null);\n@@ -383,6 +384,7 @@ protected static Map<String, String> convert(Map<String, String> parameters, Str\n         return result;\n     }\n+    @Transient\n     public ApplicationModel getApplicationModel() {\n         if (scopeModel == null) {\n             setScopeModel(getDefaultModel());\n@@ -396,13 +398,15 @@ public ApplicationModel getApplicationModel() {\n         }\n     }\n+    @Transient\n     public ScopeModel getScopeModel() {\n         if (scopeModel == null) {\n             setScopeModel(getDefaultModel());\n         }\n         return scopeModel;\n     }\n+    @Transient\n     protected ScopeModel getDefaultModel() {\n         return ApplicationModel.defaultModel();\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -16,6 +16,15 @@\n  */\n package org.apache.dubbo.config;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.Version;\n import org.apache.dubbo.common.config.ConfigurationUtils;\n@@ -35,15 +44,6 @@\n import org.apache.dubbo.rpc.model.ScopeModelUtil;\n import org.apache.dubbo.rpc.model.ServiceMetadata;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_VERSION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.INVOKER_LISTENER_KEY;\n@@ -74,7 +74,7 @@ public abstract class AbstractInterfaceConfig extends AbstractMethodConfig {\n     /**\n      * The classLoader of interface belong to\n      */\n-    protected ClassLoader interfaceClassLoader;\n+    protected transient ClassLoader interfaceClassLoader;\n     /**\n      * The remote service version the customer/provider side will reference\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConsumerConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConsumerConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConsumerConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConsumerConfigTest.java\n@@ -17,18 +17,19 @@\n package org.apache.dubbo.config;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.dubbo.common.utils.JsonUtils;\n import org.apache.dubbo.config.api.DemoService;\n import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n-\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import java.util.Collection;\n-import java.util.Map;\n-\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.is;\n@@ -243,4 +244,38 @@ void testMetaData() {\n         Map<String, String> metaData = consumerConfig.getMetaData();\n         Assertions.assertEquals(0, metaData.size(), \"Expect empty metadata but found: \"+metaData);\n     }\n-}\n\\ No newline at end of file\n+\n+    @Test\n+    void testSerialize() {\n+        ConsumerConfig consumerConfig = new ConsumerConfig();\n+        consumerConfig.setCorethreads(1);\n+        consumerConfig.setQueues(1);\n+        consumerConfig.setThreads(1);\n+        consumerConfig.setThreadpool(\"Mock\");\n+        consumerConfig.setGroup(\"Test\");\n+        consumerConfig.setMeshEnable(false);\n+        consumerConfig.setReferThreadNum(2);\n+        consumerConfig.setShareconnections(2);\n+        consumerConfig.setTimeout(2);\n+        consumerConfig.setUrlMergeProcessor(\"test\");\n+        consumerConfig.setReferBackground(false);\n+        consumerConfig.setActives(1);\n+        consumerConfig.setAsync(false);\n+        consumerConfig.setCache(\"false\");\n+        consumerConfig.setCallbacks(1);\n+        consumerConfig.setConnections(1);\n+        consumerConfig.setInterfaceClassLoader(Thread.currentThread().getContextClassLoader());\n+        consumerConfig.setApplication(new ApplicationConfig());\n+        consumerConfig.setRegistries(Collections.singletonList(new RegistryConfig()));\n+        consumerConfig.setModule(new ModuleConfig());\n+        consumerConfig.setMetadataReportConfig(new MetadataReportConfig());\n+        consumerConfig.setMonitor(new MonitorConfig());\n+        consumerConfig.setConfigCenter(new ConfigCenterConfig());\n+\n+        try {\n+            JsonUtils.getJson().toJson(consumerConfig);\n+        } catch (Throwable t) {\n+            Assertions.fail(t);\n+        }\n+    }\n+}",
    "output": "Fix config unable to serialize"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java\n@@ -140,23 +140,19 @@ private void collectRequests(List<MetricSample> list) {\n             .ifPresent(map-> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.METRIC_REQUESTS_SUCCEED, k.getTags(), REQUESTS, v::get))));\n         doExecute(RequestEvent.Type.FAILED, MetricsStatHandler::get).filter(e->!e.isEmpty())\n-            .ifPresent(map->{\n-                map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.METRIC_REQUESTS_FAILED, k.getTags(), REQUESTS, v::get)));\n-            });\n+            .ifPresent(map-> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.METRIC_REQUESTS_FAILED, k.getTags(), REQUESTS, v::get))));\n         doExecute(RequestEvent.Type.PROCESSING, MetricsStatHandler::get).filter(e->!e.isEmpty())\n             .ifPresent(map-> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.METRIC_REQUESTS_PROCESSING, k.getTags(), REQUESTS, v::get))));\n         doExecute(RequestEvent.Type.BUSINESS_FAILED, MetricsStatHandler::get).filter(e->!e.isEmpty())\n             .ifPresent(map-> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.METRIC_REQUEST_BUSINESS_FAILED, k.getTags(), REQUESTS, v::get))));\n-\n         doExecute(RequestEvent.Type.REQUEST_TIMEOUT, MetricsStatHandler::get).filter(e->!e.isEmpty())\n             .ifPresent(map-> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.METRIC_REQUESTS_TIMEOUT_AGG, k.getTags(), REQUESTS, v::get))));\n         doExecute(RequestEvent.Type.REQUEST_LIMIT, MetricsStatHandler::get).filter(e->!e.isEmpty())\n             .ifPresent(map-> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.METRIC_REQUESTS_LIMIT_AGG, k.getTags(), REQUESTS, v::get))));\n-\n     }\n     private void collectRT(List<MetricSample> list) {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/stat/DefaultMetricsStatHandler.java b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/stat/DefaultMetricsStatHandler.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/stat/DefaultMetricsStatHandler.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/stat/DefaultMetricsStatHandler.java\n@@ -53,7 +53,6 @@ protected void doIncrExecute(String interfaceName, String methodName, String gro\n         this.doExecute(interfaceName,methodName,group,version,(metric,counts)->{\n             AtomicLong count = counts.computeIfAbsent(metric, k -> new AtomicLong(0L));\n             count.incrementAndGet();\n-\n         });\n     }\n@@ -69,6 +68,5 @@ public Map<MethodMetric, AtomicLong> get() {\n         return counts;\n     }\n-    public  void doNotify(MethodMetric metric){}\n-\n+    public void doNotify(MethodMetric metric){}\n }\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java\n@@ -31,11 +31,11 @@\n public class MetricsCollectExecutor {\n     private final DefaultMetricsCollector collector;\n-    private final Invocation    invocation;\n-    private String  interfaceName;\n-    private String  methodName;\n-    private String  group;\n-    private String  version;\n+    private final Invocation invocation;\n+    private String interfaceName;\n+    private String methodName;\n+    private String group;\n+    private String version;\n     public MetricsCollectExecutor(DefaultMetricsCollector collector, Invocation invocation) {\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java\n@@ -62,7 +62,7 @@ public void onResponse(Result result, Invoker<?> invoker, Invocation invocation)\n     @Override\n     public void onError(Throwable t, Invoker<?> invoker, Invocation invocation) {\n-        collect(invocation,collector-> collector.throwExecute(t));\n+        collect(invocation, collector-> collector.throwExecute(t));\n     }\n     private void collect(Invocation invocation, Consumer<MetricsCollectExecutor> execute) {",
    "output": "Fix code format * fix: code format * fix: code format * fix: code format"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n@@ -106,7 +106,7 @@ public boolean map(URL url) {\n                     if (!succeeded) {\n                         int waitTime = ThreadLocalRandom.current().nextInt(casRetryWaitTime);\n                         logger.info(\"Failed to publish service name mapping to metadata center by cas operation. \" +\n-                            \"Times: \" + casRetryTimes + \". \" +\n+                            \"Times: \" + currentRetryTimes + \". \" +\n                             \"Next retry delay: \" + waitTime + \". \" +\n                             \"Service Interface: \" + serviceInterface + \". \" +\n                             \"Origin Content: \" + oldConfigContent + \". \" +",
    "output": "Fix cas log parameter"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java\n@@ -104,7 +104,15 @@ public boolean map(URL url) {\n                     }\n                     succeeded = metadataReport.registerServiceAppMapping(serviceInterface, DEFAULT_MAPPING_GROUP, newConfigContent, configItem.getTicket());\n                     if (!succeeded) {\n-                        Thread.sleep(ThreadLocalRandom.current().nextInt(casRetryWaitTime));\n+                        int waitTime = ThreadLocalRandom.current().nextInt(casRetryWaitTime);\n+                        logger.info(\"Failed to publish service name mapping to metadata center by cas operation. \" +\n+                            \"Times: \" + casRetryTimes + \". \" +\n+                            \"Next retry delay: \" + waitTime + \". \" +\n+                            \"Service Interface: \" + serviceInterface + \". \" +\n+                            \"Origin Content: \" + oldConfigContent + \". \" +\n+                            \"Ticket: \" + configItem.getTicket() + \". \" +\n+                            \"Excepted context: \" + newConfigContent);\n+                        Thread.sleep(waitTime);\n                     }\n                 } while (!succeeded && currentRetryTimes++ <= casRetryTimes);",
    "output": "Add some cas update failed logs"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n@@ -16,6 +16,22 @@\n  */\n package org.apache.dubbo.registry.client.event.listener;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import org.apache.dubbo.common.ProtocolServiceKey;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.URLBuilder;\n@@ -38,25 +54,9 @@\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.ScopeModelUtil;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.Semaphore;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_FAILED_REFRESH_ADDRESS;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_FAILED_REFRESH_ADDRESS;\n import static org.apache.dubbo.common.constants.RegistryConstants.EMPTY_PROTOCOL;\n import static org.apache.dubbo.common.constants.RegistryConstants.ENABLE_EMPTY_PROTECTION_KEY;\n import static org.apache.dubbo.metadata.RevisionResolver.EMPTY_REVISION;\n@@ -466,12 +466,12 @@ public boolean equals(Object o) {\n             return false;\n         }\n         ServiceInstancesChangedListener that = (ServiceInstancesChangedListener) o;\n-        return Objects.equals(getServiceNames(), that.getServiceNames());\n+        return Objects.equals(getServiceNames(), that.getServiceNames()) && Objects.equals(listeners, that.listeners);\n     }\n     @Override\n     public int hashCode() {\n-        return Objects.hash(getClass(), getServiceNames());\n+        return Objects.hash(getClass(), getServiceNames(), listeners);\n     }\n     protected class AddressRefreshRetryTask implements Runnable {\ndiff --git a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n@@ -156,6 +156,9 @@ public void addServiceInstancesChangedListener(ServiceInstancesChangedListener l\n     @Override\n     public void removeServiceInstancesChangedListener(ServiceInstancesChangedListener listener) throws IllegalArgumentException {\n+        if (!instanceListeners.remove(listener)) {\n+            return;\n+        }\n         listener.getServiceNames().forEach(serviceName -> {\n             ZookeeperServiceDiscoveryChangeWatcher watcher = watcherCaches.get(serviceName);\n             if (watcher != null) {",
    "output": "Fix zk resubscribe failed"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -16,6 +16,16 @@\n  */\n package org.apache.dubbo.registry.integration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.config.ConfigurationUtils;\n import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;\n@@ -25,6 +35,7 @@\n import org.apache.dubbo.common.timer.HashedWheelTimer;\n import org.apache.dubbo.common.url.component.ServiceConfigURL;\n import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.ConcurrentHashSet;\n import org.apache.dubbo.common.utils.NamedThreadFactory;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.common.utils.UrlUtils;\n@@ -59,15 +70,6 @@\n import org.apache.dubbo.rpc.protocol.InvokerWrapper;\n import org.apache.dubbo.rpc.support.ProtocolUtils;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-\n import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.CLUSTER_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;\n@@ -193,8 +195,8 @@ public int getDefaultPort() {\n         return 9090;\n     }\n-    public Map<URL, NotifyListener> getOverrideListeners() {\n-        Map<URL, NotifyListener> map = new HashMap<>();\n+    public Map<URL, Set<NotifyListener>> getOverrideListeners() {\n+        Map<URL, Set<NotifyListener>> map = new HashMap<>();\n         List<ApplicationModel> applicationModels = frameworkModel.getApplicationModels();\n         if (applicationModels.size() == 1) {\n             return applicationModels.get(0).getBeanFactory().getBean(ProviderConfigurationListener.class).getOverrideListeners();\n@@ -230,8 +232,9 @@ public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcExceptio\n         //  subscription information to cover.\n         final URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);\n         final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n-        Map<URL, NotifyListener> overrideListeners = getProviderConfigurationListener(overrideSubscribeUrl).getOverrideListeners();\n-        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n+        Map<URL, Set<NotifyListener>> overrideListeners = getProviderConfigurationListener(overrideSubscribeUrl).getOverrideListeners();\n+        overrideListeners.computeIfAbsent(overrideSubscribeUrl, k -> new ConcurrentHashSet<>())\n+            .add(overrideSubscribeListener);\n         providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);\n         //export invoker\n@@ -253,6 +256,7 @@ public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcExceptio\n         exporter.setRegisterUrl(registeredProviderUrl);\n         exporter.setSubscribeUrl(overrideSubscribeUrl);\n+        exporter.setNotifyListener(overrideSubscribeListener);\n         if (!registry.isServiceDiscovery()) {\n             // Deprecated! Subscribe to override rules in 2.6.x or before.\n@@ -818,7 +822,7 @@ protected void notifyOverrides() {\n     private class ProviderConfigurationListener extends AbstractConfiguratorListener {\n-        private final Map<URL, NotifyListener> overrideListeners = new ConcurrentHashMap<>();\n+        private final Map<URL, Set<NotifyListener>> overrideListeners = new ConcurrentHashMap<>();\n         public ProviderConfigurationListener(ModuleModel moduleModel) {\n             super(moduleModel);\n@@ -840,10 +844,14 @@ private <T> URL overrideUrl(URL providerUrl) {\n         @Override\n         protected void notifyOverrides() {\n-            overrideListeners.values().forEach(listener -> ((OverrideListener) listener).doOverrideIfNecessary());\n+            overrideListeners.values().forEach(listeners -> {\n+                for (NotifyListener listener : listeners) {\n+                    ((OverrideListener) listener).doOverrideIfNecessary();\n+                }\n+            });\n         }\n-        public Map<URL, NotifyListener> getOverrideListeners() {\n+        public Map<URL, Set<NotifyListener>> getOverrideListeners() {\n             return overrideListeners;\n         }\n     }\n@@ -863,6 +871,8 @@ private class ExporterChangeableWrapper<T> implements Exporter<T> {\n         private URL subscribeUrl;\n         private URL registerUrl;\n+        private NotifyListener notifyListener;\n+\n         public ExporterChangeableWrapper(Exporter<T> exporter, Invoker<T> originInvoker) {\n             this.exporter = exporter;\n             this.originInvoker = originInvoker;\n@@ -897,11 +907,11 @@ public void unexport() {\n             }\n             try {\n                 if (subscribeUrl != null) {\n-                    Map<URL, NotifyListener> overrideListeners = getProviderConfigurationListener(subscribeUrl).getOverrideListeners();\n-                    NotifyListener listener = overrideListeners.remove(subscribeUrl);\n-                    if (listener != null) {\n+                    Map<URL, Set<NotifyListener>> overrideListeners = getProviderConfigurationListener(subscribeUrl).getOverrideListeners();\n+                    Set<NotifyListener> listeners = overrideListeners.get(subscribeUrl);\n+                    if (listeners.remove(notifyListener)) {\n                         if (!registry.isServiceDiscovery()) {\n-                            registry.unsubscribe(subscribeUrl, listener);\n+                            registry.unsubscribe(subscribeUrl, notifyListener);\n                         }\n                         ApplicationModel applicationModel = getApplicationModel(registerUrl.getScopeModel());\n                         if (applicationModel.getModelEnvironment().getConfiguration().convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)) {\n@@ -914,6 +924,9 @@ public void unexport() {\n                             }\n                         }\n                     }\n+                    if (listeners.isEmpty()) {\n+                        overrideListeners.remove(subscribeUrl);\n+                    }\n                 }\n             } catch (Throwable t) {\n                 logger.warn(INTERNAL_ERROR, \"unknown error in registry module\", \"\", t.getMessage(), t);\n@@ -941,6 +954,10 @@ public void setRegisterUrl(URL registerUrl) {\n             this.registerUrl = registerUrl;\n         }\n+        public void setNotifyListener(NotifyListener notifyListener) {\n+            this.notifyListener = notifyListener;\n+        }\n+\n         public URL getRegisterUrl() {\n             return registerUrl;\n         }",
    "output": "Fix Multi Registry Override"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -230,8 +230,8 @@ public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcExceptio\n         //  subscription information to cover.\n         final URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);\n         final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n-        Map<URL, NotifyListener> overrideListeners = getProviderConfigurationListener(providerUrl).getOverrideListeners();\n-        overrideListeners.put(registryUrl, overrideSubscribeListener);\n+        Map<URL, NotifyListener> overrideListeners = getProviderConfigurationListener(overrideSubscribeUrl).getOverrideListeners();\n+        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n         providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);\n         //export invoker\n@@ -898,7 +898,7 @@ public void unexport() {\n             try {\n                 if (subscribeUrl != null) {\n                     Map<URL, NotifyListener> overrideListeners = getProviderConfigurationListener(subscribeUrl).getOverrideListeners();\n-                    NotifyListener listener = overrideListeners.remove(registerUrl);\n+                    NotifyListener listener = overrideListeners.remove(subscribeUrl);\n                     if (listener != null) {\n                         if (!registry.isServiceDiscovery()) {\n                             registry.unsubscribe(subscribeUrl, listener);",
    "output": "Fix app level configuration not work"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java\n@@ -16,17 +16,23 @@\n  */\n package org.apache.dubbo.qos.command;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.qos.command.annotation.Cmd;\n-import org.apache.dubbo.qos.common.QosConstants;\n-import org.apache.dubbo.qos.permission.PermissionLevel;\n import org.apache.dubbo.qos.command.exception.NoSuchCommandException;\n import org.apache.dubbo.qos.command.exception.PermissionDenyException;\n+import org.apache.dubbo.qos.common.QosConstants;\n import org.apache.dubbo.qos.permission.DefaultAnonymousAccessPermissionChecker;\n import org.apache.dubbo.qos.permission.PermissionChecker;\n+import org.apache.dubbo.qos.permission.PermissionLevel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n+import io.netty.channel.Channel;\n+\n public class DefaultCommandExecutor implements CommandExecutor {\n     private final static Logger logger = LoggerFactory.getLogger(DefaultCommandExecutor.class);\n     private final FrameworkModel frameworkModel;\n@@ -86,5 +92,6 @@ public String execute(CommandContext commandContext) throws NoSuchCommandExcepti\n                 \", Args: \" + Arrays.toString(commandContext.getArgs()) +\n                 \", Remote Address: \" + remoteAddress, t);\n             throw t;\n-        }    }\n+        }\n+    }\n }",
    "output": "Fix conflict"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java\n@@ -19,7 +19,6 @@\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.JsonUtils;\n import org.apache.dubbo.rpc.TriRpcStatus;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n@@ -52,8 +51,6 @@\n import java.util.Map;\n import java.util.concurrent.Executor;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_REFLECTIVE_OPERATION_FAILED;\n-\n /**\n  * ClientStream is an abstraction for bi-directional messaging. It maintains a {@link WriteQueue} to\n@@ -195,29 +192,10 @@ void finishProcess(TriRpcStatus status, Http2Headers trailers) {\n             halfClosed = true;\n             final Map<String, String> reserved = filterReservedHeaders(trailers);\n-            final Map<String, Object> attachments = headersToMap(trailers);\n-            final Map<String, Object> finalAttachments = convertNoLowerCaseHeader(attachments);\n-            listener.onComplete(status, finalAttachments, reserved);\n-        }\n-\n-        private Map<String, Object> convertNoLowerCaseHeader(Map<String, Object> attachments) {\n-            Object obj = attachments.remove(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader());\n-            if (obj == null) {\n-                return attachments;\n-            }\n-            if (obj instanceof String) {\n-                String json = TriRpcStatus.decodeMessage((String) obj);\n-                Map<String, String> map = JsonUtils.getJson().toJavaObject(json, Map.class);\n-                map.forEach((originalKey, lowerCaseKey) -> {\n-                    Object val = attachments.remove(lowerCaseKey);\n-                    if (val != null) {\n-                        attachments.put(originalKey, val);\n-                    }\n-                });\n-            } else {\n-                LOGGER.error(COMMON_REFLECTIVE_OPERATION_FAILED, \"\", \"\", \"Triple convertNoLowerCaseHeader error, obj is not String\");\n-            }\n-            return attachments;\n+            final Map<String, Object> attachments = headersToMap(trailers, () -> {\n+                return reserved.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader());\n+            });\n+            listener.onComplete(status, attachments, reserved);\n         }\n         private TriRpcStatus validateHeaderStatus(Http2Headers headers) {\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java\n@@ -371,7 +371,11 @@ private void processHeader(Http2Headers headers, boolean endStream) {\n                 }\n             }\n-            Map<String, Object> requestMetadata = headersToMap(headers);\n+            Map<String, Object> requestMetadata = headersToMap(headers, () -> {\n+                return Optional.ofNullable(headers.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()))\n+                    .map(CharSequence::toString)\n+                    .orElse(null);\n+            });\n             boolean hasStub = pathResolver.hasNativeStub(path);\n             if (hasStub) {\n                 listener = new StubAbstractServerCall(invoker, TripleServerStream.this,\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/AbstractH2TransportListener.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/AbstractH2TransportListener.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/AbstractH2TransportListener.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/AbstractH2TransportListener.java\n@@ -19,6 +19,8 @@\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.JsonUtils;\n+import org.apache.dubbo.rpc.TriRpcStatus;\n import org.apache.dubbo.rpc.protocol.tri.TripleConstant;\n import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n import org.apache.dubbo.rpc.protocol.tri.stream.StreamUtils;\n@@ -28,6 +30,7 @@\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.function.Supplier;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_PARSE;\n@@ -41,7 +44,7 @@ public abstract class AbstractH2TransportListener implements H2TransportListener\n      * @param trailers the metadata from remote\n      * @return KV pairs map\n      */\n-    protected Map<String, Object> headersToMap(Http2Headers trailers) {\n+    protected Map<String, Object> headersToMap(Http2Headers trailers, Supplier<Object> convertUpperHeaderSupplier) {\n         if (trailers == null) {\n             return Collections.emptyMap();\n         }\n@@ -62,6 +65,24 @@ protected Map<String, Object> headersToMap(Http2Headers trailers) {\n                 attachments.put(key, header.getValue().toString());\n             }\n         }\n+\n+        // try convert upper key\n+        Object obj = convertUpperHeaderSupplier.get();\n+        if (obj == null) {\n+            return attachments;\n+        }\n+        if (obj instanceof String) {\n+            String json = TriRpcStatus.decodeMessage((String) obj);\n+            Map<String, String> map = JsonUtils.getJson().toJavaObject(json, Map.class);\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                Object val = attachments.remove(entry.getKey());\n+                if (val != null) {\n+                    attachments.put(entry.getValue(), val);\n+                }\n+            }\n+        } else {\n+            LOGGER.error(PROTOCOL_FAILED_PARSE, \"\", \"\", \"Triple convertNoLowerCaseHeader error, obj is not String\");\n+        }\n         return attachments;\n     }\n@@ -73,9 +94,6 @@ protected Map<String, String> filterReservedHeaders(Http2Headers trailers) {\n         Map<String, String> excludeHeaders = new HashMap<>(trailers.size());\n         for (Map.Entry<CharSequence, CharSequence> header : trailers) {\n             String key = header.getKey().toString();\n-            if (Http2Headers.PseudoHeaderName.isPseudoHeader(key)) {\n-                excludeHeaders.put(key, trailers.getAndRemove(key).toString());\n-            }\n             if (TripleHeaderEnum.containsExcludeAttachments(key)) {\n                 excludeHeaders.put(key, trailers.getAndRemove(key).toString());\n             }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/transport/AbstractH2TransportListenerTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/transport/AbstractH2TransportListenerTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/transport/AbstractH2TransportListenerTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/transport/AbstractH2TransportListenerTest.java\n@@ -50,10 +50,10 @@ public void cancelByRemote(long errorCode) {\n         };\n         DefaultHttp2Headers headers = new DefaultHttp2Headers();\n         headers.scheme(HTTPS.name())\n-                .path(\"/foo.bar\")\n-                .method(HttpMethod.POST.asciiName());\n+            .path(\"/foo.bar\")\n+            .method(HttpMethod.POST.asciiName());\n         headers.set(\"foo\", \"bar\");\n-        final Map<String, Object> map = listener.headersToMap(headers);\n+        final Map<String, Object> map = listener.headersToMap(headers, () -> null);\n         Assertions.assertEquals(4, map.size());\n     }",
    "output": "Fix tri upper error * fix error * fix * fix * fix * fix * fix"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java\n@@ -16,9 +16,18 @@\n  */\n package org.apache.dubbo.qos.command;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n+import io.netty.channel.Channel;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n public class DefaultCommandExecutor implements CommandExecutor {\n+    private final static Logger logger = LoggerFactory.getLogger(DefaultCommandExecutor.class);\n     private FrameworkModel frameworkModel;\n     public DefaultCommandExecutor(FrameworkModel frameworkModel) {\n@@ -27,15 +36,34 @@ public DefaultCommandExecutor(FrameworkModel frameworkModel) {\n     @Override\n     public String execute(CommandContext commandContext) throws NoSuchCommandException {\n+        String remoteAddress = Optional.ofNullable(commandContext.getRemote())\n+            .map(Channel::remoteAddress).map(Objects::toString).orElse(\"unknown\");\n+\n+        logger.info(\"[Dubbo QoS] Command Process start. Command: \" + commandContext.getCommandName() +\n+            \", Args: \" + Arrays.toString(commandContext.getArgs()) + \", Remote Address: \" + remoteAddress);\n         BaseCommand command = null;\n         try {\n             command = frameworkModel.getExtensionLoader(BaseCommand.class).getExtension(commandContext.getCommandName());\n         } catch (Throwable throwable) {\n                 //can't find command\n         }\n         if (command == null) {\n+            logger.info(\"[Dubbo QoS] Command Not found. Command: \" + commandContext.getCommandName() +\n+                \", Remote Address: \" + remoteAddress);\n             throw new NoSuchCommandException(commandContext.getCommandName());\n         }\n-        return command.execute(commandContext, commandContext.getArgs());\n+\n+        try {\n+            String result = command.execute(commandContext, commandContext.getArgs());\n+            logger.info(\"[Dubbo QoS] Command Process success. Command: \" + commandContext.getCommandName() +\n+                \", Args: \" + Arrays.toString(commandContext.getArgs()) + \", Result: \" + result +\n+                \", Remote Address: \" + remoteAddress);\n+            return result;\n+        } catch (Throwable t) {\n+            logger.info(\"[Dubbo QoS] Command Process Failed. Command: \" + commandContext.getCommandName() +\n+                \", Args: \" + Arrays.toString(commandContext.getArgs()) +\n+                \", Remote Address: \" + remoteAddress, t);\n+            throw t;\n+        }\n     }\n }",
    "output": "Add some qos command logs * Add some qos command logs * Add some qos command logs * Fix tests"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n@@ -42,6 +42,8 @@\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_ZOOKEEPER_EXCEPTION;\n import static org.apache.dubbo.common.function.ThrowableFunction.execute;\n+import static org.apache.dubbo.metadata.RevisionResolver.EMPTY_REVISION;\n+import static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.getExportedServicesRevision;\n import static org.apache.dubbo.registry.zookeeper.util.CuratorFrameworkUtils.build;\n import static org.apache.dubbo.registry.zookeeper.util.CuratorFrameworkUtils.buildCuratorFramework;\n import static org.apache.dubbo.registry.zookeeper.util.CuratorFrameworkUtils.buildServiceDiscovery;\n@@ -106,6 +108,19 @@ public void doUnregister(ServiceInstance serviceInstance) throws RuntimeExceptio\n         }\n     }\n+    @Override\n+    protected void doUpdate(ServiceInstance serviceInstance) throws RuntimeException {\n+        if (!EMPTY_REVISION.equals(getExportedServicesRevision(serviceInstance))) {\n+            reportMetadata(serviceInstance.getServiceMetadata());\n+        }\n+\n+        try {\n+            serviceDiscovery.updateService(build(serviceInstance));\n+        } catch (Exception e) {\n+            throw new RpcException(REGISTRY_EXCEPTION, \"Failed register instance \" + serviceInstance.toString(), e);\n+        }\n+    }\n+\n     @Override\n     public Set<String> getServices() {\n         return doInServiceDiscovery(s -> new LinkedHashSet<>(s.queryForNames()));",
    "output": "Fix zookeeper instance update"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReport.java b/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReport.java\n--- a/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReport.java\n+++ b/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReport.java\n@@ -236,7 +236,7 @@ public boolean registerServiceAppMapping(String key, String group, String conten\n     @Override\n     public ConfigItem getConfigItem(String key, String group) {\n         String content = getConfig(key, group);\n-        String casMd5 = \"\";\n+        String casMd5 = \"0\";\n         if (StringUtils.isNotEmpty(content)) {\n             casMd5 = md5Utils.getMd5(content);\n         }",
    "output": "Fix Nacos empty ticket not work"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ProtocolPortsMetadataCustomizer.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ProtocolPortsMetadataCustomizer.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ProtocolPortsMetadataCustomizer.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ProtocolPortsMetadataCustomizer.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.registry.client.metadata;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.constants.LoggerCodeConstants;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.CollectionUtils;\n@@ -25,7 +26,6 @@\n import org.apache.dubbo.registry.client.ServiceInstanceCustomizer;\n import org.apache.dubbo.rpc.Protocol;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n-import org.apache.dubbo.common.constants.LoggerCodeConstants;\n import java.util.HashMap;\n import java.util.Map;\n@@ -55,7 +55,7 @@ public void customize(ServiceInstance serviceInstance, ApplicationModel applicat\n             String protocol = url.getProtocol();\n             Integer oldPort = protocols.get(protocol);\n             int newPort = url.getPort();\n-            if (oldPort != null) {\n+            if (oldPort != null && oldPort != newPort) {\n                 LOGGER.warn(LoggerCodeConstants.PROTOCOL_INCORRECT_PARAMETER_VALUES, \"the protocol is listening multiple ports\", \"\", \"Same protocol \" + \"[\" + protocol + \"]\" + \" listens on different ports \" + \"[\" + oldPort + \",\" + newPort + \"]\" + \" will override with each other\" +\n                     \". The port [\" + oldPort + \"] is overridden with port [\" + newPort + \"].\");\n             }",
    "output": "Fix warn when port are the same"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n@@ -39,6 +39,7 @@\n import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\n import org.springframework.beans.factory.config.BeanDefinition;\n import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n+import org.springframework.beans.factory.support.DefaultSingletonBeanRegistry;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationContextAware;\n@@ -343,7 +344,12 @@ private Object getCallProxy() throws Exception {\n             throw new IllegalStateException(\"ReferenceBean is not ready yet, please make sure to call reference interface method after dubbo is started.\");\n         }\n         //get reference proxy\n-        return referenceConfig.get();\n+        //Subclasses should synchronize on the given Object if they perform any sort of extended singleton creation phase.\n+        // In particular, subclasses should not have their own mutexes involved in singleton creation, to avoid the potential for deadlocks in lazy-init situations.\n+        //The redundant type cast is to be compatible with earlier than spring-4.2\n+        synchronized (((DefaultSingletonBeanRegistry)getBeanFactory()).getSingletonMutex()) {\n+            return referenceConfig.get();\n+        }\n     }\n     private class DubboReferenceLazyInitTargetSource extends AbstractLazyCreationTargetSource {",
    "output": "Fix deadlocks in lazy-init situations. * Fix deadlocks in lazy-init situations. * Fix deadlocks in lazy-init situations(Compatible with versions earlier than spring-4.2)"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/SpringCloudServiceInstanceNotificationCustomizer.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/SpringCloudServiceInstanceNotificationCustomizer.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/SpringCloudServiceInstanceNotificationCustomizer.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/SpringCloudServiceInstanceNotificationCustomizer.java\n@@ -31,7 +31,8 @@ public void customize(List<ServiceInstance> serviceInstance) {\n         for (ServiceInstance instance : serviceInstance) {\n             if (\"SPRING_CLOUD\".equals(instance.getMetadata(\"preserved.register.source\"))) {\n                 MetadataInfo.ServiceInfo serviceInfo = new MetadataInfo.ServiceInfo(\"*\", \"*\", \"*\", \"rest\", instance.getPort(), \"*\", new HashMap<>());\n-                MetadataInfo metadataInfo = new MetadataInfo(instance.getServiceName(), \"SPRING_CLOUD\", new ConcurrentHashMap<>(Collections.singletonMap(\"*\", serviceInfo))) {\n+                String revision = \"SPRING_CLOUD-\" + instance.getServiceName() + \"-\" + instance.getAddress() + \"-\" + instance.getPort();\n+                MetadataInfo metadataInfo = new MetadataInfo(instance.getServiceName(), revision, new ConcurrentHashMap<>(Collections.singletonMap(\"*\", serviceInfo))) {\n                     @Override\n                     public List<ServiceInfo> getMatchedServiceInfos(ProtocolServiceKey consumerProtocolServiceKey) {\n                         getServices().putIfAbsent(consumerProtocolServiceKey.getServiceKeyString(),",
    "output": "Fix Spring Cloud metadata override"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerClassLoaderFilter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerClassLoaderFilter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerClassLoaderFilter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerClassLoaderFilter.java\n@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.filter.support;\n+\n+import org.apache.dubbo.common.extension.Activate;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.Result;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;\n+import org.apache.dubbo.rpc.model.ServiceModel;\n+\n+import java.util.Optional;\n+\n+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;\n+\n+@Activate(group = CONSUMER, order = Integer.MIN_VALUE + 100)\n+public class ConsumerClassLoaderFilter implements ClusterFilter {\n+    @Override\n+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n+        ClassLoader originClassLoader = Thread.currentThread().getContextClassLoader();\n+        try {\n+            Optional.ofNullable(invocation.getServiceModel())\n+                .map(ServiceModel::getClassLoader)\n+                .ifPresent(Thread.currentThread()::setContextClassLoader);\n+            return invoker.invoke(invocation);\n+        } finally {\n+            Thread.currentThread().setContextClassLoader(originClassLoader);\n+        }\n+    }\n+}\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -1092,12 +1092,49 @@ public void testDifferentClassLoaderRequest() throws Exception {\n         Assertions.assertNotEquals(classLoader2, result1.getClass().getClassLoader());\n         Assertions.assertEquals(classLoader1, innerRequestReference.get().getClass().getClassLoader());\n+        Thread.currentThread().setContextClassLoader(classLoader1);\n+        callBean1.invoke(object1, requestClazzCustom2.newInstance());\n+        Assertions.assertEquals(classLoader1, Thread.currentThread().getContextClassLoader());\n+\n         applicationModel.destroy();\n         DubboBootstrap.getInstance().destroy();\n         Thread.currentThread().setContextClassLoader(classLoader);\n         Thread.currentThread().getContextClassLoader().loadClass(DemoService.class.getName());\n     }\n+    @Test\n+    void testClassLoader() {\n+        FrameworkModel frameworkModel = new FrameworkModel();\n+        ApplicationModel applicationModel = frameworkModel.newApplication();\n+        applicationModel.getApplicationConfigManager().setApplication(new ApplicationConfig(\"Test\"));\n+\n+        ClassLoader originClassLoader = Thread.currentThread().getContextClassLoader();\n+        ClassLoader classLoader = new ClassLoader(originClassLoader) {};\n+        Thread.currentThread().setContextClassLoader(classLoader);\n+\n+        ServiceConfig<DemoService> serviceConfig = new ServiceConfig<>(applicationModel.newModule());\n+        serviceConfig.setInterface(DemoService.class);\n+        serviceConfig.setProtocol(new ProtocolConfig(\"dubbo\", -1));\n+        serviceConfig.setRegistry(new RegistryConfig(\"N/A\"));\n+        serviceConfig.setRef(new DemoServiceImpl());\n+        serviceConfig.export();\n+\n+        ReferenceConfig<DemoService> referenceConfig = new ReferenceConfig<>(applicationModel.newModule());\n+        referenceConfig.setInterface(DemoService.class);\n+        referenceConfig.setRegistry(new RegistryConfig(\"N/A\"));\n+        DemoService demoService = referenceConfig.get();\n+\n+        demoService.sayName(\"Dubbo\");\n+        Assertions.assertEquals(classLoader, Thread.currentThread().getContextClassLoader());\n+\n+        Thread.currentThread().setContextClassLoader(null);\n+        demoService.sayName(\"Dubbo\");\n+        Assertions.assertNull(Thread.currentThread().getContextClassLoader());\n+\n+        Thread.currentThread().setContextClassLoader(originClassLoader);\n+        frameworkModel.destroy();\n+    }\n+\n     private Class<?> compileCustomRequest(ClassLoader classLoader) throws NotFoundException, CannotCompileException {\n         CtClassBuilder builder = new CtClassBuilder();\n         builder.setClassName(MultiClassLoaderServiceRequest.class.getName() + \"A\");",
    "output": "Fix Consumer ClassLoader Change * Fix Consumer ClassLoader Change * Add test cases * Fix uts"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHeaderEnum.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHeaderEnum.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHeaderEnum.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHeaderEnum.java\n@@ -19,6 +19,8 @@\n import org.apache.dubbo.common.constants.CommonConstants;\n+import io.netty.handler.codec.http2.Http2Headers;\n+\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n@@ -61,6 +63,11 @@ public enum TripleHeaderEnum {\n         excludeAttachmentsSet.add(CommonConstants.APPLICATION_KEY);\n         excludeAttachmentsSet.add(TripleConstant.SERIALIZATION_KEY);\n         excludeAttachmentsSet.add(TripleConstant.TE_KEY);\n+\n+        for (Http2Headers.PseudoHeaderName value : Http2Headers.PseudoHeaderName.values()) {\n+            excludeAttachmentsSet.add(value.value().toString());\n+        }\n+\n     }\n     private final String header;\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtils.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtils.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtils.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtils.java\n@@ -20,20 +20,19 @@\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.JsonUtils;\n+import org.apache.dubbo.common.utils.LRU2Cache;\n import org.apache.dubbo.rpc.TriRpcStatus;\n import org.apache.dubbo.rpc.protocol.tri.TripleConstant;\n import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n import io.netty.handler.codec.http2.DefaultHttp2Headers;\n-import io.netty.handler.codec.http2.Http2Headers;\n import java.nio.charset.StandardCharsets;\n import java.util.Base64;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Locale;\n import java.util.Map;\n-import java.util.stream.Collectors;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_UNSUPPORTED;\n@@ -44,6 +43,11 @@ public class StreamUtils {\n     private static final Base64.Decoder BASE64_DECODER = Base64.getDecoder();\n     private static final Base64.Encoder BASE64_ENCODER = Base64.getEncoder().withoutPadding();\n+\n+    private static final int MAX_LRU_HEADER_MAP_SIZE = 10000;\n+\n+    private static final Map<String, String> lruHeaderMap = new LRU2Cache<>(MAX_LRU_HEADER_MAP_SIZE);\n+\n     public static String encodeBase64ASCII(byte[] in) {\n         byte[] bytes = encodeBase64(in);\n         return new String(bytes, StandardCharsets.US_ASCII);\n@@ -63,9 +67,6 @@ public static Map<String, Object> toAttachments(Map<String, Object> origin) {\n         }\n         Map<String, Object> res = new HashMap<>(origin.size());\n         origin.forEach((k, v) -> {\n-            if (Http2Headers.PseudoHeaderName.isPseudoHeader(k)) {\n-                return;\n-            }\n             if (TripleHeaderEnum.containsExcludeAttachments(k)) {\n                 return;\n             }\n@@ -88,27 +89,26 @@ public static void convertAttachment(DefaultHttp2Headers headers,\n         if (attachments == null) {\n             return;\n         }\n-\n+        Map<String, String> needConvertKey = new HashMap<>();\n         for (Map.Entry<String, Object> entry : attachments.entrySet()) {\n-            final String key = entry.getKey().toLowerCase(Locale.ROOT);\n-            if (Http2Headers.PseudoHeaderName.isPseudoHeader(key)) {\n-                continue;\n+            String key = lruHeaderMap.get(entry.getKey());\n+            if (key == null) {\n+                final String lowerCaseKey = entry.getKey().toLowerCase(Locale.ROOT);\n+                lruHeaderMap.put(entry.getKey(), lowerCaseKey);\n+                key = lowerCaseKey;\n             }\n             if (TripleHeaderEnum.containsExcludeAttachments(key)) {\n                 continue;\n             }\n+            if (needConvertHeaderKey && !key.equals(entry.getKey())) {\n+                needConvertKey.put(key, entry.getKey());\n+            }\n             final Object v = entry.getValue();\n             convertSingleAttachment(headers, key, v);\n         }\n-        if (needConvertHeaderKey) {\n-            Map<String, String> needConvertKey = attachments.entrySet()\n-                .stream()\n-                .filter(it -> !headers.contains(it.getKey()))\n-                .collect(Collectors.toMap(Map.Entry::getKey, it -> it.getKey().toLowerCase(Locale.ROOT)));\n-            if (!needConvertKey.isEmpty()) {\n-                String needConvertJson = JsonUtils.getJson().toJson(needConvertKey);\n-                headers.add(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader(), TriRpcStatus.encodeMessage(needConvertJson));\n-            }\n+        if (!needConvertKey.isEmpty()) {\n+            String needConvertJson = JsonUtils.getJson().toJson(needConvertKey);\n+            headers.add(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader(), TriRpcStatus.encodeMessage(needConvertJson));\n         }\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtilsTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtilsTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtilsTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/StreamUtilsTest.java\n@@ -17,18 +17,99 @@\n package org.apache.dubbo.rpc.protocol.tri.stream;\n+import org.apache.dubbo.common.utils.JsonUtils;\n+import org.apache.dubbo.rpc.TriRpcStatus;\n+import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n+\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n class StreamUtilsTest {\n+\n     @Test\n     void encodeBase64ASCII() {\n         String content = \"\";\n         Assertions.assertArrayEquals(content.getBytes(StandardCharsets.UTF_8),\n             StreamUtils.decodeASCIIByte(StreamUtils.encodeBase64ASCII(content.getBytes(\n                 StandardCharsets.UTF_8))));\n     }\n+\n+    @Test\n+    void testConvertAttachment() throws InterruptedException {\n+        ExecutorService executorService = Executors.newFixedThreadPool(10);\n+\n+        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n+        headers.add(\"key\", \"value\");\n+\n+        Map<String, Object> attachments = new HashMap<>();\n+        attachments.put(TripleHeaderEnum.PATH_KEY.getHeader(), \"value\");\n+        attachments.put(\"key1111\", \"value\");\n+        attachments.put(\"Upper\", \"Upper\");\n+        attachments.put(\"obj\", new Object());\n+\n+        StreamUtils.convertAttachment(headers, attachments, false);\n+        Assertions.assertNull(headers.get(TripleHeaderEnum.PATH_KEY.getHeader()));\n+        Assertions.assertNull(headers.get(\"Upper\"));\n+        Assertions.assertNull(headers.get(\"obj\"));\n+\n+        headers = new DefaultHttp2Headers();\n+        headers.add(\"key\", \"value\");\n+\n+        StreamUtils.convertAttachment(headers, attachments, true);\n+        Assertions.assertNull(headers.get(TripleHeaderEnum.PATH_KEY.getHeader()));\n+        Assertions.assertNull(headers.get(\"Upper\"));\n+        Assertions.assertNull(headers.get(\"obj\"));\n+        String jsonRaw = headers.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()).toString();\n+        String json = TriRpcStatus.decodeMessage(jsonRaw);\n+        System.out.println(jsonRaw + \"---\" + json);\n+        Map<String, String> upperMap = JsonUtils.getJson().toJavaObject(json, Map.class);\n+        Assertions.assertArrayEquals(\"Upper\".getBytes(StandardCharsets.UTF_8), upperMap.get(\"upper\").getBytes(StandardCharsets.UTF_8));\n+\n+        int count = 10000;\n+        CountDownLatch latch = new CountDownLatch(count);\n+        for (int i = 0; i < count; i++) {\n+            String randomKey = \"key\" + i;\n+            String randomValue = \"value\" + i;\n+            Map<String, Object> attachments2 = new HashMap<>();\n+            attachments2.put(TripleHeaderEnum.PATH_KEY.getHeader(), \"value\");\n+            attachments2.put(\"key1111\", \"value\");\n+            attachments2.put(\"Upper\", \"Upper\");\n+            attachments2.put(\"obj\", new Object());\n+            attachments2.put(randomKey, randomValue);\n+            executorService.execute(() -> {\n+                DefaultHttp2Headers headers2 = new DefaultHttp2Headers();\n+                headers2.add(\"key\", \"value\");\n+                StreamUtils.convertAttachment(headers2, attachments2, true);\n+\n+                if (headers2.get(TripleHeaderEnum.PATH_KEY.getHeader()) != null) {\n+                    return;\n+                }\n+                if (headers2.get(\"Upper\") != null) {\n+                    return;\n+                }\n+                if (headers2.get(\"obj\") != null) {\n+                    return;\n+                }\n+                if (!headers2.get(randomKey).toString().equals(randomValue)) {\n+                    return;\n+                }\n+                latch.countDown();\n+            });\n+        }\n+        latch.await(10, TimeUnit.SECONDS);\n+        Assertions.assertEquals(0, latch.getCount());\n+        executorService.shutdown();\n+    }\n+\n+\n }",
    "output": "Fix tri convert upper header"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n@@ -26,7 +26,6 @@\n import org.apache.dubbo.rpc.model.MethodDescriptor;\n import org.apache.dubbo.rpc.model.PackableMethod;\n-import com.google.protobuf.ByteString;\n import com.google.protobuf.Message;\n import java.io.ByteArrayInputStream;",
    "output": "Fix import"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n@@ -306,7 +306,7 @@ void testMultiModuleApplication() throws InterruptedException {\n     @Test\n     void testMultiProviderApplicationsStopOneByOne() {\n-        FrameworkModel.destroyAll();\n+        DubboBootstrap.reset();\n         String version1 = \"1.0\";\n         String version2 = \"2.0\";",
    "output": "Fix uts"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/resource/GlobalResourcesRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/common/resource/GlobalResourcesRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/resource/GlobalResourcesRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/resource/GlobalResourcesRepository.java\n@@ -90,7 +90,7 @@ public ExecutorService getExecutorService() {\n             synchronized (this) {\n                 if (executorService == null || executorService.isShutdown()) {\n                     if (logger.isInfoEnabled()) {\n-                        logger.error(\"Creating global shared handler ...\", new RuntimeException());\n+                        logger.error(\"Creating global shared handler ...\");\n                     }\n                     executorService = Executors.newCachedThreadPool(new NamedThreadFactory(\"Dubbo-global-shared-handler\", true));\n                 }",
    "output": "Remove debug log"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n@@ -306,7 +306,7 @@ void testMultiModuleApplication() throws InterruptedException {\n     @Test\n     void testMultiProviderApplicationsStopOneByOne() {\n-        DubboBootstrap.reset();\n+        FrameworkModel.destroyAll();\n         String version1 = \"1.0\";\n         String version2 = \"2.0\";\n@@ -330,7 +330,7 @@ void testMultiProviderApplicationsStopOneByOne() {\n             providerBootstrap1 = DubboBootstrap.newInstance(frameworkModel);\n             providerBootstrap1.application(\"provider1\")\n-                .registry(registryConfig)\n+                .registry(new RegistryConfig(registryConfig.getAddress()))\n                 .service(serviceConfig1)\n                 .protocol(protocolConfig1)\n                 .start();",
    "output": "Fix testMultiProviderApplicationsStopOneByOne create new framework model"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/resource/GlobalResourcesRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/common/resource/GlobalResourcesRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/resource/GlobalResourcesRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/resource/GlobalResourcesRepository.java\n@@ -89,6 +89,9 @@ public ExecutorService getExecutorService() {\n         if (executorService == null || executorService.isShutdown()) {\n             synchronized (this) {\n                 if (executorService == null || executorService.isShutdown()) {\n+                    if (logger.isInfoEnabled()) {\n+                        logger.info(\"Creating global shared handler ...\");\n+                    }\n                     executorService = Executors.newCachedThreadPool(new NamedThreadFactory(\"Dubbo-global-shared-handler\", true));\n                 }\n             }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/FrameworkExecutorRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/FrameworkExecutorRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/FrameworkExecutorRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/FrameworkExecutorRepository.java\n@@ -200,6 +200,9 @@ public void destroy() {\n         shutdownExecutorServices(registryNotificationExecutorRing.listItems(),\n             \"registryNotificationExecutorRing\");\n+        // mappingRefreshingExecutor\n+        shutdownExecutorService(mappingRefreshingExecutor,\n+            \"mappingRefreshingExecutor\");\n     }\n     private void shutdownExecutorServices(List<? extends ExecutorService> executorServices, String msg) {\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n@@ -74,22 +74,26 @@ public void beforeAll() {\n         registryConfig = new RegistryConfig(ZookeeperRegistryCenterConfig.getConnectionAddress1());\n         // pre-check threads\n-        //precheckUnclosedThreads();\n+        precheckUnclosedThreads();\n     }\n     @AfterEach\n     public void afterAll() throws Exception {\n         FrameworkModel.destroyAll();\n         // check threads\n-        //checkUnclosedThreads();\n+        checkUnclosedThreads();\n     }\n-    private static Map<Thread, StackTraceElement[]> precheckUnclosedThreads() throws IOException {\n+    private static Map<Thread, StackTraceElement[]> precheckUnclosedThreads() {\n         // create a special DubboTestChecker\n         if (testChecker == null) {\n             testChecker = new DubboTestChecker();\n-            testChecker.init(null);\n+            try {\n+                testChecker.init(null);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n             testClassName = MultiInstanceTest.class.getName();\n         }\n         return testChecker.checkUnclosedThreads(testClassName, 0);\ndiff --git a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/DubboTestChecker.java b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/DubboTestChecker.java\n--- a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/DubboTestChecker.java\n+++ b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/DubboTestChecker.java\n@@ -254,6 +254,7 @@ public Map<Thread, StackTraceElement[]> checkUnclosedThreads(String testClassNam\n             .filter(thread -> !StringUtils.startsWithAny(thread.getName(),\n                 \"Reference Handler\", \"Finalizer\", \"Signal Dispatcher\", \"Attach Listener\", \"process reaper\", \"main\" // jvm\n                 , \"surefire-forkedjvm-\" // surefire plugin\n+                , \"globalEventExecutor\"\n             ))\n             .filter(thread -> !unclosedThreadMap.containsKey(thread))\n             .collect(Collectors.toList());",
    "output": "Add some check for MultiInstanceTest * Add some check for MultiInstanceTest * Add some check for MultiInstanceTest * Add some check for MultiInstanceTest"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n@@ -129,9 +129,14 @@ public void addServiceInstancesChangedListener(ServiceInstancesChangedListener l\n     @Override\n     public void removeServiceInstancesChangedListener(ServiceInstancesChangedListener listener) throws IllegalArgumentException {\n         listener.getServiceNames().forEach(serviceName -> {\n-            ZookeeperServiceDiscoveryChangeWatcher watcher = watcherCaches.remove(buildServicePath(serviceName));\n+            String servicePath = buildServicePath(serviceName);\n+            ZookeeperServiceDiscoveryChangeWatcher watcher = watcherCaches.get(servicePath);\n             if (watcher != null) {\n-                watcher.stopWatching();\n+                watcher.getListeners().remove(listener);\n+                if (watcher.getListeners().isEmpty()) {\n+                    watcher.stopWatching();\n+                    watcherCaches.remove(servicePath);\n+                }\n             }\n         });\n     }",
    "output": "Fix zk removeServiceInstancesChangedListener"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFuture.java\n@@ -115,7 +115,7 @@ public void setExecutor(ExecutorService executor) {\n     @Override\n     public boolean cancel(boolean mayInterruptIfRunning) {\n         timeoutTask.cancel();\n-        doReceived(TriRpcStatus.CANCELLED, null);\n+        doReceived(TriRpcStatus.CANCELLED, new AppResponse(TriRpcStatus.CANCELLED.asException()));\n         return true;\n     }\n@@ -127,12 +127,13 @@ private void doReceived(TriRpcStatus status, AppResponse appResponse) {\n         if (isDone() || isCancelled() || isCompletedExceptionally()) {\n             return;\n         }\n-        if (status.isOk()) {\n-            this.complete(appResponse);\n-        } else {\n-            this.completeExceptionally(\n-                status.appendDescription(\"RemoteAddress:\" + address).asException());\n-        }\n+        // Still needs to be discussed here, but for now, that's it\n+        // Remove the judgment of status is ok,\n+        // because the completelyExceptionally method will lead to the onError method in the filter,\n+        // but there are also exceptions in the onResponse in the filter,which is a bit confusing.\n+        // We recommend only handling onResponse in which onError is called for handling\n+        this.complete(appResponse);\n+\n         // the result is returning, but the caller thread may still waiting\n         // to avoid endless waiting for whatever reason, notify caller thread to return.\n@@ -178,7 +179,9 @@ public void run(Timeout timeout) {\n         private void notifyTimeout() {\n             final TriRpcStatus status = TriRpcStatus.DEADLINE_EXCEEDED.withDescription(\n                 getTimeoutMessage());\n-            DeadlineFuture.this.doReceived(status, null);\n+            AppResponse timeoutResponse = new AppResponse();\n+            timeoutResponse.setException(status.asException());\n+            DeadlineFuture.this.doReceived(status, timeoutResponse);\n         }\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFutureTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFutureTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFutureTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/DeadlineFutureTest.java\n@@ -28,8 +28,6 @@\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n-import static org.junit.jupiter.api.Assertions.fail;\n-\n class DeadlineFutureTest {\n     @Test\n@@ -40,12 +38,9 @@ void test() throws InterruptedException, ExecutionException {\n         DeadlineFuture timeout = DeadlineFuture.newFuture(service, method, address, 10,\n             ImmediateEventExecutor.INSTANCE);\n         TimeUnit.MILLISECONDS.sleep(20);\n-        try {\n-            timeout.get();\n-            fail();\n-        } catch (ExecutionException e) {\n-            Assertions.assertTrue(e.getCause() instanceof StatusRpcException);\n-        }\n+        AppResponse timeoutResponse = timeout.get();\n+        Assertions.assertTrue(timeoutResponse.getException() instanceof StatusRpcException);\n+\n         DeadlineFuture success = DeadlineFuture.newFuture(service, method, address, 1000,\n             ImmediateEventExecutor.INSTANCE);",
    "output": "Fix tri filter onError * fix tri filter onError * fix tri filter onError * fix tri filter onError * fix ut"
  },
  {
    "input": "diff --git a/dubbo-native/src/main/java/org/apache/dubbo/remoting/api/pu/PortUnificationTransporter$Adaptive.java b/dubbo-native/src/main/java/org/apache/dubbo/remoting/api/pu/PortUnificationTransporter$Adaptive.java\n--- a/dubbo-native/src/main/java/org/apache/dubbo/remoting/api/pu/PortUnificationTransporter$Adaptive.java\n+++ b/dubbo-native/src/main/java/org/apache/dubbo/remoting/api/pu/PortUnificationTransporter$Adaptive.java\n@@ -18,22 +18,22 @@\n import org.apache.dubbo.rpc.model.ScopeModel;\n import org.apache.dubbo.rpc.model.ScopeModelUtil;\n public class PortUnificationTransporter$Adaptive implements org.apache.dubbo.remoting.api.pu.PortUnificationTransporter {\n-    public org.apache.dubbo.remoting.api.connection.AbstractConnectionClient connect(org.apache.dubbo.common.URL arg0, org.apache.dubbo.remoting.ChannelHandler arg1) throws org.apache.dubbo.remoting.RemotingException {\n-        if (arg0 == null) throw new IllegalArgumentException(\"url == null\");\n-        org.apache.dubbo.common.URL url = arg0;\n-        String extName = url.getParameter(\"client\", url.getParameter(\"transporter\", \"netty4\"));\n-        if(extName == null) throw new IllegalStateException(\"Failed to get extension (org.apache.dubbo.remoting.api.pu.PortUnificationTransporter) name from url (\" + url.toString() + \") use keys([client, transporter])\");\n-        ScopeModel scopeModel = ScopeModelUtil.getOrDefault(url.getScopeModel(), org.apache.dubbo.remoting.api.pu.PortUnificationTransporter.class);\n-        org.apache.dubbo.remoting.api.pu.PortUnificationTransporter extension = (org.apache.dubbo.remoting.api.pu.PortUnificationTransporter)scopeModel.getExtensionLoader(org.apache.dubbo.remoting.api.pu.PortUnificationTransporter.class).getExtension(extName);\n-        return extension.connect(arg0, arg1);\n-    }\n-    public org.apache.dubbo.remoting.api.pu.AbstractPortUnificationServer bind(org.apache.dubbo.common.URL arg0, org.apache.dubbo.remoting.ChannelHandler arg1) throws org.apache.dubbo.remoting.RemotingException {\n-        if (arg0 == null) throw new IllegalArgumentException(\"url == null\");\n-        org.apache.dubbo.common.URL url = arg0;\n-        String extName = url.getParameter(\"server\", url.getParameter(\"transporter\", \"netty4\"));\n-        if(extName == null) throw new IllegalStateException(\"Failed to get extension (org.apache.dubbo.remoting.api.pu.PortUnificationTransporter) name from url (\" + url.toString() + \") use keys([server, transporter])\");\n-        ScopeModel scopeModel = ScopeModelUtil.getOrDefault(url.getScopeModel(), org.apache.dubbo.remoting.api.pu.PortUnificationTransporter.class);\n-        org.apache.dubbo.remoting.api.pu.PortUnificationTransporter extension = (org.apache.dubbo.remoting.api.pu.PortUnificationTransporter)scopeModel.getExtensionLoader(org.apache.dubbo.remoting.api.pu.PortUnificationTransporter.class).getExtension(extName);\n-        return extension.bind(arg0, arg1);\n-    }\n+public org.apache.dubbo.remoting.api.connection.AbstractConnectionClient connect(org.apache.dubbo.common.URL arg0, org.apache.dubbo.remoting.ChannelHandler arg1) throws org.apache.dubbo.remoting.RemotingException {\n+if (arg0 == null) throw new IllegalArgumentException(\"url == null\");\n+org.apache.dubbo.common.URL url = arg0;\n+String extName = url.getParameter(\"client\", url.getParameter(\"transporter\", \"netty4\"));\n+if(extName == null) throw new IllegalStateException(\"Failed to get extension (org.apache.dubbo.remoting.api.pu.PortUnificationTransporter) name from url (\" + url.toString() + \") use keys([client, transporter])\");\n+ScopeModel scopeModel = ScopeModelUtil.getOrDefault(url.getScopeModel(), org.apache.dubbo.remoting.api.pu.PortUnificationTransporter.class);\n+org.apache.dubbo.remoting.api.pu.PortUnificationTransporter extension = (org.apache.dubbo.remoting.api.pu.PortUnificationTransporter)scopeModel.getExtensionLoader(org.apache.dubbo.remoting.api.pu.PortUnificationTransporter.class).getExtension(extName);\n+return extension.connect(arg0, arg1);\n+}\n+public org.apache.dubbo.remoting.api.pu.AbstractPortUnificationServer bind(org.apache.dubbo.common.URL arg0, org.apache.dubbo.remoting.ChannelHandler arg1) throws org.apache.dubbo.remoting.RemotingException {\n+if (arg0 == null) throw new IllegalArgumentException(\"url == null\");\n+org.apache.dubbo.common.URL url = arg0;\n+String extName = url.getParameter(\"server\", url.getParameter(\"transporter\", \"netty4\"));\n+if(extName == null) throw new IllegalStateException(\"Failed to get extension (org.apache.dubbo.remoting.api.pu.PortUnificationTransporter) name from url (\" + url.toString() + \") use keys([server, transporter])\");\n+ScopeModel scopeModel = ScopeModelUtil.getOrDefault(url.getScopeModel(), org.apache.dubbo.remoting.api.pu.PortUnificationTransporter.class);\n+org.apache.dubbo.remoting.api.pu.PortUnificationTransporter extension = (org.apache.dubbo.remoting.api.pu.PortUnificationTransporter)scopeModel.getExtensionLoader(org.apache.dubbo.remoting.api.pu.PortUnificationTransporter.class).getExtension(extName);\n+return extension.bind(arg0, arg1);\n+}\n }",
    "output": "Fix native reflect-config.json"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-zookeeper-curator5/src/main/java/org/apache/dubbo/remoting/zookeeper/curator5/Curator5ZookeeperClient.java b/dubbo-remoting/dubbo-remoting-zookeeper-curator5/src/main/java/org/apache/dubbo/remoting/zookeeper/curator5/Curator5ZookeeperClient.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper-curator5/src/main/java/org/apache/dubbo/remoting/zookeeper/curator5/Curator5ZookeeperClient.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper-curator5/src/main/java/org/apache/dubbo/remoting/zookeeper/curator5/Curator5ZookeeperClient.java\n@@ -98,7 +98,7 @@ public List<ACL> getAclForPath(String path) {\n             boolean connected = client.blockUntilConnected(timeout, TimeUnit.MILLISECONDS);\n             if (!connected) {\n-                IllegalStateException illegalStateException = new IllegalStateException(\"zookeeper not connected\");\n+                IllegalStateException illegalStateException = new IllegalStateException(\"zookeeper not connected, the address is: \" + url);\n                 // 5-1 Failed to connect to configuration center.\n                 logger.error(CONFIG_FAILED_CONNECT_REGISTRY, \"Zookeeper server offline\", \"\",\ndiff --git a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n@@ -102,7 +102,7 @@ public List<ACL> getAclForPath(String path) {\n             boolean connected = client.blockUntilConnected(timeout, TimeUnit.MILLISECONDS);\n             if (!connected) {\n-                IllegalStateException illegalStateException = new IllegalStateException(\"zookeeper not connected\");\n+                IllegalStateException illegalStateException = new IllegalStateException(\"zookeeper not connected, the address is: \" + url);\n                 // 5-1 Failed to connect to configuration center.\n                 logger.error(CONFIG_FAILED_CONNECT_REGISTRY, \"Zookeeper server offline\", \"\",",
    "output": "Add more information when zk not connected"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Constants.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Constants.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Constants.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Constants.java\n@@ -105,4 +105,8 @@ public interface Constants {\n     String H2_SETTINGS_MAX_HEADER_LIST_SIZE_KEY = \"dubbo.rpc.tri.max-header-list-size\";\n     String H2_SUPPORT_NO_LOWER_HEADER_KEY = \"dubbo.rpc.tri.support-no-lower-header\";\n+\n+    String H2_IGNORE_1_0_0_KEY = \"dubbo.rpc.tri.ignore-1.0.0-version\";\n+\n+    String H2_RESOLVE_FALLBACK_TO_DEFAULT_KEY = \"dubbo.rpc.tri.resolve-fallback-to-default\";\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/RequestMetadata.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/RequestMetadata.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/RequestMetadata.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/RequestMetadata.java\n@@ -48,6 +48,7 @@ public class RequestMetadata {\n     public PackableMethod packableMethod;\n     public Map<String, Object> attachments;\n     public boolean convertNoLowerHeader;\n+    public boolean ignoreDefaultVersion;\n     public DefaultHttp2Headers toHeaders() {\n         DefaultHttp2Headers header = new DefaultHttp2Headers(false);\n@@ -58,7 +59,7 @@ public DefaultHttp2Headers toHeaders() {\n             .set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.CONTENT_PROTO)\n             .set(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS);\n         setIfNotNull(header, TripleHeaderEnum.TIMEOUT.getHeader(), timeout);\n-        if (!\"1.0.0\".equals(version)) {\n+        if (!ignoreDefaultVersion || !\"1.0.0\".equals(version)) {\n             setIfNotNull(header, TripleHeaderEnum.SERVICE_VERSION.getHeader(), version);\n         }\n         setIfNotNull(header, TripleHeaderEnum.SERVICE_GROUP.getHeader(), group);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -242,6 +242,7 @@ RequestMetadata createRequest(MethodDescriptor methodDescriptor, Invocation invo\n             meta.packableMethod = ReflectionPackableMethod.init(methodDescriptor, url);\n         }\n         meta.convertNoLowerHeader = TripleProtocol.CONVERT_NO_LOWER_HEADER;\n+        meta.ignoreDefaultVersion = TripleProtocol.IGNORE_1_0_0_VERSION;\n         meta.method = methodDescriptor;\n         meta.scheme = getSchemeFromUrl(url);\n         // TODO read compressor from config\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n@@ -50,6 +50,8 @@\n import java.util.Set;\n import java.util.concurrent.ExecutorService;\n+import static org.apache.dubbo.rpc.Constants.H2_IGNORE_1_0_0_KEY;\n+import static org.apache.dubbo.rpc.Constants.H2_RESOLVE_FALLBACK_TO_DEFAULT_KEY;\n import static org.apache.dubbo.config.Constants.SERVER_THREAD_POOL_NAME;\n import static org.apache.dubbo.rpc.Constants.H2_SUPPORT_NO_LOWER_HEADER_KEY;\n@@ -67,6 +69,10 @@ public class TripleProtocol extends AbstractProtocol {\n      */\n     public static boolean CONVERT_NO_LOWER_HEADER = false;\n+    public static boolean IGNORE_1_0_0_VERSION = false;\n+\n+    public static boolean RESOLVE_FALLBACK_TO_DEFAULT = false;\n+\n     private boolean versionChecked = false;\n@@ -77,6 +83,10 @@ public TripleProtocol(FrameworkModel frameworkModel) {\n             .getDefaultExtension();\n         CONVERT_NO_LOWER_HEADER = ConfigurationUtils.getEnvConfiguration(ApplicationModel.defaultModel())\n             .getBoolean(H2_SUPPORT_NO_LOWER_HEADER_KEY, true);\n+        IGNORE_1_0_0_VERSION = ConfigurationUtils.getEnvConfiguration(ApplicationModel.defaultModel())\n+            .getBoolean(H2_IGNORE_1_0_0_KEY, false);\n+        RESOLVE_FALLBACK_TO_DEFAULT = ConfigurationUtils.getEnvConfiguration(ApplicationModel.defaultModel())\n+            .getBoolean(H2_RESOLVE_FALLBACK_TO_DEFAULT_KEY, false);\n         Set<String> supported = frameworkModel.getExtensionLoader(DeCompressor.class)\n             .getSupportedExtensions();\n         this.acceptEncodings = String.join(\",\", supported);\n@@ -111,7 +121,9 @@ public void afterUnExport() {\n         invokers.add(invoker);\n         pathResolver.add(url.getServiceKey(), invoker);\n-        pathResolver.add(url.getServiceModel().getServiceModel().getInterfaceName(), invoker);\n+        if (RESOLVE_FALLBACK_TO_DEFAULT) {\n+            pathResolver.add(url.getServiceModel().getServiceModel().getInterfaceName(), invoker);\n+        }\n         // set service status\n         triBuiltinService.getHealthStatusManager()\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java\n@@ -17,7 +17,6 @@\n package org.apache.dubbo.rpc.protocol.tri.stream;\n-import io.netty.handler.codec.http2.Http2StreamChannel;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n@@ -57,6 +56,7 @@\n import io.netty.handler.codec.http2.DefaultHttp2Headers;\n import io.netty.handler.codec.http2.Http2Error;\n import io.netty.handler.codec.http2.Http2Headers;\n+import io.netty.handler.codec.http2.Http2StreamChannel;\n import io.netty.util.concurrent.Future;\n import java.io.IOException;\n@@ -288,10 +288,10 @@ private Invoker<?> getInvoker(Http2Headers headers, String serviceName) {\n                 TripleHeaderEnum.SERVICE_GROUP.getHeader()).toString() : null;\n         final String key = URL.buildKey(serviceName, group, version);\n         Invoker<?> invoker = pathResolver.resolve(key);\n-        if (invoker == null) {\n+        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n             invoker = pathResolver.resolve(URL.buildKey(serviceName, group, \"1.0.0\"));\n         }\n-        if (invoker == null) {\n+        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n             invoker = pathResolver.resolve(serviceName);\n         }\n         return invoker;",
    "output": "Fix triple default version"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -664,47 +664,7 @@ public void refresh() {\n         try {\n             // check and init before do refresh\n             preProcessRefresh();\n-\n-            Environment environment = getScopeModel().getModelEnvironment();\n-            List<Map<String, String>> configurationMaps = environment.getConfigurationMaps();\n-\n-            // Search props starts with PREFIX in order\n-            String preferredPrefix = null;\n-            List<String> prefixes = getPrefixes();\n-            for (String prefix : prefixes) {\n-                if (ConfigurationUtils.hasSubProperties(configurationMaps, prefix)) {\n-                    preferredPrefix = prefix;\n-                    break;\n-                }\n-            }\n-            if (preferredPrefix == null) {\n-                preferredPrefix = prefixes.get(0);\n-            }\n-            // Extract sub props (which key was starts with preferredPrefix)\n-            Collection<Map<String, String>> instanceConfigMaps = environment.getConfigurationMaps(this, preferredPrefix);\n-            Map<String, String> subProperties = ConfigurationUtils.getSubProperties(instanceConfigMaps, preferredPrefix);\n-            InmemoryConfiguration subPropsConfiguration = new InmemoryConfiguration(subProperties);\n-\n-            if (logger.isDebugEnabled()) {\n-                String idOrName = \"\";\n-                if (StringUtils.hasText(this.getId())) {\n-                    idOrName = \"[id=\" + this.getId() + \"]\";\n-                } else {\n-                    String name = ReflectUtils.getProperty(this, \"getName\");\n-                    if (StringUtils.hasText(name)) {\n-                        idOrName = \"[name=\" + name + \"]\";\n-                    }\n-                }\n-                logger.debug(\"Refreshing \" + this.getClass().getSimpleName() + idOrName +\n-                    \" with prefix [\" + preferredPrefix +\n-                    \"], extracted props: \" + subProperties);\n-            }\n-\n-            assignProperties(this, environment, subProperties, subPropsConfiguration);\n-\n-            // process extra refresh of subclass, e.g. refresh method configs\n-            processExtraRefresh(preferredPrefix, subPropsConfiguration);\n-\n+            refreshWithPrefixes(getPrefixes(), getConfigMode());\n         } catch (Exception e) {\n             logger.error(COMMON_FAILED_OVERRIDE_FIELD, \"\", \"\", \"Failed to override field value of config bean: \" + this, e);\n             throw new IllegalStateException(\"Failed to override field value of config bean: \" + this, e);\n@@ -714,12 +674,53 @@ public void refresh() {\n         refreshed.set(true);\n     }\n-    private void assignProperties(Object obj, Environment environment, Map<String, String> properties, InmemoryConfiguration configuration) {\n+    protected void refreshWithPrefixes(List<String> prefixes, ConfigMode configMode) {\n+        Environment environment = getScopeModel().getModelEnvironment();\n+        List<Map<String, String>> configurationMaps = environment.getConfigurationMaps();\n+\n+        // Search props starts with PREFIX in order\n+        String preferredPrefix = null;\n+        for (String prefix : prefixes) {\n+            if (ConfigurationUtils.hasSubProperties(configurationMaps, prefix)) {\n+                preferredPrefix = prefix;\n+                break;\n+            }\n+        }\n+        if (preferredPrefix == null) {\n+            preferredPrefix = prefixes.get(0);\n+        }\n+        // Extract sub props (which key was starts with preferredPrefix)\n+        Collection<Map<String, String>> instanceConfigMaps = environment.getConfigurationMaps(this, preferredPrefix);\n+        Map<String, String> subProperties = ConfigurationUtils.getSubProperties(instanceConfigMaps, preferredPrefix);\n+        InmemoryConfiguration subPropsConfiguration = new InmemoryConfiguration(subProperties);\n+\n+        if (logger.isDebugEnabled()) {\n+            String idOrName = \"\";\n+            if (StringUtils.hasText(this.getId())) {\n+                idOrName = \"[id=\" + this.getId() + \"]\";\n+            } else {\n+                String name = ReflectUtils.getProperty(this, \"getName\");\n+                if (StringUtils.hasText(name)) {\n+                    idOrName = \"[name=\" + name + \"]\";\n+                }\n+            }\n+            logger.debug(\"Refreshing \" + this.getClass().getSimpleName() + idOrName +\n+                \" with prefix [\" + preferredPrefix +\n+                \"], extracted props: \" + subProperties);\n+        }\n+\n+        assignProperties(this, environment, subProperties, subPropsConfiguration, configMode);\n+\n+        // process extra refresh of subclass, e.g. refresh method configs\n+        processExtraRefresh(preferredPrefix, subPropsConfiguration);\n+    }\n+\n+    private void assignProperties(Object obj, Environment environment, Map<String, String> properties, InmemoryConfiguration configuration, ConfigMode configMode) {\n         // if old one (this) contains non-null value, do not override\n-        boolean overrideIfAbsent = getConfigMode() == ConfigMode.OVERRIDE_IF_ABSENT;\n+        boolean overrideIfAbsent = configMode == ConfigMode.OVERRIDE_IF_ABSENT;\n         // even if old one (this) contains non-null value, do override\n-        boolean overrideAll = getConfigMode() == ConfigMode.OVERRIDE_ALL;\n+        boolean overrideAll = configMode == ConfigMode.OVERRIDE_ALL;\n         // loop methods, get override value and set the new value back to method\n         List<Method> methods = MethodUtils.getMethods(obj.getClass(), method -> method.getDeclaringClass() != Object.class);\n@@ -807,7 +808,7 @@ private void assignProperties(Object obj, Environment environment, Map<String, S\n                     String fieldName = MethodUtils.extractFieldName(method);\n                     Map<String, String> subProperties = ConfigurationUtils.getSubProperties(properties, fieldName);\n                     InmemoryConfiguration subPropsConfiguration = new InmemoryConfiguration(subProperties);\n-                    assignProperties(inner, environment, subProperties, subPropsConfiguration);\n+                    assignProperties(inner, environment, subProperties, subPropsConfiguration, configMode);\n                     method.invoke(obj, inner);\n                 } catch (ReflectiveOperationException e) {\n                     throw new IllegalStateException(\"Cannot assign nested class when refreshing config: \" + obj.getClass().getName(), e);\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.common.utils.RegexProperties;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.annotation.Reference;\n+import org.apache.dubbo.config.context.ConfigMode;\n import org.apache.dubbo.config.support.Parameter;\n import org.apache.dubbo.rpc.model.ModuleModel;\n import org.apache.dubbo.rpc.model.ScopeModel;\n@@ -134,6 +135,8 @@ protected void preProcessRefresh() {\n                 .getDefaultConsumer()\n                 .orElseThrow(() -> new IllegalStateException(\"Default consumer is not initialized\"));\n         }\n+        // try set properties from `dubbo.reference` if not set in current config\n+        refreshWithPrefixes(super.getPrefixes(), ConfigMode.OVERRIDE_IF_ABSENT);\n     }\n     @Override\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.annotation.Service;\n+import org.apache.dubbo.config.context.ConfigMode;\n import org.apache.dubbo.config.support.Parameter;\n import org.apache.dubbo.rpc.model.ModuleModel;\n import org.apache.dubbo.rpc.model.ScopeModel;\n@@ -174,6 +175,8 @@ protected void preProcessRefresh() {\n                     .getDefaultProvider()\n                     .orElseThrow(() -> new IllegalStateException(\"Default provider is not initialized\"));\n         }\n+        // try set properties from `dubbo.service` if not set in current config\n+        refreshWithPrefixes(super.getPrefixes(), ConfigMode.OVERRIDE_IF_ABSENT);\n     }\n     @Override",
    "output": "Fix dubbo.reference not work in 3.x"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JdkCompiler.java b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JdkCompiler.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JdkCompiler.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JdkCompiler.java\n@@ -120,7 +120,8 @@ public Class<?> doCompile(ClassLoader ignored, String name, String sourceCode) t\n         Boolean result = compiler.getTask(null, javaFileManager, diagnosticCollector, options,\n                 null, Collections.singletonList(javaFileObject)).call();\n         if (result == null || !result) {\n-            throw new IllegalStateException(\"Compilation failed. class: \" + name + \", diagnostics: \" + diagnosticCollector);\n+            throw new IllegalStateException(\"Compilation failed. class: \" + name + \", diagnostics: \"\n+                + diagnosticCollector.getDiagnostics());\n         }\n         return classLoader.loadClass(name);\n     }",
    "output": "Fix diagnostics log message errors"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java\n@@ -16,30 +16,33 @@\n package org.apache.dubbo.rpc.protocol.tri;\n+import org.apache.dubbo.common.config.Configuration;\n+import org.apache.dubbo.common.config.ConfigurationUtils;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n+\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2ConnectionAdapter;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2RemoteFlowController;\n+import io.netty.handler.codec.http2.Http2Stream;\n+import io.netty.handler.codec.http2.Http2StreamVisitor;\n+import io.netty.handler.codec.http2.StreamByteDistributor;\n+import io.netty.handler.codec.http2.WeightedFairQueueByteDistributor;\n import io.netty.util.internal.UnstableApi;\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n import java.util.ArrayDeque;\n import java.util.Deque;\n-import io.netty.handler.codec.http2.Http2Error;\n+\n+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;\n+import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_WEIGHT;\n+import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_WEIGHT;\n import static io.netty.handler.codec.http2.Http2Error.FLOW_CONTROL_ERROR;\n import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;\n import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;\n-import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;\n-import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_WEIGHT;\n-import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_WEIGHT;\n-import io.netty.handler.codec.http2.WeightedFairQueueByteDistributor;\n-import io.netty.handler.codec.http2.StreamByteDistributor;\n-import io.netty.handler.codec.http2.Http2StreamVisitor;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2ConnectionAdapter;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2RemoteFlowController;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import org.apache.dubbo.common.config.Configuration;\n-import org.apache.dubbo.common.config.ConfigurationUtils;\n-import org.apache.dubbo.rpc.model.ApplicationModel;\n import static io.netty.handler.codec.http2.Http2Exception.streamError;\n import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_LOCAL;\n import static io.netty.util.internal.ObjectUtil.checkNotNull;\n@@ -60,30 +63,33 @@ public class TriHttp2RemoteFlowController implements Http2RemoteFlowController {\n     private final Http2Connection.PropertyKey stateKey;\n     private final StreamByteDistributor streamByteDistributor;\n     private final FlowState connectionState;\n-    private Configuration config = ConfigurationUtils.getGlobalConfiguration(\n-        ApplicationModel.defaultModel());\n-    private int initialWindowSize = config.getInt(H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY, DEFAULT_WINDOW_SIZE);\n+    private final Configuration config;\n+    private int initialWindowSize;\n     private WritabilityMonitor monitor;\n     private ChannelHandlerContext ctx;\n-    public TriHttp2RemoteFlowController(Http2Connection connection) {\n-        this(connection, (Listener) null);\n+    public TriHttp2RemoteFlowController(Http2Connection connection, ApplicationModel applicationModel) {\n+        this(connection, (Listener) null, applicationModel);\n     }\n     public TriHttp2RemoteFlowController(Http2Connection connection,\n-                                        StreamByteDistributor streamByteDistributor) {\n-        this(connection, streamByteDistributor, null);\n+                                        StreamByteDistributor streamByteDistributor,\n+                                        ApplicationModel applicationModel) {\n+        this(connection, streamByteDistributor, null, applicationModel);\n     }\n-    public TriHttp2RemoteFlowController(Http2Connection connection, final Listener listener) {\n-        this(connection, new WeightedFairQueueByteDistributor(connection), listener);\n+    public TriHttp2RemoteFlowController(Http2Connection connection, final Listener listener, ApplicationModel applicationModel) {\n+        this(connection, new WeightedFairQueueByteDistributor(connection), listener, applicationModel);\n     }\n     public TriHttp2RemoteFlowController(Http2Connection connection,\n                                         StreamByteDistributor streamByteDistributor,\n-                                        final Listener listener) {\n+                                        final Listener listener,\n+                                        ApplicationModel applicationModel) {\n         this.connection = checkNotNull(connection, \"connection\");\n         this.streamByteDistributor = checkNotNull(streamByteDistributor, \"streamWriteDistributor\");\n+        this.config = ConfigurationUtils.getGlobalConfiguration(applicationModel);\n+        this.initialWindowSize = config.getInt(H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY, DEFAULT_WINDOW_SIZE);\n         // Add a flow state for the connection.\n         stateKey = connection.newKey();\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -127,7 +127,7 @@ public void configServerProtocolHandler(URL url, ChannelOperator operator) {\n             .frameLogger(SERVER_LOGGER)\n             .build();\n         ExecutorSupport executorSupport = ExecutorRepository.getInstance(url.getOrDefaultApplicationModel()).getExecutorSupport(url);\n-        codec.connection().remote().flowController(new TriHttp2RemoteFlowController(codec.connection()));\n+        codec.connection().remote().flowController(new TriHttp2RemoteFlowController(codec.connection(), url.getOrDefaultApplicationModel()));\n         codec.connection().local().flowController().frameWriter(codec.encoder().frameWriter());\n         TripleWriteQueue writeQueue = new TripleWriteQueue();\n         final Http2MultiplexHandler handler = new Http2MultiplexHandler(\n@@ -166,7 +166,7 @@ public void configClientPipeline(URL url, ChannelOperator operator, SslContext s\n                     DEFAULT_MAX_HEADER_LIST_SIZE)))\n             .frameLogger(CLIENT_LOGGER)\n             .build();\n-        codec.connection().remote().flowController(new TriHttp2RemoteFlowController(codec.connection()));\n+        codec.connection().remote().flowController(new TriHttp2RemoteFlowController(codec.connection(), url.getOrDefaultApplicationModel()));\n         codec.connection().local().flowController().frameWriter(codec.encoder().frameWriter());\n         final Http2MultiplexHandler handler = new Http2MultiplexHandler(\n             new TripleClientHandler(frameworkModel));",
    "output": "Fix flow controller trigger application init"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n@@ -81,7 +81,7 @@ public Environment(ScopeModel scopeModel) {\n     public void initialize() throws IllegalStateException {\n         if (initialized.compareAndSet(false, true)) {\n             this.propertiesConfiguration = new PropertiesConfiguration(scopeModel);\n-            this.systemConfiguration = new SystemConfiguration();\n+            this.systemConfiguration = new SystemConfiguration(scopeModel);\n             this.environmentConfiguration = new EnvironmentConfiguration();\n             this.externalConfiguration = new InmemoryConfiguration(\"ExternalConfig\");\n             this.appExternalConfiguration = new InmemoryConfiguration(\"AppExternalConfig\");\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/SystemConfiguration.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/SystemConfiguration.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/SystemConfiguration.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/SystemConfiguration.java\n@@ -17,8 +17,18 @@\n package org.apache.dubbo.common.config;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository;\n+import org.apache.dubbo.rpc.model.ScopeModel;\n+import org.apache.dubbo.rpc.model.ScopeModelUtil;\n+\n import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n /**\n  * FIXME: is this really necessary? PropertiesConfiguration should have already covered this:\n@@ -28,8 +38,23 @@\n  */\n public class SystemConfiguration implements Configuration {\n+    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(SystemConfiguration.class);\n+\n     private final Map<String, Object> cache = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService sharedScheduledExecutor;\n+\n+    public SystemConfiguration(ScopeModel scopeModel) {\n+        sharedScheduledExecutor = ScopeModelUtil.getFrameworkModel(scopeModel).getBeanFactory()\n+            .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor();\n+        sharedScheduledExecutor.scheduleWithFixedDelay(() -> {\n+            if (!cache.isEmpty()) {\n+                Set<String> keys = cache.keySet();\n+                keys.forEach((key) -> overwriteCache(key, System.getProperty(key)));\n+            }\n+        }, 60000, 60000, TimeUnit.MILLISECONDS);\n+    }\n+\n     @Override\n     public Object getInternalProperty(String key) {\n         if (cache.containsKey(key)) {\n@@ -72,8 +97,14 @@ public void clearCache() {\n     }\n-\n     public Map<String, String> getProperties() {\n-        return (Map) System.getProperties();\n+        Properties properties = System.getProperties();\n+        Map<String, String> res = new ConcurrentHashMap<>(properties.size());\n+        try {\n+            res.putAll((Map) properties);\n+        } catch (Exception e) {\n+            logger.warn(\"System property get failed\", e);\n+        }\n+        return res;\n     }\n }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/config/SystemConfigurationTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/config/SystemConfigurationTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/config/SystemConfigurationTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/config/SystemConfigurationTest.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.common.config;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n@@ -44,7 +45,7 @@ class SystemConfigurationTest {\n     @BeforeEach\n     public void init() {\n-        sysConfig = new SystemConfiguration();\n+        sysConfig = new SystemConfiguration(ApplicationModel.defaultModel().getDefaultModule());\n     }\n     /**\n@@ -114,4 +115,4 @@ enum ConfigMock {\n         MockTwo\n     }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java b/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n@@ -393,22 +393,33 @@ void testGetConfigByIdOrName() {\n     @Test\n     void testLoadConfigsOfTypeFromProps() {\n         try {\n+            System.setProperty(\"dubbo.protocols.dubbo1.port\", \"20880\");\n+            System.setProperty(\"dubbo.protocols.dubbo2.port\", \"20881\");\n+            System.setProperty(\"dubbo.protocols.rest1.port\", \"8080\");\n+            System.setProperty(\"dubbo.protocols.rest2.port\", \"8081\");\n+\n+            ApplicationModel.defaultModel().destroy();\n+            ApplicationModel applicationModel = ApplicationModel.defaultModel();\n+            configManager = applicationModel.getApplicationConfigManager();\n+            moduleConfigManager = applicationModel.getDefaultModule().getConfigManager();\n+\n             // dubbo.application.enable-file-cache = false\n             configManager.loadConfigsOfTypeFromProps(ApplicationConfig.class);\n             Optional<ApplicationConfig> application = configManager.getApplication();\n             Assertions.assertTrue(application.isPresent());\n             configManager.removeConfig(application.get());\n-            System.setProperty(\"dubbo.protocols.dubbo1.port\", \"20880\");\n-            System.setProperty(\"dubbo.protocols.dubbo2.port\", \"20881\");\n-            System.setProperty(\"dubbo.protocols.rest1.port\", \"8080\");\n-            System.setProperty(\"dubbo.protocols.rest2.port\", \"8081\");\n             configManager.loadConfigsOfTypeFromProps(ProtocolConfig.class);\n             Collection<ProtocolConfig> protocols = configManager.getProtocols();\n             Assertions.assertEquals(protocols.size(), 4);\n             System.setProperty(\"dubbo.applications.app1.name\", \"app-demo1\");\n             System.setProperty(\"dubbo.applications.app2.name\", \"app-demo2\");\n+\n+            ApplicationModel.defaultModel().destroy();\n+            applicationModel = ApplicationModel.defaultModel();\n+            configManager = applicationModel.getApplicationConfigManager();\n+            moduleConfigManager = applicationModel.getDefaultModule().getConfigManager();\n             try {\n                 configManager.loadConfigsOfTypeFromProps(ApplicationConfig.class);\n                 Assertions.fail();\n@@ -456,4 +467,4 @@ void testLoadConfig() {\n         Assertions.assertFalse(moduleConfigManager.getConsumers().isEmpty());\n     }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/MultiInstanceTest.java\n@@ -375,7 +375,7 @@ void testMultiProviderApplicationsStopOneByOne() {\n             // stop provider app 2 and check threads\n             providerBootstrap2.stop();\n             // shutdown register center after dubbo application to avoid unregister services blocking\n-            checkUnclosedThreadsOfApp(stackTraces2, \"Found unclosed threads of app 2: \", null);\n+            checkUnclosedThreadsOfApp(stackTraces2, \"Found unclosed threads of app 2: \", new String[]{\"Dubbo-framework-shared-scheduler\"});\n         } finally {\n             if (providerBootstrap1 != null) {",
    "output": "Add refresh system properties logic"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java\n@@ -138,7 +138,9 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)\n     private void enableSsl(ChannelHandlerContext ctx) {\n         ChannelPipeline p = ctx.pipeline();\n-        p.addLast(\"ssl\", sslCtx.newHandler(ctx.alloc()));\n+        if (sslCtx != null) {\n+            p.addLast(\"ssl\", sslCtx.newHandler(ctx.alloc()));\n+        }\n         p.addLast(\"unificationA\",\n             new NettyPortUnificationServerHandler(url, sslCtx, false, protocols,\n                 handler, dubboChannels, urlMapper, handlerMapper));",
    "output": "Fix ssl npe"
  },
  {
    "input": "diff --git a/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesMeshEnvListener.java b/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesMeshEnvListener.java\n--- a/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesMeshEnvListener.java\n+++ b/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesMeshEnvListener.java\n@@ -36,9 +36,9 @@\n public class KubernetesMeshEnvListener implements MeshEnvListener {\n     public static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(KubernetesMeshEnvListener.class);\n-    private volatile static boolean usingApiServer = false;\n-    private volatile static KubernetesClient kubernetesClient;\n-    private volatile static String namespace;\n+    private static volatile boolean usingApiServer = false;\n+    private static volatile KubernetesClient kubernetesClient;\n+    private static volatile String namespace;\n     private final Map<String, MeshAppRuleListener> appRuleListenerMap = new ConcurrentHashMap<>();\n@@ -103,11 +103,11 @@ public void eventReceived(Action action, GenericKubernetesResource resource) {\n                             }\n                         }\n-                    @Override\n-                    public void onClose(WatcherException cause) {\n-                        // ignore\n-                    }\n-                });\n+                        @Override\n+                        public void onClose(WatcherException cause) {\n+                            // ignore\n+                        }\n+                    });\n             vsAppWatch.put(appName, watch);\n             try {\n                 GenericKubernetesResource vsRule = kubernetesClient\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/listener/ListenerInvokerWrapper.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/listener/ListenerInvokerWrapper.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/listener/ListenerInvokerWrapper.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/listener/ListenerInvokerWrapper.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.rpc.listener;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.constants.LoggerCodeConstants;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.CollectionUtils;\n@@ -100,11 +101,12 @@ private void listenerEvent(Consumer<InvokerListener> consumer) {\n                     try {\n                         consumer.accept(listener);\n                     } catch (RuntimeException t) {\n-                        logger.error(t.getMessage(), t);\n+                        logger.error(LoggerCodeConstants.INTERNAL_ERROR, \"wrapped listener internal error\", \"\", t.getMessage(), t);\n                         exception = t;\n                     }\n                 }\n             }\n+\n             if (exception != null) {\n                 throw exception;\n             }",
    "output": "Add error code support of ListenerInvokerWrapper"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/AbstractMetricsReporter.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/AbstractMetricsReporter.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/AbstractMetricsReporter.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/AbstractMetricsReporter.java\n@@ -57,6 +57,7 @@ public abstract class AbstractMetricsReporter implements MetricsReporter {\n     private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(AbstractMetricsReporter.class);\n     private final AtomicBoolean initialized = new AtomicBoolean(false);\n+    private final AtomicBoolean addGlobalRegistry = new AtomicBoolean(false);\n     protected final URL url;\n     protected final List<MetricsCollector> collectors = new ArrayList<>();\n@@ -91,8 +92,9 @@ protected void addMeterRegistry(MeterRegistry registry) {\n     }\n     private void addDubboMeterRegistry(){\n         MeterRegistry globalRegistry = DubboMetrics.globalRegistry;\n-        if(globalRegistry != null){\n+        if(globalRegistry != null && !addGlobalRegistry.get()){\n             compositeRegistry.add(globalRegistry);\n+            addGlobalRegistry.set(true);\n         }\n     }\n@@ -122,6 +124,7 @@ private void scheduleMetricsCollectorSyncJob() {\n         NamedThreadFactory threadFactory = new NamedThreadFactory(\"metrics-collector-sync-job\", true);\n         collectorSyncJobExecutor = Executors.newScheduledThreadPool(1, threadFactory);\n         collectorSyncJobExecutor.scheduleWithFixedDelay(() -> {\n+            addDubboMeterRegistry();\n             collectors.forEach(collector -> {\n                 List<MetricSample> samples = collector.collect();\n                 for (MetricSample sample : samples) {\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-actuator/src/main/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboMetricsAutoConfiguration.java b/dubbo-spring-boot/dubbo-spring-boot-actuator/src/main/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboMetricsAutoConfiguration.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-actuator/src/main/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboMetricsAutoConfiguration.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-actuator/src/main/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboMetricsAutoConfiguration.java\n@@ -20,6 +20,8 @@\n import io.micrometer.core.instrument.MeterRegistry;\n import org.apache.dubbo.metrics.DubboMetrics;\n import org.apache.dubbo.spring.boot.actuate.mertics.DubboMetricsBinder;\n+import org.springframework.boot.actuate.autoconfigure.metrics.CompositeMeterRegistryAutoConfiguration;\n+import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n@@ -34,11 +36,12 @@\n )\n @ConditionalOnWebApplication\n @ConditionalOnClass({DubboMetrics.class})\n+@AutoConfigureAfter(CompositeMeterRegistryAutoConfiguration.class)\n public class DubboMetricsAutoConfiguration {\n     @Bean\n     @ConditionalOnBean({MeterRegistry.class})\n     @ConditionalOnMissingBean({DubboMetrics.class, DubboMetricsBinder.class})\n-    public DubboMetricsBinder tomcatMetricsBinder(MeterRegistry meterRegistry) {\n+    public DubboMetricsBinder dubboMetricsBinder(MeterRegistry meterRegistry) {\n         return new DubboMetricsBinder(meterRegistry);\n     }\n }",
    "output": "Fix MetericsService resource location bug"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvoker.java\n@@ -46,7 +46,6 @@\n  * 1. registry marked as 'preferred=true' has the highest priority.\n  * 2. check the zone the current request belongs, pick the registry that has the same zone first.\n  * 3. Evenly balance traffic between all registries based on each registry's weight.\n- * 4. Pick anyone that's available.\n  */\n public class ZoneAwareClusterInvoker<T> extends AbstractClusterInvoker<T> {\n@@ -112,8 +111,7 @@ public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, L\n             }\n         }\n-        //if none available,just pick one\n-        return invokers.get(0).invoke(invocation);\n+        throw new RpcException(\"No provider available in \" + invokers);\n     }\n }\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvokerTest.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.rpc.AppResponse;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.RpcContext;\n+import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.cluster.ClusterInvoker;\n import org.apache.dubbo.rpc.cluster.Directory;\n@@ -168,6 +169,18 @@ void testRegistryZoneForceStrategy() {\n             () -> zoneAwareClusterInvoker.invoke(invocation));\n     }\n+    @Test\n+    public void testNoAvailableInvoker() {\n+        given(directory.getUrl()).willReturn(url);\n+        given(directory.getConsumerUrl()).willReturn(url);\n+        given(directory.list(invocation)).willReturn(new ArrayList<>(0));\n+\n+        zoneAwareClusterInvoker = new ZoneAwareClusterInvoker<>(directory);\n+\n+        Assertions.assertThrows(RpcException.class,\n+            () -> zoneAwareClusterInvoker.invoke(invocation));\n+    }\n+\n     private ClusterInvoker newUnexpectedInvoker() {\n         return  (ClusterInvoker) Proxy.newProxyInstance(getClass().getClassLoader(), new Class<?>[]{ClusterInvoker.class}, (proxy, method, args) -> {\n             if (\"getUrl\".equals(method.getName())) {",
    "output": "Add NPE and empty list check in AwareClusterInvoker#doInvoke"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java\n@@ -18,13 +18,15 @@\n package org.apache.dubbo.metrics.filter;\n import static org.apache.dubbo.common.constants.MetricsConstants.METRIC_FILTER_START_TIME;\n+import static org.apache.dubbo.rpc.support.RpcUtils.isGenericCall;\n import java.util.function.Supplier;\n import org.apache.dubbo.common.metrics.collector.DefaultMetricsCollector;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.RpcInvocation;\n public class MetricsCollectExecutor {\n@@ -88,6 +90,12 @@ private void endExecute(Supplier<Boolean> rtStat){\n     private void init(Invocation invocation) {\n         String serviceUniqueName = invocation.getTargetServiceUniqueName();\n         String methodName = invocation.getMethodName();\n+        if (invocation instanceof RpcInvocation\n+            && isGenericCall(((RpcInvocation) invocation).getParameterTypesDesc(), methodName)\n+            && invocation.getArguments() != null\n+            && invocation.getArguments().length == 3) {\n+            methodName = ((String) invocation.getArguments()[0]).trim();\n+        }\n         String group = null;\n         String interfaceAndVersion;\n         String[] arr = serviceUniqueName.split(\"/\");\ndiff --git a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java\n@@ -38,6 +38,7 @@\n import java.util.function.Function;\n import java.util.stream.Collectors;\n+import static org.apache.dubbo.common.constants.CommonConstants.*;\n import static org.apache.dubbo.common.constants.MetricsConstants.TAG_GROUP_KEY;\n import static org.apache.dubbo.common.constants.MetricsConstants.TAG_INTERFACE_KEY;\n import static org.apache.dubbo.common.constants.MetricsConstants.TAG_METHOD_KEY;\n@@ -234,6 +235,31 @@ void testMissingGroupAndVersion() {\n         Assertions.assertNull(tags.get(TAG_VERSION_KEY));\n     }\n+    @Test\n+    void testGenericCall() {\n+        collector.setCollectEnabled(true);\n+        given(invoker.invoke(invocation)).willReturn(new AppResponse(\"success\"));\n+        invocation.setTargetServiceUniqueName(INTERFACE_NAME);\n+        invocation.setMethodName(METHOD_NAME);\n+        invocation.setParameterTypes(new Class[]{String.class});\n+\n+        Result result = filter.invoke(invoker, invocation);\n+\n+        invocation.setMethodName($INVOKE);\n+        invocation.setParameterTypesDesc(GENERIC_PARAMETER_DESC);\n+        invocation.setArguments(new Object[]{METHOD_NAME, new String[]{\"java.lang.String\"}, new Object[]{\"mock\"}});\n+\n+        filter.onResponse(result, invoker, invocation);\n+\n+        Map<String, MetricSample> metricsMap = getMetricsMap();\n+\n+        MetricSample sample = metricsMap.get(\"requests.processing\");\n+        Map<String, String> tags = sample.getTags();\n+\n+        Assertions.assertEquals(tags.get(TAG_INTERFACE_KEY), INTERFACE_NAME);\n+        Assertions.assertEquals(tags.get(TAG_METHOD_KEY), METHOD_NAME);\n+    }\n+\n     private void initParam() {\n         invocation.setTargetServiceUniqueName(GROUP + \"/\" + INTERFACE_NAME + \":\" + VERSION);\n         invocation.setMethodName(METHOD_NAME);",
    "output": "Fix metrics collection getting wrong method name when generalize called *, fixed metrics collection getting wrong method name when generalize called * avoid array out of bounds"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n@@ -244,6 +244,9 @@ protected void checkDefault() {\n         if (executorManagementMode == null) {\n             executorManagementMode = EXECUTOR_MANAGEMENT_MODE_DEFAULT;\n         }\n+        if (enableFileCache == null) {\n+            enableFileCache = Boolean.TRUE;\n+        }\n     }\n     @Parameter(key = APPLICATION_KEY, required = true)\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ApplicationConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ApplicationConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ApplicationConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ApplicationConfigTest.java\n@@ -29,7 +29,9 @@\n import java.util.Map;\n import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.DUBBO;\n import static org.apache.dubbo.common.constants.CommonConstants.DUMP_DIRECTORY;\n+import static org.apache.dubbo.common.constants.CommonConstants.EXECUTOR_MANAGEMENT_MODE_DEFAULT;\n import static org.apache.dubbo.common.constants.QosConstants.ACCEPT_FOREIGN_IP;\n import static org.apache.dubbo.common.constants.QosConstants.QOS_ENABLE;\n import static org.hamcrest.MatcherAssert.assertThat;\n@@ -333,4 +335,20 @@ void testOverrideConfigConvertCase() {\n         DubboBootstrap.getInstance().destroy();\n     }\n-}\n\\ No newline at end of file\n+\n+    @Test\n+    void testDefaultValue() {\n+        SysProps.setProperty(\"dubbo.application.NAME\", \"demo-app\");\n+\n+        DubboBootstrap.getInstance()\n+            .initialize();\n+\n+        ApplicationConfig applicationConfig = DubboBootstrap.getInstance().getApplication();\n+\n+        Assertions.assertEquals(DUBBO, applicationConfig.getProtocol());\n+        Assertions.assertEquals(EXECUTOR_MANAGEMENT_MODE_DEFAULT, applicationConfig.getExecutorManagementMode());\n+        Assertions.assertEquals(Boolean.TRUE, applicationConfig.getEnableFileCache());\n+\n+        DubboBootstrap.getInstance().destroy();\n+    }\n+}",
    "output": "Fix ApplicationConfig.enableFileCache default value is not true"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n@@ -129,7 +129,8 @@ public synchronized void setInvokers(BitList<Invoker<T>> invokers, Runnable swit\n         try {\n             Thread.sleep(1);\n         } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n+            logger.error(INTERNAL_INTERRUPTED, \"\", \"\", \"Interrupted when waiting router chain.\", e);\n+            Thread.currentThread().interrupt();\n         }\n         // 7. switch chain\n@@ -156,8 +157,9 @@ private void waitChain(SingleRouterChain<T> oldChain) {\n                 // long time wait\n                 Thread.sleep(1);\n             }\n-        } catch (Throwable t) {\n+        } catch (InterruptedException t) {\n             logger.error(INTERNAL_INTERRUPTED, \"Wait router to interrupted\", \"\", \"Wait router to interrupted.\");\n+            Thread.currentThread().interrupt();\n         }\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n@@ -111,6 +111,7 @@ private void doDestroy() {\n                         }\n                     } catch (InterruptedException e) {\n                         logger.warn(e.getMessage(), e);\n+                        Thread.currentThread().interrupt();\n                     }\n                 }\n             }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java\n@@ -304,7 +304,7 @@ protected InternalServiceConfigBuilder<T> getThis() {\n     }\n     private ApplicationConfig getApplicationConfig() {\n-        return applicationModel.getApplicationConfigManager().getApplication().get();\n+        return applicationModel.getApplicationConfigManager().getApplicationOrElseThrow();\n     }\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultMetricsServiceExporter.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultMetricsServiceExporter.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultMetricsServiceExporter.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultMetricsServiceExporter.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.dubbo.config.deploy;\n-import static org.apache.dubbo.common.constants.MetricsConstants.PROTOCOL_PROMETHEUS;\n-\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.metrics.service.MetricsService;\n@@ -28,6 +26,10 @@\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.ScopeModelAware;\n+import java.util.Optional;\n+\n+import static org.apache.dubbo.common.constants.MetricsConstants.PROTOCOL_PROMETHEUS;\n+\n /**\n  * Export metrics service\n  */\n@@ -104,7 +106,12 @@ public MetricsServiceExporter unexport() {\n     }\n     private MetricsConfig getMetricsConfig() {\n-        return applicationModel.getApplicationConfigManager().getMetrics().get();\n+        Optional<MetricsConfig> metricsConfig = applicationModel.getApplicationConfigManager().getMetrics();\n+        if (metricsConfig.isPresent()) {\n+            return metricsConfig.get();\n+        } else {\n+            throw new IllegalStateException(\"There's no MetricsConfig specified.\");\n+        }\n     }\n     private boolean isExported() {\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/UrlUtils.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/UrlUtils.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/UrlUtils.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/UrlUtils.java\n@@ -23,7 +23,6 @@\n import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.remoting.transport.CodecSupport;\n-\n import java.util.Collection;\n import java.util.Collections;\n import java.util.LinkedHashSet;\n@@ -82,7 +81,8 @@ public static Byte serializationId(URL url) {\n      */\n     public static String serializationOrDefault(URL url) {\n         //noinspection OptionalGetWithoutIsPresent\n-        return allSerializations(url).stream().findFirst().get();\n+        Optional<String> serializations = allSerializations(url).stream().findFirst();\n+        return serializations.orElseGet(DefaultSerializationSelector::getDefaultRemotingSerialization);\n     }\n     /**",
    "output": "Fix code style for 3.2"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n@@ -16,8 +16,9 @@\n  */\n package org.apache.dubbo.config.spring.beans.factory.annotation;\n-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n+\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.Assert;\n import org.apache.dubbo.common.utils.ClassUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n@@ -98,7 +99,7 @@ public class ReferenceAnnotationBeanPostProcessor extends AbstractAnnotationBean\n      */\n     private static final int CACHE_SIZE = Integer.getInteger(BEAN_NAME + \".cache.size\", 32);\n-    private final Log logger = LogFactory.getLog(getClass());\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n     private final ConcurrentMap<InjectionMetadata.InjectedElement, String> injectedFieldReferenceBeanCache =\n             new ConcurrentHashMap<>(CACHE_SIZE);\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboConfigBeanInitializer.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboConfigBeanInitializer.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboConfigBeanInitializer.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboConfigBeanInitializer.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.dubbo.config.spring.context;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.config.AbstractConfig;\n import org.apache.dubbo.config.ApplicationConfig;\n import org.apache.dubbo.config.ConsumerConfig;\n@@ -33,8 +35,6 @@\n import org.apache.dubbo.config.spring.reference.ReferenceBeanManager;\n import org.apache.dubbo.rpc.model.ModuleModel;\n-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n import org.springframework.beans.BeansException;\n import org.springframework.beans.FatalBeanException;\n import org.springframework.beans.factory.BeanFactory;\n@@ -59,7 +59,7 @@ public class DubboConfigBeanInitializer implements BeanFactoryAware, Initializin\n     public static String BEAN_NAME = \"dubboConfigBeanInitializer\";\n-    private final Log logger = LogFactory.getLog(getClass());\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n     private AtomicBoolean initialized = new AtomicBoolean(false);\n     private ConfigurableListableBeanFactory beanFactory;\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceCreator.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceCreator.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceCreator.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceCreator.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.dubbo.config.spring.reference;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.config.AbstractConfig;\n import org.apache.dubbo.config.ArgumentConfig;\n import org.apache.dubbo.config.ConsumerConfig;\n@@ -32,8 +34,6 @@\n import org.apache.dubbo.rpc.model.ModuleModel;\n import com.alibaba.spring.util.AnnotationUtils;\n-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n import org.springframework.beans.propertyeditors.StringTrimmerEditor;\n import org.springframework.context.ApplicationContext;\n import org.springframework.core.convert.support.DefaultConversionService;\n@@ -66,7 +66,7 @@ public class ReferenceCreator {\n     private static final String METHOD = \"Method\";\n-    protected final Log logger = LogFactory.getLog(getClass());\n+    protected final Logger logger = LoggerFactory.getLogger(getClass());\n     protected final Map<String, Object> attributes;\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/WelcomeLogoApplicationListener.java b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/WelcomeLogoApplicationListener.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/WelcomeLogoApplicationListener.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/WelcomeLogoApplicationListener.java\n@@ -18,8 +18,9 @@\n import org.apache.dubbo.common.Version;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;\n import org.springframework.boot.logging.LoggingApplicationListener;\n import org.springframework.context.ApplicationListener;",
    "output": "Fix log"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n@@ -135,7 +135,7 @@ public abstract class AbstractServiceConfig extends AbstractInterfaceConfig {\n      * <p>\n      * The configuration supports multiple, which are separated by commas.Such as:<code>fastjson2,fastjson,hessian2</code>\n      */\n-    private String preferSerialization; // default:hessian2\n+    private String preferSerialization; // default:fastjson2,hessian2\n     /**\n      * Weather the service is export asynchronously\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java\n@@ -82,7 +82,7 @@ public interface Constants {\n     /**\n      * Prefer serialization\n      */\n-    String PREFER_SERIALIZATION_KEY = \"prefer_serialization\";\n+    String PREFER_SERIALIZATION_KEY = \"prefer.serialization\";\n     String DEFAULT_REMOTING_SERIALIZATION_PROPERTY_KEY = \"DUBBO_DEFAULT_SERIALIZATION\";\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/UrlUtils.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/UrlUtils.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/UrlUtils.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/UrlUtils.java\n@@ -57,7 +57,7 @@ public static int getHeartbeat(URL url) {\n      */\n     public static Byte serializationId(URL url) {\n         Byte serializationId;\n-        // Obtain the value from prefer_serialization. Such as:fastjson2,hessian2\n+        // Obtain the value from prefer_serialization. Such as.fastjson2,hessian2\n         List<String> preferSerials = preferSerialization(url);\n         for (String preferSerial : preferSerials) {\n             if ((serializationId = CodecSupport.getIDByName(preferSerial)) != null) {\n@@ -81,6 +81,7 @@ public static Byte serializationId(URL url) {\n      * @return {@link String}\n      */\n     public static String serializationOrDefault(URL url) {\n+        //noinspection OptionalGetWithoutIsPresent\n         return allSerializations(url).stream().findFirst().get();\n     }\n@@ -92,8 +93,7 @@ public static String serializationOrDefault(URL url) {\n      */\n     public static Collection<String> allSerializations(URL url) {\n         // preferSerialization -> serialization -> default serialization\n-        Set<String> serializations = new LinkedHashSet<>();\n-        UrlUtils.preferSerialization(url).forEach(serializations::add);\n+        Set<String> serializations = new LinkedHashSet<>(preferSerialization(url));\n         Optional.ofNullable(url.getParameter(SERIALIZATION_KEY)).filter(StringUtils::isNotBlank).ifPresent(serializations::add);\n         serializations.add(DefaultSerializationSelector.getDefaultRemotingSerialization());\n         return Collections.unmodifiableSet(serializations);",
    "output": "Fix comments"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/EnvironmentConfiguration.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/EnvironmentConfiguration.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/EnvironmentConfiguration.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/EnvironmentConfiguration.java\n@@ -27,14 +27,24 @@ public class EnvironmentConfiguration implements Configuration {\n     @Override\n     public Object getInternalProperty(String key) {\n-        String value = System.getenv(key);\n+        String value = getenv(key);\n         if (StringUtils.isEmpty(value)) {\n-            value = System.getenv(StringUtils.toOSStyleKey(key));\n+            value = getenv(StringUtils.toOSStyleKey(key));\n         }\n         return value;\n     }\n     public Map<String, String> getProperties() {\n+        return getenv();\n+    }\n+\n+    // Adapt to System api, design for unit test\n+\n+    protected String getenv(String key) {\n+        return System.getenv(key);\n+    }\n+\n+    protected Map<String, String> getenv() {\n         return System.getenv();\n     }\n }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/config/EnvironmentConfigurationTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/config/EnvironmentConfigurationTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/config/EnvironmentConfigurationTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/config/EnvironmentConfigurationTest.java\n@@ -16,13 +16,9 @@\n  */\n package org.apache.dubbo.common.config;\n-import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import java.lang.reflect.Field;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n@@ -34,71 +30,33 @@ class EnvironmentConfigurationTest {\n     private static final String MOCK_KEY = \"DUBBO_KEY\";\n     private static final String MOCK_VALUE = \"mockValue\";\n-    /**\n-     * Init.\n-     */\n-    @BeforeEach\n-    public void init() {\n-\n-    }\n-\n     @Test\n     void testGetInternalProperty() {\n         Map<String, String> map = new HashMap<>();\n         map.put(MOCK_KEY, MOCK_VALUE);\n-        try {\n-            setEnv(map);\n-            EnvironmentConfiguration configuration = new EnvironmentConfiguration();\n-            // this UT maybe only works on particular platform, assert only when value is not null.\n-            Assertions.assertEquals(MOCK_VALUE, configuration.getInternalProperty(\"dubbo.key\"));\n-            Assertions.assertEquals(MOCK_VALUE, configuration.getInternalProperty(\"key\"));\n-            Assertions.assertEquals(MOCK_VALUE, configuration.getInternalProperty(\"dubbo_key\"));\n-            Assertions.assertEquals(MOCK_VALUE, configuration.getInternalProperty(MOCK_KEY));\n-        } catch (Exception e) {\n-            // skip test.\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    protected static void setEnv(Map<String, String> newenv) throws Exception {\n-        try {\n-            Class<?> processEnvironmentClass = Class.forName(\"java.lang.ProcessEnvironment\");\n-            Field theEnvironmentField = processEnvironmentClass.getDeclaredField(\"theEnvironment\");\n-            theEnvironmentField.setAccessible(true);\n-            Map<String, String> env = (Map<String, String>) theEnvironmentField.get(null);\n-            env.putAll(newenv);\n-            Field theCaseInsensitiveEnvironmentField = processEnvironmentClass.getDeclaredField(\"theCaseInsensitiveEnvironment\");\n-            theCaseInsensitiveEnvironmentField.setAccessible(true);\n-            Map<String, String> cienv = (Map<String, String>) theCaseInsensitiveEnvironmentField.get(null);\n-            cienv.putAll(newenv);\n-        } catch (NoSuchFieldException e) {\n-            Class[] classes = Collections.class.getDeclaredClasses();\n-            Map<String, String> env = System.getenv();\n-            for (Class cl : classes) {\n-                if (\"java.util.Collections$UnmodifiableMap\".equals(cl.getName())) {\n-                    Field field = cl.getDeclaredField(\"m\");\n-                    field.setAccessible(true);\n-                    Object obj = field.get(env);\n-                    Map<String, String> map = (Map<String, String>) obj;\n-                    map.clear();\n-                    map.putAll(newenv);\n-                }\n+        EnvironmentConfiguration configuration = new EnvironmentConfiguration() {\n+            @Override\n+            protected String getenv(String key) {\n+                return map.get(key);\n             }\n-        }\n-    }\n-\n-    private static void updateEnv(String name, String val) throws ReflectiveOperationException {\n-        Map<String, String> env = System.getenv();\n-        Field field = env.getClass().getDeclaredField(\"m\");\n-        field.setAccessible(true);\n-        ((Map<String, String>) field.get(env)).put(name, val);\n+        };\n+        // this UT maybe only works on particular platform, assert only when value is not null.\n+        Assertions.assertEquals(MOCK_VALUE, configuration.getInternalProperty(\"dubbo.key\"));\n+        Assertions.assertEquals(MOCK_VALUE, configuration.getInternalProperty(\"key\"));\n+        Assertions.assertEquals(MOCK_VALUE, configuration.getInternalProperty(\"dubbo_key\"));\n+        Assertions.assertEquals(MOCK_VALUE, configuration.getInternalProperty(MOCK_KEY));\n     }\n-    /**\n-     * Clean.\n-     */\n-    @AfterEach\n-    public void clean(){\n+    @Test\n+    void testGetProperties() {\n+        Map<String, String> map = new HashMap<>();\n+        map.put(MOCK_KEY, MOCK_VALUE);\n+        EnvironmentConfiguration configuration = new EnvironmentConfiguration() {\n+            @Override\n+            protected Map<String, String> getenv() {\n+                return map;\n+            }\n+        };\n+        Assertions.assertEquals(map, configuration.getProperties());\n     }\n-\n-}\n\\ No newline at end of file\n+}",
    "output": "Fix jacoco arg line not work in jdk17"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassLoaderResourceLoader.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassLoaderResourceLoader.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassLoaderResourceLoader.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassLoaderResourceLoader.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.dubbo.common.utils;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.resource.GlobalResourcesRepository;\n import java.io.IOException;\n@@ -34,7 +36,7 @@\n import java.util.concurrent.CountDownLatch;\n public class ClassLoaderResourceLoader {\n-\n+    private static Logger logger = LoggerFactory.getLogger(ClassLoaderResourceLoader.class);\n     private static SoftReference<Map<ClassLoader, Map<String, Set<URL>>>> classLoaderResourcesCache = null;\n     static {\n@@ -86,7 +88,7 @@ public static Set<URL> loadResources(String fileName, ClassLoader currentClassLo\n                     }\n                 }\n             } catch (IOException e) {\n-                e.printStackTrace();\n+                logger.error(\"Exception occurred when reading SPI definitions. SPI path: \" + fileName + \" ClassLoader name: \" + currentClassLoader, e);\n             }\n             urlCache.put(fileName, set);\n         }",
    "output": "Fix logger in ClassLoaderResourceLoader"
  },
  {
    "input": "diff --git a/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java b/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n--- a/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n+++ b/dubbo-test/dubbo-test-modules/src/test/java/org/apache/dubbo/dependency/FileTest.java\n@@ -33,6 +33,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n@@ -416,7 +417,7 @@ public void readSPI(File path, List<String> spis) {\n                     absolutePath = absolutePath.substring(absolutePath.lastIndexOf(\"src\" + File.separator + \"main\" + File.separator + \"java\" + File.separator)\n                         + (\"src\" + File.separator + \"main\" + File.separator + \"java\" + File.separator).length());\n                     absolutePath = absolutePath.substring(0, absolutePath.lastIndexOf(\".java\"));\n-                    absolutePath = absolutePath.replaceAll(File.separator, \".\");\n+                    absolutePath = absolutePath.replaceAll(Matcher.quoteReplacement(File.separator), \".\");\n                     spis.add(absolutePath);\n                 }\n             }\n@@ -439,7 +440,7 @@ public void readSPIResource(File path, Map<File, String> spis) {\n                 String absolutePath = path.getAbsolutePath();\n                 absolutePath = absolutePath.substring(absolutePath.lastIndexOf(\"src\" + File.separator + \"main\" + File.separator + \"resources\" + File.separator + \"META-INF\" + File.separator + \"dubbo\" + File.separator + \"internal\" + File.separator)\n                     + (\"src\" + File.separator + \"main\" + File.separator + \"resources\" + File.separator + \"META-INF\" + File.separator + \"dubbo\" + File.separator + \"internal\" + File.separator).length());\n-                absolutePath = absolutePath.replaceAll( File.separator, \".\");\n+                absolutePath = absolutePath.replaceAll(Matcher.quoteReplacement(File.separator), \".\");\n                 spis.put(path, absolutePath);\n             }\n         }",
    "output": "Fix FileTest seperator in Win"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -231,14 +231,14 @@ private void refreshInvoker(List<URL> invokerUrls) {\n             }\n             // use local reference to avoid NPE as this.cachedInvokerUrls will be set null by destroyAllInvokers().\n             Set<URL> localCachedInvokerUrls = this.cachedInvokerUrls;\n-            if (invokerUrls.isEmpty() && localCachedInvokerUrls != null) {\n-\n-                // 1-4 Empty address.\n-                logger.warn(REGISTRY_EMPTY_ADDRESS, \"configuration \", \"\",\n-                    \"Service\" + serviceKey + \" received empty address list with no EMPTY protocol set, trigger empty protection.\");\n-\n-                invokerUrls.addAll(localCachedInvokerUrls);\n+            if (invokerUrls.isEmpty()) {\n+                if(CollectionUtils.isNotEmpty(localCachedInvokerUrls)){\n+                    // 1-4 Empty address.\n+                    logger.warn(REGISTRY_EMPTY_ADDRESS, \"configuration \", \"\",\n+                        \"Service\" + serviceKey + \" received empty address list with no EMPTY protocol set, trigger empty protection.\");\n+                    invokerUrls.addAll(localCachedInvokerUrls);\n+                }\n             } else {\n                 localCachedInvokerUrls = new HashSet<>();\n                 localCachedInvokerUrls.addAll(invokerUrls);//Cached invoker urls, convenient for comparison",
    "output": "Fix the warning problem when invokerUrls is checked"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java\n@@ -38,7 +38,9 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n import java.util.stream.Stream;\n import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_PROTOCOL_KEY;\n@@ -52,6 +54,7 @@\n public class InternalServiceConfigBuilder<T> {\n     private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(getClass());\n+    private static final Set<String> UNACCEPTABLE_PROTOCOL = Stream.of(\"rest\", \"grpc\").collect(Collectors.toSet());\n     private final ApplicationModel applicationModel;\n     private String  protocol;\n@@ -115,6 +118,7 @@ private String getRelatedOrDefaultProtocol() {\n             .flatMap(Collection::stream)\n             .map(ConsumerConfig::getProtocol)\n             .filter(StringUtils::isNotEmpty)\n+            .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))\n             .findFirst()\n             .orElse(\"\");\n         // <dubbo:provider/>\n@@ -138,6 +142,7 @@ private String getRelatedOrDefaultProtocol() {\n                     }\n                 })\n                 .filter(StringUtils::isNotEmpty)\n+                .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))\n                 .findFirst()\n                 .orElse(\"\");\n         }\n@@ -146,7 +151,11 @@ private String getRelatedOrDefaultProtocol() {\n             Collection<ProtocolConfig> protocols = applicationModel.getApplicationConfigManager().getProtocols();\n             if (CollectionUtils.isNotEmpty(protocols)) {\n                 protocol = protocols.stream()\n-                    .map(ProtocolConfig::getName).filter(StringUtils::isNotEmpty).findFirst().orElse(\"\");\n+                    .map(ProtocolConfig::getName)\n+                    .filter(StringUtils::isNotEmpty)\n+                    .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))\n+                    .findFirst()\n+                    .orElse(\"\");\n             }\n         }\n         // <dubbo:application/>\n@@ -159,7 +168,7 @@ private String getRelatedOrDefaultProtocol() {\n                 }\n             }\n         }\n-        return StringUtils.isNotEmpty(protocol) ? protocol : DUBBO_PROTOCOL;\n+        return StringUtils.isNotEmpty(protocol) && !UNACCEPTABLE_PROTOCOL.contains(protocol) ? protocol : DUBBO_PROTOCOL;\n     }\n     public InternalServiceConfigBuilder<T> protocol(String protocol) {",
    "output": "Fix conflict of ConfigurableMetadataServiceExporter"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n@@ -43,6 +43,8 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n import java.util.stream.Stream;\n import static java.util.Collections.emptyList;\n@@ -66,6 +68,7 @@ public class ConfigurableMetadataServiceExporter {\n     private final ApplicationModel applicationModel;\n     private MetadataServiceDelegation metadataService;\n     private volatile ServiceConfig<MetadataService> serviceConfig;\n+    private static final Set<String> UNACCEPTABLE_PROTOCOL = Stream.of(\"rest\", \"grpc\").collect(Collectors.toSet());\n     public ConfigurableMetadataServiceExporter(ApplicationModel applicationModel, MetadataServiceDelegation metadataService) {\n         this.applicationModel = applicationModel;\n@@ -208,6 +211,7 @@ private String getRelatedOrDefaultProtocol() {\n             .flatMap(Collection::stream)\n             .map(ConsumerConfig::getProtocol)\n             .filter(StringUtils::isNotEmpty)\n+            .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))\n             .findFirst()\n             .orElse(\"\");\n         // <dubbo:provider/>\n@@ -231,6 +235,7 @@ private String getRelatedOrDefaultProtocol() {\n                     }\n                 })\n                 .filter(StringUtils::isNotEmpty)\n+                .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))\n                 .findFirst()\n                 .orElse(\"\");\n         }\n@@ -239,7 +244,11 @@ private String getRelatedOrDefaultProtocol() {\n             Collection<ProtocolConfig> protocols = applicationModel.getApplicationConfigManager().getProtocols();\n             if (CollectionUtils.isNotEmpty(protocols)) {\n                 protocol = protocols.stream()\n-                    .map(ProtocolConfig::getName).filter(StringUtils::isNotEmpty).findFirst().orElse(\"\");\n+                    .map(ProtocolConfig::getName)\n+                    .filter(StringUtils::isNotEmpty)\n+                    .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))\n+                    .findFirst()\n+                    .orElse(\"\");\n             }\n         }\n         // <dubbo:application/>\n@@ -252,7 +261,7 @@ private String getRelatedOrDefaultProtocol() {\n                 }\n             }\n         }\n-        return StringUtils.isNotEmpty(protocol) ? protocol : DUBBO_PROTOCOL;\n+        return StringUtils.isNotEmpty(protocol) && !UNACCEPTABLE_PROTOCOL.contains(protocol) ? protocol : DUBBO_PROTOCOL;\n     }\n     private ServiceConfig<MetadataService> buildServiceConfig() {",
    "output": "Fix try use rest protocol"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n@@ -349,26 +349,38 @@ public String getProtocol() {\n     }\n     public URL setProtocol(String protocol) {\n-        URLAddress newURLAddress = urlAddress.setProtocol(protocol);\n-        return returnURL(newURLAddress);\n+        if (urlAddress == null) {\n+            return new ServiceConfigURL(protocol, getHost(), getPort(), getPath(), getParameters());\n+        } else {\n+            URLAddress newURLAddress = urlAddress.setProtocol(protocol);\n+            return returnURL(newURLAddress);\n+        }\n     }\n     public String getUsername() {\n         return urlAddress == null ? null : urlAddress.getUsername();\n     }\n     public URL setUsername(String username) {\n-        URLAddress newURLAddress = urlAddress.setUsername(username);\n-        return returnURL(newURLAddress);\n+        if (urlAddress == null) {\n+            return new ServiceConfigURL(getProtocol(), getHost(), getPort(), getPath(), getParameters()).setUsername(username);\n+        } else {\n+            URLAddress newURLAddress = urlAddress.setUsername(username);\n+            return returnURL(newURLAddress);\n+        }\n     }\n     public String getPassword() {\n         return urlAddress == null ? null : urlAddress.getPassword();\n     }\n     public URL setPassword(String password) {\n-        URLAddress newURLAddress = urlAddress.setPassword(password);\n-        return returnURL(newURLAddress);\n+        if (urlAddress == null) {\n+            return new ServiceConfigURL(getProtocol(), getHost(), getPort(), getPath(), getParameters()).setPassword(password);\n+        } else {\n+            URLAddress newURLAddress = urlAddress.setPassword(password);\n+            return returnURL(newURLAddress);\n+        }\n     }\n     /**\n@@ -425,8 +437,12 @@ public String getHost() {\n     }\n     public URL setHost(String host) {\n-        URLAddress newURLAddress = urlAddress.setHost(host);\n-        return returnURL(newURLAddress);\n+        if (urlAddress == null) {\n+            return new ServiceConfigURL(getProtocol(), host, getPort(), getPath(), getParameters());\n+        } else {\n+            URLAddress newURLAddress = urlAddress.setHost(host);\n+            return returnURL(newURLAddress);\n+        }\n     }\n@@ -435,8 +451,12 @@ public int getPort() {\n     }\n     public URL setPort(int port) {\n-        URLAddress newURLAddress = urlAddress.setPort(port);\n-        return returnURL(newURLAddress);\n+        if (urlAddress == null) {\n+            return new ServiceConfigURL(getProtocol(), getHost(), port, getPath(), getParameters());\n+        } else {\n+            URLAddress newURLAddress = urlAddress.setPort(port);\n+            return returnURL(newURLAddress);\n+        }\n     }\n     public int getPort(int defaultPort) {\n@@ -445,7 +465,7 @@ public int getPort(int defaultPort) {\n     }\n     public String getAddress() {\n-        return urlAddress.getAddress();\n+        return urlAddress == null ? null : urlAddress.getAddress();\n     }\n     public URL setAddress(String address) {\n@@ -458,12 +478,16 @@ public URL setAddress(String address) {\n         } else {\n             host = address;\n         }\n-        URLAddress newURLAddress = urlAddress.setAddress(host, port);\n-        return returnURL(newURLAddress);\n+        if (urlAddress == null) {\n+            return new ServiceConfigURL(getProtocol(), host, port, getPath(), getParameters());\n+        } else {\n+            URLAddress newURLAddress = urlAddress.setAddress(host, port);\n+            return returnURL(newURLAddress);\n+        }\n     }\n     public String getIp() {\n-        return urlAddress.getIp();\n+        return urlAddress == null ? null : urlAddress.getIp();\n     }\n     public String getBackupAddress() {\n@@ -499,8 +523,12 @@ public String getPath() {\n     }\n     public URL setPath(String path) {\n-        URLAddress newURLAddress = urlAddress.setPath(path);\n-        return returnURL(newURLAddress);\n+        if (urlAddress == null) {\n+            return new ServiceConfigURL(getProtocol(), getHost(), getPort(), path, getParameters());\n+        } else {\n+            URLAddress newURLAddress = urlAddress.setPath(path);\n+            return returnURL(newURLAddress);\n+        }\n     }\n     public String getAbsolutePath() {",
    "output": "Fix NPE bug of URL"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosInstanceManageUtil.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosInstanceManageUtil.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosInstanceManageUtil.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosInstanceManageUtil.java\n@@ -19,12 +19,12 @@\n import org.apache.dubbo.common.utils.CollectionUtils;\n import com.alibaba.nacos.api.naming.pojo.Instance;\n-import com.alibaba.nacos.shaded.com.google.common.collect.Lists;\n-import com.alibaba.nacos.shaded.com.google.common.collect.Maps;\n+import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n /**\n  * Instance manage util for multiple serviceNames\n@@ -37,12 +37,12 @@ public class NacosInstanceManageUtil {\n     /**\n      * serviceName -> refreshed instance list\n      */\n-    private static final Map<String, List<Instance>> SERVICE_INSTANCE_LIST_MAP = Maps.newConcurrentMap();\n+    private static final Map<String, List<Instance>> SERVICE_INSTANCE_LIST_MAP = new ConcurrentHashMap<>();\n     /**\n      * serviceName -> corresponding serviceName list\n      */\n-    private static final Map<String, Set<String>> CORRESPONDING_SERVICE_NAMES_MAP = Maps.newConcurrentMap();\n+    private static final Map<String, Set<String>> CORRESPONDING_SERVICE_NAMES_MAP = new ConcurrentHashMap<>();\n     public static void setCorrespondingServiceNames(String serviceName, Set<String> serviceNames) {\n         CORRESPONDING_SERVICE_NAMES_MAP.put(serviceName, serviceNames);\n@@ -58,9 +58,9 @@ public static Set<String> removeCorrespondingServiceNames(String serviceName) {\n     public static List<Instance> getAllCorrespondingServiceInstanceList(String serviceName) {\n         if (!CORRESPONDING_SERVICE_NAMES_MAP.containsKey(serviceName)) {\n-            return Lists.newArrayList();\n+            return new ArrayList<>();\n         }\n-        List<Instance> allInstances = Lists.newArrayList();\n+        List<Instance> allInstances = new ArrayList<>();\n         for (String correspondingServiceName : CORRESPONDING_SERVICE_NAMES_MAP.get(serviceName)) {\n             if (SERVICE_INSTANCE_LIST_MAP.containsKey(correspondingServiceName)\n                 && CollectionUtils.isNotEmpty(SERVICE_INSTANCE_LIST_MAP.get(correspondingServiceName))) {",
    "output": "Remove guava usage in nacos registry"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n@@ -50,6 +50,7 @@\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_RECONNECT_TASK_PERIOD;\n@@ -260,6 +261,9 @@ public void addInvalidateInvoker(Invoker<T> invoker) {\n             invokersToReconnect.add(invoker);\n             // 3. try start check connectivity task\n             checkConnectivity();\n+\n+            logger.info(\"The invoker \" + invoker.getUrl() + \" has been added to invalidate list due to connectivity problem. \" +\n+                \"Will trying to reconnect to it in the background.\");\n         }\n     }\n@@ -434,4 +438,15 @@ private boolean removeValidInvoker(Invoker<T> invoker) {\n     protected abstract List<Invoker<T>> doList(BitList<Invoker<T>> invokers, Invocation invocation) throws RpcException;\n+    protected String joinValidInvokerAddresses() {\n+        BitList<Invoker<T>> validInvokers = getValidInvokers().clone();\n+        if (validInvokers.isEmpty()) {\n+            return \"empty\";\n+        }\n+        return validInvokers.stream()\n+            .limit(5)\n+            .map(Invoker::getUrl)\n+            .map(URL::getAddress)\n+            .collect(Collectors.joining(\",\"));\n+    }\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -275,6 +275,14 @@ private void refreshInvoker(List<URL> invokerUrls) {\n         // notify invokers refreshed\n         this.invokersChanged();\n+\n+        logger.info(\"Received invokers changed event from registry. \" +\n+            \"Registry type: instance. \" +\n+            \"Service Key: \" + getConsumerUrl().getServiceKey() + \". \" +\n+            \"Urls Size : \" + invokerUrls.size() + \". \" +\n+            \"Invokers Size : \" + getInvokers().size() + \". \" +\n+            \"Available Size: \" + getValidInvokers().size() + \". \" +\n+            \"Available Invokers : \" + joinValidInvokerAddresses());\n     }\n     /**\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -62,13 +62,13 @@\n import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_INIT_SERIALIZATION_OPTIMIZER;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REFER_INVOKER;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_UNSUPPORTED;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROXY_FAILED_CONVERT_URL;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_EMPTY_ADDRESS;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_FAILED_DESTROY_SERVICE;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_UNSUPPORTED_CATEGORY;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROXY_FAILED_CONVERT_URL;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_UNSUPPORTED;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_INIT_SERIALIZATION_OPTIMIZER;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REFER_INVOKER;\n import static org.apache.dubbo.common.constants.RegistryConstants.APP_DYNAMIC_CONFIGURATORS_CATEGORY;\n import static org.apache.dubbo.common.constants.RegistryConstants.COMPATIBLE_CONFIG_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.CONFIGURATORS_CATEGORY;\n@@ -296,6 +296,14 @@ private void refreshInvoker(List<URL> invokerUrls) {\n             // notify invokers refreshed\n             this.invokersChanged();\n         }\n+\n+        logger.info(\"Received invokers changed event from registry. \" +\n+            \"Registry type: interface. \" +\n+            \"Service Key: \" + getConsumerUrl().getServiceKey() + \". \" +\n+            \"Urls Size : \" + invokerUrls.size() + \". \" +\n+            \"Invokers Size : \" + getInvokers().size() + \". \" +\n+            \"Available Size: \" + getValidInvokers().size() + \". \" +\n+            \"Available Invokers : \" + joinValidInvokerAddresses());\n     }\n     private List<Invoker<T>> toMergeInvokerList(List<Invoker<T>> invokers) {",
    "output": "Add some logs"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassUtils.java\n@@ -26,6 +26,7 @@\n import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.Date;\n import java.util.HashMap;\n import java.util.HashSet;\n@@ -575,6 +576,7 @@ public static String[] getDeclaredMethodNames(Class<?> tClass) {\n                 }\n             }\n         }\n+        dmns.sort(Comparator.naturalOrder());\n         return dmns.toArray(new String[0]);\n     }\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -55,8 +55,8 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n@@ -83,8 +83,8 @@\n import static org.apache.dubbo.common.constants.CommonConstants.UNLOAD_CLUSTER_RELATED;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CLUSTER_NO_VALID_PROVIDER;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_DESTROY_INVOKER;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_NO_METHOD_FOUND;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_LOAD_ENV_VARIABLE;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_NO_METHOD_FOUND;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_PROPERTY_CONFLICT;\n import static org.apache.dubbo.common.constants.RegistryConstants.PROVIDED_BY;\n import static org.apache.dubbo.common.constants.RegistryConstants.SUBSCRIBED_SERVICE_NAMES_KEY;\n@@ -389,7 +389,9 @@ private Map<String, String> appendConfig() {\n                 logger.warn(CONFIG_NO_METHOD_FOUND, \"\", \"\", \"No method found in service interface: \" + interfaceClass.getName());\n                 map.put(METHODS_KEY, ANY_VALUE);\n             } else {\n-                map.put(METHODS_KEY, StringUtils.join(new HashSet<>(Arrays.asList(methods)), COMMA_SEPARATOR));\n+                List<String> copyOfMethods = new ArrayList<>(Arrays.asList(methods));\n+                copyOfMethods.sort(Comparator.naturalOrder());\n+                map.put(METHODS_KEY, String.join(COMMA_SEPARATOR, copyOfMethods));\n             }\n         }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -52,8 +52,8 @@\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.UUID;\n@@ -62,6 +62,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.ANY_VALUE;\n+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SEPARATOR;\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO;\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_IP_TO_BIND;\n import static org.apache.dubbo.common.constants.CommonConstants.LOCALHOST_VALUE;\n@@ -71,11 +72,11 @@\n import static org.apache.dubbo.common.constants.CommonConstants.REVISION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SERVICE_NAME_MAPPING_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_EXPORT_SERVICE;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_NO_METHOD_FOUND;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_SERVER_DISCONNECTED;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_UNEXPORT_ERROR;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_USE_RANDOM_PORT;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_EXPORT_SERVICE;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_SERVER_DISCONNECTED;\n import static org.apache.dubbo.common.constants.RegistryConstants.DYNAMIC_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.SERVICE_REGISTRY_PROTOCOL;\n import static org.apache.dubbo.common.utils.NetUtils.getAvailablePort;\n@@ -457,7 +458,9 @@ private Map<String, String> buildAttributes(ProtocolConfig protocolConfig) {\n                 logger.warn(CONFIG_NO_METHOD_FOUND, \"\", \"\", \"No method found in service interface: \" + interfaceClass.getName());\n                 map.put(METHODS_KEY, ANY_VALUE);\n             } else {\n-                map.put(METHODS_KEY, StringUtils.join(new HashSet<>(Arrays.asList(methods)), \",\"));\n+                List<String> copyOfMethods = new ArrayList<>(Arrays.asList(methods));\n+                copyOfMethods.sort(Comparator.naturalOrder());\n+                map.put(METHODS_KEY, String.join(COMMA_SEPARATOR, copyOfMethods));\n             }\n         }\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n@@ -534,7 +534,7 @@ public void test_noMethodInterface_methodsKeyHasValue() throws Exception {\n             urls = bean.getExportedUrls();\n             assertEquals(1, urls.size());\n             URL url = urls.get(0);\n-            assertEquals(\"sayName,getBox\", url.getParameter(\"methods\"));\n+            assertEquals(\"getBox,sayName\", url.getParameter(\"methods\"));\n         } finally {\n             ctx.stop();\n             ctx.close();",
    "output": "Fix MetadataService method order"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/metadata/definition/ServiceDefinitionBuilderTest.java b/dubbo-common/src/test/java/org/apache/dubbo/metadata/definition/ServiceDefinitionBuilderTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/metadata/definition/ServiceDefinitionBuilderTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/metadata/definition/ServiceDefinitionBuilderTest.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.metadata.definition.model.TypeDefinition;\n import org.apache.dubbo.metadata.definition.service.ComplexObject;\n import org.apache.dubbo.metadata.definition.service.DemoService;\n+import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n@@ -35,6 +36,7 @@ public class ServiceDefinitionBuilderTest {\n     @Test\n     public void testBuilderComplexObject() {\n+        TypeDefinitionBuilder.initBuilders(FrameworkModel.defaultModel());\n         FullServiceDefinition fullServiceDefinition = ServiceDefinitionBuilder.buildFullDefinition(DemoService.class);\n         checkComplexObjectAsParam(fullServiceDefinition);\n     }",
    "output": "Fix ServiceDefinitionBuilder uts"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -72,6 +72,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.CLUSTER_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;\n+import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_SERVER_SHUTDOWN_TIMEOUT;\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_VERSION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.ENABLED_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.EXTRA_KEYS_KEY;\n@@ -919,7 +920,10 @@ public void unexport() {\n             }\n             //TODO wait for shutdown timeout is a bit strange\n-            int timeout = ConfigurationUtils.getServerShutdownTimeout(subscribeUrl.getScopeModel());\n+            int timeout = DEFAULT_SERVER_SHUTDOWN_TIMEOUT;\n+            if (subscribeUrl != null) {\n+                timeout = ConfigurationUtils.getServerShutdownTimeout(subscribeUrl.getScopeModel());\n+            }\n             executor.schedule(() -> {\n                 try {\n                     exporter.unexport();",
    "output": "Fix issue: unexport() throws NPE when register fail"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java b/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.dubbo.metadata.definition.model;\n-import com.google.gson.annotations.SerializedName;\n-\n import java.io.Serializable;\n import java.lang.reflect.ParameterizedType;\n import java.util.ArrayList;\n@@ -46,15 +44,13 @@ public class TypeDefinition implements Serializable {\n      * <p>\n      * if this type is not ParameterizedType, the items is null or empty\n      */\n-    @SerializedName(\"items\")\n     private List<String> items;\n     /**\n      * the enum's value\n      * <p>\n      * If this type is not enum, enums is null or empty\n      */\n-    @SerializedName(\"enum\")\n     private List<String> enums;\n     /**\ndiff --git a/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesServiceDiscovery.java b/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesServiceDiscovery.java\n--- a/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesServiceDiscovery.java\n+++ b/dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesServiceDiscovery.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.JsonUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.registry.client.AbstractServiceDiscovery;\n import org.apache.dubbo.registry.client.DefaultServiceInstance;\n@@ -30,7 +31,6 @@\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.ScopeModelUtil;\n-import com.alibaba.fastjson.JSONObject;\n import io.fabric8.kubernetes.api.model.EndpointAddress;\n import io.fabric8.kubernetes.api.model.EndpointPort;\n import io.fabric8.kubernetes.api.model.EndpointSubset;\n@@ -130,7 +130,7 @@ public void doRegister(ServiceInstance serviceInstance) throws RuntimeException\n                     .edit(pod ->\n                             new PodBuilder(pod)\n                                     .editOrNewMetadata()\n-                                    .addToAnnotations(KUBERNETES_PROPERTIES_KEY, JSONObject.toJSONString(serviceInstance.getMetadata()))\n+                                    .addToAnnotations(KUBERNETES_PROPERTIES_KEY, JsonUtils.getJson().toJson(serviceInstance.getMetadata()))\n                                     .endMetadata()\n                                     .build());\n             if (logger.isInfoEnabled()) {\n@@ -416,7 +416,7 @@ private List<ServiceInstance> toServiceInstance(Endpoints endpoints, String serv\n                     String properties = pod.getMetadata().getAnnotations().get(KUBERNETES_PROPERTIES_KEY);\n                     if (StringUtils.isNotEmpty(properties)) {\n-                        serviceInstance.getMetadata().putAll(JSONObject.parseObject(properties, Map.class));\n+                        serviceInstance.getMetadata().putAll(JsonUtils.getJson().toJavaObject(properties, Map.class));\n                         instances.add(serviceInstance);\n                     } else {\n                         logger.warn(REGISTRY_UNABLE_FIND_SERVICE_KUBERNETES, \"\", \"\", \"Unable to find Service Instance metadata in Pod Annotations. \" +\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ReflectionBasedServiceDiscovery.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ReflectionBasedServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ReflectionBasedServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ReflectionBasedServiceDiscovery.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.JsonUtils;\n import org.apache.dubbo.common.utils.NamedThreadFactory;\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n@@ -37,8 +38,6 @@\n import org.apache.dubbo.rpc.model.ScopeModelUtil;\n import org.apache.dubbo.rpc.service.Destroyable;\n-import com.alibaba.fastjson.JSONObject;\n-\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.Iterator;\n@@ -139,7 +138,7 @@ public void doDestroy() throws Exception {\n     }\n     private void updateInstanceMetadata(ServiceInstance serviceInstance) {\n-        String metadataString = JSONObject.toJSONString(serviceInstance.getMetadata());\n+        String metadataString = JsonUtils.getJson().toJson(serviceInstance.getMetadata());\n         String metadataRevision = RevisionResolver.calRevision(metadataString);\n         // check if metadata updated\n@@ -201,7 +200,7 @@ public final void fillServiceInstance(DefaultServiceInstance serviceInstance) {\n             // Metadata will be updated by provider callback\n             String metadataString = metadataMap.get(hostId);\n-            serviceInstance.setMetadata(JSONObject.parseObject(metadataString, Map.class));\n+            serviceInstance.setMetadata(JsonUtils.getJson().toJavaObject(metadataString, Map.class));\n         } else {\n             // refer from MetadataUtils, this proxy is different from the one used to refer exportedURL\n             MetadataService metadataService = getMetadataServiceProxy(serviceInstance);\n@@ -220,12 +219,12 @@ public final void fillServiceInstance(DefaultServiceInstance serviceInstance) {\n                     }\n                 });\n             metadataMap.put(hostId, metadata);\n-            serviceInstance.setMetadata(JSONObject.parseObject(metadata, Map.class));\n+            serviceInstance.setMetadata(JsonUtils.getJson().toJavaObject(metadata, Map.class));\n         }\n     }\n     public final void notifyListener(String serviceName, ServiceInstancesChangedListener listener, List<ServiceInstance> instances) {\n-        String serviceInstanceRevision = RevisionResolver.calRevision(JSONObject.toJSONString(instances));\n+        String serviceInstanceRevision = RevisionResolver.calRevision(JsonUtils.getJson().toJson(instances));\n         boolean changed = !serviceInstanceRevision.equalsIgnoreCase(\n             serviceInstanceRevisionMap.put(serviceName, serviceInstanceRevision));",
    "output": "Remove fastjson and gson transitive dependency"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RpcUtilsTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RpcUtilsTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RpcUtilsTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RpcUtilsTest.java\n@@ -370,8 +370,8 @@ public void testGetParameterTypes() {\n         Assertions.assertNotNull(parameterTypes5);\n         Assertions.assertEquals(3, parameterTypes5.length);\n         Assertions.assertEquals(String.class, parameterTypes5[0]);\n-        Assertions.assertEquals(String.class, parameterTypes5[1]);\n-        Assertions.assertEquals(String.class, parameterTypes5[2]);\n+        Assertions.assertEquals(void.class, parameterTypes5[1]);\n+        Assertions.assertEquals(Object.class, parameterTypes5[2]);\n     }\n     @ParameterizedTest",
    "output": "Add dependencies check"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java\n@@ -212,7 +212,7 @@ private void renameFile(File file) {\n             String now = fileNameFormatter.format(new Date());\n             String last = fileNameFormatter.format(new Date(file.lastModified()));\n             if (!now.equals(last)) {\n-                File archive = new File(file.getAbsolutePath() + \".\" + last);\n+                File archive = new File(file.getAbsolutePath() + \".\" + now);\n                 file.renameTo(archive);\n             }\n         }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n@@ -162,7 +162,7 @@ public static Class<?>[] getParameterTypes(Invocation invocation) {\n             }\n             Class<?>[] parameterTypes = new Class<?>[types.length];\n             for (int i = 0; i < types.length; i++) {\n-                parameterTypes[i] = ReflectUtils.forName(types[0]);\n+                parameterTypes[i] = ReflectUtils.forName(types[i]);\n             }\n             return parameterTypes;\n         }",
    "output": "Fix RpcUtils#getParameterTypes and AccessLogFilter#renameFile method"
  },
  {
    "input": "diff --git a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioCitadelCertificateSigner.java b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioCitadelCertificateSigner.java\n--- a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioCitadelCertificateSigner.java\n+++ b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioCitadelCertificateSigner.java\n@@ -19,13 +19,15 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.registry.xds.XdsCertificateSigner;\n import org.apache.dubbo.rpc.RpcException;\n import io.grpc.ManagedChannel;\n import io.grpc.Metadata;\n import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n import io.grpc.stub.MetadataUtils;\n import io.grpc.stub.StreamObserver;\n import istio.v1.auth.IstioCertificateRequest;\n@@ -147,12 +149,22 @@ public CertPair createCert() throws IOException {\n         }\n         String csr = generateCsr(publicKey, signer);\n-        ManagedChannel channel = NettyChannelBuilder.forTarget(istioEnv.getCaAddr())\n-            .sslContext(\n-                GrpcSslContexts.forClient()\n-                    .trustManager(new ByteArrayInputStream(istioEnv.getCaCert().getBytes(StandardCharsets.UTF_8)))\n+        String caCert = istioEnv.getCaCert();\n+        ManagedChannel channel;\n+        if (StringUtils.isNotEmpty(caCert)) {\n+            channel = NettyChannelBuilder.forTarget(istioEnv.getCaAddr())\n+                .sslContext(\n+                    GrpcSslContexts.forClient()\n+                        .trustManager(new ByteArrayInputStream(caCert.getBytes(StandardCharsets.UTF_8)))\n+                        .build())\n+                .build();\n+        } else {\n+            channel = NettyChannelBuilder.forTarget(istioEnv.getCaAddr())\n+                .sslContext(GrpcSslContexts.forClient()\n+                    .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                     .build())\n-            .build();\n+                .build();\n+        }\n         Metadata header = new Metadata();\n         Metadata.Key<String> key = Metadata.Key.of(\"authorization\", Metadata.ASCII_STRING_MARSHALLER);\ndiff --git a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioConstant.java b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioConstant.java\n--- a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioConstant.java\n+++ b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioConstant.java\n@@ -87,6 +87,10 @@ public class IstioConstant {\n     public final static String ISTIO_META_CLUSTER_ID_KEY = \"ISTIO_META_CLUSTER_ID\";\n+    public final static String PILOT_CERT_PROVIDER_KEY = \"PILOT_CERT_PROVIDER\";\n+\n+    public final static String ISTIO_PILOT_CERT_PROVIDER = \"istiod\";\n+\n     public final static String DEFAULT_ISTIO_META_CLUSTER_ID = \"Kubernetes\";\n     public final static String SPIFFE = \"spiffe://\";\ndiff --git a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioEnv.java b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioEnv.java\n--- a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioEnv.java\n+++ b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioEnv.java\n@@ -57,6 +57,8 @@ public class IstioEnv implements XdsEnv {\n     private String istioMetaClusterId;\n+    private String pilotCertProvider;\n+\n     private IstioEnv() {\n         jwtPolicy = Optional.ofNullable(System.getenv(IstioConstant.JWT_POLICY)).orElse(IstioConstant.DEFAULT_JWT_POLICY);\n         podName = Optional.ofNullable(System.getenv(\"POD_NAME\")).orElse(System.getenv(\"HOSTNAME\"));\n@@ -79,6 +81,7 @@ private IstioEnv() {\n         secretTTL = Integer.parseInt(Optional.ofNullable(System.getenv(IstioConstant.SECRET_TTL_KEY)).orElse(IstioConstant.DEFAULT_SECRET_TTL));\n         secretGracePeriodRatio = Float.parseFloat(Optional.ofNullable(System.getenv(IstioConstant.SECRET_GRACE_PERIOD_RATIO_KEY)).orElse(IstioConstant.DEFAULT_SECRET_GRACE_PERIOD_RATIO));\n         istioMetaClusterId = Optional.ofNullable(System.getenv(IstioConstant.ISTIO_META_CLUSTER_ID_KEY)).orElse(IstioConstant.DEFAULT_ISTIO_META_CLUSTER_ID);\n+        pilotCertProvider = Optional.ofNullable(System.getenv(IstioConstant.PILOT_CERT_PROVIDER_KEY)).orElse(\"\");\n         if (getServiceAccount() == null) {\n             throw new UnsupportedOperationException(\"Unable to found kubernetes service account token file. \" +\n@@ -159,13 +162,10 @@ public String getIstioMetaClusterId() {\n     public String getCaCert() {\n         File caFile;\n-        switch (jwtPolicy) {\n-            case IstioConstant.FIRST_PARTY_JWT:\n-                caFile = new File(IstioConstant.KUBERNETES_CA_PATH);\n-                break;\n-            case IstioConstant.THIRD_PARTY_JWT:\n-            default:\n-                caFile = new File(IstioConstant.ISTIO_CA_PATH);\n+        if (IstioConstant.ISTIO_PILOT_CERT_PROVIDER.equals(pilotCertProvider)) {\n+            caFile = new File(IstioConstant.ISTIO_CA_PATH);\n+        } else {\n+            return null;\n         }\n         if (caFile.canRead()) {\n             try {",
    "output": "Fix istio first-party-jwt"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java\n@@ -16,18 +16,6 @@\n  */\n package org.apache.dubbo.config.bootstrap.builders;\n-import static org.apache.dubbo.common.constants.CommonConstants.CORE_THREADS_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_PROTOCOL;\n-import static org.apache.dubbo.common.constants.CommonConstants.THREADPOOL_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.THREADS_KEY;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_SERVICE_CONFIG_ERROR;\n-import static org.apache.dubbo.remoting.Constants.BIND_PORT_KEY;\n-\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.Assert;\n@@ -41,6 +29,18 @@\n import org.apache.dubbo.rpc.ProtocolServer;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+import static org.apache.dubbo.common.constants.CommonConstants.CORE_THREADS_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_PROTOCOL;\n+import static org.apache.dubbo.common.constants.CommonConstants.THREADPOOL_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.THREADS_KEY;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n+import static org.apache.dubbo.remoting.Constants.BIND_PORT_KEY;\n+\n public class InternalServiceConfigBuilder<T> {\n     private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(getClass());\n@@ -143,7 +143,7 @@ public InternalServiceConfigBuilder<T> port(Integer specPort, String key) {\n                     }\n                 }\n             } catch (Exception e) {\n-                logger.error(INTERNAL_SERVICE_CONFIG_ERROR, \"invalid specified \" + port + \"  port, error \"+e.getMessage(),\n+                logger.error(INTERNAL_ERROR, \"invalid specified \" + port + \"  port, error \"+e.getMessage(),\n                     \"\", \"Failed to find any valid protocol, will use random port to export  service.\",e);\n             }\n         }\n@@ -166,6 +166,9 @@ public ServiceConfig<T> build(Consumer<ServiceConfig<T>> configConsumer){\n         logger.info(\"Using \" + this.protocol + \" protocol to export \"+interfaceClass.getName()+\" service on port \" + protocolConfig.getPort());\n+        applicationModel.getApplicationConfigManager().getProtocol(this.protocol)\n+            .ifPresent(protocolConfig::mergeProtocol);\n+\n         ApplicationConfig applicationConfig = getApplicationConfig();\n         ServiceConfig<T> serviceConfig = new ServiceConfig<>();\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n@@ -19,34 +19,22 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.config.ApplicationConfig;\n import org.apache.dubbo.config.ArgumentConfig;\n import org.apache.dubbo.config.MethodConfig;\n-import org.apache.dubbo.config.ProtocolConfig;\n-import org.apache.dubbo.config.RegistryConfig;\n import org.apache.dubbo.config.ServiceConfig;\n import org.apache.dubbo.config.bootstrap.builders.InternalServiceConfigBuilder;\n import org.apache.dubbo.metadata.MetadataService;\n import org.apache.dubbo.registry.client.metadata.MetadataServiceDelegation;\n-import org.apache.dubbo.rpc.ProtocolServer;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n import static java.util.Collections.emptyList;\n-import static org.apache.dubbo.common.constants.CommonConstants.CORE_THREADS_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_PROTOCOL;\n import static org.apache.dubbo.common.constants.CommonConstants.METADATA_SERVICE_PORT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.METADATA_SERVICE_PROTOCOL_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.THREADPOOL_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.THREADS_KEY;\n-import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_FIND_PROTOCOL;\n-import static org.apache.dubbo.remoting.Constants.BIND_PORT_KEY;\n+import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_METADATA_SERVICE_EXPORTED;\n /**\n  * Export metadata service",
    "output": "Fix conflicts"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n@@ -75,7 +75,7 @@ public TripleProtocol(FrameworkModel frameworkModel) {\n         this.pathResolver = frameworkModel.getExtensionLoader(PathResolver.class)\n             .getDefaultExtension();\n         CONVERT_NO_LOWER_HEADER = ConfigurationUtils.getEnvConfiguration(ApplicationModel.defaultModel())\n-            .getBoolean(H2_SUPPORT_NO_LOWER_HEADER_KEY, false);\n+            .getBoolean(H2_SUPPORT_NO_LOWER_HEADER_KEY, true);\n         Set<String> supported = frameworkModel.getExtensionLoader(DeCompressor.class)\n             .getSupportedExtensions();\n         this.acceptEncodings = String.join(\",\", supported);",
    "output": "Change tri support upper attachment config to enable by default"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/TriRpcStatus.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/TriRpcStatus.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/TriRpcStatus.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/TriRpcStatus.java\n@@ -83,7 +83,7 @@ public static TriRpcStatus getStatus(Throwable throwable, String description) {\n             return new TriRpcStatus(code, throwable, description);\n         }\n         if (throwable instanceof TimeoutException) {\n-            return new TriRpcStatus(TriRpcStatus.Code.DEADLINE_EXCEEDED, throwable, description);\n+            return new TriRpcStatus(Code.DEADLINE_EXCEEDED, throwable, description);\n         }\n         return new TriRpcStatus(Code.UNKNOWN, throwable, description);\n     }\n@@ -165,27 +165,27 @@ private static String encodeComponent(String raw) {\n         return encoder.toString().substring(2);\n     }\n-    public static TriRpcStatus.Code httpStatusToGrpcCode(int httpStatusCode) {\n+    public static Code httpStatusToGrpcCode(int httpStatusCode) {\n         if (httpStatusCode >= 100 && httpStatusCode < 200) {\n-            return TriRpcStatus.Code.INTERNAL;\n+            return Code.INTERNAL;\n         }\n         if (httpStatusCode == HttpResponseStatus.BAD_REQUEST.code() ||\n             httpStatusCode == HttpResponseStatus.REQUEST_HEADER_FIELDS_TOO_LARGE.code()\n         ) {\n-            return TriRpcStatus.Code.INTERNAL;\n+            return Code.INTERNAL;\n         } else if (httpStatusCode == HttpResponseStatus.UNAUTHORIZED.code()) {\n-            return TriRpcStatus.Code.UNAUTHENTICATED;\n+            return Code.UNAUTHENTICATED;\n         } else if (httpStatusCode == HttpResponseStatus.FORBIDDEN.code()) {\n-            return TriRpcStatus.Code.PERMISSION_DENIED;\n+            return Code.PERMISSION_DENIED;\n         } else if (httpStatusCode == HttpResponseStatus.NOT_FOUND.code()) {\n-            return TriRpcStatus.Code.UNIMPLEMENTED;\n+            return Code.UNIMPLEMENTED;\n         } else if (httpStatusCode == HttpResponseStatus.BAD_GATEWAY.code()\n             || httpStatusCode == HttpResponseStatus.TOO_MANY_REQUESTS.code()\n             || httpStatusCode == HttpResponseStatus.SERVICE_UNAVAILABLE.code()\n             || httpStatusCode == HttpResponseStatus.GATEWAY_TIMEOUT.code()) {\n             return Code.UNAVAILABLE;\n         } else {\n-            return TriRpcStatus.Code.UNKNOWN;\n+            return Code.UNKNOWN;\n         }\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/stub/StubInvocationUtilTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/stub/StubInvocationUtilTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/stub/StubInvocationUtilTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/stub/StubInvocationUtilTest.java\n@@ -25,7 +25,7 @@\n import org.apache.dubbo.rpc.model.ConsumerModel;\n import org.apache.dubbo.rpc.model.MethodDescriptor;\n import org.apache.dubbo.rpc.model.ServiceDescriptor;\n-import org.apache.dubbo.rpc.support.DemoService;\n+import org.apache.dubbo.rpc.protocol.tri.support.IGreeter;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n@@ -43,21 +43,21 @@ class StubInvocationUtilTest {\n     @Test\n     void unaryCall() throws Throwable {\n-        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n+        Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);\n         URL url = Mockito.mock(URL.class);\n         ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n         ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n         when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n         when(url.getServiceModel())\n             .thenReturn(consumerModel);\n         when(url.getServiceInterface())\n-            .thenReturn(DemoService.class.getName());\n+            .thenReturn(IGreeter.class.getName());\n         when(url.getProtocolServiceKey())\n-            .thenReturn(DemoService.class.getName());\n+            .thenReturn(IGreeter.class.getName());\n         when(invoker.getUrl())\n             .thenReturn(url);\n         when(invoker.getInterface())\n-            .thenReturn(DemoService.class);\n+            .thenReturn(IGreeter.class);\n         Result result = Mockito.mock(Result.class);\n         when(invoker.invoke(any(Invocation.class)))\n             .thenReturn(result);\n@@ -75,21 +75,21 @@ void unaryCall() throws Throwable {\n     @Test\n     void unaryCall2() throws Throwable {\n-        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n+        Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);\n         URL url = Mockito.mock(URL.class);\n         ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n         ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n         when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n         when(url.getServiceModel())\n             .thenReturn(consumerModel);\n         when(url.getServiceInterface())\n-            .thenReturn(DemoService.class.getName());\n+            .thenReturn(IGreeter.class.getName());\n         when(url.getProtocolServiceKey())\n-            .thenReturn(DemoService.class.getName());\n+            .thenReturn(IGreeter.class.getName());\n         when(invoker.getUrl())\n             .thenReturn(url);\n         when(invoker.getInterface())\n-            .thenReturn(DemoService.class);\n+            .thenReturn(IGreeter.class);\n         Result result = Mockito.mock(Result.class);\n         when(invoker.invoke(any(Invocation.class)))\n             .thenThrow(new RuntimeException(\"a\"))\n@@ -118,21 +118,21 @@ void unaryCall2() throws Throwable {\n     @Test\n     void testUnaryCall() throws Throwable {\n-        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n+        Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);\n         URL url = Mockito.mock(URL.class);\n         ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n         ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n         when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n         when(url.getServiceModel())\n             .thenReturn(consumerModel);\n         when(url.getServiceInterface())\n-            .thenReturn(DemoService.class.getName());\n+            .thenReturn(IGreeter.class.getName());\n         when(url.getProtocolServiceKey())\n-            .thenReturn(DemoService.class.getName());\n+            .thenReturn(IGreeter.class.getName());\n         when(invoker.getUrl())\n             .thenReturn(url);\n         when(invoker.getInterface())\n-            .thenReturn(DemoService.class);\n+            .thenReturn(IGreeter.class);\n         Result result = Mockito.mock(Result.class);\n         String response = \"response\";\n         when(invoker.invoke(any(Invocation.class)))\n@@ -168,21 +168,21 @@ public void onCompleted() {\n     @Test\n     void biOrClientStreamCall() throws InterruptedException {\n-        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n+        Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);\n         URL url = Mockito.mock(URL.class);\n         ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n         ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n         when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n         when(url.getServiceModel())\n             .thenReturn(consumerModel);\n         when(url.getServiceInterface())\n-            .thenReturn(DemoService.class.getName());\n+            .thenReturn(IGreeter.class.getName());\n         when(url.getProtocolServiceKey())\n-            .thenReturn(DemoService.class.getName());\n+            .thenReturn(IGreeter.class.getName());\n         when(invoker.getUrl())\n             .thenReturn(url);\n         when(invoker.getInterface())\n-            .thenReturn(DemoService.class);\n+            .thenReturn(IGreeter.class);\n         Result result = Mockito.mock(Result.class);\n         String response = \"response\";\n@@ -243,21 +243,21 @@ public void onCompleted() {\n     @Test\n     void serverStreamCall() throws InterruptedException {\n-        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);\n+        Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);\n         URL url = Mockito.mock(URL.class);\n         ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);\n         ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);\n         when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);\n         when(url.getServiceModel())\n             .thenReturn(consumerModel);\n         when(url.getServiceInterface())\n-            .thenReturn(DemoService.class.getName());\n+            .thenReturn(IGreeter.class.getName());\n         when(url.getProtocolServiceKey())\n-            .thenReturn(DemoService.class.getName());\n+            .thenReturn(IGreeter.class.getName());\n         when(invoker.getUrl())\n             .thenReturn(url);\n         when(invoker.getInterface())\n-            .thenReturn(DemoService.class);\n+            .thenReturn(IGreeter.class);\n         Result result = Mockito.mock(Result.class);\n         String response = \"response\";\n         when(invoker.invoke(any(Invocation.class)))",
    "output": "Remove `netty-all` dependency"
  },
  {
    "input": "diff --git a/dubbo-native-plugin/src/main/java/org/apache/dubbo/maven/plugin/ClassFinder.java b/dubbo-native-plugin/src/main/java/org/apache/dubbo/maven/plugin/ClassFinder.java\n--- a/dubbo-native-plugin/src/main/java/org/apache/dubbo/maven/plugin/ClassFinder.java\n+++ b/dubbo-native-plugin/src/main/java/org/apache/dubbo/maven/plugin/ClassFinder.java\n@@ -56,15 +56,18 @@ public Set<String> findClassSet(String packageName, Consumer<String> consumer) {\n     private void findClassesByFile(String packageName, String resource, Set<String> result) {\n         File directory = new File(resource);\n         File[] listFiles = directory.listFiles();\n-        for (File file : listFiles) {\n-            if (file.isDirectory()) {\n-                findClassesByFile(packageName, file.getPath(), result);\n-            } else {\n-                String path = file.getPath();\n-                if (path.endsWith(\".class\")) {\n-                    int packageIndex = path.indexOf(packageName.replace(\"/\", File.separator));\n-                    String classPath = path.substring(packageIndex, path.length() - 6);\n-                    result.add(classPath.replace(File.separator, \".\"));\n+        // null check\n+        if (listFiles != null) {\n+            for (File file : listFiles) {\n+                if (file.isDirectory()) {\n+                    findClassesByFile(packageName, file.getPath(), result);\n+                } else {\n+                    String path = file.getPath();\n+                    if (path.endsWith(\".class\")) {\n+                        int packageIndex = path.indexOf(packageName.replace(\"/\", File.separator));\n+                        String classPath = path.substring(packageIndex, path.length() - 6);\n+                        result.add(classPath.replace(File.separator, \".\"));\n+                    }\n                 }\n             }\n         }\ndiff --git a/dubbo-native/src/main/java/org/apache/dubbo/utils/ClassFinder.java b/dubbo-native/src/main/java/org/apache/dubbo/utils/ClassFinder.java\n--- a/dubbo-native/src/main/java/org/apache/dubbo/utils/ClassFinder.java\n+++ b/dubbo-native/src/main/java/org/apache/dubbo/utils/ClassFinder.java\n@@ -56,15 +56,17 @@ public Set<String> findClassSet(String packageName) {\n     private void findClassesByFile(String packageName, String resource, Set<String> result) {\n         File directory = new File(resource);\n         File[] listFiles = directory.listFiles();\n-        for (File file : listFiles) {\n-            if (file.isDirectory()) {\n-                findClassesByFile(packageName, file.getPath(), result);\n-            } else {\n-                String path = file.getPath();\n-                if (path.endsWith(\".class\")) {\n-                    int packageIndex = path.indexOf(packageName.replace(\"/\", File.separator));\n-                    String classPath = path.substring(packageIndex, path.length() - 6);\n-                    result.add(classPath.replace(File.separator, \".\"));\n+        if (listFiles != null) {\n+            for (File file : listFiles) {\n+                if (file.isDirectory()) {\n+                    findClassesByFile(packageName, file.getPath(), result);\n+                } else {\n+                    String path = file.getPath();\n+                    if (path.endsWith(\".class\")) {\n+                        int packageIndex = path.indexOf(packageName.replace(\"/\", File.separator));\n+                        String classPath = path.substring(packageIndex, path.length() - 6);\n+                        result.add(classPath.replace(File.separator, \".\"));\n+                    }\n                 }\n             }\n         }\ndiff --git a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/initializer/ConfigZookeeperInitializer.java b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/initializer/ConfigZookeeperInitializer.java\n--- a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/initializer/ConfigZookeeperInitializer.java\n+++ b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/initializer/ConfigZookeeperInitializer.java\n@@ -23,7 +23,6 @@\n import org.apache.dubbo.test.check.registrycenter.context.ZookeeperContext;\n import java.io.File;\n-import java.io.FileInputStream;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.nio.file.Files;\n@@ -54,7 +53,8 @@ private void updateConfig(ZookeeperContext context, int clientPort, int adminSer\n         int availableAdminServerPort = NetUtils.getAvailablePort(adminServerPort);\n         Properties properties = new Properties();\n         try {\n-            properties.load(new FileInputStream(zooSample));\n+            // use Files.newInputStream instead of new FileInputStream\n+            properties.load(Files.newInputStream(zooSample.toPath()));\n             properties.setProperty(\"clientPort\", String.valueOf(clientPort));\n             properties.setProperty(\"admin.serverPort\", String.valueOf(availableAdminServerPort));\n             Path dataDir = Paths.get(zookeeperConf.getParent().toString(), \"data\");\n@@ -87,7 +87,8 @@ private void updateConfig(ZookeeperContext context, int clientPort, int adminSer\n         File log4j = Paths.get(zookeeperConf.toString(), \"log4j.properties\").toFile();\n         try {\n-            properties.load(new FileInputStream(log4j));\n+            // use Files.newInputStream instead of new FileInputStream\n+            properties.load(Files.newInputStream(log4j.toPath()));\n             Path logDir = Paths.get(zookeeperConf.getParent().toString(), \"logs\");\n             if (!Files.exists(logDir)) {\n                 try {",
    "output": "Use Files.newInputStream instead of new FileInputStream and null check"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -770,8 +770,6 @@ public void preDestroy() {\n             onStopping();\n             unregisterServiceInstance();\n-            destroyRegistries();\n-            destroyMetadataReports();\n             unRegisterShutdownHook();\n             if (asyncMetadataFuture != null) {\n@@ -788,6 +786,9 @@ public void postDestroy() {\n                 return;\n             }\n             try {\n+                destroyRegistries();\n+                destroyMetadataReports();\n+\n                 executeShutdownCallbacks();\n                 // TODO should we close unused protocol server which only used by this application?\ndiff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n@@ -531,6 +531,17 @@ private List<String> doGetServiceNames(URL url) {\n         return serviceNames;\n     }\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        try {\n+            this.namingService.shutdown();\n+        } catch (NacosException e) {\n+            logger.warn(\"Unable to shutdown nacos naming service\", e);\n+        }\n+        this.nacosListeners.clear();\n+    }\n+\n     private List<URL> toUrlWithEmpty(URL consumerURL, Collection<Instance> instances) {\n         List<URL> urls = buildURLs(consumerURL, instances);\n         // Nacos does not support configurators and routers from registry, so all notifications are of providers type.",
    "output": "Fix Registry Destroy Order"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ConnectionTest.java b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ConnectionTest.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ConnectionTest.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ConnectionTest.java\n@@ -28,9 +28,9 @@\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n-public class ConnectionTest {\n+class ConnectionTest {\n     @Test\n-    public void connectSyncTest() throws Throwable {\n+    void connectSyncTest() throws Throwable {\n         int port = NetUtils.getAvailablePort();\n         URL url = URL.valueOf(\"empty://127.0.0.1:\" + port + \"?foo=bar\");\n         NettyPortUnificationServer server = null;\n@@ -57,39 +57,44 @@ public void connectSyncTest() throws Throwable {\n                 // ignored\n             }\n         }\n-\n-\n     }\n     @Test\n-    public void testMultiConnect() throws Throwable {\n+    void testMultiConnect() throws Throwable {\n         int port = NetUtils.getAvailablePort();\n         URL url = URL.valueOf(\"empty://127.0.0.1:\" + port + \"?foo=bar\");\n         NettyPortUnificationServer server = null;\n+        ExecutorService service = Executors.newFixedThreadPool(10);\n+\n         try {\n             server = new NettyPortUnificationServer(url, new DefaultPuHandler());\n-            server.close();\n             Connection connection = new Connection(url);\n-            ExecutorService service = Executors.newFixedThreadPool(10);\n+\n             final CountDownLatch latch = new CountDownLatch(10);\n             for (int i = 0; i < 10; i++) {\n                 Runnable runnable = () -> {\n                     try {\n                         Assertions.assertTrue(connection.isAvailable());\n-                        latch.countDown();\n                     } catch (Exception e) {\n                         // ignore\n+                    } finally {\n+                        latch.countDown();\n                     }\n                 };\n+\n                 service.execute(runnable);\n             }\n+\n+            latch.await();\n         } finally {\n             try {\n                 server.close();\n             } catch (Throwable e) {\n                 // ignored\n             }\n+\n+            service.shutdown();\n         }\n     }\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ExecuteLimitFilterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ExecuteLimitFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ExecuteLimitFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ExecuteLimitFilterTest.java\n@@ -22,6 +22,7 @@\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.RpcStatus;\n import org.apache.dubbo.rpc.support.BlockMyInvoker;\n@@ -36,12 +37,12 @@\n import static org.mockito.Mockito.doThrow;\n import static org.mockito.Mockito.when;\n-public class ExecuteLimitFilterTest {\n+class ExecuteLimitFilterTest {\n     private ExecuteLimitFilter executeLimitFilter = new ExecuteLimitFilter();\n     @Test\n-    public void testNoExecuteLimitInvoke() throws Exception {\n+    void testNoExecuteLimitInvoke() {\n         Invoker invoker = Mockito.mock(Invoker.class);\n         when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(\"result\"));\n         when(invoker.getUrl()).thenReturn(URL.valueOf(\"test://test:11/test?accesslog=true&group=dubbo&version=1.1\"));\n@@ -54,7 +55,7 @@ public void testNoExecuteLimitInvoke() throws Exception {\n     }\n     @Test\n-    public void testExecuteLimitInvoke() throws Exception {\n+    void testExecuteLimitInvoke() {\n         Invoker invoker = Mockito.mock(Invoker.class);\n         when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(\"result\"));\n         when(invoker.getUrl()).thenReturn(URL.valueOf(\"test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10\"));\n@@ -67,7 +68,7 @@ public void testExecuteLimitInvoke() throws Exception {\n     }\n     @Test\n-    public void testExecuteLimitInvokeWitException() throws Exception {\n+    void testExecuteLimitInvokeWithException() {\n         Invoker invoker = Mockito.mock(Invoker.class);\n         doThrow(new RpcException())\n                 .when(invoker).invoke(any(Invocation.class));\n@@ -89,43 +90,44 @@ public void testExecuteLimitInvokeWitException() throws Exception {\n     }\n     @Test\n-    public void testMoreThanExecuteLimitInvoke() throws Exception {\n+    void testMoreThanExecuteLimitInvoke() {\n         int maxExecute = 10;\n         int totalExecute = 20;\n         final AtomicInteger failed = new AtomicInteger(0);\n-        final Invocation invocation = Mockito.mock(Invocation.class);\n+        final Invocation invocation = Mockito.mock(RpcInvocation.class);\n         when(invocation.getMethodName()).thenReturn(\"testMoreThanExecuteLimitInvoke\");\n         URL url = URL.valueOf(\"test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=\" + maxExecute);\n-        final Invoker<ExecuteLimitFilter> invoker = new BlockMyInvoker<ExecuteLimitFilter>(url, 1000);\n+        final Invoker<ExecuteLimitFilter> invoker = new BlockMyInvoker<>(url, 1000);\n+\n+        final CountDownLatch latchThatWaitsAllThreadStarted = new CountDownLatch(1);\n+        final CountDownLatch latchThatWaitsAllThreadFinished = new CountDownLatch(totalExecute);\n-        final CountDownLatch latch = new CountDownLatch(1);\n         for (int i = 0; i < totalExecute; i++) {\n-            Thread thread = new Thread(new Runnable() {\n-\n-                public void run() {\n-                    try {\n-                        latch.await();\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n-                    }\n-                    try {\n-                        executeLimitFilter.invoke(invoker, invocation);\n-                    } catch (RpcException expected) {\n-                        failed.incrementAndGet();\n-                    }\n+            Thread thread = new Thread(() -> {\n+                try {\n+                    latchThatWaitsAllThreadStarted.await();\n+                    executeLimitFilter.invoke(invoker, invocation);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                } catch (RpcException expected) {\n+                    failed.incrementAndGet();\n+                } finally {\n+                    latchThatWaitsAllThreadFinished.countDown();\n                 }\n             });\n+\n             thread.start();\n         }\n-        latch.countDown();\n+\n+        latchThatWaitsAllThreadStarted.countDown();\n         try {\n-            Thread.sleep(1000);\n+            latchThatWaitsAllThreadFinished.await();\n         } catch (InterruptedException e) {\n-            e.printStackTrace();\n+            throw new RuntimeException(e);\n         }\n         Assertions.assertEquals(totalExecute - maxExecute, failed.get());",
    "output": "Fix assertion error and class cast exception in unit tests"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/PortUnificationTransporter.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/PortUnificationTransporter.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/PortUnificationTransporter.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/PortUnificationTransporter.java\n@@ -25,7 +25,7 @@\n import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.remoting.RemotingException;\n-@SPI(value = \"netty\", scope = ExtensionScope.FRAMEWORK)\n+@SPI(value = \"netty4\", scope = ExtensionScope.FRAMEWORK)\n public interface PortUnificationTransporter {\n     @Adaptive({Constants.SERVER_KEY, Constants.TRANSPORTER_KEY})\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationTransporter.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationTransporter.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationTransporter.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationTransporter.java\n@@ -25,7 +25,7 @@\n public class NettyPortUnificationTransporter implements PortUnificationTransporter {\n-    public static final String NAME = \"netty\";\n+    public static final String NAME = \"netty4\";\n     @Override\n     public AbstractPortUnificationServer bind(URL url, ChannelHandler handler) throws RemotingException {",
    "output": "Fix no such extension by name netty4"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/LoggerCodeConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/LoggerCodeConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/LoggerCodeConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/LoggerCodeConstants.java\n@@ -164,4 +164,9 @@ public interface LoggerCodeConstants {\n     String TRANSPORT_CLIENT_CONNECT_TIMEOUT = \"6-2\";\n+    // Internal unknown error.\n+\n+    String INTERNAL_ERROR = \"99-0\";\n+\n+    String INTERNAL_INTERRUPTED = \"99-1\";\n }",
    "output": "Add 99-X error codes"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractServer.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractServer.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractServer.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractServer.java\n@@ -72,7 +72,7 @@ public AbstractServer(URL url, ChannelHandler handler) throws RemotingException\n             }\n         } catch (Throwable t) {\n             throw new RemotingException(url.toInetSocketAddress(), null, \"Failed to bind \" + getClass().getSimpleName()\n-                    + \" on \" + getLocalAddress() + \", cause: \" + t.getMessage(), t);\n+                    + \" on \" + bindAddress + \", cause: \" + t.getMessage(), t);\n         }\n         executors.add(executorRepository.createExecutorIfAbsent(url));\n     }",
    "output": "Fix NullPointerException when address already in use"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n@@ -46,6 +46,7 @@ public class ModuleModel extends ScopeModel {\n     private ModuleServiceRepository serviceRepository;\n     private ModuleConfigManager moduleConfigManager;\n     private ModuleDeployer deployer;\n+    private boolean lifeCycleManagedExternally = false;\n     public ModuleModel(ApplicationModel applicationModel) {\n         this(applicationModel, false);\n@@ -196,4 +197,12 @@ public ConsumerModel registerInternalConsumer(Class<?> internalService, URL url)\n         serviceRepository.registerConsumer(consumerModel);\n         return consumerModel;\n     }\n+\n+    public boolean isLifeCycleManagedExternally() {\n+        return lifeCycleManagedExternally;\n+    }\n+\n+    public void setLifeCycleManagedExternally(boolean lifeCycleManagedExternally) {\n+        this.lifeCycleManagedExternally = lifeCycleManagedExternally;\n+    }\n }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ModuleModelTest.java b/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ModuleModelTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ModuleModelTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/rpc/model/ModuleModelTest.java\n@@ -40,6 +40,7 @@ public void testInitialize() {\n         Assertions.assertEquals(moduleModel.getApplicationModel(), applicationModel);\n         Assertions.assertTrue(applicationModel.getPubModuleModels().contains(moduleModel));\n         Assertions.assertNotNull(moduleModel.getInternalId());\n+        Assertions.assertFalse(moduleModel.isLifeCycleManagedExternally());\n         Assertions.assertNotNull(moduleModel.getExtensionDirector());\n         Assertions.assertNotNull(moduleModel.getBeanFactory());\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n@@ -22,7 +22,9 @@\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.Assert;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.ModuleModel;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_SHUTDOWN_HOOK;\n@@ -77,7 +79,47 @@ public void run() {\n     }\n     private void doDestroy() {\n-        applicationModel.destroy();\n+        boolean hasModuleBindSpring = false;\n+        // check if any modules are bound to Spring\n+        for (ModuleModel module: applicationModel.getModuleModels()) {\n+            if (module.isLifeCycleManagedExternally()) {\n+                hasModuleBindSpring = true;\n+                break;\n+            }\n+        }\n+        if (hasModuleBindSpring) {\n+            int timeout = ConfigurationUtils.getServerShutdownTimeout(applicationModel);\n+            if (timeout > 0) {\n+                long start = System.currentTimeMillis();\n+                /**\n+                 * To avoid shutdown conflicts between Dubbo and Spring,\n+                 * wait for the modules bound to Spring to be handled by Spring util timeout.\n+                 */\n+                logger.info(\"Waiting for modules managed by Spring to be shut down.\");\n+                while (!applicationModel.isDestroyed() && hasModuleBindSpring\n+                    && (System.currentTimeMillis() - start) < timeout) {\n+                    try {\n+                        TimeUnit.MILLISECONDS.sleep(10);\n+                        hasModuleBindSpring = false;\n+                        if (!applicationModel.isDestroyed()) {\n+                            for (ModuleModel module: applicationModel.getModuleModels()) {\n+                                if (module.isLifeCycleManagedExternally()) {\n+                                    hasModuleBindSpring = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(e.getMessage(), e);\n+                    }\n+                }\n+            }\n+        }\n+        if (!applicationModel.isDestroyed()) {\n+            logger.info(\"Dubbo shuts down application \" +\n+                \"after Spring fails to do in time or doesn't do it completely.\");\n+            applicationModel.destroy();\n+        }\n     }\n     /**\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/DubboShutdownHookTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/DubboShutdownHookTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/DubboShutdownHookTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/DubboShutdownHookTest.java\n@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.config;\n+\n+import org.apache.dubbo.common.constants.CommonConstants;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.FrameworkModel;\n+import org.apache.dubbo.rpc.model.ModuleModel;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.Arrays.asList;\n+\n+public class DubboShutdownHookTest {\n+    private DubboShutdownHook dubboShutdownHook;\n+    private ApplicationModel applicationModel;\n+\n+    @BeforeEach\n+    public void init() {\n+        SysProps.setProperty(CommonConstants.IGNORE_LISTEN_SHUTDOWN_HOOK, \"false\");\n+        FrameworkModel frameworkModel = new FrameworkModel();\n+        applicationModel = new ApplicationModel(frameworkModel);\n+        ModuleModel moduleModel = applicationModel.newModule();\n+        dubboShutdownHook = new DubboShutdownHook(applicationModel);\n+    }\n+\n+    @AfterEach\n+    public void clear() {\n+        SysProps.clear();\n+    }\n+\n+    @Test\n+    public void testDubboShutdownHook() {\n+        Assertions.assertNotNull(dubboShutdownHook);\n+        Assertions.assertLinesMatch(asList(\"DubboShutdownHook\"), asList(dubboShutdownHook.getName()));\n+        Assertions.assertFalse(dubboShutdownHook.getRegistered());\n+    }\n+\n+    @Test\n+    public void testDestoryNoModuleManagedExternally() {\n+        boolean hasModuleManagedExternally = false;\n+        for (ModuleModel moduleModel : applicationModel.getModuleModels()) {\n+            if (moduleModel.isLifeCycleManagedExternally()) {\n+                hasModuleManagedExternally = true;\n+                break;\n+            }\n+        }\n+        Assertions.assertFalse(hasModuleManagedExternally);\n+        dubboShutdownHook.run();\n+        Assertions.assertTrue(applicationModel.isDestroyed());\n+    }\n+\n+    @Test\n+    public void testDestoryWithModuleManagedExternally() throws InterruptedException {\n+        applicationModel.getModuleModels().get(0).setLifeCycleManagedExternally(true);\n+        new Thread(() -> {\n+            applicationModel.getModuleModels().get(0).destroy();\n+        }).start();\n+        TimeUnit.MILLISECONDS.sleep(10);\n+        dubboShutdownHook.run();\n+        Assertions.assertTrue(applicationModel.isDestroyed());\n+    }\n+}\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboSpringInitializer.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboSpringInitializer.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboSpringInitializer.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboSpringInitializer.java\n@@ -138,6 +138,7 @@ private static void initContext(DubboSpringInitContext context, BeanDefinitionRe\n         // mark context as bound\n         context.markAsBound();\n+        moduleModel.setLifeCycleManagedExternally(true);\n         // register common beans\n         DubboBeanUtils.registerCommonBeans(registry);",
    "output": "Fix issue: resolve the conficts between Dubbo shutdown hook and Spring"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServiceContext.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServiceContext.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServiceContext.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServiceContext.java\n@@ -186,6 +186,9 @@ public List<URL> getUrls() {\n     @Override\n     public void setUrls(List<URL> urls) {\n         this.urls = urls;\n+        if (!urls.isEmpty()) {\n+            this.url = urls.get(0);\n+        }\n     }\n     @Override",
    "output": "Fix getUrl NPE after setInvokers"
  },
  {
    "input": "diff --git a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java\n--- a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java\n+++ b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java\n@@ -226,17 +226,22 @@ public void onNext(DiscoveryResponse value) {\n                 return;\n             }\n             observer.onNext(buildDiscoveryRequest(Collections.emptySet(), value));\n-            CompletableFuture<T> future = streamResult.get(requestId);\n-            if (future == null) {\n-                return;\n-            }\n-            future.complete(result);\n+            returnResult(result);\n         }\n         @Override\n         public void onError(Throwable t) {\n             logger.error(\"xDS Client received error message! detail:\", t);\n             clear();\n+            returnResult(null);\n+        }\n+\n+        private void returnResult(T result) {\n+            CompletableFuture<T> future = streamResult.get(requestId);\n+            if (future == null) {\n+                return;\n+            }\n+            future.complete(result);\n         }\n         @Override",
    "output": "Fix xds long time wait"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -122,6 +122,8 @@ public interface CommonConstants {\n     String CORE_THREADS_KEY = \"corethreads\";\n+    String THREAD_POOL_EXHAUSTED_LISTENERS_KEY = \"thread-pool-exhausted-listeners\";\n+\n     String THREADS_KEY = \"threads\";\n     String QUEUES_KEY = \"queues\";\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/event/ThreadPoolExhaustedListener.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/event/ThreadPoolExhaustedListener.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/event/ThreadPoolExhaustedListener.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/event/ThreadPoolExhaustedListener.java\n@@ -16,6 +16,10 @@\n  */\n package org.apache.dubbo.common.threadpool.event;\n+import org.apache.dubbo.common.extension.ExtensionScope;\n+import org.apache.dubbo.common.extension.SPI;\n+\n+@SPI(scope = ExtensionScope.FRAMEWORK)\n public interface ThreadPoolExhaustedListener {\n     /**\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java\n@@ -18,13 +18,15 @@\n package org.apache.dubbo.common.threadpool.support;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.threadpool.event.ThreadPoolExhaustedEvent;\n import org.apache.dubbo.common.threadpool.event.ThreadPoolExhaustedListener;\n import org.apache.dubbo.common.utils.ConcurrentHashSet;\n import org.apache.dubbo.common.utils.JVMUtil;\n import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.model.FrameworkModel;\n import java.io.File;\n import java.io.FileOutputStream;\n@@ -38,9 +40,11 @@\n import java.util.concurrent.ThreadPoolExecutor;\n import static java.lang.String.format;\n+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SEPARATOR_CHAR;\n import static org.apache.dubbo.common.constants.CommonConstants.DUMP_DIRECTORY;\n import static org.apache.dubbo.common.constants.CommonConstants.OS_NAME_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.OS_WIN_PREFIX;\n+import static org.apache.dubbo.common.constants.CommonConstants.THREAD_POOL_EXHAUSTED_LISTENERS_KEY;\n import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_THREAD_POOL_EXHAUSTED;\n /**\n@@ -72,18 +76,32 @@ public class AbortPolicyWithReport extends ThreadPoolExecutor.AbortPolicy {\n     public AbortPolicyWithReport(String threadName, URL url) {\n         this.threadName = threadName;\n         this.url = url;\n+\n+        String threadPoolExhaustedListeners =\n+            url.getParameter(THREAD_POOL_EXHAUSTED_LISTENERS_KEY, (String) url.getAttribute(THREAD_POOL_EXHAUSTED_LISTENERS_KEY));\n+\n+        Set<String> listenerKeys = StringUtils.splitToSet(threadPoolExhaustedListeners, COMMA_SEPARATOR_CHAR, true);\n+\n+        FrameworkModel frameworkModel = url.getOrDefaultFrameworkModel();\n+        ExtensionLoader<ThreadPoolExhaustedListener> extensionLoader = frameworkModel.getExtensionLoader(ThreadPoolExhaustedListener.class);\n+        listenerKeys.forEach(key -> {\n+            if (extensionLoader.hasExtension(key)) {\n+                addThreadPoolExhaustedEventListener(extensionLoader.getExtension(key));\n+            }\n+        });\n+\n     }\n     @Override\n     public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n         String msg = String.format(\"Thread pool is EXHAUSTED!\" +\n-                        \" Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d),\" +\n-                        \" Task: %d (completed: %d),\" +\n-                        \" Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!\",\n-                threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(),\n-                e.getLargestPoolSize(),\n-                e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(),\n-                url.getProtocol(), url.getIp(), url.getPort());\n+                \" Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d),\" +\n+                \" Task: %d (completed: %d),\" +\n+                \" Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!\",\n+            threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(),\n+            e.getLargestPoolSize(),\n+            e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(),\n+            url.getProtocol(), url.getIp(), url.getPort());\n         // 0-1 - Thread pool is EXHAUSTED!\n         logger.warn(COMMON_THREAD_POOL_EXHAUSTED, \"too much client requesting provider\", \"\", msg);\n@@ -104,6 +122,7 @@ public void removeThreadPoolExhaustedEventListener(ThreadPoolExhaustedListener l\n     /**\n      * dispatch ThreadPoolExhaustedEvent\n+     *\n      * @param msg\n      */\n     public void dispatchThreadPoolExhaustedEvent(String msg) {\n@@ -140,7 +159,7 @@ private void dumpJStack() {\n             String dateStr = sdf.format(new Date());\n             //try-with-resources\n             try (FileOutputStream jStackStream = new FileOutputStream(\n-                    new File(dumpPath, \"Dubbo_JStack.log\" + \".\" + dateStr))) {\n+                new File(dumpPath, \"Dubbo_JStack.log\" + \".\" + dateStr))) {\n                 JVMUtil.jstack(jStackStream);\n             } catch (Throwable t) {\n                 logger.error(\"dump jStack error\", t);\n@@ -165,7 +184,7 @@ private String getDumpPath() {\n                 logger.info(format(\"Dubbo dump directory[%s] created\", dumpDirectory.getAbsolutePath()));\n             } else {\n                 logger.warn(format(\"Dubbo dump directory[%s] can't be created, use the 'user.home'[%s]\",\n-                        dumpDirectory.getAbsolutePath(), USER_HOME));\n+                    dumpDirectory.getAbsolutePath(), USER_HOME));\n                 return USER_HOME;\n             }\n         }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ProtocolConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n@@ -24,6 +24,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_PROTOCOL;\n import static org.apache.dubbo.common.constants.CommonConstants.SSL_ENABLED_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.THREAD_POOL_EXHAUSTED_LISTENERS_KEY;\n /**\n  * ProtocolConfig\n@@ -89,6 +90,12 @@ public class ProtocolConfig extends AbstractConfig {\n      */\n     private Integer queues;\n+\n+    /**\n+     * Thread pool exhausted listeners\n+     */\n+    private String threadPoolExhaustedListeners;\n+\n     /**\n      * Max acceptable connections\n      */\n@@ -303,6 +310,15 @@ public void setThreadname(String threadname) {\n         this.threadname = threadname;\n     }\n+    @Parameter(key = THREAD_POOL_EXHAUSTED_LISTENERS_KEY)\n+    public String getThreadPoolExhaustedListeners() {\n+        return threadPoolExhaustedListeners;\n+    }\n+\n+    public void setThreadPoolExhaustedListeners(String threadPoolExhaustedListeners) {\n+        this.threadPoolExhaustedListeners = threadPoolExhaustedListeners;\n+    }\n+\n     public Integer getCorethreads() {\n         return corethreads;\n     }",
    "output": "Add thread pool exhausted listener config"
  },
  {
    "input": "diff --git a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java\n--- a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java\n+++ b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java\n@@ -154,6 +154,11 @@ public long observeResource(Set<String> resourceNames, Consumer<T> consumer) {\n                 // observer reused\n                 StreamObserver<DiscoveryRequest> observer = requestObserverMap.get(request);\n+                if (observer == null) {\n+                    observer = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request));\n+                    requestObserverMap.put(request, observer);\n+                }\n+\n                 // send request to control panel\n                 observer.onNext(buildDiscoveryRequest(names));\n@@ -231,11 +236,17 @@ public void onNext(DiscoveryResponse value) {\n         @Override\n         public void onError(Throwable t) {\n             logger.error(\"xDS Client received error message! detail:\", t);\n+            clear();\n         }\n         @Override\n         public void onCompleted() {\n-            // ignore\n+            logger.info(\"xDS Client completed, requestId: \" + requestId);\n+            clear();\n+        }\n+\n+        private void clear() {\n+            requestObserverMap.remove(requestId);\n         }\n     }",
    "output": "Fix dubbo proxyless xds connect, fix Connection closed after GOAWAY, add xds observer retry create"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -112,6 +112,8 @@ public interface CommonConstants {\n     String EXECUTOR_SERVICE_COMPONENT_KEY = ExecutorService.class.getName();\n+    String CONSUMER_SHARED_EXECUTOR_SERVICE_COMPONENT_KEY = \"CONSUMER_SHARED_SERVICE_EXECUTOR\";\n+\n     String INTERNAL_EXECUTOR_SERVICE_COMPONENT_KEY = \"INTERNAL_SERVICE_EXECUTOR\";\n     String THREADPOOL_KEY = \"threadpool\";\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.common.extension.ExtensionAccessorAware;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.store.DataStore;\n import org.apache.dubbo.common.threadpool.ThreadPool;\n import org.apache.dubbo.common.utils.ExecutorUtil;\n import org.apache.dubbo.common.utils.NamedThreadFactory;\n@@ -40,6 +41,7 @@\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ThreadPoolExecutor;\n+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SHARED_EXECUTOR_SERVICE_COMPONENT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_EXPORT_THREAD_NUM;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_PROTOCOL;\n@@ -68,9 +70,12 @@ public class DefaultExecutorRepository implements ExecutorRepository, ExtensionA\n     private final ApplicationModel applicationModel;\n     private final FrameworkExecutorRepository frameworkExecutorRepository;\n+    private final DataStore dataStore;\n+\n     public DefaultExecutorRepository(ApplicationModel applicationModel) {\n         this.applicationModel = applicationModel;\n         this.frameworkExecutorRepository = applicationModel.getFrameworkModel().getBeanFactory().getBean(FrameworkExecutorRepository.class);\n+        this.dataStore = applicationModel.getExtensionLoader(DataStore.class).getDefaultExtension();\n     }\n     /**\n@@ -81,7 +86,8 @@ public DefaultExecutorRepository(ApplicationModel applicationModel) {\n      */\n     @Override\n     public synchronized ExecutorService createExecutorIfAbsent(URL url) {\n-        Map<Integer, ExecutorService> executors = data.computeIfAbsent(getExecutorKey(url), k -> new ConcurrentHashMap<>());\n+        String executorKey = getExecutorKey(url);\n+        Map<Integer, ExecutorService> executors = data.computeIfAbsent(executorKey, k -> new ConcurrentHashMap<>());\n         // Consumer's executor is sharing globally, key=Integer.MAX_VALUE. Provider's executor is sharing by protocol.\n         Integer portKey = CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY)) ? Integer.MAX_VALUE : url.getPort();\n@@ -101,6 +107,8 @@ public synchronized ExecutorService createExecutorIfAbsent(URL url) {\n             executor = createExecutor(url);\n             executors.put(portKey, executor);\n         }\n+\n+        dataStore.put(executorKey, Integer.toString(portKey), executor);\n         return executor;\n     }\n@@ -118,6 +126,10 @@ private String getExecutorKey(URL url) {\n             executorKey = EXECUTOR_SERVICE_COMPONENT_KEY;\n         }\n+\n+        if (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))){\n+            executorKey = CONSUMER_SHARED_EXECUTOR_SERVICE_COMPONENT_KEY;\n+        }\n         return executorKey;\n     }",
    "output": "Fix executor datasource loss"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/TelnetCommandDecoder.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/TelnetCommandDecoder.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/TelnetCommandDecoder.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/TelnetCommandDecoder.java\n@@ -25,11 +25,15 @@ public class TelnetCommandDecoder {\n     public static final CommandContext decode(String str) {\n         CommandContext commandContext = null;\n         if (!StringUtils.isBlank(str)) {\n+            str = str.trim();\n             String[] array = str.split(\"(?<![\\\\\\\\]) \");\n             if (array.length > 0) {\n-                String name = array[0];\n                 String[] targetArgs = new String[array.length - 1];\n                 System.arraycopy(array, 1, targetArgs, 0, array.length - 1);\n+                String name = array[0].trim();\n+                if (name.equals(\"invoke\") && array.length > 2) {\n+                    targetArgs = reBuildInvokeCmdArgs(str);\n+                }\n                 commandContext = CommandContextFactory.newInstance( name, targetArgs,false);\n                 commandContext.setOriginRequest(str);\n             }\n@@ -38,4 +42,8 @@ public static final CommandContext decode(String str) {\n         return commandContext;\n     }\n+    private static String[] reBuildInvokeCmdArgs(String cmd) {\n+        return new String[] {cmd.substring(cmd.indexOf(\" \") + 1).trim()};\n+    }\n+\n }",
    "output": "Fix issue 10405: if the parameter contains Spaces, the invoke telnet command will fail. * fix issue 10405: if the parameter contains Spaces, the invoke telnet command will fail. * code optimizing"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java\n@@ -71,7 +71,7 @@ public class DefaultServiceInstance implements ServiceInstance {\n     private transient Map<String, String> extendParams;\n     private transient List<Endpoint> endpoints;\n     private transient ApplicationModel applicationModel;\n-    private transient InstanceAddressURL instanceAddressURL = null;\n+    private transient Map<String, InstanceAddressURL> instanceAddressURL;\n     public DefaultServiceInstance() {\n     }\n@@ -291,10 +291,15 @@ public void setServiceMetadata(MetadataInfo serviceMetadata) {\n     @Override\n     public InstanceAddressURL toURL(String protocol) {\n-        if (instanceAddressURL == null) {\n-            instanceAddressURL = new InstanceAddressURL(this, serviceMetadata, protocol);\n+        if(instanceAddressURL == null) {\n+            instanceAddressURL = new HashMap<>();\n         }\n-        return instanceAddressURL;\n+        InstanceAddressURL result = instanceAddressURL.getOrDefault(protocol, null);\n+        if (result == null) {\n+            instanceAddressURL.put(protocol, new InstanceAddressURL(this, serviceMetadata, protocol));\n+            result = instanceAddressURL.get(protocol);\n+        }\n+        return result;\n     }\n     @Override",
    "output": "Fix discovery param protocol works abnormally"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java\n@@ -23,6 +23,7 @@\n import java.text.SimpleDateFormat;\n import java.time.LocalDate;\n import java.time.LocalDateTime;\n+import java.time.LocalTime;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Date;\n@@ -34,6 +35,11 @@ public class CompatibleTypeUtils {\n     private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n+    /**\n+     * the text to parse such as \"2007-12-03T10:15:30\"\n+     */\n+    private static final int ISO_LOCAL_DATE_TIME_MIN_LEN = 19;\n+\n     private CompatibleTypeUtils() {\n     }\n@@ -128,7 +134,12 @@ public static Object compatibleTypeConvert(Object value, Class<?> type) {\n                 if (StringUtils.isEmpty(string)) {\n                     return null;\n                 }\n-                return LocalDateTime.parse(string).toLocalTime();\n+\n+                if (string.length() >= ISO_LOCAL_DATE_TIME_MIN_LEN) {\n+                    return LocalDateTime.parse(string).toLocalTime();\n+                } else {\n+                    return LocalTime.parse(string);\n+                }\n             }\n             if (type == Class.class) {\n                 try {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n@@ -33,6 +33,9 @@\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -141,6 +144,10 @@ private static Object generalize(Object pojo, Map<Object, Object> history) {\n         if (ReflectUtils.isPrimitives(pojo.getClass())) {\n             return pojo;\n         }\n+\n+        if (pojo instanceof LocalDate || pojo instanceof LocalDateTime || pojo instanceof LocalTime) {\n+            return pojo.toString();\n+        }\n         if (pojo instanceof Class) {\n             return ((Class) pojo).getName();\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n@@ -32,6 +32,9 @@\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n import java.text.SimpleDateFormat;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Date;\n@@ -760,6 +763,22 @@ public void testRealizeCollectionWithNullElement() {\n         assertEquals(setResult, setStr);\n     }\n+    @Test\n+    public void testJava8Time() {\n+\n+        Object localDateTimeGen = PojoUtils.generalize(LocalDateTime.now());\n+        Object localDateTime = PojoUtils.realize(localDateTimeGen, LocalDateTime.class);\n+        assertEquals(localDateTimeGen, localDateTime.toString());\n+\n+        Object localDateGen = PojoUtils.generalize(LocalDate.now());\n+        Object localDate = PojoUtils.realize(localDateGen, LocalDate.class);\n+        assertEquals(localDateGen, localDate.toString());\n+\n+        Object localTimeGen = PojoUtils.generalize(LocalTime.now());\n+        Object localTime = PojoUtils.realize(localTimeGen, LocalTime.class);\n+        assertEquals(localTimeGen, localTime.toString());\n+    }\n+\n     public enum Day {\n         SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY\n     }",
    "output": "Fix PojoUtils support localdatetime,lcaldate,localtime serializable and deserialize"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n@@ -259,8 +259,17 @@ public static long getTimeout(URL url, String methodName, RpcContext context, lo\n         return timeout;\n     }\n+    public static long getTimeoutFromInvocation(Invocation invocation, long defaultTimeout) {\n+        long timeout = defaultTimeout;\n+        Object genericTimeout = invocation.getObjectAttachment(TIMEOUT_KEY);\n+        if (genericTimeout != null) {\n+            timeout = convertToNumber(genericTimeout, defaultTimeout);\n+        }\n+        return timeout;\n+    }\n+\n     private static long convertToNumber(Object obj, long defaultTimeout) {\n-        long timeout = 0;\n+        long timeout = defaultTimeout;\n         try {\n             if (obj instanceof String) {\n                 timeout = Long.parseLong((String) obj);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -306,7 +306,7 @@ public void destroy() {\n     private int calculateTimeout(Invocation invocation, String methodName) {\n         if (invocation.getObjectAttachment(TIMEOUT_KEY) != null) {\n-            return (int) invocation.getObjectAttachment(TIMEOUT_KEY);\n+            return (int) RpcUtils.getTimeoutFromInvocation(invocation, 3000);\n         }\n         Object countdown = RpcContext.getClientAttachment().getObjectAttachment(TIME_COUNTDOWN_KEY);\n         int timeout;",
    "output": "Fix timeout type cast exception"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java\n@@ -113,6 +113,11 @@ private void startQosServer(URL url) {\n             int port = url.getParameter(QOS_PORT, QosConstants.DEFAULT_PORT);\n             boolean acceptForeignIp = Boolean.parseBoolean(url.getParameter(ACCEPT_FOREIGN_IP, \"false\"));\n             Server server = frameworkModel.getBeanFactory().getBean(Server.class);\n+\n+            if (server.isStarted()) {\n+                return;\n+            }\n+\n             server.setHost(host);\n             server.setPort(port);\n             server.setAcceptForeignIp(acceptForeignIp);\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/protocol/QosProtocolWrapperTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/protocol/QosProtocolWrapperTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/protocol/QosProtocolWrapperTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/protocol/QosProtocolWrapperTest.java\n@@ -17,12 +17,12 @@\n package org.apache.dubbo.qos.protocol;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.qos.command.BaseCommand;\n import org.apache.dubbo.qos.server.Server;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Protocol;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n-\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n@@ -44,19 +44,38 @@ public class QosProtocolWrapperTest {\n     private Invoker invoker = mock(Invoker.class);\n     private Protocol protocol = mock(Protocol.class);\n     private QosProtocolWrapper wrapper;\n+\n+    private URL triUrl = Mockito.mock(URL.class);\n+    private Invoker triInvoker = mock(Invoker.class);\n+    private Protocol triProtocol = mock(Protocol.class);\n+    private QosProtocolWrapper triWrapper;\n+\n     private Server server;\n     @BeforeEach\n     public void setUp() throws Exception {\n         when(url.getParameter(QOS_ENABLE, true)).thenReturn(true);\n         when(url.getParameter(QOS_HOST)).thenReturn(\"localhost\");\n         when(url.getParameter(QOS_PORT, 22222)).thenReturn(12345);\n-        when(url.getParameter(ACCEPT_FOREIGN_IP, true)).thenReturn(false);\n-        when(invoker.getUrl()).thenReturn(url);\n+        when(url.getParameter(ACCEPT_FOREIGN_IP, \"false\")).thenReturn(\"false\");\n         when(url.getProtocol()).thenReturn(REGISTRY_PROTOCOL);\n-        server = FrameworkModel.defaultModel().getBeanFactory().getBean(Server.class);\n+        when(invoker.getUrl()).thenReturn(url);\n+\n         wrapper = new QosProtocolWrapper(protocol);\n         wrapper.setFrameworkModel(FrameworkModel.defaultModel());\n+\n+        // url2 use tri protocol and qos.accept.foreign.ip=true\n+        when(triUrl.getParameter(QOS_ENABLE, true)).thenReturn(true);\n+        when(triUrl.getParameter(QOS_HOST)).thenReturn(\"localhost\");\n+        when(triUrl.getParameter(QOS_PORT, 22222)).thenReturn(12345);\n+        when(triUrl.getParameter(ACCEPT_FOREIGN_IP, \"false\")).thenReturn(\"true\");\n+        when(triUrl.getProtocol()).thenReturn(CommonConstants.TRIPLE);\n+        when(triInvoker.getUrl()).thenReturn(triUrl);\n+\n+        triWrapper = new QosProtocolWrapper(triProtocol);\n+        triWrapper.setFrameworkModel(FrameworkModel.defaultModel());\n+\n+        server = FrameworkModel.defaultModel().getBeanFactory().getBean(Server.class);\n     }\n     @AfterEach\n@@ -86,4 +105,23 @@ public void testRefer() throws Exception {\n         assertThat(server.isAcceptForeignIp(), is(false));\n         verify(protocol).refer(BaseCommand.class, url);\n     }\n+\n+    @Test\n+    public void testMultiProtocol() throws Exception {\n+        //tri protocol start first, acceptForeignIp = true\n+        triWrapper.export(triInvoker);\n+        assertThat(server.isStarted(), is(true));\n+        assertThat(server.getHost(), is(\"localhost\"));\n+        assertThat(server.getPort(), is(12345));\n+        assertThat(server.isAcceptForeignIp(), is(true));\n+        verify(triProtocol).export(triInvoker);\n+\n+        //next registry protocol server still acceptForeignIp=true even though wrapper invoker url set false\n+        wrapper.export(invoker);\n+        assertThat(server.isStarted(), is(true));\n+        assertThat(server.getHost(), is(\"localhost\"));\n+        assertThat(server.getPort(), is(12345));\n+        assertThat(server.isAcceptForeignIp(), is(true));\n+        verify(protocol).export(invoker);\n+    }\n }",
    "output": "Fix(qos): fix qos server not permit if set qos.accept.foreign.ip=true"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n@@ -137,7 +137,7 @@ public static ProxyHolder referProxy(ServiceInstance instance) {\n         Protocol protocol = applicationModel.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n-        url.setServiceModel(consumerModel);\n+        url = url.setServiceModel(consumerModel);\n         Invoker<MetadataService> invoker = protocol.refer(MetadataService.class, url);",
    "output": "Fix NPE when using tri as metadata service protocol"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.threadlocal.InternalThreadLocal;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n@@ -96,9 +97,12 @@ public void run() {\n         try {\n             while ((r = runQueue.poll()) != null) {\n                 try {\n+                    InternalThreadLocal.removeAll();\n                     r.run();\n                 } catch (RuntimeException e) {\n                     LOGGER.error(\"Exception while executing runnable \" + r, e);\n+                } finally {\n+                    InternalThreadLocal.removeAll();\n                 }\n             }\n         } finally {\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.threadlocal.InternalThreadLocal;\n import org.apache.dubbo.remoting.Channel;\n import org.apache.dubbo.remoting.ChannelHandler;\n@@ -52,6 +53,7 @@ public ChannelEventRunnable(Channel channel, ChannelHandler handler, ChannelStat\n     @Override\n     public void run() {\n+        InternalThreadLocal.removeAll();\n         if (state == ChannelState.RECEIVED) {\n             try {\n                 handler.received(channel, message);\n@@ -95,7 +97,7 @@ public void run() {\n                 logger.warn(\"unknown state: \" + state + \", message is \" + message);\n             }\n         }\n-\n+        InternalThreadLocal.removeAll();\n     }\n     /**\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n@@ -131,6 +131,9 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept\n             return invoker.invoke(invocation);\n         } finally {\n             context.clearAfterEachInvoke(true);\n+            if (context.isAsyncStarted()) {\n+                removeContext();\n+            }\n         }\n     }",
    "output": "Fix ContextFilter not cleanup thread"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n@@ -28,10 +28,10 @@\n import org.apache.dubbo.rpc.cluster.Directory;\n import org.apache.dubbo.rpc.cluster.LoadBalance;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n-import static org.apache.dubbo.rpc.Constants.ASYNC_KEY;\n-\n /**\n  * BroadcastClusterInvoker\n  */\n@@ -67,10 +67,15 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L\n         int failThresholdIndex = invokers.size() * broadcastFailPercent / MAX_BROADCAST_FAIL_PERCENT;\n         int failIndex = 0;\n-        for (Invoker<T> invoker : invokers) {\n+        for (int i = 0, invokersSize = invokers.size(); i < invokersSize; i++) {\n+            Invoker<T> invoker = invokers.get(i);\n+            RpcContext.RestoreContext restoreContext = new RpcContext.RestoreContext();\n             try {\n-                RpcInvocation subInvocation = new RpcInvocation(invocation, invoker);\n-                subInvocation.setAttachment(ASYNC_KEY, \"true\");\n+                RpcInvocation subInvocation = new RpcInvocation(invocation.getTargetServiceUniqueName(),\n+                    invocation.getServiceModel(), invocation.getMethodName(), invocation.getServiceName(), invocation.getProtocolServiceKey(),\n+                    invocation.getParameterTypes(), invocation.getArguments(), invocation.copyObjectAttachments(),\n+                    invocation.getInvoker(), Collections.synchronizedMap(new HashMap<>(invocation.getAttributes())),\n+                    invocation instanceof RpcInvocation ? ((RpcInvocation) invocation).getInvokeMode() : null);\n                 result = invokeWithContext(invoker, subInvocation);\n                 if (null != result && result.hasException()) {\n                     Throwable resultException = result.getException();\n@@ -90,6 +95,10 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L\n                 if (failIndex == failThresholdIndex) {\n                     break;\n                 }\n+            } finally {\n+                if (i != invokersSize - 1) {\n+                    restoreContext.restore();\n+                }\n             }\n         }",
    "output": "Fix broadcast context being cleared"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -764,15 +764,14 @@ public void preDestroy() {\n             }\n             onStopping();\n+            unregisterServiceInstance();\n             destroyRegistries();\n-            destroyServiceDiscoveries();\n             destroyMetadataReports();\n             unRegisterShutdownHook();\n             if (asyncMetadataFuture != null) {\n                 asyncMetadataFuture.cancel(true);\n             }\n-            unregisterServiceInstance();\n         }\n     }",
    "output": "Fix unregisterServiceInstance not work in shutdown hook"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n@@ -277,6 +277,9 @@ public void doUnsubscribe(URL url, NotifyListener listener) {\n             shutdownServiceNamesLookup();\n         } else {\n             Map<NotifyListener, NacosAggregateListener> listenerMap = originToAggregateListener.get(url);\n+            if (listenerMap == null) {\n+                return;\n+            }\n             NacosAggregateListener nacosAggregateListener = listenerMap.remove(listener);\n             if (nacosAggregateListener != null) {\n                 Set<String> serviceNames = getServiceNames(url, nacosAggregateListener);\ndiff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n@@ -78,6 +78,7 @@ public NacosServiceDiscovery(ApplicationModel applicationModel, URL registryURL)\n     @Override\n     public void doDestroy() throws Exception {\n         this.namingService.shutdown();\n+        this.eventListeners.clear();\n     }\n     @Override",
    "output": "Fix Nacos unSubscribe when shutdown"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n@@ -735,7 +735,7 @@ public boolean hasMethodParameter(String method) {\n         }\n         public String toDescString() {\n-            return this.getMatchKey() + path + new TreeMap<>(getParams());\n+            return this.getMatchKey() + port + path + new TreeMap<>(getParams());\n         }\n         public void addParameter(String key, String value) {",
    "output": "Fix Service Discovery Port Match"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/cache/FileCacheStore.java b/dubbo-common/src/main/java/org/apache/dubbo/common/cache/FileCacheStore.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/cache/FileCacheStore.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/cache/FileCacheStore.java\n@@ -73,7 +73,9 @@ public synchronized Map<String, String> loadCache(int entrySize) throws IOExcept\n             }\n             if (count > entrySize) {\n-                logger.warn(\"Cache file was truncated for exceeding the maximum entry size \" + entrySize);\n+                logger.warn(\"0-4\", \"mis-configuration of system properties\",\n+                    \"Check Java system property 'dubbo.mapping.cache.entrySize' and 'dubbo.meta.cache.entrySize'.\",\n+                    \"Cache file was truncated for exceeding the maximum entry size: \" + entrySize);\n             }\n         } catch (IOException e) {\n             logger.warn(\"Load cache failed \", e);\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n@@ -136,6 +136,7 @@ public ExecutorService getExecutor(URL url) {\n         if (executors == null) {\n             logger.warn(\"No available executors, this is not expected, framework should call createExecutorIfAbsent first \" +\n                 \"before coming to here.\");\n+\n             return null;\n         }\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/WrappedChannelHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/WrappedChannelHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/WrappedChannelHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/WrappedChannelHandler.java\n@@ -75,15 +75,19 @@ public void caught(Channel channel, Throwable exception) throws RemotingExceptio\n     }\n     protected void sendFeedback(Channel channel, Request request, Throwable t) throws RemotingException {\n-        if (request.isTwoWay()) {\n-            String msg = \"Server side(\" + url.getIp() + \",\" + url.getPort()\n-                    + \") thread pool is exhausted, detail msg:\" + t.getMessage();\n-            Response response = new Response(request.getId(), request.getVersion());\n-            response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);\n-            response.setErrorMessage(msg);\n-            channel.send(response);\n+\n+        if (!request.isTwoWay()) {\n             return;\n         }\n+\n+        String msg = \"Server side(\" + url.getIp() + \",\" + url.getPort()\n+                + \") thread pool is exhausted, detail msg:\" + t.getMessage();\n+\n+        Response response = new Response(request.getId(), request.getVersion());\n+        response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);\n+        response.setErrorMessage(msg);\n+\n+        channel.send(response);\n     }\n     @Override\n@@ -140,12 +144,16 @@ public ExecutorService getSharedExecutorService() {\n         // note: url.getOrDefaultApplicationModel() may create new application model\n         ApplicationModel applicationModel = url.getOrDefaultApplicationModel();\n+\n         ExecutorRepository executorRepository =\n                 applicationModel.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();\n+\n         ExecutorService executor = executorRepository.getExecutor(url);\n+\n         if (executor == null) {\n             executor = executorRepository.createExecutorIfAbsent(url);\n         }\n+\n         return executor;\n     }\n@@ -154,5 +162,4 @@ public ExecutorService getExecutorService() {\n         return getSharedExecutorService();\n     }\n-\n }",
    "output": "Add error code 0-4 with code optimization"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvoker.java\n@@ -17,7 +17,7 @@\n package org.apache.dubbo.rpc.cluster.support;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.timer.HashedWheelTimer;\n import org.apache.dubbo.common.timer.Timeout;\n@@ -50,7 +50,7 @@\n  */\n public class FailbackClusterInvoker<T> extends AbstractClusterInvoker<T> {\n-    private static final Logger logger = LoggerFactory.getLogger(FailbackClusterInvoker.class);\n+    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(FailbackClusterInvoker.class);\n     private static final long RETRY_FAILED_PERIOD = 5;\n@@ -93,7 +93,7 @@ private void addFailed(LoadBalance loadbalance, Invocation invocation, List<Invo\n         try {\n             failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);\n         } catch (Throwable e) {\n-            logger.error(\"Failback background works error, invocation->\" + invocation + \", exception: \" + e.getMessage());\n+            logger.error(\"2-9\",\"add newTimeout exception\",\"\",\"Failback background works error, invocation->\" + invocation + \", exception: \" + e.getMessage(),e);\n         }\n     }\n@@ -108,8 +108,8 @@ protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, Load\n             // Then the serviceContext will be cleared after the call is completed.\n             return invokeWithContextAsync(invoker, invocation, consumerUrl);\n         } catch (Throwable e) {\n-            logger.error(\"Failback to invoke method \" + invocation.getMethodName() + \", wait for retry in background. Ignored exception: \"\n-                + e.getMessage() + \", \", e);\n+            logger.error(\"2-10\",\"Failback to invoke method and start to retries\",\"\",\"Failback to invoke method \" + invocation.getMethodName() + \", wait for retry in background. Ignored exception: \"\n+                + e.getMessage() + \", \",e);\n             if (retries > 0) {\n                 addFailed(loadbalance, invocation, invokers, invoker, consumerUrl);\n             }\n@@ -166,9 +166,9 @@ public void run(Timeout timeout) {\n                 lastInvoker = retryInvoker;\n                 invokeWithContextAsync(retryInvoker, invocation, consumerUrl);\n             } catch (Throwable e) {\n-                logger.error(\"Failed retry to invoke method \" + invocation.getMethodName() + \", waiting again.\", e);\n+                logger.error(\"2-10\",\"Failed retry to invoke method\",\"\",\"Failed retry to invoke method \" + invocation.getMethodName() + \", waiting again.\",e);\n                 if ((++retriedTimes) >= retries) {\n-                    logger.error(\"Failed retry times exceed threshold (\" + retries + \"), We have to abandon, invocation->\" + invocation);\n+                    logger.error(\"2-10\",\"Failed retry to invoke method and retry times exceed threshold\",\"\",\"Failed retry times exceed threshold (\" + retries + \"), We have to abandon, invocation->\" + invocation,e);\n                 } else {\n                     rePut(timeout);\n                 }",
    "output": "Upgrade FailbackClusterInvoker.java faq-FailbackClusterInvoker"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/status/SpringStatusChecker.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/status/SpringStatusChecker.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/status/SpringStatusChecker.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/status/SpringStatusChecker.java\n@@ -51,20 +51,6 @@ public SpringStatusChecker(ApplicationContext applicationContext) {\n     @Override\n     public Status check() {\n-        // TODO It seems to be ok with GenericWebApplicationContext, need further confirmation\n-//        ApplicationContext context = null;\n-//        for (ApplicationContext c : SpringExtensionInjector.getContexts()) {\n-//            // [Issue] SpringStatusChecker execute errors on non-XML Spring configuration\n-//            // issue : https://github.com/apache/dubbo/issues/3615\n-//            if(c instanceof GenericWebApplicationContext) { // ignore GenericXmlApplicationContext\n-//                continue;\n-//            }\n-//\n-//            if (c != null) {\n-//                context = c;\n-//                break;\n-//            }\n-//        }\n         if (applicationContext == null && applicationModel != null) {\n             SpringExtensionInjector springExtensionInjector = SpringExtensionInjector.get(applicationModel);\n@@ -110,10 +96,12 @@ public Status check() {\n                     }\n                 }\n             }\n-        } catch (UnsupportedOperationException t) {\n-            logger.debug(t.getMessage(), t);\n         } catch (Throwable t) {\n-            logger.warn(t.getMessage(), t);\n+            if (t.getCause() instanceof UnsupportedOperationException){\n+                logger.debug(t.getMessage(), t);\n+            }else {\n+                logger.warn(t.getMessage(), t);\n+            }\n         }\n         return new Status(level, buf.toString());\n     }",
    "output": "Fix spring status check failed * fix spring status check failed"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n@@ -29,8 +29,6 @@\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.TimeoutCountDown;\n-import java.util.Arrays;\n-\n import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;\n /**",
    "output": "Remove unused import"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n@@ -29,8 +29,6 @@\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.TimeoutCountDown;\n-import java.util.Arrays;\n-\n import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;\n /**",
    "output": "Remove unused import"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n@@ -54,9 +54,8 @@ public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invoca\n             if (countDown.isExpired()) {\n                 ((AppResponse) appResponse).clear(); // clear response in case of timeout.\n                 if (logger.isWarnEnabled()) {\n-                    logger.warn(\"invoke timed out. method: \" + invocation.getMethodName() + \" arguments: \" +\n-                            Arrays.toString(invocation.getArguments()) + \" , url is \" + invoker.getUrl() +\n-                            \", invoke elapsed \" + countDown.elapsedMillis() + \" ms.\");\n+                    logger.warn(\"invoke timed out. method: \" + invocation.getMethodName() +\n+                        \" url is \" + invoker.getUrl() + \", invoke elapsed \" + countDown.elapsedMillis() + \" ms.\");\n                 }\n             }\n         }",
    "output": "Remove useless toString in Timeout Filter"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java\n@@ -54,9 +54,8 @@ public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invoca\n             if (countDown.isExpired()) {\n                 ((AppResponse) appResponse).clear(); // clear response in case of timeout.\n                 if (logger.isWarnEnabled()) {\n-                    logger.warn(\"invoke timed out. method: \" + invocation.getMethodName() + \" arguments: \" +\n-                            Arrays.toString(invocation.getArguments()) + \" , url is \" + invoker.getUrl() +\n-                            \", invoke elapsed \" + countDown.elapsedMillis() + \" ms.\");\n+                    logger.warn(\"invoke timed out. method: \" + invocation.getMethodName() +\n+                        \" url is \" + invoker.getUrl() + \", invoke elapsed \" + countDown.elapsedMillis() + \" ms.\");\n                 }\n             }\n         }",
    "output": "Remove useless toString in Timeout Filter"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n@@ -17,7 +17,7 @@\n package org.apache.dubbo.rpc.cluster.support;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n@@ -37,7 +37,7 @@\n  */\n public class BroadcastClusterInvoker<T> extends AbstractClusterInvoker<T> {\n-    private static final Logger logger = LoggerFactory.getLogger(BroadcastClusterInvoker.class);\n+    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(BroadcastClusterInvoker.class);\n     private static final String BROADCAST_FAIL_PERCENT_KEY = \"broadcast.fail.percent\";\n     private static final int MAX_BROADCAST_FAIL_PERCENT = 100;\n     private static final int MIN_BROADCAST_FAIL_PERCENT = 0;\n@@ -76,7 +76,7 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L\n                     Throwable resultException = result.getException();\n                     if (null != resultException) {\n                         exception = getRpcException(result.getException());\n-                        logger.warn(exception.getMessage(), exception);\n+                        logger.warn(\"2-8\",\"provider return error response\",\"\",exception.getMessage(),exception);\n                         failIndex++;\n                         if (failIndex == failThresholdIndex) {\n                             break;\n@@ -85,7 +85,7 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L\n                 }\n             } catch (Throwable e) {\n                 exception = getRpcException(e);\n-                logger.warn(exception.getMessage(), exception);\n+                logger.warn(\"2-8\",\"provider return error response\",\"\",exception.getMessage(),exception);\n                 failIndex++;\n                 if (failIndex == failThresholdIndex) {\n                     break;",
    "output": "Upgrade BroadcastClusterInvoker.java faq-BroadcastClusterInvoker"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n@@ -20,7 +20,7 @@\n import org.apache.dubbo.common.Version;\n import org.apache.dubbo.common.config.Configuration;\n import org.apache.dubbo.common.config.ConfigurationUtils;\n-import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.profiler.ProfilerSwitch;\n import org.apache.dubbo.common.utils.CollectionUtils;\n@@ -59,7 +59,7 @@\n  */\n public abstract class AbstractClusterInvoker<T> implements ClusterInvoker<T> {\n-    private static final Logger logger = LoggerFactory.getLogger(AbstractClusterInvoker.class);\n+    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(AbstractClusterInvoker.class);\n     protected Directory<T> directory;\n@@ -213,11 +213,11 @@ private Invoker<T> doSelect(LoadBalance loadbalance, Invocation invocation,\n                         //Avoid collision\n                         invoker = invokers.get((index + 1) % invokers.size());\n                     } catch (Exception e) {\n-                        logger.warn(e.getMessage() + \" may because invokers list dynamic change, ignore.\", e);\n+                        logger.warn(\"2-5\",\"select invokers exception\",\"\",e.getMessage() + \" may because invokers list dynamic change, ignore.\",e);\n                     }\n                 }\n             } catch (Throwable t) {\n-                logger.error(\"cluster reselect fail reason is :\" + t.getMessage() + \" if can not solve, you can set cluster.availablecheck=false in url\", t);\n+                logger.error(\"2-5\",\"failed to reselect invokers\",\"\",\"cluster reselect fail reason is :\" + t.getMessage() + \" if can not solve, you can set cluster.availablecheck=false in url\",t);\n             }\n         }",
    "output": "Upgrade AbstractClusterInvoker.java faq"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -438,6 +438,8 @@ public interface CommonConstants {\n     String DEFAULT_VERSION = \"0.0.0\";\n+    String CLASS_DESERIALIZE_OPEN_CHECK = \"dubbo.security.serialize.openCheckClass\";\n+\n     String ROUTER_KEY = \"router\";\n     String EXPORT_ASYNC_KEY = \"export-async\";\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeClassChecker.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeClassChecker.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeClassChecker.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeClassChecker.java\n@@ -17,6 +17,8 @@\n package org.apache.dubbo.common.utils;\n import org.apache.dubbo.common.beanutil.JavaBeanSerializeUtil;\n+import org.apache.dubbo.common.config.ConfigurationUtils;\n+import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n@@ -36,6 +38,7 @@ public class SerializeClassChecker {\n     private static volatile SerializeClassChecker INSTANCE = null;\n+    private final boolean OPEN_CHECK_CLASS;\n     private final boolean BLOCK_ALL_CLASS_EXCEPT_ALLOW;\n     private final Set<String> CLASS_DESERIALIZE_ALLOWED_SET = new ConcurrentHashSet<>();\n     private final Set<String> CLASS_DESERIALIZE_BLOCKED_SET = new ConcurrentHashSet<>();\n@@ -47,7 +50,11 @@ public class SerializeClassChecker {\n     private final AtomicLong counter = new AtomicLong(0);\n     private SerializeClassChecker() {\n-        String blockAllClassExceptAllow = System.getProperty(CLASS_DESERIALIZE_BLOCK_ALL, \"false\");\n+        String openCheckClass = ConfigurationUtils.getProperty(CommonConstants.CLASS_DESERIALIZE_OPEN_CHECK, \"true\");\n+        OPEN_CHECK_CLASS = Boolean.parseBoolean(openCheckClass);\n+\n+        String blockAllClassExceptAllow = ConfigurationUtils.getProperty(CLASS_DESERIALIZE_BLOCK_ALL, \"false\");\n+\n         BLOCK_ALL_CLASS_EXCEPT_ALLOW = Boolean.parseBoolean(blockAllClassExceptAllow);\n         String[] lines;\n@@ -70,8 +77,8 @@ private SerializeClassChecker() {\n             logger.error(\"Failed to load blocked class list! Will ignore default blocked list.\", e);\n         }\n-        String allowedClassList = System.getProperty(CLASS_DESERIALIZE_ALLOWED_LIST, \"\").trim().toLowerCase(Locale.ROOT);\n-        String blockedClassList = System.getProperty(CLASS_DESERIALIZE_BLOCKED_LIST, \"\").trim().toLowerCase(Locale.ROOT);\n+        String allowedClassList = ConfigurationUtils.getProperty(CLASS_DESERIALIZE_ALLOWED_LIST, \"\").trim().toLowerCase(Locale.ROOT);\n+        String blockedClassList = ConfigurationUtils.getProperty(CLASS_DESERIALIZE_BLOCKED_LIST, \"\").trim().toLowerCase(Locale.ROOT);\n         if (StringUtils.isNotEmpty(allowedClassList)) {\n             String[] classStrings = allowedClassList.trim().split(\",\");\n@@ -111,6 +118,10 @@ protected static void clearInstance() {\n      * @param name class name ( all are convert to lower case )\n      */\n     public void validateClass(String name) {\n+        if(!OPEN_CHECK_CLASS){\n+            return;\n+        }\n+\n         name = name.toLowerCase(Locale.ROOT);\n         if (CACHE == CLASS_ALLOW_LFU_CACHE.get(name)) {\n             return;",
    "output": "Add switch to no use"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java\n@@ -17,21 +17,25 @@\n package org.apache.dubbo.rpc.cluster.support.wrapper;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.ConfigUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.rpc.AsyncRpcResult;\n import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.InvokeMode;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.cluster.ClusterInvoker;\n import org.apache.dubbo.rpc.cluster.Directory;\n+import org.apache.dubbo.rpc.protocol.dubbo.FutureAdapter;\n import org.apache.dubbo.rpc.support.MockInvoker;\n+import org.apache.dubbo.rpc.support.RpcUtils;\n import java.util.List;\n@@ -42,6 +46,7 @@\n public class MockClusterInvoker<T> implements ClusterInvoker<T> {\n     private static final Logger logger = LoggerFactory.getLogger(MockClusterInvoker.class);\n+    private static final boolean setFutureWhenSync = Boolean.parseBoolean(System.getProperty(CommonConstants.SET_FUTURE_IN_SYNC_MODE, \"true\"));\n     private final Directory<T> directory;\n@@ -135,6 +140,9 @@ private Result doMockInvoke(Invocation invocation, RpcException e) {\n         Result result;\n         Invoker<T> mockInvoker;\n+        RpcInvocation rpcInvocation = (RpcInvocation)invocation;\n+        rpcInvocation.setInvokeMode(RpcUtils.getInvokeMode(getUrl(),invocation));\n+\n         List<Invoker<T>> mockInvokers = selectMockInvoker(invocation);\n         if (CollectionUtils.isEmpty(mockInvokers)) {\n             mockInvoker = (Invoker<T>) new MockInvoker(getUrl(), directory.getInterface());\n@@ -152,6 +160,10 @@ private Result doMockInvoke(Invocation invocation, RpcException e) {\n         } catch (Throwable me) {\n             throw new RpcException(getMockExceptionMessage(e, me), me.getCause());\n         }\n+        if (setFutureWhenSync || rpcInvocation.getInvokeMode() != InvokeMode.SYNC) {\n+            // set server context\n+            RpcContext.getServiceContext().setFuture(new FutureAdapter<>(((AsyncRpcResult)result).getResponseFuture()));\n+        }\n         return result;\n     }\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java\n@@ -37,6 +37,8 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n import static org.apache.dubbo.rpc.cluster.Constants.REFER_KEY;\n@@ -157,6 +159,9 @@ public void testMockInvokerInvoke_forcemock() {\n         invocation.setMethodName(\"sayHello\");\n         ret = cluster.invoke(invocation);\n         Assertions.assertNull(ret.getValue());\n+\n+\n+\n     }\n     @Test\n@@ -589,6 +594,29 @@ public void testMockInvokerFromOverride_Invoke_check_ListPojo_empty() {\n         Result ret = cluster.invoke(invocation);\n         Assertions.assertEquals(0, ((List<User>) ret.getValue()).size());\n     }\n+    @Test\n+    public void testMockInvokerFromOverride_Invoke_check_ListPojoAsync() throws ExecutionException, InterruptedException {\n+        URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n+            .addParameter(REFER_KEY,\n+                URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n+                    + \"&\" + \"getUsersAsync.mock=force\"))\n+            .addParameter(\"invoke_return_error\", \"true\");\n+        Invoker<IHelloService> cluster = getClusterInvoker(url);\n+        //Configured with mock\n+        RpcInvocation invocation = new RpcInvocation();\n+        invocation.setMethodName(\"getUsersAsync\");\n+        invocation.setReturnType(CompletableFuture.class);\n+        Result ret = cluster.invoke(invocation);\n+        CompletableFuture<List<User>> cf = null;\n+        try {\n+            cf = (CompletableFuture<List<User>>) ret.recreate();\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+        }\n+        Assertions.assertEquals(2, cf.get().size());\n+        Assertions.assertEquals(\"Tommock\", cf.get().get(0).getName());\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     @Test\n@@ -753,6 +781,8 @@ public interface IHelloService {\n         List<User> getUsers();\n+        CompletableFuture<List<User>> getUsersAsync();\n+\n         void sayHello();\n     }\n@@ -793,6 +823,13 @@ public List<User> getUsers() {\n             return Arrays.asList(new User[]{new User(1, \"Tom\"), new User(2, \"Jerry\")});\n         }\n+        @Override\n+        public CompletableFuture<List<User>> getUsersAsync() {\n+            CompletableFuture<List<User>> cf=new CompletableFuture<>();\n+            cf.complete(Arrays.asList(new User[]{new User(1, \"Tom\"), new User(2, \"Jerry\")}));\n+            return cf;\n+        }\n+\n         public void sayHello() {\n             System.out.println(\"hello prety\");\n         }\n@@ -827,6 +864,13 @@ public List<User> getUsers() {\n             return Arrays.asList(new User[]{new User(1, \"Tommock\"), new User(2, \"Jerrymock\")});\n         }\n+        @Override\n+        public CompletableFuture<List<User>> getUsersAsync() {\n+            CompletableFuture<List<User>> cf=new CompletableFuture<>();\n+            cf.complete(Arrays.asList(new User[]{new User(1, \"Tommock\"), new User(2, \"Jerrymock\")}));\n+            return cf;\n+        }\n+\n         public int getInt1() {\n             return 1;\n         }",
    "output": "Fix the bug that mock invoker cannot handle the methods which return Type is CompletableFuture. For issue #10473 * Fix the bug that when mocking and InvokeMode is Future,the result cannot be processed correctly * fix checkstyle problem"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n@@ -434,6 +434,11 @@ public synchronized MetadataInfo clone() {\n         return new MetadataInfo(app, revision, services, initiated, extendParams, instanceParams, updated, subscribedServiceURLs, exportedServiceURLs, loader);\n     }\n+    private Object readResolve() {\n+        // create a new object from the deserialized one, in order to call constructor\n+        return new MetadataInfo(this.app, this.revision, this.services);\n+    }\n+\n     public static class ServiceInfo implements Serializable {\n         private String name;\n         private String group;\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/MetadataInfoTest.java b/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/MetadataInfoTest.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/MetadataInfoTest.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/MetadataInfoTest.java\n@@ -22,7 +22,14 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Field;\n import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n@@ -164,6 +171,29 @@ public void testJsonFormat() {\n     }\n+    @Test\n+    public void testJdkSerialize() throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\n+        MetadataInfo metadataInfo = new MetadataInfo(\"demo\");\n+        metadataInfo.addService(url);\n+        objectOutputStream.writeObject(metadataInfo);\n+        objectOutputStream.close();\n+        byteArrayOutputStream.close();\n+        byte[] bytes = byteArrayOutputStream.toByteArray();\n+\n+        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n+        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n+        MetadataInfo metadataInfo2 = (MetadataInfo) objectInputStream.readObject();\n+        objectInputStream.close();\n+\n+        Assertions.assertEquals(metadataInfo, metadataInfo2);\n+        Field initiatedField = MetadataInfo.class.getDeclaredField(\"initiated\");\n+        initiatedField.setAccessible(true);\n+        Assertions.assertInstanceOf(AtomicBoolean.class, initiatedField.get(metadataInfo2));\n+        Assertions.assertFalse(((AtomicBoolean)initiatedField.get(metadataInfo2)).get());\n+    }\n+\n     @Test\n     public void testCal() {\n         MetadataInfo metadataInfo = new MetadataInfo(\"demo\");\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/OverrideInstanceAddressURL.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/OverrideInstanceAddressURL.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/OverrideInstanceAddressURL.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/OverrideInstanceAddressURL.java\n@@ -339,6 +339,10 @@ public String toString() {\n         return originUrl.toString() + \", overrideParams: \" + overrideParams.toString();\n     }\n+    private Object readResolve() {\n+        // create a new object from the deserialized one\n+        return new OverrideInstanceAddressURL(this.originUrl, this.overrideParams);\n+    }\n     @Override\n     protected OverrideInstanceAddressURL newURL(URLAddress urlAddress, URLParam urlParam) {\n         return new OverrideInstanceAddressURL(originUrl, overrideParams);",
    "output": "Fix transient init"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n@@ -49,7 +49,8 @@\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -79,12 +80,15 @@ public abstract class AbstractRegistry implements Registry {\n     private static final String URL_SPLIT = \"\\\\s+\";\n     // Max times to retry to save properties to local cache file\n     private static final int MAX_RETRY_TIMES_SAVE_PROPERTIES = 3;\n+    // Default interval in millisecond for saving properties to local cache file\n+    private static final long DEFAULT_INTERVAL_SAVE_PROPERTIES = 500L;\n+\n     // Log output\n     protected final Logger logger = LoggerFactory.getLogger(getClass());\n     // Local disk cache, where the special key value.registries records the list of registry centers, and the others are the list of notified service providers\n     private final Properties properties = new Properties();\n     // File cache timing writing\n-    private final ExecutorService registryCacheExecutor;\n+    private final ScheduledExecutorService registryCacheExecutor;\n     private final AtomicLong lastCacheChanged = new AtomicLong();\n     private final AtomicInteger savePropertiesRetryTimes = new AtomicInteger();\n     private final Set<URL> registered = new ConcurrentHashSet<>();\n@@ -104,7 +108,7 @@ public AbstractRegistry(URL url) {\n         registryManager = url.getOrDefaultApplicationModel().getBeanFactory().getBean(RegistryManager.class);\n         localCacheEnabled = url.getParameter(REGISTRY_LOCAL_FILE_CACHE_ENABLED, true);\n         registryCacheExecutor = url.getOrDefaultFrameworkModel().getBeanFactory()\n-            .getBean(FrameworkExecutorRepository.class).getSharedExecutor();\n+            .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor();\n         if (localCacheEnabled) {\n             // Start file save timer\n             syncSaveFile = url.getParameter(REGISTRY_FILESAVE_SYNC_KEY, false);\n@@ -238,7 +242,7 @@ public void doSaveProperties(long version) {\n                 savePropertiesRetryTimes.set(0);\n                 return;\n             } else {\n-                registryCacheExecutor.execute(() -> doSaveProperties(lastCacheChanged.incrementAndGet()));\n+                registryCacheExecutor.schedule(() -> doSaveProperties(lastCacheChanged.incrementAndGet()), DEFAULT_INTERVAL_SAVE_PROPERTIES, TimeUnit.MILLISECONDS);\n             }\n             if (!(e instanceof OverlappingFileLockException)) {\n                 logger.warn(\"Failed to save registry cache file, will retry, cause: \" + e.getMessage(), e);\n@@ -495,7 +499,7 @@ private void saveProperties(URL url) {\n             if (syncSaveFile) {\n                 doSaveProperties(version);\n             } else {\n-                registryCacheExecutor.execute(() -> doSaveProperties(version));\n+                registryCacheExecutor.schedule(() -> doSaveProperties(version), DEFAULT_INTERVAL_SAVE_PROPERTIES, TimeUnit.MILLISECONDS);\n             }\n         } catch (Throwable t) {\n             logger.warn(t.getMessage(), t);",
    "output": "Add default interval for retries of saving properties"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -1023,7 +1023,7 @@ protected List<Method> computeAttributedMethods() {\n         List<Method> methods = new ArrayList<>(beanInfo.getMethodDescriptors().length);\n         for (MethodDescriptor methodDescriptor : beanInfo.getMethodDescriptors()) {\n             Method method = methodDescriptor.getMethod();\n-            if (MethodUtils.isGetter(method)) {\n+            if (MethodUtils.isGetter(method) || isParametersGetter(method)) {\n                 // filter non attribute\n                 Parameter parameter = method.getAnnotation(Parameter.class);\n                 if (parameter != null && !parameter.attribute()) {\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n@@ -654,6 +654,24 @@ public void testEquals() {\n         Assertions.assertNotEquals(protocol1, protocol2);\n     }\n+    @Test\n+    void testRegistryConfigEquals() {\n+        RegistryConfig hangzhou = new RegistryConfig();\n+        hangzhou.setAddress(\"nacos://localhost:8848\");\n+        HashMap<String, String> parameters = new HashMap<>();\n+        parameters.put(\"namespace\", \"hangzhou\");\n+        hangzhou.setParameters(parameters);\n+\n+        RegistryConfig shanghai = new RegistryConfig();\n+        shanghai.setAddress(\"nacos://localhost:8848\");\n+        parameters = new HashMap<>();\n+        parameters.put(\"namespace\", \"shanghai\");\n+\n+        shanghai.setParameters(parameters);\n+\n+        Assertions.assertNotEquals(hangzhou, shanghai);\n+    }\n+\n     @Retention(RetentionPolicy.RUNTIME)\n     @Target({ElementType.ANNOTATION_TYPE})\n     public @interface ConfigField {",
    "output": "Fix config equals for issus#10419"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n--- a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n+++ b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n@@ -146,7 +146,7 @@ protected void doAddListener(String pathKey, ConfigurationListener listener, Str\n     @Override\n     protected void doRemoveListener(String pathKey, ConfigurationListener listener) {\n         ZookeeperDataListener zookeeperDataListener = cacheListener.removeListener(pathKey, listener);\n-        if (CollectionUtils.isEmpty(zookeeperDataListener.getListeners())) {\n+        if (zookeeperDataListener != null && CollectionUtils.isEmpty(zookeeperDataListener.getListeners())) {\n             zkClient.removeDataListener(pathKey, zookeeperDataListener);\n         }\n     }",
    "output": "Fix npe"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceBeanNameBuilder.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceBeanNameBuilder.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceBeanNameBuilder.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceBeanNameBuilder.java\n@@ -95,8 +95,9 @@ public static ServiceBeanNameBuilder create(Reference reference, Class<?> interf\n     }\n     private static void append(StringBuilder builder, String value) {\n+        builder.append(SEPARATOR);\n         if (StringUtils.hasText(value)) {\n-            builder.append(SEPARATOR).append(value);\n+            builder.append(value);\n         }\n     }\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessorTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessorTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessorTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessorTest.java\n@@ -95,7 +95,7 @@ public void testMethodAnnotation() {\n         Assertions.assertEquals(3, serviceBeansMap.size());\n-        ServiceBean demoServiceBean = serviceBeansMap.get(\"ServiceBean:org.apache.dubbo.config.spring.api.DemoService:2.5.7\");\n+        ServiceBean demoServiceBean = serviceBeansMap.get(\"ServiceBean:org.apache.dubbo.config.spring.api.DemoService:2.5.7:\");\n         Assertions.assertNotNull(demoServiceBean.getMethods());\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceBeanNameBuilderTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceBeanNameBuilderTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceBeanNameBuilderTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceBeanNameBuilderTest.java\n@@ -72,4 +72,14 @@ public void testReferenceAnnotation() {\n                 builder.build());\n     }\n+    @Test\n+    public void testServiceNameBuild() {\n+        ServiceBeanNameBuilder vBuilder = ServiceBeanNameBuilder.create(INTERFACE_CLASS, environment);\n+        String vBeanName = vBuilder.version(\"DUBBO\").build();\n+\n+        ServiceBeanNameBuilder gBuilder = ServiceBeanNameBuilder.create(INTERFACE_CLASS, environment);\n+        String gBeanName = gBuilder.group(\"DUBBO\").build();\n+\n+        Assertions.assertNotEquals(vBeanName, gBeanName);\n+    }\n }\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-actuator/src/test/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboEndpointAnnotationAutoConfigurationTest.java b/dubbo-spring-boot/dubbo-spring-boot-actuator/src/test/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboEndpointAnnotationAutoConfigurationTest.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-actuator/src/test/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboEndpointAnnotationAutoConfigurationTest.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-actuator/src/test/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboEndpointAnnotationAutoConfigurationTest.java\n@@ -179,7 +179,7 @@ public void testServices() {\n         Assert.assertEquals(1, services.size());\n-        Map<String, Object> demoServiceMeta = services.get(\"ServiceBean:org.apache.dubbo.spring.boot.actuate.autoconfigure.DubboEndpointAnnotationAutoConfigurationTest$DemoService:1.0.0\");\n+        Map<String, Object> demoServiceMeta = services.get(\"ServiceBean:org.apache.dubbo.spring.boot.actuate.autoconfigure.DubboEndpointAnnotationAutoConfigurationTest$DemoService:1.0.0:\");\n         Assert.assertEquals(\"1.0.0\", demoServiceMeta.get(\"version\"));\ndiff --git a/dubbo-spring-boot/dubbo-spring-boot-compatible/actuator/src/test/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboEndpointAutoConfigurationTest.java b/dubbo-spring-boot/dubbo-spring-boot-compatible/actuator/src/test/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboEndpointAutoConfigurationTest.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-compatible/actuator/src/test/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboEndpointAutoConfigurationTest.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-compatible/actuator/src/test/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboEndpointAutoConfigurationTest.java\n@@ -166,7 +166,7 @@ public void testServices() {\n         Assert.assertEquals(1, services.size());\n-        Map<String, Object> demoServiceMeta = services.get(\"ServiceBean:org.apache.dubbo.spring.boot.actuate.autoconfigure.DubboEndpointAutoConfigurationTest$DemoService:1.0.0\");\n+        Map<String, Object> demoServiceMeta = services.get(\"ServiceBean:org.apache.dubbo.spring.boot.actuate.autoconfigure.DubboEndpointAutoConfigurationTest$DemoService:1.0.0:\");\n         Assert.assertEquals(\"1.0.0\", demoServiceMeta.get(\"version\"));",
    "output": "Fix ServiceBeanNameBuilder same version/group conflict * fixed ServiceBeanNameBuilder same version/group conflict * fixed ServiceBeanNameBuilder same version/group conflict"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java\n@@ -97,7 +97,7 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {\n                 String generic = inv.getAttachment(GENERIC_KEY);\n                 if (StringUtils.isBlank(generic)) {\n-                    generic = RpcContext.getClientAttachment().getAttachment(GENERIC_KEY);\n+                    generic = getGenericValueFromRpcContext();\n                 }\n                 if (StringUtils.isEmpty(generic)\n@@ -205,6 +205,14 @@ private Object[] getGsonGenericArgs(final Object[] args, Type[] types) {\n         }).toArray();\n     }\n+    private String getGenericValueFromRpcContext(){\n+        String generic = RpcContext.getServerAttachment().getAttachment(GENERIC_KEY);\n+        if (StringUtils.isBlank(generic)){\n+            generic = RpcContext.getClientAttachment().getAttachment(GENERIC_KEY);\n+        }\n+        return generic;\n+    }\n+\n     @Override\n     public void onResponse(Result appResponse, Invoker<?> invoker, Invocation inv) {\n         if ((inv.getMethodName().equals($INVOKE) || inv.getMethodName().equals($INVOKE_ASYNC))\n@@ -214,7 +222,7 @@ public void onResponse(Result appResponse, Invoker<?> invoker, Invocation inv) {\n             String generic = inv.getAttachment(GENERIC_KEY);\n             if (StringUtils.isBlank(generic)) {\n-                generic = RpcContext.getClientAttachment().getAttachment(GENERIC_KEY);\n+                generic = getGenericValueFromRpcContext();\n             }\n             if (appResponse.hasException()) {",
    "output": "Fix GenericFilter get generic value"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/status/support/MemoryStatusChecker.java b/dubbo-common/src/main/java/org/apache/dubbo/common/status/support/MemoryStatusChecker.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/status/support/MemoryStatusChecker.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/status/support/MemoryStatusChecker.java\n@@ -32,7 +32,7 @@ public Status check() {\n         long freeMemory = runtime.freeMemory();\n         long totalMemory = runtime.totalMemory();\n         long maxMemory = runtime.maxMemory();\n-        boolean ok = (maxMemory - (totalMemory - freeMemory) > 2048); // Alarm when spare memory < 2M\n+        boolean ok = (maxMemory - (totalMemory - freeMemory) > 2*1024*1024); // Alarm when spare memory < 2M\n         String msg = \"max:\" + (maxMemory / 1024 / 1024) + \"M,total:\"\n                 + (totalMemory / 1024 / 1024) + \"M,used:\" + ((totalMemory / 1024 / 1024) - (freeMemory / 1024 / 1024)) + \"M,free:\" + (freeMemory / 1024 / 1024) + \"M\";\n         return new Status(ok ? Status.Level.OK : Status.Level.WARN, msg);",
    "output": "Upgrade MemoryStatusChecker.java Alarm when spare memory < 2M,not <2K"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReport.java b/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReport.java\n--- a/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReport.java\n+++ b/dubbo-metadata/dubbo-metadata-report-nacos/src/main/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReport.java\n@@ -255,6 +255,8 @@ public Set<String> getServiceAppMapping(String serviceKey, MappingListener liste\n     @Override\n     public void removeServiceAppMappingListener(String serviceKey, MappingListener listener) {\n+        String group = DEFAULT_MAPPING_GROUP;\n+\n         MappingDataListener mappingDataListener = casListenerMap.get(buildListenerKey(serviceKey, group));\n         if (null != mappingDataListener) {\n             removeCasServiceMappingListener(serviceKey, group, listener);",
    "output": "Fix nacos removeServiceAppMappingListener"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java\n@@ -47,6 +47,10 @@ public void subscribe(String serviceName, String group, EventListener eventListe\n         namingService.subscribe(handleInnerSymbol(serviceName), group, eventListener);\n     }\n+    public void unsubscribe(String serviceName, String group, EventListener eventListener) throws NacosException {\n+        namingService.unsubscribe(handleInnerSymbol(serviceName), group, eventListener);\n+    }\n+\n     public List<Instance> getAllInstances(String serviceName, String group) throws NacosException {\n         return namingService.getAllInstances(handleInnerSymbol(serviceName), group);\n     }\ndiff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.common.function.ThrowableFunction;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.ConcurrentHashSet;\n import org.apache.dubbo.registry.client.AbstractServiceDiscovery;\n import org.apache.dubbo.registry.client.ServiceDiscovery;\n import org.apache.dubbo.registry.client.ServiceInstance;\n@@ -30,13 +31,16 @@\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import com.alibaba.nacos.api.exception.NacosException;\n+import com.alibaba.nacos.api.naming.listener.Event;\n+import com.alibaba.nacos.api.naming.listener.EventListener;\n import com.alibaba.nacos.api.naming.listener.NamingEvent;\n import com.alibaba.nacos.api.naming.pojo.Instance;\n import com.alibaba.nacos.api.naming.pojo.ListView;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n import static com.alibaba.nacos.api.common.Constants.DEFAULT_GROUP;\n@@ -61,6 +65,8 @@ public class NacosServiceDiscovery extends AbstractServiceDiscovery {\n     private static final String NACOS_SD_USE_DEFAULT_GROUP_KEY = \"dubbo.nacos-service-discovery.use-default-group\";\n+    private final ConcurrentHashMap<String, NacosEventListener> eventListeners = new ConcurrentHashMap<>();\n+\n     public NacosServiceDiscovery(ApplicationModel applicationModel, URL registryURL) {\n         super(applicationModel, registryURL);\n         this.namingService = createNamingService(registryURL);\n@@ -114,18 +120,68 @@ public void addServiceInstancesChangedListener(ServiceInstancesChangedListener l\n         if (!instanceListeners.add(listener)) {\n             return;\n         }\n-        execute(namingService, service -> listener.getServiceNames().forEach(serviceName -> {\n-            try {\n-                service.subscribe(serviceName, group, e -> { // Register Nacos EventListener\n-                    if (e instanceof NamingEvent) {\n-                        NamingEvent event = (NamingEvent) e;\n-                        handleEvent(event, listener);\n+        for (String serviceName : listener.getServiceNames()) {\n+            NacosEventListener nacosEventListener = eventListeners.get(serviceName);\n+            if (nacosEventListener != null) {\n+                nacosEventListener.addListener(listener);\n+            } else {\n+                try {\n+                    nacosEventListener = new NacosEventListener();\n+                    nacosEventListener.addListener(listener);\n+                    namingService.subscribe(serviceName, group, nacosEventListener);\n+                    eventListeners.put(serviceName, nacosEventListener);\n+                } catch (NacosException e) {\n+                    logger.error(\"add nacos service instances changed listener fail \", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void removeServiceInstancesChangedListener(ServiceInstancesChangedListener listener) throws IllegalArgumentException {\n+        if (!instanceListeners.remove(listener)) {\n+            return;\n+        }\n+        for (String serviceName : listener.getServiceNames()) {\n+            NacosEventListener nacosEventListener = eventListeners.get(serviceName);\n+            if (nacosEventListener != null) {\n+                nacosEventListener.removeListener(listener);\n+                if (nacosEventListener.isEmpty()) {\n+                    eventListeners.remove(serviceName);\n+                    try {\n+                        namingService.unsubscribe(serviceName, group, nacosEventListener);\n+                    } catch (NacosException e) {\n+                        logger.error(\"remove nacos service instances changed listener fail \", e);\n                     }\n-                });\n-            } catch (NacosException e) {\n-                logger.error(\"add nacos service instances changed listener fail \", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    public class NacosEventListener implements EventListener {\n+        private final Set<ServiceInstancesChangedListener> listeners = new ConcurrentHashSet<>();\n+\n+        @Override\n+        public void onEvent(Event e) {\n+            if (e instanceof NamingEvent) {\n+                for (ServiceInstancesChangedListener listener : listeners) {\n+                    NamingEvent event = (NamingEvent) e;\n+                    handleEvent(event, listener);\n+                }\n             }\n-        }));\n+        }\n+\n+        public void addListener(ServiceInstancesChangedListener listener) {\n+            listeners.add(listener);\n+        }\n+\n+        public void removeListener(ServiceInstancesChangedListener listener) {\n+            listeners.remove(listener);\n+        }\n+\n+        public boolean isEmpty() {\n+            return listeners.isEmpty();\n+        }\n     }\n     @Override",
    "output": "Fix nacos removeServiceInstancesChangedListener"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcInvocation.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcInvocation.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcInvocation.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcInvocation.java\n@@ -669,8 +669,7 @@ public ServiceModel getServiceModel() {\n     @Override\n     public String toString() {\n         return \"RpcInvocation [methodName=\" + methodName + \", parameterTypes=\"\n-            + Arrays.toString(parameterTypes) + \", arguments=\" + Arrays.toString(arguments)\n-            + \", attachments=\" + attachments + \"]\";\n+            + Arrays.toString(parameterTypes) + \"]\";\n     }\n }",
    "output": "Remove to rpcInvocation string"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistry2S2RTest.java b/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistry2S2RTest.java\n--- a/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistry2S2RTest.java\n+++ b/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistry2S2RTest.java\n@@ -24,6 +24,7 @@\n import org.apache.dubbo.remoting.zookeeper.curator.CuratorZookeeperClient;\n import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Assumptions;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n@@ -144,8 +145,7 @@ public void testSubscription() throws InterruptedException {\n         String path = \"/dubbo/\" + SERVICE2_NAME + \"/providers\";\n         List<String> providerList = zookeeperClient.getChildren(path);\n-        Assertions.assertTrue(!providerList.isEmpty());\n-        System.out.println(providerList.get(0));\n+        Assumptions.assumeTrue(!providerList.isEmpty());\n         final List<URL> list = new ArrayList<URL>();\n         multipleRegistry.subscribe(serviceUrl, new NotifyListener() {",
    "output": "Fix for issue#10213 * fix for issue#10213 replace Assertions with Assumptions * fix for issue#10213 remove sout"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n@@ -56,7 +56,7 @@\n  *\n  * @see RpcContext\n  */\n-@Activate(group = PROVIDER, order = -10000)\n+@Activate(group = PROVIDER, order = Integer.MIN_VALUE)\n public class ContextFilter implements Filter, Filter.Listener {\n     private static final Set<String> UNLOADING_KEYS;",
    "output": "Fix issue 10425"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/ProviderReadinessProbe.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/ProviderReadinessProbe.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/ProviderReadinessProbe.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/ProviderReadinessProbe.java\n@@ -23,7 +23,6 @@\n import org.apache.dubbo.rpc.model.ProviderModel;\n import java.util.Collection;\n-import java.util.List;\n @Activate\n public class ProviderReadinessProbe implements ReadinessProbe {\n@@ -46,17 +45,18 @@ public boolean check() {\n             return true;\n         }\n-        boolean hasService = false;\n+        boolean hasService = false, anyOnline = false;\n         for (ProviderModel providerModel : providerModelList) {\n-            List<ProviderModel.RegisterStatedURL> statedUrls = providerModel.getStatedUrl();\n-            for (ProviderModel.RegisterStatedURL statedUrl : statedUrls) {\n-                if (statedUrl.isRegistered()) {\n-                    hasService = true;\n-                    break;\n-                }\n+            if (providerModel.getModuleModel().isInternal()) {\n+                continue;\n             }\n+            hasService = true;\n+            anyOnline = anyOnline || providerModel.getStatedUrl().stream().anyMatch(ProviderModel.RegisterStatedURL::isRegistered);\n         }\n-        return hasService;\n+        // no service => check pass\n+        // has service and any online => check pass\n+        // has service and none online => check fail\n+        return !(hasService && !anyOnline);\n     }\n }",
    "output": "Upgrade Readiness probe"
  },
  {
    "input": "diff --git a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioConstant.java b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioConstant.java\n--- a/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioConstant.java\n+++ b/dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/istio/IstioConstant.java\n@@ -83,7 +83,7 @@ public class IstioConstant {\n     public final static String ISTIO_META_CLUSTER_ID_KEY = \"ISTIO_META_CLUSTER_ID\";\n-    public final static String DEFAULT_ISTIO_META_CLUSTER_ID = \"kubernetes\";\n+    public final static String DEFAULT_ISTIO_META_CLUSTER_ID = \"Kubernetes\";\n     public final static String SPIFFE = \"spiffe://\";",
    "output": "Upgrade DEFAULT_ISTIO_META_CLUSTER_ID"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n@@ -92,6 +92,16 @@ public abstract class AbstractReferenceConfig extends AbstractInterfaceConfig {\n     @Deprecated\n     private Boolean referAsync;\n+    /**\n+     * client type\n+     */\n+    protected String client;\n+\n+    /**\n+     * Only the service provider of the specified protocol is invoked, and other protocols are ignored.\n+     */\n+    protected String protocol;\n+\n     public AbstractReferenceConfig() {\n     }\n@@ -267,4 +277,20 @@ public Boolean getReferAsync() {\n     public void setReferAsync(Boolean referAsync) {\n         this.referAsync = referAsync;\n     }\n+\n+    public String getClient() {\n+        return client;\n+    }\n+\n+    public void setClient(String client) {\n+        this.client = client;\n+    }\n+\n+    public String getProtocol() {\n+        return protocol;\n+    }\n+\n+    public void setProtocol(String protocol) {\n+        this.protocol = protocol;\n+    }\n }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ConsumerConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ConsumerConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ConsumerConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ConsumerConfig.java\n@@ -33,11 +33,6 @@ public class ConsumerConfig extends AbstractReferenceConfig {\n     private static final long serialVersionUID = 2827274711143680600L;\n-    /**\n-     * Networking framework client uses: netty, mina, etc.\n-     */\n-    private String client;\n-\n     /**\n      * Consumer thread pool type: cached, fixed, limit, eager\n      */\n@@ -100,14 +95,6 @@ public void setTimeout(Integer timeout) {\n             System.setProperty(\"sun.rmi.transport.tcp.responseTimeout\", String.valueOf(timeout));\n         }\n     }\n-\n-    public String getClient() {\n-        return client;\n-    }\n-\n-    public void setClient(String client) {\n-        this.client = client;\n-    }\n     public String getThreadpool() {\n         return threadpool;\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n@@ -55,10 +55,6 @@ public abstract class ReferenceConfigBase<T> extends AbstractReferenceConfig {\n      */\n     protected Class<?> interfaceClass;\n-    /**\n-     * client type\n-     */\n-    protected String client;\n     /**\n      * The url for peer-to-peer invocation\n@@ -70,12 +66,6 @@ public abstract class ReferenceConfigBase<T> extends AbstractReferenceConfig {\n      */\n     protected ConsumerConfig consumer;\n-    /**\n-     * Only the service provider of the specified protocol is invoked, and other protocols are ignored.\n-     */\n-    protected String protocol;\n-\n-\n     public ReferenceConfigBase() {\n         serviceMetadata = new ServiceMetadata();\n         serviceMetadata.addAttribute(ORIGIN_CONFIG, this);\n@@ -250,14 +240,6 @@ public void setInterface(Class<?> interfaceClass) {\n         setInterfaceClassLoader(interfaceClass == null ? null : interfaceClass.getClassLoader());\n     }\n-    public String getClient() {\n-        return client;\n-    }\n-\n-    public void setClient(String client) {\n-        this.client = client;\n-    }\n-\n     @Parameter(excluded = true)\n     public String getUrl() {\n         return url;\n@@ -275,14 +257,6 @@ public void setConsumer(ConsumerConfig consumer) {\n         this.consumer = consumer;\n     }\n-    public String getProtocol() {\n-        return protocol;\n-    }\n-\n-    public void setProtocol(String protocol) {\n-        this.protocol = protocol;\n-    }\n-\n     public ServiceMetadata getServiceMetadata() {\n         return serviceMetadata;\n     }",
    "output": "Fix protocol unable to specify from ConsumerConfig"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n@@ -95,8 +95,7 @@ public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n             @Override\n             public void afterUnExport() {\n                 pathResolver.remove(url.getServiceKey());\n-                pathResolver.add(url.getServiceModel().getServiceModel().getInterfaceName(),\n-                    invoker);\n+                pathResolver.remove(url.getServiceModel().getServiceModel().getInterfaceName());\n                 // set service status\n                 triBuiltinService.getHealthStatusManager()\n                     .setStatus(url.getServiceKey(), ServingStatus.NOT_SERVING);",
    "output": "Fix triple unexport remove"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/stub/StubInvocationUtil.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/stub/StubInvocationUtil.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/stub/StubInvocationUtil.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/stub/StubInvocationUtil.java\n@@ -33,7 +33,13 @@ public static <T, R> R unaryCall(Invoker<?> invoker, MethodDescriptor methodDesc\n     public static <T, R> void unaryCall(Invoker<?> invoker, MethodDescriptor method, T request,\n         StreamObserver<R> responseObserver) {\n-        call(invoker, method, new Object[]{request, responseObserver});\n+        try {\n+            Object res = unaryCall(invoker, method, request);\n+            responseObserver.onNext((R) res);\n+        } catch (Exception e) {\n+            responseObserver.onError(e);\n+        }\n+        responseObserver.onCompleted();\n     }\n     public static <T, R> StreamObserver<T> biOrClientStreamCall(Invoker<?> invoker,\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/stub/StubInvocationUtilTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/stub/StubInvocationUtilTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/stub/StubInvocationUtilTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/stub/StubInvocationUtilTest.java\n@@ -136,13 +136,8 @@ void testUnaryCall() throws Throwable {\n         Result result = Mockito.mock(Result.class);\n         String response = \"response\";\n         when(invoker.invoke(any(Invocation.class)))\n-            .then(invocationOnMock -> {\n-                Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];\n-                StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];\n-                observer.onNext(response);\n-                observer.onCompleted();\n-                return result;\n-            });\n+            .then(invocationOnMock -> result);\n+        when(result.recreate()).thenReturn(response);\n         MethodDescriptor method = Mockito.mock(MethodDescriptor.class);\n         when(method.getParameterClasses())\n             .thenReturn(new Class[]{String.class});\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -196,35 +196,15 @@ AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocat\n         RequestMetadata request = createRequest(methodDescriptor, invocation, timeout);\n         final Object pureArgument;\n-        if (methodDescriptor.getParameterClasses().length == 2\n-            && methodDescriptor.getParameterClasses()[1].isAssignableFrom(\n-            StreamObserver.class)) {\n-            StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];\n-            future.whenComplete((r, t) -> {\n-                if (t != null) {\n-                    observer.onError(t);\n-                    return;\n-                }\n-                if (r.hasException()) {\n-                    observer.onError(r.getException());\n-                    return;\n-                }\n-                observer.onNext(r.getValue());\n-                observer.onCompleted();\n-            });\n+\n+        if (methodDescriptor instanceof StubMethodDescriptor) {\n             pureArgument = invocation.getArguments()[0];\n-            result = new AsyncRpcResult(CompletableFuture.completedFuture(new AppResponse()),\n-                invocation);\n         } else {\n-            if (methodDescriptor instanceof StubMethodDescriptor) {\n-                pureArgument = invocation.getArguments()[0];\n-            } else {\n-                pureArgument = invocation.getArguments();\n-            }\n-            result = new AsyncRpcResult(future, invocation);\n-            result.setExecutor(callbackExecutor);\n-            FutureContext.getContext().setCompatibleFuture(future);\n+            pureArgument = invocation.getArguments();\n         }\n+        result = new AsyncRpcResult(future, invocation);\n+        FutureContext.getContext().setCompatibleFuture(future);\n+        result.setExecutor(callbackExecutor);\n         ClientCall.Listener callListener = new UnaryClientCallListener(future);\n         final StreamObserver<Object> requestObserver = call.start(request, callListener);",
    "output": "Remove processing streamObserver in TripleInvoker#invokeUnary * Remove processing streamObserver in TripleInvoker#invokeUnary * remove unaryCall with streamObserver in StubInvocationUtil * add Compatible with unaryCall * add unit test"
  },
  {
    "input": "diff --git a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/WelcomeLogoApplicationListener.java b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/WelcomeLogoApplicationListener.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/WelcomeLogoApplicationListener.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/WelcomeLogoApplicationListener.java\n@@ -77,9 +77,6 @@ String buildBannerText() {\n         bannerTextBuilder\n                 .append(LINE_SEPARATOR)\n                 .append(LINE_SEPARATOR)\n-                .append(\" :: Dubbo Spring Boot (v\").append(Version.getVersion(getClass(), Version.getVersion())).append(\") : \")\n-                .append(DUBBO_SPRING_BOOT_GITHUB_URL)\n-                .append(LINE_SEPARATOR)\n                 .append(\" :: Dubbo (v\").append(Version.getVersion()).append(\") : \")\n                 .append(DUBBO_GITHUB_URL)\n                 .append(LINE_SEPARATOR)",
    "output": "Remove `Dubbo Spring Boot` info when start application"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/configcenter/AbstractDynamicConfiguration.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/configcenter/AbstractDynamicConfiguration.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/configcenter/AbstractDynamicConfiguration.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/configcenter/AbstractDynamicConfiguration.java\n@@ -17,7 +17,7 @@\n package org.apache.dubbo.common.config.configcenter;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.NamedThreadFactory;\n import org.apache.dubbo.common.utils.StringUtils;\n@@ -75,7 +75,7 @@ public abstract class AbstractDynamicConfiguration implements DynamicConfigurati\n     /**\n      * Logger\n      */\n-    protected final Logger logger = LoggerFactory.getLogger(getClass());\n+    protected final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(getClass());\n     /**\n      * The thread pool for workers who executes the tasks\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/config/DubboConfigDefaultPropertyValueBeanPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/config/DubboConfigDefaultPropertyValueBeanPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/config/DubboConfigDefaultPropertyValueBeanPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/config/DubboConfigDefaultPropertyValueBeanPostProcessor.java\n@@ -52,6 +52,7 @@ public class DubboConfigDefaultPropertyValueBeanPostProcessor extends GenericBea\n      */\n     public static final String BEAN_NAME = \"dubboConfigDefaultPropertyValueBeanPostProcessor\";\n+    @Override\n     protected void processBeforeInitialization(AbstractConfig dubboConfigBean, String beanName) throws BeansException {\n         // ignore auto generate bean name\n         if (!beanName.contains(\"#\")) {\ndiff --git a/dubbo-configcenter/dubbo-configcenter-apollo/src/main/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfiguration.java b/dubbo-configcenter/dubbo-configcenter-apollo/src/main/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfiguration.java\n--- a/dubbo-configcenter/dubbo-configcenter-apollo/src/main/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfiguration.java\n+++ b/dubbo-configcenter/dubbo-configcenter-apollo/src/main/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfiguration.java\n@@ -21,7 +21,7 @@\n import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;\n import org.apache.dubbo.common.config.configcenter.ConfigurationListener;\n import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;\n-import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.StringUtils;\n@@ -61,7 +61,7 @@\n  * Please see http://dubbo.apache.org/zh-cn/docs/user/configuration/config-center.html for details.\n  */\n public class ApolloDynamicConfiguration implements DynamicConfiguration {\n-    private static final Logger logger = LoggerFactory.getLogger(ApolloDynamicConfiguration.class);\n+    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(ApolloDynamicConfiguration.class);\n     private static final String APOLLO_ENV_KEY = \"env\";\n     private static final String APOLLO_ADDR_KEY = \"apollo.meta\";\n     private static final String APOLLO_CLUSTER_KEY = \"apollo.cluster\";\n@@ -106,7 +106,10 @@ public class ApolloDynamicConfiguration implements DynamicConfiguration {\n                 throw new IllegalStateException(\"Failed to connect to config center, the config center is Apollo, \" +\n                     \"the address is: \" + (StringUtils.isNotEmpty(configAddr) ? configAddr : configEnv));\n             } else {\n-                logger.warn(\"Failed to connect to config center, the config center is Apollo, \" +\n+                // 5-1 Failed to connect to configuration center.\n+\n+                logger.warn(\"5-1\", \"configuration server offline\", \"\",\n+                    \"Failed to connect to config center, the config center is Apollo, \" +\n                     \"the address is: \" + (StringUtils.isNotEmpty(configAddr) ? configAddr : configEnv) +\n                     \", will use the local cache value instead before eventually the connection is established.\");\n             }\ndiff --git a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n--- a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n+++ b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n@@ -63,7 +63,16 @@ public class ZookeeperDynamicConfiguration extends TreePathDynamicConfiguration\n         zkClient = zookeeperTransporter.connect(url);\n         boolean isConnected = zkClient.isConnected();\n         if (!isConnected) {\n-            throw new IllegalStateException(\"Failed to connect with zookeeper, pls check if url \" + url + \" is correct.\");\n+\n+            IllegalStateException illegalStateException =\n+                new IllegalStateException(\"Failed to connect with zookeeper, pls check if url \" + url + \" is correct.\");\n+\n+            if (logger != null) {\n+                logger.error(\"5-1\", \"configuration server offline\", \"\",\n+                    \"Failed to connect with zookeeper\", illegalStateException);\n+            }\n+\n+            throw illegalStateException;\n         }\n     }\ndiff --git a/dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java b/dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java\n--- a/dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java\n+++ b/dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java\n@@ -52,8 +52,8 @@\n  */\n public class RedisMetadataReport extends AbstractMetadataReport {\n-    private final static String REDIS_DATABASE_KEY = \"database\";\n-    private final static Logger logger = LoggerFactory.getLogger(RedisMetadataReport.class);\n+    private static final String REDIS_DATABASE_KEY = \"database\";\n+    private static final Logger logger = LoggerFactory.getLogger(RedisMetadataReport.class);\n     // protected , for test\n     protected JedisPool pool;\n@@ -66,7 +66,7 @@ public RedisMetadataReport(URL url) {\n         super(url);\n         timeout = url.getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);\n         if (url.getParameter(CLUSTER_KEY, false)) {\n-            jedisClusterNodes = new HashSet<HostAndPort>();\n+            jedisClusterNodes = new HashSet<>();\n             List<URL> urls = url.getBackupUrls();\n             for (URL tmpUrl : urls) {\n                 jedisClusterNodes.add(new HostAndPort(tmpUrl.getHost(), tmpUrl.getPort()));\n@@ -103,7 +103,7 @@ protected List<String> doGetExportedURLs(ServiceMetadataIdentifier metadataIdent\n         if (StringUtils.isEmpty(content)) {\n             return Collections.emptyList();\n         }\n-        return new ArrayList<String>(Arrays.asList(URL.decode(content)));\n+        return new ArrayList<>(Arrays.asList(URL.decode(content)));\n     }\n     @Override\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/javassist/JavassistProxyFactory.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/javassist/JavassistProxyFactory.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/javassist/JavassistProxyFactory.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/javassist/JavassistProxyFactory.java\n@@ -19,7 +19,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.bytecode.Proxy;\n import org.apache.dubbo.common.bytecode.Wrapper;\n-import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.proxy.AbstractProxyFactory;\n@@ -33,7 +33,7 @@\n  * JavassistRpcProxyFactory\n  */\n public class JavassistProxyFactory extends AbstractProxyFactory {\n-    private final static Logger logger = LoggerFactory.getLogger(JavassistProxyFactory.class);\n+    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(JavassistProxyFactory.class);\n     private final JdkProxyFactory jdkProxyFactory = new JdkProxyFactory();\n     @Override",
    "output": "Add error code to multiple classes in multiple modules. * Add @Override in DubboConfigDefaultPropertyValueBeanPostProcessor * Add error code 5-1 in config center module. * Code optimization"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/FilterChainBuilder.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/FilterChainBuilder.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/FilterChainBuilder.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/FilterChainBuilder.java\n@@ -192,6 +192,7 @@ public CallbackRegistrationInvoker(Invoker<T> filterInvoker, List<FILTER> filter\n         public Result invoke(Invocation invocation) throws RpcException {\n             Result asyncResult = filterInvoker.invoke(invocation);\n             asyncResult.whenCompleteWithContext((r, t) -> {\n+                RuntimeException filterRuntimeException = null;\n                 for (int i = filters.size() - 1; i >= 0; i--) {\n                     FILTER filter = filters.get(i);\n                     try {\n@@ -218,14 +219,18 @@ public Result invoke(Invocation invocation) throws RpcException {\n                                 listener.onError(t, filterInvoker, invocation);\n                             }\n                         }\n-                    } catch (Throwable filterThrowable) {\n+                    } catch (RuntimeException runtimeException) {\n                         LOGGER.error(String.format(\"Exception occurred while executing the %s filter named %s.\", i, filter.getClass().getSimpleName()));\n                         if (LOGGER.isDebugEnabled()) {\n                             LOGGER.debug(String.format(\"Whole filter list is: %s\", filters.stream().map(tmpFilter -> tmpFilter.getClass().getSimpleName()).collect(Collectors.toList())));\n                         }\n-                        throw filterThrowable;\n+                        filterRuntimeException = runtimeException;\n+                        t = runtimeException;\n                     }\n                 }\n+                if (filterRuntimeException != null) {\n+                    throw filterRuntimeException;\n+                }\n             });\n             return asyncResult;",
    "output": "Fix CallbackRegistrationInvoker skip when throw exception"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n@@ -45,6 +45,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.METADATA_SERVICE_PROTOCOL_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.THREADPOOL_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.THREADS_KEY;\n+import static org.apache.dubbo.remoting.Constants.BIND_PORT_KEY;\n /**\n  * Export metadata service\n@@ -122,8 +123,12 @@ private ProtocolConfig generateMetadataProtocol() {\n                     // metadata service may export before normal service export, it.hasNext() will return false.\n                     // so need use specified protocol port.\n                     if (it.hasNext()) {\n-                        String addr = it.next().getAddress();\n-                        String rawPort = addr.substring(addr.indexOf(\":\") + 1);\n+                        ProtocolServer server = it.next();\n+                        String rawPort = server.getUrl().getParameter(BIND_PORT_KEY);\n+                        if (rawPort == null) {\n+                            String addr = server.getAddress();\n+                            rawPort = addr.substring(addr.indexOf(\":\") + 1);\n+                        }\n                         protocolConfig.setPort(Integer.parseInt(rawPort));\n                     } else {\n                         Integer protocolPort = getProtocolConfig(specifiedProtocol).getPort();",
    "output": "Fix metadata service port error when config DUBBO_PORT_TO_REGISTRY env"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n@@ -42,6 +42,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_EXPORT_THREAD_NUM;\n+import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_PROTOCOL;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_REFER_THREAD_NUM;\n import static org.apache.dubbo.common.constants.CommonConstants.EXECUTOR_SERVICE_COMPONENT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERNAL_EXECUTOR_SERVICE_COMPONENT_KEY;\n@@ -83,8 +84,14 @@ public synchronized ExecutorService createExecutorIfAbsent(URL url) {\n         Map<Integer, ExecutorService> executors = data.computeIfAbsent(getExecutorKey(url), k -> new ConcurrentHashMap<>());\n         // Consumer's executor is sharing globally, key=Integer.MAX_VALUE. Provider's executor is sharing by protocol.\n         Integer portKey = CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY)) ? Integer.MAX_VALUE : url.getPort();\n+\n+        String protocol = url.getProtocol();\n+        if (StringUtils.isEmpty(protocol)) {\n+            protocol = DEFAULT_PROTOCOL;\n+        }\n+\n         if (url.getParameter(THREAD_NAME_KEY) == null) {\n-            url = url.putAttribute(THREAD_NAME_KEY, \"Dubbo-protocol-\" + portKey);\n+            url = url.putAttribute(THREAD_NAME_KEY, protocol + \"-protocol-\" + portKey);\n         }\n         URL finalUrl = url;\n         ExecutorService executor = executors.computeIfAbsent(portKey, k -> createExecutor(finalUrl));\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java\n@@ -18,7 +18,6 @@\n package org.apache.dubbo.rpc.protocol.tri;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.threadpool.manager.ExecutorRepository;\n@@ -48,20 +47,10 @@\n import java.util.Set;\n import java.util.concurrent.ExecutorService;\n-import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_CLIENT_THREADPOOL;\n-import static org.apache.dubbo.common.constants.CommonConstants.THREADPOOL_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.THREAD_NAME_KEY;\n-\n public class TripleProtocol extends AbstractProtocol {\n     public static final String METHOD_ATTR_PACK = \"pack\";\n-    private static final String CLIENT_THREAD_POOL_NAME = \"DubboTriClientHandler\";\n-    private static final URL THREAD_POOL_URL = new URL(CommonConstants.TRIPLE,\n-        CommonConstants.LOCALHOST_VALUE, 50051)\n-        .addParameter(THREAD_NAME_KEY, CLIENT_THREAD_POOL_NAME)\n-        .addParameterIfAbsent(THREADPOOL_KEY, DEFAULT_CLIENT_THREADPOOL);\n-\n     private static final Logger logger = LoggerFactory.getLogger(TripleProtocol.class);\n     private final PathResolver pathResolver;\n     private final TriBuiltinService triBuiltinService;",
    "output": "Fix triple protocol thread name"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Online.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Online.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Online.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Online.java\n@@ -19,9 +19,9 @@\n import org.apache.dubbo.qos.command.annotation.Cmd;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n-@Cmd(name = \"onlineApp\", summary = \"online app addresses\", example = {\n-        \"onlineApp dubbo\",\n-        \"onlineApp xx.xx.xxx.service\"\n+@Cmd(name = \"online\", summary = \"online app addresses\", example = {\n+        \"online dubbo\",\n+        \"online xx.xx.xxx.service\"\n })\n public class Online extends BaseOnline {\n     public Online(FrameworkModel frameworkModel) {",
    "output": "Fix Qos Online command typo"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n@@ -97,6 +97,10 @@ private ApplicationConfig getApplicationConfig() {\n         return applicationModel.getApplicationConfigManager().getApplication().get();\n     }\n+    private ProtocolConfig getProtocolConfig(String protocol) {\n+        return applicationModel.getApplicationConfigManager().getProtocol(protocol).get();\n+    }\n+\n     private ProtocolConfig generateMetadataProtocol() {\n         // protocol always defaults to dubbo if not specified\n         String specifiedProtocol = getSpecifiedProtocol();\n@@ -115,10 +119,17 @@ private ProtocolConfig generateMetadataProtocol() {\n                 Protocol protocol = applicationModel.getExtensionLoader(Protocol.class).getExtension(specifiedProtocol);\n                 if (protocol != null && protocol.getServers() != null) {\n                     Iterator<ProtocolServer> it = protocol.getServers().iterator();\n+                    // metadata service may export before normal service export, it.hasNext() will return false.\n+                    // so need use specified protocol port.\n                     if (it.hasNext()) {\n                         String addr = it.next().getAddress();\n                         String rawPort = addr.substring(addr.indexOf(\":\") + 1);\n                         protocolConfig.setPort(Integer.parseInt(rawPort));\n+                    } else {\n+                        Integer protocolPort = getProtocolConfig(specifiedProtocol).getPort();\n+                        if (null != protocolPort && protocolPort != -1) {\n+                            protocolConfig.setPort(protocolPort);\n+                        }\n                     }\n                 }\n             } catch (Exception e) {\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/metadata/MetadataServiceURLParamsMetadataCustomizerTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/metadata/MetadataServiceURLParamsMetadataCustomizerTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/metadata/MetadataServiceURLParamsMetadataCustomizerTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/metadata/MetadataServiceURLParamsMetadataCustomizerTest.java\n@@ -26,6 +26,7 @@\n import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n import org.apache.dubbo.config.provider.impl.DemoServiceImpl;\n import org.apache.dubbo.registry.client.DefaultServiceInstance;\n+import org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.junit.jupiter.api.AfterEach;\n@@ -49,7 +50,7 @@\n public class MetadataServiceURLParamsMetadataCustomizerTest {\n     public DefaultServiceInstance instance;\n-    private URL metadataServiceURL = URL.valueOf(\"dubbo://10.225.12.124:20880/org.apache.dubbo.metadata.MetadataService\" +\n+    private URL metadataServiceURL = URL.valueOf(\"dubbo://10.225.12.124:2002/org.apache.dubbo.metadata.MetadataService\" +\n         \"?application=MetadataServiceURLParamsMetadataCustomizerTest&group=MetadataServiceURLParamsMetadataCustomizerTest\" +\n         \"&interface=org.apache.dubbo.metadata.MetadataService&side=provider&timestamp=1637573430740&version=1.0.0\");",
    "output": "Fix metadata service export port"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -305,8 +305,8 @@ public void destroy() {\n     }\n     private int calculateTimeout(Invocation invocation, String methodName) {\n-        if (invocation.get(TIMEOUT_KEY) != null) {\n-            return (int) invocation.get(TIMEOUT_KEY);\n+        if (invocation.getObjectAttachment(TIMEOUT_KEY) != null) {\n+            return (int) invocation.getObjectAttachment(TIMEOUT_KEY);\n         }\n         Object countdown = RpcContext.getClientAttachment().getObjectAttachment(TIME_COUNTDOWN_KEY);\n         int timeout;",
    "output": "Fix tri timeout not set"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n@@ -135,7 +135,7 @@ class URL implements Serializable {\n     protected URL() {\n         this.urlAddress = null;\n-        this.urlParam = null;\n+        this.urlParam = URLParam.parse(new HashMap<>());\n         this.attributes = null;\n     }\n@@ -145,7 +145,7 @@ public URL(URLAddress urlAddress, URLParam urlParam) {\n     public URL(URLAddress urlAddress, URLParam urlParam, Map<String, Object> attributes) {\n         this.urlAddress = urlAddress;\n-        this.urlParam = urlParam;\n+        this.urlParam = null == urlParam ? URLParam.parse(new HashMap<>()) : urlParam;\n         this.attributes = (attributes != null ? attributes.isEmpty() ? null : attributes : null);\n     }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n@@ -55,7 +55,7 @@ public class InstanceAddressURL extends URL {\n     private volatile transient Set<String> providerFirstParams;\n     // one instance address url serves only one protocol.\n     private final transient String protocol;\n-\n+\n     protected InstanceAddressURL() {\n         this(null, null, null);\n     }\n@@ -242,6 +242,10 @@ public String getServiceMethodParameter(String protocolServiceKey, String method\n         }\n         MetadataInfo.ServiceInfo serviceInfo = getServiceInfo(protocolServiceKey);\n+        if (null == serviceInfo) {\n+            return getParameter(key);\n+        }\n+\n         String value = serviceInfo.getMethodParameter(method, key, null);\n         if (StringUtils.isNotEmpty(value)) {\n             return value;\n@@ -307,6 +311,10 @@ public boolean hasServiceMethodParameter(String protocolServiceKey, String metho\n             return false;\n         }\n+        if (null == serviceInfo) {\n+            return false;\n+        }\n+\n         return serviceInfo.hasMethodParameter(method, key);\n     }\n@@ -344,6 +352,10 @@ public boolean hasServiceMethodParameter(String protocolServiceKey, String metho\n         }\n         MetadataInfo.ServiceInfo serviceInfo = getServiceInfo(protocolServiceKey);\n+        if (null == serviceInfo) {\n+            return false;\n+        }\n+\n         return serviceInfo.hasMethodParameter(method);\n     }\n@@ -427,7 +439,11 @@ public URL addServiceParameter(String protocolServiceKey, String key, String val\n             return this;\n         }\n-       getServiceInfo(protocolServiceKey).addParameter(key, value);\n+        MetadataInfo.ServiceInfo serviceInfo = getServiceInfo(protocolServiceKey);\n+        if (null != serviceInfo) {\n+            serviceInfo.addParameter(key, value);\n+        }\n+\n         return this;\n     }\n@@ -436,12 +452,20 @@ public URL addServiceParameterIfAbsent(String protocolServiceKey, String key, St\n             return this;\n         }\n-        getServiceInfo(protocolServiceKey).addParameterIfAbsent(key, value);\n+        MetadataInfo.ServiceInfo serviceInfo = getServiceInfo(protocolServiceKey);\n+        if (null != serviceInfo) {\n+            serviceInfo.addParameterIfAbsent(key, value);\n+        }\n+\n         return this;\n     }\n     public URL addConsumerParams(String protocolServiceKey, Map<String, String> params) {\n-        getServiceInfo(protocolServiceKey).addConsumerParams(params);\n+        MetadataInfo.ServiceInfo serviceInfo = getServiceInfo(protocolServiceKey);\n+        if (null != serviceInfo) {\n+            serviceInfo.addConsumerParams(params);\n+        }\n+\n         return this;\n     }\n@@ -456,7 +480,12 @@ public String getAnyMethodParameter(String key) {\n         String suffix = \".\" + key;\n         String protocolServiceKey = getProtocolServiceKey();\n         if (StringUtils.isNotEmpty(protocolServiceKey)) {\n-            for (String fullKey : getServiceInfo(protocolServiceKey).getAllParams().keySet()) {\n+            MetadataInfo.ServiceInfo serviceInfo = getServiceInfo(protocolServiceKey);\n+            if (null == serviceInfo) {\n+                return null;\n+            }\n+\n+            for (String fullKey : serviceInfo.getAllParams().keySet()) {\n                 if (fullKey.endsWith(suffix)) {\n                     return getParameter(fullKey);\n                 }\n@@ -477,7 +506,9 @@ public URLAddress getUrlAddress() {\n     @Override\n     protected Map<String, Number> getServiceNumbers(String protocolServiceKey) {\n-        return getServiceInfo(protocolServiceKey).getNumbers();\n+        MetadataInfo.ServiceInfo serviceInfo = getServiceInfo(protocolServiceKey);\n+\n+        return null == serviceInfo ? new ConcurrentHashMap<>() : serviceInfo.getNumbers();\n     }\n     @Override\n@@ -494,7 +525,8 @@ protected Map<String, Number> getNumbers() {\n     @Override\n     protected Map<String, Map<String, Number>> getServiceMethodNumbers(String protocolServiceKey) {\n-        return getServiceInfo(protocolServiceKey).getMethodNumbers();\n+        MetadataInfo.ServiceInfo serviceInfo = getServiceInfo(protocolServiceKey);\n+        return null == serviceInfo ? new ConcurrentHashMap<>() : serviceInfo.getMethodNumbers();\n     }\n     @Override\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -24,6 +24,7 @@\n import org.apache.dubbo.common.utils.Assert;\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.metadata.MetadataInfo;\n import org.apache.dubbo.registry.AddressListener;\n import org.apache.dubbo.registry.Constants;\n import org.apache.dubbo.registry.ProviderFirstParams;\n@@ -324,7 +325,7 @@ private boolean urlChanged(Invoker<T> invoker, InstanceAddressURL newURL) {\n         }\n         if (oldURL instanceof OverrideInstanceAddressURL || newURL instanceof OverrideInstanceAddressURL) {\n-            if(!(oldURL instanceof OverrideInstanceAddressURL && newURL instanceof OverrideInstanceAddressURL)) {\n+            if (!(oldURL instanceof OverrideInstanceAddressURL && newURL instanceof OverrideInstanceAddressURL)) {\n                 // sub-class changed\n                 return true;\n             } else {\n@@ -334,8 +335,12 @@ private boolean urlChanged(Invoker<T> invoker, InstanceAddressURL newURL) {\n             }\n         }\n-        return !oldURL.getMetadataInfo().getValidServiceInfo(getConsumerUrl().getProtocolServiceKey())\n-            .equals(newURL.getMetadataInfo().getValidServiceInfo(getConsumerUrl().getProtocolServiceKey()));\n+        MetadataInfo.ServiceInfo oldServiceInfo = oldURL.getMetadataInfo().getValidServiceInfo(getConsumerUrl().getProtocolServiceKey());\n+        if (null == oldServiceInfo) {\n+            return false;\n+        }\n+\n+        return !oldServiceInfo.equals(newURL.getMetadataInfo().getValidServiceInfo(getConsumerUrl().getProtocolServiceKey()));\n     }\n     private List<Invoker<T>> toMergeInvokerList(List<Invoker<T>> invokers) {",
    "output": "Fix for issue 10303 * issue#10303 fix for java.lang.NullPointerException * issue#10303 fix for java.lang.NullPointerException"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -247,7 +247,7 @@ public synchronized void destroy() {\n     }\n     protected synchronized void init() {\n-        if (initialized) {\n+        if (initialized && ref !=null ) {\n             return;\n         }\n         try {",
    "output": "Fix ReferenceConfig init ref check https://github.com/apache/dubbo/issues/10222"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n@@ -203,7 +203,7 @@ private static ServiceInstance selectInstance(List<ServiceInstance> instances) {\n         return instances.get(ThreadLocalRandom.current().nextInt(0, instances.size()));\n     }\n-    private static class ProxyHolder {\n+    public static class ProxyHolder {\n         private final ConsumerModel consumerModel;\n         private final MetadataService proxy;\n         private final ModuleModel internalModel;",
    "output": "Fix ProxyHolder class modifier"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n@@ -47,7 +47,7 @@ public class FrameworkModel extends ScopeModel {\n     // internal app index is 0, default app index is 1\n     private final AtomicLong appIndex = new AtomicLong(0);\n-    private static Object globalLock = new Object();\n+    private static final Object globalLock = new Object();\n     private volatile static FrameworkModel defaultInstance;\n@@ -63,7 +63,7 @@ public class FrameworkModel extends ScopeModel {\n     private ApplicationModel internalApplicationModel;\n-    private Object instLock = new Object();\n+    private final Object instLock = new Object();\n     public FrameworkModel() {\n         super(null, ExtensionScope.FRAMEWORK, false);\n@@ -142,7 +142,7 @@ protected void onDestroy() {\n     private void checkApplicationDestroy() {\n         if (applicationModels.size() > 0) {\n             List<String> remainApplications = applicationModels.stream()\n-                .map(model -> model.getDesc())\n+                .map(ScopeModel::getDesc)\n                 .collect(Collectors.toList());\n             throw new IllegalStateException(\"Not all application models are completely destroyed, remaining \" +\n                 remainApplications.size() + \" application models may be created during destruction: \" + remainApplications);",
    "output": "Add final modifier for lock in FrameworkModel"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -823,8 +823,11 @@ private void invokeSetParameters(Map<String, String> values, Object obj) {\n         if (CollectionUtils.isEmptyMap(values)) {\n             return;\n         }\n-        Map<String, String> map = invokeGetParameters(obj.getClass(), obj);\n-        map = map == null ? new HashMap<>() : map;\n+        Map<String, String> map = new HashMap<>();\n+        Map<String, String> getParametersMap = invokeGetParameters(obj.getClass(), obj);\n+        if (getParametersMap != null && !getParametersMap.isEmpty()) {\n+            map.putAll(getParametersMap);\n+        }\n         map.putAll(values);\n         invokeSetParameters(obj.getClass(), obj, map);\n     }",
    "output": "Fix UnsupportedOperationException in invokeSetParameters * fix UnsupportedOperationException 10257 * Update AbstractConfig.java * Update AbstractConfig.java"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -823,8 +823,11 @@ private void invokeSetParameters(Map<String, String> values, Object obj) {\n         if (CollectionUtils.isEmptyMap(values)) {\n             return;\n         }\n-        Map<String, String> map = invokeGetParameters(obj.getClass(), obj);\n-        map = map == null ? new HashMap<>() : map;\n+        Map<String, String> map = new HashMap<>();\n+        Map<String, String> getParametersMap = invokeGetParameters(obj.getClass(), obj);\n+        if (getParametersMap != null && !getParametersMap.isEmpty()) {\n+            map.putAll(getParametersMap);\n+        }\n         map.putAll(values);\n         invokeSetParameters(obj.getClass(), obj, map);\n     }",
    "output": "Fix UnsupportedOperationException in invokeSetParameters * fix UnsupportedOperationException 10257 * Update AbstractConfig.java * Update AbstractConfig.java"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java\n@@ -20,7 +20,6 @@\n import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.UrlUtils;\n import org.apache.dubbo.qos.common.QosConstants;\n import org.apache.dubbo.qos.server.Server;\n import org.apache.dubbo.rpc.Exporter;\n@@ -69,19 +68,13 @@ public int getDefaultPort() {\n     @Override\n     public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n-        if (UrlUtils.isRegistry(invoker.getUrl())) {\n-            startQosServer(invoker.getUrl());\n-            return protocol.export(invoker);\n-        }\n+        startQosServer(invoker.getUrl());\n         return protocol.export(invoker);\n     }\n     @Override\n     public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n-        if (UrlUtils.isRegistry(url)) {\n-            startQosServer(url);\n-            return protocol.refer(type, url);\n-        }\n+        startQosServer(url);\n         return protocol.refer(type, url);\n     }\n@@ -105,8 +98,8 @@ private void startQosServer(URL url) {\n             boolean qosEnable = url.getParameter(QOS_ENABLE, true);\n             if (!qosEnable) {\n                 logger.info(\"qos won't be started because it is disabled. \" +\n-                        \"Please check dubbo.application.qos.enable is configured either in system property, \" +\n-                        \"dubbo.properties or XML/spring-boot configuration.\");\n+                    \"Please check dubbo.application.qos.enable is configured either in system property, \" +\n+                    \"dubbo.properties or XML/spring-boot configuration.\");\n                 return;\n             }",
    "output": "Fix qos failure in non-registry scenarios * fix qos failure in non-registry scenarios"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/MemoryLimitCalculator.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/MemoryLimitCalculator.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/MemoryLimitCalculator.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/MemoryLimitCalculator.java\n@@ -17,9 +17,13 @@\n package org.apache.dubbo.common.threadpool;\n+import org.apache.dubbo.common.resource.GlobalResourcesRepository;\n+import org.apache.dubbo.common.utils.NamedThreadFactory;\n+\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n /**\n  * {@link java.lang.Runtime#freeMemory()} technology is used to calculate the\n@@ -33,26 +37,37 @@ public class MemoryLimitCalculator {\n     private static volatile long maxAvailable;\n-    private static final ScheduledExecutorService SCHEDULER = Executors.newSingleThreadScheduledExecutor();\n-\n-    static {\n-        // immediately refresh when this class is loaded to prevent maxAvailable from being 0\n-        refresh();\n-        // check every 50 ms to improve performance\n-        SCHEDULER.scheduleWithFixedDelay(MemoryLimitCalculator::refresh, 50, 50, TimeUnit.MILLISECONDS);\n-        Runtime.getRuntime().addShutdownHook(new Thread(SCHEDULER::shutdown));\n-    }\n+    private static final AtomicBoolean refreshStarted = new AtomicBoolean(false);\n     private static void refresh() {\n         maxAvailable = Runtime.getRuntime().freeMemory();\n     }\n+    private static void checkAndScheduleRefresh() {\n+        if (!refreshStarted.get()) {\n+            // immediately refresh when first call to prevent maxAvailable from being 0\n+            // to ensure that being refreshed before refreshStarted being set as true\n+            // notice: refresh may be called for more than once because there is no lock\n+            refresh();\n+            if (refreshStarted.compareAndSet(false, true)) {\n+                ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"Dubbo-Memory-Calculator\"));\n+                // check every 50 ms to improve performance\n+                scheduledExecutorService.scheduleWithFixedDelay(MemoryLimitCalculator::refresh, 50, 50, TimeUnit.MILLISECONDS);\n+                GlobalResourcesRepository.registerGlobalDisposable(() -> {\n+                    refreshStarted.set(false);\n+                    scheduledExecutorService.shutdown();\n+                });\n+            }\n+        }\n+    }\n+\n     /**\n      * Get the maximum available memory of the current JVM.\n      *\n      * @return maximum available memory\n      */\n     public static long maxAvailable() {\n+        checkAndScheduleRefresh();\n         return maxAvailable;\n     }\n@@ -67,6 +82,7 @@ public static long calculate(final float percentage) {\n         if (percentage <= 0 || percentage > 1) {\n             throw new IllegalArgumentException();\n         }\n+        checkAndScheduleRefresh();\n         return (long) (maxAvailable() * percentage);\n     }\n@@ -76,6 +92,7 @@ public static long calculate(final float percentage) {\n      * @return available memory\n      */\n     public static long defaultLimit() {\n+        checkAndScheduleRefresh();\n         return (long) (maxAvailable() * 0.8);\n     }\n }",
    "output": "Improve enhance scheduled executor for MemoryLimitCalculator"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java\n@@ -230,7 +230,7 @@ private void scanServiceBeans(Set<String> packagesToScan, BeanDefinitionRegistry\n                 }\n                 for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) {\n-                    processScannedBeanDefinition(beanDefinitionHolder, registry, scanner);\n+                    processScannedBeanDefinition(beanDefinitionHolder);\n                     servicePackagesHolder.addScannedClass(beanDefinitionHolder.getBeanDefinition().getBeanClassName());\n                 }\n             } else {\n@@ -318,13 +318,10 @@ private Set<BeanDefinitionHolder> findServiceBeanDefinitionHolders(\n      * Registers {@link ServiceBean} from new annotated {@link Service} {@link BeanDefinition}\n      *\n      * @param beanDefinitionHolder\n-     * @param registry\n-     * @param scanner\n      * @see ServiceBean\n      * @see BeanDefinition\n      */\n-    private void processScannedBeanDefinition(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,\n-                                              DubboClassPathBeanDefinitionScanner scanner) {\n+    private void processScannedBeanDefinition(BeanDefinitionHolder beanDefinitionHolder) {\n         Class<?> beanClass = resolveClass(beanDefinitionHolder);",
    "output": "Remove unused parameters of ServiceAnnotationPostProcessor#processScannedBeanDefinition method"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/SerializeClassCheckerTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/SerializeClassCheckerTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/SerializeClassCheckerTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/SerializeClassCheckerTest.java\n@@ -21,6 +21,7 @@\n import javassist.compiler.Javac;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.AfterAll;\n import org.junit.jupiter.api.Test;\n import java.net.Socket;\n@@ -35,6 +36,11 @@ public void setUp() {\n         SerializeClassChecker.clearInstance();\n     }\n+    @AfterAll\n+    public static void tearDown() {\n+        SerializeClassChecker.clearInstance();\n+    }\n+\n     @Test\n     public void testCommon() {\n         SerializeClassChecker serializeClassChecker = SerializeClassChecker.getInstance();",
    "output": "Fix test order dependencies in class `PojoUtilsTest` * fixed test order dependencies * changed AfterAll routine to static"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/SimpleReferenceCache.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/SimpleReferenceCache.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/SimpleReferenceCache.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/SimpleReferenceCache.java\n@@ -260,7 +260,9 @@ public void destroyAll() {\n     private void destroyReference(ReferenceConfigBase<?> rc) {\n         Destroyable proxy = (Destroyable) rc.get();\n-        proxy.$destroy();\n+        if (proxy != null){\n+            proxy.$destroy();\n+        }\n         rc.destroy();\n     }",
    "output": "Fix destroy reference cause NPE"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -535,4 +535,6 @@ public interface CommonConstants {\n     String NATIVE_STUB = \"nativestub\";\n     String METADATA = \"metadata\";\n+\n+    String IGNORE_LISTEN_SHUTDOWN_HOOK = \"dubbo.shutdownHook.listenIgnore\";\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.dubbo.config;\n+import org.apache.dubbo.common.config.ConfigurationUtils;\n+import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.Assert;\n@@ -45,16 +47,25 @@ public class DubboShutdownHook extends Thread {\n      */\n     private final AtomicBoolean destroyed = new AtomicBoolean(false);\n+    /**\n+     * Whether ignore listen on shutdown hook?\n+     */\n+    private final boolean ignoreListenShutdownHook;\n+\n     public DubboShutdownHook(ApplicationModel applicationModel) {\n         super(\"DubboShutdownHook\");\n         this.applicationModel = applicationModel;\n         Assert.notNull(this.applicationModel, \"ApplicationModel is null\");\n+        ignoreListenShutdownHook = Boolean.parseBoolean(ConfigurationUtils.getProperty(applicationModel, CommonConstants.IGNORE_LISTEN_SHUTDOWN_HOOK));\n+        if (ignoreListenShutdownHook) {\n+            logger.info(\"dubbo.shutdownHook.listenIgnore configured, will ignore add shutdown hook to jvm.\");\n+        }\n     }\n     @Override\n     public void run() {\n-        if (destroyed.compareAndSet(false, true)) {\n+        if (destroyed.compareAndSet(false, true) && !ignoreListenShutdownHook) {\n             if (logger.isInfoEnabled()) {\n                 logger.info(\"Run shutdown hook now.\");\n             }\n@@ -71,7 +82,7 @@ private void doDestroy() {\n      * Register the ShutdownHook\n      */\n     public void register() {\n-        if (registered.compareAndSet(false, true)) {\n+        if (registered.compareAndSet(false, true) && !ignoreListenShutdownHook) {\n             try {\n                 Runtime.getRuntime().addShutdownHook(this);\n             } catch (IllegalStateException e) {\n@@ -86,7 +97,7 @@ public void register() {\n      * Unregister the ShutdownHook\n      */\n     public void unregister() {\n-        if (registered.compareAndSet(true, false)) {\n+        if (registered.compareAndSet(true, false) && !ignoreListenShutdownHook) {\n             if (this.isAlive()) {\n                 // DubboShutdownHook thread is running\n                 return;",
    "output": "Add shutdown hook ignore support"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/DefaultMetadataParamsFilter.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/DefaultMetadataParamsFilter.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/DefaultMetadataParamsFilter.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/DefaultMetadataParamsFilter.java\n@@ -37,9 +37,9 @@ public class DefaultMetadataParamsFilter implements MetadataParamsFilter {\n     private final String[] includedInstanceParams;\n     public DefaultMetadataParamsFilter() {\n-        this.includedInstanceParams = new String[]{HEARTBEAT_TIMEOUT_KEY};\n+        this.includedInstanceParams = new String[]{HEARTBEAT_TIMEOUT_KEY, TIMESTAMP_KEY};\n         this.excludedServiceParams = new String[]{MONITOR_KEY, BIND_IP_KEY, BIND_PORT_KEY, QOS_ENABLE,\n-            QOS_HOST, QOS_PORT, ACCEPT_FOREIGN_IP, VALIDATION_KEY, INTERFACES, PID_KEY, TIMESTAMP_KEY};\n+            QOS_HOST, QOS_PORT, ACCEPT_FOREIGN_IP, VALIDATION_KEY, INTERFACES, PID_KEY, TIMESTAMP_KEY, HEARTBEAT_TIMEOUT_KEY};\n     }\n     @Override\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n@@ -47,6 +47,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.DOT_SEPARATOR;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_CHAR_SEPARATOR;\n import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n import static org.apache.dubbo.metadata.RevisionResolver.EMPTY_REVISION;\n public class MetadataInfo implements Serializable {\n@@ -394,7 +395,7 @@ private void extractInstanceParams(URL url, List<MetadataParamsFilter> filters)\n         tmpInstanceParams.forEach((key, value) -> {\n             String oldValue = instanceParams.put(key, value);\n-            if (oldValue != null && !oldValue.equals(value)) {\n+            if (!TIMESTAMP_KEY.equals(key) && oldValue != null && !oldValue.equals(value)) {\n                 throw new IllegalStateException(String.format(\"Inconsistent instance metadata found in different services: %s, %s\", oldValue, value));\n             }\n         });",
    "output": "Add 'timestamp' as the default key of the instance url"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/AbstractServiceNameMapping.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/AbstractServiceNameMapping.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/AbstractServiceNameMapping.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/AbstractServiceNameMapping.java\n@@ -26,6 +26,7 @@\n import org.apache.dubbo.rpc.model.ScopeModelAware;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n@@ -54,7 +55,8 @@ public abstract class AbstractServiceNameMapping implements ServiceNameMapping,\n     private final Map<String, Set<MappingListener>> mappingListeners = new ConcurrentHashMap<>();\n     // mapping lock is shared among registries of the same application.\n     private final ConcurrentMap<String, ReentrantLock> mappingLocks = new ConcurrentHashMap<>();\n-    private volatile boolean initiated;\n+    // TODO, check how should this be cleared once a reference or interface is destroyed to avoid key accumulation\n+    private final Map<String, Boolean> mappingInitStatus = new HashMap<>();\n     public AbstractServiceNameMapping(ApplicationModel applicationModel) {\n         this.applicationModel = applicationModel;\n@@ -86,12 +88,13 @@ public void setApplicationModel(ApplicationModel applicationModel) {\n     @Override\n     public synchronized void initInterfaceAppMapping(URL subscribedURL) {\n-        if (initiated) {\n+        String key = ServiceNameMapping.buildMappingKey(subscribedURL);\n+        if (hasInitiated(key)) {\n             return;\n         }\n-        initiated = true;\n+        mappingInitStatus.put(key, Boolean.TRUE);\n+\n         Set<String> subscribedServices = new TreeSet<>();\n-        String key = ServiceNameMapping.buildMappingKey(subscribedURL);\n         String serviceNames = subscribedURL.getParameter(PROVIDED_BY);\n         if (StringUtils.isNotEmpty(serviceNames)) {\n@@ -224,11 +227,22 @@ protected void removeMappingLock(String key) {\n         }\n     }\n+    private boolean hasInitiated(String key) {\n+        Lock lock = getMappingLock(key);\n+        try {\n+            lock.lock();\n+            return mappingInitStatus.computeIfAbsent(key, _k -> Boolean.FALSE);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n     @Override\n     public void $destroy() {\n         mappingCacheManager.destroy();\n         mappingListeners.clear();\n         mappingLocks.clear();\n+        mappingInitStatus.clear();\n     }\n     private class AsyncMappingTask implements Callable<Set<String>> {",
    "output": "Fix interface-app mapping, recored mapping init status for each unique interface key"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcInvocation.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcInvocation.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcInvocation.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcInvocation.java\n@@ -513,7 +513,7 @@ public String getAttachment(String key, String defaultValue) {\n                 return strValue;\n             }\n         }\n-        return null;\n+        return defaultValue;\n     }\n     @Deprecated",
    "output": "Fix getAttachment, return default value"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java\n@@ -444,12 +444,12 @@ public Object unpack(byte[] data) throws IOException, ClassNotFoundException {\n             TripleWrapper.TripleRequestWrapper wrapper = TripleWrapper.TripleRequestWrapper.parseFrom(\n                 data);\n             Object[] ret = new Object[wrapper.getArgsCount()];\n-            final String serializeType = convertHessianFromWrapper(wrapper.getSerializeType());\n-            ((WrapResponsePack) responsePack).serialize = serializeType;\n+            ((WrapResponsePack) responsePack).serialize = wrapper.getSerializeType();\n             for (int i = 0; i < wrapper.getArgsList().size(); i++) {\n                 ByteArrayInputStream bais = new ByteArrayInputStream(\n                     wrapper.getArgs(i).toByteArray());\n-                ret[i] = serialization.deserialize(url, serializeType, wrapper.getArgTypes(i),\n+                ret[i] = serialization.deserialize(url, wrapper.getSerializeType(),\n+                    wrapper.getArgTypes(i),\n                     bais);\n             }\n             return ret;",
    "output": "Fix hessian4"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServer.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServer.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServer.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServer.java\n@@ -35,6 +35,7 @@\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.group.DefaultChannelGroup;\n import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.ssl.SslContext;\n import io.netty.util.concurrent.Future;\n import io.netty.util.concurrent.GlobalEventExecutor;\n@@ -111,6 +112,13 @@ protected void doOpen() {\n             getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),\n             EVENT_LOOP_WORKER_POOL_NAME);\n+        final boolean enableSsl = getUrl().getParameter(SSL_ENABLED_KEY, false);\n+        final SslContext sslContext;\n+        if (enableSsl) {\n+            sslContext = SslContexts.buildServerSslContext(url);\n+        } else {\n+            sslContext = null;\n+        }\n         bootstrap.group(bossGroup, workerGroup)\n             .channel(NettyEventLoopFactory.serverSocketChannelClass())\n             .option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)\n@@ -121,15 +129,9 @@ protected void doOpen() {\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     // Do not add idle state handler here, because it should be added in the protocol handler.\n                     final ChannelPipeline p = ch.pipeline();\n-                    final boolean enableSsl = getUrl().getParameter(SSL_ENABLED_KEY, false);\n                     final PortUnificationServerHandler puHandler;\n-                    if (enableSsl) {\n-                        puHandler = new PortUnificationServerHandler(url,\n-                            SslContexts.buildServerSslContext(url), true, protocols, channels);\n-                    } else {\n-                        puHandler = new PortUnificationServerHandler(url, null, false, protocols,\n-                            channels);\n-                    }\n+                    puHandler = new PortUnificationServerHandler(url, sslContext, true, protocols,\n+                        channels);\n                     p.addLast(\"negotiation-protocol\", puHandler);\n                 }\n             });",
    "output": "Fix duplicate ssl init"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/AccessLogData.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/AccessLogData.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/AccessLogData.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/AccessLogData.java\n@@ -16,32 +16,30 @@\n  */\n package org.apache.dubbo.rpc.support;\n+\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.RpcContext;\n-\n import com.alibaba.fastjson.JSON;\n-\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n import java.util.Arrays;\n import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n /**\n- * AccessLogData is a container for log event data. In internally uses map and store each filed of log as value. It\n- * does not generate any dynamic value e.g. time stamp, local jmv machine host address etc. It does not allow any null\n+ * AccessLogData is a container for log event data. In internally uses map and store each field of log as value. It\n+ * does not generate any dynamic value e.g. time stamp, local jvm machine host address etc. It does not allow any null\n  * or empty key.\n  *\n- * Note: since its date formatter is a singleton, make sure to run it in single thread only.\n  */\n public final class AccessLogData {\n     private static final String MESSAGE_DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n-    private static final DateFormat MESSAGE_DATE_FORMATTER = new SimpleDateFormat(MESSAGE_DATE_FORMAT);\n-\n+    private static final DateTimeFormatter MESSAGE_DATE_FORMATTER = DateTimeFormatter.ofPattern(MESSAGE_DATE_FORMAT);\n     private static final String VERSION = \"version\";\n     private static final String GROUP = \"group\";\n     private static final String SERVICE = \"service\";\n@@ -194,7 +192,7 @@ public String getLogMessage() {\n         StringBuilder sn = new StringBuilder();\n         sn.append('[')\n-                .append(MESSAGE_DATE_FORMATTER.format(getInvocationTime()))\n+                .append(LocalDateTime.ofInstant(getInvocationTime().toInstant(), ZoneId.systemDefault()).format(MESSAGE_DATE_FORMATTER))\n                 .append(\"] \")\n                 .append(get(REMOTE_HOST))\n                 .append(':')",
    "output": "Change to thread-safe date processing class * Change to thread-safe date processing class * restore package order"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServer.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServer.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServer.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServer.java\n@@ -34,11 +34,11 @@\n import io.netty.channel.ChannelOption;\n import io.netty.channel.ChannelPipeline;\n import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.group.ChannelGroupFuture;\n import io.netty.channel.group.DefaultChannelGroup;\n import io.netty.channel.socket.SocketChannel;\n import io.netty.handler.timeout.IdleStateHandler;\n import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n import java.net.InetSocketAddress;\n import java.util.List;\n@@ -59,6 +59,10 @@ public class PortUnificationServer {\n     private static final Logger logger = LoggerFactory.getLogger(PortUnificationServer.class);\n     private final List<WireProtocol> protocols;\n     private final URL url;\n+\n+    private final DefaultChannelGroup channels = new DefaultChannelGroup(\n+        GlobalEventExecutor.INSTANCE);\n+\n     private final int serverShutdownTimeoutMills;\n     /**\n      * netty server bootstrap.\n@@ -68,7 +72,6 @@ public class PortUnificationServer {\n      * the boss channel that receive connections and dispatch these to worker channel.\n      */\n     private Channel channel;\n-    private DefaultChannelGroup channelGroup;\n     private EventLoopGroup bossGroup;\n     private EventLoopGroup workerGroup;\n@@ -127,15 +130,15 @@ protected void initChannel(SocketChannel ch) throws Exception {\n                     final PortUnificationServerHandler puHandler;\n                     if (enableSsl) {\n                         puHandler = new PortUnificationServerHandler(url,\n-                            SslContexts.buildServerSslContext(url), true, protocols);\n+                            SslContexts.buildServerSslContext(url), true, protocols, channels);\n                     } else {\n-                        puHandler = new PortUnificationServerHandler(url, null, false, protocols);\n+                        puHandler = new PortUnificationServerHandler(url, null, false, protocols,\n+                            channels);\n                     }\n                     p.addLast(\"server-idle-handler\",\n                         new IdleStateHandler(0, 0, idleTimeout, MILLISECONDS));\n                     p.addLast(\"negotiation-protocol\", puHandler);\n-                    channelGroup = puHandler.getChannels();\n                 }\n             });\n         // bind\n@@ -161,10 +164,7 @@ protected void doClose() throws Throwable {\n                 channel = null;\n             }\n-            if (channelGroup != null) {\n-                ChannelGroupFuture closeFuture = channelGroup.close();\n-                closeFuture.await(serverShutdownTimeoutMills);\n-            }\n+            channels.close().await(serverShutdownTimeoutMills);\n             final long cost = System.currentTimeMillis() - st;\n             logger.info(\"Port unification server closed. cost:\" + cost);\n         } catch (InterruptedException e) {\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java\n@@ -24,11 +24,10 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelPipeline;\n-import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.group.ChannelGroup;\n import io.netty.handler.codec.ByteToMessageDecoder;\n import io.netty.handler.ssl.SslContext;\n import io.netty.handler.ssl.SslHandler;\n-import io.netty.util.concurrent.GlobalEventExecutor;\n import java.util.List;\n import java.util.Set;\n@@ -38,46 +37,33 @@ public class PortUnificationServerHandler extends ByteToMessageDecoder {\n     private static final Logger LOGGER = LoggerFactory.getLogger(\n         PortUnificationServerHandler.class);\n+    private final ChannelGroup channels;\n+\n     private final SslContext sslCtx;\n     private final URL url;\n     private final boolean detectSsl;\n     private final List<WireProtocol> protocols;\n-    private final DefaultChannelGroup channels = new DefaultChannelGroup(\n-        GlobalEventExecutor.INSTANCE);\n-\n-    public PortUnificationServerHandler(URL url, List<WireProtocol> protocols) {\n-        this(url, null, false, protocols);\n-    }\n     public PortUnificationServerHandler(URL url, SslContext sslCtx, boolean detectSsl,\n-        List<WireProtocol> protocols) {\n+        List<WireProtocol> protocols, ChannelGroup channels) {\n         this.url = url;\n         this.sslCtx = sslCtx;\n         this.protocols = protocols;\n         this.detectSsl = detectSsl;\n+        this.channels = channels;\n     }\n     @Override\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         LOGGER.error(\"Unexpected exception from downstream before protocol detected.\", cause);\n     }\n-    public DefaultChannelGroup getChannels() {\n-        return channels;\n-    }\n-\n     @Override\n     public void channelActive(ChannelHandlerContext ctx) throws Exception {\n         super.channelActive(ctx);\n         channels.add(ctx.channel());\n     }\n-    @Override\n-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-        super.channelInactive(ctx);\n-        channels.remove(ctx.channel());\n-    }\n-\n     @Override\n     protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)\n         throws Exception {\n@@ -124,7 +110,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)\n     private void enableSsl(ChannelHandlerContext ctx) {\n         ChannelPipeline p = ctx.pipeline();\n         p.addLast(\"ssl\", sslCtx.newHandler(ctx.alloc()));\n-        p.addLast(\"unificationA\", new PortUnificationServerHandler(url, sslCtx, false, protocols));\n+        p.addLast(\"unificationA\",\n+            new PortUnificationServerHandler(url, sslCtx, false, protocols, channels));\n         p.remove(this);\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/GracefulShutdown.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/GracefulShutdown.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/GracefulShutdown.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/GracefulShutdown.java\n@@ -48,14 +48,14 @@ public void gracefulShutdown() {\n         Http2GoAwayFrame goAwayFrame = new DefaultHttp2GoAwayFrame(Http2Error.NO_ERROR, ByteBufUtil\n             .writeAscii(ctx.alloc(), goAwayMessage));\n         goAwayFrame.setExtraStreamIds(Integer.MAX_VALUE);\n-        ctx.write(goAwayFrame);\n+        ctx.writeAndFlush(goAwayFrame);\n         pingFuture = ctx.executor().schedule(\n             () -> secondGoAwayAndClose(ctx),\n             GRACEFUL_SHUTDOWN_PING_TIMEOUT_NANOS,\n             TimeUnit.NANOSECONDS);\n         Http2PingFrame pingFrame = new DefaultHttp2PingFrame(GRACEFUL_SHUTDOWN_PING, false);\n-        ctx.write(pingFrame);\n+        ctx.writeAndFlush(pingFrame);\n     }\n     void secondGoAwayAndClose(ChannelHandlerContext ctx) {\n@@ -69,8 +69,7 @@ void secondGoAwayAndClose(ChannelHandlerContext ctx) {\n         try {\n             Http2GoAwayFrame goAwayFrame = new DefaultHttp2GoAwayFrame(Http2Error.NO_ERROR,\n                 ByteBufUtil.writeAscii(this.ctx.alloc(), this.goAwayMessage));\n-            ctx.write(goAwayFrame);\n-            ctx.flush();\n+            ctx.writeAndFlush(goAwayFrame);\n             //TODO support customize graceful shutdown timeout mills\n             ctx.close(originPromise);\n         } catch (Exception e) {",
    "output": "Fix graceful shutdown not work"
  },
  {
    "input": "diff --git a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/env/DubboDefaultPropertiesEnvironmentPostProcessor.java b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/env/DubboDefaultPropertiesEnvironmentPostProcessor.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/env/DubboDefaultPropertiesEnvironmentPostProcessor.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/env/DubboDefaultPropertiesEnvironmentPostProcessor.java\n@@ -119,9 +119,10 @@ private void addOrReplace(MutablePropertySources propertySources,\n             PropertySource<?> source = propertySources.get(PROPERTY_SOURCE_NAME);\n             if (source instanceof MapPropertySource) {\n                 target = (MapPropertySource) source;\n-                for (String key : map.keySet()) {\n+                for (Map.Entry<String,Object> entry : map.entrySet()) {\n+                    String key = entry.getKey();\n                     if (!target.containsProperty(key)) {\n-                        target.getSource().put(key, map.get(key));\n+                        target.getSource().put(key, entry.getValue());\n                     }\n                 }\n             }",
    "output": "Improve performance"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java\n@@ -138,9 +138,11 @@ private void doSendMessage(Object message) {\n         final byte[] data;\n         try {\n             data = packableMethod.packResponse(message);\n-        } catch (IOException e) {\n+        } catch (Throwable e) {\n             close(TriRpcStatus.INTERNAL.withDescription(\"Serialize response failed\")\n                 .withCause(e), null);\n+            LOGGER.error(String.format(\"Serialize triple response failed, service=%s method=%s\",\n+                serviceName, methodName), e);\n             return;\n         }\n         if (data == null) {\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java\n@@ -80,9 +80,11 @@ public void onMessage(byte[] message) {\n         try {\n             final Object unpacked = requestMetadata.packableMethod.parseResponse(message);\n             listener.onMessage(unpacked);\n-        } catch (IOException | ClassNotFoundException e) {\n+        } catch (Throwable t) {\n             cancelByLocal(TriRpcStatus.INTERNAL.withDescription(\"Deserialize response failed\")\n-                .withCause(e).asException());\n+                .withCause(t).asException());\n+            LOGGER.error(String.format(\"Failed to deserialize triple response, service=%s, method=%s,connection=%s\",\n+                connection ,requestMetadata.service, requestMetadata.method.getMethodName()),t);\n         }\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java\n@@ -330,7 +330,6 @@ public void onData(ByteBuf data, boolean endStream) {\n                     ReferenceCountUtil.release(data);\n                     if (transportError.description.length() > 512 || endStream) {\n                         handleH2TransportError(transportError);\n-\n                     }\n                     return;\n                 }",
    "output": "Add log when serialize failed"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java\n@@ -93,7 +93,8 @@ private WriteQueue createWriteQueue(Channel parent) {\n         channel.pipeline()\n             .addLast(new TripleCommandOutBoundHandler())\n             .addLast(new TripleHttp2ClientResponseHandler(createTransportListener()));\n-        parent.closeFuture().addListener(f -> transportException(f.cause()));\n+        channel.closeFuture()\n+            .addListener(f -> transportException(f.cause()));\n         return new WriteQueue(channel);\n     }",
    "output": "Fix mem leak"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java\n@@ -102,8 +102,9 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)\n         Set<String> supported = url.getApplicationModel()\n             .getExtensionLoader(WireProtocol.class)\n             .getSupportedExtensions();\n-        LOGGER.error(String.format(\"Can not recognize protocol from downstream . \"\n-            + \"preface=%s protocols=%s\", Bytes.bytes2hex(preface), supported));\n+        LOGGER.error(String.format(\"Can not recognize protocol from downstream=%s . \"\n+                + \"preface=%s protocols=%s\", ctx.channel().remoteAddress(), Bytes.bytes2hex(preface),\n+            supported));\n         // Unknown protocol; discard everything and close the connection.\n         in.clear();",
    "output": "Add remote address log"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -193,6 +193,9 @@ AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocat\n         final AsyncRpcResult result;\n         DeadlineFuture future = DeadlineFuture.newFuture(getUrl().getPath(),\n             methodDescriptor.getMethodName(), getUrl().getAddress(), timeout, callbackExecutor);\n+\n+        RequestMetadata request = createRequest(methodDescriptor, invocation, timeout);\n+\n         final Object pureArgument;\n         if (methodDescriptor.getParameterClasses().length == 2\n             && methodDescriptor.getParameterClasses()[1].isAssignableFrom(\n@@ -224,7 +227,7 @@ AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocat\n             FutureContext.getContext().setCompatibleFuture(future);\n         }\n         ClientCall.Listener callListener = new UnaryClientCallListener(future);\n-        RequestMetadata request = createRequest(methodDescriptor, invocation, timeout);\n+\n         final StreamObserver<Object> requestObserver = call.start(request, callListener);\n         requestObserver.onNext(pureArgument);\n         requestObserver.onCompleted();",
    "output": "Fix triple protocol async call * fix triple protocol async call * Fix format"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java b/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java\n@@ -22,8 +22,6 @@\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n-import java.text.MessageFormat;\n-import java.util.Arrays;\n import java.util.Map;\n import static org.apache.dubbo.common.utils.TypeUtils.getRawClass;\n@@ -53,12 +51,6 @@ public TypeDefinition build(Type type, Class<?> clazz, Map<String, TypeDefinitio\n         Type[] actualTypeArgs = parameterizedType.getActualTypeArguments();\n         int actualTypeArgsLength = actualTypeArgs == null ? 0 : actualTypeArgs.length;\n-        if (actualTypeArgsLength != 2) {\n-            throw new IllegalArgumentException(MessageFormat.format(\n-                    \"[ServiceDefinitionBuilder] Map type [{0}] with unexpected amount of arguments [{1}].\"\n-                            + Arrays.toString(actualTypeArgs), type, actualTypeArgs));\n-        }\n-\n         String mapType = ClassUtils.getCanonicalNameForParameterizedType(parameterizedType);\n         TypeDefinition td = typeCache.get(mapType);",
    "output": "Remove hard-coded param type check in MapTypeBuilder"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java\n@@ -17,25 +17,34 @@\n package org.apache.dubbo.remoting.api;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.io.Bytes;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import io.netty.buffer.ByteBuf;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.group.DefaultChannelGroup;\n import io.netty.handler.codec.ByteToMessageDecoder;\n import io.netty.handler.ssl.SslContext;\n+import io.netty.util.ReferenceCountUtil;\n import io.netty.util.concurrent.GlobalEventExecutor;\n import java.util.List;\n+import java.util.Set;\n public class PortUnificationServerHandler extends ByteToMessageDecoder {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(\n+        PortUnificationServerHandler.class);\n+\n     private final SslContext sslCtx;\n     private final URL url;\n     private final List<WireProtocol> protocols;\n-    private final DefaultChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    private final DefaultChannelGroup channels = new DefaultChannelGroup(\n+        GlobalEventExecutor.INSTANCE);\n     public PortUnificationServerHandler(URL url, List<WireProtocol> protocols) {\n-        this(url, null,protocols);\n+        this(url, null, protocols);\n     }\n     public PortUnificationServerHandler(URL url, SslContext sslCtx, List<WireProtocol> protocols) {\n@@ -46,7 +55,7 @@ public PortUnificationServerHandler(URL url, SslContext sslCtx, List<WireProtoco\n     @Override\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-        super.exceptionCaught(ctx, cause);\n+        LOGGER.error(\"Unexpected exception from downstream before protocol detected.\", cause);\n     }\n     public DefaultChannelGroup getChannels() {\n@@ -66,7 +75,8 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n     }\n     @Override\n-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)\n+        throws Exception {\n         // Will use the first five bytes to detect a protocol.\n         if (in.readableBytes() < 5) {\n             return;\n@@ -88,9 +98,18 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t\n                     return;\n             }\n         }\n+        byte[] preface = new byte[in.readableBytes()];\n+        in.readBytes(preface);\n+        Set<String> supported = url.getApplicationModel()\n+            .getExtensionLoader(WireProtocol.class)\n+            .getSupportedExtensions();\n+        LOGGER.error(String.format(\"Can not recognize protocol from downstream . \"\n+            + \"preface=%s protocols=%s\", Bytes.bytes2hex(preface), supported));\n+\n         // Unknown protocol; discard everything and close the connection.\n         in.clear();\n         ctx.close();\n+        ReferenceCountUtil.release(in);\n     }\n }",
    "output": "Add log when protocol unrecognize or error"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvoker.java\n@@ -100,7 +100,7 @@ public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, L\n         // load balance among all registries, with registry weight count in.\n         Invoker<T> balancedInvoker = select(loadbalance, invocation, invokers, null);\n-        if (balancedInvoker.isAvailable()) {\n+        if (balancedInvoker!=null && balancedInvoker.isAvailable()) {\n             return balancedInvoker.invoke(invocation);\n         }",
    "output": "Fix npe in zone aware invoker"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n@@ -181,13 +181,30 @@ private void invoke(Channel channel, String methodKey) {\n             Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);\n             if (invocation != null) {\n                 try {\n+                    if (Boolean.TRUE.toString().equals(invocation.getAttachment(STUB_EVENT_KEY))) {\n+                        tryToGetStubService(channel, invocation);\n+                    }\n                     received(channel, invocation);\n                 } catch (Throwable t) {\n                     logger.warn(\"Failed to invoke event method \" + invocation.getMethodName() + \"(), cause: \" + t.getMessage(), t);\n                 }\n             }\n         }\n+        private void tryToGetStubService(Channel channel, Invocation invocation) throws RemotingException {\n+            try {\n+                Invoker<?> invoker = getInvoker(channel, invocation);\n+            } catch (RemotingException e) {\n+                String serviceKey = serviceKey(\n+                    0,\n+                    (String) invocation.getObjectAttachments().get(PATH_KEY),\n+                    (String) invocation.getObjectAttachments().get(VERSION_KEY),\n+                    (String) invocation.getObjectAttachments().get(GROUP_KEY)\n+                );\n+                throw new RemotingException(channel, \"The stub service[\" + serviceKey + \"] is not found, it may not be exported yet\");\n+            }\n+        }\n+\n         /**\n          * FIXME channel.getUrl() always binds to a fixed service, and this service is random.\n          * we can choose to use a common service to carry onConnect event if there's no easy way to get the specific\n@@ -250,13 +267,14 @@ Invoker<?> getInvoker(Channel channel, Invocation inv) throws RemotingException\n         int port = channel.getLocalAddress().getPort();\n         String path = (String) inv.getObjectAttachments().get(PATH_KEY);\n-        // if it's callback service on client side\n+        //if it's stub service on client side(after enable stubevent, usually is set up onconnect or ondisconnect method)\n         isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getObjectAttachments().get(STUB_EVENT_KEY));\n         if (isStubServiceInvoke) {\n-            port = channel.getRemoteAddress().getPort();\n+            //when a stub service export to local, it usually can't be exposed to port\n+            port = 0;\n         }\n-        //callback\n+        // if it's callback service on client side\n         isCallBackServiceInvoke = isClientSide(channel) && !isStubServiceInvoke;\n         if (isCallBackServiceInvoke) {\n             path += \".\" + inv.getObjectAttachments().get(CALLBACK_SERVICE_KEY);",
    "output": "Fix the problem that the consumer stub event does not trigger related #9825"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n@@ -26,6 +26,8 @@ public interface Constants {\n     String WEIGHT_KEY = \"weight\";\n+    String REGISTRY_WEIGHT_KEY = \"registry.weight\";\n+\n     int DEFAULT_WEIGHT = 100;\n     String MOCK_PROTOCOL = \"mock\";\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n@@ -20,12 +20,12 @@\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.cluster.ClusterInvoker;\n import org.apache.dubbo.rpc.cluster.LoadBalance;\n import java.util.List;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n-import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_SERVICE_REFERENCE_PATH;\n import static org.apache.dubbo.rpc.cluster.Constants.DEFAULT_WARMUP;\n import static org.apache.dubbo.rpc.cluster.Constants.DEFAULT_WEIGHT;\n@@ -75,9 +75,13 @@ public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invo\n     protected int getWeight(Invoker<?> invoker, Invocation invocation) {\n         int weight;\n         URL url = invoker.getUrl();\n+        if (invoker instanceof ClusterInvoker) {\n+            url = ((ClusterInvoker<?>) invoker).getRegistryUrl();\n+        }\n+\n         // Multiple registry scenario, load balance among multiple registries.\n         if (REGISTRY_SERVICE_REFERENCE_PATH.equals(url.getServiceInterface())) {\n-            weight = url.getParameter(REGISTRY_KEY + \".\" + WEIGHT_KEY, DEFAULT_WEIGHT);\n+            weight = url.getParameter(WEIGHT_KEY, DEFAULT_WEIGHT);\n         } else {\n             weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);\n             if (weight > 0) {\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RandomLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RandomLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RandomLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RandomLoadBalance.java\n@@ -20,12 +20,12 @@\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.cluster.ClusterInvoker;\n import java.util.List;\n import java.util.concurrent.ThreadLocalRandom;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n-import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_SERVICE_REFERENCE_PATH;\n import static org.apache.dubbo.rpc.cluster.Constants.WEIGHT_KEY;\n@@ -92,9 +92,13 @@ private <T> boolean needWeightLoadBalance(List<Invoker<T>> invokers, Invocation\n         Invoker invoker = invokers.get(0);\n         URL invokerUrl = invoker.getUrl();\n+        if (invoker instanceof ClusterInvoker) {\n+            invokerUrl = ((ClusterInvoker<?>) invoker).getRegistryUrl();\n+        }\n+\n         // Multiple registry scenario, load balance among multiple registries.\n         if (REGISTRY_SERVICE_REFERENCE_PATH.equals(invokerUrl.getServiceInterface())) {\n-            String weight = invokerUrl.getParameter(REGISTRY_KEY + \".\" + WEIGHT_KEY);\n+            String weight = invokerUrl.getParameter(WEIGHT_KEY);\n             if (StringUtils.isNotEmpty(weight)) {\n                 return true;\n             }\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalanceTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalanceTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalanceTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalanceTest.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.RpcInvocation;\n+import org.apache.dubbo.rpc.cluster.ClusterInvoker;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n@@ -30,7 +31,6 @@\n import java.util.List;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n-import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_KEY;\n import static org.apache.dubbo.rpc.cluster.Constants.WEIGHT_KEY;\n import static org.mockito.BDDMockito.given;\n import static org.mockito.Mockito.mock;\n@@ -69,15 +69,17 @@ public void testGetRegistryWeight() {\n         Invoker invoker1 = mock(Invoker.class, Mockito.withSettings().stubOnly());\n         URL url1 = new ServiceConfigURL(\"\", \"\", 0, \"DemoService\", new HashMap<>());\n-        url1 = url1.addParameter(REGISTRY_KEY + \".\" + WEIGHT_KEY, 10);\n         given(invoker1.getUrl()).willReturn(url1);\n-        Invoker invoker2 = mock(Invoker.class, Mockito.withSettings().stubOnly());\n+        ClusterInvoker invoker2 = mock(ClusterInvoker.class, Mockito.withSettings().stubOnly());\n         URL url2 = new ServiceConfigURL(\"\", \"\", 0, \"org.apache.dubbo.registry.RegistryService\", new HashMap<>());\n-        url2 = url2.addParameter(REGISTRY_KEY + \".\" + WEIGHT_KEY, 20);\n+        url2 = url2.addParameter(WEIGHT_KEY, 20);\n+        URL registryUrl2 = new ServiceConfigURL(\"\", \"\", 0, \"org.apache.dubbo.registry.RegistryService\", new HashMap<>());\n+        registryUrl2 = registryUrl2.addParameter(WEIGHT_KEY, 30);\n         given(invoker2.getUrl()).willReturn(url2);\n+        given(invoker2.getRegistryUrl()).willReturn(registryUrl2);\n         Assertions.assertEquals(100, balance.getWeight(invoker1, invocation));\n-        Assertions.assertEquals(20, balance.getWeight(invoker2, invocation));\n+        Assertions.assertEquals(30, balance.getWeight(invoker2, invocation));\n     }\n }",
    "output": "Fix weight cannot work properly on multi-registry scenario"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n@@ -240,24 +240,28 @@ protected void onDestroy() {\n         // 2. pre-destroy, set stopping\n         if (deployer != null) {\n+            // destroy registries and unregister services from registries first to notify consumers to stop consuming this instance.\n             deployer.preDestroy();\n         }\n-        // destroy application resources\n+        // 3. Try to destroy protocols to stop this instance from receiving new requests from connections\n+        frameworkModel.tryDestroyProtocols();\n+\n+        // 4. destroy application resources\n         for (ModuleModel moduleModel : new ArrayList<>(moduleModels)) {\n             if (moduleModel != internalModule) {\n                 moduleModel.destroy();\n             }\n         }\n-        // destroy internal module later\n+        // 5. destroy internal module later\n         internalModule.destroy();\n-        // post-destroy, release registry resources\n+        // 6. post-destroy, release registry resources\n         if (deployer != null) {\n             deployer.postDestroy();\n         }\n-        // destroy other resources (e.g. ZookeeperTransporter )\n+        // 7. destroy other resources (e.g. ZookeeperTransporter )\n         notifyDestroy();\n         if (environment != null) {\n@@ -273,7 +277,7 @@ protected void onDestroy() {\n             serviceRepository = null;\n         }\n-        // destroy framework if none application\n+        // 8. destroy framework if none application\n         frameworkModel.tryDestroy();\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n@@ -251,6 +251,19 @@ void removeApplication(ApplicationModel model) {\n         }\n     }\n+    /**\n+     * Protocols are special resources that need to be destroyed as soon as possible.\n+     *\n+     * Since connections inside protocol are not classified by applications, trying to destroy protocols in advance might only work for singleton application scenario.\n+     */\n+    void tryDestroyProtocols() {\n+        synchronized (instLock) {\n+            if (pubApplicationModels.size() == 0) {\n+                notifyProtocolDestroy();\n+            }\n+        }\n+    }\n+\n     void tryDestroy() {\n         synchronized (instLock) {\n             if (pubApplicationModels.size() == 0) {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java\n@@ -134,6 +134,14 @@ protected void notifyDestroy() {\n         }\n     }\n+    protected void notifyProtocolDestroy() {\n+        for (ScopeModelDestroyListener destroyListener : destroyListeners) {\n+            if (destroyListener.isProtocol()) {\n+                destroyListener.onDestroy(this);\n+            }\n+        }\n+    }\n+\n     protected abstract void onDestroy();\n     public final void addDestroyListener(ScopeModelDestroyListener listener) {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModelDestroyListener.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModelDestroyListener.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModelDestroyListener.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModelDestroyListener.java\n@@ -18,4 +18,8 @@\n public interface ScopeModelDestroyListener<T extends ScopeModel> {\n     void onDestroy(T scopeModel);\n+\n+    default boolean isProtocol() {\n+        return false;\n+    }\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -754,6 +754,10 @@ public void preDestroy() {\n             }\n             onStopping();\n+            destroyRegistries();\n+            destroyServiceDiscoveries();\n+            destroyMetadataReports();\n+\n             unRegisterShutdownHook();\n             if (asyncMetadataFuture != null) {\n                 asyncMetadataFuture.cancel(true);\n@@ -772,10 +776,6 @@ public void postDestroy() {\n             try {\n                 executeShutdownCallbacks();\n-                destroyRegistries();\n-                destroyServiceDiscoveries();\n-                destroyMetadataReports();\n-\n                 // TODO should we close unused protocol server which only used by this application?\n                 // protocol server will be closed on all applications of same framework are stopped currently, but no associate to application\n                 // see org.apache.dubbo.config.deploy.FrameworkModelCleaner#destroyProtocols\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/FrameworkModelCleaner.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/FrameworkModelCleaner.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/FrameworkModelCleaner.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/FrameworkModelCleaner.java\n@@ -23,13 +23,22 @@\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ScopeModelDestroyListener;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n /**\n  * A cleaner to release resources of framework model\n  */\n public class FrameworkModelCleaner implements ScopeModelDestroyListener<FrameworkModel> {\n     private static final Logger logger = LoggerFactory.getLogger(FrameworkModelCleaner.class);\n+    private final AtomicBoolean protocolDestroyed = new AtomicBoolean(false);\n+\n+    @Override\n+    public boolean isProtocol() {\n+        return true;\n+    }\n+\n     @Override\n     public void onDestroy(FrameworkModel frameworkModel) {\n         destroyFrameworkResources(frameworkModel);\n@@ -47,18 +56,19 @@ private void destroyFrameworkResources(FrameworkModel frameworkModel) {\n      * Destroy all the protocols.\n      */\n     private void destroyProtocols(FrameworkModel frameworkModel) {\n-        ExtensionLoader<Protocol> loader = frameworkModel.getExtensionLoader(Protocol.class);\n-        for (String protocolName : loader.getLoadedExtensions()) {\n-            try {\n-                Protocol protocol = loader.getLoadedExtension(protocolName);\n-                if (protocol != null) {\n-                    protocol.destroy();\n+        if (protocolDestroyed.compareAndSet(false, true)) {\n+            ExtensionLoader<Protocol> loader = frameworkModel.getExtensionLoader(Protocol.class);\n+            for (String protocolName : loader.getLoadedExtensions()) {\n+                try {\n+                    Protocol protocol = loader.getLoadedExtension(protocolName);\n+                    if (protocol != null) {\n+                        protocol.destroy();\n+                    }\n+                } catch (Throwable t) {\n+                    logger.warn(t.getMessage(), t);\n                 }\n-            } catch (Throwable t) {\n-                logger.warn(t.getMessage(), t);\n             }\n         }\n     }\n-\n }",
    "output": "Fix shutdown process, destroy registry and protocol server first before destroying other resources"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n--- a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n+++ b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n@@ -138,7 +138,7 @@ protected void doAddListener(String pathKey, ConfigurationListener listener) {\n     protected void doRemoveListener(String pathKey, ConfigurationListener listener) {\n         cacheListener.removeListener(pathKey, listener);\n         Set<ConfigurationListener> configurationListeners = cacheListener.getConfigurationListeners(pathKey);\n-        if (CollectionUtils.isNotEmpty(configurationListeners)) {\n+        if (CollectionUtils.isEmpty(configurationListeners)) {\n             zkClient.removeDataListener(pathKey, cacheListener);\n         }\n     }",
    "output": "Fix the logic of ZookeeperDynamicConfiguration#doRemoveListener method"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/util/ServiceCheckUtils.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/util/ServiceCheckUtils.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/util/ServiceCheckUtils.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/util/ServiceCheckUtils.java\n@@ -47,11 +47,16 @@ public static int getConsumerAddressNum(ConsumerModel consumerModel) {\n         Collection<Registry> registries = registryManager.getRegistries();\n         if (CollectionUtils.isNotEmpty(registries)) {\n-            AbstractRegistry abstractRegistry = (AbstractRegistry) registries.iterator().next();\n-            for (Map.Entry<URL, Map<String, List<URL>>> entry : abstractRegistry.getNotified().entrySet()) {\n-                if (entry.getKey().getServiceKey().equals(consumerModel.getServiceKey())) {\n-                    if (CollectionUtils.isNotEmptyMap(entry.getValue())) {\n-                        num = entry.getValue().size();\n+            for (Registry registry : registries) {\n+                if (!(registry instanceof AbstractRegistry)) {\n+                    continue;\n+                }\n+                AbstractRegistry abstractRegistry = (AbstractRegistry) registry;\n+                for (Map.Entry<URL, Map<String, List<URL>>> entry : abstractRegistry.getNotified().entrySet()) {\n+                    if (entry.getKey().getServiceKey().equals(consumerModel.getServiceKey())) {\n+                        if (CollectionUtils.isNotEmptyMap(entry.getValue())) {\n+                            num = entry.getValue().size();\n+                        }\n                     }\n                 }\n             }\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/ServiceCheckUtilsTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/ServiceCheckUtilsTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/ServiceCheckUtilsTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/ServiceCheckUtilsTest.java\n@@ -17,19 +17,32 @@\n package org.apache.dubbo.qos.command.util;\n+import com.google.common.collect.Lists;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.beans.factory.ScopeBeanFactory;\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.qos.DemoService;\n import org.apache.dubbo.qos.DemoServiceImpl;\n+import org.apache.dubbo.registry.Registry;\n+import org.apache.dubbo.registry.client.ServiceDiscoveryRegistry;\n+import org.apache.dubbo.registry.support.RegistryManager;\n+\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.ConsumerModel;\n+import org.apache.dubbo.rpc.model.ModuleModel;\n import org.apache.dubbo.rpc.model.ModuleServiceRepository;\n import org.apache.dubbo.rpc.model.ProviderModel;\n import org.apache.dubbo.rpc.model.ServiceDescriptor;\n import org.apache.dubbo.rpc.model.ServiceMetadata;\n import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.util.Collection;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.mockito.Mockito.when;\n /**\n  * Test for ServiceCheckUtils\n@@ -60,4 +73,30 @@ public void testIsRegistered() {\n         assertFalse(registered);\n     }\n+    private static final ConsumerModel consumerModel;\n+\n+    static {\n+        consumerModel = Mockito.mock(ConsumerModel.class);\n+        ServiceDiscoveryRegistry serviceDiscoveryRegistry = Mockito.mock(ServiceDiscoveryRegistry.class);\n+        Collection<Registry> registries = Lists.newArrayList(serviceDiscoveryRegistry);\n+\n+        ModuleModel moduleModel = Mockito.mock(ModuleModel.class);\n+        ApplicationModel applicationModel = Mockito.mock(ApplicationModel.class);\n+        ScopeBeanFactory scopeBeanFactory = Mockito.mock(ScopeBeanFactory.class);\n+        RegistryManager registryManager = Mockito.mock(RegistryManager.class);\n+        when(applicationModel.getBeanFactory()).thenReturn(scopeBeanFactory);\n+        when(scopeBeanFactory.getBean(RegistryManager.class)).thenReturn(registryManager);\n+        when(moduleModel.getApplicationModel()).thenReturn(applicationModel);\n+        when(consumerModel.getModuleModel()).thenReturn(moduleModel);\n+\n+        when(registryManager.getRegistries()).thenReturn(registries);\n+    }\n+\n+    @Test\n+    public void testGetConsumerAddressNum() {\n+        int consumerAddressNum = ServiceCheckUtils.getConsumerAddressNum(consumerModel);\n+        assertEquals(0, consumerAddressNum);\n+    }\n+\n+\n }",
    "output": "Fix LS telnet command, check registry type before class casting"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n@@ -240,9 +240,7 @@ public void setInterface(Class<?> interfaceClass) {\n         }\n         setInterface(interfaceClass == null ? null : interfaceClass.getName());\n         this.interfaceClass = interfaceClass;\n-        if (getInterfaceClassLoader() == null) {\n-            setInterfaceClassLoader(interfaceClass == null ? null : interfaceClass.getClassLoader());\n-        }\n+        setInterfaceClassLoader(interfaceClass == null ? null : interfaceClass.getClassLoader());\n     }\n     public String getClient() {\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java\n@@ -141,7 +141,7 @@ private CompletableFuture<Object> wrapWithFuture(Object value, Invocation invoca\n             return (CompletableFuture<Object>) value;\n         } else if (RpcContext.getServerAttachment().isAsyncStarted()) {\n             invocation.put(PROVIDER_ASYNC_KEY, Boolean.TRUE);\n-            return ((AsyncContextImpl) (RpcContext.getServiceContext().getAsyncContext())).getInternalFuture();\n+            return ((AsyncContextImpl) (RpcContext.getServerAttachment().getAsyncContext())).getInternalFuture();\n         }\n         return CompletableFuture.completedFuture(value);\n     }",
    "output": "Fix use server attachment"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/DubboAnnotationUtils.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/DubboAnnotationUtils.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/DubboAnnotationUtils.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/DubboAnnotationUtils.java\n@@ -27,6 +27,7 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n@@ -154,7 +155,7 @@ public static String resolveInterfaceName(Reference reference, Class<?> defaultI\n      */\n     public static Map<String, String> convertParameters(String[] parameters) {\n         if (ArrayUtils.isEmpty(parameters)) {\n-            return null;\n+            return Collections.emptyMap();\n         }\n         List<String> compatibleParameterArray = Arrays.stream(parameters)",
    "output": "Fix the problem that NPE may appear in ReferenceBeanSupport#convertToString method"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -85,6 +85,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.REGISTRY_PROTOCOL_LISTENER_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.RELEASE_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n import static org.apache.dubbo.common.constants.FilterConstants.VALIDATION_KEY;\n@@ -135,7 +136,7 @@ public class RegistryProtocol implements Protocol, ScopeModelAware {\n     public static final String[] DEFAULT_REGISTER_PROVIDER_KEYS = {\n         APPLICATION_KEY, CODEC_KEY, EXCHANGER_KEY, SERIALIZATION_KEY, CLUSTER_KEY, CONNECTIONS_KEY, DEPRECATED_KEY,\n         GROUP_KEY, LOADBALANCE_KEY, MOCK_KEY, PATH_KEY, TIMEOUT_KEY, TOKEN_KEY, VERSION_KEY, WARMUP_KEY,\n-        WEIGHT_KEY, DUBBO_VERSION_KEY, RELEASE_KEY\n+        WEIGHT_KEY, DUBBO_VERSION_KEY, RELEASE_KEY, SIDE_KEY\n     };\n     public static final String[] DEFAULT_REGISTER_CONSUMER_KEYS = {",
    "output": "Fix the issue that providerUrl could not be registered in the application-level registry when simplified is set to true"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n@@ -107,6 +107,8 @@ public static void restoreCancellationContext(CancellationContext oldContext) {\n         CANCELLATION_CONTEXT.set(oldContext);\n     }\n+    private boolean remove = true;\n+\n     protected RpcContext() {\n     }\n@@ -156,6 +158,14 @@ public static RpcContextAttachment getServerAttachment() {\n         return SERVER_ATTACHMENT.get();\n     }\n+    public boolean canRemove() {\n+        return remove;\n+    }\n+\n+    public void clearAfterEachInvoke(boolean remove) {\n+        this.remove = remove;\n+    }\n+\n     /**\n      * Using to pass environment parameters in the whole invocation. For example, `remotingApplicationName`,\n      * `remoteAddress`, etc. {@link RpcServiceContext}\n@@ -171,19 +181,27 @@ public static void removeServiceContext() {\n     }\n     public static void removeClientAttachment() {\n-        CLIENT_ATTACHMENT.remove();\n+        if (CLIENT_ATTACHMENT.get().canRemove()) {\n+            CLIENT_ATTACHMENT.remove();\n+        }\n     }\n     public static void removeServerAttachment() {\n-        SERVER_ATTACHMENT.remove();\n+        if (SERVER_ATTACHMENT.get().canRemove()) {\n+            SERVER_ATTACHMENT.remove();\n+        }\n     }\n     /**\n      * customized for internal use.\n      */\n     public static void removeContext() {\n-        CLIENT_ATTACHMENT.remove();\n-        SERVER_ATTACHMENT.remove();\n+        if (CLIENT_ATTACHMENT.get().canRemove()) {\n+            CLIENT_ATTACHMENT.remove();\n+        }\n+        if (SERVER_ATTACHMENT.get().canRemove()) {\n+            SERVER_ATTACHMENT.remove();\n+        }\n         SERVER_LOCAL.remove();\n         SERVICE_CONTEXT.remove();\n         CANCELLATION_CONTEXT.remove();\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n@@ -126,7 +126,12 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept\n             ((RpcInvocation) invocation).setInvoker(invoker);\n         }\n-        return invoker.invoke(invocation);\n+        try {\n+            context.clearAfterEachInvoke(false);\n+            return invoker.invoke(invocation);\n+        } finally {\n+            context.clearAfterEachInvoke(true);\n+        }\n     }\n     @Override",
    "output": "Fix check before remove on embedded rpc call"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java\n@@ -116,7 +116,7 @@ private String exportOrUnexportCallbackService(Channel channel, RpcInvocation in\n         params.put(IS_SERVER_KEY, Boolean.FALSE.toString());\n         // mark it's a callback, for troubleshooting\n         params.put(IS_CALLBACK_SERVICE, Boolean.TRUE.toString());\n-        String group = (url == null ? null : url.getGroup());\n+        String group = (inv == null ? null : (String) inv.getObjectAttachment(GROUP_KEY));\n         if (group != null && group.length() > 0) {\n             params.put(GROUP_KEY, group);\n         }\n@@ -266,7 +266,7 @@ private static boolean isInstancesOverLimit(Channel channel, URL url, String int\n         if (count != null && count >= limit) {\n             //client side error\n             throw new IllegalStateException(\"interface \" + interfaceClass + \" `s callback instances num exceed providers limit :\" + limit\n-                    + \" ,current num: \" + (count + 1) + \". The new callback service will not work !!! you can cancle the callback service which exported before. channel :\" + channel);\n+                + \" ,current num: \" + (count + 1) + \". The new callback service will not work !!! you can cancle the callback service which exported before. channel :\" + channel);\n         } else {\n             return false;\n         }\n@@ -309,10 +309,10 @@ public Object encodeInvocationArgument(Channel channel, RpcInvocation inv, int p\n         Class<?>[] pts = inv.getParameterTypes();\n         switch (callbackStatus) {\n             case CallbackServiceCodec.CALLBACK_CREATE:\n-                inv.setAttachment(INV_ATT_CALLBACK_KEY + paraIndex, exportOrUnexportCallbackService(channel, inv,  url, pts[paraIndex], args[paraIndex], true));\n+                inv.setAttachment(INV_ATT_CALLBACK_KEY + paraIndex, exportOrUnexportCallbackService(channel, inv, url, pts[paraIndex], args[paraIndex], true));\n                 return null;\n             case CallbackServiceCodec.CALLBACK_DESTROY:\n-                inv.setAttachment(INV_ATT_CALLBACK_KEY + paraIndex, exportOrUnexportCallbackService(channel, inv,  url, pts[paraIndex], args[paraIndex], false));\n+                inv.setAttachment(INV_ATT_CALLBACK_KEY + paraIndex, exportOrUnexportCallbackService(channel, inv, url, pts[paraIndex], args[paraIndex], false));\n                 return null;\n             default:\n                 return args[paraIndex];",
    "output": "Fix the callback fails when the service is grouped"
  },
  {
    "input": "diff --git a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/AwaitingNonWebApplicationListener.java b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/AwaitingNonWebApplicationListener.java\n--- a/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/AwaitingNonWebApplicationListener.java\n+++ b/dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/main/java/org/apache/dubbo/spring/boot/context/event/AwaitingNonWebApplicationListener.java\n@@ -22,6 +22,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.springframework.boot.context.event.ApplicationFailedEvent;\n import org.springframework.boot.context.event.ApplicationReadyEvent;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationEvent;\n@@ -49,14 +50,14 @@\n public class AwaitingNonWebApplicationListener implements SmartApplicationListener {\n     private static final String[] WEB_APPLICATION_CONTEXT_CLASSES = new String[]{\n-            \"org.springframework.web.context.WebApplicationContext\",\n-            \"org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext\"\n+        \"org.springframework.web.context.WebApplicationContext\",\n+        \"org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext\"\n     };\n     private static final Logger logger = LoggerFactory.getLogger(AwaitingNonWebApplicationListener.class);\n     private static final Class<? extends ApplicationEvent>[] SUPPORTED_APPLICATION_EVENTS =\n-            of(ApplicationReadyEvent.class, ContextClosedEvent.class);\n+        of(ApplicationReadyEvent.class, ContextClosedEvent.class);\n     private final AtomicBoolean awaited = new AtomicBoolean(false);\n@@ -96,6 +97,10 @@ public void onApplicationEvent(ApplicationEvent event) {\n         if (event instanceof ApplicationReadyEvent) {\n             onApplicationReadyEvent((ApplicationReadyEvent) event);\n         }\n+\n+        if (event instanceof ApplicationFailedEvent) {\n+            awaitAndRelease(((ApplicationFailedEvent) event).getApplicationContext());\n+        }\n     }\n     @Override\n@@ -112,14 +117,18 @@ protected void onApplicationReadyEvent(ApplicationReadyEvent event) {\n         }\n         if (applicationContextId.compareAndSet(UNDEFINED_ID, applicationContext.hashCode())) {\n-            await();\n-            releaseOnExit(event.getApplicationContext());\n+            awaitAndRelease(event.getApplicationContext());\n         }\n     }\n+    private void awaitAndRelease(ConfigurableApplicationContext applicationContext) {\n+        await();\n+        releaseOnExit(applicationContext);\n+    }\n+\n     /**\n-     * @since 2.7.8\n      * @param applicationContext\n+     * @since 2.7.8\n      */\n     private void releaseOnExit(ConfigurableApplicationContext applicationContext) {\n         ApplicationModel applicationModel = DubboBeanUtils.getApplicationModel(applicationContext);",
    "output": "Fix the application startup failed but did not release resources"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalMap.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalMap.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalMap.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalMap.java\n@@ -32,7 +32,12 @@ public final class InternalThreadLocalMap {\n     private static final AtomicInteger NEXT_INDEX = new AtomicInteger();\n-    public static final Object UNSET = new Object();\n+    static final Object UNSET = new Object();\n+\n+    // Reference: https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/ArrayList.java#l229\n+    private static final int ARRAY_LIST_CAPACITY_MAX_SIZE = Integer.MAX_VALUE - 8;\n+\n+    private static final int ARRAY_LIST_CAPACITY_EXPAND_THRESHOLD = 1 << 30;\n     public static InternalThreadLocalMap getIfSet() {\n         Thread thread = Thread.currentThread();\n@@ -65,8 +70,8 @@ public static void destroy() {\n     public static int nextVariableIndex() {\n         int index = NEXT_INDEX.getAndIncrement();\n-        if (index < 0) {\n-            NEXT_INDEX.decrementAndGet();\n+        if (index >= ARRAY_LIST_CAPACITY_MAX_SIZE || index < 0) {\n+            NEXT_INDEX.set(ARRAY_LIST_CAPACITY_MAX_SIZE);\n             throw new IllegalStateException(\"Too many thread-local indexed variables\");\n         }\n         return index;\n@@ -133,13 +138,19 @@ private static Object[] newIndexedVariableTable() {\n     }\n     private static int newCapacity(int index) {\n-        int newCapacity = index;\n-        newCapacity |= newCapacity >>> 1;\n-        newCapacity |= newCapacity >>> 2;\n-        newCapacity |= newCapacity >>> 4;\n-        newCapacity |= newCapacity >>> 8;\n-        newCapacity |= newCapacity >>> 16;\n-        return ++newCapacity;\n+        int newCapacity;\n+        if (index < ARRAY_LIST_CAPACITY_EXPAND_THRESHOLD) {\n+            newCapacity = index;\n+            newCapacity |= newCapacity >>>  1;\n+            newCapacity |= newCapacity >>>  2;\n+            newCapacity |= newCapacity >>>  4;\n+            newCapacity |= newCapacity >>>  8;\n+            newCapacity |= newCapacity >>> 16;\n+            newCapacity ++;\n+        } else {\n+            newCapacity = ARRAY_LIST_CAPACITY_MAX_SIZE;\n+        }\n+        return newCapacity;\n     }\n     private static InternalThreadLocalMap fastGet(InternalThread thread) {\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n@@ -21,11 +21,19 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import java.lang.reflect.Field;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n import java.util.concurrent.locks.LockSupport;\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n public class InternalThreadLocalTest {\n     private static final int THREADS = 10;\n@@ -221,4 +229,54 @@ public void run() {\n         t.start();\n         LockSupport.park(mainThread);\n     }\n+\n+    @Test\n+    public void testConstructionWithIndex() throws Exception {\n+        int ARRAY_LIST_CAPACITY_MAX_SIZE = Integer.MAX_VALUE - 8;\n+        Field nextIndexField =\n+            InternalThreadLocalMap.class.getDeclaredField(\"NEXT_INDEX\");\n+        nextIndexField.setAccessible(true);\n+        AtomicInteger nextIndex = (AtomicInteger) nextIndexField.get(AtomicInteger.class);\n+        int nextIndex_before = nextIndex.get();\n+        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();\n+        try {\n+            while (nextIndex.get() < ARRAY_LIST_CAPACITY_MAX_SIZE) {\n+                new InternalThreadLocal<Boolean>();\n+            }\n+            assertEquals(ARRAY_LIST_CAPACITY_MAX_SIZE - 1, InternalThreadLocalMap.lastVariableIndex());\n+            try {\n+                new InternalThreadLocal<Boolean>();\n+            } catch (Throwable t) {\n+                throwable.set(t);\n+            }\n+            // Assert the max index cannot greater than (ARRAY_LIST_CAPACITY_MAX_SIZE - 1)\n+            assertThat(throwable.get(), is(instanceOf(IllegalStateException.class)));\n+            // Assert the index was reset to ARRAY_LIST_CAPACITY_MAX_SIZE after it reaches ARRAY_LIST_CAPACITY_MAX_SIZE\n+            assertEquals(ARRAY_LIST_CAPACITY_MAX_SIZE - 1, InternalThreadLocalMap.lastVariableIndex());\n+        } finally {\n+            // Restore the index\n+            nextIndex.set(nextIndex_before);\n+        }\n+    }\n+\n+    @Test\n+    public void testInternalThreadLocalMapExpand() throws Exception {\n+        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();\n+        Runnable runnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                int expand_threshold = 1 << 30;\n+                try {\n+                    InternalThreadLocalMap.get().setIndexedVariable(expand_threshold, null);\n+                } catch (Throwable t) {\n+                    throwable.set(t);\n+                }\n+            }\n+        };\n+        InternalThread internalThread = new InternalThread(runnable);\n+        internalThread.start();\n+        internalThread.join();\n+        // Assert the expanded size is not overflowed to negative value\n+        assertThat(throwable.get(), is(not(instanceOf(NegativeArraySizeException.class))));\n+    }\n }",
    "output": "Fix InternalThreadLocalMap capacity expands overflow; Change access level of field InternalThreadLocalMap.UNSET to package private"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvoker.java\n@@ -54,6 +54,9 @@ public class FailbackClusterInvoker<T> extends AbstractClusterInvoker<T> {\n     private static final long RETRY_FAILED_PERIOD = 5;\n+    /**\n+     * Number of retries obtained from the configuration, don't contain the first invoke.\n+     */\n     private final int retries;\n     private final int failbackTasks;\n@@ -64,7 +67,7 @@ public FailbackClusterInvoker(Directory<T> directory) {\n         super(directory);\n         int retriesConfig = getUrl().getParameter(RETRIES_KEY, DEFAULT_FAILBACK_TIMES);\n-        if (retriesConfig <= 0) {\n+        if (retriesConfig < 0) {\n             retriesConfig = DEFAULT_FAILBACK_TIMES;\n         }\n         int failbackTasksConfig = getUrl().getParameter(FAIL_BACK_TASKS_KEY, DEFAULT_FAILBACK_TASKS);\n@@ -129,12 +132,20 @@ private class RetryTimerTask implements TimerTask {\n         private final Invocation invocation;\n         private final LoadBalance loadbalance;\n         private final List<Invoker<T>> invokers;\n-        private final int retries;\n         private final long tick;\n         private Invoker<T> lastInvoker;\n-        private int retryTimes = 0;\n         private URL consumerUrl;\n+        /**\n+         * Number of retries obtained from the configuration, don't contain the first invoke.\n+         */\n+        private final int retries;\n+\n+        /**\n+         * Number of retried.\n+         */\n+        private int retriedTimes = 0;\n+\n         RetryTimerTask(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, Invoker<T> lastInvoker,\n                        int retries, long tick, URL consumerUrl) {\n             this.loadbalance = loadbalance;\n@@ -149,12 +160,14 @@ private class RetryTimerTask implements TimerTask {\n         @Override\n         public void run(Timeout timeout) {\n             try {\n+                logger.info(\"Attempt to retry to invoke method \" + invocation.getMethodName() +\n+                        \". The total will retry \" + retries + \" times, the current is the \" + retriedTimes + \" retry\");\n                 Invoker<T> retryInvoker = select(loadbalance, invocation, invokers, Collections.singletonList(lastInvoker));\n                 lastInvoker = retryInvoker;\n                 invokeWithContextAsync(retryInvoker, invocation, consumerUrl);\n             } catch (Throwable e) {\n                 logger.error(\"Failed retry to invoke method \" + invocation.getMethodName() + \", waiting again.\", e);\n-                if ((++retryTimes) >= retries) {\n+                if ((++retriedTimes) >= retries) {\n                     logger.error(\"Failed retry times exceed threshold (\" + retries + \"), We have to abandon, invocation->\" + invocation);\n                 } else {\n                     rePut(timeout);\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvokerTest.java\n@@ -18,6 +18,7 @@\n package org.apache.dubbo.rpc.cluster.support;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.utils.DubboAppender;\n import org.apache.dubbo.common.utils.LogUtil;\n import org.apache.dubbo.rpc.AppResponse;\n@@ -37,11 +38,13 @@\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.TestMethodOrder;\n+import java.lang.reflect.Field;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n+import static org.apache.dubbo.common.constants.CommonConstants.RETRIES_KEY;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.mockito.BDDMockito.given;\n import static org.mockito.Mockito.mock;\n@@ -196,4 +199,98 @@ public void testARetryFailed() throws Exception {\n         Assertions.assertEquals(1, LogUtil.findMessage(Level.ERROR, \"Failback background works error\"), \"must have one error message \");\n         // it can be invoke successfully\n     }\n+\n+\n+\n+    private long getRetryFailedPeriod() throws NoSuchFieldException, IllegalAccessException {\n+        Field retryFailedPeriod = FailbackClusterInvoker.class.getDeclaredField(\"RETRY_FAILED_PERIOD\");\n+        retryFailedPeriod.setAccessible(true);\n+        return retryFailedPeriod.getLong(FailbackClusterInvoker.class);\n+    }\n+\n+    @Test\n+    @Order(5)\n+    public void testInvokeRetryTimesWithZeroValue() throws InterruptedException, NoSuchFieldException,\n+            IllegalAccessException {\n+        int retries = 0;\n+        resetInvokerToException();\n+        given(dic.getConsumerUrl()).willReturn(url.addParameter(RETRIES_KEY, retries));\n+\n+        FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);\n+        LogUtil.start();\n+        DubboAppender.clear();\n+\n+        invocation.setMethodName(\"testInvokeRetryTimesWithZeroValue\");\n+        invoker.invoke(invocation);\n+\n+        CountDownLatch countDown = new CountDownLatch(1);\n+        countDown.await(getRetryFailedPeriod() * (retries + 1), TimeUnit.SECONDS);\n+        LogUtil.stop();\n+        Assertions.assertEquals(0, LogUtil.findMessage(Level.INFO, \"Attempt to retry to invoke method \" +\n+                \"testInvokeRetryTimesWithZeroValue\"), \"No retry messages allowed\");\n+    }\n+\n+    @Test\n+    @Order(6)\n+    public void testInvokeRetryTimesWithTwoValue() throws InterruptedException, NoSuchFieldException,\n+            IllegalAccessException {\n+        int retries = 2;\n+        resetInvokerToException();\n+        given(dic.getConsumerUrl()).willReturn(url.addParameter(RETRIES_KEY, retries));\n+\n+        FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);\n+        LogUtil.start();\n+        DubboAppender.clear();\n+\n+        invocation.setMethodName(\"testInvokeRetryTimesWithTwoValue\");\n+        invoker.invoke(invocation);\n+\n+        CountDownLatch countDown = new CountDownLatch(1);\n+        countDown.await(getRetryFailedPeriod() * (retries + 1), TimeUnit.SECONDS);\n+        LogUtil.stop();\n+        Assertions.assertEquals(2, LogUtil.findMessage(Level.INFO, \"Attempt to retry to invoke method \" +\n+                \"testInvokeRetryTimesWithTwoValue\"), \"Must have two error message \");\n+    }\n+\n+    @Test\n+    @Order(7)\n+    public void testInvokeRetryTimesWithDefaultValue() throws InterruptedException, NoSuchFieldException,\n+            IllegalAccessException {\n+        resetInvokerToException();\n+        given(dic.getConsumerUrl()).willReturn(URL.valueOf(\"test://test:11/test\"));\n+\n+        FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);\n+        LogUtil.start();\n+        DubboAppender.clear();\n+\n+        invocation.setMethodName(\"testInvokeRetryTimesWithDefaultValue\");\n+        invoker.invoke(invocation);\n+\n+        CountDownLatch countDown = new CountDownLatch(1);\n+        countDown.await(getRetryFailedPeriod() * (CommonConstants.DEFAULT_FAILBACK_TIMES + 1), TimeUnit.SECONDS);\n+        LogUtil.stop();\n+        Assertions.assertEquals(3, LogUtil.findMessage(Level.INFO, \"Attempt to retry to invoke method \" +\n+                \"testInvokeRetryTimesWithDefaultValue\"), \"Must have three error message \");\n+    }\n+\n+    @Test\n+    @Order(8)\n+    public void testInvokeRetryTimesWithIllegalValue() throws InterruptedException, NoSuchFieldException,\n+            IllegalAccessException {\n+        resetInvokerToException();\n+        given(dic.getConsumerUrl()).willReturn(url.addParameter(RETRIES_KEY, -100));\n+\n+        FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);\n+        LogUtil.start();\n+        DubboAppender.clear();\n+\n+        invocation.setMethodName(\"testInvokeRetryTimesWithIllegalValue\");\n+        invoker.invoke(invocation);\n+\n+        CountDownLatch countDown = new CountDownLatch(1);\n+        countDown.await(getRetryFailedPeriod() * (CommonConstants.DEFAULT_FAILBACK_TIMES + 1), TimeUnit.SECONDS);\n+        LogUtil.stop();\n+        Assertions.assertEquals(3, LogUtil.findMessage(Level.INFO, \"Attempt to retry to invoke method \" +\n+                \"testInvokeRetryTimesWithIllegalValue\"), \"Must have three error message \");\n+    }\n }",
    "output": "Fix the problem of wrong number of retries in failback mode * fix: Fix the problem of wrong number of retries in failback mode When the retries value is zero, the logic in failback mode resets it to the default value of 3, making it impossible to turn off the retry mechanism. * refactor: Remove FailbackClusterInvoker unused field"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n@@ -91,7 +91,7 @@ public MetadataInfo(String app, String revision, Map<String, ServiceInfo> servic\n     }\n     private MetadataInfo(String app, String revision, Map<String, ServiceInfo> services, AtomicBoolean initiated,\n-                        Map<String, String> extendParams, Map<String, String> instanceParams, AtomicBoolean updated,\n+                        Map<String, String> extendParams, Map<String, String> instanceParams, boolean updated,\n                         ConcurrentNavigableMap<String, SortedSet<URL>> subscribedServiceURLs,\n                         ConcurrentNavigableMap<String, SortedSet<URL>> exportedServiceURLs,\n                         ExtensionLoader<MetadataParamsFilter> loader) {\n@@ -101,7 +101,7 @@ private MetadataInfo(String app, String revision, Map<String, ServiceInfo> servi\n         this.initiated = new AtomicBoolean(initiated.get());\n         this.extendParams = new ConcurrentHashMap<>(extendParams);\n         this.instanceParams = new ConcurrentHashMap<>(instanceParams);\n-        this.updated = new AtomicBoolean(updated.get());\n+        this.updated = updated;\n         this.subscribedServiceURLs = subscribedServiceURLs == null ? null : new ConcurrentSkipListMap<>(subscribedServiceURLs);\n         this.exportedServiceURLs = exportedServiceURLs == null ? null : new ConcurrentSkipListMap<>(exportedServiceURLs);\n         this.loader = loader;",
    "output": "Fix compilation issue cause of merge conflict"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerReadinessProbe.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerReadinessProbe.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerReadinessProbe.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerReadinessProbe.java\n@@ -26,10 +26,18 @@\n @Activate\n public class DeployerReadinessProbe implements ReadinessProbe {\n+    private FrameworkModel frameworkModel;\n+\n+    public DeployerReadinessProbe(FrameworkModel frameworkModel) {\n+        this.frameworkModel = frameworkModel;\n+    }\n     @Override\n     public boolean check() {\n-        List<ApplicationModel> applicationModels = FrameworkModel.defaultModel().getAllApplicationModels();\n+        if (this.frameworkModel == null) {\n+            this.frameworkModel = FrameworkModel.defaultModel();\n+        }\n+        List<ApplicationModel> applicationModels = frameworkModel.getAllApplicationModels();\n         for (ApplicationModel applicationModel : applicationModels) {\n             for (ModuleModel moduleModel : applicationModel.getModuleModels()) {\n                 if (!moduleModel.getDeployer().isStarted()) {\ndiff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerStartupProbe.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerStartupProbe.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerStartupProbe.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerStartupProbe.java\n@@ -26,10 +26,18 @@\n @Activate\n public class DeployerStartupProbe implements StartupProbe {\n+    private FrameworkModel frameworkModel;\n+\n+    public DeployerStartupProbe(FrameworkModel frameworkModel) {\n+        this.frameworkModel = frameworkModel;\n+    }\n     @Override\n     public boolean check() {\n-        List<ApplicationModel> applicationModels = FrameworkModel.defaultModel().getAllApplicationModels();\n+        if (this.frameworkModel == null) {\n+            this.frameworkModel = FrameworkModel.defaultModel();\n+        }\n+        List<ApplicationModel> applicationModels = frameworkModel.getAllApplicationModels();\n         for (ApplicationModel applicationModel : applicationModels) {\n             for (ModuleModel moduleModel : applicationModel.getModuleModels()) {\n                 if (moduleModel.getDeployer().isRunning()) {\ndiff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/ProviderReadinessProbe.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/ProviderReadinessProbe.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/ProviderReadinessProbe.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/ProviderReadinessProbe.java\n@@ -27,9 +27,17 @@\n @Activate\n public class ProviderReadinessProbe implements ReadinessProbe {\n-\n-\n-    private static FrameworkServiceRepository serviceRepository = FrameworkModel.defaultModel().getServiceRepository();\n+    private FrameworkModel frameworkModel;\n+    private FrameworkServiceRepository serviceRepository;\n+\n+    public ProviderReadinessProbe(FrameworkModel frameworkModel) {\n+        if (frameworkModel != null) {\n+            this.frameworkModel = frameworkModel;\n+        } else {\n+            this.frameworkModel = FrameworkModel.defaultModel();\n+        }\n+        this.serviceRepository = this.frameworkModel.getServiceRepository();\n+    }\n     @Override\n     public boolean check() {\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ReadyTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ReadyTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ReadyTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ReadyTest.java\n@@ -26,6 +26,7 @@\n import org.apache.dubbo.qos.probe.impl.ProviderReadinessProbe;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.FrameworkModel;\n+import org.apache.dubbo.rpc.model.FrameworkServiceRepository;\n import org.apache.dubbo.rpc.model.ModuleModel;\n import org.junit.jupiter.api.Assertions;\n@@ -34,20 +35,27 @@\n import org.mockito.Mockito;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n public class ReadyTest {\n     private FrameworkModel frameworkModel;\n     private ModuleDeployer moduleDeployer;\n+    private FrameworkServiceRepository frameworkServiceRepository;\n     @BeforeEach\n     public void setUp() {\n         frameworkModel = Mockito.mock(FrameworkModel.class);\n+        frameworkServiceRepository = Mockito.mock(FrameworkServiceRepository.class);\n+\n         ApplicationModel applicationModel = Mockito.mock(ApplicationModel.class);\n         ModuleModel moduleModel = Mockito.mock(ModuleModel.class);\n         moduleDeployer = Mockito.mock(ModuleDeployer.class);\n+        Mockito.when(frameworkServiceRepository.allProviderModels()).thenReturn(Collections.emptyList());\n         Mockito.when(frameworkModel.newApplication()).thenReturn(applicationModel);\n+        Mockito.when(frameworkModel.getAllApplicationModels()).thenReturn(Arrays.asList(applicationModel));\n+        Mockito.when(frameworkModel.getServiceRepository()).thenReturn(frameworkServiceRepository);\n         Mockito.when(applicationModel.getModuleModels()).thenReturn(Arrays.asList(moduleModel));\n         Mockito.when(moduleModel.getDeployer()).thenReturn(moduleDeployer);\n         Mockito.when(moduleDeployer.isStarted()).thenReturn(true);\n@@ -56,8 +64,8 @@ public void setUp() {\n         Mockito.when(frameworkModel.getExtensionLoader(ReadinessProbe.class)).thenReturn(loader);\n         URL url = URL.valueOf(\"application://\").addParameter(CommonConstants.QOS_READY_PROBE_EXTENSION, \"\");\n         List<ReadinessProbe> readinessProbes = Arrays.asList(\n-            new DeployerReadinessProbe(),\n-            new ProviderReadinessProbe()\n+            new DeployerReadinessProbe(frameworkModel),\n+            new ProviderReadinessProbe(frameworkModel)\n         );\n         Mockito.when(loader.getActivateExtension(url, CommonConstants.QOS_READY_PROBE_EXTENSION)).thenReturn(readinessProbes);\n     }\n@@ -68,7 +76,7 @@ public void testExecute() {\n         CommandContext commandContext = new CommandContext(\"ready\");\n         String result = ready.execute(commandContext, new String[0]);\n-        Assertions.assertEquals(result, \"true\");\n+        Assertions.assertEquals(\"true\", result);\n         Assertions.assertEquals(commandContext.getHttpCode(), 200);\n         Mockito.when(moduleDeployer.isStarted()).thenReturn(false);\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/StartupTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/StartupTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/StartupTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/StartupTest.java\n@@ -46,6 +46,7 @@ public void setUp() {\n         ModuleModel moduleModel = Mockito.mock(ModuleModel.class);\n         moduleDeployer = Mockito.mock(ModuleDeployer.class);\n         Mockito.when(frameworkModel.newApplication()).thenReturn(applicationModel);\n+        Mockito.when(frameworkModel.getAllApplicationModels()).thenReturn(Arrays.asList(applicationModel));\n         Mockito.when(applicationModel.getModuleModels()).thenReturn(Arrays.asList(moduleModel));\n         Mockito.when(moduleModel.getDeployer()).thenReturn(moduleDeployer);\n         Mockito.when(moduleDeployer.isRunning()).thenReturn(true);\n@@ -54,7 +55,7 @@ public void setUp() {\n         Mockito.when(frameworkModel.getExtensionLoader(StartupProbe.class)).thenReturn(loader);\n         URL url = URL.valueOf(\"application://\").addParameter(CommonConstants.QOS_STARTUP_PROBE_EXTENSION, \"\");\n         List<StartupProbe> readinessProbes = Arrays.asList(\n-            new DeployerStartupProbe()\n+            new DeployerStartupProbe(frameworkModel)\n         );\n         Mockito.when(loader.getActivateExtension(url, CommonConstants.QOS_STARTUP_PROBE_EXTENSION)).thenReturn(readinessProbes);\n     }",
    "output": "Fix probe extensions"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerReadinessProbe.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerReadinessProbe.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerReadinessProbe.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerReadinessProbe.java\n@@ -19,23 +19,22 @@\n import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.qos.probe.ReadinessProbe;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ModuleModel;\n+import java.util.List;\n+\n @Activate\n public class DeployerReadinessProbe implements ReadinessProbe {\n-\n-    private ApplicationModel applicationModel;\n-\n-    public DeployerReadinessProbe(ApplicationModel applicationModel) {\n-        this.applicationModel = applicationModel;\n-    }\n-\n     @Override\n     public boolean check() {\n-        for (ModuleModel moduleModel : applicationModel.getModuleModels()) {\n-            if (!moduleModel.getDeployer().isStarted()) {\n-                return false;\n+        List<ApplicationModel> applicationModels = FrameworkModel.defaultModel().getAllApplicationModels();\n+        for (ApplicationModel applicationModel : applicationModels) {\n+            for (ModuleModel moduleModel : applicationModel.getModuleModels()) {\n+                if (!moduleModel.getDeployer().isStarted()) {\n+                    return false;\n+                }\n             }\n         }\n         return true;\ndiff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerStartupProbe.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerStartupProbe.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerStartupProbe.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/DeployerStartupProbe.java\n@@ -19,22 +19,22 @@\n import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.qos.probe.StartupProbe;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.ModuleModel;\n+import java.util.List;\n+\n @Activate\n public class DeployerStartupProbe implements StartupProbe {\n-    private ApplicationModel applicationModel;\n-\n-    public DeployerStartupProbe(ApplicationModel applicationModel) {\n-        this.applicationModel = applicationModel;\n-    }\n-\n     @Override\n     public boolean check() {\n-        for (ModuleModel moduleModel : applicationModel.getModuleModels()) {\n-            if (moduleModel.getDeployer().isRunning()) {\n-                return true;\n+        List<ApplicationModel> applicationModels = FrameworkModel.defaultModel().getAllApplicationModels();\n+        for (ApplicationModel applicationModel : applicationModels) {\n+            for (ModuleModel moduleModel : applicationModel.getModuleModels()) {\n+                if (moduleModel.getDeployer().isRunning()) {\n+                    return true;\n+                }\n             }\n         }\n         return false;\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ReadyTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ReadyTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ReadyTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ReadyTest.java\n@@ -56,7 +56,7 @@ public void setUp() {\n         Mockito.when(frameworkModel.getExtensionLoader(ReadinessProbe.class)).thenReturn(loader);\n         URL url = URL.valueOf(\"application://\").addParameter(CommonConstants.QOS_READY_PROBE_EXTENSION, \"\");\n         List<ReadinessProbe> readinessProbes = Arrays.asList(\n-            new DeployerReadinessProbe(frameworkModel.newApplication()),\n+            new DeployerReadinessProbe(),\n             new ProviderReadinessProbe()\n         );\n         Mockito.when(loader.getActivateExtension(url, CommonConstants.QOS_READY_PROBE_EXTENSION)).thenReturn(readinessProbes);\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/StartupTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/StartupTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/StartupTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/StartupTest.java\n@@ -54,7 +54,7 @@ public void setUp() {\n         Mockito.when(frameworkModel.getExtensionLoader(StartupProbe.class)).thenReturn(loader);\n         URL url = URL.valueOf(\"application://\").addParameter(CommonConstants.QOS_STARTUP_PROBE_EXTENSION, \"\");\n         List<StartupProbe> readinessProbes = Arrays.asList(\n-            new DeployerStartupProbe(frameworkModel.newApplication())\n+            new DeployerStartupProbe()\n         );\n         Mockito.when(loader.getActivateExtension(url, CommonConstants.QOS_STARTUP_PROBE_EXTENSION)).thenReturn(readinessProbes);\n     }",
    "output": "Fix probes"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java\n@@ -136,7 +136,7 @@ private CompletableFuture<Object> wrapWithFuture(Object value, Invocation invoca\n         if (value instanceof CompletableFuture) {\n             invocation.put(PROVIDER_ASYNC_KEY, Boolean.TRUE);\n             return (CompletableFuture<Object>) value;\n-        } else if (RpcContext.getServiceContext().isAsyncStarted()) {\n+        } else if (RpcContext.getServerAttachment().isAsyncStarted()) {\n             invocation.put(PROVIDER_ASYNC_KEY, Boolean.TRUE);\n             return ((AsyncContextImpl) (RpcContext.getServiceContext().getAsyncContext())).getInternalFuture();\n         }",
    "output": "Fix wrong context reference"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n@@ -499,7 +499,7 @@ private void initDic() {\n         dic.buildRouterChain();\n     }\n-    @Test()\n+    @Test\n     public void testTimeoutExceptionCode() {\n         List<Invoker<DemoService>> invokers = new ArrayList<Invoker<DemoService>>();\n         invokers.add(new Invoker<DemoService>() {\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvokerTest.java\n@@ -86,7 +86,7 @@ private void resetInvokerToNoException() {\n         given(invoker3.getInterface()).willReturn(AvailableClusterInvokerTest.class);\n     }\n-    @Test()\n+    @Test\n     public void testInvokeNoException() {\n         resetInvokerToNoException();\n@@ -96,7 +96,7 @@ public void testInvokeNoException() {\n         Assertions.assertSame(result, ret);\n     }\n-    @Test()\n+    @Test\n     public void testInvokeWithException() {\n         // remove invokers for test exception\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java\n@@ -89,7 +89,7 @@ public void testInvokeExceptoin() {\n         Assertions.assertNull(RpcContext.getServiceContext().getInvoker());\n     }\n-    @Test()\n+    @Test\n     public void testInvokeNoExceptoin() {\n         resetInvokerToNoException();\n@@ -99,7 +99,7 @@ public void testInvokeNoExceptoin() {\n         Assertions.assertSame(result, ret);\n     }\n-    @Test()\n+    @Test\n     public void testNoInvoke() {\n         dic = mock(Directory.class);\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailfastClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailfastClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailfastClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailfastClusterInvokerTest.java\n@@ -108,7 +108,7 @@ public void testInvokeBizException() {\n         }\n     }\n-    @Test()\n+    @Test\n     public void testInvokeNoException() {\n         resetInvoker1ToNoException();\n@@ -118,7 +118,7 @@ public void testInvokeNoException() {\n         assertSame(result, ret);\n     }\n-    @Test()\n+    @Test\n     public void testNoInvoke() {\n         dic = mock(Directory.class);\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvokerTest.java\n@@ -101,7 +101,7 @@ public void testInvokeWithRuntimeException() {\n         }\n     }\n-    @Test()\n+    @Test\n     public void testInvokeWithRPCException() {\n         given(invoker1.invoke(invocation)).willThrow(new RpcException());\n         given(invoker1.isAvailable()).willReturn(true);\n@@ -120,7 +120,7 @@ public void testInvokeWithRPCException() {\n         }\n     }\n-    @Test()\n+    @Test\n     public void testInvoke_retryTimes() {\n         given(invoker1.invoke(invocation)).willThrow(new RpcException(RpcException.TIMEOUT_EXCEPTION));\n         given(invoker1.isAvailable()).willReturn(false);\n@@ -143,7 +143,7 @@ public void testInvoke_retryTimes() {\n         }\n     }\n-    @Test()\n+    @Test\n     public void testInvoke_retryTimes2() {\n         int finalRetries = 1;\n         given(invoker1.invoke(invocation)).willThrow(new RpcException(RpcException.TIMEOUT_EXCEPTION));\n@@ -170,7 +170,7 @@ public void testInvoke_retryTimes2() {\n         }\n     }\n-    @Test()\n+    @Test\n     public void testInvoke_retryTimes_withBizException() {\n         given(invoker1.invoke(invocation)).willThrow(new RpcException(RpcException.BIZ_EXCEPTION));\n         given(invoker1.isAvailable()).willReturn(false);\n@@ -192,7 +192,7 @@ public void testInvoke_retryTimes_withBizException() {\n         }\n     }\n-    @Test()\n+    @Test\n     public void testInvoke_without_retry() {\n         int withoutRetry = 0;\n         final URL url = URL.valueOf(\"test://localhost/\" + Demo.class.getName() + \"?loadbalance=roundrobin&retries=\" + withoutRetry);\n@@ -219,7 +219,7 @@ public void testInvoke_without_retry() {\n         }\n     }\n-    @Test()\n+    @Test\n     public void testInvoke_when_retry_illegal() {\n         int illegalRetry = -1;\n         final URL url = URL.valueOf(\"test://localhost/\" + Demo.class.getName() + \"?loadbalance=roundrobin&retries=\" + illegalRetry);\n@@ -246,7 +246,7 @@ public void testInvoke_when_retry_illegal() {\n         }\n     }\n-    @Test()\n+    @Test\n     public void testNoInvoke() {\n         dic = mock(Directory.class);\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvokerTest.java\n@@ -141,7 +141,7 @@ public void testClearRpcContext() {\n         Assertions.assertTrue(afterInvoke != null && afterInvoke.size() == 0, \"clear attachment failed!\");\n     }\n-    @Test()\n+    @Test\n     public void testInvokeNoException() {\n         resetInvokerToNoException();\n@@ -151,7 +151,7 @@ public void testInvokeNoException() {\n         Assertions.assertSame(result, ret);\n     }\n-    @Test()\n+    @Test\n     public void testInvokeWithIllegalForksParam() {\n         URL url = URL.valueOf(\"test://test:11/test?forks=-1\");\n         given(dic.getUrl()).willReturn(url);",
    "output": "Fix @test annotation"
  },
  {
    "input": "diff --git a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/GreeterService.java b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/GreeterService.java\n--- a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/GreeterService.java\n+++ b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/GreeterService.java\n@@ -19,10 +19,16 @@\n import org.apache.dubbo.demo.hello.HelloReply;\n import org.apache.dubbo.demo.hello.HelloRequest;\n+import java.util.concurrent.CompletableFuture;\n+\n public interface GreeterService {\n     /**\n      * Sends a greeting\n      */\n     HelloReply sayHello(HelloRequest request);\n+\n+\n+    CompletableFuture<String> sayHelloAsync(String request);\n+\n }\ndiff --git a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/GreeterServiceImpl.java b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/GreeterServiceImpl.java\n--- a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/GreeterServiceImpl.java\n+++ b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/GreeterServiceImpl.java\n@@ -19,6 +19,8 @@\n import org.apache.dubbo.demo.hello.HelloReply;\n import org.apache.dubbo.demo.hello.HelloRequest;\n+import java.util.concurrent.CompletableFuture;\n+\n public class GreeterServiceImpl implements GreeterService {\n     @Override\n@@ -27,4 +29,9 @@ public HelloReply sayHello(HelloRequest request) {\n                 .setMessage(\"Hello \" + request.getName())\n                 .build();\n     }\n+\n+    @Override\n+    public CompletableFuture<String> sayHelloAsync(String name) {\n+        return CompletableFuture.supplyAsync(() -> name);\n+    }\n }\ndiff --git a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiConsumer.java b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiConsumer.java\n--- a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiConsumer.java\n+++ b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiConsumer.java\n@@ -27,6 +27,7 @@\n import org.apache.dubbo.demo.hello.HelloRequest;\n import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.TimeUnit;\n public class ApiConsumer {\n@@ -53,6 +54,9 @@ public static void main(String[] args) throws InterruptedException, IOException\n                 .build());\n             TimeUnit.SECONDS.sleep(1);\n             System.out.println(\"Reply: \" + reply.getMessage());\n+\n+            CompletableFuture<String> sayHelloAsync = greeterService.sayHelloAsync(\"triple\");\n+            System.out.println(\"Async Reply: \"+sayHelloAsync.get());\n         } catch (Throwable t) {\n             t.printStackTrace();\n         }\ndiff --git a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/DefaultMultipleSerialization.java b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/DefaultMultipleSerialization.java\n--- a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/DefaultMultipleSerialization.java\n+++ b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/DefaultMultipleSerialization.java\n@@ -18,7 +18,6 @@\n package org.apache.dubbo.common.serialize;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.utils.ClassUtils;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -39,9 +38,8 @@ public void serialize(URL url, String serializeType, String clz, Object obj, Out\n     public Object deserialize(URL url, String serializeType, String clz, InputStream os) throws IOException, ClassNotFoundException {\n         serializeType = convertHessian(serializeType);\n         final Serialization serialization = url.getOrDefaultFrameworkModel().getExtensionLoader(Serialization.class).getExtension(serializeType);\n-        final Class<?> aClass = ClassUtils.forName(clz);\n         final ObjectInput in = serialization.deserialize(null, os);\n-        return in.readObject(aClass);\n+        return in.readObject();\n     }\n     private String convertHessian(String ser) {",
    "output": "Fix hessian2 deserialize fail * fix hessian2 deserialize fail * refactor: Delete redundant import items"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/curator/Curator5ZookeeperClientTest.java b/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/curator/Curator5ZookeeperClientTest.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/curator/Curator5ZookeeperClientTest.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/curator/Curator5ZookeeperClientTest.java\n@@ -28,6 +28,8 @@\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.Timeout;\n+import org.junit.jupiter.api.condition.DisabledForJreRange;\n+import org.junit.jupiter.api.condition.JRE;\n import java.util.List;\n import java.util.concurrent.CountDownLatch;\n@@ -39,6 +41,7 @@\n import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.mockito.Mockito.mock;\n+@DisabledForJreRange(min = JRE.JAVA_16)\n public class Curator5ZookeeperClientTest {\n     private static Curator5ZookeeperClient curatorClient;\n     private static CuratorFramework client = null;\ndiff --git a/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/curator/Curator5ZookeeperTransporterTest.java b/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/curator/Curator5ZookeeperTransporterTest.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/curator/Curator5ZookeeperTransporterTest.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/curator/Curator5ZookeeperTransporterTest.java\n@@ -22,11 +22,14 @@\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.DisabledForJreRange;\n+import org.junit.jupiter.api.condition.JRE;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.core.IsNot.not;\n import static org.hamcrest.core.IsNull.nullValue;\n+@DisabledForJreRange(min = JRE.JAVA_16)\n public class Curator5ZookeeperTransporterTest {\n     private ZookeeperClient zookeeperClient;\n     private Curator5ZookeeperTransporter curatorZookeeperTransporter;",
    "output": "Add test dependency"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -86,7 +86,7 @@ protected void initChannel(Channel ch) {\n                 p.addLast(new TripleServerInboundHandler());\n             }\n         });\n-        pipeline.addLast(codec, new TripleServerConnectionHandler(), handler);\n+        pipeline.addLast(codec, new TripleServerConnectionHandler(), handler, new TripleTailHandler());\n     }\n     @Override\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleTailHandler.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleTailHandler.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleTailHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleTailHandler.java\n@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.rpc.protocol.tri;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.ReferenceCounted;\n+\n+/**\n+ * Process unhandled message to avoid mem leak and netty's unhandled exception\n+ */\n+public class TripleTailHandler extends ChannelInboundHandlerAdapter {\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        if (msg instanceof ReferenceCounted) {\n+            ReferenceCountUtil.release(msg);\n+        }\n+    }\n+}",
    "output": "Add tail handler"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n@@ -508,6 +508,10 @@ public Map<String, String> getParameters() {\n         return urlParam.getParameters();\n     }\n+    public Map<String, String> getAllParameters() {\n+        return this.getParameters();\n+    }\n+\n     /**\n      * Get the parameters to be selected(filtered)\n      *\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/DubboServiceAddressURL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/DubboServiceAddressURL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/DubboServiceAddressURL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/DubboServiceAddressURL.java\n@@ -21,6 +21,8 @@\n import org.apache.dubbo.rpc.model.ScopeModel;\n import org.apache.dubbo.rpc.model.ServiceModel;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Map;\n import java.util.Objects;\n@@ -90,6 +92,23 @@ public String getAnyMethodParameter(String key) {\n         return value;\n     }\n+    /**\n+     * The returned parameters is imprecise regarding override priorities of consumer url and provider url.\n+     * This method is only used to pass the configuration in the 'client'.\n+     */\n+    @Override\n+    public Map<String, String> getAllParameters() {\n+        Map<String, String> allParameters = new HashMap<>((int)(super.getParameters().size()/.75 + 1));\n+        allParameters.putAll(super.getParameters());\n+        if (consumerURL != null) {\n+            allParameters.putAll(consumerURL.getParameters());\n+        }\n+        if (overrideURL != null) {\n+            allParameters.putAll(overrideURL.getParameters());\n+        }\n+        return Collections.unmodifiableMap(allParameters);\n+    }\n+\n     public ServiceConfigURL getOverrideURL() {\n         return overrideURL;\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n@@ -100,22 +100,6 @@ public String getVersion() {\n         return consumerURL.getVersion();\n     }\n-    /**\n-     * FIXME, Avoid calling this method on the main line.\n-     */\n-//    @Override\n-//    public Map<String, String> getParameters() {\n-//        Map<String, String> allParameters = new HashMap<>((int)(super.getParameters().size()/.75 + 1));\n-//        allParameters.putAll(super.getParameters());\n-//        if (consumerURL != null) {\n-//            allParameters.putAll(consumerURL.getParameters());\n-//        }\n-//        if (overriddenURL != null) {\n-//            allParameters.putAll(overriddenURL.getParameters());\n-//        }\n-//        allParameters.remove(CATEGORY_KEY);\n-//        return Collections.unmodifiableMap(allParameters);\n-//    }\n     @Override\n     public String getParameter(String key) {\n         // call corresponding methods directly, then we can remove the following if branches.\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n@@ -627,9 +627,6 @@ private ExchangeClient initClient(URL url) {\n          * which means params are shared among different services. Since client is shared among services this is currently not a problem.\n          */\n         String str = url.getParameter(CLIENT_KEY, url.getParameter(SERVER_KEY, DEFAULT_REMOTING_CLIENT));\n-        url = url.addParameter(CODEC_KEY, DubboCodec.NAME);\n-        // enable heartbeat by default\n-        url = url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT));\n         // BIO is not allowed since it has severe performance issue.\n         if (StringUtils.isNotEmpty(str) && !url.getOrDefaultFrameworkModel().getExtensionLoader(Transporter.class).hasExtension(str)) {\n@@ -640,7 +637,11 @@ private ExchangeClient initClient(URL url) {\n         ExchangeClient client;\n         try {\n             // Replace InstanceAddressURL with ServiceConfigURL.\n-            url = new ServiceConfigURL(DubboCodec.NAME, url.getUsername(), url.getPassword(), url.getHost(), url.getPort(), url.getPath(),  url.getParameters());\n+            url = new ServiceConfigURL(DubboCodec.NAME, url.getUsername(), url.getPassword(), url.getHost(), url.getPort(), url.getPath(),  url.getAllParameters());\n+            url = url.addParameter(CODEC_KEY, DubboCodec.NAME);\n+            // enable heartbeat by default\n+            url = url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT));\n+\n             // connection should be lazy\n             if (url.getParameter(LAZY_CONNECT_KEY, false)) {\n                 client = new LazyConnectExchangeClient(url, requestHandler);",
    "output": "Fix client parameters, consumer parameters was not included"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -33,6 +33,7 @@\n import org.apache.dubbo.config.support.Parameter;\n import org.apache.dubbo.config.utils.ConfigValidationUtils;\n import org.apache.dubbo.metadata.ServiceNameMapping;\n+import org.apache.dubbo.registry.client.metadata.MetadataUtils;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Protocol;\n import org.apache.dubbo.rpc.ProxyFactory;\n@@ -402,6 +403,7 @@ private T createProxy(Map<String, String> referenceParameters) {\n             referenceParameters.get(INTERFACE_KEY), referenceParameters);\n         consumerUrl = consumerUrl.setScopeModel(getScopeModel());\n         consumerUrl = consumerUrl.setServiceModel(consumerModel);\n+        MetadataUtils.publishServiceDefinition(interfaceName, consumerUrl, getScopeModel(), getApplicationModel());\n         // create service proxy\n         return (T) proxyFactory.getProxy(invoker, ProtocolUtils.isGeneric(generic));\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -571,11 +571,7 @@ private void exportUrl(URL url, List<URL> registryURLs) {\n                 if (!isGeneric(generic) && !isMetadataService(interfaceName)) {\n                     ServiceDescriptor descriptor = getScopeModel().getServiceRepository().getService(interfaceName);\n                     if (descriptor != null) {\n-                        MetadataUtils.publishServiceDefinition(\n-                            getScopeModel().getServiceRepository().getService(interfaceName),\n-                            version == null ? \"\" : version,\n-                            group == null ? \"\" : group,\n-                            getApplicationModel());\n+                        MetadataUtils.publishServiceDefinition(interfaceName, url, getScopeModel(), getApplicationModel());\n                     }\n                 }\n             }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n@@ -34,6 +34,7 @@\n import org.apache.dubbo.rpc.Protocol;\n import org.apache.dubbo.rpc.ProxyFactory;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.ModuleModel;\n import org.apache.dubbo.rpc.model.ScopeModel;\n import org.apache.dubbo.rpc.model.ServiceDescriptor;\n@@ -43,6 +44,7 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n import static org.apache.dubbo.common.constants.CommonConstants.REMOTE_METADATA_STORAGE_TYPE;\n import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_CLUSTER_KEY;\n@@ -63,29 +65,51 @@ public static synchronized MetadataService getMetadataServiceProxy(ServiceInstan\n         return metadataServiceProxies.computeIfAbsent(computeKey(instance), k -> referProxy(k, instance));\n     }\n-    public static void publishServiceDefinition(ServiceDescriptor serviceDescriptor, String version, String group, ApplicationModel applicationModel) {\n+    public static void publishServiceDefinition(String serviceName, URL url, ModuleModel scopeModel, ApplicationModel applicationModel) {\n         if (getMetadataReports(applicationModel).size() == 0) {\n             String msg = \"Remote Metadata Report Server not hasn't been configured or unavailable . Unable to get Metadata from remote!\";\n             logger.warn(msg);\n         }\n-        String serviceName = serviceDescriptor.getServiceName();\n-        FullServiceDefinition serviceDefinition = serviceDescriptor.getServiceDefinition(serviceName);\n-\n         try {\n-            if (StringUtils.isNotEmpty(serviceName)) {\n+            String side = url.getSide();\n+            if (PROVIDER_SIDE.equalsIgnoreCase(side)) {\n+                ServiceDescriptor serviceDescriptor = scopeModel.getServiceRepository().getService(serviceName);\n+                if (serviceDescriptor == null) {\n+                    return;\n+                }\n+                FullServiceDefinition serviceDefinition = serviceDescriptor.getServiceDefinition(serviceName);\n+\n+                if (StringUtils.isNotEmpty(serviceName) && serviceDefinition != null) {\n+                    serviceDefinition.setParameters(url.getParameters());\n+                    for (Map.Entry<String, MetadataReport> entry : getMetadataReports(applicationModel).entrySet()) {\n+                        MetadataReport metadataReport = entry.getValue();\n+                        metadataReport.storeProviderMetadata(\n+                            new MetadataIdentifier(\n+                                serviceName,\n+                                url.getVersion() == null ? \"\" : url.getVersion(),\n+                                url.getGroup() == null ? \"\" : url.getGroup(),\n+                                PROVIDER_SIDE,\n+                                applicationModel.getApplicationName())\n+                            , serviceDefinition);\n+                    }\n+                }\n+            } else {\n                 for (Map.Entry<String, MetadataReport> entry : getMetadataReports(applicationModel).entrySet()) {\n                     MetadataReport metadataReport = entry.getValue();\n-                    metadataReport.storeProviderMetadata(new MetadataIdentifier(serviceName,\n-                        version, group,\n-                        PROVIDER_SIDE, applicationModel.getApplicationName()), serviceDefinition);\n+                    metadataReport.storeConsumerMetadata(\n+                        new MetadataIdentifier(\n+                            serviceName,\n+                            url.getVersion() == null ? \"\" : url.getVersion(),\n+                            url.getGroup() == null ? \"\" : url.getGroup(),\n+                            CONSUMER_SIDE,\n+                            applicationModel.getApplicationName()),\n+                        url.getParameters());\n                 }\n-                return;\n             }\n-            logger.error(\"publishProvider interfaceName is empty.\");\n         } catch (Exception e) {\n             //ignore error\n-            logger.error(\"publishProvider getServiceDescriptor error.\", e);\n+            logger.error(\"publish service definition metadata error.\", e);\n         }\n     }",
    "output": "Fix meta service definition"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -571,7 +571,11 @@ private void exportUrl(URL url, List<URL> registryURLs) {\n                 if (!isGeneric(generic) && !isMetadataService(interfaceName)) {\n                     ServiceDescriptor descriptor = getScopeModel().getServiceRepository().getService(interfaceName);\n                     if (descriptor != null) {\n-                        MetadataUtils.publishServiceDefinition(getScopeModel().getServiceRepository().getService(interfaceName), getApplicationModel());\n+                        MetadataUtils.publishServiceDefinition(\n+                            getScopeModel().getServiceRepository().getService(interfaceName),\n+                            version == null ? \"\" : version,\n+                            group == null ? \"\" : group,\n+                            getApplicationModel());\n                     }\n                 }\n             }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java\n@@ -63,7 +63,7 @@ public static synchronized MetadataService getMetadataServiceProxy(ServiceInstan\n         return metadataServiceProxies.computeIfAbsent(computeKey(instance), k -> referProxy(k, instance));\n     }\n-    public static void publishServiceDefinition(ServiceDescriptor serviceDescriptor, ApplicationModel applicationModel) {\n+    public static void publishServiceDefinition(ServiceDescriptor serviceDescriptor, String version, String group, ApplicationModel applicationModel) {\n         if (getMetadataReports(applicationModel).size() == 0) {\n             String msg = \"Remote Metadata Report Server not hasn't been configured or unavailable . Unable to get Metadata from remote!\";\n             logger.warn(msg);\n@@ -77,7 +77,7 @@ public static void publishServiceDefinition(ServiceDescriptor serviceDescriptor,\n                 for (Map.Entry<String, MetadataReport> entry : getMetadataReports(applicationModel).entrySet()) {\n                     MetadataReport metadataReport = entry.getValue();\n                     metadataReport.storeProviderMetadata(new MetadataIdentifier(serviceName,\n-                        \"\", \"\",\n+                        version, group,\n                         PROVIDER_SIDE, applicationModel.getApplicationName()), serviceDefinition);\n                 }\n                 return;",
    "output": "Fix curator5 and metadata"
  },
  {
    "input": "diff --git a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/ZookeeperRegistryCenter.java b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/ZookeeperRegistryCenter.java\n--- a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/ZookeeperRegistryCenter.java\n+++ b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/ZookeeperRegistryCenter.java\n@@ -18,6 +18,8 @@\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.Assert;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.test.check.exception.DubboTestException;\n import org.apache.dubbo.test.check.registrycenter.context.ZookeeperContext;\n import org.apache.dubbo.test.check.registrycenter.context.ZookeeperWindowsContext;\n@@ -34,11 +36,11 @@\n import java.io.File;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n-import java.util.List;\n import java.util.ArrayList;\n-import java.util.Objects;\n+import java.util.List;\n import java.util.Map;\n import java.util.HashMap;\n+import java.util.Objects;\n import java.util.concurrent.atomic.AtomicBoolean;\n /**\n@@ -78,6 +80,11 @@ public ZookeeperRegistryCenter() {\n     private static final Logger logger = LoggerFactory.getLogger(ZookeeperRegistryCenter.class);\n+    /**\n+     * The JVM arguments to set the embedded zookeeper directory.\n+     */\n+    private static final String CONFIG_EMBEDDED_ZOOKEEPER_DIRECTORY = \"embeddedZookeeperPath\";\n+\n     /**\n      * The OS type.\n      */\n@@ -108,13 +115,6 @@ public ZookeeperRegistryCenter() {\n      */\n     private static final String TARGET_ZOOKEEPER_FILE_NAME = UNPACKED_DIRECTORY + \".tar.gz\";\n-    /**\n-     * The target directory.\n-     * The zookeeper binary file named {@link #TARGET_ZOOKEEPER_FILE_NAME} will be saved in\n-     * {@link #TARGET_DIRECTORY} if it downloaded successfully.\n-     */\n-    private static final String TARGET_DIRECTORY = \".tmp\" + File.separator + \"zookeeper\";\n-\n     /**\n      * The path of target zookeeper binary file.\n      */\n@@ -125,18 +125,42 @@ public ZookeeperRegistryCenter() {\n      */\n     private static final AtomicBoolean INITIALIZED = new AtomicBoolean(false);\n+    /**\n+     * Returns the directory to store zookeeper binary archive.\n+     * <p>The priorities to obtain the directory are as follows:</p>\n+     * <p>1. Use System.getProperty({@link #CONFIG_EMBEDDED_ZOOKEEPER_DIRECTORY}) if not null or empty</p>\n+     * <p>2. Use System.getProperty(user.home) if not null or empty</p>\n+     * <p>3. Use System.getProperty(java.io.tmpdir)</p>\n+     */\n+    private static String getEmbeddedZookeeperDirectory() {\n+        String directory;\n+        // Use System.getProperty({@link #CONFIG_EMBEDDED_ZOOKEEPER_DIRECTORY})\n+        directory = System.getProperty(CONFIG_EMBEDDED_ZOOKEEPER_DIRECTORY);\n+        logger.info(String.format(\"The customized directory is %s to store zookeeper binary archive.\",directory));\n+        if (StringUtils.isNotEmpty(directory)) {\n+            return directory;\n+        }\n+        // Use System.getProperty(user.home)\n+        logger.info(String.format(\"The user home is %s to store zookeeper binary archive.\",directory));\n+        directory = System.getProperty(\"user.home\");\n+        logger.info(String.format(\"user.home is %s\",directory));\n+        if (StringUtils.isEmpty(directory)) {\n+            // Use default temporary directory\n+            directory = System.getProperty(\"java.io.tmpdir\");\n+            logger.info(String.format(\"The temporary directory is %s to store zookeeper binary archive.\",directory));\n+        }\n+        Assert.notEmptyString(directory, \"The directory to store zookeeper binary archive cannot be null or empty.\");\n+        return directory + File.separator + \".tmp\" + File.separator + \"zookeeper\";\n+\n+    }\n+\n     /**\n      * Returns the target file path.\n      */\n     private static Path getTargetFilePath() {\n-        String currentWorkDirectory = System.getProperty(\"user.dir\");\n-        logger.info(\"Current work directory: \" + currentWorkDirectory);\n-        int index = currentWorkDirectory.lastIndexOf(File.separator + \"dubbo\" + File.separator);\n-        Path targetFilePath = Paths.get(currentWorkDirectory.substring(0, index),\n-            \"dubbo\",\n-            TARGET_DIRECTORY,\n-            TARGET_ZOOKEEPER_FILE_NAME);\n-        logger.info(\"Target file's absolute directory: \" + targetFilePath.toString());\n+        String zookeeperDirectory = getEmbeddedZookeeperDirectory();\n+        Path targetFilePath = Paths.get(zookeeperDirectory, TARGET_ZOOKEEPER_FILE_NAME);\n+        logger.info(\"Target file's absolute directory: \" + targetFilePath);\n         return targetFilePath;\n     }",
    "output": "Fix Obtain the downloaded zookeeper path when run unit test * fix: Obtain the downloaded zookeeper path when run unit test 1. Set priorities for the downloaed zookeeper path 2. Support environment variables see: https://github.com/apache/dubbo/issues/9478 * perf: Remove unused code * perf: Optimize the customized directory"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ClassLoaderFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ClassLoaderFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ClassLoaderFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ClassLoaderFilter.java\n@@ -33,7 +33,7 @@ public class ClassLoaderFilter implements Filter {\n     @Override\n     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n         ClassLoader ocl = Thread.currentThread().getContextClassLoader();\n-        Thread.currentThread().setContextClassLoader(invoker.getInterface().getClassLoader());\n+        Thread.currentThread().setContextClassLoader(invocation.getServiceModel().getClassLoader());\n         try {\n             return invoker.invoke(invocation);\n         } finally {\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ClassLoaderFilterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ClassLoaderFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ClassLoaderFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ClassLoaderFilterTest.java\n@@ -22,6 +22,7 @@\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.model.ServiceModel;\n import org.apache.dubbo.rpc.support.DemoService;\n import org.apache.dubbo.rpc.support.MyInvoker;\n@@ -64,6 +65,9 @@ public Result invoke(Invocation invocation) throws RpcException {\n             }\n         };\n         Invocation invocation = Mockito.mock(Invocation.class);\n+        ServiceModel serviceModel = Mockito.mock(ServiceModel.class);\n+        Mockito.when(serviceModel.getClassLoader()).thenReturn(cl);\n+        Mockito.when(invocation.getServiceModel()).thenReturn(serviceModel);\n         classLoaderFilter.invoke(invoker, invocation);\n     }",
    "output": "Change the way to get classloader in ClassLoaderFilter * Change the way to get classloader in ClassLoaderFilter * Fix ut"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java\n@@ -218,7 +218,7 @@ protected String computeDestination(MeshRuleCache<T> meshRuleCache, String appNa\n         do {\n             BitList<Invoker<T>> result = meshRuleCache.getSubsetInvokers(appName, subset);\n-            if (CollectionUtils.isNotEmpty(result) && !availableInvokers.and(result).isEmpty()) {\n+            if (CollectionUtils.isNotEmpty(result) && !availableInvokers.clone().and(result).isEmpty()) {\n                 return subset;\n             }\n@@ -229,6 +229,9 @@ protected String computeDestination(MeshRuleCache<T> meshRuleCache, String appNa\n             }\n             dubboDestination = dubboRouteDestination.getDestination();\n+            if (dubboDestination == null) {\n+                break;\n+            }\n             subset = dubboDestination.getSubset();\n         } while (true);\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouterTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouterTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouterTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouterTest.java\n@@ -264,8 +264,8 @@ public void testRuleChange() {\n     public void testRoute1() {\n         StandardMeshRuleRouter<Object> meshRuleRouter = new StandardMeshRuleRouter<>(url);\n         BitList<Invoker<Object>> invokers = new BitList<>(Arrays.asList(createInvoker(\"\"), createInvoker(\"unknown\"), createInvoker(\"app1\")));\n-        assertEquals(invokers, meshRuleRouter.route(invokers, null, null, false).getResult());\n-        assertEquals(\"MeshRuleCache has not been built. Skip route.\", meshRuleRouter.route(invokers, null, null, true).getMessage());\n+        assertEquals(invokers, meshRuleRouter.route(invokers.clone(), null, null, false).getResult());\n+        assertEquals(\"MeshRuleCache has not been built. Skip route.\", meshRuleRouter.route(invokers.clone(), null, null, true).getMessage());\n     }\n     @Test\n@@ -292,21 +292,21 @@ public void testRoute2() {\n         rpcInvocation.setServiceName(\"ccc\");\n         rpcInvocation.setAttachment(\"trafficLabel\", \"xxx\");\n-        assertEquals(1, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().size());\n-        assertEquals(isolation, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().get(0));\n-        assertEquals(\"Match App: app1 Subset: isolation \", meshRuleRouter.route(invokers, null, rpcInvocation, true).getMessage());\n+        assertEquals(1, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().size());\n+        assertEquals(isolation, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().get(0));\n+        assertEquals(\"Match App: app1 Subset: isolation \", meshRuleRouter.route(invokers.clone(), null, rpcInvocation, true).getMessage());\n         rpcInvocation.setAttachment(\"trafficLabel\", \"testing-trunk\");\n-        assertEquals(1, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().size());\n-        assertEquals(testingTrunk, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().get(0));\n+        assertEquals(1, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().size());\n+        assertEquals(testingTrunk, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().get(0));\n         rpcInvocation.setAttachment(\"trafficLabel\", null);\n-        assertEquals(1, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().size());\n-        assertEquals(testing, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().get(0));\n+        assertEquals(1, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().size());\n+        assertEquals(testing, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().get(0));\n         rpcInvocation.setServiceName(\"aaa\");\n-        assertEquals(invokers, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult());\n-        assertEquals(\"Empty protection after routed.\", meshRuleRouter.route(invokers, null, rpcInvocation, true).getMessage());\n+        assertEquals(invokers, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult());\n+        assertEquals(\"Empty protection after routed.\", meshRuleRouter.route(invokers.clone(), null, rpcInvocation, true).getMessage());\n         rules = new LinkedList<>();\n         rules.add(yaml.load(rule1));\n@@ -315,23 +315,23 @@ public void testRoute2() {\n         rpcInvocation.setServiceName(\"ccc\");\n         rpcInvocation.setAttachment(\"trafficLabel\", \"xxx\");\n-        assertEquals(1, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().size());\n-        assertEquals(isolation, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().get(0));\n+        assertEquals(1, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().size());\n+        assertEquals(isolation, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().get(0));\n         rpcInvocation.setAttachment(\"trafficLabel\", \"testing-trunk\");\n-        assertEquals(1, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().size());\n-        assertEquals(testingTrunk, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().get(0));\n+        assertEquals(1, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().size());\n+        assertEquals(testingTrunk, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().get(0));\n         rpcInvocation.setAttachment(\"trafficLabel\", \"testing\");\n-        assertEquals(1, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().size());\n-        assertEquals(testing, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().get(0));\n+        assertEquals(1, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().size());\n+        assertEquals(testing, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().get(0));\n         rpcInvocation.setServiceName(\"aaa\");\n-        assertEquals(1, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().size());\n-        assertEquals(testing, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().get(0));\n+        assertEquals(1, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().size());\n+        assertEquals(testing, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().get(0));\n         rpcInvocation.setAttachment(\"trafficLabel\",null);\n-        assertEquals(invokers, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult());\n+        assertEquals(invokers, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult());\n         rules = new LinkedList<>();\n         rules.add(yaml.load(rule1));\n@@ -343,7 +343,7 @@ public void testRoute2() {\n         int testingCount = 0;\n         int isolationCount = 0;\n         for (int i = 0; i < 1000; i++) {\n-            BitList<Invoker<Object>> result = meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult();\n+            BitList<Invoker<Object>> result = meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult();\n             assertEquals(1, result.size());\n             if (result.contains(testing)) {\n                 testingCount++;\n@@ -355,23 +355,23 @@ public void testRoute2() {\n         invokers.removeAll(Arrays.asList(isolation, testingTrunk));\n         for (int i = 0; i < 1000; i++) {\n-            assertEquals(1, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().size());\n-            assertEquals(testing, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().get(0));\n+            assertEquals(1, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().size());\n+            assertEquals(testing, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().get(0));\n         }\n         meshRuleRouter.notify(invokers);\n         for (int i = 0; i < 1000; i++) {\n-            assertEquals(1, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().size());\n-            assertEquals(testing, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult().get(0));\n+            assertEquals(1, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().size());\n+            assertEquals(testing, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult().get(0));\n         }\n         Invoker<Object> mock = createInvoker(Collections.singletonMap(\"env-sign\", \"mock\"));\n         invokers = new BitList<>(Arrays.asList(isolation, testingTrunk, testing, mock));\n         meshRuleRouter.notify(invokers);\n         invokers.removeAll(Arrays.asList(isolation, testingTrunk, testing));\n-        assertEquals(invokers, meshRuleRouter.route(invokers, null, rpcInvocation, false).getResult());\n+        assertEquals(invokers, meshRuleRouter.route(invokers.clone(), null, rpcInvocation, false).getResult());\n     }\n }",
    "output": "Fix ut in MeshRuleRouterTest"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -505,4 +505,9 @@ public interface CommonConstants {\n     String ENABLE_CONNECTIVITY_VALIDATION = \"dubbo.connectivity.validation\";\n     String DUBBO_INTERNAL_APPLICATION = \"DUBBO_INTERNAL_APPLICATION\";\n+\n+    String RETRY_TIMES_KEY = \"retry-times\";\n+    String RETRY_PERIOD_KEY = \"retry-period\";\n+    String SYNC_REPORT_KEY = \"sync-report\";\n+    String CYCLE_REPORT_KEY = \"cycle-report\";\n }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java\n@@ -26,6 +26,10 @@\n import java.util.HashMap;\n import java.util.Map;\n+import static org.apache.dubbo.common.constants.CommonConstants.CYCLE_REPORT_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.RETRY_PERIOD_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.RETRY_TIMES_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.SYNC_REPORT_KEY;\n import static org.apache.dubbo.common.constants.RemotingConstants.BACKUP_KEY;\n import static org.apache.dubbo.common.utils.PojoUtils.updatePropertyIfAbsent;\n import static org.apache.dubbo.common.utils.StringUtils.isEmpty;\n@@ -223,7 +227,7 @@ public void setParameters(Map<String, String> parameters) {\n         this.parameters = parameters;\n     }\n-    @Parameter(key = \"retry-times\")\n+    @Parameter(key = RETRY_TIMES_KEY)\n     public Integer getRetryTimes() {\n         return retryTimes;\n     }\n@@ -232,7 +236,7 @@ public void setRetryTimes(Integer retryTimes) {\n         this.retryTimes = retryTimes;\n     }\n-    @Parameter(key = \"retry-period\")\n+    @Parameter(key = RETRY_PERIOD_KEY)\n     public Integer getRetryPeriod() {\n         return retryPeriod;\n     }\n@@ -241,7 +245,7 @@ public void setRetryPeriod(Integer retryPeriod) {\n         this.retryPeriod = retryPeriod;\n     }\n-    @Parameter(key = \"cycle-report\")\n+    @Parameter(key = CYCLE_REPORT_KEY)\n     public Boolean getCycleReport() {\n         return cycleReport;\n     }\n@@ -250,7 +254,7 @@ public void setCycleReport(Boolean cycleReport) {\n         this.cycleReport = cycleReport;\n     }\n-    @Parameter(key = \"sync-report\")\n+    @Parameter(key = SYNC_REPORT_KEY)\n     public Boolean getSyncReport() {\n         return syncReport;\n     }\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java\n@@ -61,18 +61,18 @@\n import java.util.concurrent.atomic.AtomicLong;\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\n+import static org.apache.dubbo.common.constants.CommonConstants.CYCLE_REPORT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.FILE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n+import static org.apache.dubbo.common.constants.CommonConstants.RETRY_PERIOD_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.RETRY_TIMES_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.SYNC_REPORT_KEY;\n import static org.apache.dubbo.common.utils.StringUtils.replace;\n import static org.apache.dubbo.metadata.report.support.Constants.CACHE;\n-import static org.apache.dubbo.metadata.report.support.Constants.CYCLE_REPORT_KEY;\n import static org.apache.dubbo.metadata.report.support.Constants.DEFAULT_METADATA_REPORT_CYCLE_REPORT;\n import static org.apache.dubbo.metadata.report.support.Constants.DEFAULT_METADATA_REPORT_RETRY_PERIOD;\n import static org.apache.dubbo.metadata.report.support.Constants.DEFAULT_METADATA_REPORT_RETRY_TIMES;\n import static org.apache.dubbo.metadata.report.support.Constants.DUBBO_METADATA;\n-import static org.apache.dubbo.metadata.report.support.Constants.RETRY_PERIOD_KEY;\n-import static org.apache.dubbo.metadata.report.support.Constants.RETRY_TIMES_KEY;\n-import static org.apache.dubbo.metadata.report.support.Constants.SYNC_REPORT_KEY;\n import static org.apache.dubbo.metadata.report.support.Constants.USER_HOME;\n /**\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/Constants.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/Constants.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/Constants.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/Constants.java\n@@ -20,18 +20,10 @@\n public interface Constants {\n     String METADATA_REPORT_KEY = \"metadata\";\n-    String RETRY_TIMES_KEY = \"retry.times\";\n-\n     Integer DEFAULT_METADATA_REPORT_RETRY_TIMES = 100;\n-    String RETRY_PERIOD_KEY = \"retry.period\";\n-\n     Integer DEFAULT_METADATA_REPORT_RETRY_PERIOD = 3000;\n-    String SYNC_REPORT_KEY = \"sync.report\";\n-\n-    String CYCLE_REPORT_KEY = \"cycle.report\";\n-\n     Boolean DEFAULT_METADATA_REPORT_CYCLE_REPORT = true;\n     String USER_HOME = \"user.home\";\ndiff --git a/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java b/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n--- a/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n+++ b/dubbo-metadata/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n@@ -43,7 +43,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n-import static org.apache.dubbo.metadata.report.support.Constants.SYNC_REPORT_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.SYNC_REPORT_KEY;\n import static redis.embedded.RedisServer.newRedisServer;\n public class RedisMetadataReportTest {",
    "output": "Fix the problem that some key values of MetadataReportConfig cannot be obtained"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n@@ -42,6 +42,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.LIVENESS_PROBE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.METADATA_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.METADATA_SERVICE_PORT_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.METADATA_SERVICE_PROTOCOL_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.READINESS_PROBE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.REGISTRY_LOCAL_FILE_CACHE_ENABLED;\n import static org.apache.dubbo.common.constants.CommonConstants.SHUTDOWN_WAIT_KEY;\n@@ -532,7 +533,7 @@ public void setMetadataServicePort(Integer metadataServicePort) {\n         this.metadataServicePort = metadataServicePort;\n     }\n-    @Parameter(key = METADATA_SERVICE_PORT_KEY)\n+    @Parameter(key = METADATA_SERVICE_PROTOCOL_KEY)\n     public String getMetadataServiceProtocol() {\n         return metadataServiceProtocol;\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java\n@@ -183,7 +183,6 @@ private ProtocolConfig generateMetadataProtocol() {\n                     if (it.hasNext()) {\n                         String addr = it.next().getAddress();\n                         String rawPort = addr.substring(addr.indexOf(\":\") + 1);\n-                        logger.info(\"Using \" + specifiedProtocol +\" protocol to export MetadataService on port \" + rawPort);\n                         protocolConfig.setPort(Integer.parseInt(rawPort));\n                     }\n                 }\n@@ -198,7 +197,7 @@ private ProtocolConfig generateMetadataProtocol() {\n             protocolConfig.setPort(-1);\n         }\n-        logger.info(\"Using dubbo protocol to export metadata service on port \" + protocolConfig.getPort());\n+        logger.info(\"Using \" + specifiedProtocol + \" protocol to export metadata service on port \" + protocolConfig.getPort());\n         return protocolConfig;\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -92,6 +92,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.LIVENESS_PROBE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.METADATA_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.METADATA_SERVICE_PORT_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.METADATA_SERVICE_PROTOCOL_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PID_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.READINESS_PROBE_KEY;\n@@ -180,6 +181,7 @@ public void testAppendConfig() {\n         applicationConfig.setPublishInterface(false);\n         applicationConfig.setProtocol(\"dubbo\");\n         applicationConfig.setMetadataServicePort(88888);\n+        applicationConfig.setMetadataServiceProtocol(\"tri\");\n         applicationConfig.setLivenessProbe(\"livenessProbe\");\n         applicationConfig.setReadinessProbe(\"readinessProb\");\n         applicationConfig.setStartupProbe(\"startupProbe\");\n@@ -320,6 +322,8 @@ public void testAppendConfig() {\n         Assertions.assertTrue(serviceMetadata.getAttachments().containsKey(REGISTRY_PUBLISH_INTERFACE_KEY));\n         Assertions.assertEquals(applicationConfig.getMetadataServicePort().toString(),\n             serviceMetadata.getAttachments().get(METADATA_SERVICE_PORT_KEY));\n+        Assertions.assertEquals(applicationConfig.getMetadataServiceProtocol().toString(),\n+            serviceMetadata.getAttachments().get(METADATA_SERVICE_PROTOCOL_KEY));\n         Assertions.assertEquals(applicationConfig.getLivenessProbe(),\n             serviceMetadata.getAttachments().get(LIVENESS_PROBE_KEY));\n         Assertions.assertEquals(applicationConfig.getReadinessProbe(),\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n@@ -116,10 +116,7 @@ public static String getMetadataServiceParameter(URL url) {\n         if (url == null) {\n             return \"\";\n         }\n-        url = url.removeParameter(APPLICATION_KEY);\n-        url = url.removeParameter(GROUP_KEY);\n-        url = url.removeParameter(DEPRECATED_KEY);\n-        url = url.removeParameter(TIMESTAMP_KEY);\n+        url = url.removeParameters(APPLICATION_KEY, GROUP_KEY, DEPRECATED_KEY, TIMESTAMP_KEY);\n         Map<String, String> params = getParams(url);\n         if (params.isEmpty()) {\n@@ -278,7 +275,7 @@ public static void refreshMetadataAndInstance(ServiceInstance serviceInstance) {\n                 LOGGER.warn(\"Refreshing of service instance started, but instance hasn't been registered yet.\");\n                 instance = serviceInstance;\n             }\n-            // copy instance again, in case the same instance accidently shared among registries\n+            // copy instance again, in case the same instance accidentally shared among registries\n             instance = new DefaultServiceInstance((DefaultServiceInstance) instance);\n             calInstanceRevision(serviceDiscovery, instance);\n             customizeInstance(instance);\ndiff --git a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/util/CuratorFrameworkUtils.java b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/util/CuratorFrameworkUtils.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/util/CuratorFrameworkUtils.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/util/CuratorFrameworkUtils.java\n@@ -107,7 +107,7 @@ public static org.apache.curator.x.discovery.ServiceInstance<ZookeeperInstance>\n         int port = serviceInstance.getPort();\n         Map<String, String> metadata = serviceInstance.getSortedMetadata();\n         String id = generateId(host, port);\n-        ZookeeperInstance zookeeperInstance = new ZookeeperInstance(null, serviceName, metadata);\n+        ZookeeperInstance zookeeperInstance = new ZookeeperInstance(id, serviceName, metadata);\n         try {\n             builder = builder()\n                 .id(id)",
    "output": "Fix the issue that ApplicationConfig#getmetadataserviceprotocol method maps the wrong key"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java\n@@ -140,7 +140,7 @@ public ProviderModel getProviderModel() {\n     protected RpcInvocation buildInvocation(Metadata metadata) {\n         RpcInvocation inv = new RpcInvocation(getUrl().getServiceModel(),\n             getMethodName(), getServiceDescriptor().getServiceName(),\n-            getUrl().getProtocolServiceKey(), getMethodDescriptor().getParameterClasses(), new Object[0]);\n+            getUrl().getProtocolServiceKey(), getMethodDescriptor().getRealParameterClasses(), new Object[0]);\n         inv.setTargetServiceUniqueName(getUrl().getServiceKey());\n         inv.setReturnTypes(getMethodDescriptor().getReturnTypes());",
    "output": "Fix method sigs that may not pass original check"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyBackedChannelBuffer.java b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyBackedChannelBuffer.java\n--- a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyBackedChannelBuffer.java\n+++ b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyBackedChannelBuffer.java\n@@ -28,7 +28,7 @@\n public class NettyBackedChannelBuffer implements ChannelBuffer {\n-    private org.jboss.netty.buffer.ChannelBuffer buffer;\n+    private final org.jboss.netty.buffer.ChannelBuffer buffer;\n     public NettyBackedChannelBuffer(org.jboss.netty.buffer.ChannelBuffer buffer) {\n         Assert.notNull(buffer, \"buffer == null\");\n@@ -116,9 +116,12 @@ public void setBytes(int index, ByteBuffer src) {\n     @Override\n     public void setBytes(int index, ChannelBuffer src, int srcIndex, int length) {\n+        if (length > src.readableBytes()) {\n+            throw new IndexOutOfBoundsException();\n+        }\n         // careful\n         byte[] data = new byte[length];\n-        buffer.getBytes(srcIndex, data, 0, length);\n+        src.getBytes(srcIndex, data, 0, length);\n         setBytes(index, data, 0, length);\n     }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty/src/test/java/org/apache/dubbo/remoting/transport/netty/NettyBackedChannelBufferTest.java b/dubbo-remoting/dubbo-remoting-netty/src/test/java/org/apache/dubbo/remoting/transport/netty/NettyBackedChannelBufferTest.java\n--- a/dubbo-remoting/dubbo-remoting-netty/src/test/java/org/apache/dubbo/remoting/transport/netty/NettyBackedChannelBufferTest.java\n+++ b/dubbo-remoting/dubbo-remoting-netty/src/test/java/org/apache/dubbo/remoting/transport/netty/NettyBackedChannelBufferTest.java\n@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.remoting.transport.netty;\n+\n+\n+import org.apache.dubbo.remoting.buffer.ChannelBuffer;\n+import org.jboss.netty.buffer.ChannelBuffers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class NettyBackedChannelBufferTest {\n+\n+    private static final int CAPACITY = 4096;\n+\n+    private ChannelBuffer buffer;\n+\n+    @BeforeEach\n+    public void init() {\n+        buffer = new NettyBackedChannelBuffer(ChannelBuffers.dynamicBuffer(CAPACITY));\n+    }\n+\n+    @AfterEach\n+    public void dispose() {\n+        buffer = null;\n+    }\n+\n+    @Test\n+    public void testBufferTransfer() {\n+        byte[] tmp1 = {1, 2};\n+        byte[] tmp2 = {3, 4};\n+        ChannelBuffer source = new NettyBackedChannelBuffer(ChannelBuffers.dynamicBuffer(2));\n+        source.writeBytes(tmp1);\n+        buffer.writeBytes(tmp2);\n+\n+        assertEquals(2, buffer.readableBytes());\n+        source.setBytes(0, tmp1, 0, 2);\n+\n+        buffer.setBytes(0, source, 0, 2);\n+        assertEquals(2, buffer.readableBytes());\n+\n+        byte[] actual = new byte[2];\n+        buffer.getBytes(0, actual);\n+        assertEquals(1, actual[0]);\n+        assertEquals(2, actual[1]);\n+    }\n+}\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java\n@@ -30,7 +30,7 @@\n public class NettyBackedChannelBuffer implements ChannelBuffer {\n-    private ByteBuf buffer;\n+    private final ByteBuf buffer;\n     public NettyBackedChannelBuffer(ByteBuf buffer) {\n         Assert.notNull(buffer, \"buffer == null\");\n@@ -115,9 +115,12 @@ public void setBytes(int index, ByteBuffer src) {\n     @Override\n     public void setBytes(int index, ChannelBuffer src, int srcIndex, int length) {\n+        if (length > src.readableBytes()) {\n+            throw new IndexOutOfBoundsException();\n+        }\n         // careful\n         byte[] data = new byte[length];\n-        buffer.getBytes(srcIndex, data, 0, length);\n+        src.getBytes(srcIndex, data, 0, length);\n         setBytes(index, data, 0, length);\n     }\n@@ -155,7 +158,6 @@ public int arrayOffset() {\n     // AbstractChannelBuffer\n-\n     @Override\n     public void clear() {\n         buffer.clear();\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBufferTest.java b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBufferTest.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBufferTest.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBufferTest.java\n@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.remoting.transport.netty4;\n+\n+\n+import io.netty.buffer.Unpooled;\n+import org.apache.dubbo.remoting.buffer.ChannelBuffer;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class NettyBackedChannelBufferTest {\n+\n+    private static final int CAPACITY = 4096;\n+\n+    private ChannelBuffer buffer;\n+\n+    @BeforeEach\n+    public void init() {\n+        buffer = new NettyBackedChannelBuffer(Unpooled.buffer(CAPACITY, CAPACITY * 2));\n+    }\n+\n+    @AfterEach\n+    public void dispose() {\n+        buffer = null;\n+    }\n+\n+    @Test\n+    public void testBufferTransfer() {\n+        byte[] tmp1 = {1, 2};\n+        byte[] tmp2 = {3, 4};\n+        ChannelBuffer source = new NettyBackedChannelBuffer(Unpooled.buffer(2, 4));\n+        source.writeBytes(tmp1);\n+        buffer.writeBytes(tmp2);\n+\n+        assertEquals(2, buffer.readableBytes());\n+        source.setBytes(0, tmp1, 0, 2);\n+\n+        buffer.setBytes(0, source, 0, 2);\n+        assertEquals(2, buffer.readableBytes());\n+\n+        byte[] actual = new byte[2];\n+        buffer.getBytes(0, actual);\n+        assertEquals(1, actual[0]);\n+        assertEquals(2, actual[1]);\n+    }\n+\n+}",
    "output": "Fix The logic of setBytes does not meet expectations"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n@@ -129,7 +129,10 @@ public String getSide() {\n     @Override\n     public String getPath() {\n-        MetadataInfo.ServiceInfo serviceInfo = metadataInfo.getServiceInfo(getProtocolServiceKey());\n+        MetadataInfo.ServiceInfo serviceInfo = null;\n+        if (StringUtils.isNotEmpty(getProtocolServiceKey())) {\n+            serviceInfo = metadataInfo.getServiceInfo(getProtocolServiceKey());\n+        }\n         if (serviceInfo == null) {\n             return getServiceInterface();\n         }\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/LazyConnectExchangeClient.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/LazyConnectExchangeClient.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/LazyConnectExchangeClient.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/LazyConnectExchangeClient.java\n@@ -58,7 +58,7 @@ final class LazyConnectExchangeClient implements ExchangeClient {\n      */\n     private final boolean initialState;\n     private volatile ExchangeClient client;\n-    private AtomicLong warningCount = new AtomicLong(0);\n+    private final AtomicLong warningCount = new AtomicLong(0);\n     public LazyConnectExchangeClient(URL url, ExchangeHandler requestHandler) {\n         // lazy connect, need set send.reconnect = true, to avoid channel bad status.",
    "output": "Fix when consumer shutdown occurs npe"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n@@ -130,7 +130,10 @@ public String getSide() {\n     @Override\n     public String getPath() {\n-        MetadataInfo.ServiceInfo serviceInfo = metadataInfo.getServiceInfo(getProtocolServiceKey());\n+        MetadataInfo.ServiceInfo serviceInfo = null;\n+        if (StringUtils.isNotEmpty(getProtocolServiceKey())) {\n+            serviceInfo = metadataInfo.getServiceInfo(getProtocolServiceKey());\n+        }\n         if (serviceInfo == null) {\n             return getServiceInterface();\n         }\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/LazyConnectExchangeClient.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/LazyConnectExchangeClient.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/LazyConnectExchangeClient.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/LazyConnectExchangeClient.java\n@@ -58,7 +58,7 @@ final class LazyConnectExchangeClient implements ExchangeClient {\n      */\n     private final boolean initialState;\n     private volatile ExchangeClient client;\n-    private AtomicLong warningCount = new AtomicLong(0);\n+    private final AtomicLong warningCount = new AtomicLong(0);\n     public LazyConnectExchangeClient(URL url, ExchangeHandler requestHandler) {\n         // lazy connect, need set send.reconnect = true, to avoid channel bad status.",
    "output": "Fix when consumer shutdown occurs npe"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n@@ -170,6 +170,9 @@ public List<Invoker<T>> route(URL url, BitList<Invoker<T>> availableInvokers, In\n         }\n+        if (routers.isEmpty()) {\n+            return resultInvokers;\n+        }\n         List<Invoker<T>> commonRouterResult = new ArrayList<>(resultInvokers);\n         // 2. route common router\n         for (Router router : routers) {\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/BitList.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/BitList.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/BitList.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/BitList.java\n@@ -60,7 +60,11 @@ public BitList(List<E> originList) {\n     }\n     public BitList(List<E> originList, boolean empty) {\n-        this.originList = originList;\n+        if (originList instanceof BitList) {\n+            this.originList = ((BitList<E>) originList).getOriginList();\n+        } else {\n+            this.originList = originList;\n+        }\n         this.rootSet = new BitSet();\n         if (!empty) {\n             this.rootSet.set(0, originList.size());\n@@ -82,6 +86,18 @@ public void addIndex(int index) {\n         this.rootSet.set(index);\n     }\n+    public int totalSetSize() {\n+        return this.originList.size();\n+    }\n+\n+    public boolean indexExist(int index) {\n+        return this.rootSet.get(index);\n+    }\n+\n+    public E getByIndex(int index) {\n+        return this.originList.get(index);\n+    }\n+\n     /**\n      * And operation between two bitList. Return a new cloned list.\n      * TailList in source bitList will be totally saved even if it is not appeared in the target bitList.\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouterResult.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouterResult.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouterResult.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouterResult.java\n@@ -27,18 +27,48 @@ public StateRouterResult(BitList<T> result) {\n         this.message = null;\n     }\n+    public StateRouterResult(BitList<T> invokers, BitList<T> routedResult) {\n+        this.needContinueRoute = true;\n+        this.result = invokers.and(routedResult);\n+        this.message = null;\n+    }\n+\n     public StateRouterResult(BitList<T> result, String message) {\n         this.needContinueRoute = true;\n         this.result = result;\n         this.message = message;\n     }\n+    public StateRouterResult(BitList<T> invokers, BitList<T> routedResult, String message) {\n+        this.needContinueRoute = true;\n+        this.result = invokers.and(routedResult);\n+        this.message = message;\n+    }\n+\n+    public StateRouterResult(boolean needContinueRoute, BitList<T> result) {\n+        this.needContinueRoute = needContinueRoute;\n+        this.result = result;\n+        this.message = null;\n+    }\n+\n+    public StateRouterResult(boolean needContinueRoute, BitList<T> invokers, BitList<T> routedResult) {\n+        this.needContinueRoute = needContinueRoute;\n+        this.result = invokers.and(routedResult);\n+        this.message = null;\n+    }\n+\n     public StateRouterResult(boolean needContinueRoute, BitList<T> result, String message) {\n         this.needContinueRoute = needContinueRoute;\n         this.result = result;\n         this.message = message;\n     }\n+    public StateRouterResult(boolean needContinueRoute, BitList<T> invokers, BitList<T> routedResult, String message) {\n+        this.needContinueRoute = needContinueRoute;\n+        this.result = invokers.and(routedResult);\n+        this.message = message;\n+    }\n+\n     public boolean isNeedContinueRoute() {\n         return needContinueRoute;\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleServiceRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleServiceRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleServiceRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleServiceRepository.java\n@@ -150,8 +150,10 @@ public ServiceDescriptor registerService(String path, Class<?> interfaceClass) {\n     @Deprecated\n     public void reRegisterProvider(String newServiceKey, String serviceKey) {\n         ProviderModel providerModel = this.providers.get(serviceKey);\n+        frameworkServiceRepository.unregisterProvider(providerModel);\n         providerModel.setServiceKey(newServiceKey);\n         this.providers.putIfAbsent(newServiceKey, providerModel);\n+        frameworkServiceRepository.registerProvider(providerModel);\n         this.providers.remove(serviceKey);\n     }",
    "output": "Fix Update the version of log4j for bug fixes"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/javassist/JavassistProxyFactory.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/javassist/JavassistProxyFactory.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/javassist/JavassistProxyFactory.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/javassist/JavassistProxyFactory.java\n@@ -52,7 +52,7 @@ public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n                 logger.error(\"Failed to generate proxy by Javassist failed. Fallback to use JDK proxy is also failed. \" +\n                     \"Interfaces: \" + Arrays.toString(interfaces) + \" Javassist Error.\", fromJavassist);\n                 logger.error(\"Failed to generate proxy by Javassist failed. Fallback to use JDK proxy is also failed. \" +\n-                    \"Interfaces: \" + Arrays.toString(interfaces) + \" JDK Error.\", fromJavassist);\n+                    \"Interfaces: \" + Arrays.toString(interfaces) + \" JDK Error.\", fromJdk);\n                 throw fromJavassist;\n             }\n         }\n@@ -83,7 +83,7 @@ protected Object doInvoke(T proxy, String methodName,\n                 logger.error(\"Failed to generate proxy by Javassist failed. Fallback to use JDK proxy is also failed. \" +\n                     \"Interfaces: \" + type + \" Javassist Error.\", fromJavassist);\n                 logger.error(\"Failed to generate proxy by Javassist failed. Fallback to use JDK proxy is also failed. \" +\n-                    \"Interfaces: \" + type + \" JDK Error.\", fromJavassist);\n+                    \"Interfaces: \" + type + \" JDK Error.\", fromJdk);\n                 throw fromJavassist;\n             }\n         }",
    "output": "Fix log when JDK Proxy factory occurred exception"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java\n@@ -28,7 +28,9 @@ private StreamUtils() {\n     public static InputStream limitedInputStream(final InputStream is, final int limit) throws IOException {\n         return new InputStream() {\n-            private int mPosition = 0, mMark = 0, mLimit = Math.min(limit, is.available());\n+            private int mPosition = 0;\n+            private int mMark = 0;\n+            private final int mLimit = Math.min(limit, is.available());\n             @Override\n             public int read() throws IOException {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/io/UnsafeByteArrayOutputStream.java b/dubbo-common/src/main/java/org/apache/dubbo/common/io/UnsafeByteArrayOutputStream.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/io/UnsafeByteArrayOutputStream.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/io/UnsafeByteArrayOutputStream.java\n@@ -42,12 +42,12 @@ public UnsafeByteArrayOutputStream(int size) {\n     @Override\n     public void write(int b) {\n-        int newcount = mCount + 1;\n-        if (newcount > mBuffer.length) {\n-            mBuffer = Bytes.copyOf(mBuffer, Math.max(mBuffer.length << 1, newcount));\n+        int newCount = mCount + 1;\n+        if (newCount > mBuffer.length) {\n+            mBuffer = Bytes.copyOf(mBuffer, Math.max(mBuffer.length << 1, newCount));\n         }\n         mBuffer[mCount] = (byte) b;\n-        mCount = newcount;\n+        mCount = newCount;\n     }\n     @Override\n@@ -58,12 +58,12 @@ public void write(byte[] b, int off, int len) {\n         if (len == 0) {\n             return;\n         }\n-        int newcount = mCount + len;\n-        if (newcount > mBuffer.length) {\n-            mBuffer = Bytes.copyOf(mBuffer, Math.max(mBuffer.length << 1, newcount));\n+        int newCount = mCount + len;\n+        if (newCount > mBuffer.length) {\n+            mBuffer = Bytes.copyOf(mBuffer, Math.max(mBuffer.length << 1, newCount));\n         }\n         System.arraycopy(b, off, mBuffer, mCount, len);\n-        mCount = newcount;\n+        mCount = newCount;\n     }\n     public int size() {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/io/UnsafeStringWriter.java b/dubbo-common/src/main/java/org/apache/dubbo/common/io/UnsafeStringWriter.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/io/UnsafeStringWriter.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/io/UnsafeStringWriter.java\n@@ -23,7 +23,7 @@\n  * Thread-unsafe StringWriter.\n  */\n public class UnsafeStringWriter extends Writer {\n-    private StringBuilder mBuffer;\n+    private final StringBuilder mBuffer;\n     public UnsafeStringWriter() {\n         lock = mBuffer = new StringBuilder();\n@@ -34,7 +34,7 @@ public UnsafeStringWriter(int size) {\n             throw new IllegalArgumentException(\"Negative buffer size\");\n         }\n-        lock = mBuffer = new StringBuilder();\n+        lock = mBuffer = new StringBuilder(size);\n     }\n     @Override\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/io/UnsafeStringWriterTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/io/UnsafeStringWriterTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/io/UnsafeStringWriterTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/io/UnsafeStringWriterTest.java\n@@ -39,9 +39,7 @@ public void testWrite() {\n     @Test\n     public void testNegativeSize() {\n-        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n-            new UnsafeStringWriter(-1);\n-        });\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> new UnsafeStringWriter(-1));\n     }\n     @Test",
    "output": "Fix UnsafeStringWriter constructor"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHeaderEnum.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHeaderEnum.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHeaderEnum.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHeaderEnum.java\n@@ -37,10 +37,7 @@ public enum TripleHeaderEnum {\n     APPLICATION_GRPC(\"application/grpc\"),\n     GRPC_ENCODING(\"grpc-encoding\"),\n     GRPC_ACCEPT_ENCODING(\"grpc-accept-encoding\"),\n-    TRICE_ID_KEY(\"tri-trace-traceid\"),\n-    RPC_ID_KEY(\"tri-trace-rpcid\"),\n     CONSUMER_APP_NAME_KEY(\"tri-consumer-appname\"),\n-    UNIT_INFO_KEY(\"tri-unit-info\"),\n     SERVICE_VERSION(\"tri-service-version\"),\n     SERVICE_GROUP(\"tri-service-group\");",
    "output": "Remove unused Tri Header Enum"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/dubbo/DefaultHessian2FactoryInitializer.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/dubbo/DefaultHessian2FactoryInitializer.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/dubbo/DefaultHessian2FactoryInitializer.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/dubbo/DefaultHessian2FactoryInitializer.java\n@@ -24,7 +24,7 @@ public class DefaultHessian2FactoryInitializer extends AbstractHessian2FactoryIn\n     @Override\n     protected SerializerFactory createSerializerFactory() {\n         Hessian2SerializerFactory hessian2SerializerFactory = new Hessian2SerializerFactory();\n-        hessian2SerializerFactory.getClassFactory().allow(RuntimeException.class.getName());\n+        hessian2SerializerFactory.setAllowNonSerializable(Boolean.parseBoolean(System.getProperty(\"dubbo.hessian.allowNonSerializable\", \"false\")));\n         hessian2SerializerFactory.getClassFactory().allow(\"org.apache.dubbo.*\");\n         return hessian2SerializerFactory;\n     }\ndiff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/dubbo/WhitelistHessian2FactoryInitializer.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/dubbo/WhitelistHessian2FactoryInitializer.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/dubbo/WhitelistHessian2FactoryInitializer.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/dubbo/WhitelistHessian2FactoryInitializer.java\n@@ -47,7 +47,7 @@ public SerializerFactory createSerializerFactory() {\n                 }\n             }\n         }\n-        serializerFactory.getClassFactory().allow(RuntimeException.class.getName());\n+        serializerFactory.setAllowNonSerializable(Boolean.parseBoolean(System.getProperty(\"dubbo.hessian.allowNonSerializable\", \"false\")));\n         serializerFactory.getClassFactory().allow(\"org.apache.dubbo.*\");\n         return serializerFactory;\n     }",
    "output": "Add system properties to support allow non-serializable class"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ProviderConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ProviderConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ProviderConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ProviderConfig.java\n@@ -351,41 +351,6 @@ public void setStatus(String status) {\n         this.status = status;\n     }\n-    @Override\n-    public String getCluster() {\n-        return super.getCluster();\n-    }\n-\n-    @Override\n-    public Integer getConnections() {\n-        return super.getConnections();\n-    }\n-\n-    @Override\n-    public Integer getTimeout() {\n-        return super.getTimeout();\n-    }\n-\n-    @Override\n-    public Integer getRetries() {\n-        return super.getRetries();\n-    }\n-\n-    @Override\n-    public String getLoadbalance() {\n-        return super.getLoadbalance();\n-    }\n-\n-    @Override\n-    public Boolean isAsync() {\n-        return super.isAsync();\n-    }\n-\n-    @Override\n-    public Integer getActives() {\n-        return super.getActives();\n-    }\n-\n     public String getTransporter() {\n         return transporter;\n     }",
    "output": "Remove duplicate code of ProviderConfig"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -755,17 +755,17 @@ private Integer findConfigedPorts(ProtocolConfig protocolConfig,\n             }\n         }\n+        // save bind port, used as url's key later\n+        map.put(BIND_PORT_KEY, String.valueOf(portToBind));\n+\n         // registry port, not used as bind port by default\n         String portToRegistryStr = getValueFromConfig(protocolConfig, DUBBO_PORT_TO_REGISTRY);\n         Integer portToRegistry = parsePort(portToRegistryStr);\n-        if (portToRegistry != null) {\n-            portToBind = portToRegistry;\n+        if (portToRegistry == null) {\n+            portToRegistry = portToBind;\n         }\n-        // save bind port, used as url's key later\n-        map.put(BIND_PORT_KEY, String.valueOf(portToBind));\n-\n-        return portToBind;\n+        return portToRegistry;\n     }\n     private Integer parsePort(String configPort) {",
    "output": "Fix custom registry port"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n@@ -76,7 +76,7 @@ public abstract class CacheableFailbackRegistry extends FailbackRegistry {\n     private Semaphore semaphore = new Semaphore(1);\n     private final Map<String, String> extraParameters;\n-    protected final Map<URL, Map<String, ServiceAddressURL>> stringUrls = new HashMap<>();\n+    protected final Map<URL, Map<String, ServiceAddressURL>> stringUrls = new ConcurrentHashMap<>();\n     public CacheableFailbackRegistry(URL url) {\n         super(url);",
    "output": "Change to ConcurrentHashMap for CacheableFailbackRegistry"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ExtensionLoaderTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ExtensionLoaderTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ExtensionLoaderTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ExtensionLoaderTest.java\n@@ -43,9 +43,9 @@\n import org.apache.dubbo.common.extension.ext2.Ext2;\n import org.apache.dubbo.common.extension.ext6_wrap.WrappedExt;\n import org.apache.dubbo.common.extension.ext6_wrap.WrappedExtWrapper;\n-import org.apache.dubbo.common.extension.ext6_wrap.impl.Ext5Impl1;\n-import org.apache.dubbo.common.extension.ext6_wrap.impl.Ext5Wrapper1;\n-import org.apache.dubbo.common.extension.ext6_wrap.impl.Ext5Wrapper2;\n+import org.apache.dubbo.common.extension.ext6_wrap.impl.Ext6Impl1;\n+import org.apache.dubbo.common.extension.ext6_wrap.impl.Ext6Wrapper1;\n+import org.apache.dubbo.common.extension.ext6_wrap.impl.Ext6Wrapper2;\n import org.apache.dubbo.common.extension.ext7.InitErrorExt;\n import org.apache.dubbo.common.extension.ext8_add.AddExt1;\n import org.apache.dubbo.common.extension.ext8_add.AddExt2;\n@@ -157,7 +157,7 @@ public void test_getExtension() {\n     @Test\n     public void test_getExtension_WithWrapper() {\n         WrappedExt impl1 = getExtensionLoader(WrappedExt.class).getExtension(\"impl1\");\n-        assertThat(impl1, anyOf(instanceOf(Ext5Wrapper1.class), instanceOf(Ext5Wrapper2.class)));\n+        assertThat(impl1, anyOf(instanceOf(Ext6Wrapper1.class), instanceOf(Ext6Wrapper2.class)));\n         assertThat(impl1, instanceOf(WrappedExtWrapper.class));\n         // get origin instance from wrapper\n         WrappedExt originImpl1 = impl1;\n@@ -167,22 +167,22 @@ public void test_getExtension_WithWrapper() {\n         // test unwrapped instance\n         WrappedExt unwrappedImpl1 = getExtensionLoader(WrappedExt.class).getExtension(\"impl1\", false);\n-        assertThat(unwrappedImpl1, instanceOf(Ext5Impl1.class));\n+        assertThat(unwrappedImpl1, instanceOf(Ext6Impl1.class));\n         assertNotSame(unwrappedImpl1, impl1);\n         assertSame(unwrappedImpl1, originImpl1);\n         WrappedExt impl2 = getExtensionLoader(WrappedExt.class).getExtension(\"impl2\");\n-        assertThat(impl2, anyOf(instanceOf(Ext5Wrapper1.class), instanceOf(Ext5Wrapper2.class)));\n+        assertThat(impl2, anyOf(instanceOf(Ext6Wrapper1.class), instanceOf(Ext6Wrapper2.class)));\n         URL url = new ServiceConfigURL(\"p1\", \"1.2.3.4\", 1010, \"path1\");\n-        int echoCount1 = Ext5Wrapper1.echoCount.get();\n-        int echoCount2 = Ext5Wrapper2.echoCount.get();\n+        int echoCount1 = Ext6Wrapper1.echoCount.get();\n+        int echoCount2 = Ext6Wrapper2.echoCount.get();\n-        assertEquals(\"Ext5Impl1-echo\", impl1.echo(url, \"ha\"));\n-        assertEquals(echoCount1 + 1, Ext5Wrapper1.echoCount.get());\n-        assertEquals(echoCount2 + 1, Ext5Wrapper2.echoCount.get());\n+        assertEquals(\"Ext6Impl1-echo\", impl1.echo(url, \"ha\"));\n+        assertEquals(echoCount1 + 1, Ext6Wrapper1.echoCount.get());\n+        assertEquals(echoCount2 + 1, Ext6Wrapper2.echoCount.get());\n     }\n     @Test\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Impl1.java b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Impl1.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Impl1.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Impl1.java\n@@ -19,8 +19,8 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.extension.ext6_wrap.WrappedExt;\n-public class Ext5Impl1 implements WrappedExt {\n+public class Ext6Impl1 implements WrappedExt {\n     public String echo(URL url, String s) {\n-        return \"Ext5Impl1-echo\";\n+        return \"Ext6Impl1-echo\";\n     }\n }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Impl2.java b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Impl2.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Impl2.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Impl2.java\n@@ -19,8 +19,8 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.extension.ext6_wrap.WrappedExt;\n-public class Ext5Impl2 implements WrappedExt {\n+public class Ext6Impl2 implements WrappedExt {\n     public String echo(URL url, String s) {\n-        return \"Ext5Impl2-echo\";\n+        return \"Ext6Impl2-echo\";\n     }\n }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Wrapper1.java b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Wrapper1.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Wrapper1.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Wrapper1.java\n@@ -22,11 +22,11 @@\n import java.util.concurrent.atomic.AtomicInteger;\n-public class Ext5Wrapper1 implements WrappedExt, WrappedExtWrapper {\n+public class Ext6Wrapper1 implements WrappedExt, WrappedExtWrapper {\n     public static AtomicInteger echoCount = new AtomicInteger();\n     WrappedExt origin;\n-    public Ext5Wrapper1(WrappedExt origin) {\n+    public Ext6Wrapper1(WrappedExt origin) {\n         this.origin = origin;\n     }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Wrapper2.java b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Wrapper2.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Wrapper2.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/ext6_wrap/impl/Ext6Wrapper2.java\n@@ -22,11 +22,11 @@\n import java.util.concurrent.atomic.AtomicInteger;\n-public class Ext5Wrapper2 implements WrappedExt, WrappedExtWrapper {\n+public class Ext6Wrapper2 implements WrappedExt, WrappedExtWrapper {\n     public static AtomicInteger echoCount = new AtomicInteger();\n     WrappedExt origin;\n-    public Ext5Wrapper2(WrappedExt origin) {\n+    public Ext6Wrapper2(WrappedExt origin) {\n         this.origin = origin;\n     }",
    "output": "Fix wrong class name in package extension/ext6_wrap"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/InvokeTelnet.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/InvokeTelnet.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/InvokeTelnet.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/InvokeTelnet.java\n@@ -19,6 +19,7 @@\n import com.alibaba.fastjson.JSON;\n import io.netty.channel.Channel;\n import io.netty.util.AttributeKey;\n+import org.apache.dubbo.common.utils.ArrayUtils;\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n@@ -40,7 +41,8 @@\n import static org.apache.dubbo.common.utils.PojoUtils.realize;\n @Cmd(name = \"invoke\", summary = \"Invoke the service method.\", example = {\n-    \"invoke IHelloService.sayHello(\\\"xxxx\\\")\"\n+    \"invoke IHelloService.sayHello(\\\"xxxx\\\")\",\n+    \"invoke sayHello(\\\"xxxx\\\")\"\n })\n public class InvokeTelnet implements BaseCommand {\n     public static final AttributeKey<String> INVOKE_MESSAGE_KEY = AttributeKey.valueOf(\"telnet.invoke.method.message\");\n@@ -55,13 +57,13 @@ public InvokeTelnet(FrameworkModel frameworkModel) {\n     @Override\n     public String execute(CommandContext commandContext, String[] args) {\n-        if (args == null || args.length == 0) {\n+        if (ArrayUtils.isEmpty(args)) {\n             return \"Please input method name, eg: \\r\\ninvoke xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\\r\\n\" +\n                 \"invoke XxxService.xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\\r\\n\" +\n                 \"invoke com.xxx.XxxService.xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\";\n         }\n         Channel channel = commandContext.getRemote();\n-        String service = channel.attr(ChangeTelnet.SERVICE_KEY).get();\n+        String service = channel.attr(ChangeTelnet.SERVICE_KEY) != null ? channel.attr(ChangeTelnet.SERVICE_KEY).get() : null;\n         String message = args[0];\n         int i = message.indexOf(\"(\");\n@@ -78,6 +80,11 @@ public String execute(CommandContext commandContext, String[] args) {\n             method = method.substring(i + 1).trim();\n         }\n+        if (StringUtils.isEmpty(service)) {\n+            return \"If you want to invoke like [invoke sayHello(\\\"xxxx\\\")], please execute cd command first,\" +\n+                \" or you can execute it like [invoke IHelloService.sayHello(\\\"xxxx\\\")]\";\n+        }\n+\n         List<Object> list;\n         try {\n             list = JSON.parseArray(\"[\" + param + \"]\", Object.class);\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/InvokeTelnetTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/InvokeTelnetTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/InvokeTelnetTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/InvokeTelnetTest.java\n@@ -67,6 +67,14 @@ public void after() {\n         reset(mockChannel, mockCommandContext);\n     }\n+    @Test\n+    public void testInvokeWithoutServicePrefixAndWithoutDefaultService() throws RemotingException {\n+        registerProvider(DemoService.class.getName(), new DemoServiceImpl(), DemoService.class);\n+        String result = invoke.execute(mockCommandContext, new String[]{\"echo(\\\"ok\\\")\"});\n+        assertTrue(result.contains(\"If you want to invoke like [invoke sayHello(\\\"xxxx\\\")], please execute cd command first,\" +\n+            \" or you can execute it like [invoke IHelloService.sayHello(\\\"xxxx\\\")]\"));\n+    }\n+\n     @Test\n     public void testInvokeDefaultService() throws RemotingException {\n         defaultAttributeMap.attr(ChangeTelnet.SERVICE_KEY).set(DemoService.class.getName());\n@@ -115,7 +123,7 @@ public void testInvokeByPassingNullValue() {\n     @Test\n     public void testInvokeByPassingEnumValue() throws RemotingException {\n-        defaultAttributeMap.attr(ChangeTelnet.SERVICE_KEY).set(null);\n+        defaultAttributeMap.attr(ChangeTelnet.SERVICE_KEY).set(DemoService.class.getName());\n         defaultAttributeMap.attr(SelectTelnet.SELECT_KEY).set(null);\n         given(mockChannel.attr(ChangeTelnet.SERVICE_KEY)).willReturn(defaultAttributeMap.attr(ChangeTelnet.SERVICE_KEY));",
    "output": "Fix the problem of InvokeTelnet that user use [invoke sayHello(xxx)] without executing the cd command first * Fix the problem of InvokeTelnet that user use [invoke sayHello(xxx)] without executing the cd command first * FIX"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n@@ -50,9 +50,12 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.Objects;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n import static org.apache.dubbo.common.constants.CommonConstants.ANY_VALUE;\n@@ -128,6 +131,8 @@ public class NacosRegistry extends FailbackRegistry {\n      */\n     private volatile ScheduledExecutorService scheduledExecutorService;\n+    private final ConcurrentMap<URL, ConcurrentMap<NotifyListener, ConcurrentMap<String, EventListener>>> nacosListeners = new ConcurrentHashMap<>();\n+\n     public NacosRegistry(URL url, NacosNamingServiceWrapper namingService) {\n         super(url);\n         this.namingService = namingService;\n@@ -517,7 +522,15 @@ private List<URL> buildURLs(URL consumerURL, Collection<Instance> instances) {\n     private void subscribeEventListener(String serviceName, final URL url, final NotifyListener listener)\n         throws NacosException {\n-        EventListener eventListener = new RegistryChildListenerImpl(serviceName, url, listener);\n+        ConcurrentMap<NotifyListener, ConcurrentMap<String, EventListener>> listeners = nacosListeners.computeIfAbsent(url,\n+            k -> new ConcurrentHashMap<>());\n+\n+        ConcurrentMap<String, EventListener> eventListeners = listeners.computeIfAbsent(listener,\n+            k -> new ConcurrentHashMap<>());\n+\n+        EventListener eventListener = eventListeners.computeIfAbsent(serviceName,\n+            k -> new RegistryChildListenerImpl(serviceName, url, listener));\n+\n         namingService.subscribe(serviceName,\n             getUrl().getGroup(Constants.DEFAULT_GROUP),\n             eventListener);\n@@ -613,10 +626,19 @@ private interface NacosDataFilter<T> {\n     }\n     private class RegistryChildListenerImpl implements EventListener {\n-        private RegistryNotifier notifier;\n+        private final RegistryNotifier notifier;\n+\n+        private final String serviceName;\n+\n+        private final URL consumerUrl;\n+\n+        private final NotifyListener listener;\n         public RegistryChildListenerImpl(String serviceName, URL consumerUrl, NotifyListener listener) {\n-            notifier = new RegistryNotifier(getUrl(), NacosRegistry.this.getDelay()) {\n+            this.serviceName = serviceName;\n+            this.consumerUrl = consumerUrl;\n+            this.listener = listener;\n+            this.notifier = new RegistryNotifier(getUrl(), NacosRegistry.this.getDelay()) {\n                 @Override\n                 protected void doNotify(Object rawAddresses) {\n                     List<Instance> instances = (List<Instance>) rawAddresses;\n@@ -640,6 +662,23 @@ public void onEvent(Event event) {\n                 notifier.notify(e.getInstances());\n             }\n         }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (o == null || getClass() != o.getClass()) {\n+                return false;\n+            }\n+            RegistryChildListenerImpl that = (RegistryChildListenerImpl) o;\n+            return Objects.equals(serviceName, that.serviceName) && Objects.equals(consumerUrl, that.consumerUrl) && Objects.equals(listener, that.listener);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(serviceName, consumerUrl, listener);\n+        }\n     }\n }",
    "output": "Fix nacos registry memory leak * fix nacos registry memory leak * reduce the creation of EventListener * reduce the creation of EventListener"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -960,7 +960,9 @@ private DeployState calculateState() {\n         int pending = 0, starting = 0, started = 0, stopping = 0, stopped = 0, failed = 0;\n         for (ModuleModel moduleModel : applicationModel.getModuleModels()) {\n             ModuleDeployer deployer = moduleModel.getDeployer();\n-            if (deployer.isPending()) {\n+            if (deployer == null) {\n+                pending++;\n+            } else if (deployer.isPending()) {\n                 pending++;\n             } else if (deployer.isStarting()) {\n                 starting++;",
    "output": "Fix NPE when calculateState"
  },
  {
    "input": "diff --git a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/config/ZookeeperConfig.java b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/config/ZookeeperConfig.java\n--- a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/config/ZookeeperConfig.java\n+++ b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/registrycenter/config/ZookeeperConfig.java\n@@ -71,7 +71,7 @@ public class ZookeeperConfig implements Config {\n     /**\n      * The default admin server ports of zookeeper.\n      */\n-    private static final int[] DEFAULT_ADMIN_SERVER_PORTS = new int[]{8081, 8082};\n+    private static final int[] DEFAULT_ADMIN_SERVER_PORTS = new int[]{18081, 18082};\n     /**\n      * The default version of zookeeper.",
    "output": "Change zk server admin port to 1808x"
  },
  {
    "input": "diff --git a/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-consumer/src/main/java/org/apache/dubbo/springboot/demo/consumer/ConsumerApplication.java b/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-consumer/src/main/java/org/apache/dubbo/springboot/demo/consumer/ConsumerApplication.java\n--- a/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-consumer/src/main/java/org/apache/dubbo/springboot/demo/consumer/ConsumerApplication.java\n+++ b/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-consumer/src/main/java/org/apache/dubbo/springboot/demo/consumer/ConsumerApplication.java\n@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.springboot.demo.consumer;\n+\n+import org.apache.dubbo.config.annotation.DubboReference;\n+import org.apache.dubbo.config.spring.context.annotation.EnableDubbo;\n+import org.apache.dubbo.springboot.demo.DemoService;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.springframework.stereotype.Service;\n+\n+@SpringBootApplication\n+@Service\n+@EnableDubbo\n+public class ConsumerApplication {\n+\n+    @DubboReference\n+    private DemoService demoService;\n+\n+    public static void main(String[] args) {\n+\n+        ConfigurableApplicationContext context = SpringApplication.run(ConsumerApplication.class, args);\n+        ConsumerApplication application = context.getBean(ConsumerApplication.class);\n+        String result = application.doSayHello(\"world\");\n+        System.out.println(\"result: \" + result);\n+    }\n+\n+    public String doSayHello(String name) {\n+        return demoService.sayHello(name);\n+    }\n+}\ndiff --git a/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-interface/src/main/java/org/apache/dubbo/springboot/demo/DemoService.java b/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-interface/src/main/java/org/apache/dubbo/springboot/demo/DemoService.java\n--- a/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-interface/src/main/java/org/apache/dubbo/springboot/demo/DemoService.java\n+++ b/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-interface/src/main/java/org/apache/dubbo/springboot/demo/DemoService.java\n@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.springboot.demo;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+public interface DemoService {\n+\n+    String sayHello(String name);\n+\n+    default CompletableFuture<String> sayHelloAsync(String name) {\n+        return CompletableFuture.completedFuture(sayHello(name));\n+    }\n+\n+}\ndiff --git a/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-provider/src/main/java/org/apache/dubbo/springboot/demo/provider/DemoServiceImpl.java b/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-provider/src/main/java/org/apache/dubbo/springboot/demo/provider/DemoServiceImpl.java\n--- a/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-provider/src/main/java/org/apache/dubbo/springboot/demo/provider/DemoServiceImpl.java\n+++ b/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-provider/src/main/java/org/apache/dubbo/springboot/demo/provider/DemoServiceImpl.java\n@@ -0,0 +1,34 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.springboot.demo.provider;\n+\n+\n+import org.apache.dubbo.config.annotation.DubboService;\n+import org.apache.dubbo.rpc.RpcContext;\n+import org.apache.dubbo.springboot.demo.DemoService;\n+\n+@DubboService\n+public class DemoServiceImpl implements DemoService {\n+\n+    @Override\n+    public String sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \", request from consumer: \" + RpcContext.getContext().getRemoteAddress());\n+        return \"Hello \" + name;\n+    }\n+\n+\n+}\ndiff --git a/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-provider/src/main/java/org/apache/dubbo/springboot/demo/provider/ProviderApplication.java b/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-provider/src/main/java/org/apache/dubbo/springboot/demo/provider/ProviderApplication.java\n--- a/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-provider/src/main/java/org/apache/dubbo/springboot/demo/provider/ProviderApplication.java\n+++ b/dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-provider/src/main/java/org/apache/dubbo/springboot/demo/provider/ProviderApplication.java\n@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.springboot.demo.provider;\n+\n+\n+import org.apache.dubbo.config.spring.context.annotation.EnableDubbo;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+@SpringBootApplication\n+@EnableDubbo(scanBasePackages = {\"org.apache.dubbo.springboot.demo.provider\"})\n+public class ProviderApplication {\n+    public static void main(String[] args) throws Exception {\n+        SpringApplication.run(ProviderApplication.class, args);\n+        System.out.println(\"dubbo service started\");\n+        new CountDownLatch(1).await();\n+    }\n+}",
    "output": "Add dubbo spring boot demo"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java b/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n@@ -48,24 +48,22 @@ public String param(@RequestParam(defaultValue = \"value-param\") String param) {\n     @Override\n     @PostMapping(\"/params\")\n     public String params(@RequestParam(defaultValue = \"value-a\") int a, @RequestParam(defaultValue = \"value-b\") String b) {\n-        return a + b;\n+        return null;\n     }\n     @Override\n     @GetMapping(\"/headers\")\n     public String headers(@RequestHeader(name = \"h\", defaultValue = \"value-h\") String header,\n                           @RequestHeader(name = \"h2\", defaultValue = \"value-h2\") String header2,\n                           @RequestParam(value = \"v\", defaultValue = \"1\") Integer param) {\n-        String result = header + \" , \" + header2 + \" , \" + param;\n-        return result;\n+        return null;\n     }\n     @Override\n     @GetMapping(\"/path-variables/{p1}/{p2}\")\n     public String pathVariables(@PathVariable(\"p1\") String path1,\n                                 @PathVariable(\"p2\") String path2, @RequestParam(\"v\") String param) {\n-        String result = path1 + \" , \" + path2 + \" , \" + param;\n-        return result;\n+        return null;\n     }\n     @Override\ndiff --git a/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java b/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n--- a/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n+++ b/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n@@ -48,24 +48,22 @@ public String param(@RequestParam(defaultValue = \"value-param\") String param) {\n     @Override\n     @PostMapping(\"/params\")\n     public String params(@RequestParam(defaultValue = \"value-a\") int a, @RequestParam(defaultValue = \"value-b\") String b) {\n-        return a + b;\n+        return null;\n     }\n     @Override\n     @GetMapping(\"/headers\")\n     public String headers(@RequestHeader(name = \"h\", defaultValue = \"value-h\") String header,\n                           @RequestHeader(name = \"h2\", defaultValue = \"value-h2\") String header2,\n                           @RequestParam(value = \"v\", defaultValue = \"1\") Integer param) {\n-        String result = header + \" , \" + header2 + \" , \" + param;\n-        return result;\n+        return null;\n     }\n     @Override\n     @GetMapping(\"/path-variables/{p1}/{p2}\")\n     public String pathVariables(@PathVariable(\"p1\") String path1,\n                                 @PathVariable(\"p2\") String path2, @RequestParam(\"v\") String param) {\n-        String result = path1 + \" , \" + path2 + \" , \" + param;\n-        return result;\n+        return null;\n     }\n     @Override",
    "output": "Remove all method with param directly return in RestService"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java b/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n@@ -42,7 +42,7 @@ public class SpringRestService implements RestService {\n     @Override\n     @GetMapping(value = \"/param\")\n     public String param(@RequestParam(defaultValue = \"value-param\") String param) {\n-        return param;\n+        return null;\n     }\n     @Override\ndiff --git a/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java b/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n--- a/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n+++ b/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java\n@@ -42,7 +42,7 @@ public class SpringRestService implements RestService {\n     @Override\n     @GetMapping(value = \"/param\")\n     public String param(@RequestParam(defaultValue = \"value-param\") String param) {\n-        return param;\n+        return null;\n     }\n     @Override",
    "output": "Remove param directly return in RestService"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/Compressor.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/Compressor.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/Compressor.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/Compressor.java\n@@ -42,6 +42,9 @@ static Compressor getCompressor(FrameworkModel frameworkModel, String compressor\n         if (null == compressorStr) {\n             return null;\n         }\n+        if (compressorStr.equals(DEFAULT_COMPRESSOR)) {\n+            return NONE;\n+        }\n         return frameworkModel.getExtensionLoader(Compressor.class).getExtension(compressorStr);\n     }",
    "output": "Upgrade Compressor.java"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/AnnotationUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/AnnotationUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/AnnotationUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/AnnotationUtilsTest.java\n@@ -355,15 +355,29 @@ static class C extends B {\n     private void assertADeclaredAnnotations(List<Annotation> annotations, int offset) {\n         int size = 3 + offset;\n         assertEquals(size, annotations.size());\n-        Service service = (Service) annotations.get(offset++);\n-        assertEquals(\"java.lang.CharSequence\", service.interfaceName());\n-        assertEquals(CharSequence.class, service.interfaceClass());\n-\n-        com.alibaba.dubbo.config.annotation.Service s = (com.alibaba.dubbo.config.annotation.Service) annotations.get(offset++);\n-        assertEquals(\"java.lang.CharSequence\", service.interfaceName());\n-        assertEquals(CharSequence.class, service.interfaceClass());\n-\n-        Adaptive adaptive = (Adaptive) annotations.get(offset++);\n-        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, adaptive.value());\n+        boolean apacheServiceFound = false;\n+        boolean alibabaServiceFound = false;\n+        boolean adaptiveFound = false;\n+\n+        for (Annotation annotation: annotations) {\n+            if (!apacheServiceFound && (annotation instanceof Service)) {\n+                assertEquals(\"java.lang.CharSequence\", ((Service)annotation).interfaceName());\n+                assertEquals(CharSequence.class, ((Service)annotation).interfaceClass());\n+                apacheServiceFound = true;\n+                continue;\n+            }\n+            if (!alibabaServiceFound && (annotation instanceof com.alibaba.dubbo.config.annotation.Service)) {\n+                assertEquals(\"java.lang.CharSequence\", ((com.alibaba.dubbo.config.annotation.Service)annotation).interfaceName());\n+                assertEquals(CharSequence.class, ((com.alibaba.dubbo.config.annotation.Service)annotation).interfaceClass());\n+                alibabaServiceFound = true;\n+                continue;\n+            }\n+            if (!adaptiveFound && (annotation instanceof Adaptive)) {\n+                assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, ((Adaptive)annotation).value());\n+                adaptiveFound = true;\n+                continue;\n+            }\n+        }\n+        assertTrue(apacheServiceFound && alibabaServiceFound && adaptiveFound);\n     }\n }",
    "output": "Fix flaky due to annotation order"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n@@ -222,7 +222,7 @@ private void printRouterSnapshot(URL url, BitList<Invoker<T>> availableInvokers,\n     /**\n      * Build each router's result\n      */\n-    private RouterSnapshotNode<T> buildRouterSnapshot(URL url, BitList<Invoker<T>> availableInvokers, Invocation invocation) {\n+    public RouterSnapshotNode<T> buildRouterSnapshot(URL url, BitList<Invoker<T>> availableInvokers, Invocation invocation) {\n         AddrCache<T> cache = this.cache.get();\n         BitList<Invoker<T>> resultInvokers = availableInvokers.clone();\n         RouterSnapshotNode<T> snapshotNode = new RouterSnapshotNode<T>(\"Parent\", resultInvokers.size());\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n@@ -403,6 +403,22 @@ public ScheduledFuture<?> getConnectivityCheckFuture() {\n         return connectivityCheckFuture;\n     }\n+    public BitList<Invoker<T>> getInvokers() {\n+        return invokers;\n+    }\n+\n+    public BitList<Invoker<T>> getValidInvokers() {\n+        return validInvokers;\n+    }\n+\n+    public List<Invoker<T>> getInvokersToReconnect() {\n+        return invokersToReconnect;\n+    }\n+\n+    public Set<Invoker<T>> getDisabledInvokers() {\n+        return disabledInvokers;\n+    }\n+\n     protected abstract List<Invoker<T>> doList(BitList<Invoker<T>> invokers, Invocation invocation) throws RpcException;\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java\n@@ -253,10 +253,6 @@ public void buildRouterChain(URL url) {\n         this.setRouterChain(RouterChain.buildChain(url));\n     }\n-    public List<Invoker<T>> getInvokers() {\n-        return invokers;\n-    }\n-\n     @Override\n     public boolean isAvailable() {\n         if (isDestroyed() || this.forbidden) {\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -555,11 +555,6 @@ public Map<URL, Invoker<T>> getUrlInvokerMap() {\n         return urlInvokerMap;\n     }\n-    @Override\n-    public List<Invoker<T>> getInvokers() {\n-        return invokers;\n-    }\n-\n     private boolean isValidCategory(URL url) {\n         String category = url.getCategory(DEFAULT_CATEGORY);\n         if ((ROUTERS_CATEGORY.equals(category) || ROUTE_PROTOCOL.equals(url.getProtocol())) ||",
    "output": "Add get raw invokers in Directory Support"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/tps/StatItem.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/tps/StatItem.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/tps/StatItem.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/tps/StatItem.java\n@@ -17,42 +17,40 @@\n package org.apache.dubbo.rpc.filter.tps;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n /**\n  * Judge whether a particular invocation of service provider method should be allowed within a configured time interval.\n  * As a state it contain name of key ( e.g. method), last invocation time, interval and rate count.\n  */\n class StatItem {\n-    private String name;\n+    private final String name;\n-    private long lastResetTime;\n+    private final AtomicLong lastResetTime;\n-    private long interval;\n+    private final long interval;\n-    private AtomicInteger token;\n+    private final AtomicInteger token;\n-    private int rate;\n+    private final int rate;\n     StatItem(String name, int rate, long interval) {\n         this.name = name;\n         this.rate = rate;\n         this.interval = interval;\n-        this.lastResetTime = System.currentTimeMillis();\n+        this.lastResetTime = new AtomicLong(System.currentTimeMillis());\n         this.token = new AtomicInteger(rate);\n     }\n     public boolean isAllowable() {\n         long now = System.currentTimeMillis();\n-        if (now > lastResetTime + interval) {\n+        if (now > lastResetTime.get() + interval) {\n             token.set(rate);\n-            lastResetTime = now;\n+            lastResetTime.set(now);\n         }\n-        if (token.decrementAndGet() < 0) {\n-            return false;\n-        }\n-        return true;\n+        return token.decrementAndGet() >= 0;\n     }\n     public long getInterval() {\n@@ -66,7 +64,7 @@ public int getRate() {\n     long getLastResetTime() {\n-        return lastResetTime;\n+        return lastResetTime.get();\n     }\n     int getToken() {\n@@ -75,11 +73,10 @@ int getToken() {\n     @Override\n     public String toString() {\n-        return new StringBuilder(32).append(\"StatItem \")\n-                .append(\"[name=\").append(name).append(\", \")\n-                .append(\"rate = \").append(rate).append(\", \")\n-                .append(\"interval = \").append(interval).append(']')\n-                .toString();\n+        return \"StatItem \" +\n+            \"[name=\" + name + \", \" +\n+            \"rate = \" + rate + \", \" +\n+            \"interval = \" + interval + ']';\n     }\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/tps/DefaultTPSLimiterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/tps/DefaultTPSLimiterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/tps/DefaultTPSLimiterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/tps/DefaultTPSLimiterTest.java\n@@ -120,15 +120,15 @@ public void testMultiThread() throws InterruptedException {\n         startLatch.countDown();\n         stopLatch.await();\n-        Assertions.assertEquals(taskList.stream().map(task -> task.getCount()).reduce((a, b) -> a + b).get(), 100);\n+        Assertions.assertEquals(taskList.stream().map(Task::getCount).reduce(Integer::sum).get(), 100);\n     }\n-    class Task implements Runnable {\n-        private DefaultTPSLimiter defaultTPSLimiter;\n-        private URL url;\n-        private Invocation invocation;\n-        private CountDownLatch startLatch;\n-        private CountDownLatch stopLatch;\n+    static class Task implements Runnable {\n+        private final DefaultTPSLimiter defaultTPSLimiter;\n+        private final URL url;\n+        private final Invocation invocation;\n+        private final CountDownLatch startLatch;\n+        private final CountDownLatch stopLatch;\n         private int count;\n         public Task(DefaultTPSLimiter defaultTPSLimiter, URL url, Invocation invocation, CountDownLatch startLatch, CountDownLatch stopLatch) {\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/tps/StatItemTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/tps/StatItemTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/tps/StatItemTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/tps/StatItemTest.java\n@@ -17,10 +17,16 @@\n package org.apache.dubbo.rpc.filter.tps;\n import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n public class StatItemTest {\n@@ -47,10 +53,60 @@ public void testAccuracy() throws Exception {\n         final int EXPECTED_RATE = 5;\n         statItem = new StatItem(\"test\", EXPECTED_RATE, 60_000L);\n         for (int i = 1; i <= EXPECTED_RATE; i++) {\n-            assertEquals(true, statItem.isAllowable());\n+            assertTrue(statItem.isAllowable());\n         }\n         // Must block the 6th item\n-        assertEquals(false, statItem.isAllowable());\n+        assertFalse(statItem.isAllowable());\n+    }\n+\n+    @Test\n+    public void testConcurrency() throws Exception {\n+        statItem = new StatItem(\"test\", 100, 100000);\n+\n+        List<Task> taskList = new ArrayList<>();\n+        int threadNum = 50;\n+        CountDownLatch stopLatch = new CountDownLatch(threadNum);\n+        CountDownLatch startLatch = new CountDownLatch(1);\n+        for (int i = 0; i < threadNum; i++) {\n+            taskList.add(new Task(statItem, startLatch, stopLatch));\n+\n+        }\n+        startLatch.countDown();\n+        stopLatch.await();\n+\n+        Assertions.assertEquals(taskList.stream().map(Task::getCount).reduce(Integer::sum).get(), 100);\n+    }\n+\n+\n+    static class Task implements Runnable {\n+        private final StatItem statItem;\n+        private final CountDownLatch startLatch;\n+        private final CountDownLatch stopLatch;\n+        private int count;\n+\n+        public Task(StatItem statItem, CountDownLatch startLatch, CountDownLatch stopLatch) {\n+            this.statItem = statItem;\n+            this.startLatch = startLatch;\n+            this.stopLatch = stopLatch;\n+            new Thread(this).start();\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                startLatch.await();\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            for (int j = 0; j < 10000; j++) {\n+                count = statItem.isAllowable() ? count + 1 : count;\n+            }\n+            stopLatch.countDown();\n+        }\n+\n+        public int getCount() {\n+            return count;\n+        }\n     }\n }",
    "output": "Fix statItem concurrency issues"
  },
  {
    "input": "diff --git a/dubbo-filter/dubbo-filter-cache/src/main/java/org/apache/dubbo/cache/support/AbstractCacheFactory.java b/dubbo-filter/dubbo-filter-cache/src/main/java/org/apache/dubbo/cache/support/AbstractCacheFactory.java\n--- a/dubbo-filter/dubbo-filter-cache/src/main/java/org/apache/dubbo/cache/support/AbstractCacheFactory.java\n+++ b/dubbo-filter/dubbo-filter-cache/src/main/java/org/apache/dubbo/cache/support/AbstractCacheFactory.java\n@@ -56,7 +56,7 @@ public abstract class AbstractCacheFactory implements CacheFactory {\n     @Override\n     public Cache getCache(URL url, Invocation invocation) {\n         url = url.addParameter(METHOD_KEY, invocation.getMethodName());\n-        String key = url.toFullString();\n+        String key = url.getServiceKey() + invocation.getMethodName();\n         Cache cache = caches.get(key);\n         // get from cache first.",
    "output": "Change cache key #9076"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n@@ -29,6 +29,7 @@\n import org.apache.dubbo.registry.client.event.ServiceInstancesChangedEvent;\n import org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;\n import org.apache.dubbo.registry.client.metadata.SubscribedURLsSynthesizer;\n+import org.apache.dubbo.registry.support.FailbackRegistry;\n import org.apache.dubbo.registry.support.RegistryManager;\n import java.util.ArrayList;\n@@ -39,7 +40,6 @@\n import java.util.Set;\n import java.util.TreeSet;\n import java.util.concurrent.ConcurrentHashMap;\n-import org.apache.dubbo.registry.support.FailbackRegistry;\n import static java.lang.String.format;\n import static org.apache.dubbo.common.constants.CommonConstants.CHECK_KEY;\n@@ -141,6 +141,11 @@ protected boolean shouldRegister(URL providerURL) {\n             }\n         }\n+        if (!acceptable(providerURL)) {\n+            logger.info(\"URL \" + providerURL + \" will not be registered to Registry. Registry \" + this.getUrl() + \" does not accept service of this protocol type.\");\n+            return false;\n+        }\n+\n         return should;\n     }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n@@ -520,8 +520,9 @@ protected boolean acceptable(URL urlToRegistry) {\n             return true;\n         }\n-        return Arrays.stream(COMMA_SPLIT_PATTERN.split(pattern))\n-            .anyMatch(p -> p.equalsIgnoreCase(urlToRegistry.getProtocol()));\n+        String[] accepts = COMMA_SPLIT_PATTERN.split(pattern);\n+        return Arrays.stream(accepts).anyMatch(p -> p.equalsIgnoreCase(urlToRegistry.getProtocol())) &&\n+            Arrays.stream(accepts).noneMatch(p -> p.equalsIgnoreCase(\"-\" + urlToRegistry.getProtocol()));\n     }\n     @Override\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java\n@@ -194,7 +194,7 @@ ConcurrentMap<Holder, FailedUnsubscribedTask> getFailedUnsubscribed() {\n     @Override\n     public void register(URL url) {\n         if (!acceptable(url)) {\n-            logger.info(\"URL \" + url + \" will not be registered to Registry. Registry \" + url + \" does not accept service of this protocol type.\");\n+            logger.info(\"URL \" + url + \" will not be registered to Registry. Registry \" + this.getUrl() + \" does not accept service of this protocol type.\");\n             return;\n         }\n         super.register(url);",
    "output": "Add registry accept support for ServiceDiscovery"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java\n@@ -16,6 +16,10 @@\n  */\n package org.apache.dubbo.common.bytecode;\n+import org.apache.dubbo.common.utils.ArrayUtils;\n+import org.apache.dubbo.common.utils.ReflectUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+\n import javassist.CannotCompileException;\n import javassist.ClassPool;\n import javassist.CtClass;\n@@ -24,10 +28,8 @@\n import javassist.CtMethod;\n import javassist.CtNewConstructor;\n import javassist.CtNewMethod;\n+import javassist.LoaderClassPath;\n import javassist.NotFoundException;\n-import org.apache.dubbo.common.utils.ArrayUtils;\n-import org.apache.dubbo.common.utils.ReflectUtils;\n-import org.apache.dubbo.common.utils.StringUtils;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n@@ -91,7 +93,8 @@ public static ClassPool getClassPool(ClassLoader loader) {\n         ClassPool pool = POOL_MAP.get(loader);\n         if (pool == null) {\n             pool = new ClassPool(true);\n-            pool.insertClassPath(new CustomizedLoaderClassPath(loader));\n+            pool.insertClassPath(new LoaderClassPath(loader));\n+            pool.insertClassPath(new LoaderClassPath(ClassGenerator.class.getClassLoader()));\n             POOL_MAP.put(loader, pool);\n         }\n         return pool;\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/CustomizedLoaderClassPath.java b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/CustomizedLoaderClassPath.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/CustomizedLoaderClassPath.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/CustomizedLoaderClassPath.java\n@@ -1,127 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.common.bytecode;\n-\n-import javassist.ClassPath;\n-\n-import java.io.InputStream;\n-import java.lang.ref.WeakReference;\n-import java.net.URL;\n-\n-/**\n- * A class search-path representing a class loader.\n- *\n- * <p>It is used for obtaining a class file from the given\n- * class loader by <code>getResourceAsStream()</code>.\n- * The <code>LoaderClassPath</code> refers to the class loader through\n- * <code>WeakReference</code>.  If the class loader is garbage collected,\n- * the other search pathes are examined.\n- *\n- * <p>The given class loader must have both <code>getResourceAsStream()</code>\n- * and <code>getResource()</code>.\n- *\n- * @author <a href=\"mailto:bill@jboss.org\">Bill Burke</a>\n- * @author Shigeru Chiba\n- */\n-public class CustomizedLoaderClassPath implements ClassPath {\n-    private WeakReference clref;\n-\n-    /**\n-     * Creates a search path representing a class loader.\n-     */\n-    public CustomizedLoaderClassPath(ClassLoader cl) {\n-        clref = new WeakReference(cl);\n-    }\n-\n-    public String toString() {\n-        Object cl = null;\n-        if (clref != null) {\n-            cl = clref.get();\n-        }\n-\n-        return cl == null ? \"<null>\" : cl.toString();\n-    }\n-\n-    /**\n-     * Obtains a class file from the class loader.\n-     * This method calls <code>getResourceAsStream(String)</code>\n-     * on the class loader.\n-     */\n-    public InputStream openClassfile(String classname) {\n-        String cname = classname.replace('.', '/') + \".class\";\n-        ClassLoader cl = (ClassLoader) clref.get();\n-        if (cl == null) {\n-            return null;        // not found\n-        } else {\n-            InputStream result;\n-\n-            if (classname.startsWith(\"org.apache.dubbo\") && cl != this.getClass().getClassLoader()) {\n-                result = this.getClass().getClassLoader().getResourceAsStream(cname);\n-                if (result != null) {\n-                    return result;\n-                } else {\n-                    return cl.getResourceAsStream(cname);\n-                }\n-            } else {\n-                result = cl.getResourceAsStream(cname);\n-                if (result == null && (cl != this.getClass().getClassLoader())) {\n-                    return this.getClass().getClassLoader().getResourceAsStream(cname);\n-                }\n-                return result;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Obtains the URL of the specified class file.\n-     * This method calls <code>getResource(String)</code>\n-     * on the class loader.\n-     *\n-     * @return null if the class file could not be found.\n-     */\n-    public URL find(String classname) {\n-        String cname = classname.replace('.', '/') + \".class\";\n-        ClassLoader cl = (ClassLoader) clref.get();\n-        if (cl == null) {\n-            return null;        // not found\n-        } else {\n-            URL url;\n-\n-            if (classname.startsWith(\"org.apache.dubbo\") && cl != this.getClass().getClassLoader()) {\n-                url = this.getClass().getClassLoader().getResource(cname);\n-                if (url != null) {\n-                    return url;\n-                } else {\n-                    return cl.getResource(cname);\n-                }\n-            } else {\n-                url = cl.getResource(cname);\n-                if (url == null && (cl != this.getClass().getClassLoader())) {\n-                    return this.getClass().getClassLoader().getResource(cname);\n-                }\n-                return url;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Closes this class path.\n-     */\n-    public void close() {\n-        clref = null;\n-    }\n-}\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n@@ -16,11 +16,13 @@\n  */\n package org.apache.dubbo.common.bytecode;\n-import javassist.ClassPool;\n-import javassist.CtMethod;\n import org.apache.dubbo.common.utils.ClassUtils;\n import org.apache.dubbo.common.utils.ReflectUtils;\n+import javassist.ClassPool;\n+import javassist.CtMethod;\n+import javassist.LoaderClassPath;\n+\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n@@ -155,7 +157,8 @@ private static Wrapper makeWrapper(Class<?> c) {\n         }\n         final ClassPool classPool = new ClassPool(ClassPool.getDefault());\n-        classPool.insertClassPath(new CustomizedLoaderClassPath(cl));\n+        classPool.insertClassPath(new LoaderClassPath(cl));\n+        classPool.insertClassPath(new LoaderClassPath(ClassGenerator.class.getClassLoader()));\n         List<String> allMethod = new ArrayList<>();\n         try {",
    "output": "Remove CustomizedLoaderClassPath.java"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -484,4 +484,6 @@ public interface CommonConstants {\n     String OS_WIN_PREFIX = \"win\";\n+    String DUBBO_INTERNAL_APPLICATION = \"DUBBO_INTERNAL_APPLICATION\";\n+\n }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n@@ -23,6 +23,7 @@\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.support.Parameter;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n@@ -196,6 +197,11 @@ public ApplicationConfig(String name) {\n         setName(name);\n     }\n+    public ApplicationConfig(ApplicationModel applicationModel, String name) {\n+        super(applicationModel);\n+        setName(name);\n+    }\n+\n     @Override\n     protected void checkDefault() {\n         super.checkDefault();\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n@@ -72,6 +72,7 @@ public class ApplicationModel extends ScopeModel {\n     private AtomicInteger moduleIndex = new AtomicInteger(0);\n     private Object moduleLock = new Object();\n+    private final boolean isInternal;\n     // --------- static methods ----------//\n@@ -194,14 +195,19 @@ public static void reset() {\n     // ------------- instance methods ---------------//\n     public ApplicationModel(FrameworkModel frameworkModel) {\n+        this(frameworkModel, false);\n+    }\n+\n+    public ApplicationModel(FrameworkModel frameworkModel, boolean isInternal) {\n         super(frameworkModel, ExtensionScope.APPLICATION);\n         Assert.notNull(frameworkModel, \"FrameworkModel can not be null\");\n+        this.isInternal = isInternal;\n         this.frameworkModel = frameworkModel;\n         frameworkModel.addApplication(this);\n         initialize();\n         // bind to default instance if absent\n         synchronized (ApplicationModel.class) {\n-            if (defaultInstance == null) {\n+            if (!isInternal && defaultInstance == null) {\n                 defaultInstance = this;\n             }\n         }\n@@ -242,6 +248,9 @@ protected void onDestroy() {\n             synchronized (ApplicationModel.class) {\n                 frameworkModel.removeApplication(this);\n                 defaultInstance = null;\n+                if (LOGGER.isInfoEnabled()) {\n+                    LOGGER.info(\"Reset default Dubbo application[\" + getInternalId() + \"] to null ...\");\n+                }\n             }\n         } else {\n             frameworkModel.removeApplication(this);\n@@ -454,4 +463,8 @@ public ApplicationDeployer getDeployer() {\n     public void setDeployer(ApplicationDeployer deployer) {\n         this.deployer = deployer;\n     }\n+\n+    public boolean isInternal() {\n+        return isInternal;\n+    }\n }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n@@ -17,11 +17,13 @@\n package org.apache.dubbo.rpc.model;\n import org.apache.dubbo.common.config.Environment;\n+import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.extension.ExtensionScope;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.resource.GlobalResourcesRepository;\n+import org.apache.dubbo.config.ApplicationConfig;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -38,17 +40,20 @@ public class FrameworkModel extends ScopeModel {\n     public static final String NAME = \"FrameworkModel\";\n     private static final AtomicLong index = new AtomicLong(1);\n-    // app index starts from 1 in each FrameworkModel\n-    private final AtomicLong appIndex = new AtomicLong(1);\n+    // internal app index is 0, default app index is 1\n+    private final AtomicLong appIndex = new AtomicLong(0);\n     private volatile static FrameworkModel defaultInstance;\n     private static List<FrameworkModel> allInstances = Collections.synchronizedList(new ArrayList<>());\n     private List<ApplicationModel> applicationModels = Collections.synchronizedList(new ArrayList<>());\n+    private List<ApplicationModel> pubApplicationModels = Collections.synchronizedList(new ArrayList<>());\n+\n     private FrameworkServiceRepository serviceRepository;\n+    private ApplicationModel internalApplicationModel;\n     public FrameworkModel() {\n         super(null, ExtensionScope.FRAMEWORK);\n@@ -67,6 +72,11 @@ protected void initialize() {\n         for (ScopeModelInitializer initializer : initializers) {\n             initializer.initializeFrameworkModel(this);\n         }\n+\n+        internalApplicationModel = new ApplicationModel(this, true);\n+        internalApplicationModel.getApplicationConfigManager().setApplication(\n+            new ApplicationConfig(internalApplicationModel, CommonConstants.DUBBO_INTERNAL_APPLICATION));\n+        internalApplicationModel.setModelName(CommonConstants.DUBBO_INTERNAL_APPLICATION);\n     }\n     @Override\n@@ -83,6 +93,9 @@ protected void onDestroy() {\n             allInstances.remove(this);\n             if (defaultInstance == this) {\n                 defaultInstance = null;\n+                if (LOGGER.isInfoEnabled()) {\n+                    LOGGER.info(\"Reset default Dubbo framework[\" + getInternalId() + \"] to null ...\");\n+                }\n             }\n         }\n@@ -132,24 +145,38 @@ public ApplicationModel newApplication() {\n     synchronized void addApplication(ApplicationModel applicationModel) {\n         if (!this.applicationModels.contains(applicationModel)) {\n             this.applicationModels.add(applicationModel);\n+            if (!applicationModel.isInternal()) {\n+                this.pubApplicationModels.add(applicationModel);\n+            }\n             applicationModel.setInternalName(buildInternalName(ApplicationModel.NAME, getInternalId(), appIndex.getAndIncrement()));\n         }\n     }\n     synchronized void removeApplication(ApplicationModel model) {\n         this.applicationModels.remove(model);\n+        if (!model.isInternal()) {\n+            this.pubApplicationModels.remove(model);\n+        }\n     }\n     synchronized void tryDestroy() {\n-        if (applicationModels.size() == 0) {\n+        if (pubApplicationModels.size() == 0) {\n             destroy();\n         }\n     }\n     public List<ApplicationModel> getApplicationModels() {\n+        return Collections.unmodifiableList(pubApplicationModels);\n+    }\n+\n+    public List<ApplicationModel> getAllApplicationModels() {\n         return Collections.unmodifiableList(applicationModels);\n     }\n+    public ApplicationModel getInternalApplicationModel() {\n+        return internalApplicationModel;\n+    }\n+\n     public FrameworkServiceRepository getServiceRepository() {\n         return serviceRepository;\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/service/TriBuiltinService.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/service/TriBuiltinService.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/service/TriBuiltinService.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/service/TriBuiltinService.java\n@@ -19,7 +19,6 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.url.component.ServiceConfigURL;\n-import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.ProxyFactory;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n@@ -32,7 +31,6 @@\n import grpc.health.v1.Health;\n-import java.util.List;\n import java.util.concurrent.atomic.AtomicBoolean;\n import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n@@ -59,11 +57,7 @@ public TriBuiltinService(FrameworkModel frameworkModel) {\n         healthService = healthStatusManager.getHealthService();\n         proxyFactory = frameworkModel.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n         pathResolver = frameworkModel.getExtensionLoader(PathResolver.class).getDefaultExtension();\n-        List<ApplicationModel> applicationModels = frameworkModel.getApplicationModels();\n-        if (CollectionUtils.isEmpty(applicationModels)) {\n-            throw new IllegalStateException(\"Should have at least one applicationModel in frameworkModel. FrameworkModel:\" + frameworkModel);\n-        }\n-        repository = applicationModels.get(0).getInternalModule().getServiceRepository();\n+        repository = frameworkModel.getInternalApplicationModel().getInternalModule().getServiceRepository();\n         init();\n     }",
    "output": "Add Internal ApplicationModel"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java b/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java\n--- a/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java\n+++ b/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistry.java\n@@ -34,6 +34,7 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n+import static org.apache.dubbo.common.constants.CommonConstants.CHECK_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.EMPTY_PROTOCOL;\n /**\n@@ -92,7 +93,8 @@ protected void initServiceRegistry(URL url, Map<String, Registry> registryMap) {\n                 serviceRegistries.put(tmpUrl, registryMap.get(tmpUrl));\n                 continue;\n             }\n-            Registry registry = registryFactory.getRegistry(URL.valueOf(tmpUrl));\n+            final URL registryUrl = URL.valueOf(tmpUrl).addParameterIfAbsent(CHECK_KEY, url.getParameter(CHECK_KEY, \"true\"));\n+            Registry registry = registryFactory.getRegistry(registryUrl);\n             registryMap.put(tmpUrl, registry);\n             serviceRegistries.put(tmpUrl, registry);\n         }\n@@ -106,7 +108,8 @@ protected void initReferenceRegistry(URL url, Map<String, Registry> registryMap)\n                 referenceRegistries.put(tmpUrl, registryMap.get(tmpUrl));\n                 continue;\n             }\n-            Registry registry = registryFactory.getRegistry(URL.valueOf(tmpUrl));\n+            final URL registryUrl = URL.valueOf(tmpUrl).addParameterIfAbsent(CHECK_KEY, url.getParameter(CHECK_KEY, \"true\"));\n+            Registry registry = registryFactory.getRegistry(registryUrl);\n             registryMap.put(tmpUrl, registry);\n             referenceRegistries.put(tmpUrl, registry);\n         }",
    "output": "Fix multiple registry check"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/ClassUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/ClassUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/ClassUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/ClassUtils.java\n@@ -344,9 +344,9 @@ public static String getSizeMethod(Class<?> cls) {\n     }\n     public static String getMethodName(Method method, Class<?>[] parameterClasses, String rightCode) {\n+        StringBuilder buf = new StringBuilder(rightCode);\n         if (method.getParameterTypes().length > parameterClasses.length) {\n             Class<?>[] types = method.getParameterTypes();\n-            StringBuilder buf = new StringBuilder(rightCode);\n             for (int i = parameterClasses.length; i < types.length; i++) {\n                 if (buf.length() > 0) {\n                     buf.append(',');\n@@ -370,7 +370,7 @@ public static String getMethodName(Method method, Class<?>[] parameterClasses, S\n                 buf.append(def);\n             }\n         }\n-        return method.getName() + \"(\" + rightCode + \")\";\n+        return method.getName() + \"(\" + buf + \")\";\n     }\n     public static Method searchMethod(Class<?> currentClass, String name, Class<?>[] parameterTypes) throws NoSuchMethodException {",
    "output": "Fix getMethodName"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/DubboBootstrapMultiInstanceTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/DubboBootstrapMultiInstanceTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/DubboBootstrapMultiInstanceTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/DubboBootstrapMultiInstanceTest.java\n@@ -605,7 +605,7 @@ public void testBothStartByModuleAndByApplication() throws Exception {\n                 .service(serviceConfig1)\n                 .endModule();\n-            // 1. start module1\n+            // 1. start module1 and wait\n             ModuleDeployer moduleDeployer1 = serviceConfig1.getScopeModel().getDeployer();\n             moduleDeployer1.start().get();\n             Assertions.assertEquals(DeployState.STARTED, moduleDeployer1.getState());\n@@ -654,7 +654,7 @@ public void testBothStartByModuleAndByApplication() throws Exception {\n     @Test\n-    public void testBothStartByModuleAndByApplication2() throws Exception {\n+    public void testBothStartModuleAndApplicationNoWait() throws Exception {\n         String version1 = \"1.0\";\n         String version2 = \"2.0\";\n         String version3 = \"3.0\";\n@@ -685,12 +685,13 @@ public void testBothStartByModuleAndByApplication2() throws Exception {\n                 .service(serviceConfig1)\n                 .endModule();\n+            ApplicationModel applicationModel = providerBootstrap.getApplicationModel();\n+\n             // 1. start module1 but no wait\n             ModuleDeployer moduleDeployer1 = serviceConfig1.getScopeModel().getDeployer();\n             moduleDeployer1.start();\n-            Assertions.assertEquals(DeployState.STARTING, moduleDeployer1.getState());\n+            Assertions.assertTrue(moduleDeployer1.isRunning());\n-            ApplicationModel applicationModel = providerBootstrap.getApplicationModel();\n             ApplicationDeployer applicationDeployer = applicationModel.getDeployer();\n             Assertions.assertEquals(DeployState.STARTING, applicationDeployer.getState());\n             ModuleModel defaultModule = applicationModel.getDefaultModule();",
    "output": "Fix module state checking"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n@@ -149,9 +149,7 @@ public URL toUrl() {\n         if (StringUtils.isEmpty(map.get(PROTOCOL_KEY))) {\n             map.put(PROTOCOL_KEY, ZOOKEEPER_PROTOCOL);\n         }\n-        URL url = UrlUtils.parseURL(address, map);\n-        url.setScopeModel(getScopeModel());\n-        return url;\n+        return UrlUtils.parseURL(address, map).setScopeModel(getScopeModel());\n     }\n     public boolean checkOrUpdateInitialized(boolean update) {",
    "output": "Fix the bug of invalid scopeModel in ConfigCenterConfig update the returned URL instance in ConfigCenterConfig#toUrl see issue: https://github.com/apache/dubbo/issues/9070"
  },
  {
    "input": "diff --git a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/DubboTestChecker.java b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/DubboTestChecker.java\n--- a/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/DubboTestChecker.java\n+++ b/dubbo-test/dubbo-test-check/src/main/java/org/apache/dubbo/test/check/DubboTestChecker.java\n@@ -179,7 +179,9 @@ private void printThreadCheckingSummaryReport() {\n     private void flushReportFile() {\n         try {\n-            reportWriter.flush();\n+            if (reportWriter != null) {\n+                reportWriter.flush();\n+            }\n             if (reportFileOut != null) {\n                 reportFileOut.getFD().sync();\n             }",
    "output": "Fix DubboTestChecker NPE"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleServiceDiscovery.java b/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleServiceDiscovery.java\n@@ -113,6 +113,15 @@ public ServiceInstancesChangedListener createListener(Set<String> serviceNames)\n         return new MultiServiceInstancesChangedListener(serviceNames, this);\n     }\n+    @Override\n+    public List<ServiceInstance> getInstances(String serviceName) {\n+        List<ServiceInstance> serviceInstanceList = new ArrayList<>();\n+        for (ServiceDiscovery serviceDiscovery : serviceDiscoveries.values()) {\n+            serviceInstanceList.addAll(serviceDiscovery.getInstances(serviceName));\n+        }\n+        return serviceInstanceList;\n+    }\n+\n     @Override\n     public Page<ServiceInstance> getInstances(String serviceName, int offset, int pageSize, boolean healthyOnly)\n         throws NullPointerException, IllegalArgumentException, UnsupportedOperationException {",
    "output": "Fix multiple registry subscribe"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n@@ -87,7 +87,7 @@ public class DefaultExecutorRepository implements ExecutorRepository, ExtensionA\n     public DefaultExecutorRepository() {\n         for (int i = 0; i < DEFAULT_SCHEDULER_SIZE; i++) {\n             ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(\n-                new NamedThreadFactory(\"Dubbo-framework-scheduler\"));\n+                new NamedThreadFactory(\"Dubbo-framework-scheduler\", true));\n             scheduledExecutors.addItem(scheduler);\n             executorServiceRing.addItem(new ThreadPoolExecutor(1, 1,",
    "output": "Fix process can't stop when tomcat port already in use. * make scheduledExecutors thread is daemon. * shutdown scheduledExecutors and executorServiceRing when destroy. * cancel shutdown"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n@@ -279,7 +279,7 @@ public static void refreshMetadataAndInstance(ServiceInstance serviceInstance) {\n             instance = new DefaultServiceInstance((DefaultServiceInstance) instance);\n             calInstanceRevision(serviceDiscovery, instance);\n             customizeInstance(instance);\n-            if (serviceInstance.getPort() > 0) {\n+            if (instance.getPort() > 0) {\n                 // update service instance revision\n                 serviceDiscovery.update(instance);\n             }",
    "output": "Fix instance update failed"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.status.reporter.FrameworkStatusReportService;\n import org.apache.dubbo.registry.client.migration.model.MigrationRule;\n import org.apache.dubbo.registry.client.migration.model.MigrationStep;\n@@ -97,12 +98,14 @@ private boolean refreshInvoker(MigrationStep step, Float threshold, MigrationRul\n     }\n     private void report(MigrationStep step, MigrationStep originStep, String success) {\n-        //TODO FrameworkStatusReporter\n-//        if (FrameworkStatusReporter.hasReporter()) {\n-//            FrameworkStatusReporter.reportMigrationStepStatus(\n-//                    FrameworkStatusReporter.createMigrationStepReport(consumerURL.getServiceInterface(), consumerURL.getVersion(),\n-//                            consumerURL.getGroup(), String.valueOf(originStep), String.valueOf(step), success));\n-//        }\n+        FrameworkStatusReportService reportService =\n+            consumerURL.getOrDefaultApplicationModel().getBeanFactory().getBean(FrameworkStatusReportService.class);\n+\n+        if (reportService.hasReporter()) {\n+            reportService.reportMigrationStepStatus(\n+                reportService.createMigrationStepReport(consumerURL.getServiceInterface(), consumerURL.getVersion(),\n+                            consumerURL.getGroup(), String.valueOf(originStep), String.valueOf(step), success));\n+        }\n     }\n     private void setMigrationRule(MigrationRule rule) {\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandlerTest.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandlerTest.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandlerTest.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandlerTest.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.registry.client.migration.model.MigrationRule;\n import org.apache.dubbo.registry.client.migration.model.MigrationStep;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n@@ -31,6 +32,7 @@ public void test() {\n         URL url = Mockito.mock(URL.class);\n         Mockito.when(url.getDisplayServiceKey()).thenReturn(\"test\");\n         Mockito.when(url.getParameter(Mockito.any(), (String) Mockito.any())).thenAnswer(i->i.getArgument(1));\n+        Mockito.when(url.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());\n         MigrationRuleHandler handler = new MigrationRuleHandler(invoker, url);\n         Mockito.when(invoker.migrateToForceApplicationInvoker(Mockito.any())).thenReturn(true);",
    "output": "Fix Migration Report for Multi-instances * Fix Migration Report for Multi-instances * Fix ut"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleUtil.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleUtil.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleUtil.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleUtil.java\n@@ -57,15 +57,17 @@\n public class TripleUtil {\n     public static final AttributeKey<AbstractServerStream> SERVER_STREAM_KEY = AttributeKey.newInstance(\n-            \"tri_server_stream\");\n+        \"tri_server_stream\");\n     public static final AttributeKey<AbstractClientStream> CLIENT_STREAM_KEY = AttributeKey.newInstance(\n-            \"tri_client_stream\");\n+        \"tri_client_stream\");\n     public static final AttributeKey<Compressor> COMPRESSOR_KEY = AttributeKey.newInstance(\n-            \"tri_compressor\");\n-\n+        \"tri_compressor\");\n+    public static final String LANGUAGE = \"java\";\n     // Some exceptions are not very useful and add too much noise to the log\n     private static final Set<String> QUIET_EXCEPTIONS = new HashSet<>();\n     private static final Set<Class<?>> QUIET_EXCEPTIONS_CLASS = new HashSet<>();\n+    private static final Base64.Decoder BASE64_DECODER = Base64.getDecoder();\n+    private static final Base64.Encoder BASE64_ENCODER = Base64.getEncoder().withoutPadding();\n     static {\n         QUIET_EXCEPTIONS.add(\"NativeIoException\");\n@@ -83,12 +85,6 @@ public static boolean isQuiteException(Throwable t) {\n         return false;\n     }\n-\n-    public static final String LANGUAGE = \"java\";\n-\n-    private static final Base64.Decoder BASE64_DECODER = Base64.getDecoder();\n-    private static final Base64.Encoder BASE64_ENCODER = Base64.getEncoder().withoutPadding();\n-\n     public static AbstractServerStream getServerStream(ChannelHandlerContext ctx) {\n         return ctx.channel().attr(TripleUtil.SERVER_STREAM_KEY).get();\n     }\n@@ -103,7 +99,10 @@ public static Compressor getCompressor(ChannelHandlerContext ctx) {\n     public static int calcCompressFlag(ChannelHandlerContext ctx) {\n         Compressor compressor = getCompressor(ctx);\n-        return null == compressor ? 0 : 1;\n+        if (null == compressor || IdentityCompressor.NONE.equals(compressor)) {\n+            return 0;\n+        }\n+        return 1;\n     }\n     /**\n@@ -176,7 +175,7 @@ public static Object[] unwrapReq(URL url, TripleWrapper.TripleRequestWrapper wra\n             for (int i = 0; i < arguments.length; i++) {\n                 final ByteArrayInputStream bais = new ByteArrayInputStream(wrap.getArgs(i).toByteArray());\n                 Object obj = multipleSerialization.deserialize(url,\n-                        serializeType, wrap.getArgTypes(i), bais);\n+                    serializeType, wrap.getArgTypes(i), bais);\n                 arguments[i] = obj;\n             }\n             return arguments;\n@@ -190,8 +189,8 @@ public static TripleWrapper.TripleResponseWrapper wrapResp(URL url, String seria\n                                                                MultipleSerialization multipleSerialization) {\n         try {\n             final TripleWrapper.TripleResponseWrapper.Builder builder = TripleWrapper.TripleResponseWrapper.newBuilder()\n-                    .setType(desc.getReturnClass().getName())\n-                    .setSerializeType(convertHessianToWrapper(serializeType));\n+                .setType(desc.getReturnClass().getName())\n+                .setSerializeType(convertHessianToWrapper(serializeType));\n             ByteArrayOutputStream bos = new ByteArrayOutputStream();\n             multipleSerialization.serialize(url, serializeType, desc.getReturnClass().getName(), resp, bos);\n             builder.setData(ByteString.copyFrom(bos.toByteArray()));\n@@ -207,9 +206,9 @@ public static TripleWrapper.TripleExceptionWrapper wrapException(URL url, Throwa\n                                                                      MultipleSerialization serialization) {\n         try {\n             final TripleWrapper.TripleExceptionWrapper.Builder builder = TripleWrapper.TripleExceptionWrapper.newBuilder()\n-                    .setLanguage(LANGUAGE)\n-                    .setClassName(throwable.getClass().getName())\n-                    .setSerialization(serializeType);\n+                .setLanguage(LANGUAGE)\n+                .setClassName(throwable.getClass().getName())\n+                .setSerialization(serializeType);\n             ByteArrayOutputStream bos = new ByteArrayOutputStream();\n             serialization.serialize(url, serializeType, builder.getClassName(), throwable, bos);\n             builder.setData(ByteString.copyFrom(bos.toByteArray()));\n@@ -246,8 +245,8 @@ public static TripleWrapper.TripleRequestWrapper wrapReq(URL url, String seriali\n                                                              MultipleSerialization multipleSerialization) {\n         try {\n             final TripleWrapper.TripleRequestWrapper.Builder builder = TripleWrapper.TripleRequestWrapper.newBuilder()\n-                    .addArgTypes(type)\n-                    .setSerializeType(convertHessianToWrapper(serializeType));\n+                .addArgTypes(type)\n+                .setSerializeType(convertHessianToWrapper(serializeType));\n             ByteArrayOutputStream bos = new ByteArrayOutputStream();\n             multipleSerialization.serialize(url, serializeType, type, req, bos);\n             builder.addArgs(ByteString.copyFrom(bos.toByteArray()));\n@@ -263,7 +262,7 @@ public static TripleWrapper.TripleRequestWrapper wrapReq(URL url, RpcInvocation\n         try {\n             String serializationName = (String) invocation.getObjectAttachment(Constants.SERIALIZATION_KEY);\n             final TripleWrapper.TripleRequestWrapper.Builder builder = TripleWrapper.TripleRequestWrapper.newBuilder()\n-                    .setSerializeType(convertHessianToWrapper(serializationName));\n+                .setSerializeType(convertHessianToWrapper(serializationName));\n             for (int i = 0; i < invocation.getArguments().length; i++) {\n                 final String clz = invocation.getParameterTypes()[i].getName();\n                 builder.addArgTypes(clz);\n@@ -314,14 +313,14 @@ public static byte[] pack(Object obj) {\n     }\n     public static String encodeWrapper(URL url, Object obj, String serializeType, MultipleSerialization serialization)\n-            throws IOException {\n+        throws IOException {\n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         serialization.serialize(url, serializeType, obj.getClass().getName(), obj, bos);\n         final TripleWrapper.TripleRequestWrapper wrap = TripleWrapper.TripleRequestWrapper.newBuilder()\n-                .setSerializeType(convertHessianToWrapper(serializeType))\n-                .addArgTypes(obj.getClass().getName())\n-                .addArgs(ByteString.copyFrom(bos.toByteArray()))\n-                .build();\n+            .setSerializeType(convertHessianToWrapper(serializeType))\n+            .addArgTypes(obj.getClass().getName())\n+            .addArgs(ByteString.copyFrom(bos.toByteArray()))\n+            .build();\n         return encodeBase64ASCII(wrap.toByteArray());\n     }\n@@ -335,7 +334,7 @@ public static byte[] encodeBase64(byte[] in) {\n     }\n     public static Object decodeObjFromHeader(URL url, CharSequence value, MultipleSerialization serialization)\n-            throws InvalidProtocolBufferException {\n+        throws InvalidProtocolBufferException {\n         final byte[] decode = decodeASCIIByte(value);\n         final TripleWrapper.TripleRequestWrapper wrapper = TripleWrapper.TripleRequestWrapper.parseFrom(decode);\n         final Object[] objects = TripleUtil.unwrapReq(url, wrapper, serialization);",
    "output": "Fix compressor flag = 1 when compressor is none"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/AbstractCompiler.java b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/AbstractCompiler.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/AbstractCompiler.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/AbstractCompiler.java\n@@ -18,6 +18,10 @@\n import org.apache.dubbo.common.compiler.Compiler;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n@@ -30,6 +34,8 @@ public abstract class AbstractCompiler implements Compiler {\n     private static final Pattern CLASS_PATTERN = Pattern.compile(\"class\\\\s+([$_a-zA-Z][$_a-zA-Z0-9]*)\\\\s+\");\n+    private static final Map<String, Lock> CLASS_IN_CREATION_MAP = new ConcurrentHashMap<>();\n+\n     @Override\n     public Class<?> compile(String code, ClassLoader classLoader) {\n         code = code.trim();\n@@ -48,22 +54,30 @@ public Class<?> compile(String code, ClassLoader classLoader) {\n             throw new IllegalArgumentException(\"No such class name in \" + code);\n         }\n         String className = pkg != null && pkg.length() > 0 ? pkg + \".\" + cls : cls;\n+        Lock lock = CLASS_IN_CREATION_MAP.get(className);\n+        if (lock == null) {\n+            CLASS_IN_CREATION_MAP.putIfAbsent(className, new ReentrantLock());\n+            lock = CLASS_IN_CREATION_MAP.get(className);\n+        }\n         try {\n-            return Class.forName(className, true, org.apache.dubbo.common.utils.ClassUtils.getCallerClassLoader(getClass()));\n+            lock.lock();\n+            return Class.forName(className, true, classLoader);\n         } catch (ClassNotFoundException e) {\n             if (!code.endsWith(\"}\")) {\n                 throw new IllegalStateException(\"The java code not endsWith \\\"}\\\", code: \\n\" + code + \"\\n\");\n             }\n             try {\n-                return doCompile(className, code);\n+                return doCompile(classLoader, className, code);\n             } catch (RuntimeException t) {\n                 throw t;\n             } catch (Throwable t) {\n                 throw new IllegalStateException(\"Failed to compile class, cause: \" + t.getMessage() + \", class: \" + className + \", code: \\n\" + code + \"\\n, stack: \" + ClassUtils.toString(t));\n             }\n+        } finally {\n+            lock.unlock();\n         }\n     }\n-    protected abstract Class<?> doCompile(String name, String source) throws Throwable;\n+    protected abstract Class<?> doCompile(ClassLoader classLoader, String name, String source) throws Throwable;\n }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JavassistCompiler.java b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JavassistCompiler.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JavassistCompiler.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JavassistCompiler.java\n@@ -39,7 +39,7 @@ public class JavassistCompiler extends AbstractCompiler {\n     private static final Pattern FIELD_PATTERN = Pattern.compile(\"[^\\n]+=[^\\n]+;\");\n     @Override\n-    public Class<?> doCompile(String name, String source) throws Throwable {\n+    public Class<?> doCompile(ClassLoader classLoader, String name, String source) throws Throwable {\n         CtClassBuilder builder = new CtClassBuilder();\n         builder.setClassName(name);\n@@ -77,7 +77,6 @@ public Class<?> doCompile(String name, String source) throws Throwable {\n         });\n         // compile\n-        ClassLoader classLoader = org.apache.dubbo.common.utils.ClassUtils.getCallerClassLoader(getClass());\n         CtClass cls = builder.build(classLoader);\n         return cls.toClass(classLoader, JavassistCompiler.class.getProtectionDomain());\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JdkCompiler.java b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JdkCompiler.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JdkCompiler.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/JdkCompiler.java\n@@ -110,7 +110,7 @@ public JdkCompiler(String javaVersion) {\n     }\n     @Override\n-    public Class<?> doCompile(String name, String sourceCode) throws Throwable {\n+    public Class<?> doCompile(ClassLoader ignored, String name, String sourceCode) throws Throwable {\n         int i = name.lastIndexOf('.');\n         String packageName = i < 0 ? \"\" : name.substring(0, i);\n         String className = i < 0 ? name : name.substring(i + 1);\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java b/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java\n@@ -1163,7 +1163,8 @@ private Class<?> getAdaptiveExtensionClass() {\n     }\n     private Class<?> createAdaptiveExtensionClass() {\n-        ClassLoader classLoader = findClassLoader();\n+        // Adaptive Classes' ClassLoader should be the same with Real SPI interface classes' ClassLoader\n+        ClassLoader classLoader = type.getClassLoader();\n         try {\n             if (NativeUtils.isNative()) {\n                 return classLoader.loadClass(type.getName() + \"$Adaptive\");",
    "output": "Fix Concurrent issue when creating SPIs' Adaptive class * Fix Concurrent issue when creating SPIs' Adaptive class * Fix ut"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java b/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n@@ -119,7 +119,7 @@ public void testMonitorConfig() {\n     // Test MonitorConfig correlative methods\n     @Test\n-    public void tesModuleConfig() {\n+    public void testModuleConfig() {\n         ModuleConfig config = new ModuleConfig();\n         moduleConfigManager.setModule(config);\n         assertTrue(moduleConfigManager.getModule().isPresent());",
    "output": "Fix ConfigManagerTest spelling-mistake"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n@@ -186,7 +186,7 @@ protected void checkRef() {\n         if (!interfaceClass.isInstance(ref)) {\n             throw new IllegalStateException(\"The class \"\n                 + ref.getClass().getName() + getClassloaderDesc(ref.getClass()) + \" unimplemented interface \"\n-                + interfaceClass + getClassloaderDesc(ref.getClass()) + \"!\");\n+                + interfaceClass + getClassloaderDesc(interfaceClass) + \"!\");\n         }\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -67,6 +67,7 @@\n import java.io.FileInputStream;\n import java.io.IOException;\n import java.lang.reflect.Constructor;\n+import java.net.URLDecoder;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -938,9 +939,10 @@ public void testDifferentClassLoader() throws Exception {\n         serviceConfig.export();\n         String basePath = DemoService.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n-        basePath = java.net.URLDecoder.decode(basePath, \"UTF-8\");\n-        TestClassLoader classLoader1 = new TestClassLoader(Thread.currentThread().getContextClassLoader(), basePath);\n-        TestClassLoader classLoader2 = new TestClassLoader(Thread.currentThread().getContextClassLoader(), basePath);\n+        basePath = URLDecoder.decode(basePath, \"UTF-8\");\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        TestClassLoader classLoader1 = new TestClassLoader(classLoader, basePath);\n+        TestClassLoader classLoader2 = new TestClassLoader(classLoader, basePath);\n         Class<?> class1 = classLoader1.loadClass(DemoService.class.getName(), false);\n         Class<?> class2 = classLoader2.loadClass(DemoService.class.getName(), false);\n@@ -988,12 +990,16 @@ public void testDifferentClassLoader() throws Exception {\n         Assertions.assertNotEquals(result1.getClass(), result2.getClass());\n         applicationModel.destroy();\n+        DubboBootstrap.getInstance().destroy();\n+        Thread.currentThread().setContextClassLoader(classLoader);\n+        Thread.currentThread().getContextClassLoader().loadClass(DemoService.class.getName());\n     }\n     @Test\n     public void testDifferentClassLoaderRequest() throws Exception {\n         String basePath = DemoService.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n         basePath = java.net.URLDecoder.decode(basePath, \"UTF-8\");\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n         TestClassLoader1 classLoader1 = new TestClassLoader1(basePath);\n         TestClassLoader1 classLoader2 = new TestClassLoader1(basePath);\n         TestClassLoader2 classLoader3 = new TestClassLoader2(classLoader2, basePath);\n@@ -1046,6 +1052,9 @@ public void testDifferentClassLoaderRequest() throws Exception {\n         Assertions.assertEquals(classLoader1, innerRequestReference.get().getClass().getClassLoader());\n         applicationModel.destroy();\n+        DubboBootstrap.getInstance().destroy();\n+        Thread.currentThread().setContextClassLoader(classLoader);\n+        Thread.currentThread().getContextClassLoader().loadClass(DemoService.class.getName());\n     }\n     private Class<?> compileCustomRequest(ClassLoader classLoader) throws NotFoundException, CannotCompileException {",
    "output": "Fix exception info * fix exception info * fix test * Restore classload"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscoveryTest.java b/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscoveryTest.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscoveryTest.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscoveryTest.java\n@@ -85,8 +85,21 @@ public void testRegistration() throws InterruptedException {\n         DefaultServiceInstance serviceInstance = createServiceInstance(SERVICE_NAME, LOCALHOST, NetUtils.getAvailablePort());\n+        CountDownLatch latch = new CountDownLatch(1);\n+\n+        // Add Listener\n+        discovery.addServiceInstancesChangedListener(\n+                new ServiceInstancesChangedListener(Sets.newSet(SERVICE_NAME), discovery) {\n+            @Override\n+            public void onEvent(ServiceInstancesChangedEvent event) {\n+                latch.countDown();\n+            }\n+        });\n+\n         discovery.register(serviceInstance);\n+        latch.await();\n+\n         List<ServiceInstance> serviceInstances = discovery.getInstances(SERVICE_NAME);\n         assertTrue(serviceInstances.contains(serviceInstance));",
    "output": "Add latch waiting for registration finished"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n@@ -17,15 +17,12 @@\n package org.apache.dubbo.rpc.cluster;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.Version;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.threadpool.manager.ExecutorRepository;\n import org.apache.dubbo.common.utils.CollectionUtils;\n-import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n-import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.cluster.router.state.AddrCache;\n import org.apache.dubbo.rpc.cluster.router.state.BitList;\n import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n@@ -169,26 +166,23 @@ public List<StateRouter> getStateRouters() {\n     public List<Invoker<T>> route(URL url, Invocation invocation) {\n         AddrCache<T> cache = this.cache.get();\n-        if (cache == null) {\n-            throw new RpcException(RpcException.ROUTER_CACHE_NOT_BUILD, \"Failed to invoke the method \"\n-                + invocation.getMethodName() + \" in the service \" + url.getServiceInterface()\n-                + \". address cache not build \"\n-                + \" on the consumer \" + NetUtils.getLocalHost()\n-                + \" using the dubbo version \" + Version.getVersion()\n-                + \".\");\n-        }\n-        BitList<Invoker<T>> finalBitListInvokers = new BitList<>(invokers, false);\n-        for (StateRouter stateRouter : stateRouters) {\n-            if (stateRouter.isEnable()) {\n-                RouterCache<T> routerCache = cache.getCache().get(stateRouter.getName());\n-                finalBitListInvokers = stateRouter.route(finalBitListInvokers, routerCache, url, invocation);\n+        List<Invoker<T>> finalInvokers = null;\n+\n+        if (cache != null) {\n+            BitList<Invoker<T>> finalBitListInvokers = new BitList<>(invokers, false);\n+            for (StateRouter stateRouter : stateRouters) {\n+                if (stateRouter.isEnable()) {\n+                    RouterCache<T> routerCache = cache.getCache().get(stateRouter.getName());\n+                    finalBitListInvokers = stateRouter.route(finalBitListInvokers, routerCache, url, invocation);\n+                }\n             }\n-        }\n+            finalInvokers = new ArrayList<>(finalBitListInvokers.size());\n-        List<Invoker<T>> finalInvokers = new ArrayList<>(finalBitListInvokers.size());\n+            finalInvokers.addAll(finalBitListInvokers);\n+        }\n-        for(Invoker<T> invoker: finalBitListInvokers) {\n-            finalInvokers.add(invoker);\n+        if (finalInvokers == null) {\n+            finalInvokers = new ArrayList<>(invokers);\n         }\n         for (Router router : routers) {",
    "output": "Fix State Router Throw Exception when Address is Empty"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvokerTest.java\n@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.support;\n+\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.rpc.AppResponse;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.Result;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.RpcInvocation;\n+import org.apache.dubbo.rpc.cluster.Directory;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Test for AvailableClusterInvoker\n+ */\n+public class AvailableClusterInvokerTest {\n+\n+    private final URL url = URL.valueOf(\"test://test:80/test\");\n+    private final Invoker<AvailableClusterInvokerTest> invoker1 = mock(Invoker.class);\n+    private final Invoker<AvailableClusterInvokerTest> invoker2 = mock(Invoker.class);\n+    private final Invoker<AvailableClusterInvokerTest> invoker3 = mock(Invoker.class);\n+    private final RpcInvocation invocation = new RpcInvocation();\n+    private final Result result = new AppResponse();\n+    private final List<Invoker<AvailableClusterInvokerTest>> invokers = new ArrayList<>();\n+    private Directory<AvailableClusterInvokerTest> dic;\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+\n+        dic = mock(Directory.class);\n+\n+        given(dic.getUrl()).willReturn(url);\n+        given(dic.getConsumerUrl()).willReturn(url);\n+        given(dic.list(invocation)).willReturn(invokers);\n+        given(dic.getInterface()).willReturn(AvailableClusterInvokerTest.class);\n+\n+        invocation.setMethodName(\"method1\");\n+\n+        invokers.add(invoker1);\n+        invokers.add(invoker2);\n+        invokers.add(invoker3);\n+    }\n+\n+    private void resetInvokerToNoException() {\n+\n+        given(invoker1.invoke(invocation)).willReturn(result);\n+        given(invoker1.getUrl()).willReturn(url);\n+        given(invoker1.isAvailable()).willReturn(true);\n+        given(invoker1.getInterface()).willReturn(AvailableClusterInvokerTest.class);\n+\n+        given(invoker2.invoke(invocation)).willReturn(result);\n+        given(invoker2.getUrl()).willReturn(url);\n+        given(invoker2.isAvailable()).willReturn(true);\n+        given(invoker2.getInterface()).willReturn(AvailableClusterInvokerTest.class);\n+\n+        given(invoker3.invoke(invocation)).willReturn(result);\n+        given(invoker3.getUrl()).willReturn(url);\n+        given(invoker3.isAvailable()).willReturn(true);\n+        given(invoker3.getInterface()).willReturn(AvailableClusterInvokerTest.class);\n+    }\n+\n+    @Test()\n+    public void testInvokeNoException() {\n+\n+        resetInvokerToNoException();\n+\n+        AvailableClusterInvoker<AvailableClusterInvokerTest> invoker = new AvailableClusterInvoker<>(dic);\n+        Result ret = invoker.invoke(invocation);\n+        Assertions.assertSame(result, ret);\n+    }\n+\n+    @Test()\n+    public void testInvokeWithException() {\n+\n+        // remove invokers for test exception\n+        dic.list(invocation).removeAll(invokers);\n+\n+        AvailableClusterInvoker<AvailableClusterInvokerTest> invoker = new AvailableClusterInvoker<>(dic);\n+        try {\n+            invoker.invoke(invocation);\n+            fail();\n+        } catch (RpcException e) {\n+            Assertions.assertTrue(e.getMessage().contains(\"No provider available in\"));\n+            assertFalse(e.getCause() instanceof RpcException);\n+        }\n+    }\n+}",
    "output": "Add some AvailableClusterInvoker unit test"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n@@ -26,7 +26,7 @@ public abstract class AbstractServiceDiscovery implements ServiceDiscovery {\n     private volatile boolean isDestroy;\n-    protected ServiceInstance serviceInstance;\n+    protected volatile ServiceInstance serviceInstance;\n     @Override\n     public final ServiceInstance getLocalInstance() {\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n@@ -254,9 +254,9 @@ public static void registerMetadataAndInstance(ServiceInstance serviceInstance)\n                 ServiceInstance serviceInstanceForRegistry = new DefaultServiceInstance((DefaultServiceInstance) serviceInstance);\n                 calInstanceRevision(serviceDiscovery, serviceInstanceForRegistry);\n                 if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.info(\"Start registering instance address to registry\" + serviceDiscovery.getUrl() + \", instance \" + serviceInstanceForRegistry);\n+                    LOGGER.debug(\"Start registering instance address to registry\" + serviceDiscovery.getUrl() + \", instance \" + serviceInstanceForRegistry);\n                 }\n-                // register metadata\n+                // register service instance\n                 serviceDiscovery.register(serviceInstanceForRegistry);\n             });\n         }\n@@ -285,7 +285,7 @@ public static void customizeInstance(ServiceInstance instance) {\n                 instance.getOrDefaultApplicationModel().getExtensionLoader(ServiceInstanceCustomizer.class);\n         // FIXME, sort customizer before apply\n         loader.getSupportedExtensionInstances().forEach(customizer -> {\n-            // customizes\n+            // customize\n             customizer.customize(instance);\n         });\n     }",
    "output": "Add volatile modifier to AbstractServiceDiscovery#serviceInstance 1.add volatile 2.log level"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n@@ -26,21 +26,20 @@\n import org.apache.dubbo.metadata.ServiceNameMapping;\n import org.apache.dubbo.metadata.WritableMetadataService;\n import org.apache.dubbo.registry.NotifyListener;\n-import org.apache.dubbo.registry.Registry;\n import org.apache.dubbo.registry.client.event.ServiceInstancesChangedEvent;\n import org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;\n import org.apache.dubbo.registry.client.metadata.SubscribedURLsSynthesizer;\n import org.apache.dubbo.registry.support.RegistryManager;\n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n import java.util.TreeSet;\n import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.dubbo.registry.support.FailbackRegistry;\n import static java.lang.String.format;\n import static org.apache.dubbo.common.constants.CommonConstants.CHECK_KEY;\n@@ -69,33 +68,29 @@\n  * - Maps interface to applications depending on ServiceNameMapping.\n  * - Starts the new service discovery listener (InstanceListener) and makes NotifierListeners part of the InstanceListener.\n  */\n-public class ServiceDiscoveryRegistry implements Registry {\n+public class ServiceDiscoveryRegistry extends FailbackRegistry {\n     protected final Logger logger = LoggerFactory.getLogger(getClass());\n     private final ServiceDiscovery serviceDiscovery;\n     private final WritableMetadataService writableMetadataService;\n-    private final Set<String> registeredListeners = new LinkedHashSet<>();\n-\n     /* apps - listener */\n     private final Map<String, ServiceInstancesChangedListener> serviceListeners = new ConcurrentHashMap<>();\n-    private URL registryURL;\n-\n     private RegistryManager registryManager;\n     public ServiceDiscoveryRegistry(URL registryURL) {\n-        this.registryURL = registryURL;\n+        super(registryURL);\n         this.serviceDiscovery = createServiceDiscovery(registryURL);\n         this.writableMetadataService = WritableMetadataService.getDefaultExtension(registryURL.getScopeModel());\n         this.registryManager = registryURL.getOrDefaultApplicationModel().getBeanFactory().getBean(RegistryManager.class);\n     }\n     // Currently, for test purpose\n     protected ServiceDiscoveryRegistry(URL registryURL, ServiceDiscovery serviceDiscovery, WritableMetadataService writableMetadataService) {\n-        this.registryURL = registryURL;\n+        super(registryURL);\n         this.serviceDiscovery = serviceDiscovery;\n         this.writableMetadataService = writableMetadataService;\n     }\n@@ -161,6 +156,7 @@ public final void register(URL url) {\n         doRegister(url);\n     }\n+    @Override\n     public void doRegister(URL url) {\n         url = addRegistryClusterKey(url);\n         if (writableMetadataService.exportURL(url)) {\n@@ -182,6 +178,7 @@ public final void unregister(URL url) {\n         doUnregister(url);\n     }\n+    @Override\n     public void doUnregister(URL url) {\n         url = addRegistryClusterKey(url);\n         if (writableMetadataService.unexportURL(url)) {\n@@ -204,15 +201,16 @@ public final void subscribe(URL url, NotifyListener listener) {\n         doSubscribe(url, listener);\n     }\n+    @Override\n     public void doSubscribe(URL url, NotifyListener listener) {\n         writableMetadataService.subscribeURL(url);\n         boolean check = url.getParameter(CHECK_KEY, false);\n         Set<String> subscribedServices = Collections.emptySet();\n         try {\n-            ServiceNameMapping serviceNameMapping = ServiceNameMapping.getDefaultExtension(registryURL.getScopeModel());\n-            subscribedServices = serviceNameMapping.getAndListenServices(registryURL, url, new DefaultMappingListener(url, subscribedServices, listener));\n+            ServiceNameMapping serviceNameMapping = ServiceNameMapping.getDefaultExtension(this.getUrl().getScopeModel());\n+            subscribedServices = serviceNameMapping.getAndListenServices(this.getUrl(), url, new DefaultMappingListener(url, subscribedServices, listener));\n         } catch (Exception e) {\n             logger.warn(\"Cannot find app mapping for service \" + url.getServiceInterface() + \", will not migrate.\", e);\n         }\n@@ -244,6 +242,7 @@ private URL addRegistryClusterKey(URL url) {\n         return url;\n     }\n+    @Override\n     public void doUnsubscribe(URL url, NotifyListener listener) {\n         // TODO: remove service name mapping listener\n         writableMetadataService.unsubscribeURL(url);\n@@ -266,11 +265,6 @@ public List<URL> lookup(URL url) {\n         throw new UnsupportedOperationException(\"\");\n     }\n-    @Override\n-    public URL getUrl() {\n-        return registryURL;\n-    }\n-\n     @Override\n     public boolean isAvailable() {\n         return !serviceDiscovery.isDestroy() && !serviceDiscovery.getServices().isEmpty();",
    "output": "Fix registry cast to AbstractRegistry error in telnet * chore:add @Override for some methods * chore:delete unused import * chore:checkstyle"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java b/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java\n--- a/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java\n+++ b/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java\n@@ -88,6 +88,8 @@ public void close() {\n         try {\n             tomcat.stop();\n+            // close port by destroy()\n+            tomcat.destroy();\n         } catch (Exception e) {\n             logger.warn(e.getMessage(), e);\n         }\ndiff --git a/dubbo-remoting/dubbo-remoting-http/src/test/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpBinderTest.java b/dubbo-remoting/dubbo-remoting-http/src/test/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpBinderTest.java\n--- a/dubbo-remoting/dubbo-remoting-http/src/test/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpBinderTest.java\n+++ b/dubbo-remoting/dubbo-remoting-http/src/test/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpBinderTest.java\n@@ -52,5 +52,6 @@ public void handle(HttpServletRequest request, HttpServletResponse response) thr\n         assertThat(response, is(\"Tomcat\"));\n         httpServer.close();\n+        assertThat(NetUtils.isPortInUsed(port), is(false));\n     }\n }",
    "output": "Add destroy() calling to close tomcat server port"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n@@ -127,9 +127,9 @@ protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, Load\n             Method method;\n             try {\n                 method = returnType.getMethod(merger, returnType);\n-            } catch (NoSuchMethodException e) {\n+            } catch (NoSuchMethodException | NullPointerException e) {\n                 throw new RpcException(\"Can not merge result because missing method [ \" + merger + \" ] in class [ \" +\n-                        returnType.getName() + \" ]\");\n+                    returnType.getName() + \" ]\");\n             }\n             if (!Modifier.isPublic(method.getModifiers())) {\n                 method.setAccessible(true);",
    "output": "Fix MergeableClusterInvoker NPE"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -250,8 +250,11 @@ public synchronized void exportOnly() {\n         if (this.shouldExport()) {\n             this.init();\n-            // just do export, delay export is done by caller\n-            doExport();\n+            if (shouldDelay()) {\n+                doDelayExport();\n+            } else {\n+                doExport();\n+            }\n         }\n     }",
    "output": "Fix delay export not work for ServiceConfig"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboConfigBeanInitializer.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboConfigBeanInitializer.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboConfigBeanInitializer.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboConfigBeanInitializer.java\n@@ -40,6 +40,7 @@\n import org.springframework.beans.factory.BeanFactoryAware;\n import org.springframework.beans.factory.InitializingBean;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -66,6 +67,7 @@ public class DubboConfigBeanInitializer implements BeanFactoryAware, Initializin\n     private ConfigManager configManager;\n     @Autowired\n+    @Qualifier(\"org.apache.dubbo.rpc.model.ModuleModel\")\n     private ModuleModel moduleModel;\n     @Override",
    "output": "Add ModuleModel Qualifier for SpringBean Initializer"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java\n@@ -110,7 +110,7 @@ public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache<T\n     }\n     private boolean isForceUseTag(Invocation invocation) {\n-        return Boolean.valueOf(invocation.getAttachment(FORCE_USE_TAG, url.getParameter(FORCE_USE_TAG, \"false\")));\n+        return Boolean.parseBoolean(invocation.getAttachment(FORCE_USE_TAG, url.getParameter(FORCE_USE_TAG, \"false\")));\n     }\n     @Override\n@@ -249,7 +249,6 @@ public <T> void notify(List<Invoker<T>> invokers) {\n                 }\n             }\n         }\n-        pool(invokers);\n     }\n     @Override\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java\n@@ -137,8 +137,6 @@ public <T> void notify(List<Invoker<T>> invokers) {\n         if (CollectionUtils.isEmpty(invokers)) {\n             return;\n         }\n-\n-        pool(invokers);\n     }\n }",
    "output": "Remove meaningless code"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.common.config.ConfigurationUtils;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.ClassUtils;\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.metadata.InstanceMetadataChangedListener;\n@@ -242,7 +243,10 @@ public void publishServiceDefinition(URL url) {\n             String interfaceName = url.getServiceInterface();\n             if (StringUtils.isNotEmpty(interfaceName)\n                 && !ProtocolUtils.isGeneric(url.getParameter(GENERIC_KEY))) {\n-                Class interfaceClass = Class.forName(interfaceName);\n+                ClassLoader classLoader = url.getServiceModel() != null ?\n+                    url.getServiceModel().getClassLoader() :\n+                    ClassUtils.getClassLoader();\n+                Class interfaceClass = Class.forName(interfaceName, false, classLoader);\n                 ServiceDefinition serviceDefinition = ServiceDefinitionBuilder.build(interfaceClass);\n                 Gson gson = new Gson();\n                 String data = gson.toJson(serviceDefinition);\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.ClassUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.metadata.MetadataInfo;\n import org.apache.dubbo.metadata.WritableMetadataService;\n@@ -136,7 +137,10 @@ private void publishProvider(URL providerUrl) throws RpcException {\n         try {\n             String interfaceName = providerUrl.getServiceInterface();\n             if (StringUtils.isNotEmpty(interfaceName)) {\n-                Class interfaceClass = Class.forName(interfaceName);\n+                ClassLoader classLoader = providerUrl.getServiceModel() != null ?\n+                    providerUrl.getServiceModel().getClassLoader() :\n+                    ClassUtils.getClassLoader();\n+                Class interfaceClass = Class.forName(interfaceName, false, classLoader);\n                 FullServiceDefinition fullServiceDefinition = ServiceDefinitionBuilder.buildFullDefinition(interfaceClass,\n                     providerUrl.getParameters());\n                 for (Map.Entry<String, MetadataReport> entry : getMetadataReports().entrySet()) {",
    "output": "Fix Class.forName when publish ServiceDefinition"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/logger/support/FailsafeLogger.java b/dubbo-common/src/main/java/org/apache/dubbo/common/logger/support/FailsafeLogger.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/logger/support/FailsafeLogger.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/logger/support/FailsafeLogger.java\n@@ -24,10 +24,16 @@ public class FailsafeLogger implements Logger {\n     private Logger logger;\n+    private static boolean disabled = false;\n+\n     public FailsafeLogger(Logger logger) {\n         this.logger = logger;\n     }\n+    public static void setDisabled(boolean disabled) {\n+        FailsafeLogger.disabled = disabled;\n+    }\n+\n     public Logger getLogger() {\n         return logger;\n     }\n@@ -42,6 +48,9 @@ private String appendContextMessage(String msg) {\n     @Override\n     public void trace(String msg, Throwable e) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.trace(appendContextMessage(msg), e);\n         } catch (Throwable t) {\n@@ -50,6 +59,9 @@ public void trace(String msg, Throwable e) {\n     @Override\n     public void trace(Throwable e) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.trace(e);\n         } catch (Throwable t) {\n@@ -58,6 +70,9 @@ public void trace(Throwable e) {\n     @Override\n     public void trace(String msg) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.trace(appendContextMessage(msg));\n         } catch (Throwable t) {\n@@ -66,6 +81,9 @@ public void trace(String msg) {\n     @Override\n     public void debug(String msg, Throwable e) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.debug(appendContextMessage(msg), e);\n         } catch (Throwable t) {\n@@ -74,6 +92,9 @@ public void debug(String msg, Throwable e) {\n     @Override\n     public void debug(Throwable e) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.debug(e);\n         } catch (Throwable t) {\n@@ -82,6 +103,9 @@ public void debug(Throwable e) {\n     @Override\n     public void debug(String msg) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.debug(appendContextMessage(msg));\n         } catch (Throwable t) {\n@@ -90,6 +114,9 @@ public void debug(String msg) {\n     @Override\n     public void info(String msg, Throwable e) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.info(appendContextMessage(msg), e);\n         } catch (Throwable t) {\n@@ -98,6 +125,9 @@ public void info(String msg, Throwable e) {\n     @Override\n     public void info(String msg) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.info(appendContextMessage(msg));\n         } catch (Throwable t) {\n@@ -106,6 +136,9 @@ public void info(String msg) {\n     @Override\n     public void warn(String msg, Throwable e) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.warn(appendContextMessage(msg), e);\n         } catch (Throwable t) {\n@@ -114,6 +147,9 @@ public void warn(String msg, Throwable e) {\n     @Override\n     public void warn(String msg) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.warn(appendContextMessage(msg));\n         } catch (Throwable t) {\n@@ -122,6 +158,9 @@ public void warn(String msg) {\n     @Override\n     public void error(String msg, Throwable e) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.error(appendContextMessage(msg), e);\n         } catch (Throwable t) {\n@@ -130,6 +169,9 @@ public void error(String msg, Throwable e) {\n     @Override\n     public void error(String msg) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.error(appendContextMessage(msg));\n         } catch (Throwable t) {\n@@ -138,6 +180,9 @@ public void error(String msg) {\n     @Override\n     public void error(Throwable e) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.error(e);\n         } catch (Throwable t) {\n@@ -146,6 +191,9 @@ public void error(Throwable e) {\n     @Override\n     public void info(Throwable e) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.info(e);\n         } catch (Throwable t) {\n@@ -154,6 +202,9 @@ public void info(Throwable e) {\n     @Override\n     public void warn(Throwable e) {\n+        if (disabled) {\n+            return;\n+        }\n         try {\n             logger.warn(e);\n         } catch (Throwable t) {\n@@ -162,6 +213,9 @@ public void warn(Throwable e) {\n     @Override\n     public boolean isTraceEnabled() {\n+        if (disabled) {\n+            return false;\n+        }\n         try {\n             return logger.isTraceEnabled();\n         } catch (Throwable t) {\n@@ -171,6 +225,9 @@ public boolean isTraceEnabled() {\n     @Override\n     public boolean isDebugEnabled() {\n+        if (disabled) {\n+            return false;\n+        }\n         try {\n             return logger.isDebugEnabled();\n         } catch (Throwable t) {\n@@ -180,6 +237,9 @@ public boolean isDebugEnabled() {\n     @Override\n     public boolean isInfoEnabled() {\n+        if (disabled) {\n+            return false;\n+        }\n         try {\n             return logger.isInfoEnabled();\n         } catch (Throwable t) {\n@@ -189,6 +249,9 @@ public boolean isInfoEnabled() {\n     @Override\n     public boolean isWarnEnabled() {\n+        if (disabled) {\n+            return false;\n+        }\n         try {\n             return logger.isWarnEnabled();\n         } catch (Throwable t) {\n@@ -198,6 +261,9 @@ public boolean isWarnEnabled() {\n     @Override\n     public boolean isErrorEnabled() {\n+        if (disabled) {\n+            return false;\n+        }\n         try {\n             return logger.isErrorEnabled();\n         } catch (Throwable t) {",
    "output": "Add Logger Disabled Option"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java b/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java\n@@ -112,7 +112,13 @@ public <T> T getOrRegisterBean(Class<T> type) {\n     public <T> T getOrRegisterBean(String name, Class<T> type) {\n         T bean = getBean(name, type);\n         if (bean == null) {\n-            bean = createAndRegisterBean(name, type);\n+            // lock by type\n+            synchronized (type) {\n+                bean = getBean(name, type);\n+                if (bean == null) {\n+                    bean = createAndRegisterBean(name, type);\n+                }\n+            }\n         }\n         return bean;\n     }\n@@ -124,9 +130,14 @@ public <T> T getOrRegisterBean(Class<T> type, Function<? super Class<T>, ? exten\n     public <T> T getOrRegisterBean(String name, Class<T> type, Function<? super Class<T>, ? extends T> mappingFunction) {\n         T bean = getBean(name, type);\n         if (bean == null) {\n-            //TODO add lock for type\n-            bean = mappingFunction.apply(type);\n-            registerBean(name, bean);\n+            // lock by type\n+            synchronized (type) {\n+                bean = getBean(name, type);\n+                if (bean == null) {\n+                    bean = mappingFunction.apply(type);\n+                    registerBean(name, bean);\n+                }\n+            }\n         }\n         return bean;\n     }",
    "output": "Fix concurrent bean creation error"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n@@ -206,6 +206,9 @@ public void onDestroy() {\n         for (ModuleModel moduleModel : new ArrayList<>(moduleModels)) {\n             moduleModel.destroy();\n         }\n+\n+        notifyDestroy();\n+\n         if (defaultInstance == this) {\n             synchronized (ApplicationModel.class) {\n                 frameworkModel.removeApplication(this);\n@@ -220,8 +223,6 @@ public void onDestroy() {\n             deployer = null;\n         }\n-        notifyDestroy();\n-\n         if (environment != null) {\n             environment.destroy();\n             environment = null;\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java\n@@ -76,14 +76,14 @@ public void onDestroy() {\n             applicationModel.destroy();\n         }\n+        notifyDestroy();\n+\n         allInstances.remove(this);\n         if (defaultInstance == this) {\n             synchronized (FrameworkModel.class) {\n                 defaultInstance = null;\n             }\n         }\n-\n-        notifyDestroy();\n     }\n     public static FrameworkModel defaultModel() {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n@@ -82,6 +82,7 @@ private void initModuleExt() {\n     @Override\n     public void onDestroy() {\n+        notifyDestroy();\n         applicationModel.removeModule(this);\n         if (deployer != null) {\n@@ -93,8 +94,6 @@ public void onDestroy() {\n             serviceRepository = null;\n         }\n-        notifyDestroy();\n-\n         if (moduleEnvironment != null) {\n             moduleEnvironment.destroy();\n             moduleEnvironment = null;",
    "output": "Fix destroy notify order"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/AbstractDeployer.java b/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/AbstractDeployer.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/AbstractDeployer.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/AbstractDeployer.java\n@@ -93,6 +93,10 @@ public void removeDeployListener(DeployListener<E> listener) {\n         listeners.remove(listener);\n     }\n+    public void setPending() {\n+        this.state = PENDING;\n+    }\n+\n     protected void setStarting() {\n         this.state = STARTING;\n         for (DeployListener<E> listener : listeners) {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/ModuleDeployer.java b/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/ModuleDeployer.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/ModuleDeployer.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/deploy/ModuleDeployer.java\n@@ -41,6 +41,8 @@ public interface ModuleDeployer extends Deployer<ModuleModel> {\n     void prepare();\n+    void setPending();\n+\n     void notifyExportService(ServiceConfigBase<?> sc);\n     boolean isAsync();\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java\n@@ -832,7 +832,9 @@ public void checkStarting() {\n     @Override\n     public void checkStarted() {\n         for (ModuleModel moduleModel : applicationModel.getModuleModels()) {\n-            if (!moduleModel.getDeployer().isStarted()) {\n+            if (moduleModel.getDeployer().isPending()) {\n+                setPending();\n+            } else if (moduleModel.getDeployer().isStarting()) {\n                 return;\n             }\n         }\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n@@ -90,6 +90,7 @@ public void afterPropertiesSet() throws Exception {\n         //register service bean\n         ModuleModel moduleModel = DubboBeanUtils.getModuleModel(applicationContext);\n         moduleModel.getConfigManager().addService(this);\n+        moduleModel.getDeployer().setPending();\n     }\n     /**",
    "output": "Fix Deployer State for delay injected bean"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ServiceAnnotationResolver.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ServiceAnnotationResolver.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ServiceAnnotationResolver.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ServiceAnnotationResolver.java\n@@ -84,7 +84,7 @@ private Annotation getServiceAnnotation(Class<?> serviceType) {\n      */\n     public String resolveInterfaceClassName() {\n-        Class interfaceClass = null;\n+        Class interfaceClass;\n         // first, try to get the value from \"interfaceName\" attribute\n         String interfaceName = resolveAttribute(\"interfaceName\");\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/rest/ClassPathServiceRestMetadataReader.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/rest/ClassPathServiceRestMetadataReader.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/rest/ClassPathServiceRestMetadataReader.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/rest/ClassPathServiceRestMetadataReader.java\n@@ -41,14 +41,14 @@\n  */\n public class ClassPathServiceRestMetadataReader implements ServiceRestMetadataReader {\n-    private final String serviceRestMetadataJsonResoucePath;\n+    private final String serviceRestMetadataJsonResourcePath;\n     public ClassPathServiceRestMetadataReader() {\n         this(SERVICE_REST_METADATA_RESOURCE_PATH);\n     }\n-    public ClassPathServiceRestMetadataReader(String serviceRestMetadataJsonResoucePath) {\n-        this.serviceRestMetadataJsonResoucePath = serviceRestMetadataJsonResoucePath;\n+    public ClassPathServiceRestMetadataReader(String serviceRestMetadataJsonResourcePath) {\n+        this.serviceRestMetadataJsonResourcePath = serviceRestMetadataJsonResourcePath;\n     }\n     @Override\n@@ -59,7 +59,7 @@ public List<ServiceRestMetadata> read() {\n         ClassLoader classLoader = getClass().getClassLoader();\n         execute(() -> {\n-            Enumeration<URL> resources = classLoader.getResources(serviceRestMetadataJsonResoucePath);\n+            Enumeration<URL> resources = classLoader.getResources(serviceRestMetadataJsonResourcePath);\n             Gson gson = new Gson();\n             while (resources.hasMoreElements()) {\n                 URL resource = resources.nextElement();\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/springmvc/SpringMvcServiceRestMetadataResolverTest.java b/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/springmvc/SpringMvcServiceRestMetadataResolverTest.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/springmvc/SpringMvcServiceRestMetadataResolverTest.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/springmvc/SpringMvcServiceRestMetadataResolverTest.java\n@@ -59,7 +59,7 @@ public void testSupports() {\n     @Test\n     public void testResolve() {\n         // Generated by \"dubbo-metadata-processor\"\n-        ClassPathServiceRestMetadataReader reader = new ClassPathServiceRestMetadataReader(\"META-INF/dubbo/spring-mvc-servoce-rest-metadata.json\");\n+        ClassPathServiceRestMetadataReader reader = new ClassPathServiceRestMetadataReader(\"META-INF/dubbo/spring-mvc-service-rest-metadata.json\");\n         List<ServiceRestMetadata> serviceRestMetadataList = reader.read();\n         ServiceRestMetadata expectedServiceRestMetadata = serviceRestMetadataList.get(0);\ndiff --git a/dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java b/dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java\n--- a/dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java\n+++ b/dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java\n@@ -55,8 +55,9 @@ public class RedisMetadataReport extends AbstractMetadataReport {\n     private final static String REDIS_DATABASE_KEY = \"database\";\n     private final static Logger logger = LoggerFactory.getLogger(RedisMetadataReport.class);\n-    JedisPool pool;\n-    Set<HostAndPort> jedisClusterNodes;\n+    // protected , for test\n+    protected JedisPool pool;\n+    private Set<HostAndPort> jedisClusterNodes;\n     private int timeout;\n     private String password;\ndiff --git a/dubbo-metadata/dubbo-metadata-report-zookeeper/src/test/java/org/apache/dubbo/metadata/store/zookeeper/ZookeeperMetadataReportTest.java b/dubbo-metadata/dubbo-metadata-report-zookeeper/src/test/java/org/apache/dubbo/metadata/store/zookeeper/ZookeeperMetadataReportTest.java\n--- a/dubbo-metadata/dubbo-metadata-report-zookeeper/src/test/java/org/apache/dubbo/metadata/store/zookeeper/ZookeeperMetadataReportTest.java\n+++ b/dubbo-metadata/dubbo-metadata-report-zookeeper/src/test/java/org/apache/dubbo/metadata/store/zookeeper/ZookeeperMetadataReportTest.java\n@@ -17,7 +17,9 @@\n package org.apache.dubbo.metadata.store.zookeeper;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.config.configcenter.ConfigItem;\n import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.metadata.MetadataInfo;\n import org.apache.dubbo.metadata.definition.ServiceDefinitionBuilder;\n import org.apache.dubbo.metadata.definition.model.FullServiceDefinition;\n import org.apache.dubbo.metadata.report.MetadataReport;\n@@ -33,14 +35,13 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutionException;\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n+import static org.apache.dubbo.metadata.ServiceNameMapping.DEFAULT_MAPPING_GROUP;\n /**\n  * 2018/10/9\n@@ -273,4 +274,45 @@ private URL generateURL(String interfaceName, String version, String group, Stri\n                 + application + (group == null ? \"\" : \"&group=\" + group));\n         return url;\n     }\n+\n+\n+    @Test\n+    public void testMapping() throws InterruptedException {\n+        String serviceKey = ZookeeperMetadataReportTest.class.getName();\n+        URL url = URL.valueOf(\"test://127.0.0.1:8888/\" + serviceKey);\n+        String appNames = \"demo1,demo2\";\n+\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Set<String> serviceAppMapping = zookeeperMetadataReport.getServiceAppMapping(serviceKey, event -> {\n+            Set<String> apps = event.getApps();\n+            Assertions.assertEquals(apps.size(), 2);\n+            Assertions.assertTrue(apps.contains(\"demo1\"));\n+            Assertions.assertTrue(apps.contains(\"demo2\"));\n+            latch.countDown();\n+        }, url);\n+        Assertions.assertTrue(serviceAppMapping.isEmpty());\n+\n+        ConfigItem configItem = zookeeperMetadataReport.getConfigItem(serviceKey, DEFAULT_MAPPING_GROUP);\n+        zookeeperMetadataReport.registerServiceAppMapping(serviceKey, DEFAULT_MAPPING_GROUP, appNames, configItem.getTicket());\n+        latch.await();\n+    }\n+\n+    @Test\n+    public void testAppMetadata() {\n+        String serviceKey = ZookeeperMetadataReportTest.class.getName();\n+        String appName = \"demo\";\n+        URL url = URL.valueOf(\"test://127.0.0.1:8888/\" + serviceKey);\n+        MetadataInfo metadataInfo = new MetadataInfo(appName);\n+        metadataInfo.addService(new MetadataInfo.ServiceInfo(url));\n+\n+        SubscriberMetadataIdentifier identifier = new SubscriberMetadataIdentifier(appName, metadataInfo.calAndGetRevision());\n+        MetadataInfo appMetadata = zookeeperMetadataReport.getAppMetadata(identifier, Collections.emptyMap());\n+        Assertions.assertNull(appMetadata);\n+\n+        zookeeperMetadataReport.publishAppMetadata(identifier, metadataInfo);\n+        appMetadata = zookeeperMetadataReport.getAppMetadata(identifier, Collections.emptyMap());\n+        Assertions.assertNotNull(appMetadata);\n+        Assertions.assertEquals(appMetadata.calAndGetRevision(), metadataInfo.calAndGetRevision());\n+\n+    }\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n@@ -93,7 +93,7 @@ public ServiceDiscoveryRegistry(URL registryURL) {\n         this.registryManager = registryURL.getOrDefaultApplicationModel().getBeanFactory().getBean(RegistryManager.class);\n     }\n-    // Currently for test purpose\n+    // Currently, for test purpose\n     protected ServiceDiscoveryRegistry(URL registryURL, ServiceDiscovery serviceDiscovery, WritableMetadataService writableMetadataService) {\n         this.registryURL = registryURL;\n         this.serviceDiscovery = serviceDiscovery;\n@@ -142,7 +142,7 @@ protected boolean shouldRegister(URL providerURL) {\n         if (!should) {\n             if (logger.isDebugEnabled()) {\n-                logger.debug(String.format(\"The URL[%s] should not be registered.\", providerURL.toString()));\n+                logger.debug(String.format(\"The URL[%s] should not be registered.\", providerURL));\n             }\n         }",
    "output": "Add test case for ZookeeperMetadataReportTest * Add test case for ZookeeperMetadataReportTest 1.test case 2.fix typo 3.remove unused param * Restore original method signature * Restore original method signature"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java\n@@ -64,9 +64,9 @@ public <T> boolean shouldMigrate(ClusterInvoker<T> newInvoker, ClusterInvoker<T>\n         migrationData.put(NEW_ADDRESS_SIZE, newAddressSize);\n         String rawThreshold = null;\n-        Float configedThreshold = rule == null ? null : rule.getThreshold(oldInvoker.getUrl());\n-        if (configedThreshold != null && configedThreshold >= 0) {\n-            rawThreshold = String.valueOf(configedThreshold);\n+        Float configuredThreshold = rule == null ? null : rule.getThreshold(oldInvoker.getUrl());\n+        if (configuredThreshold != null && configuredThreshold >= 0) {\n+            rawThreshold = String.valueOf(configuredThreshold);\n         }\n         rawThreshold = StringUtils.isNotEmpty(rawThreshold) ? rawThreshold : ConfigurationUtils.getCachedDynamicProperty(newInvoker.getUrl().getScopeModel(), MIGRATION_THRESHOLD, DEFAULT_THRESHOLD_STRING);\n         float threshold;\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n@@ -54,7 +54,7 @@\n  * - Migration rule is of consumer application scope.\n  * - Listener is shared among all invokers (interfaces), it keeps the relation between interface and handler.\n  *\n- * There're two execution points:\n+ * There are two execution points:\n  * - Refer, invoker behaviour is determined with default rule.\n  * - Rule change, invoker behaviour is changed according to the newly received rule.\n  */\n@@ -63,6 +63,7 @@ public class MigrationRuleListener implements RegistryProtocolListener, Configur\n     private static final Logger logger = LoggerFactory.getLogger(MigrationRuleListener.class);\n     private static final String DUBBO_SERVICEDISCOVERY_MIGRATION = \"DUBBO_SERVICEDISCOVERY_MIGRATION\";\n     private static final String MIGRATION_DELAY_KEY = \"dubbo.application.migration.delay\";\n+    private static final int MIGRATION_DEFAULT_DELAY_TIME = 60000;\n     private String ruleKey;\n     protected final Map<MigrationInvoker, MigrationRuleHandler> handlers = new ConcurrentHashMap<>();\n@@ -117,7 +118,7 @@ private void init() {\n     }\n     private int getDelay() {\n-        int delay = 60000;\n+        int delay = MIGRATION_DEFAULT_DELAY_TIME;\n         String delayStr = ConfigurationUtils.getProperty(moduleModel, MIGRATION_DELAY_KEY);\n         if (StringUtils.isEmpty(delayStr)) {\n             return delay;\n@@ -244,6 +245,10 @@ public void onDestroy() {\n         if (localRuleMigrationFuture != null) {\n             localRuleMigrationFuture.cancel(true);\n         }\n+        if (ruleManageExecutor != null) {\n+            ruleManageExecutor.shutdown();\n+        }\n+        ruleQueue.clear();\n     }\n     public Map<MigrationInvoker, MigrationRuleHandler> getHandlers() {\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/migration/MigrationRuleListenerTest.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/migration/MigrationRuleListenerTest.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/migration/MigrationRuleListenerTest.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/client/migration/MigrationRuleListenerTest.java\n@@ -110,7 +110,7 @@ public void test() throws InterruptedException {\n      * Test listener started without local rule and config center, INIT should be used and no scheduled task should be started.\n      */\n     @Test\n-    public void testWithInitAndNoLocalRule() throws InterruptedException {\n+    public void testWithInitAndNoLocalRule() {\n         ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(null);\n         ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule(\"\");\n         ApplicationConfig applicationConfig = new ApplicationConfig();",
    "output": "Improve the logic of MigrationRuleListener#destroy method 1.Improve the logic of MigrationRuleListener#destroy method 2.Fix typo"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -140,7 +140,7 @@ public class ServiceConfig<T> extends ServiceConfigBase<T> {\n      */\n     private final List<Exporter<?>> exporters = new ArrayList<Exporter<?>>();\n-    private List<ServiceListener> serviceListeners = new ArrayList<>();\n+    private final List<ServiceListener> serviceListeners = new ArrayList<>();\n     private WritableMetadataService localMetadataService;\n     public ServiceConfig() {\n@@ -709,7 +709,7 @@ private String findConfigedHosts(ProtocolConfig protocolConfig,\n                 if (logger.isDebugEnabled()) {\n                     logger.info(\"No valid ip found from environment, try to get local host.\");\n                 }\n-                hostToBind = getLocalHost();\n+                hostToBind = getLocalHost();\n             }\n         }\n@@ -767,24 +767,24 @@ private Integer findConfigedPorts(ProtocolConfig protocolConfig,\n             }\n         }\n-        // save bind port, used as url's key later\n-        map.put(BIND_PORT_KEY, String.valueOf(portToBind));\n-\n         // registry port, not used as bind port by default\n         String portToRegistryStr = getValueFromConfig(protocolConfig, DUBBO_PORT_TO_REGISTRY);\n         Integer portToRegistry = parsePort(portToRegistryStr);\n-        if (portToRegistry == null) {\n-            portToRegistry = portToBind;\n+        if (portToRegistry != null) {\n+            portToBind = portToRegistry;\n         }\n-        return portToRegistry;\n+        // save bind port, used as url's key later\n+        map.put(BIND_PORT_KEY, String.valueOf(portToBind));\n+\n+        return portToBind;\n     }\n     private Integer parsePort(String configPort) {\n         Integer port = null;\n         if (configPort != null && configPort.length() > 0) {\n             try {\n-                Integer intPort = Integer.parseInt(configPort);\n+                int intPort = Integer.parseInt(configPort);\n                 if (isInvalidPort(intPort)) {\n                     throw new IllegalArgumentException(\"Specified invalid port from env value:\" + configPort);\n                 }\n@@ -828,10 +828,6 @@ public void addServiceListener(ServiceListener listener) {\n         this.serviceListeners.add(listener);\n     }\n-    public boolean removeServiceListener(ServiceListener listener) {\n-        return this.serviceListeners.remove(listener);\n-    }\n-\n     protected void onExported() {\n         for (ServiceListener serviceListener : this.serviceListeners) {\n             serviceListener.exported(this);",
    "output": "Fix issue-7656: When using multiple protocols and having port specifi * fix issue-7656: When using multiple protocols and having port specified, service can not be started. * remove unused code * formate code * recory initialized to volatile"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n@@ -82,7 +82,7 @@ public Object decode(Channel channel, InputStream input) throws IOException {\n         }\n         // switch TCCL\n-        if (invocation.getServiceModel() != null) {\n+        if (invocation != null && invocation.getServiceModel() != null) {\n             Thread.currentThread().setContextClassLoader(invocation.getServiceModel().getClassLoader());\n         }\n         ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)",
    "output": "Add invocation null check at decode(Channel, InputStream)"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n@@ -277,7 +277,7 @@ private static boolean addParam(String str, boolean isEncoded, int nameStart, in\n         if (isEncoded) {\n             String name = decodeComponent(str, nameStart, valueStart - 3, false, tempBuf);\n             String value;\n-            if (valueStart == valueEnd) {\n+            if (valueStart >= valueEnd) {\n                 value = name;\n             } else {\n                 value = decodeComponent(str, valueStart, valueEnd, false, tempBuf);\n@@ -290,7 +290,7 @@ private static boolean addParam(String str, boolean isEncoded, int nameStart, in\n         } else {\n             String name = str.substring(nameStart, valueStart - 1);\n             String value;\n-            if (valueStart == valueEnd) {\n+            if (valueStart >= valueEnd) {\n                 value = name;\n             } else {\n                 value = str.substring(valueStart, valueEnd);\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n@@ -1041,5 +1041,9 @@ public void testParameterContainPound() {\n         Assertions.assertEquals(\"registry\", url.getParameter(\"protocol\"));\n     }\n-\n+    @Test\n+    public void test_valueOfHasNameWithoutValue() throws Exception {\n+        URL url = URL.valueOf(\"dubbo://admin:hello1234@10.20.130.230:20880/context/path?version=1.0.0&application=morgan&noValue\");\n+        Assertions.assertEquals(\"noValue\", url.getParameter(\"noValue\"));\n+    }\n }",
    "output": "Fix StringIndexOutOfBoundsException at addParam()"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRouterRule.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRouterRule.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRouterRule.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRouterRule.java\n@@ -45,8 +45,8 @@\n public class TagRouterRule extends AbstractRouterRule {\n     private List<Tag> tags;\n-    private Map<String, List<String>> addressToTagnames = new HashMap<>();\n-    private Map<String, List<String>> tagnameToAddresses = new HashMap<>();\n+    private final Map<String, List<String>> addressToTagnames = new HashMap<>();\n+    private final Map<String, List<String>> tagnameToAddresses = new HashMap<>();\n     @SuppressWarnings(\"unchecked\")\n     public static TagRouterRule parseFromMap(Map<String, Object> map) {",
    "output": "Fix optimization field scope"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerContextFilter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerContextFilter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerContextFilter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerContextFilter.java\n@@ -47,7 +47,7 @@\n  * @see Filter\n  * @see RpcContext\n  */\n-@Activate(group = CONSUMER, order = -10000)\n+@Activate(group = CONSUMER, order = Integer.MIN_VALUE)\n public class ConsumerContextFilter implements ClusterFilter, ClusterFilter.Listener {\n     private ApplicationModel applicationModel;\n@@ -74,11 +74,11 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept\n             for (String supportedSelector : supportedSelectors) {\n                 Map<String, Object> selected = selectorExtensionLoader.getExtension(supportedSelector).select();\n                 if (CollectionUtils.isNotEmptyMap(selected)) {\n-                    ((RpcInvocation) invocation).addObjectAttachmentsIfAbsent(selected);\n+                    ((RpcInvocation) invocation).addObjectAttachments(selected);\n                 }\n             }\n         } else {\n-            ((RpcInvocation) invocation).addObjectAttachmentsIfAbsent(RpcContext.getServerAttachment().getObjectAttachments());\n+            ((RpcInvocation) invocation).addObjectAttachments(RpcContext.getServerAttachment().getObjectAttachments());\n         }\n         Map<String, Object> contextAttachments = RpcContext.getClientAttachment().getObjectAttachments();\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java\n@@ -19,7 +19,6 @@\n import org.apache.dubbo.common.Node;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.Version;\n-import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.threadpool.ThreadlessExecutor;\n@@ -34,7 +33,6 @@\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.InvokeMode;\n import org.apache.dubbo.rpc.Invoker;\n-import org.apache.dubbo.rpc.PenetrateAttachmentSelector;\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcException;\n@@ -46,7 +44,6 @@\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.Set;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.TimeUnit;\n@@ -210,22 +207,6 @@ private void addInvocationAttachments(RpcInvocation invocation) {\n         if (CollectionUtils.isNotEmptyMap(clientContextAttachments)) {\n             invocation.addObjectAttachmentsIfAbsent(clientContextAttachments);\n         }\n-\n-        // server context attachment\n-        ExtensionLoader<PenetrateAttachmentSelector> selectorExtensionLoader = invocation.getModuleModel().getExtensionLoader(PenetrateAttachmentSelector.class);\n-        Set<String> supportedSelectors = selectorExtensionLoader.getSupportedExtensions();\n-        if (CollectionUtils.isNotEmpty(supportedSelectors)) {\n-            // custom context attachment\n-            for (String supportedSelector : supportedSelectors) {\n-                Map<String, Object> selected = selectorExtensionLoader.getExtension(supportedSelector).select();\n-                if (CollectionUtils.isNotEmptyMap(selected)) {\n-                    invocation.addObjectAttachmentsIfAbsent(selected);\n-                }\n-            }\n-        } else {\n-            Map<String, Object> serverContextAttachments = RpcContext.getServerAttachment().getObjectAttachments();\n-            invocation.addObjectAttachmentsIfAbsent(serverContextAttachments);\n-        }\n     }\n     private AsyncRpcResult doInvokeAndReturn(RpcInvocation invocation) {",
    "output": "Fix RpcContext duplicated override * Fix RpcContext duplicated override * Fix import"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n@@ -138,4 +138,27 @@ public void setDeployer(ModuleDeployer deployer) {\n         this.deployer = deployer;\n     }\n+    /**\n+     * for ut only\n+     */\n+    @Deprecated\n+    public void setModuleEnvironment(ModuleEnvironment moduleEnvironment) {\n+        this.moduleEnvironment = moduleEnvironment;\n+    }\n+\n+    /**\n+     * for ut only\n+     */\n+    @Deprecated\n+    public void setServiceRepository(ModuleServiceRepository serviceRepository) {\n+        this.serviceRepository = serviceRepository;\n+    }\n+\n+    /**\n+     * for ut only\n+     */\n+    @Deprecated\n+    public void setModuleConfigManager(ModuleConfigManager moduleConfigManager) {\n+        this.moduleConfigManager = moduleConfigManager;\n+    }\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -661,6 +661,8 @@ private void exportLocal(URL url) {\n                 .setHost(LOCALHOST_VALUE)\n                 .setPort(0)\n                 .build();\n+        local = local.setScopeModel(getScopeModel())\n+            .setServiceModel(providerModel);\n         doExportUrl(local, false);\n         logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to local registry url : \" + local);\n     }",
    "output": "Add ScopeModel to Local Invoke"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n@@ -55,6 +55,7 @@\n import java.util.stream.Collectors;\n import static org.apache.dubbo.common.constants.CommonConstants.ANY_VALUE;\n+import static org.apache.dubbo.common.constants.CommonConstants.CHECK_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n@@ -227,12 +228,19 @@ private void doSubscribe(final URL url, final NotifyListener listener, final Set\n                     subscribeEventListener(serviceName, url, listener);\n                 }\n             } else {\n-                List<Instance> instances = new LinkedList<>();\n                 for (String serviceName : serviceNames) {\n+                    List<Instance> instances = new LinkedList<>();\n                     instances.addAll(namingService.getAllInstances(serviceName\n                         , getUrl().getGroup(Constants.DEFAULT_GROUP)));\n-                    notifySubscriber(url, listener, instances);\n-                    subscribeEventListener(serviceName, url, listener);\n+                    String serviceInterface = serviceName;\n+                    String[] segments = serviceName.split(SERVICE_NAME_SEPARATOR, -1);\n+                    if (segments.length == 4) {\n+                        serviceInterface = segments[SERVICE_INTERFACE_INDEX];\n+                    }\n+                    URL subscriberURL = url.setPath(serviceInterface).addParameters(INTERFACE_KEY, serviceInterface,\n+                        CHECK_KEY, String.valueOf(false));\n+                    notifySubscriber(subscriberURL, listener, instances);\n+                    subscribeEventListener(serviceName, subscriberURL, listener);\n                 }\n             }\n         }catch (Throwable cause){",
    "output": "Fix nacos admin protocol cant't get interface name"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n@@ -59,7 +59,7 @@ public class Environment extends LifecycleAdapter implements ApplicationExt {\n     protected CompositeConfiguration globalConfiguration;\n-    private List<Map<String, String>> globalConfigurationMaps;\n+    protected List<Map<String, String>> globalConfigurationMaps;\n     private CompositeConfiguration defaultDynamicGlobalConfiguration;\n@@ -293,6 +293,9 @@ public String getLocalMigrationRule() {\n     public void refreshClassLoaders() {\n         propertiesConfiguration.refresh();\n         loadMigrationRule();\n+        this.globalConfiguration = null;\n+        this.globalConfigurationMaps = null;\n+        this.defaultDynamicGlobalConfiguration = null;\n     }\n     public Configuration getDynamicGlobalConfiguration() {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/ModuleEnvironment.java\n@@ -120,6 +120,7 @@ public void setDynamicConfiguration(DynamicConfiguration dynamicConfiguration) {\n     @Override\n     public void destroy() throws IllegalStateException {\n         this.orderedPropertiesConfiguration = null;\n+        this.globalConfiguration = null;\n         this.dynamicGlobalConfiguration = null;\n         this.dynamicConfiguration = null;\n     }\n@@ -213,5 +214,8 @@ public String getLocalMigrationRule() {\n     public void refreshClassLoaders() {\n         orderedPropertiesConfiguration.refresh();\n         applicationDelegate.refreshClassLoaders();\n+        this.globalConfiguration = null;\n+        this.globalConfigurationMaps = null;\n+        this.dynamicGlobalConfiguration = null;\n     }\n }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/OrderedPropertiesConfiguration.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/OrderedPropertiesConfiguration.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/OrderedPropertiesConfiguration.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/OrderedPropertiesConfiguration.java\n@@ -26,7 +26,7 @@\n import java.util.Set;\n public class OrderedPropertiesConfiguration implements Configuration{\n-    private Properties properties = new Properties();\n+    private Properties properties;\n     private ModuleModel moduleModel;\n     public OrderedPropertiesConfiguration(ModuleModel moduleModel) {\n@@ -35,6 +35,7 @@ public OrderedPropertiesConfiguration(ModuleModel moduleModel) {\n     }\n     public void refresh() {\n+        properties = new Properties();\n         ExtensionLoader<OrderedPropertiesProvider> propertiesProviderExtensionLoader = moduleModel.getExtensionLoader(OrderedPropertiesProvider.class);\n         Set<String> propertiesProviderNames = propertiesProviderExtensionLoader.getSupportedExtensions();\n         if (propertiesProviderNames == null || propertiesProviderNames.isEmpty()) {",
    "output": "Fix ModuleModel update Properties * Fix ModuleModel update Properties * Fix ModuleModel update Properties"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java\n@@ -131,6 +131,14 @@ public ModuleServiceRepository getServiceRepository() {\n         return serviceRepository;\n     }\n+    @Override\n+    public void addClassLoader(ClassLoader classLoader) {\n+        super.addClassLoader(classLoader);\n+        if (moduleEnvironment != null) {\n+            moduleEnvironment.refreshClassLoaders();\n+        }\n+    }\n+\n     @Override\n     public ModuleEnvironment getModelEnvironment() {\n         if (moduleEnvironment == null) {",
    "output": "Fix ModuleModel update environment when update Classloaders"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java\n@@ -91,7 +91,7 @@ public static ClassPool getClassPool(ClassLoader loader) {\n         ClassPool pool = POOL_MAP.get(loader);\n         if (pool == null) {\n             pool = new ClassPool(true);\n-            pool.appendClassPath(new CustomizedLoaderClassPath(loader));\n+            pool.insertClassPath(new CustomizedLoaderClassPath(loader));\n             POOL_MAP.put(loader, pool);\n         }\n         return pool;\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n@@ -156,7 +156,7 @@ private static Wrapper makeWrapper(Class<?> c) {\n         }\n         final ClassPool classPool = new ClassPool(ClassPool.getDefault());\n-        classPool.appendClassPath(new CustomizedLoaderClassPath(cl));\n+        classPool.insertClassPath(new CustomizedLoaderClassPath(cl));\n         List<String> allMethod = new ArrayList<>();\n         try {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/CtClassBuilder.java b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/CtClassBuilder.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/CtClassBuilder.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/CtClassBuilder.java\n@@ -140,7 +140,7 @@ protected String getQualifiedClassName(String className) {\n      */\n     public CtClass build(ClassLoader classLoader) throws NotFoundException, CannotCompileException {\n         ClassPool pool = new ClassPool(true);\n-        pool.appendClassPath(new LoaderClassPath(classLoader));\n+        pool.insertClassPath(new LoaderClassPath(classLoader));\n         // create class\n         CtClass ctClass = pool.makeClass(className, pool.get(superClassName));",
    "output": "Fix Javaassist ClassPool ClassPath"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/OrderedPropertiesProvider.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/OrderedPropertiesProvider.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/OrderedPropertiesProvider.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/OrderedPropertiesProvider.java\n@@ -27,7 +27,7 @@\n  * The smaller value, the higher priority\n  *\n  */\n-@SPI(scope = ExtensionScope.APPLICATION)\n+@SPI(scope = ExtensionScope.MODULE)\n public interface OrderedPropertiesProvider {\n     /**\n      * order",
    "output": "Change OrderedPropertiesProvider SPI scope to Module"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ScopeModel.java\n@@ -52,6 +52,11 @@ public abstract class ScopeModel implements ExtensionAccessor {\n      */\n     private String internalName;\n+    /**\n+     * Public Model Name, can be set from user\n+     */\n+    private String modelName;\n+\n     private Set<ClassLoader> classLoaders;\n     private final ScopeModel parent;\n@@ -154,6 +159,7 @@ public String getInternalName() {\n     protected void setInternalName(String internalName) {\n         this.internalName = internalName;\n+        this.modelName = internalName;\n     }\n     public void addClassLoader(ClassLoader classLoader) {\n@@ -202,4 +208,12 @@ protected String buildInternalName(String type, String parentInternalId, long ch\n             return type + \"-\" + childIndex;\n         }\n     }\n+\n+    public String getModelName() {\n+        return modelName;\n+    }\n+\n+    public void setModelName(String modelName) {\n+        this.modelName = modelName;\n+    }\n }",
    "output": "Add ModelName for ScopeModel"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java\n@@ -84,7 +84,7 @@ public List<URL> build(ServiceInstance serviceInstance) {\n             url = generateWithMetadata(serviceName, host, paramsMap);\n         }\n-        url = url.setScopeModel(serviceInstance.getApplicationModel());\n+        url = url.setScopeModel(serviceInstance.getApplicationModel().getInternalModule());\n         return Collections.singletonList(url);\n     }",
    "output": "Fix MetadataInfo Module"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/registry/AddressListener.java b/dubbo-cluster/src/main/java/org/apache/dubbo/registry/AddressListener.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/registry/AddressListener.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/registry/AddressListener.java\n@@ -17,12 +17,13 @@\n package org.apache.dubbo.registry;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionScope;\n import org.apache.dubbo.common.extension.SPI;\n import org.apache.dubbo.rpc.cluster.Directory;\n import java.util.List;\n-@SPI\n+@SPI(scope = ExtensionScope.MODULE)\n public interface AddressListener {\n     /**\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/ClusterFilter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/ClusterFilter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/ClusterFilter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/ClusterFilter.java\n@@ -16,9 +16,10 @@\n  */\n package org.apache.dubbo.rpc.cluster.filter;\n+import org.apache.dubbo.common.extension.ExtensionScope;\n import org.apache.dubbo.common.extension.SPI;\n import org.apache.dubbo.rpc.BaseFilter;\n-@SPI\n+@SPI(scope = ExtensionScope.MODULE)\n public interface ClusterFilter extends BaseFilter {\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -149,7 +149,7 @@ public synchronized void notify(List<URL> instanceUrls) {\n         RpcServiceContext.setRpcContext(getConsumerUrl());\n         //  3.x added for extend URL address\n-        ExtensionLoader<AddressListener> addressListenerExtensionLoader = getUrl().getOrDefaultApplicationModel().getExtensionLoader(AddressListener.class);\n+        ExtensionLoader<AddressListener> addressListenerExtensionLoader = getUrl().getOrDefaultModuleModel().getExtensionLoader(AddressListener.class);\n         List<AddressListener> supportedListeners = addressListenerExtensionLoader.getActivateExtension(getUrl(), (String[]) null);\n         if (supportedListeners != null && !supportedListeners.isEmpty()) {\n             for (AddressListener addressListener : supportedListeners) {\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java\n@@ -282,7 +282,7 @@ public void destroy() {\n             logger.warn(\"unexpected error when unsubscribe service \" + serviceKey + \" from registry: \" + registry.getUrl(), t);\n         }\n-        ExtensionLoader<AddressListener> addressListenerExtensionLoader = getUrl().getOrDefaultApplicationModel().getExtensionLoader(AddressListener.class);\n+        ExtensionLoader<AddressListener> addressListenerExtensionLoader = getUrl().getOrDefaultModuleModel().getExtensionLoader(AddressListener.class);\n         List<AddressListener> supportedListeners = addressListenerExtensionLoader.getActivateExtension(getUrl(), (String[]) null);\n         if (supportedListeners != null && !supportedListeners.isEmpty()) {\n             for (AddressListener addressListener : supportedListeners) {\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -152,7 +152,7 @@ public synchronized void notify(List<URL> urls) {\n         List<URL> providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());\n         // 3.x added for extend URL address\n-        ExtensionLoader<AddressListener> addressListenerExtensionLoader = getUrl().getOrDefaultApplicationModel().getExtensionLoader(AddressListener.class);\n+        ExtensionLoader<AddressListener> addressListenerExtensionLoader = getUrl().getOrDefaultModuleModel().getExtensionLoader(AddressListener.class);\n         List<AddressListener> supportedListeners = addressListenerExtensionLoader.getActivateExtension(getUrl(), (String[]) null);\n         if (supportedListeners != null && !supportedListeners.isEmpty()) {\n             for (AddressListener addressListener : supportedListeners) {\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Filter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Filter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Filter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Filter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.rpc;\n+import org.apache.dubbo.common.extension.ExtensionScope;\n import org.apache.dubbo.common.extension.SPI;\n /**\n@@ -64,7 +65,7 @@\n  * @see org.apache.dubbo.rpc.filter.TokenFilter\n  * @see org.apache.dubbo.rpc.filter.TpsLimitFilter\n  */\n-@SPI\n+@SPI(scope = ExtensionScope.MODULE)\n public interface Filter extends BaseFilter {\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ArgumentCallbackTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ArgumentCallbackTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ArgumentCallbackTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ArgumentCallbackTest.java\n@@ -26,6 +26,7 @@\n import org.apache.dubbo.rpc.model.ConsumerModel;\n import org.apache.dubbo.rpc.model.ModuleServiceRepository;\n import org.apache.dubbo.rpc.protocol.dubbo.support.ProtocolUtils;\n+\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n@@ -85,7 +86,7 @@ public void initOrResetUrl(int callbacks, int timeout) throws Exception {\n                 + \"&timeout=\" + timeout\n                 + \"&retries=0\"\n                 + \"&\" + CALLBACK_INSTANCES_LIMIT_KEY + \"=\" + callbacks)\n-            .setScopeModel(ApplicationModel.defaultModel())\n+            .setScopeModel(ApplicationModel.defaultModel().getDefaultModule())\n             .setServiceModel(new ConsumerModel(IDemoService.class.getName(), null, null, null,\n             ApplicationModel.defaultModel().getDefaultModule(), null, null));",
    "output": "Change Filter & AddressListener scope to Module * Change Filter & AddressListener scope to Module * Fix ut"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/BaseServiceMetadata.java b/dubbo-common/src/main/java/org/apache/dubbo/common/BaseServiceMetadata.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/BaseServiceMetadata.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/BaseServiceMetadata.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.common;\n import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.model.ServiceModel;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_VERSION;\n@@ -30,6 +31,7 @@ public class BaseServiceMetadata {\n     protected String serviceInterfaceName;\n     protected String version;\n     protected volatile String group;\n+    private ServiceModel serviceModel;\n     public static String buildServiceKey(String path, String group, String version) {\n         int length = path == null ? 0 : path.length();\n@@ -145,4 +147,11 @@ public void setGroup(String group) {\n         this.group = group;\n     }\n+    public ServiceModel getServiceModel() {\n+        return serviceModel;\n+    }\n+\n+    public void setServiceModel(ServiceModel serviceModel) {\n+        this.serviceModel = serviceModel;\n+    }\n }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceModel.java\n@@ -51,6 +51,9 @@ public ServiceModel(Object proxyObject, String serviceKey, ServiceDescriptor ser\n         this.moduleModel = moduleModel;\n         this.config = config;\n         this.serviceMetadata = serviceMetadata;\n+        if (serviceMetadata != null) {\n+            serviceMetadata.setServiceModel(this);\n+        }\n         if (config != null) {\n             this.classLoader = config.getInterfaceClassLoader();\n         }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java\n@@ -124,7 +124,7 @@ protected Object deserializeResponse(byte[] data) {\n         ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n         try {\n             if (getConsumerModel() != null) {\n-                ClassLoadUtil.switchContextLoader(getConsumerModel().getServiceInterfaceClass().getClassLoader());\n+                ClassLoadUtil.switchContextLoader(getConsumerModel().getClassLoader());\n             }\n             if (getMethodDescriptor().isNeedWrap()) {\n                 final TripleWrapper.TripleResponseWrapper wrapper = TripleUtil.unpack(data,\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java\n@@ -94,7 +94,7 @@ private static ProviderModel lookupProviderModel(URL url) {\n         FrameworkServiceRepository repo = ScopeModelUtil.getFrameworkModel(url.getScopeModel()).getServiceRepository();\n         final ProviderModel model = repo.lookupExportedService(url.getServiceKey());\n         if (model != null) {\n-            ClassLoadUtil.switchContextLoader(model.getServiceInterfaceClass().getClassLoader());\n+            ClassLoadUtil.switchContextLoader(model.getClassLoader());\n         }\n         return model;\n     }\n@@ -140,7 +140,7 @@ protected Object[] deserializeRequest(byte[] data) {\n         ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n         try {\n             if (getProviderModel() != null) {\n-                ClassLoadUtil.switchContextLoader(getProviderModel().getServiceInterfaceClass().getClassLoader());\n+                ClassLoadUtil.switchContextLoader(getProviderModel().getClassLoader());\n             }\n             if (getMethodDescriptor() == null || getMethodDescriptor().isNeedWrap()) {\n                 final TripleWrapper.TripleRequestWrapper wrapper = TripleUtil.unpack(data,\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java\n@@ -16,12 +16,6 @@\n  */\n package org.apache.dubbo.rpc.protocol.tri;\n-import io.netty.channel.ChannelDuplexHandler;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http2.Http2GoAwayFrame;\n-import io.netty.handler.codec.http2.Http2SettingsFrame;\n-import io.netty.util.ReferenceCountUtil;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.stream.StreamObserver;\n@@ -39,6 +33,13 @@\n import org.apache.dubbo.rpc.model.FrameworkModel;\n import org.apache.dubbo.rpc.model.MethodDescriptor;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http2.Http2GoAwayFrame;\n+import io.netty.handler.codec.http2.Http2SettingsFrame;\n+import io.netty.util.ReferenceCountUtil;\n+\n import java.util.Arrays;\n import java.util.List;\n@@ -79,7 +80,7 @@ private void writeRequest(ChannelHandlerContext ctx, final Request req, final Ch\n         MethodDescriptor methodDescriptor = getTriMethodDescriptor(consumerModel,inv);\n-        ClassLoadUtil.switchContextLoader(consumerModel.getServiceInterfaceClass().getClassLoader());\n+        ClassLoadUtil.switchContextLoader(consumerModel.getClassLoader());\n         AbstractClientStream stream;\n         if (methodDescriptor.isUnary()) {\n             stream = AbstractClientStream.unary(url);",
    "output": "Fix Triple Classloader & Add backward of ServiceMetadata"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java\n@@ -55,7 +55,7 @@ public URL getUrl() {\n     public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache<T> routerCache, URL url, Invocation invocation)\n         throws RpcException {\n-        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+        String tag = isNoTag(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n             invocation.getAttachment(TAG_KEY);\n         if (StringUtils.isEmpty(tag)) {\n             tag = NO_TAG;\n@@ -69,6 +69,10 @@ public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache<T\n         return invokers.intersect(res, invokers.getUnmodifiableList());\n     }\n+    private boolean isNoTag(String tag) {\n+        return StringUtils.isEmpty(tag) || NO_TAG.equals(tag);\n+    }\n+\n     @Override\n     protected List<String> getTags(URL url, Invocation invocation) {\n         List<String> tags = new ArrayList<>();",
    "output": "Fix issue-8741: consumer and provider have same tag, but no provider found"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java\n@@ -137,6 +137,15 @@ public Request copy() {\n         return copy;\n     }\n+    public Request copyWithoutData(){\n+        Request copy = new Request(mId);\n+        copy.mVersion = this.mVersion;\n+        copy.mTwoWay = this.mTwoWay;\n+        copy.mEvent = this.mEvent;\n+        copy.mBroken = this.mBroken;\n+        return copy;\n+    }\n+\n     @Override\n     public String toString() {\n         return \"Request [id=\" + mId + \", version=\" + mVersion + \", twoway=\" + mTwoWay + \", event=\" + mEvent\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java\n@@ -147,7 +147,7 @@ public static void closeChannel(Channel channel) {\n                     disconnectResponse.setErrorMessage(\"Channel \" +\n                             channel +\n                             \" is inactive. Directly return the unFinished request : \" +\n-                            future.getRequest());\n+                            (logger.isDebugEnabled() ? future.getRequest() : future.getRequest().copyWithoutData()));\n                     DefaultFuture.received(channel, disconnectResponse);\n                 }\n             }\n@@ -251,15 +251,10 @@ private String getTimeoutMessage(boolean scan) {\n                 + (sent > 0 ? \" client elapsed: \" + (sent - start)\n                 + \" ms, server elapsed: \" + (nowTimestamp - sent)\n                 : \" elapsed: \" + (nowTimestamp - start)) + \" ms, timeout: \"\n-                + timeout + \" ms, request: \" + (logger.isDebugEnabled() ? request : getRequestWithoutData()) + \", channel: \" + channel.getLocalAddress()\n+                + timeout + \" ms, request: \" + (logger.isDebugEnabled() ? request : request.copyWithoutData()) + \", channel: \" + channel.getLocalAddress()\n                 + \" -> \" + channel.getRemoteAddress();\n     }\n-    private Request getRequestWithoutData() {\n-        Request newRequest = request.copy();\n-        newRequest.setData(null);\n-        return newRequest;\n-    }\n     private static class TimeoutCheckTask implements TimerTask {",
    "output": "Fix issue-8695:DefaultFuture turn off logging optimization for Channel * fix issue-8695:DefaultFuture turn off exception logging optimization for Channel * fix issue-8695:Remove the getRequestWithoutData method from DefaultFuture"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n@@ -18,6 +18,8 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.model.ScopeModel;\n+import org.apache.dubbo.rpc.model.ServiceModel;\n import java.util.HashMap;\n import java.util.Map;\n@@ -212,6 +214,26 @@ public int hashCode() {\n         return super.hashCode();\n     }\n+    @Override\n+    public ScopeModel getScopeModel() {\n+        return consumerURL.getScopeModel();\n+    }\n+\n+    @Override\n+    public ServiceModel getServiceModel() {\n+        return consumerURL.getServiceModel();\n+    }\n+\n+    @Override\n+    public URL setScopeModel(ScopeModel scopeModel) {\n+        throw new UnsupportedOperationException(\"setScopeModel is forbidden for ServiceAddressURL\");\n+    }\n+\n+    @Override\n+    public URL setServiceModel(ServiceModel serviceModel) {\n+        throw new UnsupportedOperationException(\"setServiceModel is forbidden for ServiceAddressURL\");\n+    }\n+\n     /**\n      * ignore consumer url compare.\n      * It's only meaningful for comparing two address urls related to the same consumerURL.",
    "output": "Add ConsumerUrl adapt to ServiceAddressURL"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java\n@@ -75,7 +75,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n     private void writeRequest(ChannelHandlerContext ctx, final Request req, final ChannelPromise promise) {\n         final RpcInvocation inv = (RpcInvocation) req.getData();\n         final URL url = inv.getInvoker().getUrl();\n-        ConsumerModel consumerModel = (ConsumerModel) url.getServiceModel();\n+        ConsumerModel consumerModel = inv.getServiceModel() != null ? (ConsumerModel) inv.getServiceModel() : (ConsumerModel) url.getServiceModel();\n         MethodDescriptor methodDescriptor = getTriMethodDescriptor(consumerModel,inv);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -81,6 +81,7 @@ public TripleInvoker(Class<T> serviceType, URL url, Set<Invoker<?>> invokers) th\n     protected Result doInvoke(final Invocation invocation) throws Throwable {\n         RpcInvocation inv = (RpcInvocation) invocation;\n         final String methodName = RpcUtils.getMethodName(invocation);\n+        inv.setServiceModel(RpcContext.getServiceContext().getConsumerUrl().getServiceModel());\n         inv.setAttachment(PATH_KEY, getUrl().getPath());\n         inv.setAttachment(Constants.SERIALIZATION_KEY,\n                 getUrl().getParameter(Constants.SERIALIZATION_KEY, Constants.DEFAULT_REMOTING_SERIALIZATION));",
    "output": "Fix the consumerModel's NPE in TripleClientHandler"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n@@ -17,6 +17,8 @@\n package org.apache.dubbo.registry;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.threadpool.manager.ExecutorRepository;\n import java.util.concurrent.ScheduledExecutorService;\n@@ -26,6 +28,7 @@\n public abstract class RegistryNotifier {\n+    private static final Logger logger = LoggerFactory.getLogger(RegistryNotifier.class);\n     private volatile long lastExecuteTime;\n     private volatile long lastEventTime;\n@@ -90,14 +93,18 @@ public NotificationTask(RegistryNotifier listener, long time) {\n         @Override\n         public void run() {\n-            if (this.time == listener.lastEventTime) {\n-                listener.doNotify(listener.rawAddresses);\n-                listener.lastExecuteTime = System.currentTimeMillis();\n-                synchronized (listener) {\n-                    if (this.time == listener.lastEventTime) {\n-                        listener.rawAddresses = null;\n+            try {\n+                if (this.time == listener.lastEventTime) {\n+                    listener.doNotify(listener.rawAddresses);\n+                    listener.lastExecuteTime = System.currentTimeMillis();\n+                    synchronized (listener) {\n+                        if (this.time == listener.lastEventTime) {\n+                            listener.rawAddresses = null;\n+                        }\n                     }\n                 }\n+            } catch (Throwable t) {\n+                logger.error(\"Error occurred when notify directory. \", t);\n             }\n         }\n     }",
    "output": "Add log output when notify error"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n@@ -389,7 +389,7 @@ public void testSelect_multiInvokers(String lbname) throws Exception {\n         int min = 100, max = 500;\n         Double d = (Math.random() * (max - min + 1) + min);\n         int runs = d.intValue();\n-        Assertions.assertTrue(runs > min);\n+        Assertions.assertTrue(runs >= min);\n         LoadBalance lb = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(lbname);\n         initlistsize5();\n         for (int i = 0; i < runs; i++) {",
    "output": "Fix random assertions"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-jdk/src/main/java/org/apache/dubbo/common/serialize/java/JavaSerialization.java b/dubbo-serialization/dubbo-serialization-jdk/src/main/java/org/apache/dubbo/common/serialize/java/JavaSerialization.java\n--- a/dubbo-serialization/dubbo-serialization-jdk/src/main/java/org/apache/dubbo/common/serialize/java/JavaSerialization.java\n+++ b/dubbo-serialization/dubbo-serialization-jdk/src/main/java/org/apache/dubbo/common/serialize/java/JavaSerialization.java\n@@ -17,13 +17,16 @@\n package org.apache.dubbo.common.serialize.java;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.serialize.ObjectInput;\n import org.apache.dubbo.common.serialize.ObjectOutput;\n import org.apache.dubbo.common.serialize.Serialization;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import static org.apache.dubbo.common.serialize.Constants.JAVA_SERIALIZATION_ID;\n@@ -35,6 +38,8 @@\n  * </pre>\n  */\n public class JavaSerialization implements Serialization {\n+    private static final Logger logger = LoggerFactory.getLogger(JavaSerialization.class);\n+    private final static AtomicBoolean warn = new AtomicBoolean(false);\n     @Override\n     public byte getContentTypeId() {\n@@ -48,11 +53,21 @@ public String getContentType() {\n     @Override\n     public ObjectOutput serialize(URL url, OutputStream out) throws IOException {\n+        if (warn.compareAndSet(false, true)) {\n+            logger.error(\"Java serialization is unsafe. Dubbo Team do not recommend anyone to use it.\" +\n+                \"If you still want to use it, please follow [JEP 290](https://openjdk.java.net/jeps/290)\" +\n+                \"to set serialization filter to prevent deserialization leak.\");\n+        }\n         return new JavaObjectOutput(out);\n     }\n     @Override\n     public ObjectInput deserialize(URL url, InputStream is) throws IOException {\n+        if (warn.compareAndSet(false, true)) {\n+            logger.error(\"Java serialization is unsafe. Dubbo Team do not recommend anyone to use it.\" +\n+                \"If you still want to use it, please follow [JEP 290](https://openjdk.java.net/jeps/290)\" +\n+                \"to set serialization filter to prevent deserialization leak.\");\n+        }\n         return new JavaObjectInput(is);\n     }\ndiff --git a/dubbo-serialization/dubbo-serialization-jdk/src/main/java/org/apache/dubbo/common/serialize/nativejava/NativeJavaSerialization.java b/dubbo-serialization/dubbo-serialization-jdk/src/main/java/org/apache/dubbo/common/serialize/nativejava/NativeJavaSerialization.java\n--- a/dubbo-serialization/dubbo-serialization-jdk/src/main/java/org/apache/dubbo/common/serialize/nativejava/NativeJavaSerialization.java\n+++ b/dubbo-serialization/dubbo-serialization-jdk/src/main/java/org/apache/dubbo/common/serialize/nativejava/NativeJavaSerialization.java\n@@ -18,13 +18,17 @@\n package org.apache.dubbo.common.serialize.nativejava;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.serialize.ObjectInput;\n import org.apache.dubbo.common.serialize.ObjectOutput;\n import org.apache.dubbo.common.serialize.Serialization;\n+import org.apache.dubbo.common.serialize.java.JavaSerialization;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import static org.apache.dubbo.common.serialize.Constants.NATIVE_JAVA_SERIALIZATION_ID;\n@@ -36,7 +40,8 @@\n  * </pre>\n  */\n public class NativeJavaSerialization implements Serialization {\n-\n+    private static final Logger logger = LoggerFactory.getLogger(JavaSerialization.class);\n+    private final static AtomicBoolean warn = new AtomicBoolean(false);\n     @Override\n     public byte getContentTypeId() {\n@@ -50,11 +55,21 @@ public String getContentType() {\n     @Override\n     public ObjectOutput serialize(URL url, OutputStream output) throws IOException {\n+        if (warn.compareAndSet(false, true)) {\n+            logger.error(\"Java serialization is unsafe. Dubbo Team do not recommend anyone to use it.\" +\n+                \"If you still want to use it, please follow [JEP 290](https://openjdk.java.net/jeps/290)\" +\n+                \"to set serialization filter to prevent deserialization leak.\");\n+        }\n         return new NativeJavaObjectOutput(output);\n     }\n     @Override\n     public ObjectInput deserialize(URL url, InputStream input) throws IOException {\n+        if (warn.compareAndSet(false, true)) {\n+            logger.error(\"Java serialization is unsafe. Dubbo Team do not recommend anyone to use it.\" +\n+                \"If you still want to use it, please follow [JEP 290](https://openjdk.java.net/jeps/290)\" +\n+                \"to set serialization filter to prevent deserialization leak.\");\n+        }\n         return new NativeJavaObjectInput(input);\n     }\n }",
    "output": "Add Serialization warning message to java serialization"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java\n@@ -78,8 +78,9 @@ protected void onError(GrpcStatus status) {\n             Response response = new Response(getRequest().getId(), TripleConstant.TRI_VERSION);\n             response.setErrorMessage(status.description);\n             final AppResponse result = new AppResponse();\n-            result.setException(getThrowable(this.getTrailers()));\n-            result.setObjectAttachments(UnaryClientStream.this.parseMetadataToAttachmentMap(this.getTrailers()));\n+            final Metadata trailers = getTrailers() == null ? getHeaders() : getTrailers();\n+            result.setException(getThrowable(trailers));\n+            result.setObjectAttachments(UnaryClientStream.this.parseMetadataToAttachmentMap(trailers));\n             response.setResult(result);\n             if (!result.hasException()) {\n                 final byte code = GrpcStatus.toDubboStatus(status.code);\n@@ -89,6 +90,9 @@ protected void onError(GrpcStatus status) {\n         }\n         private Throwable getThrowable(Metadata metadata) {\n+            if (null == metadata) {\n+                return null;\n+            }\n             // second get status detail\n             if (!metadata.contains(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader())) {\n                 return null;",
    "output": "Fix client can not recognize trailers only"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java\n@@ -178,12 +178,25 @@ private void initFrameworkExts() {\n         }\n     }\n+    @Override\n     public void destroy() {\n         // TODO destroy application resources\n         for (ModuleModel moduleModel : new ArrayList<>(moduleModels)) {\n             moduleModel.destroy();\n         }\n         frameworkModel.removeApplication(this);\n+        if (environment != null) {\n+            environment.destroy();\n+            environment = null;\n+        }\n+        if (configManager != null) {\n+            configManager.destroy();\n+            configManager = null;\n+        }\n+        if (serviceRepository != null) {\n+            serviceRepository.destroy();\n+            serviceRepository = null;\n+        }\n     }\n     public FrameworkModel getFrameworkModel() {\n@@ -251,6 +264,21 @@ public ModuleModel getInternalModule() {\n         return internalModule;\n     }\n+    @Deprecated\n+    public void setEnvironment(Environment environment) {\n+        this.environment = environment;\n+    }\n+\n+    @Deprecated\n+    public void setConfigManager(ConfigManager configManager) {\n+        this.configManager = configManager;\n+    }\n+\n+    @Deprecated\n+    public void setServiceRepository(ServiceRepository serviceRepository) {\n+        this.serviceRepository = serviceRepository;\n+    }\n+\n     @Override\n     public String toString() {\n         return \"ApplicationModel\";\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java\n@@ -51,7 +51,7 @@ public class UrlTestBase {\n     private static final int TESTVALUE5 = 8;\n     private static final int TESTVALUE6 = 9;\n     private static final int TESTVALUE7 = 10;\n-    protected ApplicationConfig application = new ApplicationConfig();\n+    protected ApplicationConfig application;\n     protected RegistryConfig regConfForProvider;\n     protected RegistryConfig regConfForService;\n     protected ProviderConfig provConf;\n@@ -144,6 +144,7 @@ protected void initServConf() {\n         servConf = new ServiceConfig<DemoService>();\n //        provConf.setApplication(appConfForProvider);\n+        application = new ApplicationConfig();\n         application.setMetadataServicePort(20881);\n         servConf.setApplication(application);\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/javaconfig/JavaConfigReferenceBeanTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/javaconfig/JavaConfigReferenceBeanTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/javaconfig/JavaConfigReferenceBeanTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/reference/javaconfig/JavaConfigReferenceBeanTest.java\n@@ -53,17 +53,17 @@ public class JavaConfigReferenceBeanTest {\n     @BeforeEach\n     public void setUp() {\n+        DubboBootstrap.reset();\n         multipleRegistryCenter = new ZookeeperMultipleRegistryCenter();\n         multipleRegistryCenter.startup();\n-        DubboBootstrap.reset();\n         SpringExtensionInjector.clearContexts();\n     }\n     @AfterEach\n     public void tearDown() {\n-        DubboBootstrap.reset();\n         multipleRegistryCenter.shutdown();\n         SpringExtensionInjector.clearContexts();\n+        DubboBootstrap.reset();\n     }\n     @Test",
    "output": "Add ApplicationModel destroy support and ut support * Add ApplicationModel destroy support and ut support * Fix ut * Fix ut"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/SingleRegistryCenterDubboProtocolIntegrationTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/SingleRegistryCenterDubboProtocolIntegrationTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/SingleRegistryCenterDubboProtocolIntegrationTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/SingleRegistryCenterDubboProtocolIntegrationTest.java\n@@ -20,11 +20,11 @@\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.utils.NetUtils;\n-import org.apache.dubbo.config.RegistryConfig;\n-import org.apache.dubbo.config.ServiceConfig;\n-import org.apache.dubbo.config.ReferenceConfig;\n import org.apache.dubbo.config.ApplicationConfig;\n import org.apache.dubbo.config.ProtocolConfig;\n+import org.apache.dubbo.config.ReferenceConfig;\n+import org.apache.dubbo.config.RegistryConfig;\n+import org.apache.dubbo.config.ServiceConfig;\n import org.apache.dubbo.config.ServiceListener;\n import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n import org.apache.dubbo.integration.IntegrationTest;\n@@ -41,9 +41,10 @@\n import org.apache.dubbo.registrycenter.RegistryCenter;\n import org.apache.dubbo.registrycenter.ZookeeperSingleRegistryCenter;\n import org.apache.dubbo.rpc.cluster.Directory;\n+\n+import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -243,7 +244,7 @@ private void afterExport() {\n         // MetadataInfo exists or not in InMemoryWritableMetadataService\n         Assertions.assertNotNull(metadataInfo);\n         // MetadataInfo has reported or not\n-        Assertions.assertTrue(metadataInfo.hasReported());\n+        Assertions.assertFalse(metadataInfo.hasReported());\n         // MetadataInfo has reported or not has service or not\n         Assertions.assertFalse(metadataInfo.getServices().isEmpty());\n         // MetadataInfo has reported or not has service or not",
    "output": "Fix ut after disable default metadata report"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mock/MockInvokersSelectorTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mock/MockInvokersSelectorTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mock/MockInvokersSelectorTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mock/MockInvokersSelectorTest.java\n@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.mock;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcInvocation;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.rpc.cluster.Constants.INVOCATION_NEED_MOCK;\n+\n+public class MockInvokersSelectorTest {\n+    @Test\n+    public void test() {\n+\n+        MockInvokersSelector selector = new MockInvokersSelector();\n+\n+        // Data preparation\n+        Invoker<DemoService> invoker1 = Mockito.mock(Invoker.class);\n+        Invoker<DemoService> invoker2 = Mockito.mock(Invoker.class);\n+        Invoker<DemoService> invoker3 = Mockito.mock(Invoker.class);\n+        Mockito.when(invoker1.getUrl()).thenReturn(URL.valueOf(\"mock://127.0.0.1/test\"));\n+        Mockito.when(invoker2.getUrl()).thenReturn(URL.valueOf(\"mock://127.0.0.1/test\"));\n+        Mockito.when(invoker3.getUrl()).thenReturn(URL.valueOf(\"dubbo://127.0.0.1/test\"));\n+        List<Invoker<DemoService>> providers = Arrays.asList(invoker1, invoker2, invoker3);\n+\n+        RpcInvocation rpcInvocation = Mockito.mock(RpcInvocation.class);\n+\n+        URL consumerURL = URL.valueOf(\"test://127.0.0.1\");\n+\n+        // rpcInvocation does not have an attached \"invocation.need.mock\" parameter, so normal invokers will be filtered out\n+        List<Invoker<DemoService>> invokers = selector.route(providers, consumerURL, rpcInvocation);\n+        Assertions.assertEquals(invokers.size(),1);\n+        Assertions.assertTrue(invokers.contains(invoker3));\n+\n+        // rpcInvocation have an attached \"invocation.need.mock\" parameter, so it will filter out the invoker whose protocol is mock\n+        Map<String,Object> attachments = new HashMap<>();\n+        attachments.put(INVOCATION_NEED_MOCK,\"true\");\n+        Mockito.when(rpcInvocation.getObjectAttachments()).thenReturn(attachments);\n+        invokers = selector.route(providers, consumerURL, rpcInvocation);\n+        Assertions.assertEquals(invokers.size(),2);\n+        Assertions.assertTrue(invokers.contains(invoker1));\n+        Assertions.assertTrue(invokers.contains(invoker2));\n+\n+    }\n+\n+    class DemoService{\n+\n+    }\n+}",
    "output": "Add unit test for MockInvokersSelector"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java\n@@ -251,9 +251,6 @@ private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL pa\n                 sampleValue = url.getHost();\n             } else {\n                 sampleValue = sample.get(key);\n-                if (sampleValue == null) {\n-                    sampleValue = sample.get(key);\n-                }\n             }\n             if (sampleValue != null) {\n                 if (!matchPair.getValue().isMatch(sampleValue, param)) {\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n@@ -46,8 +46,8 @@ public abstract class ListenableRouter extends AbstractRouter implements Configu\n     private static final String RULE_SUFFIX = \".condition-router\";\n     private static final Logger logger = LoggerFactory.getLogger(ListenableRouter.class);\n-    private ConditionRouterRule routerRule;\n-    private List<ConditionRouter> conditionRouters = Collections.emptyList();\n+    private volatile ConditionRouterRule routerRule;\n+    private volatile List<ConditionRouter> conditionRouters = Collections.emptyList();\n     public ListenableRouter(URL url, String ruleKey) {\n         super(url);",
    "output": "Add volatile modifier to some variables in ListenableRouter * Remove useless code in ConditionRouter * Add volatile modifier to some variables in ListenableRouter"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n@@ -197,13 +197,13 @@ protected void connect() throws RemotingException {\n             doConnect();\n             if (!isConnected()) {\n-                throw new RemotingException(this, \"Failed connect to server \" + getRemoteAddress() + \" from \" + getClass().getSimpleName() + \" \"\n+                throw new RemotingException(this, \"Failed to connect to server \" + getRemoteAddress() + \" from \" + getClass().getSimpleName() + \" \"\n                                 + NetUtils.getLocalHost() + \" using dubbo version \" + Version.getVersion()\n                                 + \", cause: Connect wait timeout: \" + getConnectTimeout() + \"ms.\");\n             } else {\n                 if (logger.isInfoEnabled()) {\n-                    logger.info(\"Successed connect to server \" + getRemoteAddress() + \" from \" + getClass().getSimpleName() + \" \"\n+                    logger.info(\"Successfully connect to server \" + getRemoteAddress() + \" from \" + getClass().getSimpleName() + \" \"\n                                     + NetUtils.getLocalHost() + \" using dubbo version \" + Version.getVersion()\n                                     + \", channel is \" + this.getChannel());\n                 }\n@@ -213,7 +213,7 @@ protected void connect() throws RemotingException {\n             throw e;\n         } catch (Throwable e) {\n-            throw new RemotingException(this, \"Failed connect to server \" + getRemoteAddress() + \" from \" + getClass().getSimpleName() + \" \"\n+            throw new RemotingException(this, \"Failed to connect to server \" + getRemoteAddress() + \" from \" + getClass().getSimpleName() + \" \"\n                             + NetUtils.getLocalHost() + \" using dubbo version \" + Version.getVersion()\n                             + \", cause: \" + e.getMessage(), e);",
    "output": "Upgrade AbstractClient.java"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -199,8 +199,6 @@ public void init() {\n             // load ServiceListeners from extension\n             ExtensionLoader<ServiceListener> extensionLoader = ExtensionLoader.getExtensionLoader(ServiceListener.class);\n             this.serviceListeners.addAll(extensionLoader.getSupportedExtensionInstances());\n-\n-            this.checkAndUpdateSubConfigs();\n         }\n         initServiceMetadata(provider);",
    "output": "Fix duplicate config init"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n@@ -1114,6 +1114,7 @@ public void testProtocolRandomPort() throws Exception {\n     }\n     @Test\n+    @Disabled(\"waiting-to-fix, see: https://github.com/apache/dubbo/pull/8534\")\n     public void testReferGenericExport() throws Exception {\n         RegistryConfig rc = new RegistryConfig();\n         rc.setAddress(RegistryConfig.NO_AVAILABLE);",
    "output": "Fix disable testcase of ConfigTest#testReferGenericExport"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/absent/AbsentConfiguratorTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/absent/AbsentConfiguratorTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/absent/AbsentConfiguratorTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/absent/AbsentConfiguratorTest.java\n@@ -23,6 +23,9 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n /**\n  * OverrideConfiguratorTest\n  */\n@@ -65,4 +68,53 @@ public void testOverrideHost() {\n         Assertions.assertEquals(\"1000\", url.getParameter(\"timeout\"));\n     }\n+    // Test the version after 2.7\n+    @Test\n+    public void testAbsentForVersion27() {\n+        {\n+            String consumerUrlV27 = \"dubbo://172.24.160.179/com.foo.BarService?application=foo&side=consumer&timeout=100\";\n+\n+            URL consumerConfiguratorUrl = URL.valueOf(\"absent://0.0.0.0/com.foo.BarService\");\n+            Map<String, String> params = new HashMap<>();\n+            params.put(\"side\", \"consumer\");\n+            params.put(\"configVersion\", \"2.7\");\n+            params.put(\"application\", \"foo\");\n+            params.put(\"timeout\", \"10000\");\n+            params.put(\"weight\", \"200\");\n+            consumerConfiguratorUrl = consumerConfiguratorUrl.addParameters(params);\n+\n+            AbsentConfigurator configurator = new AbsentConfigurator(consumerConfiguratorUrl);\n+            // Meet the configured conditions:\n+            // same side\n+            // The port of configuratorUrl is 0\n+            // The host of configuratorUrl is 0.0.0.0 or the local address is the same as consumerUrlV27\n+            // same appName\n+            URL url = configurator.configure(URL.valueOf(consumerUrlV27));\n+            Assertions.assertEquals(url.getParameter(\"timeout\"), \"100\");\n+            Assertions.assertEquals(url.getParameter(\"weight\"), \"200\");\n+        }\n+\n+        {\n+            String providerUrlV27 = \"dubbo://172.24.160.179:21880/com.foo.BarService?application=foo&side=provider&weight=100\";\n+\n+            URL providerConfiguratorUrl = URL.valueOf(\"absent://172.24.160.179:21880/com.foo.BarService\");\n+            Map<String, String> params = new HashMap<>();\n+            params.put(\"side\", \"provider\");\n+            params.put(\"configVersion\", \"2.7\");\n+            params.put(\"application\", \"foo\");\n+            params.put(\"timeout\", \"20000\");\n+            params.put(\"weight\", \"200\");\n+            providerConfiguratorUrl = providerConfiguratorUrl.addParameters(params);\n+            // Meet the configured conditions:\n+            // same side\n+            // same port\n+            // The host of configuratorUrl is 0.0.0.0 or the host of providerConfiguratorUrl is the same as consumerUrlV27\n+            // same appName\n+            AbsentConfigurator configurator = new AbsentConfigurator(providerConfiguratorUrl);\n+            URL url = configurator.configure(URL.valueOf(providerUrlV27));\n+            Assertions.assertEquals(url.getParameter(\"timeout\"), \"20000\");\n+            Assertions.assertEquals(url.getParameter(\"weight\"), \"100\");\n+        }\n+    }\n+\n }\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/override/OverrideConfiguratorTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/override/OverrideConfiguratorTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/override/OverrideConfiguratorTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/override/OverrideConfiguratorTest.java\n@@ -24,6 +24,9 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n /**\n  * OverrideConfiguratorTest\n  */\n@@ -65,4 +68,50 @@ public void testOverride_Host() {\n         Assertions.assertEquals(\"1000\", url.getParameter(\"timeout\"));\n     }\n+    // Test the version after 2.7\n+    @Test\n+    public void testOverrideForVersion27() {\n+        {\n+            String consumerUrlV27 = \"dubbo://172.24.160.179/com.foo.BarService?application=foo&side=consumer&timeout=100\";\n+\n+            URL consumerConfiguratorUrl = URL.valueOf(\"override://0.0.0.0/com.foo.BarService\");\n+            Map<String, String> params = new HashMap<>();\n+            params.put(\"side\", \"consumer\");\n+            params.put(\"configVersion\", \"2.7\");\n+            params.put(\"application\", \"foo\");\n+            params.put(\"timeout\", \"10000\");\n+            consumerConfiguratorUrl = consumerConfiguratorUrl.addParameters(params);\n+\n+            OverrideConfigurator configurator = new OverrideConfigurator(consumerConfiguratorUrl);\n+            // Meet the configured conditions:\n+            // same side\n+            // The port of configuratorUrl is 0\n+            // The host of configuratorUrl is 0.0.0.0 or the local address is the same as consumerUrlV27\n+            // same appName\n+            URL url = configurator.configure(URL.valueOf(consumerUrlV27));\n+            Assertions.assertEquals(url.getParameter(\"timeout\"), \"10000\");\n+        }\n+\n+        {\n+            String providerUrlV27 = \"dubbo://172.24.160.179:21880/com.foo.BarService?application=foo&side=provider&weight=100\";\n+\n+            URL providerConfiguratorUrl = URL.valueOf(\"override://172.24.160.179:21880/com.foo.BarService\");\n+            Map<String, String> params = new HashMap<>();\n+            params.put(\"side\", \"provider\");\n+            params.put(\"configVersion\", \"2.7\");\n+            params.put(\"application\", \"foo\");\n+            params.put(\"weight\", \"200\");\n+            providerConfiguratorUrl = providerConfiguratorUrl.addParameters(params);\n+            // Meet the configured conditions:\n+            // same side\n+            // same port\n+            // The host of configuratorUrl is 0.0.0.0 or the host of providerConfiguratorUrl is the same as consumerUrlV27\n+            // same appName\n+            OverrideConfigurator configurator = new OverrideConfigurator(providerConfiguratorUrl);\n+            URL url = configurator.configure(URL.valueOf(providerUrlV27));\n+            Assertions.assertEquals(url.getParameter(\"weight\"), \"200\");\n+        }\n+\n+    }\n+\n }",
    "output": "Add test cases to the Configurator after version 2.7"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockInvoker.java\n@@ -161,14 +161,15 @@ public static Throwable getThrowable(String throwstr) {\n     }\n     @SuppressWarnings(\"unchecked\")\n-    private Invoker<T> getInvoker(String mockService) {\n+    private Invoker<T> getInvoker(String mock) {\n+        Class<T> serviceType = (Class<T>) ReflectUtils.forName(url.getServiceInterface());\n+        String mockService = ConfigUtils.isDefault(mock) ? serviceType.getName() + \"Mock\" : mock;\n         Invoker<T> invoker = (Invoker<T>) MOCK_MAP.get(mockService);\n         if (invoker != null) {\n             return invoker;\n         }\n-        Class<T> serviceType = (Class<T>) ReflectUtils.forName(url.getServiceInterface());\n-        T mockObject = (T) getMockObject(mockService, serviceType);\n+        T mockObject = (T) getMockObject(mock, serviceType);\n         invoker = PROXY_FACTORY.getInvoker(mockObject, serviceType, url);\n         if (MOCK_MAP.size() < 10000) {\n             MOCK_MAP.put(mockService, invoker);\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceA.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceA.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceA.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceA.java\n@@ -0,0 +1,21 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.support;\n+\n+public interface DemoServiceA {\n+    String methodA();\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceAMock.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceAMock.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceAMock.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceAMock.java\n@@ -0,0 +1,28 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.support;\n+\n+/**\n+ * default mock service for DemoServiceA\n+ */\n+public class DemoServiceAMock implements DemoServiceA{\n+    public static final String MOCK_VALUE = \"mockA\";\n+    @Override\n+    public String methodA() {\n+        return MOCK_VALUE;\n+    }\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceB.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceB.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceB.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceB.java\n@@ -0,0 +1,21 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.support;\n+\n+public interface DemoServiceB {\n+    String methodB();\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceBMock.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceBMock.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceBMock.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/DemoServiceBMock.java\n@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.support;\n+\n+/**\n+ * default mock service for DemoServiceA\n+ */\n+public class DemoServiceBMock implements DemoServiceB {\n+    public static final String MOCK_VALUE = \"mockB\";\n+\n+    @Override\n+    public String methodB() {\n+        return MOCK_VALUE;\n+    }\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/MockInvokerTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/MockInvokerTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/MockInvokerTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/MockInvokerTest.java\n@@ -65,6 +65,31 @@ public void testInvoke() {\n                 mockInvoker.invoke(invocation).getObjectAttachments());\n     }\n+    @Test\n+    public void testGetDefaultObject() {\n+        // test methodA in DemoServiceAMock\n+        final Class<DemoServiceA> demoServiceAClass = DemoServiceA.class;\n+        URL url = URL.valueOf(\"remote://1.2.3.4/\" + demoServiceAClass.getName());\n+        url = url.addParameter(MOCK_KEY, \"force:true\");\n+        MockInvoker mockInvoker = new MockInvoker(url, demoServiceAClass);\n+\n+        RpcInvocation invocation = new RpcInvocation();\n+        invocation.setMethodName(\"methodA\");\n+        Assertions.assertEquals(new HashMap<>(),\n+                mockInvoker.invoke(invocation).getObjectAttachments());\n+\n+        // test methodB in DemoServiceBMock\n+        final Class<DemoServiceB> demoServiceBClass = DemoServiceB.class;\n+        url = URL.valueOf(\"remote://1.2.3.4/\" + demoServiceBClass.getName());\n+        url = url.addParameter(MOCK_KEY, \"force:true\");\n+        mockInvoker = new MockInvoker(url, demoServiceBClass);\n+        invocation = new RpcInvocation();\n+        invocation.setMethodName(\"methodB\");\n+        Assertions.assertEquals(new HashMap<>(),\n+                mockInvoker.invoke(invocation).getObjectAttachments());\n+    }\n+\n+\n     @Test\n     public void testInvokeThrowsRpcException1() {\n         URL url = URL.valueOf(\"remote://1.2.3.4/\" + String.class.getName());",
    "output": "Fix Issue 8516 on branch 3.0: fix mock:true configuration. * fix issue-8516 * add license to file"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n@@ -336,6 +336,7 @@ protected MetadataInfo doGetMetadataInfo(ServiceInstance instance) {\n                 // change the instance used to communicate to avoid all requests route to the same instance\n                 MetadataService metadataServiceProxy = MetadataUtils.getMetadataServiceProxy(instance);\n                 metadataInfo = metadataServiceProxy.getMetadataInfo(ServiceInstanceMetadataUtils.getExportedServicesRevision(instance));\n+                MetadataUtils.destroyMetadataServiceProxy(instance);\n             }\n         } catch (Exception e) {\n             logger.error(\"Failed to load service metadata, meta type is \" + metadataType, e);",
    "output": "Fix MetadataService connections leak"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n@@ -72,20 +72,18 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L\n                     if (null != resultException) {\n                         exception = getRpcException(result.getException());\n                         logger.warn(exception.getMessage(), exception);\n+                        failIndex++;\n                         if (failIndex == failThresholdIndex) {\n                             break;\n-                        } else {\n-                            failIndex++;\n                         }\n                     }\n                 }\n             } catch (Throwable e) {\n                 exception = getRpcException(e);\n                 logger.warn(exception.getMessage(), exception);\n+                failIndex++;\n                 if (failIndex == failThresholdIndex) {\n                     break;\n-                } else {\n-                    failIndex++;\n                 }\n             }\n         }\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/BroadCastClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/BroadCastClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/BroadCastClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/BroadCastClusterInvokerTest.java\n@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.support;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.Result;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.RpcInvocation;\n+import org.apache.dubbo.rpc.cluster.Directory;\n+import org.apache.dubbo.rpc.cluster.filter.DemoService;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * @see BroadcastClusterInvoker\n+ */\n+public class BroadCastClusterInvokerTest {\n+    private URL url;\n+    private Directory<DemoService> dic;\n+    private RpcInvocation invocation;\n+    private BroadcastClusterInvoker clusterInvoker;\n+\n+    private MockInvoker invoker1;\n+    private MockInvoker invoker2;\n+    private MockInvoker invoker3;\n+    private MockInvoker invoker4;\n+\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+\n+        dic = mock(Directory.class);\n+\n+        invoker1 = new MockInvoker();\n+        invoker2 = new MockInvoker();\n+        invoker3 = new MockInvoker();\n+        invoker4 = new MockInvoker();\n+\n+        url = URL.valueOf(\"test://127.0.0.1:8080/test\");\n+        given(dic.getUrl()).willReturn(url);\n+        given(dic.getConsumerUrl()).willReturn(url);\n+        given(dic.getInterface()).willReturn(DemoService.class);\n+\n+        invocation = new RpcInvocation();\n+        invocation.setMethodName(\"test\");\n+\n+        clusterInvoker = new BroadcastClusterInvoker(dic);\n+    }\n+\n+\n+    @Test\n+    public void testNormal() {\n+        given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));\n+        // Every invoker will be called\n+        clusterInvoker.invoke(invocation);\n+        assertTrue(invoker1.isInvoked());\n+        assertTrue(invoker2.isInvoked());\n+        assertTrue(invoker3.isInvoked());\n+        assertTrue(invoker4.isInvoked());\n+    }\n+\n+    @Test\n+    public void testEx() {\n+        given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));\n+        invoker1.invokeThrowEx();\n+        assertThrows(RpcException.class, () -> {\n+            clusterInvoker.invoke(invocation);\n+        });\n+        // The default failure percentage is 100, even if a certain invoker#invoke throws an exception, other invokers will still be called\n+        assertTrue(invoker1.isInvoked());\n+        assertTrue(invoker2.isInvoked());\n+        assertTrue(invoker3.isInvoked());\n+        assertTrue(invoker4.isInvoked());\n+    }\n+\n+    @Test\n+    public void testFailPercent() {\n+        given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));\n+        // We set the failure percentage to 75, which means that when the number of call failures is 4*(75/100) = 3,\n+        // an exception will be thrown directly and subsequent invokers will not be called.\n+        url = url.addParameter(\"broadcast.fail.percent\", 75);\n+        given(dic.getConsumerUrl()).willReturn(url);\n+        invoker1.invokeThrowEx();\n+        invoker2.invokeThrowEx();\n+        invoker3.invokeThrowEx();\n+        invoker4.invokeThrowEx();\n+        assertThrows(RpcException.class, () -> {\n+            clusterInvoker.invoke(invocation);\n+        });\n+        assertTrue(invoker1.isInvoked());\n+        assertTrue(invoker2.isInvoked());\n+        assertTrue(invoker3.isInvoked());\n+        assertFalse(invoker4.isInvoked());\n+    }\n+}\n+\n+class MockInvoker implements Invoker<DemoService> {\n+    private static int count = 0;\n+    private URL url = URL.valueOf(\"test://127.0.0.1:8080/test\");\n+    private boolean throwEx = false;\n+    private boolean invoked = false;\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void destroy() {\n+\n+    }\n+\n+    @Override\n+    public Class<DemoService> getInterface() {\n+        return DemoService.class;\n+    }\n+\n+    @Override\n+    public Result invoke(Invocation invocation) throws RpcException {\n+        invoked = true;\n+        if (throwEx) {\n+            throwEx = false;\n+            throw new RpcException();\n+        }\n+        return null;\n+    }\n+\n+    public void invokeThrowEx() {\n+        throwEx = true;\n+    }\n+\n+    public boolean isInvoked() {\n+        return invoked;\n+    }\n+}",
    "output": "Fix bug of BroadcastClusterInvoker and add test cases"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/ShortestResponseLoadBalanceTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/ShortestResponseLoadBalanceTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/ShortestResponseLoadBalanceTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/ShortestResponseLoadBalanceTest.java\n@@ -97,14 +97,13 @@ public void testSelectByResponse() throws NoSuchFieldException, IllegalAccessExc\n             }\n         }\n         Map<Invoker<LoadBalanceBaseTest>, Integer> weightMap = weightInvokersSR.stream()\n-                .collect(Collectors.toMap(Function.identity(), e -> Integer.valueOf(e.getUrl().getParameter(\"weight\"))));\n+            .collect(Collectors.toMap(Function.identity(), e -> Integer.valueOf(e.getUrl().getParameter(\"weight\"))));\n         Integer totalWeight = weightMap.values().stream().reduce(0, Integer::sum);\n-        // max deviation 10%\n+        // max deviation = expectWeightValue * 2\n         int expectWeightValue = loop / totalWeight;\n-        int maxDeviation = expectWeightValue / 10;\n+        int maxDeviation = expectWeightValue * 2;\n         Assertions.assertEquals(sumInvoker1 + sumInvoker2 + sumInvoker5, loop, \"select failed!\");\n-        Assertions.assertTrue(Math.abs(sumInvoker1 / weightMap.get(weightInvoker1) - expectWeightValue) < maxDeviation, \"select failed!\");\n         Assertions.assertTrue(Math.abs(sumInvoker2 / weightMap.get(weightInvoker2) - expectWeightValue) < maxDeviation, \"select failed!\");\n         Assertions.assertTrue(Math.abs(sumInvoker5 / weightMap.get(weightInvoker5) - expectWeightValue) < maxDeviation, \"select failed!\");\n     }",
    "output": "Fix ShortestResponseLoadBalanceTest failure"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n@@ -118,11 +118,13 @@ public Object decode(Channel channel, InputStream input) throws IOException {\n     public void decode() throws Exception {\n         if (!hasDecoded && channel != null && inputStream != null) {\n             try {\n-                if (ConfigurationUtils.getSystemConfiguration().getBoolean(SERIALIZATION_SECURITY_CHECK_KEY, true)) {\n-                    Object serializationType_obj = invocation.get(SERIALIZATION_ID_KEY);\n-                    if (serializationType_obj != null) {\n-                        if ((byte) serializationType_obj != serializationType) {\n-                            throw new IOException(\"Unexpected serialization id:\" + serializationType + \" received from network, please check if the peer send the right id.\");\n+                if (invocation != null) {\n+                    if (ConfigurationUtils.getSystemConfiguration().getBoolean(SERIALIZATION_SECURITY_CHECK_KEY, true)) {\n+                        Object serializationType_obj = invocation.get(SERIALIZATION_ID_KEY);\n+                        if (serializationType_obj != null) {\n+                            if ((byte) serializationType_obj != serializationType) {\n+                                throw new IOException(\"Unexpected serialization id:\" + serializationType + \" received from network, please check if the peer send the right id.\");\n+                            }\n                         }\n                     }\n                 }",
    "output": "Fix NPE on serialization checking when request timed out"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java\n@@ -74,6 +74,10 @@ public List<Instance> selectInstances(String serviceName, boolean healthy) throw\n         return namingService.selectInstances(handleInnerSymbol(serviceName), healthy);\n     }\n+    public List<Instance> selectInstances(String serviceName, String group, boolean healthy) throws NacosException {\n+        return namingService.selectInstances(handleInnerSymbol(serviceName), group, healthy);\n+    }\n+\n     public void shutdown() throws NacosException {\n         this.namingService.shutDown();\n     }\ndiff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n@@ -27,6 +27,7 @@\n import org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;\n import org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils;\n+import com.alibaba.nacos.api.common.Constants;\n import com.alibaba.nacos.api.exception.NacosException;\n import com.alibaba.nacos.api.naming.listener.NamingEvent;\n import com.alibaba.nacos.api.naming.pojo.Instance;\n@@ -39,7 +40,6 @@\n import static org.apache.dubbo.common.function.ThrowableConsumer.execute;\n import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.createNamingService;\n-import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.getGroup;\n import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.toInstance;\n /**\n@@ -52,16 +52,13 @@ public class NacosServiceDiscovery extends AbstractServiceDiscovery {\n     private final Logger logger = LoggerFactory.getLogger(getClass());\n-    private String group;\n-\n     private NacosNamingServiceWrapper namingService;\n     private URL registryURL;\n     @Override\n     public void doInitialize(URL registryURL) throws Exception {\n         this.namingService = createNamingService(registryURL);\n-        this.group = getGroup(registryURL);\n         this.registryURL = registryURL;\n     }\n@@ -74,7 +71,10 @@ public void doDestroy() throws Exception {\n     public void doRegister(ServiceInstance serviceInstance) {\n         execute(namingService, service -> {\n             Instance instance = toInstance(serviceInstance);\n-            service.registerInstance(instance.getServiceName(), group, instance);\n+            // Should not register real group for ServiceInstance\n+            // Or will cause consumer unable to fetch all of the providers from every group\n+            // Provider's group is invisible for consumer\n+            service.registerInstance(instance.getServiceName(), Constants.DEFAULT_GROUP, instance);\n         });\n     }\n@@ -89,22 +89,28 @@ public void doUpdate(ServiceInstance serviceInstance) {\n     public void doUnregister(ServiceInstance serviceInstance) throws RuntimeException {\n         execute(namingService, service -> {\n             Instance instance = toInstance(serviceInstance);\n-            service.deregisterInstance(instance.getServiceName(), group, instance);\n+            // Should not register real group for ServiceInstance\n+            // Or will cause consumer unable to fetch all of the providers from every group\n+            // Provider's group is invisible for consumer\n+            service.deregisterInstance(instance.getServiceName(), Constants.DEFAULT_GROUP, instance);\n         });\n     }\n     @Override\n     public Set<String> getServices() {\n         return ThrowableFunction.execute(namingService, service -> {\n-            ListView<String> view = service.getServicesOfServer(0, Integer.MAX_VALUE, group);\n+            // Should not register real group for ServiceInstance\n+            // Or will cause consumer unable to fetch all of the providers from every group\n+            // Provider's group is invisible for consumer\n+            ListView<String> view = service.getServicesOfServer(0, Integer.MAX_VALUE, Constants.DEFAULT_GROUP);\n             return new LinkedHashSet<>(view.getData());\n         });\n     }\n     @Override\n     public List<ServiceInstance> getInstances(String serviceName) throws NullPointerException {\n         return ThrowableFunction.execute(namingService, service ->\n-                service.selectInstances(serviceName, true)\n+                service.selectInstances(serviceName, Constants.DEFAULT_GROUP, true)\n                         .stream().map(NacosNamingServiceUtils::toServiceInstance)\n                         .collect(Collectors.toList())\n         );\n@@ -116,7 +122,7 @@ public void addServiceInstancesChangedListener(ServiceInstancesChangedListener l\n         execute(namingService, service -> {\n             listener.getServiceNames().forEach(serviceName -> {\n                 try {\n-                    service.subscribe(serviceName, e -> { // Register Nacos EventListener\n+                    service.subscribe(serviceName, Constants.DEFAULT_GROUP, e -> { // Register Nacos EventListener\n                         if (e instanceof NamingEvent) {\n                             NamingEvent event = (NamingEvent) e;\n                             handleEvent(event, listener);\ndiff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtils.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtils.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtils.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtils.java\n@@ -36,9 +36,7 @@\n import static com.alibaba.nacos.api.PropertyKeyConst.NAMING_LOAD_CACHE_AT_START;\n import static com.alibaba.nacos.api.PropertyKeyConst.SERVER_ADDR;\n-import static com.alibaba.nacos.api.common.Constants.DEFAULT_GROUP;\n import static com.alibaba.nacos.client.naming.utils.UtilAndComs.NACOS_NAMING_LOG_NAME;\n-import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.RemotingConstants.BACKUP_KEY;\n import static org.apache.dubbo.common.utils.StringConstantFieldValuePredicate.of;\n@@ -85,19 +83,6 @@ public static ServiceInstance toServiceInstance(Instance instance) {\n         return serviceInstance;\n     }\n-    /**\n-     * The group of {@link NamingService} to register\n-     *\n-     * @param connectionURL {@link URL connection url}\n-     * @return non-null, \"default\" as default\n-     * @since 2.7.5\n-     */\n-    public static String getGroup(URL connectionURL) {\n-        // Compatible with nacos grouping via group.\n-        String group = connectionURL.getParameter(GROUP_KEY, DEFAULT_GROUP);\n-        return connectionURL.getParameter(NACOS_GROUP_KEY, group);\n-    }\n-\n     /**\n      * Create an instance of {@link NamingService} from specified {@link URL connection url}\n      *",
    "output": "Fix nacos group inviable in consumer side * Fix nacos group inviable in consumer side * remove getGroup method"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientTransportObserver.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientTransportObserver.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientTransportObserver.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientTransportObserver.java\n@@ -30,7 +30,7 @@\n import io.netty.util.AsciiString;\n public class ClientTransportObserver implements TransportObserver {\n-    private static final AsciiString SCHEME = AsciiString.of(\"http\");\n+    private final AsciiString SCHEME;\n     private final ChannelHandlerContext ctx;\n     private final Http2StreamChannel streamChannel;\n     private final ChannelPromise promise;\n@@ -41,6 +41,12 @@ public class ClientTransportObserver implements TransportObserver {\n     public ClientTransportObserver(ChannelHandlerContext ctx, AbstractClientStream stream, ChannelPromise promise) {\n         this.ctx = ctx;\n         this.promise = promise;\n+        Boolean ssl = ctx.channel().attr(TripleConstant.SSL_ATTRIBUTE_KEY).get();\n+        if (ssl != null && ssl) {\n+            SCHEME = TripleConstant.HTTPS_SCHEME;\n+        } else {\n+            SCHEME = TripleConstant.HTTP_SCHEME;\n+        }\n         final Http2StreamChannelBootstrap streamChannelBootstrap = new Http2StreamChannelBootstrap(ctx.channel());\n         streamChannel = streamChannelBootstrap.open().syncUninterruptibly().getNow();\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java\n@@ -16,8 +16,16 @@\n  */\n package org.apache.dubbo.rpc.protocol.tri;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http2.Http2GoAwayFrame;\n+import io.netty.handler.codec.http2.Http2SettingsFrame;\n+import io.netty.util.ReferenceCountUtil;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.stream.StreamObserver;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.remoting.api.Connection;\n import org.apache.dubbo.remoting.api.ConnectionHandler;\n@@ -31,13 +39,6 @@\n import org.apache.dubbo.rpc.model.MethodDescriptor;\n import org.apache.dubbo.rpc.model.ServiceRepository;\n-import io.netty.channel.ChannelDuplexHandler;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http2.Http2GoAwayFrame;\n-import io.netty.handler.codec.http2.Http2SettingsFrame;\n-import io.netty.util.ReferenceCountUtil;\n-\n public class TripleClientHandler extends ChannelDuplexHandler {\n     @Override\n@@ -82,6 +83,10 @@ private void writeRequest(ChannelHandlerContext ctx, final Request req, final Ch\n         } else {\n             stream = AbstractClientStream.stream(url);\n         }\n+        String ssl = url.getParameter(CommonConstants.SSL_ENABLED_KEY);\n+        if (StringUtils.isNotEmpty(ssl)) {\n+            ctx.channel().attr(TripleConstant.SSL_ATTRIBUTE_KEY).set(Boolean.parseBoolean(ssl));\n+        }\n         stream.service(service)\n                 .connection(Connection.getConnectionFromChannel(ctx.channel()))\n                 .method(methodDescriptor)\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleConstant.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleConstant.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleConstant.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleConstant.java\n@@ -17,15 +17,24 @@\n package org.apache.dubbo.rpc.protocol.tri;\n import io.netty.handler.codec.http2.Http2CodecUtil;\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+import org.apache.dubbo.common.constants.CommonConstants;\n public interface TripleConstant {\n     String CONTENT_PROTO = \"application/grpc+proto\";\n     String APPLICATION_GRPC = \"application/grpc\";\n     String TRI_VERSION = \"1.0.0\";\n     String SERIALIZATION_KEY = \"serialization\";\n-    String TE_KEY=\"te\";\n+    String TE_KEY = \"te\";\n     // each header size\n     long DEFAULT_HEADER_LIST_SIZE = Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;\n+    AttributeKey<Boolean> SSL_ATTRIBUTE_KEY = AttributeKey.valueOf(CommonConstants.SSL_ENABLED_KEY);\n+\n+\n+    AsciiString HTTPS_SCHEME = AsciiString.of(\"https\");\n+    AsciiString HTTP_SCHEME = AsciiString.of(\"http\");\n+\n }",
    "output": "Fix TLS using scheme HTTP when using TRI protocol * Fixed TLS using scheme HTTP when using TRI protocol * change ssl config to channel attr * Reuse scheme variable & Set attr only if ssl enabled"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n@@ -236,18 +236,18 @@ private void buildCache(boolean notify) {\n     /**\n      * Cache the address list for each StateRouter.\n      * @param router router\n-     * @param orign The original address cache\n+     * @param origin The original address cache\n      * @param invokers The full address list\n      * @param notify Whether the addresses in registry has changed.\n      * @return\n      */\n-    private RouterCache poolRouter(StateRouter router, AddrCache<T> orign, List<Invoker<T>> invokers, boolean notify) {\n+    private RouterCache poolRouter(StateRouter router, AddrCache<T> origin, List<Invoker<T>> invokers, boolean notify) {\n         String routerName = router.getName();\n         RouterCache routerCache;\n-        if (isCacheMiss(orign, routerName) || router.shouldRePool() || notify) {\n+        if (isCacheMiss(origin, routerName) || router.shouldRePool() || notify) {\n             return router.pool(invokers);\n         } else {\n-            routerCache = orign.getCache().get(routerName);\n+            routerCache = origin.getCache().get(routerName);\n         }\n         if (routerCache == null) {\n             return new RouterCache();\n@@ -293,8 +293,8 @@ public NotifyLoopRunnable(boolean notify, Semaphore loopPermit) {\n         @Override\n         public void run() {\n-            loopPermit.release();\n             buildCache(notify);\n+            loopPermit.release();\n         }\n     }\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java\n@@ -83,11 +83,6 @@ public synchronized void process(ConfigChangedEvent event) {\n         }\n     }\n-    @Override\n-    public URL getUrl() {\n-        return url;\n-    }\n-\n     @Override\n     public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache<T> cache, URL url,\n         Invocation invocation) throws RpcException {\n@@ -154,11 +149,7 @@ public <T> RouterCache<T> pool(List<Invoker<T>> invokers) {\n         if (tagRouterRuleCopy == null || !tagRouterRuleCopy.isValid() || !tagRouterRuleCopy.isEnabled()) {\n-            BitList<Invoker<T>> noTagList = new BitList<>(invokers, true);\n-\n-            for (int index = 0; index < invokers.size(); index++) {\n-                noTagList.addIndex(index);\n-            }\n+            BitList<Invoker<T>> noTagList = new BitList<>(invokers, false);\n             addrPool.put(NO_TAG, noTagList);\n             routerCache.setAddrPool(addrPool);\n             return routerCache;",
    "output": "Fix typo and some optimizations"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java\n@@ -96,7 +96,7 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L\n                         String.format(\"The number of BroadcastCluster call failures has reached the threshold %s\", failThresholdIndex));\n             } else {\n                 logger.debug(String.format(\"The number of BroadcastCluster call failures has not reached the threshold %s, fail size is %s\",\n-                        failIndex));\n+                        failThresholdIndex, failIndex));\n             }\n             throw exception;\n         }",
    "output": "Fix broadcast log format bug"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/multiple/injvm/MultipleRegistryCenterInjvmIntegrationTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/multiple/injvm/MultipleRegistryCenterInjvmIntegrationTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/multiple/injvm/MultipleRegistryCenterInjvmIntegrationTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/multiple/injvm/MultipleRegistryCenterInjvmIntegrationTest.java\n@@ -87,7 +87,7 @@ public void setUp() throws Exception {\n         logger.info(getClass().getSimpleName() + \" testcase is beginning...\");\n         DubboBootstrap.reset();\n         //start all zookeeper services only once\n-        registryCenter = new DefaultMultipleRegistryCenter();\n+        registryCenter = new DefaultMultipleRegistryCenter(-1);\n         registryCenter.startup();\n         // initialize service config\n         serviceConfig = new ServiceConfig<>();\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/SingleRegistryCenterDubboProtocolIntegrationTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/SingleRegistryCenterDubboProtocolIntegrationTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/SingleRegistryCenterDubboProtocolIntegrationTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/SingleRegistryCenterDubboProtocolIntegrationTest.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.config.RegistryConfig;\n import org.apache.dubbo.config.ServiceConfig;\n import org.apache.dubbo.config.ReferenceConfig;\n@@ -109,7 +110,7 @@ public class SingleRegistryCenterDubboProtocolIntegrationTest implements Integra\n     public void setUp() throws Exception {\n         logger.info(getClass().getSimpleName() + \" testcase is beginning...\");\n         DubboBootstrap.reset();\n-        registryCenter = new DefaultSingleRegistryCenter();\n+        registryCenter = new DefaultSingleRegistryCenter(NetUtils.getAvailablePort());\n         registryCenter.startup();\n         // initialize ServiceConfig\n         serviceConfig = new ServiceConfig<>();\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/injvm/SingleRegistryCenterInjvmIntegrationTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/injvm/SingleRegistryCenterInjvmIntegrationTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/injvm/SingleRegistryCenterInjvmIntegrationTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/integration/single/injvm/SingleRegistryCenterInjvmIntegrationTest.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.integration.single.injvm;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.config.ServiceConfig;\n import org.apache.dubbo.config.ReferenceConfig;\n import org.apache.dubbo.config.ServiceListener;\n@@ -84,7 +85,7 @@ public class SingleRegistryCenterInjvmIntegrationTest implements IntegrationTest\n     public void setUp() throws Exception {\n         logger.info(getClass().getSimpleName() + \" testcase is beginning...\");\n         DubboBootstrap.reset();\n-        registryCenter = new DefaultSingleRegistryCenter();\n+        registryCenter = new DefaultSingleRegistryCenter(NetUtils.getAvailablePort());\n         registryCenter.startup();\n         // initialize service config\n         serviceConfig = new ServiceConfig<>();\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/registrycenter/DefaultMultipleRegistryCenter.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/registrycenter/DefaultMultipleRegistryCenter.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/registrycenter/DefaultMultipleRegistryCenter.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/registrycenter/DefaultMultipleRegistryCenter.java\n@@ -48,14 +48,24 @@ public class DefaultMultipleRegistryCenter implements MultipleRegistryCenter {\n      */\n     private static final int DEFAULT_PORT = 2181;\n+    private final int port;\n+\n+    public DefaultMultipleRegistryCenter() {\n+        this(DEFAULT_PORT);\n+    }\n+\n+    public DefaultMultipleRegistryCenter(int port) {\n+        this.port = port;\n+    }\n+\n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public void startup() throws RpcException {\n         try {\n             logger.info(\"The DefaultMultipleRegistryCenter is starting...\");\n-            this.zookeeperServer1 = new TestingServer(DEFAULT_PORT);\n+            this.zookeeperServer1 = new TestingServer(port);\n             this.zookeeperServer2 = new TestingServer();\n             logger.info(\"The DefaultMultipleRegistryCenter is started successfully\");\n         } catch (Exception exception) {",
    "output": "Fix address in used error of port 2181"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n@@ -17,23 +17,19 @@\n package org.apache.dubbo.metadata;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.compiler.support.ClassUtils;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.url.component.URLParam;\n import org.apache.dubbo.common.utils.ArrayUtils;\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import java.io.Serializable;\n-import java.lang.reflect.Method;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n-import java.util.SortedSet;\n import java.util.TreeMap;\n-import java.util.TreeSet;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -191,10 +187,10 @@ public String getServiceString(String protocolServiceKey) {\n     @Override\n     public String toString() {\n         return \"metadata{\" +\n-                \"app='\" + app + \"',\" +\n-                \"revision='\" + revision + \"',\" +\n-                \"services=\" + services +\n-                \"}\";\n+            \"app='\" + app + \"',\" +\n+            \"revision='\" + revision + \"',\" +\n+            \"services=\" + services +\n+            \"}\";\n     }\n     public static class ServiceInfo implements Serializable {\n@@ -409,17 +405,7 @@ public boolean hasMethodParameter(String method) {\n         }\n         public String toDescString() {\n-            return this.getMatchKey() + getMethodSignaturesString() + new TreeMap<>(getParams());\n-        }\n-\n-        private String getMethodSignaturesString() {\n-            SortedSet<String> methodStrings = new TreeSet();\n-\n-            Method[] methods = ClassUtils.forName(name).getMethods();\n-            for (Method method : methods) {\n-                methodStrings.add(method.toString());\n-            }\n-            return methodStrings.toString();\n+            return this.getMatchKey() + path + new TreeMap<>(getParams());\n         }\n         public void addParameter(String key, String value) {\n@@ -490,13 +476,13 @@ public int hashCode() {\n         @Override\n         public String toString() {\n             return \"service{\" +\n-                    \"name='\" + name + \"',\" +\n-                    \"group='\" + group + \"',\" +\n-                    \"version='\" + version + \"',\" +\n-                    \"protocol='\" + protocol + \"',\" +\n-                    \"params=\" + params + \",\" +\n-                    \"consumerParams=\" + consumerParams +\n-                    \"}\";\n+                \"name='\" + name + \"',\" +\n+                \"group='\" + group + \"',\" +\n+                \"version='\" + version + \"',\" +\n+                \"protocol='\" + protocol + \"',\" +\n+                \"params=\" + params + \",\" +\n+                \"consumerParams=\" + consumerParams +\n+                \"}\";\n         }\n     }\n }",
    "output": "Change Service Info revision cal structure * Change Service Info revision cal structure * remove duplicated params"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java\n@@ -23,7 +23,6 @@\n import org.apache.dubbo.common.serialize.MultipleSerialization;\n import org.apache.dubbo.common.stream.StreamObserver;\n import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;\n-import org.apache.dubbo.common.utils.ConfigUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.Constants;\n import org.apache.dubbo.remoting.exchange.Request;\n@@ -37,7 +36,6 @@\n import com.google.rpc.Status;\n import io.netty.handler.codec.http2.Http2Headers;\n-import java.io.IOException;\n import java.util.ArrayList;\n import java.util.LinkedHashMap;\n import java.util.List;\n@@ -51,13 +49,11 @@\n import java.util.concurrent.TimeUnit;\n public abstract class AbstractStream implements Stream {\n-    public static final boolean ENABLE_ATTACHMENT_WRAP = Boolean.parseBoolean(\n-            ConfigUtils.getProperty(\"triple.attachment\", \"false\"));\n     protected static final String DUPLICATED_DATA = \"Duplicated data\";\n     private static final List<Executor> CALLBACK_EXECUTORS = new ArrayList<>(4);\n     static {\n-        ThreadFactory tripleTF = new NamedInternalThreadFactory(\"tri-callbcak\", true);\n+        ThreadFactory tripleTF = new NamedInternalThreadFactory(\"tri-callback\", true);\n         for (int i = 0; i < 4; i++) {\n             final ThreadPoolExecutor tp = new ThreadPoolExecutor(1, 1, 0, TimeUnit.DAYS,\n                     new LinkedBlockingQueue<>(1024),\n@@ -278,16 +274,6 @@ protected Map<String, Object> parseMetadataToMap(Metadata metadata) {\n                 continue;\n             }\n-            if (ENABLE_ATTACHMENT_WRAP) {\n-                if (key.endsWith(\"-tw-bin\") && key.length() > 7) {\n-                    try {\n-                        attachments.put(key.substring(0, key.length() - 7),\n-                                TripleUtil.decodeObjFromHeader(url, header.getValue(), multipleSerialization));\n-                    } catch (Exception e) {\n-                        LOGGER.error(\"Failed to parse response attachment key=\" + key, e);\n-                    }\n-                }\n-            }\n             if (key.endsWith(\"-bin\") && key.length() > 4) {\n                 try {\n                     attachments.put(key.substring(0, key.length() - 4), TripleUtil.decodeASCIIByte(header.getValue()));\n@@ -314,22 +300,13 @@ protected void convertAttachment(Metadata metadata, Map<String, Object> attachme\n     private void convertSingleAttachment(Metadata metadata, String key, Object v) {\n         try {\n-            if (!ENABLE_ATTACHMENT_WRAP) {\n-                if (v instanceof String) {\n-                    metadata.put(key, (String) v);\n-                } else if (v instanceof byte[]) {\n-                    metadata.put(key + \"-bin\", TripleUtil.encodeBase64ASCII((byte[]) v));\n-                }\n-            } else {\n-                if (v instanceof String || serializeType == null) {\n-                    metadata.put(key, v.toString());\n-                } else {\n-                    String encoded = TripleUtil.encodeWrapper(url, v, this.serializeType, getMultipleSerialization());\n-                    metadata.put(key + \"-tw-bin\", encoded);\n-                }\n+            if (v instanceof String) {\n+                metadata.put(key, (String) v);\n+            } else if (v instanceof byte[]) {\n+                metadata.put(key + \"-bin\", TripleUtil.encodeBase64ASCII((byte[]) v));\n             }\n-        } catch (IOException e) {\n-            LOGGER.warn(\"Meet exception when convert single attachment key:\" + key, e);\n+        } catch (Throwable t) {\n+            LOGGER.warn(\"Meet exception when convert single attachment key:\" + key + \" value=\" + v, t);\n         }\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java\n@@ -76,6 +76,9 @@ protected void onError(GrpcStatus status) {\n             response.setErrorMessage(status.description);\n             final AppResponse result = new AppResponse();\n             result.setException(getThrowable(this.getTrailers()));\n+            // avoid subsequent parse header problems\n+            this.getTrailers().remove(TripleConstant.EXCEPTION_TW_BIN);\n+            this.getTrailers().remove(TripleConstant.STATUS_KEY);\n             result.setObjectAttachments(UnaryClientStream.this.parseMetadataToMap(this.getTrailers()));\n             response.setResult(result);\n             if (!result.hasException()) {\n@@ -103,8 +106,6 @@ private Throwable getThrowable(Metadata metadata) {\n                     } finally {\n                         ClassLoadUtil.switchContextLoader(tccl);\n                     }\n-                    // avoid subsequent parse header problems\n-                    metadata.remove(TripleConstant.EXCEPTION_TW_BIN);\n                 }\n             } catch (Throwable t) {\n                 LOGGER.warn(String.format(\"Decode exception instance from triple trailers:%s failed\", metadata), t);",
    "output": "Remove auto wrap when attachment is an object instance & remove excpption metadata when handled & fix typo"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/rule/VirtualServiceRuleTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/rule/VirtualServiceRuleTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/rule/VirtualServiceRuleTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/rule/VirtualServiceRuleTest.java\n@@ -17,11 +17,17 @@\n package org.apache.dubbo.rpc.cluster.router.mesh.rule;\n+import org.apache.dubbo.rpc.cluster.router.mesh.rule.virtualservice.DubboRoute;\n+import org.apache.dubbo.rpc.cluster.router.mesh.rule.virtualservice.DubboRouteDetail;\n import org.apache.dubbo.rpc.cluster.router.mesh.rule.virtualservice.VirtualServiceRule;\n import org.junit.jupiter.api.Test;\n import org.yaml.snakeyaml.Yaml;\n+import java.util.List;\n+\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n public class VirtualServiceRuleTest {\n@@ -33,6 +39,43 @@ public void parserTest() {\n         System.out.println(virtualServiceRule);\n         assertNotNull(virtualServiceRule);\n+\n+        assertEquals(\"service.dubbo.apache.org/v1alpha1\", virtualServiceRule.getApiVersion());\n+        assertEquals(\"VirtualService\", virtualServiceRule.getKind());\n+        assertEquals(\"demo-route\", virtualServiceRule.getMetadata().get(\"name\"));\n+\n+        List<String> hosts = virtualServiceRule.getSpec().getHosts();\n+        assertEquals(1, hosts.size());\n+        assertEquals(\"demo\", hosts.get(0));\n+\n+        List<DubboRoute> dubboRoutes = virtualServiceRule.getSpec().getDubbo();\n+        assertEquals(1, dubboRoutes.size());\n+\n+        DubboRoute dubboRoute = dubboRoutes.get(0);\n+        assertNull(dubboRoute.getName());\n+\n+        assertEquals(1, dubboRoute.getServices().size());\n+        assertEquals(\"ccc\", dubboRoute.getServices().get(0).getRegex());\n+\n+        List<DubboRouteDetail> routedetail = dubboRoute.getRoutedetail();\n+        DubboRouteDetail firstDubboRouteDetail = routedetail.get(0);\n+        DubboRouteDetail secondDubboRouteDetail = routedetail.get(1);\n+        DubboRouteDetail thirdDubboRouteDetail = routedetail.get(2);\n+\n+        assertEquals(\"xxx-project\", firstDubboRouteDetail.getName());\n+        assertEquals(\"xxx\", firstDubboRouteDetail.getMatch().get(0).getSourceLabels().get(\"trafficLabel\"));\n+        assertEquals(\"demo\", firstDubboRouteDetail.getRoute().get(0).getDestination().getHost());\n+        assertEquals(\"isolation\", firstDubboRouteDetail.getRoute().get(0).getDestination().getSubset());\n+\n+        assertEquals(\"testing-trunk\", secondDubboRouteDetail.getName());\n+        assertEquals(\"testing-trunk\", secondDubboRouteDetail.getMatch().get(0).getSourceLabels().get(\"trafficLabel\"));\n+        assertEquals(\"demo\", secondDubboRouteDetail.getRoute().get(0).getDestination().getHost());\n+        assertEquals(\"testing-trunk\", secondDubboRouteDetail.getRoute().get(0).getDestination().getSubset());\n+\n+        assertEquals(\"testing\", thirdDubboRouteDetail.getName());\n+        assertNull(thirdDubboRouteDetail.getMatch());\n+        assertEquals(\"demo\", thirdDubboRouteDetail.getRoute().get(0).getDestination().getHost());\n+        assertEquals(\"testing\", thirdDubboRouteDetail.getRoute().get(0).getDestination().getSubset());\n     }\n }",
    "output": "Add unit test for VirtualServiceRule * Add unit test for VirtualServiceRule * FIX UT"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java\n@@ -44,7 +44,7 @@ public class MeshAppRuleListener implements ConfigurationListener {\n     private final String appName;\n-    private VsDestinationGroup vsDestinationGroupHolder;\n+    private volatile VsDestinationGroup vsDestinationGroupHolder;\n     public MeshAppRuleListener(String appName) {\n         this.appName = appName;\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java\n@@ -59,7 +59,7 @@ public class MeshRuleRouter implements Router, VsDestinationGroupRuleListener {\n     private volatile Map<String, List<Invoker<?>>> subsetMap;\n-    private String remoteAppName;\n+    private volatile String remoteAppName;\n     public MeshRuleRouter(URL url) {\n         this.url = url;",
    "output": "Add volatile modifier to some variables"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.rpc.cluster.router.mesh.route;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;\n import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;\n import org.apache.dubbo.common.config.configcenter.ConfigurationListener;\n import org.apache.dubbo.common.logger.Logger;\n@@ -101,6 +102,10 @@ public void unregister(MeshRuleRouter sub) {\n     @Override\n     public void process(ConfigChangedEvent event) {\n+        if (event.getChangeType() == ConfigChangeType.DELETED) {\n+            receiveConfigInfo(\"\");\n+            return;\n+        }\n         receiveConfigInfo(event.getContent());\n     }\n }",
    "output": "Fix delete mesh rule npx"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n@@ -228,14 +228,10 @@ public static URL valueOf(String url) {\n      * @return\n      */\n     public static URL valueOf(String url, boolean encoded) {\n-        return valueOf(url, encoded, false);\n-    }\n-\n-    public static URL valueOf(String url, boolean encoded, boolean modifiable) {\n         if (encoded) {\n-            return URLStrParser.parseEncodedStr(url, modifiable);\n+            return URLStrParser.parseEncodedStr(url);\n         }\n-        return URLStrParser.parseDecodedStr(url, modifiable);\n+        return URLStrParser.parseDecodedStr(url);\n     }\n     public static URL valueOf(String url, String... reserveParams) {\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.dubbo.common;\n-import org.apache.dubbo.common.logger.Logger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.url.component.ServiceConfigURL;\n import org.apache.dubbo.common.url.component.URLItemCache;\n@@ -31,7 +29,6 @@\n import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n public final class URLStrParser {\n-    private static final Logger logger = LoggerFactory.getLogger(URLStrParser.class);\n     public static final String ENCODED_QUESTION_MARK = \"%3F\";\n     public static final String ENCODED_TIMESTAMP_KEY = \"timestamp%3D\";\n     public static final String ENCODED_PID_KEY = \"pid%3D\";\n@@ -44,16 +41,13 @@ private URLStrParser() {\n         //empty\n     }\n-    public static URL parseDecodedStr(String decodedURLStr) {\n-        return parseDecodedStr(decodedURLStr, false);\n-    }\n     /**\n      * @param decodedURLStr : after {@link URL#decode} string\n      *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n      *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n      */\n-    public static URL parseDecodedStr(String decodedURLStr, boolean modifiable) {\n+    public static URL parseDecodedStr(String decodedURLStr) {\n         Map<String, String> parameters = null;\n         int pathEndIdx = decodedURLStr.indexOf('?');\n         if (pathEndIdx >= 0) {\n@@ -63,7 +57,7 @@ public static URL parseDecodedStr(String decodedURLStr, boolean modifiable) {\n         }\n         String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n-        return parseURLBody(decodedURLStr, decodedBody, parameters, modifiable);\n+        return parseURLBody(decodedURLStr, decodedBody, parameters);\n     }\n     private static Map<String, String> parseDecodedParams(String str, int from) {\n@@ -106,7 +100,7 @@ private static Map<String, String> parseDecodedParams(String str, int from) {\n      * @param parameters  :\n      * @return URL\n      */\n-    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters, boolean modifiable) {\n+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n         int starIdx = 0, endIdx = decodedBody.length();\n         // ignore the url content following '#'\n         int poundIndex = decodedBody.indexOf('#');\n@@ -181,10 +175,6 @@ private static URL parseURLBody(String fullURLStr, String decodedBody, Map<Strin\n         return new ServiceConfigURL(protocol, username, password, host, port, path, parameters);\n     }\n-    public static URL parseEncodedStr(String encodedURLStr) {\n-        return parseEncodedStr(encodedURLStr, false);\n-    }\n-\n     public static String[] parseRawURLToArrays(String rawURLStr, int pathEndIdx) {\n         String[] parts = new String[2];\n         int paramStartIdx = pathEndIdx + 3;//skip ENCODED_QUESTION_MARK\n@@ -218,7 +208,7 @@ public static Map<String, String> parseParams(String rawParams, boolean encoded)\n      *                      encodedURLStr after decode format: protocol://username:password@host:port/path?k1=v1&k2=v2\n      *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n      */\n-    public static URL parseEncodedStr(String encodedURLStr, boolean modifiable) {\n+    public static URL parseEncodedStr(String encodedURLStr) {\n         Map<String, String> parameters = null;\n         int pathEndIdx = encodedURLStr.toUpperCase().indexOf(\"%3F\");// '?'\n         if (pathEndIdx >= 0) {\n@@ -229,7 +219,7 @@ public static URL parseEncodedStr(String encodedURLStr, boolean modifiable) {\n         //decodedBody format: [protocol://][username:password@][host:port]/[path]\n         String decodedBody = decodeComponent(encodedURLStr, 0, pathEndIdx, false, DECODE_TEMP_BUF.get());\n-        return parseURLBody(encodedURLStr, decodedBody, parameters, modifiable);\n+        return parseURLBody(encodedURLStr, decodedBody, parameters);\n     }\n     private static Map<String, String> parseEncodedParams(String str, int from) {",
    "output": "Remove unused modifiable param * Remove unused modifiable param * FIX ut"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/state/BitListTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/state/BitListTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/state/BitListTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/state/BitListTest.java\n@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public class BitListTest {\n+    @Test\n+    public void test() {\n+        List<String> list = Arrays.asList(\"A\", \"B\", \"C\");\n+        BitList<String> bitList = new BitList<>(list);\n+        Assertions.assertEquals(bitList.getUnmodifiableList(), list);\n+        Assertions.assertEquals(3, bitList.size());\n+\n+        Assertions.assertEquals(\"A\", bitList.get(0));\n+        Assertions.assertEquals(\"B\", bitList.get(1));\n+        Assertions.assertEquals(\"C\", bitList.get(2));\n+\n+        Assertions.assertTrue(bitList.contains(\"A\"));\n+        Assertions.assertTrue(bitList.contains(\"B\"));\n+        Assertions.assertTrue(bitList.contains(\"C\"));\n+\n+        Iterator<String> iterator = bitList.iterator();\n+        while (iterator.hasNext()) {\n+            String str = iterator.next();\n+            Assertions.assertTrue(list.contains(str));\n+        }\n+\n+        Assertions.assertEquals(0, bitList.indexOf(\"A\"));\n+        Assertions.assertEquals(1, bitList.indexOf(\"B\"));\n+        Assertions.assertEquals(2, bitList.indexOf(\"C\"));\n+\n+        Object[] objects = bitList.toArray();\n+        for (Object obj : objects) {\n+            Assertions.assertTrue(list.contains(obj));\n+        }\n+\n+        Object[] newObjects = new Object[1];\n+        Object[] copiedList = bitList.toArray(newObjects);\n+        Assertions.assertEquals(copiedList.length, 3);\n+        Assertions.assertArrayEquals(copiedList, list.toArray());\n+\n+        newObjects = new Object[10];\n+        copiedList = bitList.toArray(newObjects);\n+        Assertions.assertNull(copiedList);\n+\n+        bitList.remove(0);\n+        Assertions.assertEquals(\"B\", bitList.get(0));\n+        bitList.addIndex(0);\n+        Assertions.assertEquals(\"A\", bitList.get(0));\n+\n+        bitList.removeAll(list);\n+        Assertions.assertEquals(0, bitList.size());\n+        bitList.clear();\n+    }\n+\n+    @Test\n+    public void testIntersect() {\n+        List<String> aList = Arrays.asList(\"A\", \"B\", \"C\");\n+        List<String> bList = Arrays.asList(\"A\", \"B\");\n+        List<String> totalList = Arrays.asList(\"A\", \"B\", \"C\");\n+\n+        BitList<String> aBitList = new BitList<>(aList);\n+        BitList<String> bBitList = new BitList<>(bList);\n+\n+        BitList<String> intersectBitList = aBitList.intersect(bBitList, totalList);\n+        Assertions.assertEquals(intersectBitList.size(), 2);\n+        Assertions.assertEquals(intersectBitList.get(0), totalList.get(0));\n+        Assertions.assertEquals(intersectBitList.get(1), totalList.get(1));\n+    }\n+\n+}",
    "output": "Add unit test for BitList * Add unit test for BitList * FIX UT"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboBootstrapApplicationListener.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboBootstrapApplicationListener.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboBootstrapApplicationListener.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboBootstrapApplicationListener.java\n@@ -82,7 +82,11 @@ public void onApplicationEvent(ApplicationEvent event) {\n     private void initDubboConfigBeans() {\n         // load DubboConfigBeanInitializer to init config beans\n-        applicationContext.getBean(DubboConfigBeanInitializer.BEAN_NAME, DubboConfigBeanInitializer.class);\n+        if (applicationContext.containsBean(DubboConfigBeanInitializer.BEAN_NAME)) {\n+            applicationContext.getBean(DubboConfigBeanInitializer.BEAN_NAME, DubboConfigBeanInitializer.class);\n+        } else {\n+            logger.warn(\"Bean '\" + DubboConfigBeanInitializer.BEAN_NAME + \"' was not found\");\n+        }\n         // All infrastructure config beans are loaded, initialize dubbo here\n         DubboBootstrap.getInstance().initialize();\n@@ -138,6 +142,10 @@ public int getOrder() {\n     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n         this.applicationContext = applicationContext;\n+        checkCallStackAndInit();\n+    }\n+\n+    private void checkCallStackAndInit() {\n         // check call stack whether contains org.springframework.context.support.AbstractApplicationContext.registerListeners()\n         Exception exception = new Exception();\n         StackTraceElement[] stackTrace = exception.getStackTrace();\n@@ -148,13 +156,13 @@ public void setApplicationContext(ApplicationContext applicationContext) throws\n                 break;\n             }\n         }\n-        if (!found) {\n+        if (found) {\n+            // init config beans here, compatible with spring 3.x/4.1.x\n+            initDubboConfigBeans();\n+        } else {\n             logger.warn(\"DubboBootstrapApplicationListener initialization is unexpected, \" +\n-                \"it should be created in AbstractApplicationContext.registerListeners() method\", exception);\n+                    \"it should be created in AbstractApplicationContext.registerListeners() method\", exception);\n         }\n-\n-        // init config beans here, compatible with spring 3.x/4.1.x\n-        initDubboConfigBeans();\n     }\n     public ApplicationContext getApplicationContext() {",
    "output": "Fix error when register dubbo bootstrap application listener in hsf consumer bean"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n@@ -221,6 +221,9 @@ public static class ServiceInfo implements Serializable {\n         private transient URL url;\n+        private final static String[] KEYS_TO_REMOVE = {MONITOR_KEY, BIND_IP_KEY, BIND_PORT_KEY, QOS_ENABLE,\n+            QOS_HOST, QOS_PORT, ACCEPT_FOREIGN_IP, VALIDATION_KEY, INTERFACES, PID_KEY, TIMESTAMP_KEY};\n+\n         public ServiceInfo() {\n         }\n@@ -231,11 +234,10 @@ public ServiceInfo(URL url) {\n             Map<String, String> params = new HashMap<>();\n             List<MetadataParamsFilter> filters = loader.getActivateExtension(url, \"params-filter\");\n             if (filters.size() == 0) {\n-                params.putAll(\n-                        url.removeParameters(\n-                                MONITOR_KEY, BIND_IP_KEY, BIND_PORT_KEY, QOS_ENABLE,\n-                                QOS_HOST, QOS_PORT, ACCEPT_FOREIGN_IP, VALIDATION_KEY, INTERFACES, PID_KEY, TIMESTAMP_KEY)\n-                                .getParameters());\n+                params.putAll(url.getParameters());\n+                for (String key : KEYS_TO_REMOVE) {\n+                    params.remove(key);\n+                }\n             }\n             for (MetadataParamsFilter filter : filters) {\n                 String[] paramsIncluded = filter.serviceParamsIncluded();",
    "output": "Fix Metadata Service Info param filter not work"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n@@ -134,18 +134,22 @@ protected void checkDefault() {\n         }\n     }\n+    @Override\n     public String getVersion() {\n         return version;\n     }\n+    @Override\n     public void setVersion(String version) {\n         this.version = version;\n     }\n+    @Override\n     public String getGroup() {\n         return group;\n     }\n+    @Override\n     public void setGroup(String group) {\n         this.group = group;\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n@@ -200,10 +200,12 @@ public static Class<?> determineInterfaceClass(String generic, String interfaceN\n         return null;\n     }\n+    @Override\n     public String getInterface() {\n         return interfaceName;\n     }\n+    @Override\n     public void setInterface(String interfaceName) {\n         this.interfaceName = interfaceName;\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -209,6 +209,7 @@ public void init() {\n         serviceMetadata.generateServiceKey();\n     }\n+    @Override\n     public synchronized void export() {\n         if (this.shouldExport() && !this.exported) {\n             this.init();",
    "output": "Add the lost @Override annotation of Config"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n@@ -140,11 +140,14 @@ public String getParameter(String key) {\n     @Override\n     public String getServiceParameter(String service, String key) {\n-        String value = getInstanceParameter(key);\n-        if (StringUtils.isEmpty(value) && metadataInfo != null) {\n-            value = metadataInfo.getParameter(key, service);\n+        if (metadataInfo != null) {\n+            String value = metadataInfo.getParameter(key, service);\n+            if (StringUtils.isNotEmpty(value)) {\n+                return value;\n+            }\n         }\n-        return value;\n+\n+        return getInstanceParameter(key);\n     }\n     /**",
    "output": "Fix service parameter fetch order"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n@@ -41,6 +41,8 @@\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_CHAR_SEPARATOR;\n import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.MONITOR_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.PID_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n import static org.apache.dubbo.common.constants.FilterConstants.VALIDATION_KEY;\n import static org.apache.dubbo.common.constants.QosConstants.ACCEPT_FOREIGN_IP;\n import static org.apache.dubbo.common.constants.QosConstants.QOS_ENABLE;\n@@ -232,7 +234,7 @@ public ServiceInfo(URL url) {\n                 params.putAll(\n                         url.removeParameters(\n                                 MONITOR_KEY, BIND_IP_KEY, BIND_PORT_KEY, QOS_ENABLE,\n-                                QOS_HOST, QOS_PORT, ACCEPT_FOREIGN_IP, VALIDATION_KEY, INTERFACES)\n+                                QOS_HOST, QOS_PORT, ACCEPT_FOREIGN_IP, VALIDATION_KEY, INTERFACES, PID_KEY, TIMESTAMP_KEY)\n                                 .getParameters());\n             }\n             for (MetadataParamsFilter filter : filters) {",
    "output": "Fix ServiceInfo contains runtime params"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleManager.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleManager.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleManager.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleManager.java\n@@ -31,7 +31,6 @@ public final class MeshRuleManager {\n     public static final Logger logger = LoggerFactory.getLogger(MeshRuleManager.class);\n     private static final String MESH_RULE_DATA_ID_SUFFIX = \".MESHAPPRULE\";\n-    private static final String GROUP = \"DEFAULT_GROUP\";\n     private static final ConcurrentHashMap<String, MeshAppRuleListener> APP_RULE_LISTENERS = new ConcurrentHashMap<>();\n@@ -48,15 +47,15 @@ public synchronized static void subscribeAppRule(String app) {\n         }\n         try {\n-            String rawConfig = configuration.getConfig(appRuleDataId, GROUP, 5000L);\n+            String rawConfig = configuration.getConfig(appRuleDataId, DynamicConfiguration.DEFAULT_GROUP, 5000L);\n             if (rawConfig != null) {\n                 meshAppRuleListener.receiveConfigInfo(rawConfig);\n             }\n         } catch (Throwable throwable) {\n             logger.error(\"get MeshRuleManager app rule failed.\", throwable);\n         }\n-        configuration.addListener(appRuleDataId, GROUP, meshAppRuleListener);\n+        configuration.addListener(appRuleDataId, DynamicConfiguration.DEFAULT_GROUP, meshAppRuleListener);\n         APP_RULE_LISTENERS.put(app, meshAppRuleListener);\n     }",
    "output": "Change mesh rule group to config default value"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/mock/MockProtocol.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/mock/MockProtocol.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/mock/MockProtocol.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/mock/MockProtocol.java\n@@ -40,13 +40,15 @@ public int getDefaultPort() {\n     /* (non-Javadoc)\n      * @see org.apache.dubbo.rpc.Protocol#export(org.apache.dubbo.rpc.Invoker)\n      */\n+    @Override\n     public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n         return Mockito.mock(Exporter.class);\n     }\n     /* (non-Javadoc)\n      * @see org.apache.dubbo.rpc.Protocol#refer(java.lang.Class, org.apache.dubbo.common.URL)\n      */\n+    @Override\n     public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n         final URL u = url;\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java\n@@ -62,6 +62,7 @@ protected static String serviceKey(int port, String serviceName, String serviceV\n         return ProtocolUtils.serviceKey(port, serviceName, serviceVersion, serviceGroup);\n     }\n+    @Override\n     public List<ProtocolServer> getServers() {\n         return Collections.unmodifiableList(new ArrayList<>(serverMap.values()));\n     }",
    "output": "Add the lost annotation of the Subclass of Protocol. * Add the lost annotation of the Subclass of Protocol. * rollback the class generate in native"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n@@ -549,7 +549,7 @@ public ReferenceConfigCache getCache() {\n     /**\n      * Initialize\n      */\n-    public void initialize() {\n+    public synchronized void initialize() {\n         if (!initialized.compareAndSet(false, true)) {\n             return;\n         }",
    "output": "Make initialize synchronized"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java b/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n@@ -103,7 +103,6 @@ public class ConfigManager extends LifecycleAdapter implements FrameworkExt {\n         for (Class<? extends AbstractConfig> configType : uniqueConfigTypes) {\n             configNames.add(configType.getSimpleName());\n         }\n-        logger.info(\"Unique config types: \" + configNames);\n     }\n     public ConfigManager() {\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/definition/builder/EnumTypeBuilder.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/definition/builder/EnumTypeBuilder.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/definition/builder/EnumTypeBuilder.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/definition/builder/EnumTypeBuilder.java\n@@ -52,6 +52,7 @@ public TypeDefinition build(Type type, Class<?> clazz, Map<String, TypeDefinitio\n         try {\n             Method methodValues = clazz.getDeclaredMethod(\"values\");\n+            methodValues.setAccessible(true);\n             Object[] values = (Object[]) methodValues.invoke(clazz, new Object[0]);\n             int length = values.length;\n             for (int i = 0; i < length; i++) {\n@@ -62,7 +63,7 @@ public TypeDefinition build(Type type, Class<?> clazz, Map<String, TypeDefinitio\n         } catch (Throwable t) {\n             logger.error(\"There is an error while process class \" + clazz, t);\n         }\n-        return null;\n+        return td;\n     }\n }",
    "output": "Remove logger output when init & Fix Enum inaccessible cause NPE"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java\n@@ -21,6 +21,8 @@\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n public abstract class RegistryNotifier {\n@@ -30,6 +32,11 @@ public abstract class RegistryNotifier {\n     private Object rawAddresses;\n     private long delayTime;\n+    // should delay notify or not\n+    private final AtomicBoolean shouldDelay = new AtomicBoolean(false);\n+    // for the first 10 notification will be notified immediately\n+    private final AtomicInteger executeTime = new AtomicInteger(0);\n+\n     private ScheduledExecutorService scheduler;\n     public RegistryNotifier(long delayTime) {\n@@ -52,10 +59,17 @@ public synchronized void notify(Object rawAddresses) {\n         this.lastEventTime = notifyTime;\n         long delta = (System.currentTimeMillis() - lastExecuteTime) - delayTime;\n-        if (delta >= 0) {\n-            scheduler.submit(new NotificationTask(this, notifyTime));\n-        } else {\n+\n+        // more than 10 calls && next execute time is in the future\n+        boolean delay = shouldDelay.get() && delta < 0;\n+        if (delay) {\n             scheduler.schedule(new NotificationTask(this, notifyTime), -delta, TimeUnit.MILLISECONDS);\n+        } else {\n+            // check if more than 10 calls\n+            if (!shouldDelay.get() && executeTime.incrementAndGet() > 10) {\n+                shouldDelay.set(true);\n+            }\n+            scheduler.submit(new NotificationTask(this, notifyTime));\n         }\n     }",
    "output": "Make first 10 calls notify not delay"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/OverrideInstanceAddressURL.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/OverrideInstanceAddressURL.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/OverrideInstanceAddressURL.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/OverrideInstanceAddressURL.java\n@@ -90,7 +90,7 @@ public String getServiceKey() {\n     @Override\n     public String getAddress() {\n-        return originUrl.getAddress() + \"?\" + overrideParams.toString();\n+        return originUrl.getAddress();\n     }\n     @Override\n@@ -260,6 +260,10 @@ protected Map<String, Map<String, Number>> getMethodNumbers() {\n         return methodNumbers;\n     }\n+    public URLParam getOverrideParams() {\n+        return overrideParams;\n+    }\n+\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) return true;\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -68,14 +68,14 @@ public ServiceDiscoveryRegistryDirectory(Class<T> serviceType, URL url) {\n     @Override\n     public void subscribe(URL url) {\n-        super.subscribe(url);\n         if (ApplicationModel.getEnvironment().getConfiguration().convert(Boolean.class, Constants.ENABLE_CONFIGURATION_LISTEN, true)) {\n             enableConfigurationListen = true;\n             CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(this);\n             referenceConfigurationListener = new ReferenceConfigurationListener(this, url);\n         } else {\n             enableConfigurationListen = false;\n         }\n+        super.subscribe(url);\n     }\n     @Override\n@@ -283,7 +283,7 @@ private Map<String, Invoker<T>> toInvokers(List<URL> urls) {\n                 instanceAddressURL = overrideWithConfigurator(instanceAddressURL);\n             }\n-            Invoker<T> invoker = urlInvokerMap == null ? null : urlInvokerMap.remove(instanceAddressURL.getAddress());\n+            Invoker<T> invoker = urlInvokerMap == null ? null : urlInvokerMap.get(instanceAddressURL.getAddress());\n             if (invoker == null || urlChanged(invoker, instanceAddressURL)) { // Not in the cache, refer again\n                 try {\n                     boolean enabled = true;\n@@ -303,6 +303,7 @@ private Map<String, Invoker<T>> toInvokers(List<URL> urls) {\n                 }\n             } else {\n                 newUrlInvokerMap.put(instanceAddressURL.getAddress(), invoker);\n+                urlInvokerMap.remove(instanceAddressURL.getAddress(), invoker);\n             }\n         }\n         return newUrlInvokerMap;\n@@ -315,6 +316,17 @@ private boolean urlChanged(Invoker<T> invoker, InstanceAddressURL newURL) {\n             return true;\n         }\n+        if (oldURL instanceof OverrideInstanceAddressURL || newURL instanceof OverrideInstanceAddressURL) {\n+            if(!(oldURL instanceof OverrideInstanceAddressURL && newURL instanceof OverrideInstanceAddressURL)) {\n+                // sub-class changed\n+                return true;\n+            } else {\n+                if (!((OverrideInstanceAddressURL) oldURL).getOverrideParams().equals(((OverrideInstanceAddressURL) newURL).getOverrideParams())) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n         return !oldURL.getMetadataInfo().getServiceInfo(getConsumerUrl().getProtocolServiceKey())\n             .equals(newURL.getMetadataInfo().getServiceInfo(getConsumerUrl().getProtocolServiceKey()));\n     }",
    "output": "Fix service discovery not work on bootstrap & fix address pollution * fix service discovery not work on bootstrap & fix address pollution * fix invoker leakage when urlChanged"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n@@ -41,6 +41,7 @@\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.TreeSet;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n@@ -292,6 +293,7 @@ public void destroy() {\n     }\n     protected void subscribeURLs(URL url, NotifyListener listener, Set<String> serviceNames) {\n+        serviceNames = new TreeSet<>(serviceNames);\n         String serviceNamesKey = toStringKeys(serviceNames);\n         String protocolServiceKey = url.getServiceKey() + GROUP_CHAR_SEPARATOR + url.getParameter(PROTOCOL_KEY, DUBBO);",
    "output": "Use TreeSet to ensure ServiceNames order"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java b/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n@@ -87,7 +87,7 @@ public class ConfigManager extends LifecycleAdapter implements FrameworkExt {\n     private boolean ignoreDuplicatedInterface = false;\n-    private static Map<Class, AtomicInteger> configIdIndexes = new ConcurrentHashMap<>();\n+    private static Map<String, AtomicInteger> configIdIndexes = new ConcurrentHashMap<>();\n     private static Set<Class<? extends AbstractConfig>> uniqueConfigTypes = new ConcurrentHashSet<>();\n@@ -737,8 +737,9 @@ private AbstractInterfaceConfig checkDuplicatedInterfaceConfig(AbstractInterface\n     }\n     public static <C extends AbstractConfig> String generateConfigId(C config) {\n-        int idx = configIdIndexes.computeIfAbsent(config.getClass(), clazz -> new AtomicInteger(0)).incrementAndGet();\n-        return getTagName(config.getClass()) + \"#\" + idx;\n+        String tagName = getTagName(config.getClass());\n+        int idx = configIdIndexes.computeIfAbsent(tagName, clazz -> new AtomicInteger(0)).incrementAndGet();\n+        return tagName + \"#\" + idx;\n     }\n     static <C extends AbstractConfig> String getId(C config) {",
    "output": "Fix Config id Override when both using API and Spring"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLAddress.java b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLAddress.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLAddress.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLAddress.java\n@@ -24,6 +24,8 @@\n import java.net.URLDecoder;\n import java.util.Objects;\n+import static org.apache.dubbo.common.constants.CommonConstants.PATH_SEPARATOR;\n+\n public class URLAddress implements Serializable {\n     private static final long serialVersionUID = -1985165475234910535L;\n@@ -168,7 +170,7 @@ public static URLAddress parse(String rawAddress, String defaultProtocol, boolea\n                 decodeStr = URLDecoder.decode(rawAddress, \"UTF-8\");\n             }\n-            boolean isPathAddress = !Character.isDigit(decodeStr.charAt(0));\n+            boolean isPathAddress = decodeStr.contains(PATH_SEPARATOR);\n             if (isPathAddress) {\n                 return createPathURLAddress(decodeStr, rawAddress, defaultProtocol);\n             }",
    "output": "Fix org.apache.dubbo.common.url.component.URLAddress#parse method to judge the isPathAddress problem #8285"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/ProviderURLMergeProcessor.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/ProviderURLMergeProcessor.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/ProviderURLMergeProcessor.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/ProviderURLMergeProcessor.java\n@@ -33,6 +33,8 @@ public interface ProviderURLMergeProcessor {\n      */\n     URL mergeUrl(URL remoteUrl, Map<String, String> localParametersMap);\n+    default Map<String, String> mergeLocalParams(Map<String, String> localMap) { return localMap; }\n+\n     default boolean accept(URL providerUrl, Map<String, String> localParametersMap) {\n         return true;\n     }\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n@@ -26,6 +26,7 @@\n import org.apache.dubbo.rpc.cluster.Directory;\n import org.apache.dubbo.rpc.cluster.Router;\n import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.support.ClusterUtils;\n import java.util.Collections;\n import java.util.List;\n@@ -73,18 +74,22 @@ public AbstractDirectory(URL url, RouterChain<T> routerChain, boolean isUrlFromR\n         this.url = url.removeAttribute(REFER_KEY).removeAttribute(MONITOR_KEY);\n-        Object referParams = url.getAttribute(REFER_KEY);\n-        if (referParams != null) {\n-            this.queryMap = (Map<String, String>) referParams;\n-            this.consumerUrl = (URL)url.getAttribute(CONSUMER_URL_KEY);\n+        Map<String, String> queryMap;\n+        Object referParams =  url.getAttribute(REFER_KEY);\n+        if (referParams instanceof Map) {\n+            queryMap = (Map<String, String>) referParams;\n+            this.consumerUrl = (URL) url.getAttribute(CONSUMER_URL_KEY);\n         } else {\n-            this.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));\n+            queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));\n         }\n+        // remove some local only parameters\n+        this.queryMap = ClusterUtils.mergeLocalParams(queryMap);\n+\n         if (consumerUrl == null) {\n             String host = StringUtils.isNotEmpty(queryMap.get(\"register.ip\")) ? queryMap.get(\"register.ip\") : this.url.getHost();\n             String path = queryMap.get(PATH_KEY);\n-            String consumedProtocol = this.queryMap.get(PROTOCOL_KEY) == null ? DUBBO : this.queryMap.get(PROTOCOL_KEY);\n+            String consumedProtocol = queryMap.get(PROTOCOL_KEY) == null ? DUBBO : queryMap.get(PROTOCOL_KEY);\n             URL consumerUrlFrom = this.url\n                     .setHost(host)\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java\n@@ -48,4 +48,18 @@ public static URL mergeUrl(URL remoteUrl, Map<String, String> localMap) {\n         return providerURLMergeProcessor.mergeUrl(remoteUrl, localMap);\n     }\n+    public static Map<String, String> mergeLocalParams(Map<String, String> localMap) {\n+        String ump = localMap.get(URL_MERGE_PROCESSOR_KEY);\n+        ProviderURLMergeProcessor providerURLMergeProcessor;\n+\n+        if (StringUtils.isNotEmpty(ump)) {\n+            providerURLMergeProcessor = ExtensionLoader.getExtensionLoader(ProviderURLMergeProcessor.class).getExtension(ump);\n+        } else {\n+            providerURLMergeProcessor = ExtensionLoader.getExtensionLoader(ProviderURLMergeProcessor.class).getExtension(\"default\");\n+        }\n+\n+        return providerURLMergeProcessor.mergeLocalParams(localMap);\n+\n+    }\n+\n }",
    "output": "Remove some local only parameters"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java\n@@ -275,6 +275,9 @@ public static class Endpoint {\n         Integer port;\n         String protocol;\n+        public Endpoint() {\n+        }\n+\n         public Endpoint(Integer port, String protocol) {\n             this.port = port;\n             this.protocol = protocol;",
    "output": "Add Endpoint default constructor."
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/telnet/support/TelnetHandlerAdapterTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/telnet/support/TelnetHandlerAdapterTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/telnet/support/TelnetHandlerAdapterTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/telnet/support/TelnetHandlerAdapterTest.java\n@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.remoting.telnet.support;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.remoting.Channel;\n+import org.apache.dubbo.remoting.RemotingException;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class TelnetHandlerAdapterTest {\n+\n+    @Test\n+    public void testTelnet() throws RemotingException {\n+\n+        Channel channel = Mockito.mock(Channel.class);\n+        Map<String, String> param = new HashMap<>();\n+        param.put(\"telnet\", \"status\");\n+        URL url = new URL(\"p1\", \"127.0.0.1\", 12345, \"path1\", param);\n+        Mockito.when(channel.getUrl()).thenReturn(url);\n+        TelnetHandlerAdapter telnetHandlerAdapter = new TelnetHandlerAdapter();\n+\n+        String message = \"--no-prompt status \";\n+        String expectedResult = \"OK\\r\\n\";\n+        Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));\n+\n+        message = \"--no-prompt status test\";\n+        expectedResult = \"Unsupported parameter test for status.\\r\\n\";\n+        Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));\n+\n+        message = \"--no-prompt test\";\n+        expectedResult = \"Unsupported command: test\\r\\n\";\n+        Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));\n+\n+        message = \"--no-prompt help\";\n+        expectedResult = \"Command: help disabled\\r\\n\";\n+        Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));\n+\n+        message = \"--no-prompt\";\n+        expectedResult = StringUtils.EMPTY_STRING;\n+        Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));\n+\n+        message = \"help\";\n+        expectedResult = \"Command: help disabled\\r\\ndubbo>\";\n+        Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));\n+    }\n+}",
    "output": "Add TelnetHandlerAdapterTest to branch 3.0"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n@@ -180,7 +180,7 @@ public void setRawRule(String rawRule) {\n     }\n     private MigrationRule parseRule(String rawRule) {\n-        MigrationRule tmpRule = rule;\n+        MigrationRule tmpRule = rule == null ? MigrationRule.INIT : rule;\n         if (INIT.equals(rawRule)) {\n             tmpRule = MigrationRule.INIT;\n         } else {",
    "output": "Fix NPE when parse migration rule error happen"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.common;\n+import org.apache.dubbo.common.utils.NetUtils;\n import org.junit.jupiter.api.Test;\n import java.util.Arrays;\n@@ -48,26 +49,28 @@ public void shouldAddParameter() {\n     @Test\n     public void shouldSet() {\n         URL url1 = URL.valueOf(\"dubbo://admin:hello1234@10.20.130.230:20880/context/path?version=1.0.0&application=morgan\");\n+        int port = NetUtils.getAvailablePort();\n         URL url2 = URLBuilder.from(url1)\n                 .setProtocol(\"rest\")\n                 .setUsername(\"newUsername\")\n                 .setPassword(\"newPassword\")\n                 .setHost(\"newHost\")\n                 .setPath(\"newContext\")\n-                .setPort(1234)\n+                .setPort(port)\n                 .build();\n         assertThat(url2.getProtocol(), equalTo(\"rest\"));\n         assertThat(url2.getUsername(), equalTo(\"newUsername\"));\n         assertThat(url2.getPassword(), equalTo(\"newPassword\"));\n         assertThat(url2.getHost(), equalTo(\"newHost\"));\n-        assertThat(url2.getPort(), equalTo(1234));\n+        assertThat(url2.getPort(), equalTo(port));\n         assertThat(url2.getPath(), equalTo(\"newContext\"));\n+        int port2 = NetUtils.getAvailablePort();\n         url2 = URLBuilder.from(url1)\n-                .setAddress(\"newHost2:2345\")\n+                .setAddress(\"newHost2:\"+ port2)\n                 .build();\n         assertThat(url2.getHost(), equalTo(\"newHost2\"));\n-        assertThat(url2.getPort(), equalTo(2345));\n+        assertThat(url2.getPort(), equalTo(port2));\n     }\n     @Test\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ProtocolConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ProtocolConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ProtocolConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ProtocolConfigTest.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.config;\n+import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n import org.apache.dubbo.config.context.ConfigManager;\n import org.junit.jupiter.api.AfterEach;\n@@ -30,9 +31,7 @@\n import java.util.Map;\n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.equalTo;\n-import static org.hamcrest.Matchers.hasEntry;\n-import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.*;\n public class ProtocolConfigTest {\n@@ -71,10 +70,11 @@ public void testHost() throws Exception {\n     @Test\n     public void testPort() throws Exception {\n         ProtocolConfig protocol = new ProtocolConfig();\n-        protocol.setPort(8080);\n+        int port = NetUtils.getAvailablePort();\n+        protocol.setPort(port);\n         Map<String, String> parameters = new HashMap<String, String>();\n         ProtocolConfig.appendParameters(parameters, protocol);\n-        assertThat(protocol.getPort(), equalTo(8080));\n+        assertThat(protocol.getPort(), equalTo(port));\n         assertThat(parameters.isEmpty(), is(true));\n     }\n@@ -228,10 +228,11 @@ public void testMetaData() {\n     @Test\n     public void testOverrideEmptyConfig() {\n+        int port = NetUtils.getAvailablePort();\n         //dubbo.protocol.name=rest\n-        //dubbo.protocol.port=1234\n+        //dubbo.protocol.port=port\n         SysProps.setProperty(\"dubbo.protocol.name\", \"rest\");\n-        SysProps.setProperty(\"dubbo.protocol.port\", \"1234\");\n+        SysProps.setProperty(\"dubbo.protocol.port\", String.valueOf(port));\n         try {\n             ProtocolConfig protocolConfig = new ProtocolConfig();\n@@ -242,14 +243,15 @@ public void testOverrideEmptyConfig() {\n                     .initialize();\n             Assertions.assertEquals(\"rest\", protocolConfig.getName());\n-            Assertions.assertEquals(1234, protocolConfig.getPort());\n+            Assertions.assertEquals(port, protocolConfig.getPort());\n         } finally {\n         }\n     }\n     @Test\n     public void testOverrideConfigByName() {\n-        SysProps.setProperty(\"dubbo.protocols.rest.port\", \"1234\");\n+        int port = NetUtils.getAvailablePort();\n+        SysProps.setProperty(\"dubbo.protocols.rest.port\", String.valueOf(port));\n         try {\n             ProtocolConfig protocolConfig = new ProtocolConfig();\n@@ -261,15 +263,16 @@ public void testOverrideConfigByName() {\n                     .initialize();\n             Assertions.assertEquals(\"rest\", protocolConfig.getName());\n-            Assertions.assertEquals(1234, protocolConfig.getPort());\n+            Assertions.assertEquals(port, protocolConfig.getPort());\n         } finally {\n         }\n     }\n     @Test\n     public void testOverrideConfigById() {\n+        int port = NetUtils.getAvailablePort();\n         SysProps.setProperty(\"dubbo.protocols.rest1.name\", \"rest\");\n-        SysProps.setProperty(\"dubbo.protocols.rest1.port\", \"1234\");\n+        SysProps.setProperty(\"dubbo.protocols.rest1.port\",  String.valueOf(port));\n         try {\n             ProtocolConfig protocolConfig = new ProtocolConfig();\n@@ -282,17 +285,19 @@ public void testOverrideConfigById() {\n                     .initialize();\n             Assertions.assertEquals(\"rest\", protocolConfig.getName());\n-            Assertions.assertEquals(1234, protocolConfig.getPort());\n+            Assertions.assertEquals(port, protocolConfig.getPort());\n         } finally {\n         }\n     }\n     @Test\n     public void testCreateConfigFromPropsWithId() {\n+        int port1 = NetUtils.getAvailablePort();\n+        int port2 = NetUtils.getAvailablePort();\n         SysProps.setProperty(\"dubbo.protocols.rest1.name\", \"rest\");\n-        SysProps.setProperty(\"dubbo.protocols.rest1.port\", \"1234\");\n+        SysProps.setProperty(\"dubbo.protocols.rest1.port\", String.valueOf(port1));\n         SysProps.setProperty(\"dubbo.protocol.name\", \"dubbo\"); // ignore\n-        SysProps.setProperty(\"dubbo.protocol.port\", \"2346\");\n+        SysProps.setProperty(\"dubbo.protocol.port\", String.valueOf(port2));\n         try {\n@@ -307,16 +312,18 @@ public void testCreateConfigFromPropsWithId() {\n             ProtocolConfig protocol = configManager.getProtocol(\"rest1\").get();\n             Assertions.assertEquals(\"rest\", protocol.getName());\n-            Assertions.assertEquals(1234, protocol.getPort());\n+            Assertions.assertEquals(port1, protocol.getPort());\n         } finally {\n         }\n     }\n     @Test\n     public void testCreateConfigFromPropsWithName() {\n-        SysProps.setProperty(\"dubbo.protocols.rest.port\", \"1234\");\n+        int port1 = NetUtils.getAvailablePort();\n+        int port2 = NetUtils.getAvailablePort();\n+        SysProps.setProperty(\"dubbo.protocols.rest.port\", String.valueOf(port1));\n         SysProps.setProperty(\"dubbo.protocol.name\", \"dubbo\"); // ignore\n-        SysProps.setProperty(\"dubbo.protocol.port\", \"2346\");\n+        SysProps.setProperty(\"dubbo.protocol.port\", String.valueOf(port2));\n         try {\n@@ -331,15 +338,16 @@ public void testCreateConfigFromPropsWithName() {\n             ProtocolConfig protocol = configManager.getProtocol(\"rest\").get();\n             Assertions.assertEquals(\"rest\", protocol.getName());\n-            Assertions.assertEquals(1234, protocol.getPort());\n+            Assertions.assertEquals(port1, protocol.getPort());\n         } finally {\n         }\n     }\n     @Test\n     public void testCreateDefaultConfigFromProps() {\n+        int port = NetUtils.getAvailablePort();\n         SysProps.setProperty(\"dubbo.protocol.name\", \"rest\");\n-        SysProps.setProperty(\"dubbo.protocol.port\", \"2346\");\n+        SysProps.setProperty(\"dubbo.protocol.port\", String.valueOf(port));\n         String protocolId = \"rest-protocol\";\n         SysProps.setProperty(\"dubbo.protocol.id\", protocolId); // Allow override config id from props\n@@ -355,7 +363,7 @@ public void testCreateDefaultConfigFromProps() {\n             ProtocolConfig protocol = configManager.getProtocol(\"rest\").get();\n             Assertions.assertEquals(\"rest\", protocol.getName());\n-            Assertions.assertEquals(2346, protocol.getPort());\n+            Assertions.assertEquals(port, protocol.getPort());\n             Assertions.assertEquals(protocolId, protocol.getId());\n             ProtocolConfig protocolConfig = configManager.getProtocol(protocolId).get();",
    "output": "Remove hard code about port in URLBuilderTest and ProtocolConfigTest"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ReferenceConfigCache.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ReferenceConfigCache.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ReferenceConfigCache.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ReferenceConfigCache.java\n@@ -107,16 +107,13 @@ public <T> T get(ReferenceConfigBase<T> referenceConfig) {\n         String key = generator.generateKey(referenceConfig);\n         Class<?> type = referenceConfig.getInterfaceClass();\n-        proxies.computeIfAbsent(type, _t -> new ConcurrentHashMap<>());\n+        ConcurrentMap<String, Object> proxiesOfType = proxies.computeIfAbsent(type, _t -> new ConcurrentHashMap<>());\n-        ConcurrentMap<String, Object> proxiesOfType = proxies.get(type);\n-        proxiesOfType.computeIfAbsent(key, _k -> {\n+        return (T) proxiesOfType.computeIfAbsent(key, _k -> {\n             Object proxy = referenceConfig.get();\n             referredReferences.put(key, referenceConfig);\n             return proxy;\n         });\n-\n-        return (T) proxiesOfType.get(key);\n     }\n     /**",
    "output": "Remove redundant 'get' action after 'computeIFAbsent',"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/descriptor/DescriptorService.java b/dubbo-common/src/test/java/org/apache/dubbo/descriptor/DescriptorService.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/descriptor/DescriptorService.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/descriptor/DescriptorService.java\n@@ -16,8 +16,17 @@\n  */\n package org.apache.dubbo.descriptor;\n+import org.apache.dubbo.proto.HelloReply;\n+\n public interface DescriptorService {\n     void noParameterMethod();\n+    /**\n+     * only for test.\n+     *\n+     * @param reply\n+     * @return\n+     */\n+    HelloReply sayHello(HelloReply reply);\n }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/descriptor/MethodDescriptorTest.java b/dubbo-common/src/test/java/org/apache/dubbo/descriptor/MethodDescriptorTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/descriptor/MethodDescriptorTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/descriptor/MethodDescriptorTest.java\n@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.descriptor;\n+\n+import org.apache.dubbo.proto.HelloReply;\n+import org.apache.dubbo.rpc.model.MethodDescriptor;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Method;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class MethodDescriptorTest {\n+    @Test\n+    public void testMethodWithNoParameters() throws Exception {\n+        Method method = DescriptorService.class.getMethod(\"noParameterMethod\");\n+        MethodDescriptor descriptor = new MethodDescriptor(method);\n+        assertEquals(\"\", descriptor.getParamDesc());\n+        Assertions.assertEquals(0, descriptor.getParameterClasses().length);\n+    }\n+\n+    @Test\n+    public void testIsStream() throws NoSuchMethodException {\n+        Method method = DescriptorService.class.getMethod(\"noParameterMethod\");\n+        MethodDescriptor descriptor = new MethodDescriptor(method);\n+        Assertions.assertFalse(descriptor.isStream());\n+\n+        method = DescriptorService.class.getMethod(\"sayHello\", HelloReply.class);\n+        descriptor = new MethodDescriptor(method);\n+        Assertions.assertFalse(descriptor.isStream());\n+    }\n+\n+    @Test\n+    public void testIsUnary() throws NoSuchMethodException {\n+        Method method = DescriptorService.class.getMethod(\"noParameterMethod\");\n+        MethodDescriptor descriptor = new MethodDescriptor(method);\n+        Assertions.assertTrue(descriptor.isUnary());\n+\n+        method = DescriptorService.class.getMethod(\"sayHello\", HelloReply.class);\n+        descriptor = new MethodDescriptor(method);\n+        Assertions.assertTrue(descriptor.isUnary());\n+    }\n+\n+    @Test\n+    public void testIsNeedWrap() throws NoSuchMethodException {\n+        Method method = DescriptorService.class.getMethod(\"noParameterMethod\");\n+        MethodDescriptor descriptor = new MethodDescriptor(method);\n+        Assertions.assertTrue(descriptor.isNeedWrap());\n+\n+        method = DescriptorService.class.getMethod(\"sayHello\", HelloReply.class);\n+        descriptor = new MethodDescriptor(method);\n+        Assertions.assertFalse(descriptor.isNeedWrap());\n+    }\n+}\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/proto/HelloReply.java b/dubbo-common/src/test/java/org/apache/dubbo/proto/HelloReply.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/proto/HelloReply.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/proto/HelloReply.java\n@@ -14,23 +14,36 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.dubbo.descriptor;\n-import org.apache.dubbo.rpc.model.MethodDescriptor;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n+package org.apache.dubbo.proto;\n-import java.lang.reflect.Method;\n+import com.google.protobuf.Message;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n+public final class HelloReply extends com.google.protobuf.GeneratedMessageV3 {\n-public class MethodDescritorTest {\n-    @Test\n-    public void testMethodWithNoParameters() throws Exception {\n-        Method method = DescriptorService.class.getMethod(\"noParameterMethod\");\n-        MethodDescriptor descriptor = new MethodDescriptor(method);\n-        assertEquals(\"\", descriptor.getParamDesc());\n-        Assertions.assertEquals(0, descriptor.getParameterClasses().length);\n+    @Override\n+    protected FieldAccessorTable internalGetFieldAccessorTable() {\n+        return null;\n+    }\n+\n+    @Override\n+    protected Message.Builder newBuilderForType(BuilderParent builderParent) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Message.Builder newBuilderForType() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Message.Builder toBuilder() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Message getDefaultInstanceForType() {\n+        return null;\n     }\n }",
    "output": "Add test case for MethodDescriptor * add test case for MethodDescriptor * add test scope"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n@@ -32,6 +32,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.CONFIG_ENABLE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;\n+import static org.apache.dubbo.common.utils.PojoUtils.updatePropertyIfAbsent;\n import static org.apache.dubbo.config.Constants.CONFIG_APP_CONFIGFILE_KEY;\n import static org.apache.dubbo.config.Constants.ZOOKEEPER_PROTOCOL;\n@@ -170,10 +171,12 @@ public void setAddress(String address) {\n         if (address != null) {\n             try {\n                 URL url = URL.valueOf(address);\n-                setUsername(url.getUsername());\n-                setPassword(url.getPassword());\n-                updateProtocolIfAbsent(url.getProtocol());\n-                updatePortIfAbsent(url.getPort());\n+\n+                updatePropertyIfAbsent(this::getUsername, this::setUsername, url.getUsername());\n+                updatePropertyIfAbsent(this::getPassword, this::setPassword, url.getPassword());\n+                updatePropertyIfAbsent(this::getProtocol, this::setProtocol, url.getProtocol());\n+                updatePropertyIfAbsent(this::getPort, this::setPort, url.getPort());\n+\n                 updateParameters(url.getParameters());\n             } catch (Exception ignored) {\n             }\n@@ -291,18 +294,6 @@ public boolean isValid() {\n         return address.contains(\"://\") || StringUtils.isNotEmpty(protocol);\n     }\n-    protected void updatePortIfAbsent(Integer value) {\n-        if (value != null && value > 0 && port == null) {\n-            this.port = value;\n-        }\n-    }\n-\n-    protected void updateProtocolIfAbsent(String value) {\n-        if (StringUtils.isNotEmpty(value) && StringUtils.isEmpty(protocol)) {\n-            this.protocol = value;\n-        }\n-    }\n-\n     public void updateParameters(Map<String, String> parameters) {\n         if (CollectionUtils.isEmptyMap(parameters)) {\n             return;\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java\n@@ -285,4 +285,20 @@ public void testAttributes() {\n         Assertions.assertEquals(null, attributes.get(\"refreshed\"));\n     }\n+\n+    @Test\n+    public void testSetAddress() {\n+        String address = \"zookeeper://127.0.0.1:2181\";\n+        ConfigCenterConfig cc = new ConfigCenterConfig();\n+        cc.setUsername(\"user123\"); // set username first\n+        cc.setPassword(\"pass123\");\n+        cc.setAddress(address); // set address last, expect did not override username/password\n+\n+        Assertions.assertEquals(address, cc.getAddress());\n+        Assertions.assertEquals(\"zookeeper\", cc.getProtocol());\n+        Assertions.assertEquals(2181, cc.getPort());\n+        Assertions.assertEquals(\"user123\", cc.getUsername());\n+        Assertions.assertEquals(\"pass123\", cc.getPassword());\n+\n+    }\n }",
    "output": "Fix ConfigCenterConfig.setAddress * fix ConfigCenterConfig.setAddress #8237 * add tests"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n@@ -44,7 +44,10 @@\n import io.netty.util.concurrent.Promise;\n import java.net.InetSocketAddress;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -64,6 +67,8 @@ public class Connection extends AbstractReferenceCounted implements ReferenceCou\n     private final AtomicBoolean closed = new AtomicBoolean(false);\n     private final AtomicReference<Channel> channel = new AtomicReference<>();\n     private final ChannelFuture initPromise;\n+    private volatile CompletableFuture<Object> connectedFuture = new CompletableFuture<>();\n+    private static final Object CONNECTED_OBJECT = new Object();\n     private final Bootstrap bootstrap;\n     private final ConnectionListener connectionListener = new ConnectionListener();\n@@ -90,11 +95,11 @@ public Promise<Void> getCloseFuture() {\n     private Bootstrap create() {\n         final Bootstrap bootstrap = new Bootstrap();\n         bootstrap.group(NettyEventLoopFactory.NIO_EVENT_LOOP_GROUP)\n-                .option(ChannelOption.SO_KEEPALIVE, true)\n-                .option(ChannelOption.TCP_NODELAY, true)\n-                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n-                .remoteAddress(getConnectAddress())\n-                .channel(socketChannelClass());\n+            .option(ChannelOption.SO_KEEPALIVE, true)\n+            .option(ChannelOption.TCP_NODELAY, true)\n+            .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n+            .remoteAddress(getConnectAddress())\n+            .channel(socketChannelClass());\n         final ConnectionHandler connectionHandler = new ConnectionHandler(this);\n         bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectTimeout);\n@@ -136,7 +141,8 @@ public Channel getChannel() {\n     @Override\n     public String toString() {\n-        return super.toString() + \" (Ref=\" + ReferenceCountUtil.refCnt(this) + \",local=\" + (getChannel() == null ? null : getChannel().localAddress()) + \",remote=\" + getRemote();\n+        return super.toString() + \" (Ref=\" + ReferenceCountUtil.refCnt(this) + \",local=\" +\n+            (getChannel() == null ? null : getChannel().localAddress()) + \",remote=\" + getRemote();\n     }\n     public void onGoaway(Channel channel) {\n@@ -145,18 +151,21 @@ public void onGoaway(Channel channel) {\n                 logger.info(String.format(\"%s goaway\", this));\n             }\n         }\n+        this.connectedFuture = new CompletableFuture<>();\n     }\n     public void onConnected(Channel channel) {\n         this.channel.set(channel);\n+        // This indicates that the connection is available.\n+        this.connectedFuture.complete(CONNECTED_OBJECT);\n         channel.attr(CONNECTION).set(this);\n         if (logger.isInfoEnabled()) {\n             logger.info(String.format(\"%s connected \", this));\n         }\n     }\n-    public void connectSync() {\n-        this.initPromise.awaitUninterruptibly(this.connectTimeout);\n+    public void connectSync() throws InterruptedException, ExecutionException, TimeoutException {\n+        this.connectedFuture.get(this.connectTimeout, TimeUnit.MILLISECONDS);\n     }\n     public boolean isAvailable() {\n@@ -171,7 +180,8 @@ public boolean isClosed() {\n     //TODO replace channelFuture with intermediate future\n     public ChannelFuture write(Object request) throws RemotingException {\n         if (!isAvailable()) {\n-            throw new RemotingException(null, null, \"Failed to send request \" + request + \", cause: The channel to \" + remote + \" is closed!\");\n+            throw new RemotingException(null, null,\n+                \"Failed to send request \" + request + \", cause: The channel to \" + remote + \" is closed!\");\n         }\n         return getChannel().writeAndFlush(request);\n     }\n@@ -197,6 +207,7 @@ public void close() {\n             current.close();\n         }\n         this.channel.set(null);\n+        this.connectedFuture = new CompletableFuture<>();\n     }\n     @Override\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/ConnectionTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/ConnectionTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/ConnectionTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/ConnectionTest.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.utils.NetUtils;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n@@ -55,4 +56,19 @@ public void testRefCnt2() throws InterruptedException {\n         latch.await();\n         Assertions.assertEquals(0, latch.getCount());\n     }\n+\n+    @Test\n+    public void connectSyncTest() throws Exception {\n+        int port = NetUtils.getAvailablePort();\n+        URL url = URL.valueOf(\"empty://127.0.0.1:\" + port + \"?foo=bar\");\n+        PortUnificationServer server = new PortUnificationServer(url);\n+        server.bind();\n+\n+        Connection connection = new Connection(url);\n+        connection.connectSync();\n+        Assertions.assertTrue(connection.isAvailable());\n+\n+        connection.close();\n+        Assertions.assertFalse(connection.isAvailable());\n+    }\n }",
    "output": "Fix the problem that in the Triple protocol, an error will be reported immediately when the service is exposed * Fix the problem that in the Triple protocol, an error will be reported immediately when the service is exposed * Wait for the channel to become available * use CompletableFuture to optimize code * use const object. * remove initPromise.awaitUninterruptibly * add test case for connectSync method. * When the channel is unavailable, reset the connectedFuture"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TriplePathResolverTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TriplePathResolverTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TriplePathResolverTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TriplePathResolverTest.java\n@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.rpc.protocol.tri;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.Result;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public class TriplePathResolverTest {\n+\n+    private static final PathResolver PATH_RESOLVER = ExtensionLoader.getExtensionLoader(PathResolver.class)\n+        .getDefaultExtension();\n+\n+    private static Invoker<Object> INVOKER = new Invoker<Object>() {\n+        @Override\n+        public URL getUrl() {\n+            return null;\n+        }\n+\n+        @Override\n+        public boolean isAvailable() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void destroy() {\n+\n+        }\n+\n+        @Override\n+        public Class<Object> getInterface() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Result invoke(Invocation invocation) throws RpcException {\n+            return null;\n+        }\n+    };\n+\n+    @BeforeEach\n+    public void init() {\n+\n+        PATH_RESOLVER.add(\"/abc\", INVOKER);\n+    }\n+\n+    @AfterEach\n+    public void destroy() {\n+        PATH_RESOLVER.destroy();\n+    }\n+\n+    @Test\n+    public void testResolve() {\n+        Assertions.assertEquals(INVOKER, getInvokerByPath(\"/abc\"));\n+    }\n+\n+    @Test\n+    public void testRemove() {\n+        Assertions.assertEquals(INVOKER, getInvokerByPath(\"/abc\"));\n+        PATH_RESOLVER.remove(\"/abc\");\n+        Assertions.assertNull(getInvokerByPath(\"/abc\"));\n+    }\n+\n+    @Test\n+    public void testDestroy() {\n+        Assertions.assertEquals(INVOKER, getInvokerByPath(\"/abc\"));\n+        {\n+            PATH_RESOLVER.add(\"/bcd\", INVOKER);\n+            Assertions.assertEquals(INVOKER, getInvokerByPath(\"/bcd\"));\n+        }\n+        PATH_RESOLVER.destroy();\n+        Assertions.assertNull(getInvokerByPath(\"/abc\"));\n+        Assertions.assertNull(getInvokerByPath(\"/bcd\"));\n+    }\n+\n+    private Invoker getInvokerByPath(String path) {\n+        return PATH_RESOLVER.resolve(path);\n+    }\n+}",
    "output": "Add test case for TriplePathResolver"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -678,7 +678,7 @@ public synchronized void doOverrideIfNecessary() {\n             //The current, may have been merged many times\n             URL currentUrl = exporter.getInvoker().getUrl();\n             //Merged with this configuration\n-            URL newUrl = getConfigedInvokerUrl(configurators, currentUrl);\n+            URL newUrl = getConfigedInvokerUrl(configurators, originUrl);\n             newUrl = getConfigedInvokerUrl(providerConfigurationListener.getConfigurators(), newUrl);\n             newUrl = getConfigedInvokerUrl(serviceConfigurationListeners.get(originUrl.getServiceKey())\n                     .getConfigurators(), newUrl);",
    "output": "Fix issue-8042"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n@@ -1084,7 +1084,6 @@ private void initMetadataService() {\n     public DubboBootstrap start() {\n         if (started.compareAndSet(false, true)) {\n             startup.set(false);\n-            initialized.set(false);\n             shutdown.set(false);\n             awaited.set(false);\n@@ -1289,17 +1288,21 @@ private void exportServices() {\n                 ExecutorService executor = executorRepository.getExportReferExecutor();\n                 CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n                     try {\n-                        sc.export();\n-                        exportedServices.add(sc);\n+                        if (!sc.isExported()) {\n+                            sc.export();\n+                            exportedServices.add(sc);\n+                        }\n                     } catch (Throwable t) {\n                         logger.error(\"export async catch error : \" + t.getMessage(), t);\n                     }\n                 }, executor);\n                 asyncExportingFutures.add(future);\n             } else {\n-                sc.export();\n-                exportedServices.add(sc);\n+                if (!sc.isExported()) {\n+                    sc.export();\n+                    exportedServices.add(sc);\n+                }\n             }\n         }\n     }",
    "output": "Fix re-start override dynamic config"
  },
  {
    "input": "diff --git a/dubbo-demo/dubbo-demo-api/dubbo-demo-api-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java b/dubbo-demo/dubbo-demo-api/dubbo-demo-api-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java\n--- a/dubbo-demo/dubbo-demo-api/dubbo-demo-api-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java\n+++ b/dubbo-demo/dubbo-demo-api/dubbo-demo-api-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.demo.consumer;\n import org.apache.dubbo.config.ApplicationConfig;\n+import org.apache.dubbo.config.MetadataReportConfig;\n import org.apache.dubbo.config.ReferenceConfig;\n import org.apache.dubbo.config.RegistryConfig;\n import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n@@ -63,6 +64,7 @@ private static void runWithRefer() {\n         ReferenceConfig<DemoService> reference = new ReferenceConfig<>();\n         reference.setApplication(new ApplicationConfig(\"dubbo-demo-api-consumer\"));\n         reference.setRegistry(new RegistryConfig(\"zookeeper://127.0.0.1:2181\"));\n+        reference.setMetadataReportConfig(new MetadataReportConfig(\"zookeeper://127.0.0.1:2181\"));\n         reference.setInterface(DemoService.class);\n         DemoService service = reference.get();\n         String message = service.sayHello(\"dubbo\");\ndiff --git a/dubbo-demo/dubbo-demo-api/dubbo-demo-api-provider/src/main/java/org/apache/dubbo/demo/provider/Application.java b/dubbo-demo/dubbo-demo-api/dubbo-demo-api-provider/src/main/java/org/apache/dubbo/demo/provider/Application.java\n--- a/dubbo-demo/dubbo-demo-api/dubbo-demo-api-provider/src/main/java/org/apache/dubbo/demo/provider/Application.java\n+++ b/dubbo-demo/dubbo-demo-api/dubbo-demo-api-provider/src/main/java/org/apache/dubbo/demo/provider/Application.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.demo.provider;\n import org.apache.dubbo.config.ApplicationConfig;\n+import org.apache.dubbo.config.MetadataReportConfig;\n import org.apache.dubbo.config.RegistryConfig;\n import org.apache.dubbo.config.ServiceConfig;\n import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n@@ -56,6 +57,7 @@ private static void startWithExport() throws InterruptedException {\n         service.setRef(new DemoServiceImpl());\n         service.setApplication(new ApplicationConfig(\"dubbo-demo-api-provider\"));\n         service.setRegistry(new RegistryConfig(\"zookeeper://127.0.0.1:2181\"));\n+        service.setMetadataReportConfig(new MetadataReportConfig(\"zookeeper://127.0.0.1:2181\"));\n         service.export();\n         System.out.println(\"dubbo service started\");\ndiff --git a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiConsumer.java b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiConsumer.java\n--- a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiConsumer.java\n+++ b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiConsumer.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.config.ApplicationConfig;\n import org.apache.dubbo.config.ReferenceConfig;\n import org.apache.dubbo.config.RegistryConfig;\n+import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n import org.apache.dubbo.demo.GreeterService;\n import org.apache.dubbo.demo.hello.HelloReply;\n import org.apache.dubbo.demo.hello.HelloRequest;\n@@ -35,8 +36,13 @@ public static void main(String[] args) throws InterruptedException, IOException\n         referenceConfig.setProtocol(CommonConstants.TRIPLE);\n         referenceConfig.setLazy(true);\n         referenceConfig.setTimeout(100000);\n-        referenceConfig.setApplication(new ApplicationConfig(\"dubbo-demo-triple-api-consumer\"));\n-        referenceConfig.setRegistry(new RegistryConfig(\"zookeeper://127.0.0.1:2181\"));\n+\n+        DubboBootstrap bootstrap = DubboBootstrap.getInstance();\n+        bootstrap.application(new ApplicationConfig(\"dubbo-demo-triple-api-consumer\"))\n+                .registry(new RegistryConfig(\"zookeeper://127.0.0.1:2181\"))\n+                .reference(referenceConfig)\n+                .start();\n+\n         GreeterService greeterService = referenceConfig.get();\n         System.out.println(\"dubbo referenceConfig started\");\n         try {\ndiff --git a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiWrapperConsumer.java b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiWrapperConsumer.java\n--- a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiWrapperConsumer.java\n+++ b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/consumer/ApiWrapperConsumer.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.config.ApplicationConfig;\n import org.apache.dubbo.config.ReferenceConfig;\n import org.apache.dubbo.config.RegistryConfig;\n+import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n import org.apache.dubbo.demo.GreeterWrapperService;\n import java.io.IOException;\n@@ -30,8 +31,13 @@ public static void main(String[] args) throws IOException {\n         referenceConfig.setCheck(false);\n         referenceConfig.setProtocol(\"tri\");\n         referenceConfig.setLazy(true);\n-        referenceConfig.setApplication(new ApplicationConfig(\"dubbo-demo-triple-api-wrapper-consumer\"));\n-        referenceConfig.setRegistry(new RegistryConfig(\"zookeeper://127.0.0.1:2181\"));\n+\n+        DubboBootstrap bootstrap = DubboBootstrap.getInstance();\n+        bootstrap.application(new ApplicationConfig(\"dubbo-demo-triple-api-wrapper-consumer\"))\n+                .registry(new RegistryConfig(\"zookeeper://127.0.0.1:2181\"))\n+                .reference(referenceConfig)\n+                .start();\n+\n         final GreeterWrapperService greeterWrapperService = referenceConfig.get();\n         System.out.println(\"dubbo referenceConfig started\");\n         long st = System.currentTimeMillis();\ndiff --git a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/provider/ApiProvider.java b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/provider/ApiProvider.java\n--- a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/provider/ApiProvider.java\n+++ b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/provider/ApiProvider.java\n@@ -21,21 +21,22 @@\n import org.apache.dubbo.config.ProtocolConfig;\n import org.apache.dubbo.config.RegistryConfig;\n import org.apache.dubbo.config.ServiceConfig;\n+import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n import org.apache.dubbo.demo.GreeterService;\n import org.apache.dubbo.demo.GreeterServiceImpl;\n-import java.util.concurrent.CountDownLatch;\n-\n public class ApiProvider {\n     public static void main(String[] args) throws InterruptedException {\n         ServiceConfig<GreeterService> serviceConfig = new ServiceConfig<>();\n         serviceConfig.setInterface(GreeterService.class);\n         serviceConfig.setRef(new GreeterServiceImpl());\n-        serviceConfig.setProtocol(new ProtocolConfig(CommonConstants.TRIPLE, 50051));\n-        serviceConfig.setApplication(new ApplicationConfig(\"dubbo-demo-triple-api-provider\"));\n-        serviceConfig.setRegistry(new RegistryConfig(\"zookeeper://127.0.0.1:2181\"));\n-        serviceConfig.export();\n-        System.out.println(\"dubbo service started\");\n-        new CountDownLatch(1).await();\n+\n+        DubboBootstrap bootstrap = DubboBootstrap.getInstance();\n+        bootstrap.application(new ApplicationConfig(\"dubbo-demo-triple-api-provider\"))\n+                .registry(new RegistryConfig(\"zookeeper://127.0.0.1:2181\"))\n+                .protocol(new ProtocolConfig(CommonConstants.TRIPLE, 50051))\n+                .service(serviceConfig)\n+                .start()\n+                .await();\n     }\n }\ndiff --git a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/provider/ApiWrapperProvider.java b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/provider/ApiWrapperProvider.java\n--- a/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/provider/ApiWrapperProvider.java\n+++ b/dubbo-demo/dubbo-demo-triple/src/main/java/org/apache/dubbo/demo/provider/ApiWrapperProvider.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.config.ProtocolConfig;\n import org.apache.dubbo.config.RegistryConfig;\n import org.apache.dubbo.config.ServiceConfig;\n+import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n import org.apache.dubbo.demo.GreeterWrapperService;\n import org.apache.dubbo.demo.GreeterWrapperServiceImpl;\n@@ -31,11 +32,13 @@ public static void main(String[] args) throws IOException {\n         ServiceConfig<GreeterWrapperService> serviceConfig = new ServiceConfig<>();\n         serviceConfig.setInterface(GreeterWrapperService.class);\n         serviceConfig.setRef(new GreeterWrapperServiceImpl());\n-        serviceConfig.setProtocol(new ProtocolConfig(CommonConstants.TRIPLE, 50051));\n-        serviceConfig.setApplication(new ApplicationConfig(\"dubbo-demo-triple-api-wrapper-provider\"));\n-        serviceConfig.setRegistry(new RegistryConfig(\"zookeeper://127.0.0.1:2181\"));\n-        serviceConfig.export();\n-        System.out.println(\"dubbo service started\");\n-        System.in.read();\n+\n+        DubboBootstrap bootstrap = DubboBootstrap.getInstance();\n+        bootstrap.application(new ApplicationConfig(\"dubbo-demo-triple-api-wrapper-provider\"))\n+                .registry(new RegistryConfig(\"zookeeper://127.0.0.1:2181\"))\n+                .protocol(new ProtocolConfig(CommonConstants.TRIPLE, 50051))\n+                .service(serviceConfig)\n+                .start()\n+                .await();\n     }\n }",
    "output": "Use new code model in dubbo-demo-triple"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/MultiplexProtocolConnectionManagerTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/MultiplexProtocolConnectionManagerTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/MultiplexProtocolConnectionManagerTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/MultiplexProtocolConnectionManagerTest.java\n@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.remoting.api;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.remoting.RemotingException;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Field;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+public class MultiplexProtocolConnectionManagerTest {\n+    private ConnectionManager connectionManager = ExtensionLoader.getExtensionLoader(ConnectionManager.class).getExtension(\"multiple\");\n+\n+    @Test\n+    public void testConnect() throws Exception {\n+        URL url = URL.valueOf(\"empty://127.0.0.1:8080?foo=bar\");\n+        Connection connect = connectionManager.connect(url);\n+        Assertions.assertNotNull(connect);\n+        Field protocolsField = connectionManager.getClass().getDeclaredField(\"protocols\");\n+        protocolsField.setAccessible(true);\n+        Map protocolMap = (Map) protocolsField.get(connectionManager);\n+        Assertions.assertNotNull(protocolMap.get(url.getProtocol()));\n+        connect.close();\n+    }\n+\n+    @Test\n+    public void testForEachConnection() throws RemotingException {\n+        {\n+            URL url = URL.valueOf(\"empty://127.0.0.1:8080?foo=bar\");\n+            Connection connect = connectionManager.connect(url);\n+        }\n+        {\n+            URL url = URL.valueOf(\"tri://127.0.0.1:8080?foo=bar\");\n+            Connection connect = connectionManager.connect(url);\n+        }\n+\n+        Consumer<Connection> consumer = new Consumer<Connection>() {\n+            @Override\n+            public void accept(Connection connection) {\n+                try {\n+                    Assertions.assertEquals(\"empty\", connection.getUrl().getProtocol());\n+                } catch (Exception e) {\n+                    Assertions.assertEquals(\"tri\", connection.getUrl().getProtocol());\n+                }\n+\n+            }\n+        };\n+\n+        connectionManager.forEachConnection(consumer);\n+    }\n+\n+}\n+\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/SingleProtocolConnectionManagerTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/SingleProtocolConnectionManagerTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/SingleProtocolConnectionManagerTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/SingleProtocolConnectionManagerTest.java\n@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.remoting.api;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.remoting.RemotingException;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Field;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+public class SingleProtocolConnectionManagerTest {\n+\n+    private ConnectionManager connectionManager = ExtensionLoader.getExtensionLoader(ConnectionManager.class).getExtension(\"single\");\n+\n+    @Test\n+    public void testConnect() throws Exception {\n+        URL url = URL.valueOf(\"empty://127.0.0.1:8080?foo=bar\");\n+        Connection connect = connectionManager.connect(url);\n+        Assertions.assertNotNull(connect);\n+        Field protocolsField = connectionManager.getClass().getDeclaredField(\"connections\");\n+        protocolsField.setAccessible(true);\n+        Map protocolMap = (Map) protocolsField.get(connectionManager);\n+        Assertions.assertNotNull(protocolMap.get(url.getAddress()));\n+        connect.close();\n+    }\n+\n+    @Test\n+    public void testForEachConnection() throws RemotingException {\n+        URL url = URL.valueOf(\"empty://127.0.0.1:8080?foo=bar\");\n+        Connection connect = connectionManager.connect(url);\n+\n+        {\n+            Consumer<Connection> consumer1 = new Consumer<Connection>() {\n+                @Override\n+                public void accept(Connection connection) {\n+                    Assertions.assertEquals( \"empty\", connection.getUrl().getProtocol());\n+                }\n+            };\n+\n+            connectionManager.forEachConnection(consumer1);\n+        }\n+\n+        {\n+            Consumer<Connection> consumer2 = new Consumer<Connection>() {\n+                @Override\n+                public void accept(Connection connection) {\n+                    Assertions.assertNotEquals( \"not-empty\", connection.getUrl().getProtocol());\n+                }\n+            };\n+\n+            connectionManager.forEachConnection(consumer2);\n+        }\n+\n+    }\n+}",
    "output": "Add test case for MultiplexProtocolConnectionManager"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocolTest.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocolTest.java\n@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.rpc.protocol.tri;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.rpc.Protocol;\n+import org.apache.dubbo.rpc.ProxyFactory;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.ServiceDescriptor;\n+import org.apache.dubbo.rpc.model.ServiceMetadata;\n+import org.apache.dubbo.rpc.protocol.tri.support.IGreeter;\n+import org.apache.dubbo.rpc.protocol.tri.support.IGreeterImpl;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+\n+public class TripleProtocolTest {\n+    private Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n+    private ProxyFactory proxy = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n+\n+    @Test\n+    public void testDemoProtocol() throws Exception {\n+        IGreeter serviceImpl = new IGreeterImpl();\n+\n+        int availablePort = NetUtils.getAvailablePort();\n+\n+        URL url = URL.valueOf(\"tri://127.0.0.1:\" + availablePort + \"/\" + IGreeter.class.getName());\n+\n+        ServiceDescriptor serviceDescriptor = ApplicationModel.getServiceRepository().registerService(IGreeter.class);\n+        ApplicationModel.getServiceRepository().registerProvider(\n+            url.getServiceKey(),\n+            serviceImpl,\n+            serviceDescriptor,\n+            null,\n+            new ServiceMetadata()\n+        );\n+\n+        protocol.export(proxy.getInvoker(serviceImpl, IGreeter.class, url));\n+        serviceImpl = proxy.getProxy(protocol.refer(IGreeter.class, url));\n+         Thread.sleep(1000);\n+        Assertions.assertEquals(\"hello world\", serviceImpl.echo(\"hello world\"));\n+\n+        // resource recycle.\n+        ApplicationModel.getServiceRepository().destroy();\n+    }\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/support/IGreeter.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/support/IGreeter.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/support/IGreeter.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/support/IGreeter.java\n@@ -0,0 +1,26 @@\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.apache.dubbo.rpc.protocol.tri.support;\n+\n+public interface IGreeter {\n+    /**\n+     * Use request to respond\n+     */\n+    String echo(String request);\n+\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/support/IGreeterImpl.java b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/support/IGreeterImpl.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/support/IGreeterImpl.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/support/IGreeterImpl.java\n@@ -0,0 +1,26 @@\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.apache.dubbo.rpc.protocol.tri.support;\n+\n+public class IGreeterImpl implements IGreeter {\n+\n+    @Override\n+    public String echo(String request) {\n+        return request;\n+    }\n+}",
    "output": "Add test case for TripleProtocol * add test case for TripleProtocol * remove author tag"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n@@ -308,26 +308,34 @@ protected Semaphore getSemaphore() {\n     private static class RemovalTask implements Runnable {\n         @Override\n         public void run() {\n-            logger.info(\"Clearing cached URLs, size \" + waitForRemove.size());\n-            Iterator<Map.Entry<ServiceAddressURL, Long>> it = waitForRemove.entrySet().iterator();\n-            while (it.hasNext()) {\n-                Map.Entry<ServiceAddressURL, Long> entry = it.next();\n-                ServiceAddressURL removeURL = entry.getKey();\n-                long removeTime = entry.getValue();\n-                long current = System.currentTimeMillis();\n-                if (current - removeTime >= cacheClearWaitingThresholdInMillis) {\n-                    URLAddress urlAddress = removeURL.getUrlAddress();\n-                    URLParam urlParam = removeURL.getUrlParam();\n-                    if (current - urlAddress.getTimestamp() >= cacheClearWaitingThresholdInMillis) {\n-                        stringAddress.remove(urlAddress.getRawAddress());\n-                    }\n-                    if (current - urlParam.getTimestamp() >= cacheClearWaitingThresholdInMillis) {\n-                        stringParam.remove(urlParam.getRawParam());\n+            logger.info(\"Clearing cached URLs, waiting to clear size \" + waitForRemove.size());\n+            int clearCount = 0;\n+            try {\n+                Iterator<Map.Entry<ServiceAddressURL, Long>> it = waitForRemove.entrySet().iterator();\n+                while (it.hasNext()) {\n+                    Map.Entry<ServiceAddressURL, Long> entry = it.next();\n+                    ServiceAddressURL removeURL = entry.getKey();\n+                    long removeTime = entry.getValue();\n+                    long current = System.currentTimeMillis();\n+                    if (current - removeTime >= cacheClearWaitingThresholdInMillis) {\n+                        URLAddress urlAddress = removeURL.getUrlAddress();\n+                        URLParam urlParam = removeURL.getUrlParam();\n+                        if (current - urlAddress.getTimestamp() >= cacheClearWaitingThresholdInMillis) {\n+                            stringAddress.remove(urlAddress.getRawAddress());\n+                        }\n+                        if (current - urlParam.getTimestamp() >= cacheClearWaitingThresholdInMillis) {\n+                            stringParam.remove(urlParam.getRawParam());\n+                        }\n+                        it.remove();\n+                        clearCount++;\n                     }\n-                    it.remove();\n                 }\n+            } catch (Throwable t) {\n+                logger.error(\"Error occurred when clearing cached URLs\", t);\n+            } finally {\n+                semaphore.release();\n             }\n-            semaphore.release();\n+            logger.info(\"Clear cached URLs, size \" + clearCount);\n             if (CollectionUtils.isNotEmptyMap(waitForRemove)) {\n                 // move to next schedule",
    "output": "Add exception catch for RemovalTask, ensure semaphore release"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -237,7 +237,8 @@ public synchronized void export() {\n         }\n     }\n-    public void exported() {\n+    protected void exported() {\n+        exported = true;\n         List<URL> exportedURLs = this.getExportedUrls();\n         exportedURLs.forEach(url -> {\n             ServiceNameMapping serviceNameMapping = ServiceNameMapping.getDefaultExtension();\n@@ -330,7 +331,6 @@ protected synchronized void doExport() {\n         if (exported) {\n             return;\n         }\n-        exported = true;\n         if (StringUtils.isEmpty(path)) {\n             path = interfaceName;\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n@@ -109,7 +109,7 @@ public String getBeanName() {\n      * @since 2.6.5\n      */\n     @Override\n-    public void exported() {\n+    protected void exported() {\n         super.exported();\n         // Publish ServiceBeanExportedEvent\n         publishExportEvent();",
    "output": "Improve service exported logic"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n@@ -357,7 +357,8 @@ public void testServiceListener() {\n         service.export();\n         Map<String, ServiceConfig> exportedServices = mockServiceListener.getExportedServices();\n-        assertEquals(1, exportedServices.size());\n+        // MetadataService, DemoService\n+        assertEquals(2, exportedServices.size());\n         ServiceConfig serviceConfig = exportedServices.get(service.getUniqueServiceName());\n         assertSame(service, serviceConfig);\n     }",
    "output": "Fix ut in ServiceConfigTest"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java\n@@ -38,15 +38,8 @@\n  */\n public class ServiceInstanceMetadataCustomizer implements ServiceInstanceCustomizer {\n-    private volatile boolean customized = false;\n-\n     @Override\n     public void customize(ServiceInstance serviceInstance) {\n-        if (customized) {\n-            return;\n-        }\n-        customized = true;\n-\n         ExtensionLoader<MetadataParamsFilter> loader = ExtensionLoader.getExtensionLoader(MetadataParamsFilter.class);\n         Set<MetadataParamsFilter> paramsFilters = loader.getSupportedExtensionInstances();",
    "output": "Fix customizer not changed"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/PortUnificationServerTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/PortUnificationServerTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/PortUnificationServerTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/PortUnificationServerTest.java\n@@ -17,17 +17,22 @@\n package org.apache.dubbo.remoting.api;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.url.component.ServiceConfigURL;\n import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.remoting.RemotingException;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n-public class NettyServerTest {\n+public class PortUnificationServerTest {\n-    public static void main(String[] args) throws RemotingException {\n-        URL url = new ServiceConfigURL(\"transport\", \"localhost\", 8898,\n+    @Test\n+    public void testBind() throws RemotingException {\n+        URL url = new ServiceConfigURL(CommonConstants.TRIPLE, \"localhost\", 8898,\n                 new String[]{Constants.BIND_PORT_KEY, String.valueOf(8898)});\n         final PortUnificationServer server = new PortUnificationServer(url);\n-        System.out.println(server.isBound());\n+        server.bind();\n+        Assertions.assertTrue(server.isBound());\n     }\n }",
    "output": "Fix NettyServerTest test case problem"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n@@ -62,6 +62,7 @@ public class MetadataInfo implements Serializable {\n     private transient AtomicBoolean reported = new AtomicBoolean(false);\n     public MetadataInfo() {\n+        this(null);\n     }\n     public MetadataInfo(String app) {\ndiff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReport.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReport.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReport.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReport.java\n@@ -74,6 +74,10 @@ default boolean registerServiceAppMapping(String serviceInterface, String defaul\n         return false;\n     }\n+    default boolean registerServiceAppMapping(String serviceKey, String application, URL url) {\n+        return false;\n+    }\n+\n     /**\n      * Service<-->Application Mapping -- START\n      **/",
    "output": "Fix NPE in MetadataInfo"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboClassPathBeanDefinitionScanner.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboClassPathBeanDefinitionScanner.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboClassPathBeanDefinitionScanner.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboClassPathBeanDefinitionScanner.java\n@@ -17,13 +17,15 @@\n package org.apache.dubbo.config.spring.context.annotation;\n import org.springframework.beans.factory.config.BeanDefinition;\n-import org.springframework.beans.factory.config.BeanDefinitionHolder;\n import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;\n import org.springframework.core.env.Environment;\n import org.springframework.core.io.ResourceLoader;\n+import java.util.Objects;\n import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n import static org.springframework.context.annotation.AnnotationConfigUtils.registerAnnotationConfigProcessors;\n@@ -36,6 +38,11 @@\n  */\n public class DubboClassPathBeanDefinitionScanner extends ClassPathBeanDefinitionScanner {\n+    /**\n+     * key is package to scan, value is BeanDefinition\n+     */\n+    private final ConcurrentMap<String, Set<BeanDefinition>> beanDefinitionMap = new ConcurrentHashMap<>();\n+\n     public DubboClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment,\n                                                ResourceLoader resourceLoader) {\n@@ -58,13 +65,13 @@ public DubboClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, Envi\n     }\n     @Override\n-    public Set<BeanDefinitionHolder> doScan(String... basePackages) {\n-        return super.doScan(basePackages);\n+    public Set<BeanDefinition> findCandidateComponents(String basePackage) {\n+        Set<BeanDefinition> beanDefinitions = beanDefinitionMap.get(basePackage);\n+        // if beanDefinitions size is null => scan\n+        if (Objects.isNull(beanDefinitions)) {\n+            beanDefinitions = super.findCandidateComponents(basePackage);\n+            beanDefinitionMap.put(basePackage, beanDefinitions);\n+        }\n+        return beanDefinitions;\n     }\n-\n-    @Override\n-    public boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {\n-        return super.checkCandidate(beanName, beanDefinition);\n-    }\n-\n }",
    "output": "Add cache for scan result. * add cache for scan result. * remove unused method and delete Unused import. * delete checkCandidate method. * Please remove redundant comments."
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n@@ -189,7 +189,7 @@ private static Object generalize(Object pojo, Map<Object, Object> history) {\n                     if (history.containsKey(pojo)) {\n                         Object pojoGeneralizedValue = history.get(pojo);\n                         if (pojoGeneralizedValue instanceof Map\n-                                && ((Map) pojoGeneralizedValue).containsKey(field.getName())) {\n+                            && ((Map) pojoGeneralizedValue).containsKey(field.getName())) {\n                             continue;\n                         }\n                     }\n@@ -312,9 +312,9 @@ private static Object realize0(Object pojo, Class<?> type, Type genericType, fin\n         }\n         if (ReflectUtils.isPrimitives(pojo.getClass())\n-                && !(type != null && type.isArray()\n-                && type.getComponentType().isEnum()\n-                && pojo.getClass() == String[].class)) {\n+            && !(type != null && type.isArray()\n+            && type.getComponentType().isEnum()\n+            && pojo.getClass() == String[].class)) {\n             return CompatibleTypeUtils.compatibleTypeConvert(pojo, type);\n         }\n@@ -399,7 +399,11 @@ private static Object realize0(Object pojo, Class<?> type, Type genericType, fin\n             if (type.isEnum()) {\n                 Object name = ((Map<Object, Object>) pojo).get(\"name\");\n                 if (name != null) {\n-                    return Enum.valueOf((Class<Enum>) type, name.toString());\n+                    if (!(name instanceof String)) {\n+                        throw new IllegalArgumentException(\"`name` filed should be string!\");\n+                    } else {\n+                        return Enum.valueOf((Class<Enum>) type, (String) name);\n+                    }\n                 }\n             }\n             Map<Object, Object> map;\n@@ -426,8 +430,8 @@ private static Object realize0(Object pojo, Class<?> type, Type genericType, fin\n                 Type mapKeyType = getKeyTypeForMap(map.getClass());\n                 Type typeKeyType = getGenericClassByIndex(genericType, 0);\n                 boolean typeMismatch = mapKeyType instanceof Class\n-                        && typeKeyType instanceof Class\n-                        && !typeKeyType.getTypeName().equals(mapKeyType.getTypeName());\n+                    && typeKeyType instanceof Class\n+                    && !typeKeyType.getTypeName().equals(mapKeyType.getTypeName());\n                 if (typeMismatch) {\n                     result = createMap(new HashMap(0));\n                 } else {\n@@ -485,7 +489,7 @@ private static Object realize0(Object pojo, Class<?> type, Type genericType, fin\n                                     method.invoke(dest, value);\n                                 } catch (Exception e) {\n                                     String exceptionDescription = \"Failed to set pojo \" + dest.getClass().getSimpleName() + \" property \" + name\n-                                            + \" value \" + value + \"(\" + value.getClass() + \"), cause: \" + e.getMessage();\n+                                        + \" value \" + value.getClass() + \", cause: \" + e.getMessage();\n                                     logger.error(exceptionDescription, e);\n                                     throw new RuntimeException(exceptionDescription, e);\n                                 }\n@@ -663,8 +667,8 @@ private static Field getField(Class<?> cls, String fieldName) {\n     public static boolean isPojo(Class<?> cls) {\n         return !ReflectUtils.isPrimitives(cls)\n-                && !Collection.class.isAssignableFrom(cls)\n-                && !Map.class.isAssignableFrom(cls);\n+            && !Collection.class.isAssignableFrom(cls)\n+            && !Map.class.isAssignableFrom(cls);\n     }\n     /**\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java\n@@ -123,7 +123,7 @@ public Object decode(Channel channel, InputStream input) throws IOException {\n         setParameterTypesDesc(desc);\n         try {\n-            if (ConfigurationUtils.getSystemConfiguration().getBoolean(SERIALIZATION_SECURITY_CHECK_KEY, false)) {\n+            if (ConfigurationUtils.getSystemConfiguration().getBoolean(SERIALIZATION_SECURITY_CHECK_KEY, true)) {\n                 CodecSupport.checkSerialization(path, version, serializationType);\n             }\n             Object[] args = DubboCodec.EMPTY_OBJECT_ARRAY;\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n@@ -118,7 +118,7 @@ public Object decode(Channel channel, InputStream input) throws IOException {\n     public void decode() throws Exception {\n         if (!hasDecoded && channel != null && inputStream != null) {\n             try {\n-                if (ConfigurationUtils.getSystemConfiguration().getBoolean(SERIALIZATION_SECURITY_CHECK_KEY, false)) {\n+                if (ConfigurationUtils.getSystemConfiguration().getBoolean(SERIALIZATION_SECURITY_CHECK_KEY, true)) {\n                     Object serializationType_obj = invocation.get(SERIALIZATION_ID_KEY);\n                     if (serializationType_obj != null) {\n                         if ((byte) serializationType_obj != serializationType) {",
    "output": "Remove needless toString convert & Enable checking by default * Remove needless toString convert & Enable checking by default * enable check"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -394,33 +394,15 @@ private T createProxy(Map<String, String> map) {\n                 List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\n                 URL registryURL = null;\n                 for (URL url : urls) {\n-                    Invoker<?> referInvoker = REF_PROTOCOL.refer(interfaceClass, url);\n-                    if (shouldCheck()) {\n-                        if (referInvoker.isAvailable()) {\n-                            invokers.add(referInvoker);\n-                        } else {\n-                            referInvoker.destroy();\n-                        }\n-                    } else {\n-                        invokers.add(referInvoker);\n-                    }\n+                    // For multi-registry scenarios, it is not checked whether each referInvoker is available.\n+                    // Because this invoker may become available later.\n+                    invokers.add(REF_PROTOCOL.refer(interfaceClass, url));\n                     if (UrlUtils.isRegistry(url)) {\n                         registryURL = url; // use last registry url\n                     }\n                 }\n-                if (shouldCheck() && invokers.size() == 0) {\n-                    throw new IllegalStateException(\"Failed to check the status of the service \"\n-                            + interfaceName\n-                            + \". No provider available for the service \"\n-                            + (group == null ? \"\" : group + \"/\")\n-                            + interfaceName +\n-                            (version == null ? \"\" : \":\" + version)\n-                            + \" from the multi registry cluster\"\n-                            + \" use dubbo version \" + Version.getVersion());\n-                }\n-\n                 if (registryURL != null) { // registry url is available\n                     // for multi-subscription scenario, use 'zone-aware' policy by default\n                     String cluster = registryURL.getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME);",
    "output": "Fix multi-registry bug"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java\n@@ -77,13 +77,13 @@ public void execute(Runnable runnable) {\n         } catch (RejectedExecutionException e) {\n             LOGGER.error(\"Consumer's thread pool is full\", e);\n             getStreamSubscriber().onError(GrpcStatus.fromCode(GrpcStatus.Code.RESOURCE_EXHAUSTED)\n-                    .withDescription(\"Consumer's thread pool is full\").asException());\n+                .withDescription(\"Consumer's thread pool is full\").asException());\n         } catch (Throwable t) {\n             LOGGER.error(\"Consumer submit request to thread pool error \", t);\n             getStreamSubscriber().onError(GrpcStatus.fromCode(GrpcStatus.Code.INTERNAL)\n-                    .withCause(t)\n-                    .withDescription(\"Consumer's error\")\n-                    .asException());\n+                .withCause(t)\n+                .withDescription(\"Consumer's error\")\n+                .asException());\n         }\n     }\n@@ -128,8 +128,12 @@ protected Object deserializeResponse(byte[] data) {\n             }\n             if (getMethodDescriptor().isNeedWrap()) {\n                 final TripleWrapper.TripleResponseWrapper wrapper = TripleUtil.unpack(data,\n-                        TripleWrapper.TripleResponseWrapper.class);\n-                serialize(wrapper.getSerializeType());\n+                    TripleWrapper.TripleResponseWrapper.class);\n+                if (!getSerializeType().equals(TripleUtil.convertHessianFromWrapper(wrapper.getSerializeType()))) {\n+                    throw new UnsupportedOperationException(\"Received inconsistent serialization type from server, \" +\n+                        \"reject to deserialize! Expected:\" + getSerializeType() +\n+                        \" Actual:\" + TripleUtil.convertHessianFromWrapper(wrapper.getSerializeType()));\n+                }\n                 return TripleUtil.unwrapResp(getUrl(), wrapper, getMultipleSerialization());\n             } else {\n                 return TripleUtil.unpack(data, getMethodDescriptor().getReturnClass());\n@@ -142,17 +146,17 @@ protected Object deserializeResponse(byte[] data) {\n     protected Metadata createRequestMeta(RpcInvocation inv) {\n         Metadata metadata = new DefaultMetadata();\n         metadata.put(TripleConstant.PATH_KEY, \"/\" + inv.getObjectAttachment(CommonConstants.PATH_KEY) + \"/\" + inv.getMethodName())\n-                .put(TripleConstant.AUTHORITY_KEY, getUrl().getAddress())\n-                .put(TripleConstant.CONTENT_TYPE_KEY, TripleConstant.CONTENT_PROTO)\n-                .put(TripleConstant.TIMEOUT, inv.get(CommonConstants.TIMEOUT_KEY) + \"m\")\n-                .put(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS);\n+            .put(TripleConstant.AUTHORITY_KEY, getUrl().getAddress())\n+            .put(TripleConstant.CONTENT_TYPE_KEY, TripleConstant.CONTENT_PROTO)\n+            .put(TripleConstant.TIMEOUT, inv.get(CommonConstants.TIMEOUT_KEY) + \"m\")\n+            .put(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS);\n         metadata.putIfNotNull(TripleConstant.SERVICE_VERSION, inv.getInvoker().getUrl().getVersion())\n-                .putIfNotNull(TripleConstant.CONSUMER_APP_NAME_KEY,\n-                        (String) inv.getObjectAttachments().remove(CommonConstants.APPLICATION_KEY))\n-                .putIfNotNull(TripleConstant.CONSUMER_APP_NAME_KEY,\n-                        (String) inv.getObjectAttachments().remove(CommonConstants.REMOTE_APPLICATION_KEY))\n-                .putIfNotNull(TripleConstant.SERVICE_GROUP, inv.getInvoker().getUrl().getGroup());\n+            .putIfNotNull(TripleConstant.CONSUMER_APP_NAME_KEY,\n+                (String) inv.getObjectAttachments().remove(CommonConstants.APPLICATION_KEY))\n+            .putIfNotNull(TripleConstant.CONSUMER_APP_NAME_KEY,\n+                (String) inv.getObjectAttachments().remove(CommonConstants.REMOTE_APPLICATION_KEY))\n+            .putIfNotNull(TripleConstant.SERVICE_GROUP, inv.getInvoker().getUrl().getGroup());\n         inv.getObjectAttachments().remove(CommonConstants.GROUP_KEY);\n         inv.getObjectAttachments().remove(CommonConstants.INTERFACE_KEY);\n         inv.getObjectAttachments().remove(CommonConstants.PATH_KEY);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.threadpool.manager.ExecutorRepository;\n+import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n@@ -58,6 +59,7 @@ protected AbstractServerStream(URL url, ProviderModel providerModel) {\n     protected AbstractServerStream(URL url, Executor executor, ProviderModel providerModel) {\n         super(url, executor);\n         this.providerModel = providerModel;\n+        this.serialize(getUrl().getParameter(Constants.SERIALIZATION_KEY, Constants.DEFAULT_REMOTING_SERIALIZATION));\n     }\n     private static Executor lookupExecutor(URL url, ProviderModel providerModel) {\n@@ -142,7 +144,13 @@ protected Object[] deserializeRequest(byte[] data) {\n             if (getMethodDescriptor() == null || getMethodDescriptor().isNeedWrap()) {\n                 final TripleWrapper.TripleRequestWrapper wrapper = TripleUtil.unpack(data,\n                         TripleWrapper.TripleRequestWrapper.class);\n-                serialize(wrapper.getSerializeType());\n+                if (!getSerializeType().equals(TripleUtil.convertHessianFromWrapper(wrapper.getSerializeType()))) {\n+                    transportError(GrpcStatus.fromCode(GrpcStatus.Code.INVALID_ARGUMENT)\n+                        .withDescription(\"Received inconsistent serialization type from client, \" +\n+                            \"reject to deserialize! Expected:\" + getSerializeType() +\n+                            \" Actual:\" + TripleUtil.convertHessianFromWrapper(wrapper.getSerializeType())));\n+                    return null;\n+                }\n                 if (getMethodDescriptor() == null) {\n                     final String[] paramTypes = wrapper.getArgTypesList().toArray(new String[wrapper.getArgsCount()]);",
    "output": "Add force check"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n@@ -37,13 +37,13 @@\n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n import static java.lang.String.format;\n@@ -104,7 +104,7 @@ public class ServiceDiscoveryRegistry implements Registry {\n     private final Set<String> registeredListeners = new LinkedHashSet<>();\n     /* apps - listener */\n-    private final Map<String, ServiceInstancesChangedListener> serviceListeners = new HashMap<>();\n+    private final Map<String, ServiceInstancesChangedListener> serviceListeners = new ConcurrentHashMap<>();\n     private URL registryURL;",
    "output": "Fix concurrent modified problem"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n@@ -489,8 +489,4 @@ private boolean needRefresh(ClusterInvoker<T> invoker) {\n     public boolean checkInvokerAvailable(ClusterInvoker<T> invoker) {\n         return invoker != null && !invoker.isDestroyed() && invoker.isAvailable();\n     }\n-\n-    public ClusterInvoker<T> getCurrentAvailableInvoker() {\n-        return currentAvailableInvoker;\n-    }\n }",
    "output": "Fix compile error"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java\n@@ -58,7 +58,7 @@ public class DefaultExecutorRepository implements ExecutorRepository {\n     private ScheduledExecutorService reconnectScheduledExecutor;\n-    private ScheduledExecutorService serviceDiscveryAddressNotificationExecutor;\n+    private ScheduledExecutorService serviceDiscoveryAddressNotificationExecutor;\n     private ScheduledExecutorService metadataRetryExecutor;\n@@ -84,7 +84,7 @@ public DefaultExecutorRepository() {\n         poolRouterExecutor = new ThreadPoolExecutor(1, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(1024),\n             new NamedInternalThreadFactory(\"Dubbo-state-router-pool-router\", true), new ThreadPoolExecutor.AbortPolicy());\n         serviceExporterExecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"Dubbo-exporter-scheduler\"));\n-        serviceDiscveryAddressNotificationExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"Dubbo-SD-address-refresh\"));\n+        serviceDiscoveryAddressNotificationExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"Dubbo-SD-address-refresh\"));\n         registryNotificationExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"Dubbo-registry-notification\"));\n         metadataRetryExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"Dubbo-metadata-retry\"));\n     }\n@@ -187,7 +187,7 @@ public ScheduledExecutorService getRegistryNotificationExecutor() {\n     }\n     public ScheduledExecutorService getServiceDiscoveryAddressNotificationExecutor() {\n-        return serviceDiscveryAddressNotificationExecutor;\n+        return serviceDiscoveryAddressNotificationExecutor;\n     }\n     @Override\n@@ -211,6 +211,12 @@ public ExecutorService getPoolRouterExecutor() {\n     @Override\n     public void destroyAll() {\n+        poolRouterExecutor.shutdown();\n+        serviceExporterExecutor.shutdown();\n+        serviceDiscoveryAddressNotificationExecutor.shutdown();\n+        registryNotificationExecutor.shutdown();\n+        metadataRetryExecutor.shutdown();\n+\n         data.values().forEach(executors -> {\n             if (executors != null) {\n                 executors.values().forEach(executor -> {",
    "output": "Add shutdown logic for Executor in ExecutorRepository"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n@@ -49,13 +49,17 @@ public ServiceAddressURL(\n         this.consumerURL = consumerURL;\n     }\n-    public ServiceAddressURL(URLAddress urlAddress, URLParam urlParam, URL consumerURL){\n+    public ServiceAddressURL(URLAddress urlAddress, URLParam urlParam, URL consumerURL) {\n         super(urlAddress, urlParam);\n         this.consumerURL = consumerURL;\n     }\n     @Override\n     public String getPath() {\n+        String path = super.getPath();\n+        if (StringUtils.isNotEmpty(path)) {\n+            return path;\n+        }\n         return consumerURL.getPath();\n     }\n@@ -108,7 +112,6 @@ public String getVersion() {\n //        allParameters.remove(CATEGORY_KEY);\n //        return Collections.unmodifiableMap(allParameters);\n //    }\n-\n     @Override\n     public String getParameter(String key) {\n         if (GROUP_KEY.equals(key)) {\n@@ -195,7 +198,7 @@ public URL getConsumerURL() {\n     @Override\n     public int hashCode() {\n-        return super.hashCode() ;\n+        return super.hashCode();\n     }\n     /**",
    "output": "Fix get wrong path for ServiceAddressURL"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceRepository.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceRepository.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceRepository.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceRepository.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.context.LifecycleAdapter;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.ReferenceConfigBase;\n import org.apache.dubbo.config.ServiceConfigBase;\n@@ -123,7 +124,12 @@ public void registerProvider(String serviceKey,\n     }\n     private static String keyWithoutGroup(String serviceKey) {\n-        return interfaceFromServiceKey(serviceKey) + \":\" + versionFromServiceKey(serviceKey);\n+        String interfaceName = interfaceFromServiceKey(serviceKey);\n+        String version = versionFromServiceKey(serviceKey);\n+        if (StringUtils.isEmpty(version)) {\n+            return interfaceName;\n+        }\n+        return interfaceName + \":\" + version;\n     }\n     public void reRegisterProvider(String newServiceKey, String serviceKey) {",
    "output": "Fix, check empty version"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/legacy/TraceTelnetHandlerTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/legacy/TraceTelnetHandlerTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/legacy/TraceTelnetHandlerTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/legacy/TraceTelnetHandlerTest.java\n@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.qos.legacy;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.qos.legacy.service.DemoService;\n+import org.apache.dubbo.remoting.Channel;\n+import org.apache.dubbo.remoting.telnet.TelnetHandler;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol;\n+import org.apache.dubbo.rpc.protocol.dubbo.filter.TraceFilter;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Field;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.reset;\n+\n+public class TraceTelnetHandlerTest {\n+\n+    private TelnetHandler handler;\n+    private Channel mockChannel;\n+    private Invoker<DemoService> mockInvoker;\n+    private URL url = URL.valueOf(\"dubbo://127.0.0.1:20884/demo\");\n+\n+    @BeforeEach\n+    public void setUp() {\n+        handler = new TraceTelnetHandler();\n+        mockChannel = mock(Channel.class);\n+        mockInvoker = mock(Invoker.class);\n+        given(mockInvoker.getInterface()).willReturn(DemoService.class);\n+        given(mockInvoker.getUrl()).willReturn(url);\n+    }\n+\n+    @AfterEach\n+    public void tearDown() {\n+        reset(mockChannel, mockInvoker);\n+        ProtocolUtils.closeAll();\n+    }\n+\n+    @Test\n+    public void testTraceTelnetAddTracer() throws Exception {\n+        String method = \"sayHello\";\n+        String message = \"org.apache.dubbo.qos.legacy.service.DemoService sayHello 1\";\n+        Class<?> type = DemoService.class;\n+\n+        DubboProtocol.getDubboProtocol().export(mockInvoker);\n+        handler.telnet(mockChannel, message);\n+\n+        String key = type.getName() + \".\" + method;\n+        Field tracers = TraceFilter.class.getDeclaredField(\"TRACERS\");\n+        tracers.setAccessible(true);\n+        ConcurrentHashMap<String, Set<Channel>> map =\n+                (ConcurrentHashMap<String, Set<Channel>>) tracers.get(new ConcurrentHashMap<String, Set<Channel>>());\n+\n+        Set<Channel> channels = map.getOrDefault(key, null);\n+        Assertions.assertNotNull(channels);\n+\n+        Assertions.assertTrue(channels.contains(mockChannel));\n+    }\n+}",
    "output": "Add unit test for TraceTelnetHandler"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/filter/MockChannel.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/filter/MockChannel.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/filter/MockChannel.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/filter/MockChannel.java\n@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.dubbo.filter;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.remoting.Channel;\n+import org.apache.dubbo.remoting.ChannelHandler;\n+import org.apache.dubbo.remoting.RemotingException;\n+\n+import java.net.InetSocketAddress;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class MockChannel implements Channel {\n+\n+    private Map<String, Object> attributes = new HashMap<>();\n+    private List<Object> receivedObjects = new LinkedList<>();\n+    private URL url;\n+\n+    public MockChannel() {\n+    }\n+\n+    public MockChannel(URL url) {\n+        this.url = url;\n+    }\n+\n+    @Override\n+    public InetSocketAddress getRemoteAddress() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean hasAttribute(String key) {\n+        return attributes.containsKey(key);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String key) {\n+        return attributes.getOrDefault(key, null);\n+    }\n+\n+    @Override\n+    public void setAttribute(String key, Object value) {\n+        attributes.put(key, value);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String key) {\n+        attributes.remove(key);\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public ChannelHandler getChannelHandler() {\n+        return null;\n+    }\n+\n+    @Override\n+    public InetSocketAddress getLocalAddress() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void send(Object message) throws RemotingException {\n+        receivedObjects.add(message);\n+    }\n+\n+    @Override\n+    public void send(Object message, boolean sent) throws RemotingException {\n+        receivedObjects.add(message);\n+    }\n+\n+    @Override\n+    public void close() {\n+\n+    }\n+\n+    @Override\n+    public void close(int timeout) {\n+\n+    }\n+\n+    @Override\n+    public void startClose() {\n+\n+    }\n+\n+    @Override\n+    public boolean isClosed() {\n+        return false;\n+    }\n+\n+    public List<Object> getReceivedObjects() {\n+        return receivedObjects;\n+    }\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/filter/TraceFilterTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/filter/TraceFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/filter/TraceFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/filter/TraceFilterTest.java\n@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.dubbo.filter;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.remoting.Channel;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.Result;\n+import org.apache.dubbo.rpc.protocol.dubbo.support.DemoService;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Field;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+\n+public class TraceFilterTest {\n+\n+    private MockChannel mockChannel;\n+    private static final String TRACE_MAX = \"trace.max\";\n+    private static final String TRACE_COUNT = \"trace.count\";\n+    private static final String TRACERS_FIELD_NAME = \"TRACERS\";\n+\n+    @BeforeEach\n+    public void setUp() {\n+        URL url = URL.valueOf(\"dubbo://127.0.0.1:20884/demo\");\n+        mockChannel = new MockChannel(url);\n+    }\n+\n+    @AfterEach\n+    public void tearDown() {\n+        mockChannel.close();\n+    }\n+\n+    @Test\n+    public void testAddAndRemoveTracer() throws Exception {\n+        String method = \"sayHello\";\n+        Class<?> type = DemoService.class;\n+        String key = type.getName() + \".\" + method;\n+\n+        // add tracer\n+        TraceFilter.addTracer(type, method, mockChannel, 100);\n+\n+        Assertions.assertEquals(100, mockChannel.getAttribute(TRACE_MAX));\n+        Assertions.assertTrue(mockChannel.getAttribute(TRACE_COUNT) instanceof AtomicInteger);\n+\n+        Field tracers = TraceFilter.class.getDeclaredField(TRACERS_FIELD_NAME);\n+        tracers.setAccessible(true);\n+        ConcurrentHashMap<String, Set<Channel>> o = (ConcurrentHashMap<String, Set<Channel>>) tracers.get(new ConcurrentHashMap<String, Set<Channel>>());\n+\n+        Assertions.assertTrue(o.containsKey(key));\n+        Set<Channel> channels = o.get(key);\n+        Assertions.assertNotNull(channels);\n+        Assertions.assertTrue(channels.contains(mockChannel));\n+\n+        // remove tracer\n+        TraceFilter.removeTracer(type, method, mockChannel);\n+        Assertions.assertNull(mockChannel.getAttribute(TRACE_MAX));\n+        Assertions.assertNull(mockChannel.getAttribute(TRACE_COUNT));\n+        Assertions.assertFalse(channels.contains(mockChannel));\n+    }\n+\n+    @Test\n+    public void testInvoke() throws Exception {\n+        String method = \"sayHello\";\n+        Class<?> type = DemoService.class;\n+        String key = type.getName() + \".\" + method;\n+        // add tracer\n+        TraceFilter.addTracer(type, method, mockChannel, 2);\n+\n+        Invoker<DemoService> mockInvoker = mock(Invoker.class);\n+        Invocation mockInvocation = mock(Invocation.class);\n+        Result mockResult = mock(Result.class);\n+        TraceFilter filter = new TraceFilter();\n+\n+        given(mockInvoker.getInterface()).willReturn(DemoService.class);\n+        given(mockInvocation.getMethodName()).willReturn(method);\n+        given(mockInvocation.getArguments()).willReturn(new Object[0]);\n+        given(mockInvoker.invoke(mockInvocation)).willReturn(mockResult);\n+        given(mockResult.getValue()).willReturn(\"result\");\n+\n+        // test invoke\n+        filter.invoke(mockInvoker, mockInvocation);\n+        String message = listToString(mockChannel.getReceivedObjects());\n+        String expectMessage = \"org.apache.dubbo.rpc.protocol.dubbo.support.DemoService.sayHello([]) -> \\\"result\\\"\";\n+        System.out.println(\"actual message: \" + message);\n+        Assertions.assertTrue(message.contains(expectMessage));\n+        Assertions.assertTrue(message.contains(\"elapsed:\"));\n+        AtomicInteger traceCount = (AtomicInteger) mockChannel.getAttribute(TRACE_COUNT);\n+        Assertions.assertEquals(1, traceCount.get());\n+\n+        // test remove channel when count >= max - 1\n+        filter.invoke(mockInvoker, mockInvocation);\n+        Field tracers = TraceFilter.class.getDeclaredField(TRACERS_FIELD_NAME);\n+        tracers.setAccessible(true);\n+        ConcurrentHashMap<String, Set<Channel>> o = (ConcurrentHashMap<String, Set<Channel>>) tracers.get(new ConcurrentHashMap<String, Set<Channel>>());\n+        Assertions.assertTrue(o.containsKey(key));\n+        Set<Channel> channels = o.get(key);\n+        Assertions.assertNotNull(channels);\n+        Assertions.assertFalse(channels.contains(mockChannel));\n+    }\n+\n+    private static String listToString(List<Object> objectList) {\n+        StringBuilder sb = new StringBuilder();\n+        if (CollectionUtils.isEmpty(objectList)) {\n+            return \"\";\n+        }\n+\n+        objectList.forEach(o -> {\n+            sb.append(o.toString());\n+        });\n+        return sb.toString();\n+    }\n+}",
    "output": "Add unit test for TraceFilter * Add unit test for TraceFilter * println actual message * Fix TraceFilterTest#testInvoke"
  },
  {
    "input": "diff --git a/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/AbstractMonitorFactory.java b/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/AbstractMonitorFactory.java\n--- a/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/AbstractMonitorFactory.java\n+++ b/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/AbstractMonitorFactory.java\n@@ -27,9 +27,7 @@\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n import java.util.concurrent.SynchronousQueue;\n@@ -55,7 +53,7 @@ public abstract class AbstractMonitorFactory implements MonitorFactory {\n      */\n     private static final Map<String, Monitor> MONITORS = new ConcurrentHashMap<String, Monitor>();\n-    private static final Map<String, CompletableFuture<Monitor>> FUTURES = new ConcurrentHashMap<String, CompletableFuture<Monitor>>();\n+    private static final Map<String, Future<Monitor>> FUTURES = new ConcurrentHashMap<String, Future<Monitor>>();\n     /**\n      * The monitor create executor\n@@ -85,10 +83,18 @@ public Monitor getMonitor(URL url) {\n             }\n             final URL monitorUrl = url;\n-            final CompletableFuture<Monitor> completableFuture = CompletableFuture.supplyAsync(() -> AbstractMonitorFactory.this.createMonitor(monitorUrl));\n-            FUTURES.put(key, completableFuture);\n-            completableFuture.thenRunAsync(new MonitorListener(key), EXECUTOR);\n-\n+            future = EXECUTOR.submit(() -> {\n+                try {\n+                    Monitor m = createMonitor(monitorUrl);\n+                    MONITORS.put(key, m);\n+                    FUTURES.remove(key);\n+                    return m;\n+                } catch (Throwable e) {\n+                    logger.warn(\"Create monitor failed, monitor data will not be collected until you fix this problem. monitorUrl: \" + monitorUrl, e);\n+                    return null;\n+                }\n+            });\n+            FUTURES.put(key, future);\n             return null;\n         } finally {\n             // unlock\n@@ -98,28 +104,4 @@ public Monitor getMonitor(URL url) {\n     protected abstract Monitor createMonitor(URL url);\n-\n-    class MonitorListener implements Runnable {\n-\n-        private String key;\n-\n-        public MonitorListener(String key) {\n-            this.key = key;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                CompletableFuture<Monitor> completableFuture = AbstractMonitorFactory.FUTURES.get(key);\n-                AbstractMonitorFactory.MONITORS.put(key, completableFuture.get());\n-                AbstractMonitorFactory.FUTURES.remove(key);\n-            } catch (InterruptedException e) {\n-                logger.warn(\"Thread was interrupted unexpectedly, monitor will never be got.\");\n-                AbstractMonitorFactory.FUTURES.remove(key);\n-            } catch (ExecutionException e) {\n-                logger.warn(\"Create monitor failed, monitor data will not be collected until you fix this problem. \", e);\n-            }\n-        }\n-    }\n-\n }",
    "output": "Improve monitor creating, handle errors"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/ServiceAddressURL.java\n@@ -111,6 +111,9 @@ public String getVersion() {\n     @Override\n     public String getParameter(String key) {\n+        if (GROUP_KEY.equals(key)) {\n+            return getGroup();\n+        }\n         String value = null;\n         if (consumerURL != null) {\n             value = consumerURL.getParameter(key);\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LRUCache.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LRUCache.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LRUCache.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/LRUCache.java\n@@ -20,6 +20,12 @@\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n+/**\n+ * LRU-2\n+ * </p>\n+ * When the data accessed for the first time, add it to history list. If the size of history list reaches max capacity, eliminate the earliest data (first in first out).\n+ * When the data already exists in the history list, and be accessed for the second time, then it will be put into cache.\n+ */\n public class LRUCache<K, V> extends LinkedHashMap<K, V> {\n     private static final long serialVersionUID = -5167631809472116969L;\n@@ -30,13 +36,17 @@ public class LRUCache<K, V> extends LinkedHashMap<K, V> {\n     private final Lock lock = new ReentrantLock();\n     private volatile int maxCapacity;\n+    // as history list\n+    private PreCache<K, Boolean> preCache;\n+\n     public LRUCache() {\n         this(DEFAULT_MAX_CAPACITY);\n     }\n     public LRUCache(int maxCapacity) {\n         super(16, DEFAULT_LOAD_FACTOR, true);\n         this.maxCapacity = maxCapacity;\n+        this.preCache = new PreCache<>(maxCapacity);\n     }\n     @Override\n@@ -68,7 +78,15 @@ public V get(Object key) {\n     public V put(K key, V value) {\n         lock.lock();\n         try {\n-            return super.put(key, value);\n+            if (preCache.containsKey(key)) {\n+                // add it to cache\n+                preCache.remove(key);\n+                return super.put(key, value);\n+            } else {\n+                // add it to history list\n+                preCache.put(key, true);\n+                return value;\n+            }\n         } finally {\n             lock.unlock();\n         }\n@@ -78,6 +96,7 @@ public V put(K key, V value) {\n     public V remove(Object key) {\n         lock.lock();\n         try {\n+            preCache.remove(key);\n             return super.remove(key);\n         } finally {\n             lock.unlock();\n@@ -98,6 +117,7 @@ public int size() {\n     public void clear() {\n         lock.lock();\n         try {\n+            preCache.clear();\n             super.clear();\n         } finally {\n             lock.unlock();\n@@ -109,7 +129,31 @@ public int getMaxCapacity() {\n     }\n     public void setMaxCapacity(int maxCapacity) {\n+        preCache.setMaxCapacity(maxCapacity);\n         this.maxCapacity = maxCapacity;\n     }\n+    static class PreCache<K, V> extends LinkedHashMap<K, V> {\n+\n+        private volatile int maxCapacity;\n+\n+        public PreCache() {\n+            this(DEFAULT_MAX_CAPACITY);\n+        }\n+\n+        public PreCache(int maxCapacity) {\n+            super(16, DEFAULT_LOAD_FACTOR, true);\n+            this.maxCapacity = maxCapacity;\n+        }\n+\n+        @Override\n+        protected boolean removeEldestEntry(java.util.Map.Entry<K, V> eldest) {\n+            return size() > maxCapacity;\n+        }\n+\n+        public void setMaxCapacity(int maxCapacity) {\n+            this.maxCapacity = maxCapacity;\n+        }\n+    }\n+\n }\n\\ No newline at end of file\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/LRUCacheTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/LRUCacheTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/LRUCacheTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/LRUCacheTest.java\n@@ -31,11 +31,18 @@ public void testCache() throws Exception {\n         cache.put(\"one\", 1);\n         cache.put(\"two\", 2);\n         cache.put(\"three\", 3);\n+        assertFalse(cache.containsKey(\"one\"));\n+        assertFalse(cache.containsKey(\"two\"));\n+        assertFalse(cache.containsKey(\"three\"));\n+        cache.put(\"one\", 1);\n+        cache.put(\"two\", 2);\n+        cache.put(\"three\", 3);\n         assertThat(cache.get(\"one\"), equalTo(1));\n         assertThat(cache.get(\"two\"), equalTo(2));\n         assertThat(cache.get(\"three\"), equalTo(3));\n         assertThat(cache.size(), equalTo(3));\n         cache.put(\"four\", 4);\n+        cache.put(\"four\", 4);\n         assertThat(cache.size(), equalTo(3));\n         assertFalse(cache.containsKey(\"one\"));\n         assertTrue(cache.containsKey(\"two\"));\n@@ -44,11 +51,14 @@ public void testCache() throws Exception {\n         cache.remove(\"four\");\n         assertThat(cache.size(), equalTo(2));\n         cache.put(\"five\", 5);\n+        cache.put(\"five\", 5);\n         assertFalse(cache.containsKey(\"four\"));\n         assertTrue(cache.containsKey(\"five\"));\n         assertTrue(cache.containsKey(\"two\"));\n         assertTrue(cache.containsKey(\"three\"));\n         assertThat(cache.size(), equalTo(3));\n+        cache.put(\"six\", 6);\n+        assertFalse(cache.containsKey(\"six\"));\n     }\n     @Test\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/cache/CacheTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/cache/CacheTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/cache/CacheTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/cache/CacheTest.java\n@@ -83,6 +83,7 @@ private void testCache(String type) throws Exception {\n                 // verify cache, same result is returned for multiple invocations (in fact, the return value increases\n                 // on every invocation on the server side)\n                 String fix = null;\n+                cacheService.findCache(\"0\");\n                 for (int i = 0; i < 3; i++) {\n                     String result = cacheService.findCache(\"0\");\n                     assertTrue(fix == null || fix.equals(result));\n@@ -94,6 +95,7 @@ private void testCache(String type) throws Exception {\n                     // default cache.size is 1000 for LRU, should have cache expired if invoke more than 1001 times\n                     for (int n = 0; n < 1001; n++) {\n                         String pre = null;\n+                        cacheService.findCache(String.valueOf(n));\n                         for (int i = 0; i < 10; i++) {\n                             String result = cacheService.findCache(String.valueOf(n));\n                             assertTrue(pre == null || pre.equals(result));\ndiff --git a/dubbo-filter/dubbo-filter-cache/src/test/java/org/apache/dubbo/cache/filter/CacheFilterTest.java b/dubbo-filter/dubbo-filter-cache/src/test/java/org/apache/dubbo/cache/filter/CacheFilterTest.java\n--- a/dubbo-filter/dubbo-filter-cache/src/test/java/org/apache/dubbo/cache/filter/CacheFilterTest.java\n+++ b/dubbo-filter/dubbo-filter-cache/src/test/java/org/apache/dubbo/cache/filter/CacheFilterTest.java\n@@ -85,6 +85,7 @@ public void testNonArgsMethod(String cacheType, CacheFactory cacheFactory) {\n         invocation.setParameterTypes(new Class<?>[]{});\n         invocation.setArguments(new Object[]{});\n+        cacheFilter.invoke(invoker, invocation);\n         cacheFilter.invoke(invoker, invocation);\n         Result rpcResult1 = cacheFilter.invoke(invoker1, invocation);\n         Result rpcResult2 = cacheFilter.invoke(invoker2, invocation);\n@@ -100,6 +101,7 @@ public void testMethodWithArgs(String cacheType, CacheFactory cacheFactory) {\n         invocation.setParameterTypes(new Class<?>[]{String.class});\n         invocation.setArguments(new Object[]{\"arg1\"});\n+        cacheFilter.invoke(invoker, invocation);\n         cacheFilter.invoke(invoker, invocation);\n         Result rpcResult1 = cacheFilter.invoke(invoker1, invocation);\n         Result rpcResult2 = cacheFilter.invoke(invoker2, invocation);\n@@ -115,6 +117,7 @@ public void testException(String cacheType, CacheFactory cacheFactory) {\n         invocation.setParameterTypes(new Class<?>[]{String.class});\n         invocation.setArguments(new Object[]{\"arg2\"});\n+        cacheFilter.invoke(invoker3, invocation);\n         cacheFilter.invoke(invoker3, invocation);\n         Result rpcResult = cacheFilter.invoke(invoker2, invocation);\n         Assertions.assertEquals(rpcResult.getValue(), \"value2\");\n@@ -128,6 +131,7 @@ public void testNull(String cacheType, CacheFactory cacheFactory) {\n         invocation.setParameterTypes(new Class<?>[]{String.class});\n         invocation.setArguments(new Object[]{\"arg3\"});\n+        cacheFilter.invoke(invoker4, invocation);\n         cacheFilter.invoke(invoker4, invocation);\n         Result result1 = cacheFilter.invoke(invoker1, invocation);\n         Result result2 = cacheFilter.invoke(invoker2, invocation);",
    "output": "Fix Integration Test * fix group key fetch * enhance LRUCache * enhance LRUCache * enhance LRUCache (cherry picked from commit d3a400daca2d78a43dd9cc9160675c02f3b1bb76) * add dependency pass"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n@@ -267,26 +267,28 @@ public void loop(boolean notify) {\n         }\n         if (notify) {\n             if (loopPermitNotify.tryAcquire()) {\n-                loopPool.submit(new NotifyLoopRunnable(true));\n+                loopPool.submit(new NotifyLoopRunnable(true, loopPermitNotify));\n             }\n         } else {\n             if (loopPermit.tryAcquire()) {\n-                loopPool.submit(new NotifyLoopRunnable(false));\n+                loopPool.submit(new NotifyLoopRunnable(false, loopPermit));\n             }\n         }\n     }\n     class NotifyLoopRunnable implements Runnable {\n         private final boolean notify;\n+        private final Semaphore loopPermit;\n-        public NotifyLoopRunnable(boolean notify) {\n+        public NotifyLoopRunnable(boolean notify, Semaphore loopPermit) {\n             this.notify = notify;\n+            this.loopPermit = loopPermit;\n         }\n         @Override\n         public void run() {\n-            loopPermitNotify.release();\n+            loopPermit.release();\n             buildCache(notify);\n         }\n     }",
    "output": "Fix semaphore usage error when calculating address. * fix addr cache bug * fix router chain loop err"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/ReferenceCountManagedChannel.java b/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/ReferenceCountManagedChannel.java\n--- a/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/ReferenceCountManagedChannel.java\n+++ b/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/ReferenceCountManagedChannel.java\n@@ -40,8 +40,8 @@ public ReferenceCountManagedChannel(ManagedChannel delegated) {\n     /**\n      * The reference count of current ExchangeClient, connection will be closed if all invokers destroyed.\n      */\n-    public void incrementAndGetCount() {\n-        referenceCount.incrementAndGet();\n+    public int incrementAndGetCount() {\n+        return referenceCount.incrementAndGet();\n     }\n     @Override",
    "output": "Fix ReferenceCountManagedChannel#incrementAndGetCount return type"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java\n@@ -336,7 +336,9 @@ public URLBuilder addParametersIfAbsent(Map<String, String> parameters) {\n         if (CollectionUtils.isEmptyMap(parameters)) {\n             return this;\n         }\n-        this.parameters.putAll(parameters);\n+        for(Map.Entry<String, String> entry : parameters.entrySet()) {\n+            this.parameters.putIfAbsent(entry.getKey(), entry.getValue());\n+        }\n         return this;\n     }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/URLBuilderTest.java\n@@ -19,6 +19,8 @@\n import org.junit.jupiter.api.Test;\n import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.hamcrest.MatcherAssert.assertThat;\n@@ -97,4 +99,46 @@ public void shouldAddIfAbsent() {\n         assertThat(url2.getVersion(), equalTo(\"1.0.0\"));\n         assertThat(url2.getParameter(\"absentKey\"), equalTo(\"absentValue\"));\n     }\n+\n+    @Test\n+    public void shouldAddParameters() {\n+        URL url1 = URL.valueOf(\"dubbo://admin:hello1234@10.20.130.230:20880/context/path?version=1.0.0&application=morgan&key2=v2\");\n+\n+        // string pairs test\n+        URL url2 = URLBuilder.from(url1)\n+                .addParameters(\"version\", \"1.0.0\", \"absentKey1\", \"absentValue1\")\n+                .build();\n+        assertThat(url2.getParameter(\"version\"), equalTo(\"1.0.0\"));\n+        assertThat(url2.getParameter(\"absentKey1\"), equalTo(\"absentValue1\"));\n+\n+        // map test\n+        Map<String, String> parameters = new HashMap<String, String>(){\n+            {\n+                this.put(\"version\", \"2.0.0\");\n+                this.put(\"absentKey2\", \"absentValue2\");\n+            }\n+        };\n+        url2 = URLBuilder.from(url1)\n+                .addParameters(parameters)\n+                .build();\n+        assertThat(url2.getParameter(\"version\"), equalTo(\"2.0.0\"));\n+        assertThat(url2.getParameter(\"absentKey2\"), equalTo(\"absentValue2\"));\n+    }\n+\n+    @Test\n+    public void shouldAddParametersIfAbsent() {\n+        URL url1 = URL.valueOf(\"dubbo://admin:hello1234@10.20.130.230:20880/context/path?version=1.0.0&application=morgan&key2=v2\");\n+\n+        Map<String, String> parameters = new HashMap<String, String>(){\n+            {\n+                this.put(\"version\", \"2.0.0\");\n+                this.put(\"absentKey\", \"absentValue\");\n+            }\n+        };\n+        URL url2 = URLBuilder.from(url1)\n+                .addParametersIfAbsent(parameters)\n+                .build();\n+        assertThat(url2.getParameter(\"version\"), equalTo(\"1.0.0\"));\n+        assertThat(url2.getParameter(\"absentKey\"), equalTo(\"absentValue\"));\n+    }\n }",
    "output": "Fix URLBuilder#addParametersIfAbsent"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n@@ -18,7 +18,9 @@\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -209,19 +211,20 @@ private void buildCache(boolean notify) {\n         AddrCache<T> origin = cache.get();\n         List<Invoker<T>> copyInvokers = new ArrayList<>(this.invokers);\n         AddrCache<T> newCache = new AddrCache<T>();\n+        Map<String, RouterCache<T>> routerCacheMap = new HashMap<>((int) (stateRouters.size() / 0.75f) + 1);\n         newCache.setInvokers(invokers);\n         for (StateRouter stateRouter : stateRouters) {\n-            RouterCache routerCache;\n             try {\n-                routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n+                RouterCache routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n                 //file cache\n-                newCache.getCache().put(stateRouter.getName(), routerCache);\n+                routerCacheMap.put(stateRouter.getName(), routerCache);\n             } catch (Throwable t) {\n                 logger.error(\"Failed to pool router: \" + stateRouter.getUrl() + \", cause: \" + t.getMessage(), t);\n                 return;\n             }\n         }\n+        newCache.setCache(routerCacheMap);\n         this.cache.set(newCache);\n     }\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java\n@@ -16,9 +16,9 @@\n  */\n package org.apache.dubbo.rpc.cluster.router.state;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n+import java.util.Map;\n import org.apache.dubbo.rpc.Invoker;\n@@ -29,10 +29,9 @@\n  * @since 3.0\n  */\n public class AddrCache<T> {\n-    private final static ConcurrentHashMap EMPTY_MAP = new ConcurrentHashMap<>();\n     protected List<Invoker<T>> invokers;\n-    protected ConcurrentMap<String, RouterCache<T>> cache = EMPTY_MAP;\n+    protected Map<String, RouterCache<T>> cache = Collections.emptyMap();\n     public List<Invoker<T>> getInvokers() {\n         return invokers;\n@@ -42,11 +41,11 @@ public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = invokers;\n     }\n-    public ConcurrentMap<String, RouterCache<T>> getCache() {\n+    public Map<String, RouterCache<T>> getCache() {\n         return cache;\n     }\n-    public void setCache(ConcurrentHashMap<String, RouterCache<T>> cache) {\n+    public void setCache(Map<String, RouterCache<T>> cache) {\n         this.cache = cache;\n     }\n }",
    "output": "Fix addr cache bug"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java\n@@ -53,6 +53,7 @@ public class MethodDescriptor {\n     public MethodDescriptor(Method method) {\n         this.method = method;\n+        this.methodName = method.getName();\n         Class<?>[] parameterTypes = method.getParameterTypes();\n         if (parameterTypes.length == 1 && isStreamType(parameterTypes[0])) {\n             this.parameterClasses = new Class<?>[]{\n@@ -78,7 +79,6 @@ public MethodDescriptor(Method method) {\n         this.compatibleParamSignatures = Stream.of(parameterClasses)\n                 .map(Class::getName)\n                 .toArray(String[]::new);\n-        this.methodName = method.getName();\n         this.generic = (methodName.equals($INVOKE) || methodName.equals($INVOKE_ASYNC)) && parameterClasses.length == 3;\n     }",
    "output": "Make method and methodName first set"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/BaseServiceMetadata.java b/dubbo-common/src/main/java/org/apache/dubbo/common/BaseServiceMetadata.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/BaseServiceMetadata.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/BaseServiceMetadata.java\n@@ -42,7 +42,7 @@ public static String buildServiceKey(String path, String group, String version)\n         if (version != null && version.length() > 0) {\n             buf.append(\":\").append(version);\n         }\n-        return buf.toString();\n+        return buf.toString().intern();\n     }\n     public static String versionFromServiceKey(String serviceKey) {",
    "output": "Use String Intern to reduce memory allocation"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/builders/AbstractInterfaceBuilderTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/builders/AbstractInterfaceBuilderTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/builders/AbstractInterfaceBuilderTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/bootstrap/builders/AbstractInterfaceBuilderTest.java\n@@ -247,6 +247,7 @@ void scope() {\n     void build() {\n         MonitorConfig monitorConfig = new MonitorConfig(\"123\");\n         ApplicationConfig applicationConfig = new ApplicationConfig();\n+        applicationConfig.setName(\"appName\");\n         ModuleConfig moduleConfig = new ModuleConfig();\n         RegistryConfig registryConfig = new RegistryConfig();\n         MetadataReportConfig metadataReportConfig = new MetadataReportConfig();\ndiff --git a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/test/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfigurationTest.java b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/test/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfigurationTest.java\n--- a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/test/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfigurationTest.java\n+++ b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/test/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfigurationTest.java\n@@ -141,11 +141,12 @@ public void testPublishConfig() {\n     @Test\n     public void testPublishConfigCas() {\n-        String key = \"user-service\";\n+        String key = \"user-service-cas\";\n         String group = \"org.apache.dubbo.service.UserService\";\n         String content = \"test\";\n-        assertTrue(configuration.publishConfigCas(key, group, content, null));\n         ConfigItem configItem = configuration.getConfigItem(key, group);\n+        assertTrue(configuration.publishConfigCas(key, group, content, configItem.getStat()));\n+        configItem = configuration.getConfigItem(key, group);\n         assertEquals(\"test\", configItem.getContent());\n         assertTrue(configuration.publishConfigCas(key, group, \"newtest\", configItem.getStat()));\n         try {\ndiff --git a/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/annotation/processing/util/TypeUtilsTest.java b/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/annotation/processing/util/TypeUtilsTest.java\n--- a/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/annotation/processing/util/TypeUtilsTest.java\n+++ b/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/annotation/processing/util/TypeUtilsTest.java\n@@ -25,6 +25,7 @@\n import org.apache.dubbo.metadata.tools.GenericTestService;\n import org.apache.dubbo.metadata.tools.TestServiceImpl;\n+import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n import javax.lang.model.element.Element;\n@@ -450,6 +451,7 @@ public void testListTypeElements() {\n     }\n     @Test\n+    @Disabled\n     public void testGetResource() throws URISyntaxException {\n         URL resource = getResource(processingEnv, testType);\n         assertNotNull(resource);",
    "output": "Fix testPublishConfigCas exec fail * fix testPublishConfigCas exec fail * fix AbstractInterfaceBuilderTest.build test case. * disable testGetResource"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n@@ -56,9 +56,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_SEPARATOR_ENCODED;\n import static org.apache.dubbo.common.constants.RegistryConstants.CATEGORY_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.EMPTY_PROTOCOL;\n-import static org.apache.dubbo.common.constants.RegistryConstants.OVERRIDE_PROTOCOL;\n-import static org.apache.dubbo.common.constants.RegistryConstants.ROUTE_PROTOCOL;\n-import static org.apache.dubbo.common.constants.RegistryConstants.ROUTE_SCRIPT_PROTOCOL;\n+import static org.apache.dubbo.common.constants.RegistryConstants.PROVIDERS_CATEGORY;\n import static org.apache.dubbo.common.url.component.DubboServiceAddressURL.PROVIDER_FIRST_KEYS;\n /**\n@@ -112,9 +110,9 @@ public void doUnsubscribe(URL url, NotifyListener listener) {\n     protected void evictURLCache(URL url) {\n         Map<String, ServiceAddressURL> oldURLs = stringUrls.remove(url);\n-        logger.info(\"Evicting urls for service \" + url.getServiceKey() + \", size \" + oldURLs.size());\n         try {\n             if (oldURLs != null && oldURLs.size() > 0) {\n+                logger.info(\"Evicting urls for service \" + url.getServiceKey() + \", size \" + oldURLs.size());\n                 Long currentTimestamp = System.currentTimeMillis();\n                 for (Map.Entry<String, ServiceAddressURL> entry : oldURLs.entrySet()) {\n                     waitForRemove.put(entry.getValue(), currentTimestamp);\n@@ -164,40 +162,28 @@ protected List<URL> toUrlsWithoutEmpty(URL consumer, Collection<String> provider\n             }\n         }\n+        evictURLCache(consumer);\n         stringUrls.put(consumer, newURLs);\n-        // destroy used urls\n-        try {\n-            if (oldURLs != null && oldURLs.size() > 0) {\n-                Long currentTimestamp = System.currentTimeMillis();\n-                for (Map.Entry<String, ServiceAddressURL> entry : oldURLs.entrySet()) {\n-                    waitForRemove.put(entry.getValue(), currentTimestamp);\n-                }\n-                if (CollectionUtils.isNotEmptyMap(waitForRemove)) {\n-                    if (semaphore.tryAcquire()) {\n-                        cacheRemovalScheduler.schedule(new RemovalTask(), cacheRemovalTaskIntervalInMillis, TimeUnit.MILLISECONDS);\n-                    }\n-                }\n-            }\n-        } catch (Exception e) {\n-            logger.warn(\"Failed to evict url for \" + consumer, e);\n-        }\n-\n         return new ArrayList<>(newURLs.values());\n     }\n     protected List<URL> toUrlsWithEmpty(URL consumer, String path, Collection<String> providers) {\n-        List<URL> urls;\n-        if (CollectionUtils.isEmpty(providers)) {\n-            urls = new ArrayList<>(1);\n+        List<URL> urls = new ArrayList<>(1);\n+        boolean isProviderPath = path.endsWith(PROVIDERS_CATEGORY);\n+        if (isProviderPath) {\n+            if (CollectionUtils.isNotEmpty(providers)) {\n+                urls = toUrlsWithoutEmpty(consumer, providers);\n+            } else {\n+                // clear cache on empty notification: unsubscribe or provider offline\n+                evictURLCache(consumer);\n+            }\n         } else {\n-            String rawProvider = providers.iterator().next();\n-            if (rawProvider.startsWith(OVERRIDE_PROTOCOL) || rawProvider.startsWith(ROUTE_PROTOCOL) || rawProvider.startsWith(ROUTE_SCRIPT_PROTOCOL)) {\n+            if (CollectionUtils.isNotEmpty(providers)) {\n                 urls = toConfiguratorsWithoutEmpty(consumer, providers);\n-            } else {\n-                urls = toUrlsWithoutEmpty(consumer, providers);\n             }\n         }\n+\n         if (urls.isEmpty()) {\n             int i = path.lastIndexOf(PATH_SEPARATOR);\n             String category = i < 0 ? path : path.substring(i + 1);\n@@ -207,6 +193,7 @@ protected List<URL> toUrlsWithEmpty(URL consumer, String path, Collection<String\n                     .build();\n             urls.add(empty);\n         }\n+\n         return urls;\n     }",
    "output": "Fix cache was deleted when startup"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshAppRuleListener.java\n@@ -37,7 +37,7 @@ public class MeshAppRuleListener implements ConfigurationListener {\n     private final VsDestinationGroupRuleDispatcher vsDestinationGroupRuleDispatcher = new VsDestinationGroupRuleDispatcher();\n-    private String appName;\n+    private final String appName;\n     private VsDestinationGroup vsDestinationGroupHolder;\n@@ -55,15 +55,15 @@ public void receiveConfigInfo(String configInfo) {\n             Yaml yaml = new Yaml();\n             Yaml yaml2 = new Yaml();\n-            Iterable objectIterable = yaml.loadAll(configInfo);\n+            Iterable<Object> objectIterable = yaml.loadAll(configInfo);\n             for (Object result : objectIterable) {\n                 Map resultMap = (Map) result;\n-                if (resultMap.get(\"kind\").equals(\"DestinationRule\")) {\n+                if (\"DestinationRule\".equals(resultMap.get(\"kind\"))) {\n                     DestinationRule destinationRule = yaml2.loadAs(yaml2.dump(result), DestinationRule.class);\n                     vsDestinationGroup.getDestinationRuleList().add(destinationRule);\n-                } else if (resultMap.get(\"kind\").equals(\"VirtualService\")) {\n+                } else if (\"VirtualService\".equals(resultMap.get(\"kind\"))) {\n                     VirtualServiceRule virtualServiceRule = yaml2.loadAs(yaml2.dump(result), VirtualServiceRule.class);\n                     vsDestinationGroup.getVirtualServiceRuleList().add(virtualServiceRule);\n                 }\n@@ -86,7 +86,7 @@ public void register(MeshRuleRouter subscriber) {\n         vsDestinationGroupRuleDispatcher.register(subscriber);\n     }\n-    //\n+\n     public void unregister(MeshRuleRouter sub) {\n         vsDestinationGroupRuleDispatcher.unregister(sub);\n     }\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleAddressListenerInterceptor.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleAddressListenerInterceptor.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleAddressListenerInterceptor.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleAddressListenerInterceptor.java\n@@ -28,18 +28,18 @@\n @Activate(order = 670)\n public class MeshRuleAddressListenerInterceptor implements AddressListener {\n-    private static final Object mark = new Object();\n-    private static ConcurrentHashMap<String, Object> appMap = new ConcurrentHashMap<String, Object>();\n+    private static final Object MARK = new Object();\n+    private static final ConcurrentHashMap<String, Object> APP_MAP = new ConcurrentHashMap<>();\n     @Override\n     public List<URL> notify(List<URL> addresses, URL consumerUrl, Directory registryDirectory) {\n         if (addresses != null && !addresses.isEmpty()) {\n-            for (URL serviceURL : addresses) {\n+            for (URL url : addresses) {\n-                String app = serviceURL.getRemoteApplication();\n+                String app = url.getRemoteApplication();\n                 if (app != null && !app.isEmpty()) {\n-                    if (appMap.putIfAbsent(app, mark) == null) {\n+                    if (APP_MAP.putIfAbsent(app, MARK) == null) {\n                         MeshRuleManager.subscribeAppRule(app);\n                     }\n                 }\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleManager.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleManager.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleManager.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleManager.java\n@@ -33,7 +33,7 @@ public final class MeshRuleManager {\n     private static final String MESH_RULE_DATA_ID_SUFFIX = \".MESHAPPRULE\";\n     private static final String GROUP = \"DEFAULT_GROUP\";\n-    private static ConcurrentHashMap<String, MeshAppRuleListener> appRuleListeners = new ConcurrentHashMap<>();\n+    private static final ConcurrentHashMap<String, MeshAppRuleListener> APP_RULE_LISTENERS = new ConcurrentHashMap<>();\n     public synchronized static void subscribeAppRule(String app) {\n@@ -57,11 +57,11 @@ public synchronized static void subscribeAppRule(String app) {\n         }\n         configuration.addListener(appRuleDataId, GROUP, meshAppRuleListener);\n-        appRuleListeners.put(app, meshAppRuleListener);\n+        APP_RULE_LISTENERS.put(app, meshAppRuleListener);\n     }\n     public static void register(String app, MeshRuleRouter subscriber) {\n-        MeshAppRuleListener meshAppRuleListener = appRuleListeners.get(app);\n+        MeshAppRuleListener meshAppRuleListener = APP_RULE_LISTENERS.get(app);\n         if (meshAppRuleListener == null) {\n             logger.warn(\"appRuleListener can't find when Router register\");\n             return;\n@@ -70,7 +70,7 @@ public static void register(String app, MeshRuleRouter subscriber) {\n     }\n     public static void unregister(MeshRuleRouter subscriber) {\n-        Collection<MeshAppRuleListener> listeners = appRuleListeners.values();\n+        Collection<MeshAppRuleListener> listeners = APP_RULE_LISTENERS.values();\n         for (MeshAppRuleListener listener : listeners) {\n             listener.unregister(subscriber);\n         }\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java\n@@ -53,7 +53,7 @@ public class MeshRuleRouter implements Router, VsDestinationGroupRuleListener {\n     private VsDestinationGroup vsDestinationGroup;\n-    private Map<String, String> sourcesLables = new HashMap<>();\n+    private Map<String, String> sourcesLabels = new HashMap<>();\n     protected List<Invoker<?>> invokerList = new ArrayList<>();\n@@ -63,7 +63,7 @@ public class MeshRuleRouter implements Router, VsDestinationGroupRuleListener {\n     public MeshRuleRouter(URL url) {\n         this.url = url;\n-        sourcesLables.putAll(url.getParameters());\n+        sourcesLabels.putAll(url.getParameters());\n     }\n     @Override\n@@ -146,6 +146,7 @@ private void registerAppRule(List<Invoker<?>> invokers) {\n     }\n+    @Override\n     public void onRuleChange(VsDestinationGroup vsDestinationGroup) {\n         this.vsDestinationGroup = vsDestinationGroup;\n         computeSubset();\n@@ -236,7 +237,7 @@ protected DubboRouteDetail findMatchDubboRouteDetail(List<DubboRouteDetail> dubb\n             //FIXME to deal with headers\n             for (DubboMatchRequest dubboMatchRequest : matchRequestList) {\n                 if (!DubboMatchRequest.isMatch(dubboMatchRequest, methodName, parameterTypeList, parameters,\n-                        sourcesLables,\n+                        sourcesLabels,\n                         new HashMap<>(), invocation.getAttachments(),\n                         new HashMap<>())) {\n                     match = false;\n@@ -320,22 +321,34 @@ protected boolean containMapKeyValue(Map<String, String> originMap, Map<String,\n     }\n-    // just for test\n+    /**\n+     * just for test\n+     * @param vsDestinationGroup\n+     */\n     protected void setVsDestinationGroup(VsDestinationGroup vsDestinationGroup) {\n         this.vsDestinationGroup = vsDestinationGroup;\n     }\n-    // just for test\n-    protected void setSourcesLables(Map<String, String> sourcesLables) {\n-        this.sourcesLables = sourcesLables;\n+    /**\n+     * just for test\n+     * @param sourcesLabels\n+     */\n+    protected void setSourcesLabels(Map<String, String> sourcesLabels) {\n+        this.sourcesLabels = sourcesLabels;\n     }\n-    // just for test\n+    /**\n+     * just for test\n+     * @param invokerList\n+     */\n     protected void setInvokerList(List<Invoker<?>> invokerList) {\n         this.invokerList = invokerList;\n     }\n-    // just for test\n+    /**\n+     * just for test\n+     * @param subsetMap\n+     */\n     protected void setSubsetMap(Map<String, List<Invoker<?>>> subsetMap) {\n         this.subsetMap = subsetMap;\n     }\n@@ -345,8 +358,8 @@ public VsDestinationGroup getVsDestinationGroup() {\n         return vsDestinationGroup;\n     }\n-    public Map<String, String> getSourcesLables() {\n-        return sourcesLables;\n+    public Map<String, String> getSourcesLabels() {\n+        return sourcesLabels;\n     }\n     public List<Invoker<?>> getInvokerList() {",
    "output": "Fix typo"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/registry/AddressListener.java b/dubbo-cluster/src/main/java/org/apache/dubbo/registry/AddressListener.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/registry/AddressListener.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/registry/AddressListener.java\n@@ -28,10 +28,13 @@ public interface AddressListener {\n     /**\n      * processing when receiving the address list\n      *\n-     * @param addresses            provider address list\n+     * @param addresses         provider address list\n      * @param consumerUrl\n      * @param registryDirectory\n      */\n     List<URL> notify(List<URL> addresses, URL consumerUrl, Directory registryDirectory);\n+    default void destroy(URL consumerUrl, Directory registryDirectory) {\n+    }\n+\n }\n\\ No newline at end of file",
    "output": "Make AddressListener destroyable * delete duplicate log line * Make AddressListener destroyable"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -234,6 +234,8 @@ public interface CommonConstants {\n      */\n     String RELEASE_KEY = \"release\";\n+    String PROTOBUF_MESSAGE_CLASS_NAME = \"com.google.protobuf.Message\";\n+\n     int MAX_PROXY_COUNT = 65535;\n     String MONITOR_KEY = \"monitor\";\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java\n@@ -20,16 +20,16 @@\n import org.apache.dubbo.common.stream.StreamObserver;\n import org.apache.dubbo.common.utils.ReflectUtils;\n-import com.google.protobuf.Message;\n-\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n+import java.util.Arrays;\n import java.util.stream.Stream;\n import static org.apache.dubbo.common.constants.CommonConstants.$ECHO;\n import static org.apache.dubbo.common.constants.CommonConstants.$INVOKE;\n import static org.apache.dubbo.common.constants.CommonConstants.$INVOKE_ASYNC;\n+import static org.apache.dubbo.common.constants.CommonConstants.PROTOBUF_MESSAGE_CLASS_NAME;\n /**\n  *\n@@ -101,10 +101,25 @@ private boolean needWrap() {\n         } else if ($ECHO.equals(methodName)) {\n             return true;\n         } else {\n-            if (parameterClasses.length != 1) {\n+            if (parameterClasses.length != 1 || parameterClasses[0] == null) {\n                 return true;\n             }\n-            return !Message.class.isAssignableFrom(parameterClasses[0]);\n+\n+            Class<?> clazz = parameterClasses[0];\n+            while (clazz != Object.class && clazz != null) {\n+                Class<?>[] interfaces = clazz.getInterfaces();\n+                if (interfaces.length > 0) {\n+                    for (Class<?> clazzInterface : interfaces) {\n+                        if (PROTOBUF_MESSAGE_CLASS_NAME.equalsIgnoreCase(clazzInterface.getName())) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+\n+                clazz = clazz.getSuperclass();\n+            }\n+\n+            return true;\n         }\n     }",
    "output": "Remove protobuf dependency from dubbo common * fix protobuf dependency * fix npe * fix npe"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n@@ -29,9 +29,11 @@\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelOption;\n import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoop;\n import io.netty.channel.socket.SocketChannel;\n import io.netty.util.AbstractReferenceCounted;\n import io.netty.util.AttributeKey;\n@@ -42,6 +44,7 @@\n import io.netty.util.concurrent.Promise;\n import java.net.InetSocketAddress;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -61,6 +64,8 @@ public class Connection extends AbstractReferenceCounted implements ReferenceCou\n     private final AtomicBoolean closed = new AtomicBoolean(false);\n     private final AtomicReference<Channel> channel = new AtomicReference<>();\n     private final ChannelFuture initPromise;\n+    private final Bootstrap bootstrap;\n+    private final ConnectionListener connectionListener = new ConnectionListener();\n     public Connection(URL url) {\n         url = ExecutorUtil.setThreadName(url, \"DubboClientHandler\");\n@@ -70,6 +75,7 @@ public Connection(URL url) {\n         this.connectTimeout = Math.max(3000, url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));\n         this.closeFuture = new DefaultPromise<>(GlobalEventExecutor.INSTANCE);\n         this.remote = getConnectAddress();\n+        this.bootstrap = create();\n         this.initPromise = connect();\n     }\n@@ -81,11 +87,7 @@ public Promise<Void> getCloseFuture() {\n         return closeFuture;\n     }\n-\n-    public ChannelFuture connect() {\n-        if (isClosed()) {\n-            return null;\n-        }\n+    private Bootstrap create() {\n         final Bootstrap bootstrap = new Bootstrap();\n         bootstrap.group(NettyEventLoopFactory.NIO_EVENT_LOOP_GROUP)\n                 .option(ChannelOption.SO_KEEPALIVE, true)\n@@ -112,8 +114,19 @@ protected void initChannel(SocketChannel ch) {\n                 // TODO support Socks5\n             }\n         });\n+        return bootstrap;\n+    }\n+\n+    public ChannelFuture connect() {\n+        if (isClosed()) {\n+            if (logger.isInfoEnabled()) {\n+                logger.info(String.format(\"%s aborted to reconnect cause connection closed. \", Connection.this));\n+            }\n+            return null;\n+        }\n+\n         final ChannelFuture promise = bootstrap.connect();\n-        promise.addListener(new ConnectionListener(this));\n+        promise.addListener(this.connectionListener);\n         return promise;\n     }\n@@ -123,13 +136,13 @@ public Channel getChannel() {\n     @Override\n     public String toString() {\n-        return \"(Ref=\" + ReferenceCountUtil.refCnt(this) + \",local=\" + (getChannel() == null ? null : getChannel().localAddress()) + \",remote=\" + getRemote();\n+        return super.toString() + \" (Ref=\" + ReferenceCountUtil.refCnt(this) + \",local=\" + (getChannel() == null ? null : getChannel().localAddress()) + \",remote=\" + getRemote();\n     }\n     public void onGoaway(Channel channel) {\n         if (this.channel.compareAndSet(channel, null)) {\n             if (logger.isInfoEnabled()) {\n-                logger.info(String.format(\"Connection:%s  goaway\", this));\n+                logger.info(String.format(\"%s goaway\", this));\n             }\n         }\n     }\n@@ -138,7 +151,7 @@ public void onConnected(Channel channel) {\n         this.channel.set(channel);\n         channel.attr(CONNECTION).set(this);\n         if (logger.isInfoEnabled()) {\n-            logger.info(String.format(\"Connection:%s connected \", this));\n+            logger.info(String.format(\"%s connected \", this));\n         }\n     }\n@@ -175,6 +188,9 @@ protected void deallocate() {\n     }\n     public void close() {\n+        if (logger.isInfoEnabled()) {\n+            logger.info(String.format(\"Connection:%s freed \", this));\n+        }\n         final Channel current = this.channel.get();\n         if (current != null) {\n             current.close();\n@@ -200,8 +216,26 @@ public URL getUrl() {\n         return url;\n     }\n-    private int getConnectTimeout() {\n-        return connectTimeout;\n+    class ConnectionListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) {\n+            if (future.isSuccess()) {\n+                return;\n+            }\n+            final Connection conn = Connection.this;\n+            if (conn.isClosed() || conn.refCnt() == 0) {\n+                if (logger.isInfoEnabled()) {\n+                    logger.info(String.format(\"%s aborted to reconnect. %s\", conn, future.cause().getMessage()));\n+                }\n+                return;\n+            }\n+            if (logger.isInfoEnabled()) {\n+                logger.info(String.format(\"%s is reconnecting, attempt=%d cause=%s\", conn, 0, future.cause().getMessage()));\n+            }\n+            final EventLoop loop = future.channel().eventLoop();\n+            loop.schedule((Runnable) conn::connect, 1L, TimeUnit.SECONDS);\n+        }\n     }\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n@@ -24,6 +24,7 @@\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n import io.netty.channel.EventLoop;\n+import io.netty.util.Attribute;\n import io.netty.util.AttributeKey;\n import java.util.concurrent.TimeUnit;\n@@ -39,10 +40,18 @@ public ConnectionHandler(Connection connection) {\n     }\n     public void onGoAway(Channel channel) {\n-        channel.attr(GO_AWAY_KEY).set(true);\n+        final Attribute<Boolean> attr = channel.attr(GO_AWAY_KEY);\n+        if (Boolean.TRUE.equals(attr.get())) {\n+            return;\n+        }\n+\n+        attr.set(true);\n         if (connection != null) {\n             connection.onGoaway(channel);\n         }\n+        if (log.isInfoEnabled()) {\n+            log.info(String.format(\"Channel %s go away ,schedule reconnect\", channel));\n+        }\n         reconnect(channel);\n     }\n@@ -65,8 +74,11 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E\n     @Override\n     public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-        reconnect(ctx.channel());\n         super.channelInactive(ctx);\n+        final Attribute<Boolean> goawayAttr = ctx.channel().attr(GO_AWAY_KEY);\n+        if (!Boolean.TRUE.equals(goawayAttr.get())) {\n+            reconnect(ctx.channel());\n+        }\n     }\n     private void reconnect(Channel channel) {\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionListener.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionListener.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionListener.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionListener.java\n@@ -1,48 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.dubbo.remoting.api;\n-\n-import org.apache.dubbo.common.logger.Logger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n-\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.EventLoop;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-public class ConnectionListener implements ChannelFutureListener {\n-    private static final Logger log = LoggerFactory.getLogger(ConnectionListener.class);\n-\n-    private final Connection connection;\n-\n-    public ConnectionListener(Connection connection) {\n-        this.connection = connection;\n-    }\n-\n-    @Override\n-    public void operationComplete(ChannelFuture channelFuture) {\n-        if (!channelFuture.isSuccess()) {\n-            if (log.isInfoEnabled()) {\n-                log.info(String.format(\"Connection %s is reconnecting, attempt=%d\", connection, 0));\n-            }\n-            final EventLoop loop = channelFuture.channel().eventLoop();\n-            loop.schedule((Runnable) connection::connect, 1L, TimeUnit.SECONDS);\n-        }\n-    }\n-}\n\\ No newline at end of file",
    "output": "Fix mem leak caused by duplicate reconnect task"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Proxy.java b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Proxy.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Proxy.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Proxy.java\n@@ -20,7 +20,7 @@\n import org.apache.dubbo.common.utils.ReflectUtils;\n import java.lang.ref.Reference;\n-import java.lang.ref.WeakReference;\n+import java.lang.ref.SoftReference;\n import java.lang.reflect.InvocationHandler;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n@@ -50,6 +50,8 @@ public Object invoke(Object proxy, Method method, Object[] args) {\n     private static final AtomicLong PROXY_CLASS_COUNTER = new AtomicLong(0);\n     private static final String PACKAGE_NAME = Proxy.class.getPackage().getName();\n     private static final Map<ClassLoader, Map<String, Object>> PROXY_CACHE_MAP = new WeakHashMap<ClassLoader, Map<String, Object>>();\n+    // cache class, avoid PermGen OOM.\n+    private static final Map<ClassLoader, Map<String, Object>> PROXY_CLASS_MAP = new WeakHashMap<ClassLoader, Map<String, Object>>();\n     private static final Object PENDING_GENERATION_MARKER = new Object();\n@@ -103,8 +105,11 @@ public static Proxy getProxy(ClassLoader cl, Class<?>... ics) {\n         // get cache by class loader.\n         final Map<String, Object> cache;\n+        // cache class\n+        final Map<String, Object> classCache;\n         synchronized (PROXY_CACHE_MAP) {\n             cache = PROXY_CACHE_MAP.computeIfAbsent(cl, k -> new HashMap<>());\n+            classCache = PROXY_CLASS_MAP.computeIfAbsent(cl, k -> new HashMap<>());\n         }\n         Proxy proxy = null;\n@@ -118,14 +123,38 @@ public static Proxy getProxy(ClassLoader cl, Class<?>... ics) {\n                     }\n                 }\n-                if (value == PENDING_GENERATION_MARKER) {\n-                    try {\n-                        cache.wait();\n-                    } catch (InterruptedException e) {\n+                // get Class by key.\n+                Object clazzObj = classCache.get(key);\n+                if (null == clazzObj || clazzObj instanceof Reference<?>) {\n+                    Class<?> clazz = null;\n+                    if (clazzObj instanceof Reference<?>) {\n+                        clazz = (Class<?>) ((Reference<?>) clazzObj).get();\n+                    }\n+\n+                    if (null == clazz) {\n+                        if (value == PENDING_GENERATION_MARKER) {\n+                            try {\n+                                cache.wait();\n+                            } catch (InterruptedException e) {\n+                            }\n+                        } else {\n+                            cache.put(key, PENDING_GENERATION_MARKER);\n+                            break;\n+                        }\n+                    } else {\n+                        try {\n+                            proxy = (Proxy) clazz.newInstance();\n+                            return proxy;\n+                        } catch (InstantiationException | IllegalAccessException e) {\n+                            throw new RuntimeException(e);\n+                        } finally {\n+                            if (null == proxy) {\n+                                cache.remove(key);\n+                            } else {\n+                                cache.put(key, new SoftReference<>(proxy));\n+                            }\n+                        }\n                     }\n-                } else {\n-                    cache.put(key, PENDING_GENERATION_MARKER);\n-                    break;\n                 }\n             }\n             while (true);\n@@ -190,7 +219,7 @@ public static Proxy getProxy(ClassLoader cl, Class<?>... ics) {\n             ccp.setClassName(pcn);\n             ccp.addField(\"public static java.lang.reflect.Method[] methods;\");\n             ccp.addField(\"private \" + InvocationHandler.class.getName() + \" handler;\");\n-            ccp.addConstructor(Modifier.PUBLIC, new Class<?>[]{InvocationHandler.class}, new Class<?>[0], \"handler=$1;\");\n+            ccp.addConstructor(Modifier.PUBLIC, new Class<?>[] {InvocationHandler.class}, new Class<?>[0], \"handler=$1;\");\n             ccp.addDefaultConstructor();\n             Class<?> clazz = ccp.toClass();\n             clazz.getField(\"methods\").set(null, methods.toArray(new Method[0]));\n@@ -204,6 +233,10 @@ public static Proxy getProxy(ClassLoader cl, Class<?>... ics) {\n             ccm.addMethod(\"public Object newInstance(\" + InvocationHandler.class.getName() + \" h){ return new \" + pcn + \"($1); }\");\n             Class<?> pc = ccm.toClass();\n             proxy = (Proxy) pc.newInstance();\n+\n+            synchronized (classCache) {\n+                classCache.put(key, new SoftReference<Class<?>>(pc));\n+            }\n         } catch (RuntimeException e) {\n             throw e;\n         } catch (Exception e) {\n@@ -220,7 +253,7 @@ public static Proxy getProxy(ClassLoader cl, Class<?>... ics) {\n                 if (proxy == null) {\n                     cache.remove(key);\n                 } else {\n-                    cache.put(key, new WeakReference<Proxy>(proxy));\n+                    cache.put(key, new SoftReference<Proxy>(proxy));\n                 }\n                 cache.notifyAll();\n             }",
    "output": "Fix cache Class avoid PermGen space OOM in dubbo3.0 * cache Class avoid PermGen space OOM * optimization cache Class avoid PermGen space OOM * optimization cache Class avoid PermGen space OOM * Optimize Proxy WeakReference to SoftReference"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n@@ -168,6 +168,9 @@ public void doSubscribe(final URL url, final NotifyListener listener) {\n                 for (String path : toCategoriesPath(url)) {\n                     ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.computeIfAbsent(url, k -> new ConcurrentHashMap<>());\n                     ChildListener zkListener = listeners.computeIfAbsent(listener, k -> new RegistryChildListenerImpl(url, path, k, latch));\n+                    if (zkListener instanceof RegistryChildListenerImpl) {\n+                        ((RegistryChildListenerImpl) zkListener).setLatch(latch);\n+                    }\n                     zkClient.create(path, false);\n                     List<String> children = zkClient.addChildListener(path, zkListener);\n                     if (children != null) {\n@@ -320,6 +323,10 @@ protected void doNotify(Object rawAddresses) {\n             };\n         }\n+        public void setLatch(CountDownLatch latch) {\n+            this.latch = latch;\n+        }\n+\n         @Override\n         public void childChanged(String path, List<String> children) {\n             try {",
    "output": "Fix recover and zk notify concurrent problem. * fix recover and zk notify concurrent problem. * maybe npe fix"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/DubboConfigInitializationPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/DubboConfigInitializationPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/DubboConfigInitializationPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/DubboConfigInitializationPostProcessor.java\n@@ -75,14 +75,6 @@ public Object postProcessBeforeInitialization(Object bean, String beanName) thro\n     @Override\n     public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n-//        try {\n-//            if (bean instanceof ReferenceBean) {\n-//                ReferenceBean referenceBean = (ReferenceBean) bean;\n-//                referenceBeanManager.addReference(referenceBean);\n-//            }\n-//        } catch (Exception e) {\n-//            throw new BeanInitializationException(\"Initialization reference bean failed\", e);\n-//        }\n         return bean;\n     }\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBeanManager.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBeanManager.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBeanManager.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBeanManager.java\n@@ -94,13 +94,13 @@ public void setApplicationContext(ApplicationContext applicationContext) throws\n      * @throws Exception\n      */\n     public void prepareReferenceBeans() throws Exception {\n-        for (ReferenceBean referenceBean : getReferences()) {\n-            initReferenceBean(referenceBean);\n-        }\n-\n         // prepare all reference beans\n         Map<String, ReferenceBean> referenceBeanMap = applicationContext.getBeansOfType(ReferenceBean.class, true, false);\n         for (ReferenceBean referenceBean : referenceBeanMap.values()) {\n+            addReference(referenceBean);\n+        }\n+\n+        for (ReferenceBean referenceBean : getReferences()) {\n             initReferenceBean(referenceBean);\n         }\n         initialized = true;\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n@@ -252,8 +252,8 @@ private ReferenceBean getReferenceBean(Class<?> injectedType, AnnotationAttribut\n                 beanDefinitionRegistry.registerBeanDefinition(referenceBeanName, beanDefinition);\n                 getBeanFactory().registerSingleton(referenceBeanName, referenceBean);\n-\n-                //referenceBeanManager.addReference(referenceBean);\n+                //cache reference bean, avoid re-inject same element after prepare reference bean\n+                referenceBeanManager.addReference(referenceBean);\n             } catch (Exception e) {\n                 throw new Exception(\"Create dubbo reference bean failed\", e);\n             }",
    "output": "Fix reference cache"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientStream.java\n@@ -109,10 +109,9 @@ public void write(Object obj, ChannelPromise promise) throws IOException {\n                 .set(TripleConstant.TIMEOUT, invocation.get(CommonConstants.TIMEOUT_KEY) +\"m\")\n                 .set(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS);\n-        final String version = (String) invocation.getObjectAttachment(CommonConstants.VERSION_KEY);\n+        final String version = invocation.getInvoker().getUrl().getVersion();\n         if (version != null) {\n             headers.set(TripleConstant.SERVICE_VERSION, version);\n-            invocation.getObjectAttachments().remove(CommonConstants.VERSION_KEY);\n         }\n         final String app = (String) invocation.getObjectAttachment(CommonConstants.APPLICATION_KEY);\n@@ -121,7 +120,7 @@ public void write(Object obj, ChannelPromise promise) throws IOException {\n             invocation.getObjectAttachments().remove(CommonConstants.APPLICATION_KEY);\n         }\n-        final String group = (String) invocation.getObjectAttachment(CommonConstants.GROUP_KEY);\n+        final String group = invocation.getInvoker().getUrl().getGroup();\n         if (group != null) {\n             headers.set(TripleConstant.SERVICE_GROUP, group);\n             invocation.getObjectAttachments().remove(CommonConstants.GROUP_KEY);\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2FrameServerHandler.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2FrameServerHandler.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2FrameServerHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2FrameServerHandler.java\n@@ -130,6 +130,10 @@ public void onHeadersRead(ChannelHandlerContext ctx, Http2HeadersFrame msg) thro\n         }\n         String[] parts = path.split(\"/\");\n+        if (parts.length != 3) {\n+            responseErr(ctx, GrpcStatus.fromCode(Code.UNIMPLEMENTED).withDescription(\"Bad path format:\" + path));\n+            return;\n+        }\n         String serviceName = parts[1];\n         String originalMethodName = parts[2];\n         String methodName = Character.toLowerCase(originalMethodName.charAt(0)) + originalMethodName.substring(1);",
    "output": "Add triple version and group header"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture2.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture2.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture2.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture2.java\n@@ -32,6 +32,7 @@\n import io.netty.channel.Channel;\n+import java.net.InetSocketAddress;\n import java.text.SimpleDateFormat;\n import java.util.Date;\n import java.util.Map;\n@@ -204,7 +205,12 @@ private void doReceived(Response res) {\n         } else if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {\n             this.completeExceptionally(new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, null, connection.getRemote(), res.getErrorMessage()));\n         } else {\n-            this.completeExceptionally(new RemotingException(null, connection.getRemote(), res.getErrorMessage()));\n+            if (connection.getChannel() != null) {\n+                final InetSocketAddress local = (InetSocketAddress) connection.getChannel().localAddress();\n+                this.completeExceptionally(new RemotingException(local, connection.getRemote(), res.getErrorMessage()));\n+            } else {\n+                this.completeExceptionally(new RemotingException(null, connection.getRemote(), res.getErrorMessage()));\n+            }\n         }\n         // the result is returning, but the caller thread may still waiting\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -44,6 +44,8 @@ public void configServerPipeline(ChannelPipeline pipeline, SslContext sslContext\n                 .gracefulShutdownTimeoutMillis(10000)\n                 .initialSettings(new Http2Settings()\n                         .maxHeaderListSize(8192)\n+                        .maxFrameSize(2 << 16)\n+                        .maxConcurrentStreams(Integer.MAX_VALUE)\n                         .initialWindowSize(1048576))\n                 .frameLogger(SERVER_LOGGER)\n                 .build();\n@@ -61,6 +63,8 @@ public void configClientPipeline(ChannelPipeline pipeline, SslContext sslContext\n         final Http2FrameCodec codec = Http2FrameCodecBuilder.forClient()\n                 .initialSettings(new Http2Settings()\n                         .maxHeaderListSize(8192)\n+                        .maxFrameSize(2 << 16)\n+                        .maxConcurrentStreams(Integer.MAX_VALUE)\n                         .initialWindowSize(1048576))\n                 .gracefulShutdownTimeoutMillis(10000)\n                 .frameLogger(CLIENT_LOGGER)\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleUtil.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleUtil.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleUtil.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleUtil.java\n@@ -70,10 +70,6 @@ public static void setClientStream(Channel channel, ClientStream clientStream) {\n         channel.attr(TripleUtil.CLIENT_STREAM_KEY).set(clientStream);\n     }\n-    public static void setClientStream(ChannelHandlerContext ctx, ClientStream clientStream) {\n-        setClientStream(ctx.channel(), clientStream);\n-    }\n-\n     public static ClientStream getClientStream(ChannelHandlerContext ctx) {\n         return ctx.channel().attr(TripleUtil.CLIENT_STREAM_KEY).get();\n     }\n@@ -94,15 +90,16 @@ public static void responseErr(ChannelHandlerContext ctx, GrpcStatus status) {\n                 .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n                 .setInt(TripleConstant.STATUS_KEY, status.code.code)\n                 .set(TripleConstant.MESSAGE_KEY, getErrorMsg(status));\n-        ctx.write(new DefaultHttp2HeadersFrame(trailers, true));\n+        ctx.writeAndFlush(new DefaultHttp2HeadersFrame(trailers, true));\n     }\n     public static String getErrorMsg(GrpcStatus status) {\n         final String msg;\n         if (status.cause == null) {\n             msg = status.description;\n         } else {\n-            msg = StringUtils.toString(status.description, status.cause);\n+            String placeHolder = status.description == null ? \"\" : status.description;\n+            msg = StringUtils.toString(placeHolder, status.cause);\n         }\n         return percentEncode(msg);\n     }\n@@ -206,10 +203,11 @@ public static <T> T unpack(InputStream is, Class<T> clz) {\n             return req;\n         } catch (IOException e) {\n             throw new RuntimeException(\"Failed to unpack req\", e);\n-        }finally {\n+        } finally {\n             closeQuietly(is);\n         }\n     }\n+\n     private static void closeQuietly(Closeable c) {\n         if (c != null) {\n             try {\n@@ -273,14 +271,6 @@ public static byte[] encodeBase64(byte[] in) {\n         return BASE64_ENCODER.encode(in);\n     }\n-    public static byte[] decodeBase64(byte[] in) {\n-        return BASE64_DECODER.decode(in);\n-    }\n-\n-    public static byte[] decodeBase64(String in) {\n-        return BASE64_DECODER.decode(in.getBytes(StandardCharsets.UTF_8));\n-    }\n-\n     public static Object decodeObjFromHeader(URL url, CharSequence value, MultipleSerialization serialization) throws InvalidProtocolBufferException {\n         final byte[] decode = decodeASCIIByte(value);\n         final TripleWrapper.TripleRequestWrapper wrapper = TripleWrapper.TripleRequestWrapper.parseFrom(decode);",
    "output": "Add initinal max frame size and max concurrent stream"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java\n@@ -130,6 +130,9 @@ protected Map<String, Object> parseHeadersToMap(Http2Headers headers) {\n         Map<String, Object> attachments = new HashMap<>();\n         for (Map.Entry<CharSequence, CharSequence> header : headers) {\n             String key = header.getKey().toString();\n+            if(Http2Headers.PseudoHeaderName.isPseudoHeader(key)){\n+                continue;\n+            }\n             if (ENABLE_ATTACHMENT_WRAP) {\n                 if (key.endsWith(\"-tw-bin\") && key.length() > 7) {\n@@ -156,6 +159,9 @@ protected Map<String, Object> parseHeadersToMap(Http2Headers headers) {\n     protected void convertAttachment(Http2Headers trailers, Map<String, Object> attachments) throws IOException {\n         for (Map.Entry<String, Object> entry : attachments.entrySet()) {\n             final String key = entry.getKey().toLowerCase(Locale.ROOT);\n+            if(Http2Headers.PseudoHeaderName.isPseudoHeader(key)){\n+                continue;\n+            }\n             final Object v = entry.getValue();\n             if (!ENABLE_ATTACHMENT_WRAP) {\n                 if (v instanceof String) {\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ServerStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ServerStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ServerStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ServerStream.java\n@@ -27,6 +27,7 @@\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n+import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.MethodDescriptor;\n@@ -183,12 +184,12 @@ private void unaryInvoke() {\n                     ClassLoadUtil.switchContextLoader(tccl);\n                 }\n-                final Http2Headers trailers = new DefaultHttp2Headers()\n-                        .setInt(TripleConstant.STATUS_KEY, GrpcStatus.Code.OK.code);\n+                final Http2Headers trailers = new DefaultHttp2Headers();\n                 final Map<String, Object> attachments = response.getObjectAttachments();\n                 if (attachments != null) {\n                     convertAttachment(trailers, attachments);\n                 }\n+                trailers.setInt(TripleConstant.STATUS_KEY, GrpcStatus.Code.OK.code);\n                 ctx.write(new DefaultHttp2HeadersFrame(http2Headers));\n                 final DefaultHttp2DataFrame data = new DefaultHttp2DataFrame(buf);\n                 ctx.write(data);\n@@ -206,6 +207,7 @@ private void unaryInvoke() {\n         };\n         future.whenComplete(onComplete);\n+        RpcContext.removeContext();\n     }\n@@ -277,6 +279,15 @@ private Invocation buildInvocation() {\n         inv.setParameterTypes(methodDescriptor.getParameterClasses());\n         inv.setReturnTypes(methodDescriptor.getReturnTypes());\n         final Map<String, Object> attachments = parseHeadersToMap(getHeaders());\n+        attachments.remove(\"content-type\");\n+        attachments.remove(\"interface\");\n+        attachments.remove(\"tri-service-version\");\n+        attachments.remove(\"tri-service-group\");\n+        attachments.remove(\"serialization\");\n+        attachments.remove(\"te\");\n+        attachments.remove(\"path\");\n+        attachments.remove(\"grpc-status\");\n+        attachments.remove(\"grpc-message\");\n         inv.setObjectAttachments(attachments);\n         return inv;\n     }",
    "output": "Remove rpc context to avoid http2 headers override"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n@@ -31,6 +31,7 @@\n import io.netty.util.AttributeKey;\n import io.netty.util.Timer;\n+import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n @ChannelHandler.Sharable\n@@ -43,6 +44,7 @@ public class ConnectionHandler extends ChannelInboundHandlerAdapter {\n     private final Timer timer;\n     private final Bootstrap bootstrap;\n     private final Connection connection;\n+    private final Semaphore permit = new Semaphore(1);\n     private volatile long lastReconnect;\n     public ConnectionHandler(Connection connection, Bootstrap bootstrap, Timer timer) {\n@@ -105,7 +107,9 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n             ctx.fireChannelInactive();\n             return;\n         }\n-        tryReconnect(connection);\n+        if (connection.getChannel() == null || connection.getChannel().equals(ctx.channel())) {\n+            tryReconnect(connection);\n+        }\n         ctx.fireChannelInactive();\n     }\n@@ -115,7 +119,7 @@ private void tryReconnect(Connection connection) {\n                 if (log.isInfoEnabled()) {\n                     log.info(String.format(\"Connection %s inactive, schedule fast reconnect\", connection));\n                 }\n-                reconnect(connection, 1);\n+                reconnect(connection, 4);\n             } else {\n                 if (log.isInfoEnabled()) {\n                     log.info(String.format(\"Connection %s inactive, schedule normal reconnect\", connection));\n@@ -134,11 +138,14 @@ private void reconnect(final Connection connection, final int attempts) {\n         }\n         int nextAttempt = Math.min(BACKOFF_CAP, attempts + 1);\n-        timer.newTimeout(timeout1 -> tryReconnect(connection, nextAttempt), timeout, TimeUnit.MILLISECONDS);\n+        if (permit.tryAcquire()) {\n+            timer.newTimeout(timeout1 -> tryReconnect(connection, nextAttempt), timeout, TimeUnit.MILLISECONDS);\n+        }\n     }\n     private void tryReconnect(final Connection connection, final int nextAttempt) {\n+        permit.release();\n         if (connection.isClosed() || bootstrap.config().group().isShuttingDown()) {\n             return;\n@@ -162,7 +169,11 @@ private void tryReconnect(final Connection connection, final int nextAttempt) {\n             if (future.isSuccess()) {\n                 final Channel channel = future.channel();\n                 if (!connection.isClosed()) {\n-                    connection.onConnected(channel);\n+                    if (connection.getChannel() == null || !connection.getChannel().isActive()) {\n+                        connection.onConnected(channel);\n+                    } else {\n+                        channel.close();\n+                    }\n                 } else {\n                     channel.close();\n                 }",
    "output": "Fix reconnect bug"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n@@ -258,7 +258,7 @@ public Result invoke(final Invocation invocation) throws RpcException {\n         // binding attachments into invocation.\n         Map<String, Object> contextAttachments = RpcContext.getContext().getObjectAttachments();\n         if (contextAttachments != null && contextAttachments.size() != 0) {\n-            ((RpcInvocation) invocation).addObjectAttachments(contextAttachments);\n+            ((RpcInvocation) invocation).addObjectAttachmentsIfAbsent(contextAttachments);\n         }\n         List<Invoker<T>> invokers = list(invocation);\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ConsumerContextFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ConsumerContextFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ConsumerContextFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ConsumerContextFilter.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.rpc.filter;\n import org.apache.dubbo.common.extension.Activate;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.rpc.AsyncRpcResult;\n import org.apache.dubbo.rpc.Filter;\n@@ -28,6 +29,8 @@\n import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.TimeoutCountDown;\n+import java.util.Map;\n+\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;\n import static org.apache.dubbo.common.constants.CommonConstants.REMOTE_APPLICATION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;\n@@ -52,6 +55,17 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept\n             ((RpcInvocation) invocation).setInvoker(invoker);\n         }\n+        Map<String, Object> contextAttachments = RpcContext.getContext().getObjectAttachments();\n+        if (CollectionUtils.isNotEmptyMap(contextAttachments)) {\n+            /**\n+             * invocation.addAttachmentsIfAbsent(context){@link RpcInvocation#addAttachmentsIfAbsent(Map)}should not be used here,\n+             * because the {@link RpcContext#setAttachment(String, String)} is passed in the Filter when the call is triggered\n+             * by the built-in retry mechanism of the Dubbo. The attachment to update RpcContext will no longer work, which is\n+             * a mistake in most cases (for example, through Filter to RpcContext output traceId and spanId and other information).\n+             */\n+            ((RpcInvocation) invocation).addObjectAttachments(contextAttachments);\n+        }\n+\n         // pass default timeout set by end user (ReferenceConfig)\n         Object countDown = context.get(TIME_COUNTDOWN_KEY);\n         if (countDown != null) {\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java\n@@ -145,17 +145,6 @@ public Result invoke(Invocation inv) throws RpcException {\n             invocation.addObjectAttachmentsIfAbsent(attachment);\n         }\n-        Map<String, Object> contextAttachments = RpcContext.getContext().getObjectAttachments();\n-        if (CollectionUtils.isNotEmptyMap(contextAttachments)) {\n-            /**\n-             * invocation.addAttachmentsIfAbsent(context){@link RpcInvocation#addAttachmentsIfAbsent(Map)}should not be used here,\n-             * because the {@link RpcContext#setAttachment(String, String)} is passed in the Filter when the call is triggered\n-             * by the built-in retry mechanism of the Dubbo. The attachment to update RpcContext will no longer work, which is\n-             * a mistake in most cases (for example, through Filter to RpcContext output traceId and spanId and other information).\n-             */\n-            invocation.addObjectAttachments(contextAttachments);\n-        }\n-\n         invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));\n         RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);",
    "output": "Fix attachments override"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n@@ -34,7 +34,6 @@\n import io.netty.channel.ChannelOption;\n import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n-import io.netty.channel.DefaultChannelPromise;\n import io.netty.channel.socket.SocketChannel;\n import io.netty.util.AbstractReferenceCounted;\n import io.netty.util.AttributeKey;\n@@ -99,7 +98,7 @@ public ChannelPromise connect() {\n                 .remoteAddress(getConnectAddress())\n                 .channel(socketChannelClass());\n-        final ConnectionHandler connectionHandler = new ConnectionHandler(this,bootstrap, TIMER);\n+        final ConnectionHandler connectionHandler = new ConnectionHandler(this, bootstrap, TIMER);\n         bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectTimeout);\n         bootstrap.handler(new ChannelInitializer<SocketChannel>() {\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n@@ -51,7 +51,8 @@ public ConnectionHandler(Connection connection, Bootstrap bootstrap, Timer timer\n         this.timer = timer;\n     }\n-    public ChannelPromise connect(){\n+\n+    public ChannelPromise connect() {\n         final ChannelFuture init = bootstrap.connect();\n         final DefaultChannelPromise promise = new DefaultChannelPromise(init.channel());\n         init.addListener(future -> {\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientStream.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientStream.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientStream.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientStream.java\n@@ -47,8 +47,6 @@\n import io.netty.handler.codec.http2.Http2StreamChannel;\n import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\n import io.netty.util.AsciiString;\n-import io.netty.util.concurrent.Future;\n-import io.netty.util.concurrent.GenericFutureListener;\n import java.io.IOException;\n import java.io.InputStream;\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java\n@@ -21,7 +21,6 @@\n import org.apache.dubbo.remoting.api.Http2WireProtocol;\n import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelInboundHandlerAdapter;\n import io.netty.channel.ChannelPipeline;\n import io.netty.channel.SimpleChannelInboundHandler;\n import io.netty.handler.codec.http2.Http2FrameCodec;",
    "output": "Fix codestyle"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java\n@@ -33,6 +33,8 @@\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelOption;\n import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultChannelPromise;\n import io.netty.channel.socket.SocketChannel;\n import io.netty.util.AbstractReferenceCounted;\n import io.netty.util.AttributeKey;\n@@ -66,18 +68,17 @@ public class Connection extends AbstractReferenceCounted implements ReferenceCou\n     private final InetSocketAddress remote;\n     private final AtomicBoolean closed = new AtomicBoolean(false);\n     private final AtomicReference<Channel> channel = new AtomicReference<>();\n-    private final ChannelFuture initConnectFuture;\n+    private final ChannelPromise initPromise;\n     public Connection(URL url) {\n         url = ExecutorUtil.setThreadName(url, \"DubboClientHandler\");\n         url = url.addParameterIfAbsent(THREADPOOL_KEY, DEFAULT_CLIENT_THREADPOOL);\n         this.url = url;\n         this.protocol = ExtensionLoader.getExtensionLoader(WireProtocol.class).getExtension(url.getProtocol());\n-        this.connectTimeout = url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT);\n+        this.connectTimeout = Math.max(3000, url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));\n         this.closeFuture = new DefaultPromise<>(GlobalEventExecutor.INSTANCE);\n         this.remote = getConnectAddress();\n-        final Bootstrap bootstrap = open();\n-        this.initConnectFuture = bootstrap.connect();\n+        this.initPromise = connect();\n     }\n     public static Connection getConnectionFromChannel(Channel channel) {\n@@ -89,7 +90,7 @@ public Promise<Void> getCloseFuture() {\n     }\n-    public Bootstrap open() {\n+    public ChannelPromise connect() {\n         final Bootstrap bootstrap = new Bootstrap();\n         bootstrap.group(NettyEventLoopFactory.NIO_EVENT_LOOP_GROUP)\n                 .option(ChannelOption.SO_KEEPALIVE, true)\n@@ -98,8 +99,8 @@ public Bootstrap open() {\n                 .remoteAddress(getConnectAddress())\n                 .channel(socketChannelClass());\n-        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.max(3000, connectTimeout));\n-        final ConnectionHandler connectionHandler = new ConnectionHandler(bootstrap, TIMER);\n+        final ConnectionHandler connectionHandler = new ConnectionHandler(this,bootstrap, TIMER);\n+        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectTimeout);\n         bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n             @Override\n@@ -116,7 +117,7 @@ protected void initChannel(SocketChannel ch) {\n                 // TODO support Socks5\n             }\n         });\n-        return bootstrap;\n+        return connectionHandler.connect();\n     }\n     public Channel getChannel() {\n@@ -139,14 +140,16 @@ public void onGoaway(Channel channel) {\n     public void onConnected(Channel channel) {\n         this.channel.set(channel);\n         channel.attr(CONNECTION).set(this);\n+        this.initPromise.trySuccess();\n         if (logger.isInfoEnabled()) {\n             logger.info(String.format(\"Connection:%s connected \", this));\n         }\n     }\n-    public void connectSync(){\n-        this.initConnectFuture.awaitUninterruptibly();\n+    public void connectSync() {\n+        this.initPromise.awaitUninterruptibly(this.connectTimeout);\n     }\n+\n     public boolean isAvailable() {\n         final Channel channel = getChannel();\n         return channel != null && channel.isActive();\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ConnectionHandler.java\n@@ -21,10 +21,13 @@\n import io.netty.bootstrap.Bootstrap;\n import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n import io.netty.channel.ChannelFutureListener;\n import io.netty.channel.ChannelHandler;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultChannelPromise;\n import io.netty.util.AttributeKey;\n import io.netty.util.Timer;\n@@ -35,20 +38,33 @@ public class ConnectionHandler extends ChannelInboundHandlerAdapter {\n     private static final Logger log = LoggerFactory.getLogger(ConnectionHandler.class);\n     private static final int MIN_FAST_RECONNECT_INTERVAL = 4000;\n-    private static final int BACKOFF_CAP = 15;\n+    private static final int BACKOFF_CAP = 13;\n     private static final AttributeKey<Boolean> GO_AWAY_KEY = AttributeKey.valueOf(\"dubbo_channel_goaway\");\n     private final Timer timer;\n     private final Bootstrap bootstrap;\n+    private final Connection connection;\n     private volatile long lastReconnect;\n-    public ConnectionHandler(Bootstrap bootstrap, Timer timer) {\n+    public ConnectionHandler(Connection connection, Bootstrap bootstrap, Timer timer) {\n+        this.connection = connection;\n         this.bootstrap = bootstrap;\n         this.timer = timer;\n+\n+    }\n+    public ChannelPromise connect(){\n+        final ChannelFuture init = bootstrap.connect();\n+        final DefaultChannelPromise promise = new DefaultChannelPromise(init.channel());\n+        init.addListener(future -> {\n+            if (!future.isSuccess()) {\n+                promise.tryFailure(future.cause());\n+                tryReconnect(connection);\n+            }\n+        });\n+        return promise;\n     }\n     public void onGoAway(Channel channel) {\n         channel.attr(GO_AWAY_KEY).set(true);\n-        final Connection connection = Connection.getConnectionFromChannel(channel);\n         if (connection != null) {\n             connection.onGoaway(channel);\n         }\n@@ -64,6 +80,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {\n         }\n     }\n+\n     @Override\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         log.warn(String.format(\"Channel error:%s\", ctx.channel()), cause);\n@@ -87,7 +104,6 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n             ctx.fireChannelInactive();\n             return;\n         }\n-        Connection connection = Connection.getConnectionFromChannel(ctx.channel());\n         tryReconnect(connection);\n         ctx.fireChannelInactive();\n     }\n@@ -130,7 +146,7 @@ private void tryReconnect(final Connection connection, final int nextAttempt) {\n             log.info(String.format(\"Connection %s is reconnecting, attempt=%d\", connection, nextAttempt));\n         }\n-        bootstrap.connect(connection.getRemote()).addListener((ChannelFutureListener) future -> {\n+        bootstrap.connect().addListener((ChannelFutureListener) future -> {\n             if (connection.isClosed() || bootstrap.config().group().isShuttingDown()) {\n                 if (future.isSuccess()) {\n                     Channel ch = future.channel();\ndiff --git a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java\n@@ -93,14 +93,15 @@ protected Result doInvoke(final Invocation invocation) throws Throwable {\n             req.setTwoWay(true);\n             req.setData(inv);\n+            connection.connectSync();\n+\n             DefaultFuture2 future = DefaultFuture2.newFuture(this.connection, req, timeout, executor);\n             final CompletableFuture<AppResponse> respFuture = future.thenApply(obj -> (AppResponse) obj);\n             // save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter\n             FutureContext.getContext().setCompatibleFuture(respFuture);\n             AsyncRpcResult result = new AsyncRpcResult(respFuture, inv);\n             result.setExecutor(executor);\n-            connection.connectSync();\n             if (!connection.isAvailable()) {\n                 Response response = new Response(req.getId(), req.getVersion());",
    "output": "Fix first connect failed"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n@@ -96,7 +96,6 @@ public interface Constants {\n      */\n     String REFER_KEY = \"refer\";\n-    String TIMESTAMP_KEY = \"timestamp\";\n     /**\n      * The key name for export URL in register center\n      */\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n@@ -38,9 +38,9 @@\n import java.util.stream.Collectors;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n import static org.apache.dubbo.rpc.cluster.Constants.EXPORT_KEY;\n import static org.apache.dubbo.rpc.cluster.Constants.REFER_KEY;\n-import static org.apache.dubbo.rpc.cluster.Constants.TIMESTAMP_KEY;\n /**\n  * AbstractRegistryFactory. (SPI, Singleton, ThreadSafe)",
    "output": "Remove duplicate constant variable declaration"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n@@ -95,6 +95,8 @@ public interface Constants {\n      * The key name for reference URL in register center\n      */\n     String REFER_KEY = \"refer\";\n+\n+    String TIMESTAMP_KEY = \"timestamp\";\n     /**\n      * The key name for export URL in register center\n      */\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n@@ -40,6 +40,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n import static org.apache.dubbo.rpc.cluster.Constants.EXPORT_KEY;\n import static org.apache.dubbo.rpc.cluster.Constants.REFER_KEY;\n+import static org.apache.dubbo.rpc.cluster.Constants.TIMESTAMP_KEY;\n /**\n  * AbstractRegistryFactory. (SPI, Singleton, ThreadSafe)\n@@ -120,7 +121,7 @@ public Registry getRegistry(URL url) {\n         url = URLBuilder.from(url)\n                 .setPath(RegistryService.class.getName())\n                 .addParameter(INTERFACE_KEY, RegistryService.class.getName())\n-                .removeParameters(EXPORT_KEY, REFER_KEY)\n+                .removeParameters(EXPORT_KEY, REFER_KEY, TIMESTAMP_KEY)\n                 .build();\n         String key = createRegistryCacheKey(url);\n         // Lock the registry access process to ensure a single instance of the registry",
    "output": "Fix AbstractRegistryFactory bug"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/annotation/DubboReference.java b/dubbo-common/src/main/java/org/apache/dubbo/config/annotation/DubboReference.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/annotation/DubboReference.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/annotation/DubboReference.java\n@@ -286,6 +286,14 @@\n      * @return The service names that the Dubbo interface subscribed\n      * @see RegistryConstants#SUBSCRIBED_SERVICE_NAMES_KEY\n      * @since 2.7.8\n+     * @deprecated using {@link DubboReference#providedBy()}\n      */\n+    @Deprecated\n     String[] services() default {};\n+\n+    /**\n+     * declares which app or service this interface belongs to\n+     * @see RegistryConstants#PROVIDED_BY\n+     */\n+    String[] providedBy() default {};\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -170,6 +170,7 @@ public ReferenceConfig(Reference reference) {\n      * @see RegistryConstants#SUBSCRIBED_SERVICE_NAMES_KEY\n      * @since 2.7.8\n      */\n+    @Deprecated\n     @Parameter(key = SUBSCRIBED_SERVICE_NAMES_KEY)\n     public String getServices() {\n         return services;\n@@ -181,6 +182,7 @@ public String getServices() {\n      * @return the String {@link List} presenting the Dubbo interface subscribed\n      * @since 2.7.8\n      */\n+    @Deprecated\n     @Parameter(excluded = true)\n     public Set<String> getSubscribedServices() {\n         return splitToSet(getServices(), COMMA_SEPARATOR_CHAR);\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceBeanBuilderTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceBeanBuilderTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceBeanBuilderTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceBeanBuilderTest.java\n@@ -73,7 +73,8 @@ public class ReferenceBeanBuilderTest {\n             // @since 2.7.3\n             id = \"reference\",\n             // @since 2.7.8\n-            services = {\"service1\", \"service2\", \"service3\", \"service2\", \"service1\"}\n+            services = {\"service1\", \"service2\", \"service3\", \"service2\", \"service1\"},\n+            providedBy = {\"service1\", \"service2\", \"service3\"}\n     )\n     private static final Object TEST_FIELD = new Object();\n@@ -127,6 +128,7 @@ public void testBuild() throws Exception {\n         Assert.assertEquals(\"deprecated\", referenceBean.getListener());\n         Assert.assertEquals(\"reference\", referenceBean.getId());\n         Assert.assertEquals(ofSet(\"service1\", \"service2\", \"service3\"), referenceBean.getSubscribedServices());\n+        Assert.assertEquals(\"service1,service2,service3\", referenceBean.getProvidedBy());\n         // parameters\n         Map<String, String> parameters = new HashMap<String, String>();",
    "output": "Add provided-by paramater for DubboReference"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n@@ -44,6 +44,7 @@\n import static org.apache.dubbo.common.constants.QosConstants.QOS_ENABLE;\n import static org.apache.dubbo.common.constants.QosConstants.QOS_HOST;\n import static org.apache.dubbo.common.constants.QosConstants.QOS_PORT;\n+import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_PUBLISH_INSTANCE_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_PUBLISH_INTERFACE_KEY;\n import static org.apache.dubbo.config.Constants.DEVELOPMENT_ENVIRONMENT;\n import static org.apache.dubbo.config.Constants.PRODUCTION_ENVIRONMENT;\n@@ -166,6 +167,8 @@ public class ApplicationConfig extends AbstractConfig {\n     private Boolean publishInterface;\n+    private Boolean publishInstance;\n+\n     /**\n      * The preferred protocol(name) of this application\n      * convenient for places where it's hard to determine which is the preferred protocol\n@@ -490,6 +493,15 @@ public void setPublishInterface(Boolean publishInterface) {\n         this.publishInterface = publishInterface;\n     }\n+    @Parameter(key = REGISTRY_PUBLISH_INSTANCE_KEY)\n+    public Boolean getPublishInstance() {\n+        return publishInstance;\n+    }\n+\n+    public void setPublishInstance(Boolean publishInstance) {\n+        this.publishInstance = publishInstance;\n+    }\n+\n     @Parameter(excluded = true, key=\"application-protocol\")\n     public String getProtocol() {\n         return protocol == null ? DUBBO : protocol;",
    "output": "Add publishInstance config in ApplicationConfig"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLAddress.java b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLAddress.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLAddress.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLAddress.java\n@@ -163,98 +163,98 @@ public String toString() {\n     public static URLAddress parse(String rawAddress, String defaultProtocol, boolean encoded) {\n         try {\n+            String decodeStr = rawAddress;\n             if (encoded) {\n-                rawAddress = URLDecoder.decode(rawAddress, \"UTF-8\");\n+                decodeStr = URLDecoder.decode(rawAddress, \"UTF-8\");\n             }\n-            boolean isPathAddress = !Character.isDigit(rawAddress.charAt(0));\n+            boolean isPathAddress = !Character.isDigit(decodeStr.charAt(0));\n             if (isPathAddress) {\n-                return createPathURLAddress(rawAddress, defaultProtocol);\n+                return createPathURLAddress(decodeStr, rawAddress, defaultProtocol);\n             }\n-            return createURLAddress(rawAddress, defaultProtocol);\n+            return createURLAddress(decodeStr, rawAddress, defaultProtocol);\n         } catch (UnsupportedEncodingException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n     }\n-    private static URLAddress createURLAddress(String rawAddress, String defaultProtocol) {\n+    private static URLAddress createURLAddress(String decodeStr, String rawAddress, String defaultProtocol) {\n         String host = null;\n         int port = 0;\n-        int i = rawAddress.lastIndexOf(':');\n-        if (i >= 0 && i < rawAddress.length() - 1) {\n-            if (rawAddress.lastIndexOf('%') > i) {\n+        int i = decodeStr.lastIndexOf(':');\n+        if (i >= 0 && i < decodeStr.length() - 1) {\n+            if (decodeStr.lastIndexOf('%') > i) {\n                 // ipv6 address with scope id\n                 // e.g. fe80:0:0:0:894:aeec:f37d:23e1%en0\n                 // see https://howdoesinternetwork.com/2013/ipv6-zone-id\n                 // ignore\n             } else {\n-                port = Integer.parseInt(rawAddress.substring(i + 1));\n-                host = rawAddress.substring(0, i);\n+                port = Integer.parseInt(decodeStr.substring(i + 1));\n+                host = decodeStr.substring(0, i);\n             }\n         } else {\n-            host = rawAddress;\n+            host = decodeStr;\n         }\n         return new URLAddress(host, port, rawAddress);\n     }\n-    private static PathURLAddress createPathURLAddress(String rawAddress, String defaultProtocol) {\n+    private static PathURLAddress createPathURLAddress(String decodeStr, String rawAddress, String defaultProtocol) {\n         String protocol = defaultProtocol;\n-        String copyOfRawAddress = rawAddress;\n         String path = null, username = null, password = null, host = null;\n         int port = 0;\n-        int i = rawAddress.indexOf(\"://\");\n+        int i = decodeStr.indexOf(\"://\");\n         if (i >= 0) {\n             if (i == 0) {\n-                throw new IllegalStateException(\"url missing protocol: \\\"\" + rawAddress + \"\\\"\");\n+                throw new IllegalStateException(\"url missing protocol: \\\"\" + decodeStr + \"\\\"\");\n             }\n-            protocol = rawAddress.substring(0, i);\n-            rawAddress = rawAddress.substring(i + 3);\n+            protocol = decodeStr.substring(0, i);\n+            decodeStr = decodeStr.substring(i + 3);\n         } else {\n             // case: file:/path/to/file.txt\n-            i = rawAddress.indexOf(\":/\");\n+            i = decodeStr.indexOf(\":/\");\n             if (i >= 0) {\n                 if (i == 0) {\n-                    throw new IllegalStateException(\"url missing protocol: \\\"\" + rawAddress + \"\\\"\");\n+                    throw new IllegalStateException(\"url missing protocol: \\\"\" + decodeStr + \"\\\"\");\n                 }\n-                protocol = rawAddress.substring(0, i);\n-                rawAddress = rawAddress.substring(i + 1);\n+                protocol = decodeStr.substring(0, i);\n+                decodeStr = decodeStr.substring(i + 1);\n             }\n         }\n-        i = rawAddress.indexOf('/');\n+        i = decodeStr.indexOf('/');\n         if (i >= 0) {\n-            path = rawAddress.substring(i + 1);\n-            rawAddress = rawAddress.substring(0, i);\n+            path = decodeStr.substring(i + 1);\n+            decodeStr = decodeStr.substring(0, i);\n         }\n-        i = rawAddress.lastIndexOf('@');\n+        i = decodeStr.lastIndexOf('@');\n         if (i >= 0) {\n-            username = rawAddress.substring(0, i);\n+            username = decodeStr.substring(0, i);\n             int j = username.indexOf(':');\n             if (j >= 0) {\n                 password = username.substring(j + 1);\n                 username = username.substring(0, j);\n             }\n-            rawAddress = rawAddress.substring(i + 1);\n+            decodeStr = decodeStr.substring(i + 1);\n         }\n-        i = rawAddress.lastIndexOf(':');\n-        if (i >= 0 && i < rawAddress.length() - 1) {\n-            if (rawAddress.lastIndexOf('%') > i) {\n+        i = decodeStr.lastIndexOf(':');\n+        if (i >= 0 && i < decodeStr.length() - 1) {\n+            if (decodeStr.lastIndexOf('%') > i) {\n                 // ipv6 address with scope id\n                 // e.g. fe80:0:0:0:894:aeec:f37d:23e1%en0\n                 // see https://howdoesinternetwork.com/2013/ipv6-zone-id\n                 // ignore\n             } else {\n-                port = Integer.parseInt(rawAddress.substring(i + 1));\n-                host = rawAddress.substring(0, i);\n+                port = Integer.parseInt(decodeStr.substring(i + 1));\n+                host = decodeStr.substring(0, i);\n             }\n         }\n         // check cache\n         protocol = URLItemCache.checkProtocol(protocol);\n         path = URLItemCache.checkPath(path);\n-        return new PathURLAddress(protocol, username, password, path, host, port, copyOfRawAddress);\n+        return new PathURLAddress(protocol, username, password, path, host, port, rawAddress);\n     }\n }",
    "output": "Fix memory leak for stringAddress cache"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/configcenter/nop/NopDynamicConfiguration.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/configcenter/nop/NopDynamicConfiguration.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/configcenter/nop/NopDynamicConfiguration.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/configcenter/nop/NopDynamicConfiguration.java\n@@ -20,6 +20,8 @@\n import org.apache.dubbo.common.config.configcenter.ConfigurationListener;\n import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;\n+import static java.util.Collections.emptySortedSet;\n+\n import java.util.SortedSet;\n /**\n@@ -67,6 +69,6 @@ public boolean publishConfig(String key, String group, String content) {\n      */\n     @Override\n     public SortedSet<String> getConfigKeys(String group) {\n-        return null;\n+        return emptySortedSet();\n     }\n }",
    "output": "Fix NopDynamicConfiguration cause NPE"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/ConnectionTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/ConnectionTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/ConnectionTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/ConnectionTest.java\n@@ -14,10 +14,9 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.dubbo.remoting.netty4;\n+package org.apache.dubbo.remoting.api;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.remoting.api.Connection;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/EmptyProtocol.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/EmptyProtocol.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/EmptyProtocol.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/EmptyProtocol.java\n@@ -14,10 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.dubbo.remoting.netty4;\n-\n-import org.apache.dubbo.remoting.api.ProtocolDetector;\n-import org.apache.dubbo.remoting.api.WireProtocol;\n+package org.apache.dubbo.remoting.api;\n import io.netty.channel.ChannelPipeline;\n import io.netty.handler.ssl.SslContext;\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/NettyServerTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/NettyServerTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/NettyServerTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/NettyServerTest.java\n@@ -14,12 +14,11 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.dubbo.remoting.netty4;\n+package org.apache.dubbo.remoting.api;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.remoting.RemotingException;\n-import org.apache.dubbo.remoting.api.PortUnificationServer;\n public class NettyServerTest {",
    "output": "Fix remoting-api UT"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/InterfaceAddressURLTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/InterfaceAddressURLTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/InterfaceAddressURLTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/InterfaceAddressURLTest.java\n@@ -51,7 +51,6 @@ public void testGetParameter() {\n         ServiceAddressURL interfaceAddressURL = new DubboServiceAddressURL(url.getUrlAddress(), url.getUrlParam(), consumerURL, null);\n         assertEquals(\"3000\", interfaceAddressURL.getParameter(TIMEOUT_KEY));\n-        assertNotEquals(\"1.0.0\", interfaceAddressURL.getVersion());\n         assertEquals(\"morgan\", interfaceAddressURL.getApplication());\n         assertEquals(\"provider\", interfaceAddressURL.getRemoteApplication());",
    "output": "Remove error assertion"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java\n@@ -306,8 +306,11 @@ public void run() {\n                 }\n             }\n-            if (semaphore.tryAcquire() && CollectionUtils.isNotEmptyMap(waitForRemove)) {//move to next schedule\n-                cacheRemovalScheduler.schedule(new RemovalTask(), cacheRemovalTaskIntervalInMillis, TimeUnit.MILLISECONDS);\n+            if (CollectionUtils.isNotEmptyMap(waitForRemove)) {\n+                // move to next schedule\n+                if (semaphore.tryAcquire()) {\n+                    cacheRemovalScheduler.schedule(new RemovalTask(), cacheRemovalTaskIntervalInMillis, TimeUnit.MILLISECONDS);\n+                }\n             }\n         }\n     }",
    "output": "Fix memory leak of waitForRemove attribute"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n@@ -504,8 +504,16 @@ public static boolean isRegistry(URL url) {\n      * @return If it is, return <code>true</code>, or <code>false</code>\n      * @since 2.7.5\n      */\n-    public static boolean isServiceDiscoveryRegistryType(URL url) {\n-        return isServiceDiscoveryRegistryType(url == null ? emptyMap() : url.getParameters());\n+    public static boolean hasServiceDiscoveryRegistryTypeKey(URL url) {\n+        return hasServiceDiscoveryRegistryTypeKey(url == null ? emptyMap() : url.getParameters());\n+    }\n+\n+    public static boolean hasServiceDiscoveryRegistryProtocol(URL url) {\n+        return SERVICE_REGISTRY_PROTOCOL.equalsIgnoreCase(url.getProtocol());\n+    }\n+\n+    public static boolean isServiceDiscoveryURL(URL url) {\n+        return hasServiceDiscoveryRegistryProtocol(url) || hasServiceDiscoveryRegistryTypeKey(url);\n     }\n     /**\n@@ -515,7 +523,7 @@ public static boolean isServiceDiscoveryRegistryType(URL url) {\n      * @return If it is, return <code>true</code>, or <code>false</code>\n      * @since 2.7.5\n      */\n-    public static boolean isServiceDiscoveryRegistryType(Map<String, String> parameters) {\n+    public static boolean hasServiceDiscoveryRegistryTypeKey(Map<String, String> parameters) {\n         if (parameters == null || parameters.isEmpty()) {\n             return false;\n         }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n@@ -97,7 +97,6 @@\n import static org.apache.dubbo.common.constants.RegistryConstants.SERVICE_REGISTRY_PROTOCOL;\n import static org.apache.dubbo.common.constants.RemotingConstants.BACKUP_KEY;\n import static org.apache.dubbo.common.extension.ExtensionLoader.getExtensionLoader;\n-import static org.apache.dubbo.common.utils.UrlUtils.isServiceDiscoveryRegistryType;\n import static org.apache.dubbo.config.Constants.ARCHITECTURE;\n import static org.apache.dubbo.config.Constants.CONTEXTPATH_KEY;\n import static org.apache.dubbo.config.Constants.DUBBO_IP_TO_REGISTRY;\n@@ -547,7 +546,7 @@ public static void validateMethodConfig(MethodConfig config) {\n     }\n     private static String extractRegistryType(URL url) {\n-        return isServiceDiscoveryRegistryType(url) ? SERVICE_REGISTRY_PROTOCOL : getRegistryProtocolType(url);\n+        return UrlUtils.hasServiceDiscoveryRegistryTypeKey(url) ? SERVICE_REGISTRY_PROTOCOL : getRegistryProtocolType(url);\n     }\n     private static String getRegistryProtocolType(URL url) {\ndiff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OfflineApp.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OfflineApp.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OfflineApp.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OfflineApp.java\n@@ -31,7 +31,7 @@ public class OfflineApp extends BaseOffline {\n     @Override\n     protected void doUnexport(ProviderModel.RegisterStatedURL statedURL) {\n-        if (UrlUtils.isServiceDiscoveryRegistryType(statedURL.getRegistryUrl())) {\n+        if (UrlUtils.isServiceDiscoveryURL(statedURL.getRegistryUrl())) {\n             super.doUnexport(statedURL);\n         }\n     }\ndiff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OfflineInterface.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OfflineInterface.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OfflineInterface.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OfflineInterface.java\n@@ -26,7 +26,7 @@\n })\n public class OfflineInterface extends BaseOffline {\n     protected void doUnexport(ProviderModel.RegisterStatedURL statedURL) {\n-        if (!UrlUtils.isServiceDiscoveryRegistryType(statedURL.getRegistryUrl())) {\n+        if (!UrlUtils.isServiceDiscoveryURL(statedURL.getRegistryUrl())) {\n             super.doUnexport(statedURL);\n         }\n     }\ndiff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OnlineApp.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OnlineApp.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OnlineApp.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OnlineApp.java\n@@ -27,7 +27,7 @@ public class OnlineApp extends BaseOnline {\n     @Override\n     protected void doExport(ProviderModel.RegisterStatedURL statedURL) {\n-        if (UrlUtils.isServiceDiscoveryRegistryType(statedURL.getRegistryUrl())) {\n+        if (UrlUtils.isServiceDiscoveryURL(statedURL.getRegistryUrl())) {\n            super.doExport(statedURL);\n         }\n     }\ndiff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OnlineInterface.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OnlineInterface.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OnlineInterface.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/OnlineInterface.java\n@@ -22,7 +22,7 @@\n public class OnlineInterface extends BaseOnline {\n     @Override\n     protected void doExport(ProviderModel.RegisterStatedURL statedURL) {\n-        if (!UrlUtils.isServiceDiscoveryRegistryType(statedURL.getRegistryUrl())) {\n+        if (!UrlUtils.isServiceDiscoveryURL(statedURL.getRegistryUrl())) {\n             super.doExport(statedURL);\n         }\n     }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryFactory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryFactory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryFactory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryFactory.java\n@@ -17,18 +17,18 @@\n package org.apache.dubbo.registry.client;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.utils.UrlUtils;\n import org.apache.dubbo.registry.Registry;\n import org.apache.dubbo.registry.support.AbstractRegistryFactory;\n import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_KEY;\n-import static org.apache.dubbo.common.constants.RegistryConstants.SERVICE_REGISTRY_PROTOCOL;\n import static org.apache.dubbo.registry.Constants.DEFAULT_REGISTRY;\n public class ServiceDiscoveryRegistryFactory extends AbstractRegistryFactory {\n     @Override\n     protected Registry createRegistry(URL url) {\n-        if (SERVICE_REGISTRY_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {\n+        if (UrlUtils.hasServiceDiscoveryRegistryProtocol(url)) {\n             String protocol = url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY);\n             url = url.setProtocol(protocol).removeParameter(REGISTRY_KEY);\n         }",
    "output": "Fix service discovery registry url check logic during offline/online"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -53,6 +53,7 @@\n import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;\n@@ -294,7 +295,7 @@ private Optional<List<Router>> toRouters(List<URL> urls) {\n      * @return invokers\n      */\n     private Map<URL, Invoker<T>> toInvokers(List<URL> urls) {\n-        Map<URL, Invoker<T>> newUrlInvokerMap = new HashMap<>();\n+        Map<URL, Invoker<T>> newUrlInvokerMap = new ConcurrentHashMap<>();\n         if (urls == null || urls.isEmpty()) {\n             return newUrlInvokerMap;\n         }",
    "output": "Change RegistryDirectory urlInvokerMap hashmap to a ConcurrentHashMap"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java b/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n@@ -16,7 +16,6 @@\n  */\n package org.apache.dubbo.config.context;\n-import org.apache.dubbo.common.config.ConfigurationUtils;\n import org.apache.dubbo.common.context.FrameworkExt;\n import org.apache.dubbo.common.context.LifecycleAdapter;\n import org.apache.dubbo.common.logger.Logger;\n@@ -78,7 +77,7 @@ public class ConfigManager extends LifecycleAdapter implements FrameworkExt {\n     public ConfigManager() {\n         try {\n-            String rawWarn = ConfigurationUtils.getProperty(\"dubbo.application.config.warn\", null);\n+            String rawWarn = System.getProperty(\"dubbo.application.config.warn\");\n             if (rawWarn != null) {\n                 configWarnLogEnabled = Boolean.parseBoolean(rawWarn);\n             }",
    "output": "Use system property"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n@@ -49,12 +49,19 @@ public class MigrationRuleListener implements RegistryProtocolListener, Configur\n     public MigrationRuleListener() {\n         this.configuration = ApplicationModel.getEnvironment().getDynamicConfiguration().orElse(null);\n-\n-        logger.info(\"Listening for migration rules on dataId-\" + RULE_KEY + \" group-\" + DUBBO_SERVICEDISCOVERY_MIGRATION);\n-        configuration.addListener(RULE_KEY, DUBBO_SERVICEDISCOVERY_MIGRATION, this);\n-\n-        String rawRule = configuration.getConfig(RULE_KEY, DUBBO_SERVICEDISCOVERY_MIGRATION);\n-        if (StringUtils.isEmpty(rawRule)) {\n+        if (this.configuration != null) {\n+            logger.info(\"Listening for migration rules on dataId \" + RULE_KEY + \", group \" + DUBBO_SERVICEDISCOVERY_MIGRATION);\n+            configuration.addListener(RULE_KEY, DUBBO_SERVICEDISCOVERY_MIGRATION, this);\n+\n+            String rawRule = configuration.getConfig(RULE_KEY, DUBBO_SERVICEDISCOVERY_MIGRATION);\n+            if (StringUtils.isEmpty(rawRule)) {\n+                rawRule = INIT;\n+            }\n+            this.rawRule = rawRule;\n+        } else {\n+            if (logger.isWarnEnabled()) {\n+                logger.warn(\"Using default configuration rule because config center is not configured!\");\n+            }\n             rawRule = INIT;\n         }\n         process(new ConfigChangedEvent(RULE_KEY, DUBBO_SERVICEDISCOVERY_MIGRATION, rawRule));",
    "output": "Fix migration rule listener when config center is not set"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleListener.java\n@@ -48,7 +48,7 @@ public class MigrationRuleListener implements RegistryProtocolListener, Configur\n     private volatile String rawRule;\n     public MigrationRuleListener() {\n-        this.configuration = ApplicationModel.getEnvironment().getDynamicConfiguration().orElseGet(null);\n+        this.configuration = ApplicationModel.getEnvironment().getDynamicConfiguration().orElse(null);\n         logger.info(\"Listening for migration rules on dataId-\" + RULE_KEY + \" group-\" + DUBBO_SERVICEDISCOVERY_MIGRATION);\n         configuration.addListener(RULE_KEY, DUBBO_SERVICEDISCOVERY_MIGRATION, this);",
    "output": "Fix optional NPE"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java\n@@ -64,7 +64,7 @@ public <T> boolean shouldMigrate(ClusterInvoker<T> serviceDiscoveryInvoker, Clus\n             threshold = DEFAULT_THREAD;\n         }\n-        logger.info(\"Instance address size \" + newAddressSize + \", interface address size \" + oldAddressSize + \", threshold \" + threshold);\n+        logger.info(\"serviceKey:\" + invoker.getUrl().getServiceKey() + \" Instance address size \" + newAddressSize + \", interface address size \" + oldAddressSize + \", threshold \" + threshold);\n         if (newAddressSize != 0 && oldAddressSize == 0) {\n             return true;\n@@ -73,7 +73,7 @@ public <T> boolean shouldMigrate(ClusterInvoker<T> serviceDiscoveryInvoker, Clus\n             return false;\n         }\n-        if (((float)newAddressSize / (float)oldAddressSize) >= threshold) {\n+        if (((float) newAddressSize / (float) oldAddressSize) >= threshold) {\n             return true;\n         }\n         return false;\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n@@ -118,7 +118,7 @@ public void reRefer(URL newSubscribeUrl) {\n     }\n     private void doReSubscribe(ClusterInvoker<T> invoker, URL newSubscribeUrl) {\n-        DynamicDirectory<T> directory = (DynamicDirectory<T>)invoker.getDirectory();\n+        DynamicDirectory<T> directory = (DynamicDirectory<T>) invoker.getDirectory();\n         URL oldSubscribeUrl = directory.getRegisteredConsumerUrl();\n         Registry registry = directory.getRegistry();\n         registry.unregister(directory.getRegisteredConsumerUrl());\n@@ -275,8 +275,10 @@ private synchronized void compareAddresses(ClusterInvoker<T> serviceDiscoveryInv\n         Set<MigrationAddressComparator> detectors = ExtensionLoader.getExtensionLoader(MigrationAddressComparator.class).getSupportedExtensionInstances();\n         if (detectors != null && detectors.stream().allMatch(migrationDetector -> migrationDetector.shouldMigrate(serviceDiscoveryInvoker, invoker, rule))) {\n+            logger.info(\"serviceKey:\" + invoker.getUrl().getServiceKey() + \" switch to APP Level address\");\n             discardInterfaceInvokerAddress(invoker);\n         } else {\n+            logger.info(\"serviceKey:\" + invoker.getUrl().getServiceKey() + \" switch to Service Level address\");\n             discardServiceDiscoveryInvokerAddress(serviceDiscoveryInvoker);\n         }\n     }\n@@ -299,7 +301,7 @@ protected synchronized void discardServiceDiscoveryInvokerAddress(ClusterInvoker\n         }\n         if (serviceDiscoveryInvoker != null) {\n             if (logger.isDebugEnabled()) {\n-                List<Invoker<T>>  invokers = serviceDiscoveryInvoker.getDirectory().getAllInvokers();\n+                List<Invoker<T>> invokers = serviceDiscoveryInvoker.getDirectory().getAllInvokers();\n                 logger.debug(\"Discarding instance addresses, total size \" + (invokers == null ? 0 : invokers.size()));\n             }\n //            serviceDiscoveryInvoker.getDirectory().discordAddresses();\n@@ -314,7 +316,7 @@ protected void refreshServiceDiscoveryInvoker() {\n             }\n             serviceDiscoveryInvoker = registryProtocol.getServiceDiscoveryInvoker(cluster, registry, type, url);\n         } else {\n-            ((DynamicDirectory)serviceDiscoveryInvoker.getDirectory()).markInvokersChanged();\n+            ((DynamicDirectory) serviceDiscoveryInvoker.getDirectory()).markInvokersChanged();\n         }\n     }\n@@ -328,7 +330,7 @@ protected void refreshInterfaceInvoker() {\n             invoker = registryProtocol.getInvoker(cluster, registry, type, url);\n         } else {\n-            ((DynamicDirectory)invoker.getDirectory()).markInvokersChanged();\n+            ((DynamicDirectory) invoker.getDirectory()).markInvokersChanged();\n         }\n     }",
    "output": "Add more detail log"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -101,6 +101,7 @@ private void refreshInvoker(List<URL> invokerUrls) {\n         Assert.notNull(invokerUrls, \"invokerUrls should not be null, use empty url list to clear address.\");\n         if (invokerUrls.size() == 0) {\n+            logger.info(\"Received empty url list...\");\n             this.forbidden = true; // Forbid to access\n             this.invokers = Collections.emptyList();\n             routerChain.setInvokers(this.invokers);\n@@ -115,6 +116,7 @@ private void refreshInvoker(List<URL> invokerUrls) {\n         }\n         Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map\n+        logger.info(\"Refreshed invoker size \" + newUrlInvokerMap.size());\n         if (CollectionUtils.isEmptyMap(newUrlInvokerMap)) {\n             logger.error(new IllegalStateException(\"Cannot create invokers from url address list (total \" + invokerUrls.size() + \")\"));\n@@ -253,6 +255,7 @@ private void destroyUnusedInvokers(Map<String, Invoker<T>> oldUrlInvokerMap, Map\n         }\n         if (deleted != null) {\n+            logger.info(deleted.size() + \" unused invokers deleted.\");\n             for (String addressKey : deleted) {\n                 if (addressKey != null) {\n                     Invoker<T> invoker = oldUrlInvokerMap.remove(addressKey);\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n@@ -134,6 +134,8 @@ public synchronized void onEvent(ServiceInstancesChangedEvent event) {\n             }\n         }\n+        logger.info(newRevisionToMetadata.size() + \" unique revisions. \");\n+\n         if (hasEmptyMetadata(newRevisionToMetadata)) {// retry every 10 seconds\n             if (retryPermission.tryAcquire()) {\n                 scheduler.submit(new AddressRefreshRetryTask(retryPermission));\n@@ -304,7 +306,9 @@ private MetadataInfo getMetadataInfo(ServiceInstance instance) {\n     private void notifyAddressChanged() {\n         listeners.forEach((key, notifyListener) -> {\n             //FIXME, group wildcard match\n-            notifyListener.notify(toUrlsWithEmpty(serviceUrls.get(key)));\n+            List<URL> urls = toUrlsWithEmpty(serviceUrls.get(key));\n+            logger.info(\"Notify service \" + key + \" with services \" + urls.size());\n+            notifyListener.notify(urls);\n         });\n     }",
    "output": "Add service notification log"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n@@ -58,7 +58,7 @@ public void doMigrate(String rawRule) {\n             try {\n                 rule = MigrationRule.parse(rawRule);\n                 // FIXME, consumerURL.getHost() might not exactly the ip expected.\n-                if (CollectionUtils.isEmpty(rule.getTargetIps()) || (rule.getTargetIps() != null && rule.getTargetIps().contains(consumerURL.getHost()))) {\n+                if (CollectionUtils.isEmpty(rule.getTargetIps()) || rule.getTargetIps().contains(consumerURL.getHost())) {\n                     setMigrationRule(rule);\n                     step = rule.getStep(consumerURL.getServiceKey());\n                     threshold = rule.getThreshold(consumerURL.getServiceKey());",
    "output": "Use isNotEmpty"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.common.extension.Activate;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.registry.client.migration.model.MigrationRule;\n import org.apache.dubbo.registry.client.migration.model.MigrationStep;\n@@ -57,7 +58,7 @@ public void doMigrate(String rawRule) {\n             try {\n                 rule = MigrationRule.parse(rawRule);\n                 // FIXME, consumerURL.getHost() might not exactly the ip expected.\n-                if (rule.getTargetIps() == null || (rule.getTargetIps() != null && rule.getTargetIps().contains(consumerURL.getHost()))) {\n+                if (CollectionUtils.isEmpty(rule.getTargetIps()) || (rule.getTargetIps() != null && rule.getTargetIps().contains(consumerURL.getHost()))) {\n                     setMigrationRule(rule);\n                     step = rule.getStep(consumerURL.getServiceKey());\n                     threshold = rule.getThreshold(consumerURL.getServiceKey());",
    "output": "Use collection isNotEmpty"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n@@ -57,7 +57,7 @@ public void doMigrate(String rawRule) {\n             try {\n                 rule = MigrationRule.parse(rawRule);\n                 // FIXME, consumerURL.getHost() might not exactly the ip expected.\n-                if (rule.getTargetIps() != null && rule.getTargetIps().contains(consumerURL.getHost())) {\n+                if (rule.getTargetIps() == null || (rule.getTargetIps() != null && rule.getTargetIps().contains(consumerURL.getHost()))) {\n                     setMigrationRule(rule);\n                     step = rule.getStep(consumerURL.getServiceKey());\n                     threshold = rule.getThreshold(consumerURL.getServiceKey());",
    "output": "Fix rule ip support"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n@@ -57,13 +57,13 @@ public void doMigrate(String rawRule) {\n             try {\n                 rule = MigrationRule.parse(rawRule);\n                 // FIXME, consumerURL.getHost() might not exactly the ip expected.\n-                if (rule.getTargetIps() == null || !rule.getTargetIps().contains(consumerURL.getHost())) {\n+                if (rule.getTargetIps() != null && rule.getTargetIps().contains(consumerURL.getHost())) {\n+                    setMigrationRule(rule);\n+                    step = rule.getStep(consumerURL.getServiceKey());\n+                    threshold = rule.getThreshold(consumerURL.getServiceKey());\n+                } else {\n                     logger.info(\"Migration rule ignored, rule target ips \" + rule.getTargetIps() + \" and local ip \" + consumerURL.getHost() + \" do not match\");\n-                    return;\n                 }\n-                setMigrationRule(rule);\n-                step = rule.getStep(consumerURL.getServiceKey());\n-                threshold = rule.getThreshold(consumerURL.getServiceKey());\n             } catch (Exception e) {\n                 logger.error(\"Parse migration rule error, will use default step \" + step, e);\n             }",
    "output": "Fix migration rule ip match logic"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n@@ -101,24 +101,12 @@ public ServiceInstancesChangedListener(Set<String> serviceNames, ServiceDiscover\n      * @param event {@link ServiceInstancesChangedEvent}\n      */\n     public synchronized void onEvent(ServiceInstancesChangedEvent event) {\n-        String appName = event.getServiceName();\n-        List<ServiceInstance> appInstances = event.getServiceInstances();\n-        if (event instanceof RetryServiceInstancesChangedEvent) {\n-            RetryServiceInstancesChangedEvent retryEvent = (RetryServiceInstancesChangedEvent) event;\n-            logger.warn(\"Received address refresh retry event, \" + retryEvent.getFailureRecordTime());\n-            if (retryEvent.getFailureRecordTime() < lastRefreshTime) {\n-                logger.warn(\"Ignore retry event, event time: \" + retryEvent.getFailureRecordTime() + \", last refresh time: \" + lastRefreshTime);\n-                return;\n-            }\n-            logger.warn(\"Retrying address notification...\");\n-        } else {\n-            logger.info(\"Received instance notification, serviceName: \" + appName + \", instances: \" + appInstances.size());\n-            allInstances.put(appName, appInstances);\n-            lastRefreshTime = System.currentTimeMillis();\n+        if (this.isRetryAndExpired(event)) {\n+            return;\n         }\n         if (logger.isDebugEnabled()) {\n-            logger.debug(appInstances.toString());\n+            logger.debug(event.getServiceInstances().toString());\n         }\n         Map<String, List<ServiceInstance>> revisionToInstances = new HashMap<>();\n@@ -151,15 +139,11 @@ public synchronized void onEvent(ServiceInstancesChangedEvent event) {\n                 scheduler.submit(new AddressRefreshRetryTask(retryPermission));\n                 logger.warn(\"Address refresh try task submitted.\");\n             }\n-            logger.warn(\"Address refresh failed because of Metadata Server failure, wait for retry or new refresh event.\");\n+            logger.warn(\"Address refresh failed because of Metadata Server failure, wait for retry or new address refresh event.\");\n             this.revisionToMetadata = newRevisionToMetadata;\n             return;\n         }\n-        if (revisionToMetadata.size() != 0) {\n-            logger.info(\"Revisions removed: \" + revisionToMetadata.keySet());\n-            revisionToMetadata.clear();\n-        }\n         this.revisionToMetadata = newRevisionToMetadata;\n         localServiceToRevisions.forEach((serviceKey, revisions) -> {\n@@ -182,6 +166,67 @@ public synchronized void onEvent(ServiceInstancesChangedEvent event) {\n         this.notifyAddressChanged();\n     }\n+    public void addListener(String serviceKey, NotifyListener listener) {\n+        this.listeners.put(serviceKey, listener);\n+    }\n+\n+    public void removeListener(String serviceKey) {\n+        listeners.remove(serviceKey);\n+        if (listeners.isEmpty()) {\n+            serviceDiscovery.removeServiceInstancesChangedListener(this);\n+        }\n+    }\n+\n+    public List<URL> getUrls(String serviceKey) {\n+        return toUrlsWithEmpty(serviceUrls.get(serviceKey));\n+    }\n+\n+    /**\n+     * Get the correlative service name\n+     *\n+     * @return the correlative service name\n+     */\n+    public final Set<String> getServiceNames() {\n+        return serviceNames;\n+    }\n+\n+    public void setUrl(URL url) {\n+        this.url = url;\n+    }\n+\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    /**\n+     * @param event {@link ServiceInstancesChangedEvent event}\n+     * @return If service name matches, return <code>true</code>, or <code>false</code>\n+     */\n+    public final boolean accept(ServiceInstancesChangedEvent event) {\n+        return serviceNames.contains(event.getServiceName());\n+    }\n+\n+\n+    private boolean isRetryAndExpired(ServiceInstancesChangedEvent event) {\n+        String appName = event.getServiceName();\n+        List<ServiceInstance> appInstances = event.getServiceInstances();\n+\n+        if (event instanceof RetryServiceInstancesChangedEvent) {\n+            RetryServiceInstancesChangedEvent retryEvent = (RetryServiceInstancesChangedEvent) event;\n+            logger.warn(\"Received address refresh retry event, \" + retryEvent.getFailureRecordTime());\n+            if (retryEvent.getFailureRecordTime() < lastRefreshTime) {\n+                logger.warn(\"Ignore retry event, event time: \" + retryEvent.getFailureRecordTime() + \", last refresh time: \" + lastRefreshTime);\n+                return true;\n+            }\n+            logger.warn(\"Retrying address notification...\");\n+        } else {\n+            logger.info(\"Received instance notification, serviceName: \" + appName + \", instances: \" + appInstances.size());\n+            allInstances.put(appName, appInstances);\n+            lastRefreshTime = System.currentTimeMillis();\n+        }\n+        return false;\n+    }\n+\n     private boolean hasEmptyMetadata(Map<String, MetadataInfo> revisionToMetadata) {\n         if (revisionToMetadata == null) {\n             return false;\n@@ -197,13 +242,14 @@ private boolean hasEmptyMetadata(Map<String, MetadataInfo> revisionToMetadata) {\n     }\n     private MetadataInfo getRemoteMetadata(ServiceInstance instance, String revision, Map<String, Set<String>> localServiceToRevisions, List<ServiceInstance> subInstances) {\n-        MetadataInfo metadata = revisionToMetadata.remove(revision);\n+        MetadataInfo metadata = revisionToMetadata.get(revision);\n         if (metadata == null) {\n             if (failureCounter.get() < 3 || (System.currentTimeMillis() - lastFailureTime > 5000)) {\n                 metadata = getMetadataInfo(instance);\n                 if (metadata != null) {\n                     logger.info(\"MetadataInfo for instance \" + instance.getAddress() + \"?revision=\" + revision + \" is \" + metadata);\n                     failureCounter.set(0);\n+                    revisionToMetadata.put(revision, metadata);\n                     parseMetadata(revision, metadata, localServiceToRevisions);\n                 } else {\n                     logger.error(\"Failed to get MetadataInfo for instance \" + instance.getAddress() + \"?revision=\" + revision\n@@ -212,7 +258,8 @@ private MetadataInfo getRemoteMetadata(ServiceInstance instance, String revision\n                     failureCounter.incrementAndGet();\n                 }\n             }\n-        } else if (subInstances.size() > 1) {// check if metadata info parsed\n+        } else if (subInstances.size() < 1) {\n+            // \"subInstances.size() >= 1\" means metadata of this revision has been parsed, ignore\n             parseMetadata(revision, metadata, localServiceToRevisions);\n         }\n         return metadata;\n@@ -268,46 +315,6 @@ private List<URL> toUrlsWithEmpty(List<URL> urls) {\n         return urls;\n     }\n-    public void addListener(String serviceKey, NotifyListener listener) {\n-        this.listeners.put(serviceKey, listener);\n-    }\n-\n-    public void removeListener(String serviceKey) {\n-        listeners.remove(serviceKey);\n-        if (listeners.isEmpty()) {\n-            serviceDiscovery.removeServiceInstancesChangedListener(this);\n-        }\n-    }\n-\n-    public List<URL> getUrls(String serviceKey) {\n-        return toUrlsWithEmpty(serviceUrls.get(serviceKey));\n-    }\n-\n-    /**\n-     * Get the correlative service name\n-     *\n-     * @return the correlative service name\n-     */\n-    public final Set<String> getServiceNames() {\n-        return serviceNames;\n-    }\n-\n-    public void setUrl(URL url) {\n-        this.url = url;\n-    }\n-\n-    public URL getUrl() {\n-        return url;\n-    }\n-\n-    /**\n-     * @param event {@link ServiceInstancesChangedEvent event}\n-     * @return If service name matches, return <code>true</code>, or <code>false</code>\n-     */\n-    public final boolean accept(ServiceInstancesChangedEvent event) {\n-        return serviceNames.contains(event.getServiceName());\n-    }\n-\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) return true;",
    "output": "Fix instance listener metadata update"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -64,6 +64,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.CLUSTER_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;\n+import static org.apache.dubbo.common.constants.CommonConstants.DUBBO;\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_VERSION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.EXTRA_KEYS_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n@@ -73,6 +74,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.MONITOR_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.RELEASE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n@@ -92,7 +94,6 @@\n import static org.apache.dubbo.common.constants.RegistryConstants.SERVICE_REGISTRY_PROTOCOL;\n import static org.apache.dubbo.common.utils.UrlUtils.classifyUrls;\n import static org.apache.dubbo.registry.Constants.CONFIGURATORS_SUFFIX;\n-import static org.apache.dubbo.registry.Constants.CONSUMER_PROTOCOL;\n import static org.apache.dubbo.registry.Constants.DEFAULT_REGISTRY_RETRY_PERIOD;\n import static org.apache.dubbo.registry.Constants.PROVIDER_PROTOCOL;\n import static org.apache.dubbo.registry.Constants.REGISTER_IP_KEY;\n@@ -452,7 +453,7 @@ public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n     }\n     protected <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url, Map<String, String> parameters) {\n-        URL consumerUrl = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);\n+        URL consumerUrl = new URL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY), parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);\n         ClusterInvoker<T> migrationInvoker = getMigrationInvoker(this, cluster, registry, type, url, consumerUrl);\n         return interceptInvoker(migrationInvoker, url, consumerUrl);\n     }\n@@ -489,7 +490,7 @@ protected <T> ClusterInvoker<T> doCreateInvoker(DynamicDirectory<T> directory, C\n         directory.setProtocol(protocol);\n         // all attributes of REFER_KEY\n         Map<String, String> parameters = new HashMap<String, String>(directory.getConsumerUrl().getParameters());\n-        URL urlToRegistry = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);\n+        URL urlToRegistry = new URL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY), parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);\n         if (directory.isShouldRegister()) {\n             directory.setRegisteredConsumerUrl(urlToRegistry);\n             registry.register(directory.getRegisteredConsumerUrl());\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java\n@@ -38,7 +38,6 @@\n import java.util.concurrent.TimeUnit;\n import static org.apache.dubbo.common.constants.CommonConstants.FILE_KEY;\n-import static org.apache.dubbo.registry.Constants.CONSUMER_PROTOCOL;\n import static org.apache.dubbo.registry.Constants.DEFAULT_REGISTRY_RETRY_PERIOD;\n import static org.apache.dubbo.registry.Constants.REGISTRY_RETRY_PERIOD_KEY;\n@@ -244,7 +243,7 @@ public void register(URL url) {\n             // If the startup detection is opened, the Exception is thrown directly.\n             boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                     && url.getParameter(Constants.CHECK_KEY, true)\n-                    && !CONSUMER_PROTOCOL.equals(url.getProtocol());\n+                    && !(url.getPort() == 0);\n             boolean skipFailback = t instanceof SkipFailbackWrapperException;\n             if (check || skipFailback) {\n                 if (skipFailback) {\n@@ -293,7 +292,7 @@ public void unregister(URL url) {\n             // If the startup detection is opened, the Exception is thrown directly.\n             boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                     && url.getParameter(Constants.CHECK_KEY, true)\n-                    && !CONSUMER_PROTOCOL.equals(url.getProtocol());\n+                    && !(url.getPort() == 0);\n             boolean skipFailback = t instanceof SkipFailbackWrapperException;\n             if (check || skipFailback) {\n                 if (skipFailback) {",
    "output": "Change protocol of consumer url to real biz protocol, 'dubbo' by default"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java\n@@ -31,6 +31,7 @@\n import java.util.Map;\n import java.util.Objects;\n import java.util.SortedSet;\n+import java.util.TreeMap;\n import java.util.TreeSet;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -97,7 +98,7 @@ public String calAndGetRevision() {\n         StringBuilder sb = new StringBuilder();\n         sb.append(app);\n-        for (Map.Entry<String, ServiceInfo> entry : services.entrySet()) {\n+        for (Map.Entry<String, ServiceInfo> entry : new TreeMap<>(services).entrySet()) {\n             sb.append(entry.getValue().toDescString());\n         }\n         this.revision = RevisionResolver.calRevision(sb.toString());\n@@ -365,7 +366,7 @@ public boolean hasMethodParameter(String method) {\n         }\n         public String toDescString() {\n-            return this.getMatchKey() + getMethodSignaturesString() + getParams();\n+            return this.getMatchKey() + getMethodSignaturesString() + new TreeMap<>(getParams());\n         }\n         private String getMethodSignaturesString() {",
    "output": "Use TreeMap to cal revision * remove not used classes. * support service discovery unsubscribe and re-refer * add publishInterface config item to ApplicationConfig * remove useless class definition * fix service instance equals bug * use ordered treemap to cal revision"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -233,7 +233,8 @@ public synchronized void init() {\n         if (bootstrap == null) {\n             bootstrap = DubboBootstrap.getInstance();\n-            bootstrap.init();\n+            bootstrap.initialize();\n+            bootstrap.reference(this);\n         }\n         checkAndUpdateSubConfigs();\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -182,13 +182,14 @@ public void unexport() {\n     }\n     public synchronized void export() {\n-        if (!shouldExport()) {\n+        if (!shouldExport() || exported) {\n             return;\n         }\n         if (bootstrap == null) {\n             bootstrap = DubboBootstrap.getInstance();\n             bootstrap.initialize();\n+            bootstrap.service(this);\n         }\n         checkAndUpdateSubConfigs();\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n@@ -511,11 +511,6 @@ public DubboBootstrap referAsync() {\n         return this;\n     }\n-    @Deprecated\n-    public void init() {\n-        initialize();\n-    }\n-\n     /**\n      * Initialize\n      */\n@@ -928,7 +923,7 @@ public DubboBootstrap start() {\n     }\n     private boolean hasExportedServices() {\n-        return !metadataService.getExportedURLs().isEmpty();\n+        return CollectionUtils.isNotEmpty(configManager.getServices());\n     }\n     /**",
    "output": "Make sure instance and meta registered to remote when interface delay publish enabled"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/ServiceNameMapping.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/ServiceNameMapping.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/ServiceNameMapping.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/ServiceNameMapping.java\n@@ -70,10 +70,4 @@ static String buildGroup(String serviceInterface, String group, String version,\n         return DEFAULT_MAPPING_GROUP + SLASH + serviceInterface;\n     }\n-    static class MappingException extends RuntimeException {\n-        public MappingException(String message) {\n-            super(message);\n-        }\n-    }\n-\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java\n@@ -184,7 +184,7 @@ public boolean equals(Object o) {\n             if (entry.getKey().equals(REVISION_KEY)) {\n                 continue;\n             }\n-            equals = equals && !entry.getValue().equals(that.getMetadata().get(entry.getKey()));\n+            equals = equals && entry.getValue().equals(that.getMetadata().get(entry.getKey()));\n         }\n         return equals;",
    "output": "Fix service instance equals"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n@@ -323,20 +323,24 @@ protected void subscribeURLs(URL url, NotifyListener listener, Set<String> servi\n         serviceToAppsMapping.put(protocolServiceKey, serviceNamesKey);\n         // register ServiceInstancesChangedListener\n-        ServiceInstancesChangedListener serviceListener = serviceListeners.computeIfAbsent(serviceNamesKey,\n-                k -> new ServiceInstancesChangedListener(serviceNames, serviceDiscovery));\n-        serviceListener.setUrl(url);\n-        listener.addServiceListener(serviceListener);\n-\n-        serviceNames.forEach(serviceName -> {\n-            List<ServiceInstance> serviceInstances = serviceDiscovery.getInstances(serviceName);\n-            serviceListener.onEvent(new ServiceInstancesChangedEvent(serviceName, serviceInstances));\n+        ServiceInstancesChangedListener serviceListener = serviceListeners.computeIfAbsent(serviceNamesKey, k -> {\n+            ServiceInstancesChangedListener serviceInstancesChangedListener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);\n+            serviceInstancesChangedListener.setUrl(url);\n+            serviceNames.forEach(serviceName -> {\n+                List<ServiceInstance> serviceInstances = serviceDiscovery.getInstances(serviceName);\n+                if (CollectionUtils.isNotEmpty(serviceInstances)) {\n+                    serviceInstancesChangedListener.onEvent(new ServiceInstancesChangedEvent(serviceName, serviceInstances));\n+                }\n+            });\n+            return serviceInstancesChangedListener;\n         });\n-        listener.notify(serviceListener.getUrls(protocolServiceKey));\n-\n+        serviceListener.setUrl(url);\n+        listener.addServiceListener(serviceListener);\n         serviceListener.addListener(protocolServiceKey, listener);\n         registerServiceInstancesChangedListener(url, serviceListener);\n+\n+        listener.notify(serviceListener.getUrls(protocolServiceKey));\n     }\n     /**\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n@@ -26,12 +26,14 @@\n import org.apache.dubbo.registry.integration.DynamicDirectory;\n import org.apache.dubbo.registry.integration.RegistryProtocol;\n import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.cluster.Cluster;\n import org.apache.dubbo.rpc.cluster.ClusterInvoker;\n import org.apache.dubbo.rpc.cluster.Directory;\n+import java.util.List;\n import java.util.Set;\n import static org.apache.dubbo.rpc.cluster.Constants.REFER_KEY;\n@@ -279,13 +281,14 @@ protected synchronized void destroyServiceDiscoveryInvoker(ClusterInvoker<?> ser\n         }\n     }\n-    protected synchronized void discardServiceDiscoveryInvokerAddress(ClusterInvoker<?> serviceDiscoveryInvoker) {\n+    protected synchronized void discardServiceDiscoveryInvokerAddress(ClusterInvoker<T> serviceDiscoveryInvoker) {\n         if (this.invoker != null) {\n             this.currentAvailableInvoker = this.invoker;\n         }\n         if (serviceDiscoveryInvoker != null) {\n             if (logger.isDebugEnabled()) {\n-                logger.debug(\"Discarding instance addresses, total size \" + serviceDiscoveryInvoker.getDirectory().getAllInvokers().size());\n+                List<Invoker<T>>  invokers = serviceDiscoveryInvoker.getDirectory().getAllInvokers();\n+                logger.debug(\"Discarding instance addresses, total size \" + (invokers == null ? 0 : invokers.size()));\n             }\n //            serviceDiscoveryInvoker.getDirectory().discordAddresses();\n         }\n@@ -298,6 +301,8 @@ protected void refreshServiceDiscoveryInvoker() {\n                 logger.debug(\"Re-subscribing instance addresses, current interface \" + type.getName());\n             }\n             serviceDiscoveryInvoker = registryProtocol.getServiceDiscoveryInvoker(cluster, registry, type, url);\n+        } else {\n+            ((DynamicDirectory)serviceDiscoveryInvoker.getDirectory()).markInvokersChanged();\n         }\n     }\n@@ -310,6 +315,8 @@ protected void refreshInterfaceInvoker() {\n             }\n             invoker = registryProtocol.getInvoker(cluster, registry, type, url);\n+        } else {\n+            ((DynamicDirectory)invoker.getDirectory()).markInvokersChanged();\n         }\n     }\n@@ -331,7 +338,8 @@ protected synchronized void discardInterfaceInvokerAddress(ClusterInvoker<T> inv\n         }\n         if (invoker != null) {\n             if (logger.isDebugEnabled()) {\n-                logger.debug(\"Discarding interface addresses, total address size \" + invoker.getDirectory().getAllInvokers().size());\n+                List<Invoker<T>> invokers = invoker.getDirectory().getAllInvokers();\n+                logger.debug(\"Discarding interface addresses, total address size \" + (invokers == null ? 0 : invokers.size()));\n             }\n             //invoker.getDirectory().discordAddresses();\n         }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java\n@@ -260,17 +260,27 @@ public void discordAddresses() {\n     }\n     private volatile InvokersChangedListener invokersChangedListener;\n+    private volatile boolean invokersChanged;\n-    public void setInvokersChangedListener(InvokersChangedListener listener) {\n+    public synchronized void setInvokersChangedListener(InvokersChangedListener listener) {\n         this.invokersChangedListener = listener;\n-        invokersChanged();\n+        if (invokersChangedListener != null && invokersChanged) {\n+            invokersChangedListener.onChange();\n+            invokersChanged = false;\n+        }\n     }\n-    protected void invokersChanged() {\n-        if (invokersChangedListener != null) {\n+    protected synchronized void invokersChanged() {\n+        invokersChanged = true;\n+        if (invokersChangedListener != null && invokersChanged) {\n             invokersChangedListener.onChange();\n+            invokersChanged = false;\n         }\n     }\n+    public synchronized void markInvokersChanged() {\n+        this.invokersChanged = true;\n+    }\n+\n     protected abstract void destroyAllInvokers();\n }",
    "output": "Fix migration mark invokers as changed when refresh invoker"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n@@ -159,7 +159,7 @@ public Configuration getConfiguration() {\n     public Configuration getDynamicGlobalConfiguration() {\n         if (dynamicGlobalConfiguration == null) {\n-            if (dynamicConfiguration != null) {\n+            if (dynamicConfiguration == null) {\n                 throw new IllegalStateException(\"Init dynamic configuration before use.\");\n             }\n             dynamicGlobalConfiguration = new CompositeConfiguration();\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java\n@@ -267,6 +267,7 @@ public void doSubscribe(URL url, NotifyListener listener) {\n             if (check) {\n                 throw new IllegalStateException(\"Should has at least one way to know which services this interface belongs to, subscription url: \" + url);\n             }\n+            return;\n         }\n         subscribeURLs(url, listener, serviceNames);\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/ServiceDiscoveryMigrationInvoker.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/ServiceDiscoveryMigrationInvoker.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/ServiceDiscoveryMigrationInvoker.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/ServiceDiscoveryMigrationInvoker.java\n@@ -17,6 +17,8 @@\n package org.apache.dubbo.registry.client.migration;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.registry.Registry;\n import org.apache.dubbo.registry.integration.RegistryProtocol;\n import org.apache.dubbo.rpc.Invocation;\n@@ -26,6 +28,7 @@\n import org.apache.dubbo.rpc.cluster.ClusterInvoker;\n public class ServiceDiscoveryMigrationInvoker<T> extends MigrationInvoker<T> {\n+    private static final Logger logger = LoggerFactory.getLogger(ServiceDiscoveryMigrationInvoker.class);\n     public ServiceDiscoveryMigrationInvoker(RegistryProtocol registryProtocol, Cluster cluster, Registry registry, Class<T> type, URL url, URL consumerUrl) {\n         super(registryProtocol, cluster, registry, type, url, consumerUrl);\n@@ -38,7 +41,8 @@ public boolean isServiceDiscovery() {\n     @Override\n     public synchronized void fallbackToInterfaceInvoker() {\n-        destroyServiceDiscoveryInvoker(this.getServiceDiscoveryInvoker());\n+        logger.error(\"Service discovery registry type does not support discovery of interface level addresses, \" + getRegistryUrl());\n+        migrateToServiceDiscoveryInvoker(true);\n     }\n     @Override",
    "output": "Fix service discovery delay subscription"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/ServiceDiscoveryMigrationInvoker.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/ServiceDiscoveryMigrationInvoker.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/ServiceDiscoveryMigrationInvoker.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/ServiceDiscoveryMigrationInvoker.java\n@@ -38,7 +38,7 @@ public boolean isServiceDiscovery() {\n     @Override\n     public synchronized void fallbackToInterfaceInvoker() {\n-        destroyServiceDiscoveryInvoker();\n+        destroyServiceDiscoveryInvoker(this.getServiceDiscoveryInvoker());\n     }\n     @Override",
    "output": "Fix sub class method call"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/ServiceNameMapping.java b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/ServiceNameMapping.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/ServiceNameMapping.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/ServiceNameMapping.java\n@@ -46,8 +46,6 @@ public interface ServiceNameMapping {\n      */\n     Set<String> getAndListen(URL url, MappingListener mappingListener);\n-    Set<String> get(URL url);\n-\n     /**\n      * Get the default extension of {@link ServiceNameMapping}\n      *",
    "output": "Remove interface definition"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -127,6 +127,9 @@ private void refreshInvoker(List<URL> invokerUrls) {\n                 logger.warn(\"destroyUnusedInvokers error. \", e);\n             }\n         }\n+\n+        // notify invokers refreshed\n+        this.invokersChanged();\n     }\n     /**\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n@@ -108,7 +108,7 @@ public synchronized void onEvent(ServiceInstancesChangedEvent event) {\n                     metadata = getMetadataInfo(instance);\n                     logger.info(\"MetadataInfo for instance \" + instance.getAddress() + \"?revision=\" + revision + \" is \" + metadata);\n                     if (metadata != null) {\n-                        revisionToMetadata.put(revision, getMetadataInfo(instance));\n+                        revisionToMetadata.put(revision, metadata);\n                     } else {\n                     }\n@@ -123,23 +123,23 @@ public synchronized void onEvent(ServiceInstancesChangedEvent event) {\n //                    Set<String> set = localServiceToRevisions.computeIfAbsent(url.getServiceKey(), k -> new TreeSet<>());\n //                    set.add(revision);\n //                }\n+            }\n-                localServiceToRevisions.forEach((serviceKey, revisions) -> {\n-                    List<URL> urls = revisionsToUrls.get(revisions);\n-                    if (urls != null) {\n-                        serviceUrls.put(serviceKey, urls);\n-                    } else {\n-                        urls = new ArrayList<>();\n-                        for (String r : revisions) {\n-                            for (ServiceInstance i : revisionToInstances.get(r)) {\n-                                urls.add(i.toURL());\n-                            }\n+            localServiceToRevisions.forEach((serviceKey, revisions) -> {\n+                List<URL> urls = revisionsToUrls.get(revisions);\n+                if (urls != null) {\n+                    serviceUrls.put(serviceKey, urls);\n+                } else {\n+                    urls = new ArrayList<>();\n+                    for (String r : revisions) {\n+                        for (ServiceInstance i : revisionToInstances.get(r)) {\n+                            urls.add(i.toURL());\n                         }\n-                        revisionsToUrls.put(revisions, urls);\n-                        serviceUrls.put(serviceKey, urls);\n                     }\n-                });\n-            }\n+                    revisionsToUrls.put(revisions, urls);\n+                    serviceUrls.put(serviceKey, urls);\n+                }\n+            });\n         }\n         this.notifyAddressChanged();\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/DefaultMigrationAddressComparator.java\n@@ -62,7 +62,7 @@ public <T> boolean shouldMigrate(ClusterInvoker<T> serviceDiscoveryInvoker, Clus\n             return false;\n         }\n-        if ((float) (newAddressSize / oldAddressSize) >= threshold) {\n+        if (((float)newAddressSize / (float)oldAddressSize) >= threshold) {\n             return true;\n         }\n         return false;\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java\n@@ -141,11 +141,11 @@ public synchronized void fallbackToInterfaceInvoker() {\n     @Override\n     public Result invoke(Invocation invocation) throws RpcException {\n-        if (needRefresh(serviceDiscoveryInvoker)) {\n+        if (!checkInvokerAvailable(serviceDiscoveryInvoker)) {\n             return invoker.invoke(invocation);\n         }\n-        if (needRefresh(invoker)) {\n+        if (!checkInvokerAvailable(invoker)) {\n             return serviceDiscoveryInvoker.invoke(invocation);\n         }\n@@ -270,7 +270,10 @@ protected synchronized void discardInterfaceInvokerAddress() {\n     }\n     private boolean needRefresh(ClusterInvoker<T> invoker) {\n-        return invoker == null || invoker.isDestroyed() || !invoker.isAvailable();\n+        return invoker == null || invoker.isDestroyed();\n     }\n+    public boolean checkInvokerAvailable(ClusterInvoker<T> invoker) {\n+        return invoker != null && !invoker.isDestroyed() && invoker.isAvailable();\n+    }\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java\n@@ -32,6 +32,7 @@ public class MigrationRuleHandler<T> {\n     private static final String DUBBO_SERVICEDISCOVERY_MIGRATION = \"dubbo.application.service-discovery.migration\";\n     private MigrationInvoker<T> migrationInvoker;\n+    private MigrationStep currentStep;\n     public MigrationRuleHandler(MigrationInvoker<T> invoker) {\n         this.migrationInvoker = invoker;\n@@ -51,16 +52,19 @@ public void doMigrate(String rawRule) {\n             step = rule.getStep();\n         }\n-        switch (step) {\n-            case APPLICATION_FIRST:\n-                migrationInvoker.migrateToServiceDiscoveryInvoker(false);\n-                break;\n-            case FORCE_APPLICATION:\n-                migrationInvoker.migrateToServiceDiscoveryInvoker(true);\n-                break;\n-            case INTERFACE_FIRST:\n-            default:\n-                migrationInvoker.fallbackToInterfaceInvoker();\n+        if (currentStep == null || currentStep != step) {\n+            currentStep = step;\n+            switch (step) {\n+                case APPLICATION_FIRST:\n+                    migrationInvoker.migrateToServiceDiscoveryInvoker(false);\n+                    break;\n+                case FORCE_APPLICATION:\n+                    migrationInvoker.migrateToServiceDiscoveryInvoker(true);\n+                    break;\n+                case INTERFACE_FIRST:\n+                default:\n+                    migrationInvoker.fallbackToInterfaceInvoker();\n+            }\n         }\n     }\n }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n@@ -71,7 +71,7 @@ public void eventReceived(CuratorFramework client, CuratorEvent event) throws Ex\n     public static void testMigrationRule() {\n         String serviceStr = \"---\\n\" +\n                 \"key: demo-consumer\\n\" +\n-                \"step: APPLICATION_FIRST\\n\" +\n+                \"step: INTERFACE_FIRST\\n\" +\n                 \"...\";\n         try {\n             String servicePath = \"/dubbo/config/DUBBO_SERVICEDISCOVERY_MIGRATION/demo-consumer.migration\";",
    "output": "Fix service discovery address notification and migration bugs"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n@@ -157,7 +157,7 @@ public Configuration getConfiguration() {\n             globalConfiguration.addConfiguration(propertiesConfiguration);\n         } else {\n             if (!globalConfiguration.isDynamicIncluded() && dynamicConfiguration != null) {\n-                globalConfiguration.addConfiguration(dynamicConfiguration);\n+                globalConfiguration.addConfigurationFirst(dynamicConfiguration);\n                 globalConfiguration.setDynamicIncluded(true);\n             }\n         }",
    "output": "Fix, add dynamic config at the first place"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/CompositeConfiguration.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/CompositeConfiguration.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/CompositeConfiguration.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/CompositeConfiguration.java\n@@ -38,6 +38,9 @@ public class CompositeConfiguration implements Configuration {\n      */\n     private List<Configuration> configList = new LinkedList<Configuration>();\n+    //FIXME, consider change configList to SortedMap to replace this boolean status.\n+    private boolean dynamicIncluded;\n+\n     public CompositeConfiguration() {\n         this(null, null);\n     }\n@@ -58,6 +61,15 @@ public CompositeConfiguration(Configuration... configurations) {\n         }\n     }\n+    public void setDynamicIncluded(boolean dynamicIncluded) {\n+        this.dynamicIncluded = dynamicIncluded;\n+    }\n+\n+    //FIXME, consider change configList to SortedMap to replace this boolean status.\n+    public boolean isDynamicIncluded() {\n+        return dynamicIncluded;\n+    }\n+\n     public void addConfiguration(Configuration configuration) {\n         if (configList.contains(configuration)) {\n             return;\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n@@ -148,12 +148,18 @@ public Configuration getConfiguration() {\n             globalConfiguration = new CompositeConfiguration();\n             if (dynamicConfiguration != null) {\n                 globalConfiguration.addConfiguration(dynamicConfiguration);\n+                globalConfiguration.setDynamicIncluded(true);\n             }\n             globalConfiguration.addConfiguration(systemConfiguration);\n             globalConfiguration.addConfiguration(environmentConfiguration);\n             globalConfiguration.addConfiguration(appExternalConfiguration);\n             globalConfiguration.addConfiguration(externalConfiguration);\n             globalConfiguration.addConfiguration(propertiesConfiguration);\n+        } else {\n+            if (!globalConfiguration.isDynamicIncluded() && dynamicConfiguration != null) {\n+                globalConfiguration.addConfiguration(dynamicConfiguration);\n+                globalConfiguration.setDynamicIncluded(true);\n+            }\n         }\n         return globalConfiguration;\n     }",
    "output": "Make sure dynamic configuration is included after globalConfiguration is cached"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java\n@@ -27,6 +27,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.REMOTE_APPLICATION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n public class InstanceAddressURL extends URL {\n@@ -105,6 +106,8 @@ public String getParameter(String key) {\n             return getGroup();\n         } else if (INTERFACE_KEY.equals(key)) {\n             return getServiceInterface();\n+        } else if (REMOTE_APPLICATION_KEY.equals(key)) {\n+            return instance.getServiceName();\n         }\n         String protocolServiceKey = getProtocolServiceKey();",
    "output": "Fix TagRoute unable to get remote application name"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java\n@@ -0,0 +1,36 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.registry.client;\n+\n+public abstract class AbstractServiceDiscovery implements ServiceDiscovery {\n+\n+    protected ServiceInstance serviceInstance;\n+\n+    @Override\n+    public ServiceInstance getLocalInstance() {\n+        return serviceInstance;\n+    }\n+\n+    @Override\n+    public void register(ServiceInstance serviceInstance) throws RuntimeException {\n+    }\n+\n+    @Override\n+    public void update(ServiceInstance serviceInstance) throws RuntimeException {\n+        this.serviceInstance = serviceInstance;\n+    }\n+}\ndiff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.function.ThrowableFunction;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.registry.client.AbstractServiceDiscovery;\n import org.apache.dubbo.registry.client.ServiceDiscovery;\n import org.apache.dubbo.registry.client.ServiceInstance;\n import org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;\n@@ -47,7 +48,7 @@\n  * @see ServiceDiscovery\n  * @since 2.7.5\n  */\n-public class NacosServiceDiscovery implements ServiceDiscovery {\n+public class NacosServiceDiscovery extends AbstractServiceDiscovery {\n     private final Logger logger = LoggerFactory.getLogger(getClass());\n@@ -57,8 +58,6 @@ public class NacosServiceDiscovery implements ServiceDiscovery {\n     private URL registryURL;\n-    private ServiceInstance instance;\n-\n     @Override\n     public void initialize(URL registryURL) throws Exception {\n         this.namingService = createNamingService(registryURL);\n@@ -73,7 +72,7 @@ public void destroy() {\n     @Override\n     public void register(ServiceInstance serviceInstance) throws RuntimeException {\n-        this.instance = serviceInstance;\n+        this.serviceInstance = serviceInstance;\n         execute(namingService, service -> {\n             Instance instance = toInstance(serviceInstance);\n             service.registerInstance(instance.getServiceName(), group, instance);\n@@ -82,7 +81,7 @@ public void register(ServiceInstance serviceInstance) throws RuntimeException {\n     @Override\n     public void update(ServiceInstance serviceInstance) throws RuntimeException {\n-        this.instance = serviceInstance;\n+        this.serviceInstance = serviceInstance;\n         // TODO: Nacos should support\n         unregister(serviceInstance);\n         register(serviceInstance);\n@@ -137,11 +136,6 @@ public URL getUrl() {\n         return registryURL;\n     }\n-    @Override\n-    public ServiceInstance getLocalInstance() {\n-        return instance;\n-    }\n-\n     private void handleEvent(NamingEvent event, ServiceInstancesChangedListener listener) {\n         String serviceName = event.getServiceName();\n         List<ServiceInstance> serviceInstances = event.getInstances()\ndiff --git a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscovery.java\n@@ -24,6 +24,7 @@\n import org.apache.dubbo.common.utils.DefaultPage;\n import org.apache.dubbo.common.utils.Page;\n import org.apache.dubbo.event.EventDispatcher;\n+import org.apache.dubbo.registry.client.AbstractServiceDiscovery;\n import org.apache.dubbo.registry.client.ServiceDiscovery;\n import org.apache.dubbo.registry.client.ServiceInstance;\n import org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;\n@@ -51,7 +52,7 @@\n  * Zookeeper {@link ServiceDiscovery} implementation based on\n  * <a href=\"https://curator.apache.org/curator-x-discovery/index.html\">Apache Curator X Discovery</a>\n  */\n-public class ZookeeperServiceDiscovery implements ServiceDiscovery {\n+public class ZookeeperServiceDiscovery extends AbstractServiceDiscovery {\n     private final Logger logger = LoggerFactory.getLogger(getClass());\n@@ -65,8 +66,6 @@ public class ZookeeperServiceDiscovery implements ServiceDiscovery {\n     private org.apache.curator.x.discovery.ServiceDiscovery<ZookeeperInstance> serviceDiscovery;\n-    private ServiceInstance serviceInstance;\n-\n     /**\n      * The Key is watched Zookeeper path, the value is an instance of {@link CuratorWatcher}\n      */\n@@ -90,11 +89,6 @@ public void destroy() throws Exception {\n         serviceDiscovery.close();\n     }\n-    @Override\n-    public ServiceInstance getLocalInstance() {\n-        return serviceInstance;\n-    }\n-\n     public void register(ServiceInstance serviceInstance) throws RuntimeException {\n         this.serviceInstance = serviceInstance;\n         doInServiceRegistry(serviceDiscovery -> {",
    "output": "Add AbstractServiceDiscovery"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DefaultMigrationAddressComparator.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DefaultMigrationAddressComparator.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DefaultMigrationAddressComparator.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DefaultMigrationAddressComparator.java\n@@ -21,6 +21,9 @@\n public class DefaultMigrationAddressComparator implements MigrationAddressComparator {\n     @Override\n     public <T> boolean shouldMigrate(ClusterInvoker<T> serviceDiscoveryInvoker, ClusterInvoker<T> invoker) {\n-        return true;\n+        if (serviceDiscoveryInvoker.isAvailable()) {\n+            return true;\n+        }\n+        return false;\n     }\n }",
    "output": "Fix typo"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java\n@@ -25,6 +25,7 @@\n import org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;\n import org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils;\n+import com.alibaba.nacos.api.exception.NacosException;\n import com.alibaba.nacos.api.naming.NamingService;\n import com.alibaba.nacos.api.naming.listener.NamingEvent;\n import com.alibaba.nacos.api.naming.pojo.Instance;\n@@ -56,6 +57,8 @@ public class NacosServiceDiscovery implements ServiceDiscovery {\n     private URL registryURL;\n+    private ServiceInstance instance;\n+\n     @Override\n     public void initialize(URL registryURL) throws Exception {\n         this.namingService = createNamingService(registryURL);\n@@ -70,6 +73,7 @@ public void destroy() {\n     @Override\n     public void register(ServiceInstance serviceInstance) throws RuntimeException {\n+        this.instance = serviceInstance;\n         execute(namingService, service -> {\n             Instance instance = toInstance(serviceInstance);\n             service.registerInstance(instance.getServiceName(), group, instance);\n@@ -78,6 +82,7 @@ public void register(ServiceInstance serviceInstance) throws RuntimeException {\n     @Override\n     public void update(ServiceInstance serviceInstance) throws RuntimeException {\n+        this.instance = serviceInstance;\n         // TODO: Nacos should support\n         unregister(serviceInstance);\n         register(serviceInstance);\n@@ -112,10 +117,16 @@ public List<ServiceInstance> getInstances(String serviceName) throws NullPointer\n     public void addServiceInstancesChangedListener(ServiceInstancesChangedListener listener)\n             throws NullPointerException, IllegalArgumentException {\n         execute(namingService, service -> {\n-            service.subscribe(listener.getServiceNames(), e -> { // Register Nacos EventListener\n-                if (e instanceof NamingEvent) {\n-                    NamingEvent event = (NamingEvent) e;\n-                    handleEvent(event, listener);\n+            listener.getServiceNames().forEach(serviceName -> {\n+                try {\n+                    service.subscribe(serviceName, e -> { // Register Nacos EventListener\n+                        if (e instanceof NamingEvent) {\n+                            NamingEvent event = (NamingEvent) e;\n+                            handleEvent(event, listener);\n+                        }\n+                    });\n+                } catch (NacosException e) {\n+                    e.printStackTrace();\n                 }\n             });\n         });\n@@ -126,6 +137,11 @@ public URL getUrl() {\n         return registryURL;\n     }\n+    @Override\n+    public ServiceInstance getLocalInstance() {\n+        return instance;\n+    }\n+\n     private void handleEvent(NamingEvent event, ServiceInstancesChangedListener listener) {\n         String serviceName = event.getServiceName();\n         List<ServiceInstance> serviceInstances = event.getInstances()",
    "output": "Fix wrong parent module version"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -23,6 +23,7 @@\n import org.apache.dubbo.common.utils.Assert;\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.registry.AddressListener;\n import org.apache.dubbo.registry.NotifyListener;\n import org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;\n import org.apache.dubbo.registry.integration.DynamicDirectory;\n@@ -73,26 +74,30 @@ public boolean isAvailable() {\n     public synchronized void notify(List<URL> instanceUrls) {\n         // Set the context of the address notification thread.\n         RpcContext.setRpcContext(getConsumerUrl());\n+\n+        /**\n+         * 3.x added for extend URL address\n+         */\n+        ExtensionLoader<AddressListener> addressListenerExtensionLoader = ExtensionLoader.getExtensionLoader(AddressListener.class);\n+        List<AddressListener> supportedListeners = addressListenerExtensionLoader.getActivateExtension(getUrl(), (String[]) null);\n+        if (supportedListeners != null && !supportedListeners.isEmpty()) {\n+            for (AddressListener addressListener : supportedListeners) {\n+                instanceUrls = addressListener.notify(instanceUrls, getConsumerUrl(), this);\n+            }\n+        }\n+\n         refreshInvoker(instanceUrls);\n     }\n     private void refreshInvoker(List<URL> invokerUrls) {\n-        Assert.notNull(invokerUrls, \"invokerUrls should not be null, use empty InstanceAddressURL to clear address.\");\n+        Assert.notNull(invokerUrls, \"invokerUrls should not be null, use empty url list to clear address.\");\n-        if (invokerUrls.size() == 1) {\n-            URL url = invokerUrls.get(0);\n-            if (!(url instanceof InstanceAddressURL)) {\n-                throw new IllegalStateException(\"use empty InstanceAddressURL to clear address\");\n-            } else {\n-                InstanceAddressURL instanceAddressURL = (InstanceAddressURL) url;\n-                if (instanceAddressURL.getInstance() == null) {\n-                    this.forbidden = true; // Forbid to access\n-                    this.invokers = Collections.emptyList();\n-                    routerChain.setInvokers(this.invokers);\n-                    destroyAllInvokers(); // Close all invokers\n-                    return;\n-                }\n-            }\n+        if (invokerUrls.size() == 0) {\n+            this.forbidden = true; // Forbid to access\n+            this.invokers = Collections.emptyList();\n+            routerChain.setInvokers(this.invokers);\n+            destroyAllInvokers(); // Close all invokers\n+            return;\n         }\n         this.forbidden = false; // Allow to access\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n@@ -19,15 +19,13 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.event.ConditionalEventListener;\n import org.apache.dubbo.event.EventListener;\n import org.apache.dubbo.metadata.MetadataInfo;\n import org.apache.dubbo.metadata.MetadataInfo.ServiceInfo;\n import org.apache.dubbo.metadata.MetadataService;\n import org.apache.dubbo.registry.NotifyListener;\n import org.apache.dubbo.registry.client.DefaultServiceInstance;\n-import org.apache.dubbo.registry.client.InstanceAddressURL;\n import org.apache.dubbo.registry.client.RegistryClusterIdentifier;\n import org.apache.dubbo.registry.client.ServiceDiscovery;\n import org.apache.dubbo.registry.client.ServiceInstance;\n@@ -37,6 +35,7 @@\n import org.apache.dubbo.registry.client.metadata.store.RemoteMetadataServiceImpl;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -86,6 +85,7 @@ public ServiceInstancesChangedListener(Set<String> serviceNames, ServiceDiscover\n      * @param event {@link ServiceInstancesChangedEvent}\n      */\n     public synchronized void onEvent(ServiceInstancesChangedEvent event) {\n+        logger.info(\"Received instance notification, serviceName: \" + event.getServiceName() + \", instances: \" + event.getServiceInstances().size());\n         String appName = event.getServiceName();\n         allInstances.put(appName, event.getServiceInstances());\n@@ -106,6 +106,7 @@ public synchronized void onEvent(ServiceInstancesChangedEvent event) {\n                 MetadataInfo metadata = revisionToMetadata.get(revision);\n                 if (metadata == null) {\n                     metadata = getMetadataInfo(instance);\n+                    logger.info(\"MetadataInfo for instance \" + instance.getAddress() + \"?revision=\" + revision + \" is \" + metadata);\n                     if (metadata != null) {\n                         revisionToMetadata.put(revision, getMetadataInfo(instance));\n                     } else {\n@@ -183,9 +184,8 @@ private void notifyAddressChanged() {\n     }\n     private List<URL> toUrlsWithEmpty(List<URL> urls) {\n-        if (CollectionUtils.isEmpty(urls)) {\n-            urls = new ArrayList<>();\n-            urls.add(new InstanceAddressURL());\n+        if (urls == null) {\n+            urls = Collections.emptyList();\n         }\n         return urls;\n     }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java\n@@ -51,7 +51,7 @@ public void customize(ServiceInstance serviceInstance) {\n         // FIXME, check the same key in different urls has the same value\n         MetadataInfo metadataInfo = localMetadataService.getMetadataInfos().values().iterator().next();\n         MetadataInfo.ServiceInfo serviceInfo = metadataInfo.getServices().values().iterator().next();\n-        Map<String, String> allParams = new HashMap<>(serviceInfo.getParams());\n+        Map<String, String> allParams = new HashMap<>(serviceInfo.getUrl().getParameters());\n         // load instance params users want to load.\n         // TODO, duplicate logic with that in ApplicationConfig\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java\n@@ -85,7 +85,7 @@ public MetadataInfo getMetadata(ServiceInstance instance) {\n         if (metadataReport == null) {\n             metadataReport = getMetadataReports().entrySet().iterator().next().getValue();\n         }\n-        return metadataReport.getAppMetadata(identifier, instance.getMetadata());\n+        return metadataReport.getAppMetadata(identifier, instance.getExtendParams());\n     }\n     public void publishServiceDefinition(URL url) {",
    "output": "Fix address notification issue"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -44,7 +44,7 @@\n public class ServiceDiscoveryRegistryDirectory<T> extends DynamicDirectory<T> implements NotifyListener {\n     private static final Logger logger = LoggerFactory.getLogger(ServiceDiscoveryRegistryDirectory.class);\n-    // Map<url, Invoker> cache service url to invoker mapping.\n+    // instance address to invoker mapping.\n     private volatile Map<String, Invoker<T>> urlInvokerMap; // The initial value is null and the midway may be assigned to null, please use the local variable reference\n     private ServiceInstancesChangedListener listener;\n@@ -53,6 +53,22 @@ public ServiceDiscoveryRegistryDirectory(Class<T> serviceType, URL url) {\n         super(serviceType, url);\n     }\n+    @Override\n+    public boolean isAvailable() {\n+        if (isDestroyed()) {\n+            return false;\n+        }\n+        Map<String, Invoker<T>> localUrlInvokerMap = urlInvokerMap;\n+        if (localUrlInvokerMap != null && localUrlInvokerMap.size() > 0) {\n+            for (Invoker<T> invoker : new ArrayList<>(localUrlInvokerMap.values())) {\n+                if (invoker.isAvailable()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n     @Override\n     public synchronized void notify(List<URL> instanceUrls) {\n         // Set the context of the address notification thread.\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java\n@@ -27,8 +27,10 @@\n import java.util.Map;\n import static java.lang.String.valueOf;\n+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PORT_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n import static org.apache.dubbo.metadata.MetadataConstants.DEFAULT_METADATA_TIMEOUT_VALUE;\n import static org.apache.dubbo.metadata.MetadataConstants.METADATA_PROXY_TIMEOUT_KEY;\n@@ -70,7 +72,8 @@ public List<URL> build(ServiceInstance serviceInstance) {\n                     .setPort(port)\n                     .setProtocol(protocol)\n                     .setPath(MetadataService.class.getName())\n-                    .addParameter(TIMEOUT_KEY, ConfigurationUtils.get(METADATA_PROXY_TIMEOUT_KEY, DEFAULT_METADATA_TIMEOUT_VALUE));\n+                    .addParameter(TIMEOUT_KEY, ConfigurationUtils.get(METADATA_PROXY_TIMEOUT_KEY, DEFAULT_METADATA_TIMEOUT_VALUE))\n+                    .addParameter(SIDE_KEY, CONSUMER);\n             // add parameters\n             params.forEach((name, value) -> urlBuilder.addParameter(name, valueOf(value)));",
    "output": "Add side key to MetadataService"
  },
  {
    "input": "diff --git a/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java b/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java\n--- a/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java\n+++ b/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.demo.consumer;\n import org.apache.dubbo.demo.DemoService;\n+import org.apache.dubbo.demo.GreetingService;\n import org.springframework.context.support.ClassPathXmlApplicationContext;\n@@ -31,9 +32,27 @@ public static void main(String[] args) throws Exception {\n         ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring/dubbo-consumer.xml\");\n         context.start();\n         DemoService demoService = context.getBean(\"demoService\", DemoService.class);\n+        GreetingService greetingService = context.getBean(\"greetingService\", GreetingService.class);\n+\n+        new Thread(() -> {\n+            while (true) {\n+                String greetings = greetingService.hello();\n+                System.out.println(greetings + \" from separated thread.\");\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }).start();\n+\n         while (true) {\n             CompletableFuture<String> hello = demoService.sayHelloAsync(\"world\");\n             System.out.println(\"result: \" + hello.get());\n+\n+            String greetings = greetingService.hello();\n+            System.out.println(\"result: \" + greetings);\n+\n             Thread.sleep(500);\n         }\n     }\ndiff --git a/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-provider/src/main/java/org/apache/dubbo/demo/provider/GreetingServiceImpl.java b/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-provider/src/main/java/org/apache/dubbo/demo/provider/GreetingServiceImpl.java\n--- a/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-provider/src/main/java/org/apache/dubbo/demo/provider/GreetingServiceImpl.java\n+++ b/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-provider/src/main/java/org/apache/dubbo/demo/provider/GreetingServiceImpl.java\n@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.demo.provider;\n+\n+import org.apache.dubbo.demo.GreetingService;\n+\n+/**\n+ *\n+ */\n+public class GreetingServiceImpl implements GreetingService {\n+    @Override\n+    public String hello() {\n+        return \"Greetings!\";\n+    }\n+}",
    "output": "Add demo"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java\n@@ -125,7 +125,7 @@ public SortedSet<String> getExportedURLs(String serviceInterface, String group,\n     @Override\n     public boolean exportURL(URL url) {\n-        String registryCluster = RegistryClusterIdentifier.getExtension().providerKey(url);\n+        String registryCluster = RegistryClusterIdentifier.getExtension(url).providerKey(url);\n         String[] clusters = registryCluster.split(\",\");\n         for (String cluster : clusters) {\n             MetadataInfo metadataInfo = metadataInfos.computeIfAbsent(cluster, k -> {\n@@ -139,7 +139,7 @@ public boolean exportURL(URL url) {\n     @Override\n     public boolean unexportURL(URL url) {\n-        String registryCluster = RegistryClusterIdentifier.getExtension().providerKey(url);\n+        String registryCluster = RegistryClusterIdentifier.getExtension(url).providerKey(url);\n         String[] clusters = registryCluster.split(\",\");\n         for (String cluster : clusters) {\n             MetadataInfo metadataInfo = metadataInfos.get(cluster);",
    "output": "Fix compilation error"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java\n@@ -117,6 +117,11 @@ public String getTargetServiceUniqueName() {\n             return delegate.getTargetServiceUniqueName();\n         }\n+        @Override\n+        public String getProtocolServiceKey() {\n+            return delegate.getProtocolServiceKey();\n+        }\n+\n         @Override\n         public String getMethodName() {\n             return delegate.getMethodName();\ndiff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n@@ -108,6 +108,11 @@ public void setInvoker(Invoker<?> invoker) {\n         this.invoker = invoker;\n     }\n+    @Override\n+    public String getProtocolServiceKey() {\n+        return null;\n+    }\n+\n     public String getMethodName() {\n         return methodName;\n     }\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/cache/CacheTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/cache/CacheTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/cache/CacheTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/cache/CacheTest.java\n@@ -53,6 +53,11 @@ public String getTargetServiceUniqueName() {\n             return null;\n         }\n+        @Override\n+        public String getProtocolServiceKey() {\n+            return null;\n+        }\n+\n         @Override\n         public String getMethodName() {\n             return null;\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java b/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java\n@@ -45,6 +45,11 @@ public String getTargetServiceUniqueName() {\n         return null;\n     }\n+    @Override\n+    public String getProtocolServiceKey() {\n+        return null;\n+    }\n+\n     public String getMethodName() {\n         return \"echo\";\n     }\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/service/MockInvocation.java b/dubbo-compatible/src/test/java/org/apache/dubbo/service/MockInvocation.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/service/MockInvocation.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/service/MockInvocation.java\n@@ -56,6 +56,11 @@ public String getTargetServiceUniqueName() {\n         return null;\n     }\n+    @Override\n+    public String getProtocolServiceKey() {\n+        return null;\n+    }\n+\n     public String getMethodName() {\n         return \"echo\";\n     }",
    "output": "Fix uts"
  },
  {
    "input": "diff --git a/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/MetricsFilterTest.java b/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/MetricsFilterTest.java\n--- a/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/MetricsFilterTest.java\n+++ b/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/MetricsFilterTest.java\n@@ -116,7 +116,7 @@ public void testConsumerSuccess() throws Exception {\n         IMetricManager metricManager = MetricManager.getIMetricManager();\n         metricManager.clear();\n         MetricsFilter metricsFilter = new MetricsFilter();\n-        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), new Class<?>[]{Integer.class}, new Object[0]);\n+        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), \"\", new Class<?>[]{Integer.class}, new Object[0]);\n         RpcContext.getContext().setRemoteAddress(NetUtils.getLocalHost(), 20880).setLocalAddress(NetUtils.getLocalHost(), 2345);\n         RpcContext.getContext().setUrl(serviceInvoker.getUrl().addParameter(SIDE_KEY, CONSUMER_SIDE));\n         AppResponse response = AppResponseBuilder.create()\n@@ -144,7 +144,7 @@ public void testConsumerTimeout() {\n         IMetricManager metricManager = MetricManager.getIMetricManager();\n         metricManager.clear();\n         MetricsFilter metricsFilter = new MetricsFilter();\n-        Invocation invocation = new RpcInvocation(\"timeoutException\", DemoService.class.getName(), null, null);\n+        Invocation invocation = new RpcInvocation(\"timeoutException\", DemoService.class.getName(), \"\", null, null);\n         RpcContext.getContext().setRemoteAddress(NetUtils.getLocalHost(), 20880).setLocalAddress(NetUtils.getLocalHost(), 2345);\n         RpcContext.getContext().setUrl(timeoutInvoker.getUrl().addParameter(SIDE_KEY, CONSUMER_SIDE)\n             .addParameter(TIMEOUT_KEY, 300));\n@@ -177,7 +177,7 @@ public void testProviderSuccess() throws Exception {\n         IMetricManager metricManager = MetricManager.getIMetricManager();\n         metricManager.clear();\n         MetricsFilter metricsFilter = new MetricsFilter();\n-        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), new Class<?>[0], new Object[0]);\n+        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), \"\", new Class<?>[0], new Object[0]);\n         RpcContext.getContext().setRemoteAddress(NetUtils.getLocalHost(), 20880).setLocalAddress(NetUtils.getLocalHost(), 2345);\n         RpcContext.getContext().setUrl(serviceInvoker.getUrl().addParameter(SIDE_KEY, PROVIDER));\n         AppResponse response = AppResponseBuilder.create()\n@@ -204,7 +204,7 @@ public void testInvokeMetricsService() {\n         IMetricManager metricManager = MetricManager.getIMetricManager();\n         metricManager.clear();\n         MetricsFilter metricsFilter = new MetricsFilter();\n-        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), new Class<?>[0], new Object[0]);\n+        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), \"\", new Class<?>[0], new Object[0]);\n         RpcContext.getContext().setRemoteAddress(NetUtils.getLocalHost(), 20880).setLocalAddress(NetUtils.getLocalHost(), 2345);\n         RpcContext.getContext().setUrl(serviceInvoker.getUrl().addParameter(SIDE_KEY, PROVIDER_SIDE)\n             .addParameter(TIMEOUT_KEY, 300));\n@@ -222,7 +222,7 @@ public void testInvokeMetricsService() {\n         Protocol protocol = new DubboProtocol();\n         URL url = URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":20880/\" + MetricsService.class.getName());\n         Invoker<MetricsService> invoker = protocol.refer(MetricsService.class, url);\n-        invocation = new RpcInvocation(\"getMetricsByGroup\", DemoService.class.getName(), new Class<?>[]{String.class}, new Object[]{DUBBO_GROUP});\n+        invocation = new RpcInvocation(\"getMetricsByGroup\", DemoService.class.getName(), \"\", new Class<?>[]{String.class}, new Object[]{DUBBO_GROUP});\n         try {\n             Thread.sleep(5000);\n         } catch (Exception e) {\n@@ -251,13 +251,13 @@ public void testInvokeMetricsMethodService() {\n         IMetricManager metricManager = MetricManager.getIMetricManager();\n         metricManager.clear();\n         MetricsFilter metricsFilter = new MetricsFilter();\n-        Invocation sayNameInvocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), new Class<?>[0], new Object[0]);\n-        Invocation echoInvocation = new RpcInvocation(\"echo\", DemoService.class.getName(), new Class<?>[]{Integer.class}, new Integer[]{1});\n+        Invocation sayNameInvocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), \"\", new Class<?>[0], new Object[0]);\n+        Invocation echoInvocation = new RpcInvocation(\"echo\", DemoService.class.getName(), \"\", new Class<?>[]{Integer.class}, new Integer[]{1});\n         RpcContext.getContext().setRemoteAddress(NetUtils.getLocalHost(), 20880).setLocalAddress(NetUtils.getLocalHost(), 2345);\n         RpcContext.getContext().setUrl(serviceInvoker.getUrl().addParameter(SIDE_KEY, PROVIDER_SIDE)\n-            .addParameter(TIMEOUT_KEY, 300));\n+                .addParameter(TIMEOUT_KEY, 300));\n         AppResponse response = AppResponseBuilder.create()\n-            .build();\n+                .build();\n         onInvokeReturns(response);\n         for (int i = 0; i < 50; i++) {\n             metricsFilter.invoke(serviceInvoker, sayNameInvocation);\n@@ -277,7 +277,7 @@ public void testInvokeMetricsMethodService() {\n         Protocol protocol = new DubboProtocol();\n         URL url = URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":20880/\" + MetricsService.class.getName());\n         Invoker<MetricsService> invoker = protocol.refer(MetricsService.class, url);\n-        Invocation invocation = new RpcInvocation(\"getMetricsByGroup\", DemoService.class.getName(), new Class<?>[]{String.class}, new Object[]{DUBBO_GROUP});\n+        Invocation invocation = new RpcInvocation(\"getMetricsByGroup\", DemoService.class.getName(), \"\", new Class<?>[]{String.class}, new Object[]{DUBBO_GROUP});\n         try {\n             Thread.sleep(15000);\n         } catch (Exception e) {\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/RestProtocolTest.java b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/RestProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/RestProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/RestProtocolTest.java\n@@ -177,7 +177,7 @@ public void testInvoke() {\n         Exporter<DemoService> exporter = protocol.export(proxy.getInvoker(server, DemoService.class, exportUrl));\n-        RpcInvocation rpcInvocation = new RpcInvocation(\"hello\", DemoService.class.getName(), new Class[]{Integer.class, Integer.class}, new Integer[]{2, 3});\n+        RpcInvocation rpcInvocation = new RpcInvocation(\"hello\", DemoService.class.getName(), \"\", new Class[]{Integer.class, Integer.class}, new Integer[]{2, 3});\n         Result result = exporter.getInvoker().invoke(rpcInvocation);\n         assertThat(result.getValue(), CoreMatchers.<Object>is(5));",
    "output": "Fix uts"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -23,6 +23,7 @@\n import org.apache.dubbo.common.utils.Assert;\n import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.registry.AddressListener;\n import org.apache.dubbo.registry.NotifyListener;\n import org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;\n import org.apache.dubbo.registry.integration.DynamicDirectory;\n@@ -73,26 +74,30 @@ public boolean isAvailable() {\n     public synchronized void notify(List<URL> instanceUrls) {\n         // Set the context of the address notification thread.\n         RpcContext.setRpcContext(getConsumerUrl());\n+\n+        /**\n+         * 3.x added for extend URL address\n+         */\n+        ExtensionLoader<AddressListener> addressListenerExtensionLoader = ExtensionLoader.getExtensionLoader(AddressListener.class);\n+        List<AddressListener> supportedListeners = addressListenerExtensionLoader.getActivateExtension(getUrl(), (String[]) null);\n+        if (supportedListeners != null && !supportedListeners.isEmpty()) {\n+            for (AddressListener addressListener : supportedListeners) {\n+                instanceUrls = addressListener.notify(instanceUrls, getConsumerUrl(), this);\n+            }\n+        }\n+\n         refreshInvoker(instanceUrls);\n     }\n     private void refreshInvoker(List<URL> invokerUrls) {\n-        Assert.notNull(invokerUrls, \"invokerUrls should not be null, use empty InstanceAddressURL to clear address.\");\n+        Assert.notNull(invokerUrls, \"invokerUrls should not be null, use empty url list to clear address.\");\n-        if (invokerUrls.size() == 1) {\n-            URL url = invokerUrls.get(0);\n-            if (!(url instanceof InstanceAddressURL)) {\n-                throw new IllegalStateException(\"use empty InstanceAddressURL to clear address\");\n-            } else {\n-                InstanceAddressURL instanceAddressURL = (InstanceAddressURL) url;\n-                if (instanceAddressURL.getInstance() == null) {\n-                    this.forbidden = true; // Forbid to access\n-                    this.invokers = Collections.emptyList();\n-                    routerChain.setInvokers(this.invokers);\n-                    destroyAllInvokers(); // Close all invokers\n-                    return;\n-                }\n-            }\n+        if (invokerUrls.size() == 0) {\n+            this.forbidden = true; // Forbid to access\n+            this.invokers = Collections.emptyList();\n+            routerChain.setInvokers(this.invokers);\n+            destroyAllInvokers(); // Close all invokers\n+            return;\n         }\n         this.forbidden = false; // Allow to access\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java\n@@ -19,15 +19,13 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.event.ConditionalEventListener;\n import org.apache.dubbo.event.EventListener;\n import org.apache.dubbo.metadata.MetadataInfo;\n import org.apache.dubbo.metadata.MetadataInfo.ServiceInfo;\n import org.apache.dubbo.metadata.MetadataService;\n import org.apache.dubbo.registry.NotifyListener;\n import org.apache.dubbo.registry.client.DefaultServiceInstance;\n-import org.apache.dubbo.registry.client.InstanceAddressURL;\n import org.apache.dubbo.registry.client.RegistryClusterIdentifier;\n import org.apache.dubbo.registry.client.ServiceDiscovery;\n import org.apache.dubbo.registry.client.ServiceInstance;\n@@ -37,6 +35,7 @@\n import org.apache.dubbo.registry.client.metadata.store.RemoteMetadataServiceImpl;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -86,6 +85,7 @@ public ServiceInstancesChangedListener(Set<String> serviceNames, ServiceDiscover\n      * @param event {@link ServiceInstancesChangedEvent}\n      */\n     public synchronized void onEvent(ServiceInstancesChangedEvent event) {\n+        logger.info(\"Received instance notification, serviceName: \" + event.getServiceName() + \", instances: \" + event.getServiceInstances().size());\n         String appName = event.getServiceName();\n         allInstances.put(appName, event.getServiceInstances());\n@@ -106,6 +106,7 @@ public synchronized void onEvent(ServiceInstancesChangedEvent event) {\n                 MetadataInfo metadata = revisionToMetadata.get(revision);\n                 if (metadata == null) {\n                     metadata = getMetadataInfo(instance);\n+                    logger.info(\"MetadataInfo for instance \" + instance.getAddress() + \"?revision=\" + revision + \" is \" + metadata);\n                     if (metadata != null) {\n                         revisionToMetadata.put(revision, getMetadataInfo(instance));\n                     } else {\n@@ -183,9 +184,8 @@ private void notifyAddressChanged() {\n     }\n     private List<URL> toUrlsWithEmpty(List<URL> urls) {\n-        if (CollectionUtils.isEmpty(urls)) {\n-            urls = new ArrayList<>();\n-            urls.add(new InstanceAddressURL());\n+        if (urls == null) {\n+            urls = Collections.emptyList();\n         }\n         return urls;\n     }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataCustomizer.java\n@@ -51,7 +51,7 @@ public void customize(ServiceInstance serviceInstance) {\n         // FIXME, check the same key in different urls has the same value\n         MetadataInfo metadataInfo = localMetadataService.getMetadataInfos().values().iterator().next();\n         MetadataInfo.ServiceInfo serviceInfo = metadataInfo.getServices().values().iterator().next();\n-        Map<String, String> allParams = new HashMap<>(serviceInfo.getParams());\n+        Map<String, String> allParams = new HashMap<>(serviceInfo.getUrl().getParameters());\n         // load instance params users want to load.\n         // TODO, duplicate logic with that in ApplicationConfig\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/RemoteMetadataServiceImpl.java\n@@ -85,7 +85,7 @@ public MetadataInfo getMetadata(ServiceInstance instance) {\n         if (metadataReport == null) {\n             metadataReport = getMetadataReports().entrySet().iterator().next().getValue();\n         }\n-        return metadataReport.getAppMetadata(identifier, instance.getMetadata());\n+        return metadataReport.getAppMetadata(identifier, instance.getExtendParams());\n     }\n     public void publishServiceDefinition(URL url) {",
    "output": "Fix address notification issue"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java b/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java\n--- a/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java\n+++ b/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java\n@@ -32,6 +32,7 @@\n import com.orbitz.consul.KeyValueClient;\n import com.orbitz.consul.cache.KVCache;\n import com.orbitz.consul.model.kv.Value;\n+import org.apache.dubbo.common.utils.StringUtils;\n import java.util.Collection;\n import java.util.LinkedHashSet;\n@@ -55,17 +56,26 @@ public class ConsulDynamicConfiguration extends TreePathDynamicConfiguration {\n     private static final int DEFAULT_WATCH_TIMEOUT = 60 * 1000;\n     private static final String WATCH_TIMEOUT = \"consul-watch-timeout\";\n-    private Consul client;\n+    private final Consul client;\n-    private KeyValueClient kvClient;\n+    private final KeyValueClient kvClient;\n-    private ConcurrentMap<String, ConsulListener> watchers = new ConcurrentHashMap<>();\n+    private final int watchTimeout;\n+\n+    private final ConcurrentMap<String, ConsulListener> watchers = new ConcurrentHashMap<>();\n     public ConsulDynamicConfiguration(URL url) {\n         super(url);\n+        watchTimeout = url.getParameter(WATCH_TIMEOUT, DEFAULT_WATCH_TIMEOUT);\n         String host = url.getHost();\n         int port = url.getPort() != 0 ? url.getPort() : DEFAULT_PORT;\n-        client = Consul.builder().withHostAndPort(HostAndPort.fromParts(host, port)).build();\n+        Consul.Builder builder = Consul.builder()\n+                .withHostAndPort(HostAndPort.fromParts(host, port));\n+        String token = url.getParameter(\"token\", (String) null);\n+        if (StringUtils.isNotEmpty(token)) {\n+            builder.withAclToken(token);\n+        }\n+        client = builder.build();\n         this.kvClient = client.keyValueClient();\n     }\n@@ -128,16 +138,16 @@ protected void doClose() throws Exception {\n     private class ConsulListener implements KVCache.Listener<String, Value> {\n         private KVCache kvCache;\n-        private Set<ConfigurationListener> listeners = new LinkedHashSet<>();\n-        private String normalizedKey;\n+        private final Set<ConfigurationListener> listeners = new LinkedHashSet<>();\n+        private final String normalizedKey;\n         public ConsulListener(String normalizedKey) {\n             this.normalizedKey = normalizedKey;\n             initKVCache();\n         }\n         private void initKVCache() {\n-            this.kvCache = KVCache.newCache(kvClient, normalizedKey);\n+            this.kvCache = KVCache.newCache(kvClient, normalizedKey, watchTimeout);\n             kvCache.addListener(this);\n             kvCache.start();\n         }",
    "output": "Fix issue 6504, and polish some code"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java\n@@ -44,7 +44,7 @@\n public class ServiceDiscoveryRegistryDirectory<T> extends DynamicDirectory<T> implements NotifyListener {\n     private static final Logger logger = LoggerFactory.getLogger(ServiceDiscoveryRegistryDirectory.class);\n-    // Map<url, Invoker> cache service url to invoker mapping.\n+    // instance address to invoker mapping.\n     private volatile Map<String, Invoker<T>> urlInvokerMap; // The initial value is null and the midway may be assigned to null, please use the local variable reference\n     private ServiceInstancesChangedListener listener;\n@@ -53,6 +53,22 @@ public ServiceDiscoveryRegistryDirectory(Class<T> serviceType, URL url) {\n         super(serviceType, url);\n     }\n+    @Override\n+    public boolean isAvailable() {\n+        if (isDestroyed()) {\n+            return false;\n+        }\n+        Map<String, Invoker<T>> localUrlInvokerMap = urlInvokerMap;\n+        if (localUrlInvokerMap != null && localUrlInvokerMap.size() > 0) {\n+            for (Invoker<T> invoker : new ArrayList<>(localUrlInvokerMap.values())) {\n+                if (invoker.isAvailable()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n     @Override\n     public synchronized void notify(List<URL> instanceUrls) {\n         // Set the context of the address notification thread.\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/StandardMetadataServiceURLBuilder.java\n@@ -27,8 +27,10 @@\n import java.util.Map;\n import static java.lang.String.valueOf;\n+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PORT_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n import static org.apache.dubbo.metadata.MetadataConstants.DEFAULT_METADATA_TIMEOUT_VALUE;\n import static org.apache.dubbo.metadata.MetadataConstants.METADATA_PROXY_TIMEOUT_KEY;\n@@ -70,7 +72,8 @@ public List<URL> build(ServiceInstance serviceInstance) {\n                     .setPort(port)\n                     .setProtocol(protocol)\n                     .setPath(MetadataService.class.getName())\n-                    .addParameter(TIMEOUT_KEY, ConfigurationUtils.get(METADATA_PROXY_TIMEOUT_KEY, DEFAULT_METADATA_TIMEOUT_VALUE));\n+                    .addParameter(TIMEOUT_KEY, ConfigurationUtils.get(METADATA_PROXY_TIMEOUT_KEY, DEFAULT_METADATA_TIMEOUT_VALUE))\n+                    .addParameter(SIDE_KEY, CONSUMER);\n             // add parameters\n             params.forEach((name, value) -> urlBuilder.addParameter(name, valueOf(value)));",
    "output": "Add side key to MetadataService"
  },
  {
    "input": "diff --git a/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java b/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java\n--- a/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java\n+++ b/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.demo.consumer;\n import org.apache.dubbo.demo.DemoService;\n+import org.apache.dubbo.demo.GreetingService;\n import org.springframework.context.support.ClassPathXmlApplicationContext;\n@@ -31,9 +32,27 @@ public static void main(String[] args) throws Exception {\n         ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring/dubbo-consumer.xml\");\n         context.start();\n         DemoService demoService = context.getBean(\"demoService\", DemoService.class);\n+        GreetingService greetingService = context.getBean(\"greetingService\", GreetingService.class);\n+\n+        new Thread(() -> {\n+            while (true) {\n+                String greetings = greetingService.hello();\n+                System.out.println(greetings + \" from separated thread.\");\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }).start();\n+\n         while (true) {\n             CompletableFuture<String> hello = demoService.sayHelloAsync(\"world\");\n             System.out.println(\"result: \" + hello.get());\n+\n+            String greetings = greetingService.hello();\n+            System.out.println(\"result: \" + greetings);\n+\n             Thread.sleep(500);\n         }\n     }\ndiff --git a/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-provider/src/main/java/org/apache/dubbo/demo/provider/GreetingServiceImpl.java b/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-provider/src/main/java/org/apache/dubbo/demo/provider/GreetingServiceImpl.java\n--- a/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-provider/src/main/java/org/apache/dubbo/demo/provider/GreetingServiceImpl.java\n+++ b/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-provider/src/main/java/org/apache/dubbo/demo/provider/GreetingServiceImpl.java\n@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.demo.provider;\n+\n+import org.apache.dubbo.demo.GreetingService;\n+\n+/**\n+ *\n+ */\n+public class GreetingServiceImpl implements GreetingService {\n+    @Override\n+    public String hello() {\n+        return \"Greetings!\";\n+    }\n+}",
    "output": "Add demo"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/store/InMemoryWritableMetadataService.java\n@@ -125,7 +125,7 @@ public SortedSet<String> getExportedURLs(String serviceInterface, String group,\n     @Override\n     public boolean exportURL(URL url) {\n-        String registryCluster = RegistryClusterIdentifier.getExtension().providerKey(url);\n+        String registryCluster = RegistryClusterIdentifier.getExtension(url).providerKey(url);\n         String[] clusters = registryCluster.split(\",\");\n         for (String cluster : clusters) {\n             MetadataInfo metadataInfo = metadataInfos.computeIfAbsent(cluster, k -> {\n@@ -139,7 +139,7 @@ public boolean exportURL(URL url) {\n     @Override\n     public boolean unexportURL(URL url) {\n-        String registryCluster = RegistryClusterIdentifier.getExtension().providerKey(url);\n+        String registryCluster = RegistryClusterIdentifier.getExtension(url).providerKey(url);\n         String[] clusters = registryCluster.split(\",\");\n         for (String cluster : clusters) {\n             MetadataInfo metadataInfo = metadataInfos.get(cluster);",
    "output": "Fix compilation error"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -329,6 +329,11 @@ public interface CommonConstants {\n     String SSL_ENABLED_KEY = \"ssl-enabled\";\n+    String SERVICE_PATH_PREFIX = \"service.path.prefix\";\n+\n+    String PROTOCOL_SERVER_SERVLET = \"servlet\";\n+\n+    String PROTOCOL_SERVER = \"server\";\n     /**\n      * The parameter key for the class path of the ServiceNameMapping {@link Properties} file\ndiff --git a/dubbo-rpc/dubbo-rpc-webservice/src/main/java/org/apache/dubbo/rpc/protocol/webservice/WebServiceProtocol.java b/dubbo-rpc/dubbo-rpc-webservice/src/main/java/org/apache/dubbo/rpc/protocol/webservice/WebServiceProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-webservice/src/main/java/org/apache/dubbo/rpc/protocol/webservice/WebServiceProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-webservice/src/main/java/org/apache/dubbo/rpc/protocol/webservice/WebServiceProtocol.java\n@@ -57,7 +57,10 @@\n import java.lang.reflect.Method;\n import java.net.SocketTimeoutException;\n+import static org.apache.dubbo.common.constants.CommonConstants.SERVICE_PATH_PREFIX;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_TIMEOUT;\n+import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_SERVER;\n+import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_SERVER_SERVLET;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n /**\n@@ -132,8 +135,12 @@ public void run() {\n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcException {\n+    protected <T> T doRefer(final Class<T> serviceType, URL url) throws RpcException {\n         ClientProxyFactoryBean proxyFactoryBean = new ClientProxyFactoryBean();\n+        String servicePathPrefix = url.getParameter(SERVICE_PATH_PREFIX);\n+        if (!StringUtils.isEmpty(servicePathPrefix) && PROTOCOL_SERVER_SERVLET.equals(url.getParameter(PROTOCOL_SERVER))) {\n+            url = url.setPath(servicePathPrefix + \"/\" + url.getPath());\n+        }\n         proxyFactoryBean.setAddress(url.setProtocol(\"http\").toIdentityString());\n         proxyFactoryBean.setServiceClass(serviceType);\n         proxyFactoryBean.setBus(bus);\ndiff --git a/dubbo-rpc/dubbo-rpc-webservice/src/test/java/org/apache/dubbo/rpc/protocol/webservice/WebserviceProtocolTest.java b/dubbo-rpc/dubbo-rpc-webservice/src/test/java/org/apache/dubbo/rpc/protocol/webservice/WebserviceProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-webservice/src/test/java/org/apache/dubbo/rpc/protocol/webservice/WebserviceProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-webservice/src/test/java/org/apache/dubbo/rpc/protocol/webservice/WebserviceProtocolTest.java\n@@ -16,15 +16,25 @@\n  */\n package org.apache.dubbo.rpc.protocol.webservice;\n+import org.apache.catalina.Context;\n+import org.apache.catalina.LifecycleException;\n+import org.apache.catalina.connector.Connector;\n+import org.apache.catalina.startup.Tomcat;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.URLBuilder;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.remoting.http.servlet.DispatcherServlet;\n+import org.apache.dubbo.remoting.http.servlet.ServletManager;\n import org.apache.dubbo.rpc.Exporter;\n import org.apache.dubbo.rpc.Protocol;\n import org.apache.dubbo.rpc.ProxyFactory;\n import org.junit.jupiter.api.Test;\n+import java.io.File;\n+\n+import static org.apache.dubbo.common.constants.CommonConstants.SERVICE_PATH_PREFIX;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -73,5 +83,85 @@ public void testWebserviceProtocol() throws Exception {\n //        assertEquals(echo.$echo(1234), 1234);\n     }\n+    @Test\n+    public void testWebserviceServlet() throws LifecycleException {\n+        int port = 55065;\n+        Tomcat tomcat = buildTomcat(\"/dubbo-webservice\", \"/services/*\", port);\n+        DemoService service = new DemoServiceImpl();\n+\n+\n+        URLBuilder builder = new URLBuilder()\n+                .setProtocol(\"webservice\")\n+                .setHost(\"127.0.0.1\")\n+                .setPort(port)\n+                .setPath(\"dubbo-webservice2/\" + DemoService.class.getName())\n+                .addParameter(\"server\", \"servlet\")\n+                .addParameter(\"bind.port\", 55065)\n+                .addParameter(\"contextpath\", \"dubbo-webservice2\")\n+                .addParameter(SERVICE_PATH_PREFIX, \"dubbo-webservice/services\")\n+                .addParameter(\"codec\", \"exchange\")\n+                .addParameter(\"timeout\", 600000);\n+        URL url = builder.build();\n+\n+        tomcat.start();\n+        Exporter<DemoService> exporter = protocol.export(proxy.getInvoker(service, DemoService.class, url));\n+        service = proxy.getProxy(protocol.refer(DemoService.class, url));\n+        assertEquals(service.getSize(new String[]{\"\", \"\", \"\"}), 3);\n+        exporter.unexport();\n+        tomcat.stop();\n+        tomcat.destroy();\n+    }\n+\n+    @Test\n+    public void testWebserviceJetty() throws LifecycleException {\n+        Tomcat tomcat = buildTomcat(\"/dubbo-webservice\", \"/services/*\", 55065);\n+        DemoService service = new DemoServiceImpl();\n+        int port = 55066;\n+        URLBuilder builder = new URLBuilder()\n+                .setProtocol(\"webservice\")\n+                .setHost(\"127.0.0.1\")\n+                .setPort(port)\n+                .setPath(\"dubbo-webservice3/\" + DemoService.class.getName())\n+                .addParameter(\"server\", \"jetty\")\n+                .addParameter(\"bind.port\", 55066)\n+                .addParameter(\"contextpath\", \"dubbo-webservice2\")\n+                .addParameter(\"codec\", \"exchange\")\n+                .addParameter(\"timeout\", 3000);\n+        URL url = builder.build();\n+\n+        tomcat.start();\n+        Exporter<DemoService> exporter = protocol.export(proxy.getInvoker(service, DemoService.class, url));\n+        service = proxy.getProxy(protocol.refer(DemoService.class, url));\n+        assertEquals(service.getSize(new String[]{\"\", \"\", \"\"}), 3);\n+        exporter.unexport();\n+        tomcat.stop();\n+        tomcat.destroy();\n+    }\n+\n+    private Tomcat buildTomcat(String servicePathPrefix, String servletPattern, int port) {\n+        String baseDir = new File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath();\n+\n+        Tomcat tomcat = new Tomcat();\n+        Connector connector = tomcat.getConnector();\n+        connector.setPort(port);\n+        connector.setProperty(\"maxThreads\", \"5\");\n+        connector.setProperty(\"maxConnections\", \"-1\");\n+        connector.setProperty(\"URIEncoding\", \"UTF-8\");\n+        connector.setProperty(\"connectionTimeout\", \"60000\");\n+        connector.setProperty(\"maxKeepAliveRequests\", \"-1\");\n+\n+        tomcat.setBaseDir(baseDir);\n+        tomcat.setPort(port);\n+\n+        Context context = tomcat.addContext(servicePathPrefix, baseDir);\n+        Tomcat.addServlet(context, \"dispatcher\", new DispatcherServlet());\n+\n+        context.addServletMappingDecoded(servletPattern, \"dispatcher\");\n+        ServletManager.getInstance().addServletContext(port, context.getServletContext());\n+\n+        // tell tomcat to fail on startup failures.\n+        System.setProperty(\"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE\", \"true\");\n+        return tomcat;\n+    }\n }",
    "output": "Fix problem that webservice consumer cannot invoke webservice provider when provider webservice server use servlet, and the container has context path and servlet pattern * fix problem that webservice consumer cannot invoke webservice provider when provider container has context path and servlet pattern"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invocation.java\n@@ -117,6 +117,11 @@ public String getTargetServiceUniqueName() {\n             return delegate.getTargetServiceUniqueName();\n         }\n+        @Override\n+        public String getProtocolServiceKey() {\n+            return delegate.getProtocolServiceKey();\n+        }\n+\n         @Override\n         public String getMethodName() {\n             return delegate.getMethodName();\ndiff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n@@ -108,6 +108,11 @@ public void setInvoker(Invoker<?> invoker) {\n         this.invoker = invoker;\n     }\n+    @Override\n+    public String getProtocolServiceKey() {\n+        return null;\n+    }\n+\n     public String getMethodName() {\n         return methodName;\n     }\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/cache/CacheTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/cache/CacheTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/cache/CacheTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/cache/CacheTest.java\n@@ -53,6 +53,11 @@ public String getTargetServiceUniqueName() {\n             return null;\n         }\n+        @Override\n+        public String getProtocolServiceKey() {\n+            return null;\n+        }\n+\n         @Override\n         public String getMethodName() {\n             return null;\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java b/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java\n@@ -45,6 +45,11 @@ public String getTargetServiceUniqueName() {\n         return null;\n     }\n+    @Override\n+    public String getProtocolServiceKey() {\n+        return null;\n+    }\n+\n     public String getMethodName() {\n         return \"echo\";\n     }\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/service/MockInvocation.java b/dubbo-compatible/src/test/java/org/apache/dubbo/service/MockInvocation.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/service/MockInvocation.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/service/MockInvocation.java\n@@ -56,6 +56,11 @@ public String getTargetServiceUniqueName() {\n         return null;\n     }\n+    @Override\n+    public String getProtocolServiceKey() {\n+        return null;\n+    }\n+\n     public String getMethodName() {\n         return \"echo\";\n     }",
    "output": "Fix uts"
  },
  {
    "input": "diff --git a/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/MetricsFilterTest.java b/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/MetricsFilterTest.java\n--- a/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/MetricsFilterTest.java\n+++ b/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/MetricsFilterTest.java\n@@ -116,7 +116,7 @@ public void testConsumerSuccess() throws Exception {\n         IMetricManager metricManager = MetricManager.getIMetricManager();\n         metricManager.clear();\n         MetricsFilter metricsFilter = new MetricsFilter();\n-        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), new Class<?>[]{Integer.class}, new Object[0]);\n+        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), \"\", new Class<?>[]{Integer.class}, new Object[0]);\n         RpcContext.getContext().setRemoteAddress(NetUtils.getLocalHost(), 20880).setLocalAddress(NetUtils.getLocalHost(), 2345);\n         RpcContext.getContext().setUrl(serviceInvoker.getUrl().addParameter(SIDE_KEY, CONSUMER_SIDE));\n         AppResponse response = AppResponseBuilder.create()\n@@ -144,7 +144,7 @@ public void testConsumerTimeout() {\n         IMetricManager metricManager = MetricManager.getIMetricManager();\n         metricManager.clear();\n         MetricsFilter metricsFilter = new MetricsFilter();\n-        Invocation invocation = new RpcInvocation(\"timeoutException\", DemoService.class.getName(), null, null);\n+        Invocation invocation = new RpcInvocation(\"timeoutException\", DemoService.class.getName(), \"\", null, null);\n         RpcContext.getContext().setRemoteAddress(NetUtils.getLocalHost(), 20880).setLocalAddress(NetUtils.getLocalHost(), 2345);\n         RpcContext.getContext().setUrl(timeoutInvoker.getUrl().addParameter(SIDE_KEY, CONSUMER_SIDE)\n             .addParameter(TIMEOUT_KEY, 300));\n@@ -177,7 +177,7 @@ public void testProviderSuccess() throws Exception {\n         IMetricManager metricManager = MetricManager.getIMetricManager();\n         metricManager.clear();\n         MetricsFilter metricsFilter = new MetricsFilter();\n-        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), new Class<?>[0], new Object[0]);\n+        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), \"\", new Class<?>[0], new Object[0]);\n         RpcContext.getContext().setRemoteAddress(NetUtils.getLocalHost(), 20880).setLocalAddress(NetUtils.getLocalHost(), 2345);\n         RpcContext.getContext().setUrl(serviceInvoker.getUrl().addParameter(SIDE_KEY, PROVIDER));\n         AppResponse response = AppResponseBuilder.create()\n@@ -204,7 +204,7 @@ public void testInvokeMetricsService() {\n         IMetricManager metricManager = MetricManager.getIMetricManager();\n         metricManager.clear();\n         MetricsFilter metricsFilter = new MetricsFilter();\n-        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), new Class<?>[0], new Object[0]);\n+        Invocation invocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), \"\", new Class<?>[0], new Object[0]);\n         RpcContext.getContext().setRemoteAddress(NetUtils.getLocalHost(), 20880).setLocalAddress(NetUtils.getLocalHost(), 2345);\n         RpcContext.getContext().setUrl(serviceInvoker.getUrl().addParameter(SIDE_KEY, PROVIDER_SIDE)\n             .addParameter(TIMEOUT_KEY, 300));\n@@ -222,7 +222,7 @@ public void testInvokeMetricsService() {\n         Protocol protocol = new DubboProtocol();\n         URL url = URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":20880/\" + MetricsService.class.getName());\n         Invoker<MetricsService> invoker = protocol.refer(MetricsService.class, url);\n-        invocation = new RpcInvocation(\"getMetricsByGroup\", DemoService.class.getName(), new Class<?>[]{String.class}, new Object[]{DUBBO_GROUP});\n+        invocation = new RpcInvocation(\"getMetricsByGroup\", DemoService.class.getName(), \"\", new Class<?>[]{String.class}, new Object[]{DUBBO_GROUP});\n         try {\n             Thread.sleep(5000);\n         } catch (Exception e) {\n@@ -251,13 +251,13 @@ public void testInvokeMetricsMethodService() {\n         IMetricManager metricManager = MetricManager.getIMetricManager();\n         metricManager.clear();\n         MetricsFilter metricsFilter = new MetricsFilter();\n-        Invocation sayNameInvocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), new Class<?>[0], new Object[0]);\n-        Invocation echoInvocation = new RpcInvocation(\"echo\", DemoService.class.getName(), new Class<?>[]{Integer.class}, new Integer[]{1});\n+        Invocation sayNameInvocation = new RpcInvocation(\"sayName\", DemoService.class.getName(), \"\", new Class<?>[0], new Object[0]);\n+        Invocation echoInvocation = new RpcInvocation(\"echo\", DemoService.class.getName(), \"\", new Class<?>[]{Integer.class}, new Integer[]{1});\n         RpcContext.getContext().setRemoteAddress(NetUtils.getLocalHost(), 20880).setLocalAddress(NetUtils.getLocalHost(), 2345);\n         RpcContext.getContext().setUrl(serviceInvoker.getUrl().addParameter(SIDE_KEY, PROVIDER_SIDE)\n-            .addParameter(TIMEOUT_KEY, 300));\n+                .addParameter(TIMEOUT_KEY, 300));\n         AppResponse response = AppResponseBuilder.create()\n-            .build();\n+                .build();\n         onInvokeReturns(response);\n         for (int i = 0; i < 50; i++) {\n             metricsFilter.invoke(serviceInvoker, sayNameInvocation);\n@@ -277,7 +277,7 @@ public void testInvokeMetricsMethodService() {\n         Protocol protocol = new DubboProtocol();\n         URL url = URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":20880/\" + MetricsService.class.getName());\n         Invoker<MetricsService> invoker = protocol.refer(MetricsService.class, url);\n-        Invocation invocation = new RpcInvocation(\"getMetricsByGroup\", DemoService.class.getName(), new Class<?>[]{String.class}, new Object[]{DUBBO_GROUP});\n+        Invocation invocation = new RpcInvocation(\"getMetricsByGroup\", DemoService.class.getName(), \"\", new Class<?>[]{String.class}, new Object[]{DUBBO_GROUP});\n         try {\n             Thread.sleep(15000);\n         } catch (Exception e) {\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/RestProtocolTest.java b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/RestProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/RestProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/RestProtocolTest.java\n@@ -177,7 +177,7 @@ public void testInvoke() {\n         Exporter<DemoService> exporter = protocol.export(proxy.getInvoker(server, DemoService.class, exportUrl));\n-        RpcInvocation rpcInvocation = new RpcInvocation(\"hello\", DemoService.class.getName(), new Class[]{Integer.class, Integer.class}, new Integer[]{2, 3});\n+        RpcInvocation rpcInvocation = new RpcInvocation(\"hello\", DemoService.class.getName(), \"\", new Class[]{Integer.class, Integer.class}, new Integer[]{2, 3});\n         Result result = exporter.getInvoker().invoke(rpcInvocation);\n         assertThat(result.getValue(), CoreMatchers.<Object>is(5));",
    "output": "Fix uts"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n@@ -74,6 +74,7 @@\n import java.util.Collection;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.Optional;\n import java.util.Set;\n import java.util.SortedSet;\n import java.util.concurrent.CompletableFuture;\n@@ -1005,10 +1006,10 @@ private void exportMetadataService() {\n     }\n     private void unexportMetadataService() {\n-        metadataServiceExporters\n-                .stream()\n-                .filter(this::supports)\n-                .forEach(MetadataServiceExporter::unexport);\n+        Optional.ofNullable(metadataServiceExporters)\n+                .ifPresent(set -> set.stream()\n+                        .filter(this::supports)\n+                        .forEach(MetadataServiceExporter::unexport));\n     }\n     private boolean supports(MetadataServiceExporter exporter) {",
    "output": "Fix NPE when unexport Metadata Service"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/extension/ExtensionFactory.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/extension/ExtensionFactory.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/extension/ExtensionFactory.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/extension/ExtensionFactory.java\n@@ -16,7 +16,10 @@\n  */\n package com.alibaba.dubbo.common.extension;\n+import org.apache.dubbo.common.extension.SPI;\n+\n @Deprecated\n+@SPI\n public interface ExtensionFactory extends org.apache.dubbo.common.extension.ExtensionFactory {\n }",
    "output": "Add @SPI annotation"
  },
  {
    "input": "diff --git a/dubbo-demo/dubbo-demo-annotation/dubbo-demo-annotation-consumer/src/main/java/org/apache/dubbo/demo/consumer/comp/DemoServiceComponent.java b/dubbo-demo/dubbo-demo-annotation/dubbo-demo-annotation-consumer/src/main/java/org/apache/dubbo/demo/consumer/comp/DemoServiceComponent.java\n--- a/dubbo-demo/dubbo-demo-annotation/dubbo-demo-annotation-consumer/src/main/java/org/apache/dubbo/demo/consumer/comp/DemoServiceComponent.java\n+++ b/dubbo-demo/dubbo-demo-annotation/dubbo-demo-annotation-consumer/src/main/java/org/apache/dubbo/demo/consumer/comp/DemoServiceComponent.java\n@@ -16,7 +16,7 @@\n  */\n package org.apache.dubbo.demo.consumer.comp;\n-import org.apache.dubbo.config.annotation.Reference;\n+import org.apache.dubbo.config.annotation.DubboReference;\n import org.apache.dubbo.demo.DemoService;\n import org.springframework.stereotype.Component;\n@@ -25,7 +25,7 @@\n @Component(\"demoServiceComponent\")\n public class DemoServiceComponent implements DemoService {\n-    @Reference\n+    @DubboReference\n     private DemoService demoService;\n     @Override\ndiff --git a/dubbo-demo/dubbo-demo-annotation/dubbo-demo-annotation-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java b/dubbo-demo/dubbo-demo-annotation/dubbo-demo-annotation-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java\n--- a/dubbo-demo/dubbo-demo-annotation/dubbo-demo-annotation-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java\n+++ b/dubbo-demo/dubbo-demo-annotation/dubbo-demo-annotation-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java\n@@ -16,7 +16,7 @@\n  */\n package org.apache.dubbo.demo.provider;\n-import org.apache.dubbo.config.annotation.Service;\n+import org.apache.dubbo.config.annotation.DubboService;\n import org.apache.dubbo.demo.DemoService;\n import org.apache.dubbo.rpc.RpcContext;\n@@ -25,7 +25,7 @@\n import java.util.concurrent.CompletableFuture;\n-@Service\n+@DubboService\n public class DemoServiceImpl implements DemoService {\n     private static final Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);",
    "output": "Upgrade @Service And @Reference with @DubboService and @DubboReference"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java b/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java\n--- a/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java\n+++ b/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java\n@@ -51,14 +51,13 @@ public TomcatHttpServer(URL url, final HttpHandler handler) {\n         String baseDir = new File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath();\n         tomcat = new Tomcat();\n-        Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\n+        Connector connector = tomcat.getConnector();\n         connector.setPort(url.getPort());\n         connector.setProperty(\"maxThreads\", String.valueOf(url.getParameter(THREADS_KEY, DEFAULT_THREADS)));\n         connector.setProperty(\"maxConnections\", String.valueOf(url.getParameter(ACCEPTS_KEY, -1)));\n         connector.setProperty(\"URIEncoding\", \"UTF-8\");\n         connector.setProperty(\"connectionTimeout\", \"60000\");\n         connector.setProperty(\"maxKeepAliveRequests\", \"-1\");\n-        tomcat.setConnector(connector);\n         tomcat.setBaseDir(baseDir);\n         tomcat.setPort(url.getPort());",
    "output": "Fix bug: Rest Protocol can't work when use Tomcat as WebContainer"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java\n--- a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java\n+++ b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java\n@@ -768,7 +768,7 @@ public void testNofityOverrideUrls_Clean1() {\n         List<Invoker<?>> invokers = registryDirectory.list(invocation);\n         Invoker<?> aInvoker = invokers.get(0);\n         //Need to be restored to the original providerUrl\n-        Assertions.assertEquals(\"1\", aInvoker.getUrl().getParameter(\"timeout\"));\n+        Assertions.assertEquals(\"3\", aInvoker.getUrl().getParameter(\"timeout\"));\n     }\n     /**",
    "output": "Fix ut"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java\n@@ -157,6 +157,7 @@ public void testAsync() {\n         rpcContext.stopAsync();\n         Assertions.assertTrue(rpcContext.isAsyncStarted());\n+        RpcContext.removeContext();\n     }\n     @Test",
    "output": "Remove RpcContext after test finishes"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -112,21 +112,21 @@ public interface CommonConstants {\n     // used by invocation attachments to transfer timeout from Consumer to Provider.\n     // works as a replacement of TIMEOUT_KEY on wire, which seems to be totally useless in previous releases).\n-    String TIMEOUT_ATTACHENT_KEY = \"_TO\";\n+    String TIMEOUT_ATTACHMENT_KEY = \"_TO\";\n     String TIME_COUNTDOWN_KEY = \"timeout-countdown\";\n     String ENABLE_TIMEOUT_COUNTDOWN_KEY = \"enable-timeout-countdown\";\n     String REMOVE_VALUE_PREFIX = \"-\";\n-    String PROPERTIES_CHAR_SEPERATOR = \"-\";\n+    String PROPERTIES_CHAR_SEPARATOR = \"-\";\n     String UNDERLINE_SEPARATOR = \"_\";\n     String SEPARATOR_REGEX = \"_|-\";\n-    String GROUP_CHAR_SEPERATOR = \":\";\n+    String GROUP_CHAR_SEPARATOR = \":\";\n     String HIDE_KEY_PREFIX = \".\";\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java\n@@ -24,7 +24,7 @@\n import java.util.Map;\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO;\n-import static org.apache.dubbo.common.constants.CommonConstants.PROPERTIES_CHAR_SEPERATOR;\n+import static org.apache.dubbo.common.constants.CommonConstants.PROPERTIES_CHAR_SEPARATOR;\n /**\n  * MetadataReportConfig\n@@ -38,7 +38,7 @@ public class MetadataReportConfig extends AbstractConfig {\n      * the value is : metadata-report\n      */\n     private static final String PREFIX_TAG = StringUtils.camelToSplitName(\n-            MetadataReportConfig.class.getSimpleName().substring(0, MetadataReportConfig.class.getSimpleName().length() - 6), PROPERTIES_CHAR_SEPERATOR);\n+            MetadataReportConfig.class.getSimpleName().substring(0, MetadataReportConfig.class.getSimpleName().length() - 6), PROPERTIES_CHAR_SEPARATOR);\n     // Register center address\n     private String address;\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n@@ -40,7 +40,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER;\n import static org.apache.dubbo.common.constants.CommonConstants.REMOTE_APPLICATION_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_ATTACHENT_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_ATTACHMENT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n@@ -71,7 +71,7 @@ public class ContextFilter implements Filter, Filter.Listener {\n         UNLOADING_KEYS.add(DUBBO_VERSION_KEY);\n         UNLOADING_KEYS.add(TOKEN_KEY);\n         UNLOADING_KEYS.add(TIMEOUT_KEY);\n-        UNLOADING_KEYS.add(TIMEOUT_ATTACHENT_KEY);\n+        UNLOADING_KEYS.add(TIMEOUT_ATTACHMENT_KEY);\n         // Remove async property to avoid being passed to the following invoke chain.\n         UNLOADING_KEYS.add(ASYNC_KEY);\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n@@ -34,7 +34,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.$INVOKE;\n import static org.apache.dubbo.common.constants.CommonConstants.$INVOKE_ASYNC;\n-import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_ATTACHENT_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_ATTACHMENT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n import static org.apache.dubbo.rpc.Constants.$ECHO;\n import static org.apache.dubbo.rpc.Constants.ASYNC_KEY;\n@@ -217,7 +217,7 @@ private static Method getMethodByService(Invocation invocation, String service)\n     public static long getTimeout(Invocation invocation, long defaultTimeout) {\n         long timeout = defaultTimeout;\n-        Object genericTimeout = invocation.getObjectAttachment(TIMEOUT_ATTACHENT_KEY);\n+        Object genericTimeout = invocation.getObjectAttachment(TIMEOUT_ATTACHMENT_KEY);\n         if (genericTimeout != null) {\n             timeout = convertToNumber(genericTimeout, defaultTimeout);\n         }\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n@@ -47,7 +47,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_ATTACHENT_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_ATTACHMENT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n import static org.apache.dubbo.rpc.Constants.TOKEN_KEY;\n@@ -168,12 +168,12 @@ private int calculateTimeout(Invocation invocation, String methodName) {\n         if (countdown == null) {\n             timeout = (int) RpcUtils.getTimeout(getUrl(), methodName, RpcContext.getContext(), DEFAULT_TIMEOUT);\n             if (getUrl().getParameter(ENABLE_TIMEOUT_COUNTDOWN_KEY, false)) {\n-                invocation.setObjectAttachment(TIMEOUT_ATTACHENT_KEY, timeout); // pass timeout to remote server\n+                invocation.setObjectAttachment(TIMEOUT_ATTACHMENT_KEY, timeout); // pass timeout to remote server\n             }\n         } else {\n             TimeoutCountDown timeoutCountDown = (TimeoutCountDown) countdown;\n             timeout = (int) timeoutCountDown.timeRemaining(TimeUnit.MILLISECONDS);\n-            invocation.setObjectAttachment(TIMEOUT_ATTACHENT_KEY, timeout);// pass timeout to remote server\n+            invocation.setObjectAttachment(TIMEOUT_ATTACHMENT_KEY, timeout);// pass timeout to remote server\n         }\n         return timeout;\n     }",
    "output": "Fix typo in CommonConstants"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n@@ -138,7 +138,12 @@ public void setServiceKey(String serviceKey) {\n     }\n     public void initMethodModels() {\n-        Class[] interfaceList = serviceMetadata.getTarget().getClass().getInterfaces();\n+        Class[] interfaceList = null;\n+        if (proxyObject == null) {\n+            interfaceList = new Class[]{referenceConfig.getActualInterface()};\n+        } else {\n+            interfaceList = proxyObject.getClass().getInterfaces();\n+        }\n         for (Class interfaceClass : interfaceList) {\n             for (Method method : interfaceClass.getMethods()) {\n                 methodModels.put(method, new ConsumerMethodModel(method));",
    "output": "Fix NPE when check=false is set and provider is empty"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n@@ -92,7 +92,7 @@ public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation\n     @Override\n     public int getPriority() {\n-        return DEFAULT_PRIORITY;\n+        return priority;\n     }\n     @Override",
    "output": "Fix the priority of ListenableRouter were not effective"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java b/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java\n--- a/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java\n+++ b/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java\n@@ -145,7 +145,7 @@ public boolean publishConfig(String key, String group, String content) throws Un\n //        }\n //        return true;\n         String normalizedKey = convertKey(group, key);\n-        return kvClient.putValue(normalizedKey + PATH_SEPARATOR + content);\n+        return kvClient.putValue(normalizedKey, content);\n     }\n     @Override\ndiff --git a/dubbo-configcenter/dubbo-configcenter-consul/src/test/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfigurationTest.java b/dubbo-configcenter/dubbo-configcenter-consul/src/test/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfigurationTest.java\n--- a/dubbo-configcenter/dubbo-configcenter-consul/src/test/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfigurationTest.java\n+++ b/dubbo-configcenter/dubbo-configcenter-consul/src/test/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfigurationTest.java\n@@ -102,6 +102,12 @@ public void testAddListener() {\n         System.out.println(kvClient.getValues(\"/dubbo/config/dubbo/foo\"));\n     }\n+    @Test\n+    public void testPublishConfig() {\n+        configuration.publishConfig(\"foo\", \"value1\");\n+        Assertions.assertEquals(\"value1\", configuration.getString(\"/dubbo/config/dubbo/foo\"));\n+    }\n+\n     @Test\n     public void testGetConfigKeys() {",
    "output": "Fix publish null value when use consul config center * fix publish null value when use consul config center"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java\n--- a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java\n+++ b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java\n@@ -65,6 +65,7 @@\n import static org.apache.dubbo.registry.consul.AbstractConsulRegistry.SERVICE_TAG;\n import static org.apache.dubbo.registry.consul.AbstractConsulRegistry.URL_META_KEY;\n import static org.apache.dubbo.registry.consul.AbstractConsulRegistry.WATCH_TIMEOUT;\n+import static org.apache.dubbo.rpc.Constants.TOKEN_KEY;\n /**\n  * registry center implementation for consul\n@@ -78,10 +79,15 @@ public class ConsulRegistry extends FailbackRegistry {\n             new NamedThreadFactory(\"dubbo-consul-notifier\", true));\n     private ConcurrentMap<URL, ConsulNotifier> notifiers = new ConcurrentHashMap<>();\n     private ScheduledExecutorService ttlConsulCheckExecutor;\n+    /**\n+     * The ACL token\n+     */\n+    private String token;\n     public ConsulRegistry(URL url) {\n         super(url);\n+        token = url.getParameter(TOKEN_KEY, (String) null);\n         String host = url.getHost();\n         int port = url.getPort() != 0 ? url.getPort() : DEFAULT_PORT;\n         client = new ConsulClient(host, port);\n@@ -102,7 +108,11 @@ public void register(URL url) {\n     @Override\n     public void doRegister(URL url) {\n-        client.agentServiceRegister(buildService(url));\n+        if (token == null) {\n+            client.agentServiceRegister(buildService(url));\n+        } else {\n+            client.agentServiceRegister(buildService(url), token);\n+        }\n     }\n     @Override\n@@ -116,7 +126,11 @@ public void unregister(URL url) {\n     @Override\n     public void doUnregister(URL url) {\n-        client.agentServiceDeregister(buildId(url));\n+        if (token == null) {\n+            client.agentServiceDeregister(buildId(url));\n+        } else {\n+            client.agentServiceDeregister(buildId(url), token);\n+        }\n     }\n     @Override\n@@ -198,12 +212,16 @@ private void checkPass() {\n         for (URL url : getRegistered()) {\n             String checkId = buildId(url);\n             try {\n-                client.agentCheckPass(\"service:\" + checkId);\n+                if (token == null) {\n+                    client.agentCheckPass(\"service:\" + checkId);\n+                } else {\n+                    client.agentCheckPass(\"service:\" + checkId, null, token);\n+                }\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"check pass for url: \" + url + \" with check id: \" + checkId);\n                 }\n             } catch (Throwable t) {\n-                logger.warn(\"fail to check pass for url: \" + url + \", check id is: \" + checkId);\n+                logger.warn(\"fail to check pass for url: \" + url + \", check id is: \" + checkId, t);\n             }\n         }\n     }\n@@ -213,13 +231,15 @@ private Response<List<HealthService>> getHealthServices(String service, long ind\n                 .setTag(SERVICE_TAG)\n                 .setQueryParams(new QueryParams(watchTimeout, index))\n                 .setPassing(true)\n+                .setToken(token)\n                 .build();\n         return client.getHealthServices(service, request);\n     }\n     private Response<Map<String, List<String>>> getAllServices(long index, int watchTimeout) {\n         CatalogServicesRequest request = CatalogServicesRequest.newBuilder()\n                 .setQueryParams(new QueryParams(watchTimeout, index))\n+                .setToken(token)\n                 .build();\n         return client.getCatalogServices(request);\n     }",
    "output": "Make consul registry suppor ACL * make consul registry suppor ACL"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java\n--- a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java\n+++ b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java\n@@ -45,8 +45,8 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n import java.util.stream.Collectors;\n@@ -86,7 +86,7 @@ public ConsulRegistry(URL url) {\n         int port = url.getPort() != 0 ? url.getPort() : DEFAULT_PORT;\n         client = new ConsulClient(host, port);\n         checkPassInterval = url.getParameter(CHECK_PASS_INTERVAL, DEFAULT_CHECK_PASS_INTERVAL);\n-        ttlConsulCheckExecutor = Executors.newSingleThreadScheduledExecutor();\n+        ttlConsulCheckExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(\"Ttl-Consul-Check-Executor\", true));\n         ttlConsulCheckExecutor.scheduleAtFixedRate(this::checkPass, checkPassInterval / 8,\n                 checkPassInterval / 8, TimeUnit.MILLISECONDS);\n     }",
    "output": "Fix application cannot exit when use consul registry * fix application cannot exit when use consul registry"
  },
  {
    "input": "diff --git a/dubbo-filter/dubbo-filter-validation/src/main/java/org/apache/dubbo/validation/support/jvalidation/JValidator.java b/dubbo-filter/dubbo-filter-validation/src/main/java/org/apache/dubbo/validation/support/jvalidation/JValidator.java\n--- a/dubbo-filter/dubbo-filter-validation/src/main/java/org/apache/dubbo/validation/support/jvalidation/JValidator.java\n+++ b/dubbo-filter/dubbo-filter-validation/src/main/java/org/apache/dubbo/validation/support/jvalidation/JValidator.java\n@@ -186,7 +186,7 @@ private static Class<?> generateMethodParameterClass(Class<?> clazz, Method meth\n     private static String generateMethodParameterClassName(Class<?> clazz, Method method) {\n         StringBuilder builder = new StringBuilder().append(clazz.getName())\n                 .append(\"_\")\n-                .append(toUpperMethoName(method.getName()))\n+                .append(toUpperMethodName(method.getName()))\n                 .append(\"Parameter\");\n         Class<?>[] parameterTypes = method.getParameterTypes();\n@@ -211,7 +211,7 @@ private static boolean hasConstraintParameter(Method method) {\n         return false;\n     }\n-    private static String toUpperMethoName(String methodName) {\n+    private static String toUpperMethodName(String methodName) {\n         return methodName.substring(0, 1).toUpperCase() + methodName.substring(1);\n     }\n@@ -292,7 +292,7 @@ public void validate(String methodName, Class<?>[] parameterTypes, Object[] argu\n     private Class methodClass(String methodName) {\n         Class<?> methodClass = null;\n-        String methodClassName = clazz.getName() + \"$\" + toUpperMethoName(methodName);\n+        String methodClassName = clazz.getName() + \"$\" + toUpperMethodName(methodName);\n         Class cached = methodClassMap.get(methodClassName);\n         if (cached != null) {\n             return cached == clazz ? null : cached;",
    "output": "Fix method name typo in JValidator.java"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n@@ -297,7 +297,6 @@ public static void validateAbstractInterfaceConfig(AbstractInterfaceConfig confi\n         checkExtension(ProxyFactory.class, PROXY_KEY, config.getProxy());\n         checkExtension(Cluster.class, CLUSTER_KEY, config.getCluster());\n         checkMultiExtension(Filter.class, FILE_KEY, config.getFilter());\n-        checkMultiExtension(InvokerListener.class, LISTENER_KEY, config.getListener());\n         checkNameHasSymbol(LAYER_KEY, config.getLayer());\n         List<MethodConfig> methods = config.getMethods();\n@@ -312,7 +311,7 @@ public static void validateServiceConfig(ServiceConfig config) {\n         checkName(TOKEN_KEY, config.getToken());\n         checkPathName(PATH_KEY, config.getPath());\n-        checkMultiExtension(ExporterListener.class, \"listener\", config.getListener());\n+        checkMultiExtension(ExporterListener.class, LISTENER_KEY, config.getListener());\n         validateAbstractInterfaceConfig(config);\n@@ -337,7 +336,7 @@ public static void validateServiceConfig(ServiceConfig config) {\n     }\n     public static void validateReferenceConfig(ReferenceConfig config) {\n-        checkMultiExtension(InvokerListener.class, \"listener\", config.getListener());\n+        checkMultiExtension(InvokerListener.class, LISTENER_KEY, config.getListener());\n         checkKey(VERSION_KEY, config.getVersion());\n         checkKey(GROUP_KEY, config.getGroup());\n         checkName(CLIENT_KEY, config.getClient());",
    "output": "Fix wrong check of InvokerListener when export a service"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtils.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtils.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtils.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtils.java\n@@ -27,6 +27,7 @@\n import com.alibaba.nacos.api.exception.NacosException;\n import com.alibaba.nacos.api.naming.NamingService;\n import com.alibaba.nacos.api.naming.pojo.Instance;\n+import com.alibaba.nacos.api.naming.utils.NamingUtils;\n import java.util.Properties;\n@@ -90,7 +91,7 @@ public static Instance toInstance(ServiceInstance serviceInstance) {\n      */\n     public static ServiceInstance toServiceInstance(Instance instance) {\n         DefaultServiceInstance serviceInstance = new DefaultServiceInstance(instance.getInstanceId(),\n-                instance.getServiceName(), instance.getIp(), instance.getPort());\n+                NamingUtils.getServiceName(instance.getServiceName()), instance.getIp(), instance.getPort());\n         serviceInstance.setMetadata(instance.getMetadata());\n         serviceInstance.setEnabled(instance.isEnabled());\n         serviceInstance.setHealthy(instance.isHealthy());",
    "output": "Fix nacos service name associated with group name"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AttachmentsAdapter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AttachmentsAdapter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AttachmentsAdapter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AttachmentsAdapter.java\n@@ -29,25 +29,25 @@ public static class ObjectToStringMap extends HashMap<String, String> {\n         private Map<String, Object> attachments;\n         public ObjectToStringMap(Map<String, Object> attachments) {\n+            for (Entry<String, Object> entry : attachments.entrySet()) {\n+                String converResult = convert(entry.getValue());\n+                if (converResult != null) {\n+                    super.put(entry.getKey(), converResult);\n+                }\n+            }\n             this.attachments = attachments;\n         }\n-        @Override\n-        public String get(Object key) {\n-            Object obj = attachments.get(key);\n-            return convert(obj);\n-        }\n-\n         @Override\n         public String put(String key, String value) {\n-            Object obj = attachments.put(key, value);\n-            return convert(obj);\n+            attachments.put(key, value);\n+            return super.put(key, value);\n         }\n         @Override\n         public String remove(Object key) {\n-            Object obj = attachments.remove(key);\n-            return convert(obj);\n+            attachments.remove(key);\n+            return super.remove(key);\n         }\n         private String convert(Object obj) {\n@@ -56,31 +56,17 @@ private String convert(Object obj) {\n             }\n             return null; // or JSON.toString(obj);\n         }\n-    }\n-\n-    public static class StringToObjectMap extends HashMap<String, Object> {\n-        private Map<String, String> attachments;\n-\n-        public StringToObjectMap(Map<String, String> attachments) {\n-            this.attachments = attachments;\n-        }\n         @Override\n-        public Object get(Object key) {\n-            return attachments.get(key);\n-        }\n-\n-        @Override\n-        public Object put(String key, Object value) {\n-            if (value instanceof String) {\n-                return attachments.put(key, (String) value);\n-            }\n-            return null; // or JSON.toString(obj);\n+        public void clear() {\n+            attachments.clear();\n+            super.clear();\n         }\n         @Override\n-        public Object remove(Object key) {\n-            return attachments.remove(key);\n+        public void putAll(Map<? extends String, ? extends String> map) {\n+            attachments.putAll(map);\n+            super.putAll(map);\n         }\n     }\n-}\n+}\n\\ No newline at end of file",
    "output": "Fix object attachments iteration bug * fix object attachments iteration bug"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n@@ -84,10 +84,8 @@ public Service getService() {\n     @Override\n     public void afterPropertiesSet() throws Exception {\n         if (StringUtils.isEmpty(getPath())) {\n-            if (StringUtils.isNotEmpty(beanName)\n-                    && StringUtils.isNotEmpty(getInterface())\n-                    && beanName.startsWith(getInterface())) {\n-                setPath(beanName);\n+            if (StringUtils.isNotEmpty(getInterface())) {\n+                setPath(getInterface());\n             }\n         }\n     }",
    "output": "Use interface name as path * use interface name as path"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java b/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java\n@@ -52,7 +52,8 @@ public final class Version {\n      * Because {@link #isSupportResponseAttachment} is checked for every call, int compare expect to has higher\n      * performance than string.\n      */\n-    private static final int LOWEST_VERSION_FOR_RESPONSE_ATTACHMENT = 2000200; // 2.0.2\n+    public static final int LOWEST_VERSION_FOR_RESPONSE_ATTACHMENT = 2000200; // 2.0.2\n+    public static final int HIGHEST_PROTOCOL_VERSION = 2009900; // 2.0.99\n     private static final Map<String, Integer> VERSION2INT = new HashMap<String, Integer>();\n     static {\n@@ -87,31 +88,29 @@ public static boolean isRelease270OrHigher(String version) {\n     /**\n      * Check the framework release version number to decide if it's 2.6.3 or higher\n      *\n-     * Because response attachments feature is firstly introduced in 2.6.3\n-     * and moreover we have no other approach to know the framework's version, so we use\n-     * isSupportResponseAttachment to decide if it's v2.6.3.\n+     * @param version, the sdk version\n      */\n     public static boolean isRelease263OrHigher(String version) {\n-        return isSupportResponseAttachment(version);\n+        return getIntVersion(version) >= 2060300;\n     }\n+    /**\n+     * Dubbo 2.x protocol version numbers are limited to 2.0.2/2000200 ~ 2.0.99/2009900, other versions are consider as\n+     * invalid or not from official release.\n+     *\n+     * @param version, the protocol version.\n+     * @return\n+     */\n     public static boolean isSupportResponseAttachment(String version) {\n         if (StringUtils.isEmpty(version)) {\n             return false;\n         }\n-        // for previous dubbo version(2.0.10/020010~2.6.2/020602), this version is the jar's version, so they need to\n-        // be ignore\n         int iVersion = getIntVersion(version);\n-        if (iVersion >= 2001000 && iVersion < 2060300) {\n-            return false;\n-        }\n-\n-        // 2.8.x is reserved for dubbox\n-        if (iVersion >= 2080000 && iVersion < 2090000) {\n-            return false;\n+        if (iVersion >= LOWEST_VERSION_FOR_RESPONSE_ATTACHMENT && iVersion <= HIGHEST_PROTOCOL_VERSION) {\n+            return true;\n         }\n-        return iVersion >= LOWEST_VERSION_FOR_RESPONSE_ATTACHMENT;\n+        return false;\n     }\n     public static int getIntVersion(String version) {\n@@ -139,7 +138,10 @@ private static int parseInt(String version) {\n         String[] vArr = version.split(\"\\\\.\");\n         int len = vArr.length;\n         for (int i = 0; i < len; i++) {\n-            v += Integer.parseInt(getPrefixDigits(vArr[i])) * Math.pow(10, (len - i - 1) * 2);\n+            String subV = getPrefixDigits(vArr[i]);\n+            if (StringUtils.isNotEmpty(subV)) {\n+                v += Integer.parseInt(subV) * Math.pow(10, (len - i - 1) * 2);\n+            }\n         }\n         return v;\n     }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/version/VersionTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/version/VersionTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/version/VersionTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/version/VersionTest.java\n@@ -33,10 +33,14 @@ public void testGetProtocolVersion() {\n     public void testSupportResponseAttachment() {\n         Assertions.assertTrue(Version.isSupportResponseAttachment(\"2.0.2\"));\n         Assertions.assertTrue(Version.isSupportResponseAttachment(\"2.0.3\"));\n+        Assertions.assertTrue(Version.isSupportResponseAttachment(\"2.0.99\"));\n+\n+        Assertions.assertFalse(Version.isSupportResponseAttachment(\"2.1.0\"));\n         Assertions.assertFalse(Version.isSupportResponseAttachment(\"2.0.0\"));\n         Assertions.assertFalse(Version.isSupportResponseAttachment(\"1.0.0\"));\n-        Assertions.assertTrue(Version.isSupportResponseAttachment(\"2.6.6-stable\"));\n-\n+        Assertions.assertFalse(Version.isSupportResponseAttachment(\"3.0.0\"));\n+        Assertions.assertFalse(Version.isSupportResponseAttachment(\"2.6.6-stable\"));\n+        Assertions.assertFalse(Version.isSupportResponseAttachment(\"2.6.6.RC1\"));\n         Assertions.assertFalse(Version.isSupportResponseAttachment(\"2.0.contains\"));\n         Assertions.assertFalse(Version.isSupportResponseAttachment(\"version.string\"));\n         Assertions.assertFalse(Version.isSupportResponseAttachment(\"prefix2.0\"));\n@@ -48,6 +52,9 @@ public void testGetIntVersion() {\n         Assertions.assertEquals(2060101, Version.getIntVersion(\"2.6.1.1\"));\n         Assertions.assertEquals(2070001, Version.getIntVersion(\"2.7.0.1\"));\n         Assertions.assertEquals(2070000, Version.getIntVersion(\"2.7.0\"));\n+        Assertions.assertEquals(Version.HIGHEST_PROTOCOL_VERSION, Version.getIntVersion(\"2.0.99\"));\n+        Assertions.assertEquals(2070000, Version.getIntVersion(\"2.7.0.RC1\"));\n+        Assertions.assertEquals(2070000, Version.getIntVersion(\"2.7.0-SNAPSHOT\"));\n     }\n     @Test\n@@ -69,5 +76,6 @@ public void testIsFramework263OrHigher() {\n         Assertions.assertFalse(Version.isRelease263OrHigher(\"2.6.2.1\"));\n         Assertions.assertFalse(Version.isRelease263OrHigher(\"2.6.1.1\"));\n         Assertions.assertTrue(Version.isRelease263OrHigher(\"2.6.3\"));\n+        Assertions.assertTrue(Version.isRelease263OrHigher(\"2.6.3.0\"));\n     }\n }",
    "output": "Fix protocol version compatibility"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n@@ -37,6 +37,7 @@\n import java.io.InputStream;\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_VERSION_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n import static org.apache.dubbo.rpc.protocol.dubbo.CallbackServiceCodec.encodeInvocationArgument;\n@@ -168,7 +169,12 @@ protected void encodeRequestData(Channel channel, ObjectOutput out, Object data,\n         RpcInvocation inv = (RpcInvocation) data;\n         out.writeUTF(version);\n-        out.writeUTF(inv.getAttachment(PATH_KEY));\n+        // https://github.com/apache/dubbo/issues/6138\n+        String serviceName = inv.getAttachment(INTERFACE_KEY);\n+        if (serviceName == null) {\n+            serviceName = inv.getAttachment(PATH_KEY);\n+        }\n+        out.writeUTF(serviceName);\n         out.writeUTF(inv.getAttachment(VERSION_KEY));\n         out.writeUTF(inv.getMethodName());",
    "output": "Use the correct service name in the request package #6138"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java\n--- a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java\n+++ b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.utils.LogUtil;\n import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.registry.NotifyListener;\n import org.apache.dubbo.registry.Registry;\n import org.apache.dubbo.registry.RegistryFactory;\n@@ -46,6 +47,7 @@\n import javax.script.ScriptEngineManager;\n import java.lang.reflect.Field;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -96,7 +98,8 @@ public void setUp() {\n     }\n     private RegistryDirectory getRegistryDirectory(URL url) {\n-        RegistryDirectory registryDirectory = new RegistryDirectory(URL.class, url);\n+        Map<String, String> qs = Collections.unmodifiableMap(StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY)));\n+        RegistryDirectory registryDirectory = new RegistryDirectory(URL.class, url, qs);\n         registryDirectory.setProtocol(protocol);\n         registryDirectory.setRegistry(registry);\n         registryDirectory.setRouterChain(RouterChain.buildChain(url));\n@@ -115,21 +118,22 @@ private RegistryDirectory getRegistryDirectory() {\n     @Test\n     public void test_Constructor_WithErrorParam() {\n         try {\n-            new RegistryDirectory(null, null);\n+            new RegistryDirectory(null, null, null);\n             fail();\n         } catch (IllegalArgumentException e) {\n         }\n         try {\n+            Map<String, String> qs = Collections.unmodifiableMap(StringUtils.parseQueryString(noMeaningUrl.getParameterAndDecoded(REFER_KEY)));\n             // null url\n-            new RegistryDirectory(null, noMeaningUrl);\n+            new RegistryDirectory(null, noMeaningUrl, qs);\n             fail();\n         } catch (IllegalArgumentException e) {\n         }\n         try {\n             // no servicekey\n-            new RegistryDirectory(RegistryDirectoryTest.class, URL.valueOf(\"dubbo://10.20.30.40:9090\"));\n+            new RegistryDirectory(RegistryDirectoryTest.class, URL.valueOf(\"dubbo://10.20.30.40:9090\"), new HashMap<>());\n             fail();\n         } catch (IllegalArgumentException e) {\n@@ -333,9 +337,10 @@ public void testParametersMerge() {\n         RegistryDirectory registryDirectory = getRegistryDirectory();\n         URL regurl = noMeaningUrl.addParameter(\"test\", \"reg\").addParameterAndEncoded(REFER_KEY,\n                 \"key=query&\" + LOADBALANCE_KEY + \"=\" + LeastActiveLoadBalance.NAME);\n+        Map<String, String> qs = Collections.unmodifiableMap(StringUtils.parseQueryString(regurl.getParameterAndDecoded(REFER_KEY)));\n         RegistryDirectory<RegistryDirectoryTest> registryDirectory2 = new RegistryDirectory(\n                 RegistryDirectoryTest.class,\n-                regurl);\n+                regurl, qs);\n         registryDirectory2.setProtocol(protocol);\n         List<URL> serviceUrls = new ArrayList<URL>();",
    "output": "Fix compilation"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceMetadata.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceMetadata.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceMetadata.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceMetadata.java\n@@ -73,7 +73,7 @@ public void addAttribute(String key, Object value) {\n     }\n     public void addAttachment(String key, Object value) {\n-        this.attributeMap.put(key, value);\n+        this.attachments.put(key, value);\n     }\n     public Class<?> getServiceType() {",
    "output": "Fix addAttachment put into the wrong property"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.registry.nacos;\n+import com.alibaba.nacos.api.common.Constants;\n import com.google.common.collect.Lists;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.URLBuilder;\n@@ -138,7 +139,8 @@ public List<URL> lookup(final URL url) {\n         execute(namingService -> {\n             Set<String> serviceNames = getServiceNames(url, null);\n             for (String serviceName : serviceNames) {\n-                List<Instance> instances = namingService.getAllInstances(serviceName);\n+                List<Instance> instances = namingService.getAllInstances(serviceName,\n+                        getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP));\n                 urls.addAll(buildURLs(url, instances));\n             }\n         });\n@@ -149,15 +151,25 @@ public List<URL> lookup(final URL url) {\n     public void doRegister(URL url) {\n         final String serviceName = getServiceName(url);\n         final Instance instance = createInstance(url);\n-        execute(namingService -> namingService.registerInstance(serviceName, instance));\n+        /**\n+         *  namingService.registerInstance with {@link org.apache.dubbo.registry.support.AbstractRegistry#registryUrl}\n+         *  default {@link DEFAULT_GROUP}\n+         *\n+         * in https://github.com/apache/dubbo/issues/5978\n+         */\n+        execute(namingService -> namingService.registerInstance(serviceName,\n+                getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP), instance));\n     }\n     @Override\n     public void doUnregister(final URL url) {\n         execute(namingService -> {\n             String serviceName = getServiceName(url);\n             Instance instance = createInstance(url);\n-            namingService.deregisterInstance(serviceName, instance.getIp(), instance.getPort());\n+            namingService.deregisterInstance(serviceName,\n+                    getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP),\n+                    instance.getIp()\n+                    , instance.getPort());\n         });\n     }\n@@ -166,8 +178,8 @@ public void doSubscribe(final URL url, final NotifyListener listener) {\n         Set<String> serviceNames = getServiceNames(url, listener);\n         //Set corresponding serviceNames for easy search later\n-        if(isServiceNamesWithCompatibleMode(url)){\n-            for(String serviceName:serviceNames){\n+        if (isServiceNamesWithCompatibleMode(url)) {\n+            for (String serviceName : serviceNames) {\n                 NacosInstanceManageUtil.setCorrespondingServiceNames(serviceName, serviceNames);\n             }\n         }\n@@ -183,9 +195,15 @@ private void doSubscribe(final URL url, final NotifyListener listener, final Set\n                 /**\n                  * Get all instances with serviceNames to avoid instance overwrite and but with empty instance mentioned\n                  * in https://github.com/apache/dubbo/issues/5885 and https://github.com/apache/dubbo/issues/5899\n+                 *\n+                 * namingService.getAllInstances with {@link org.apache.dubbo.registry.support.AbstractRegistry#registryUrl}\n+                 * default {@link DEFAULT_GROUP}\n+                 *\n+                 * in https://github.com/apache/dubbo/issues/5978\n                  */\n                 for (String serviceName : serviceNames) {\n-                    List<Instance> instances = namingService.getAllInstances(serviceName);\n+                    List<Instance> instances = namingService.getAllInstances(serviceName,\n+                            getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP));\n                     NacosInstanceManageUtil.initOrRefreshServiceInstanceList(serviceName, instances);\n                     allCorrespondingInstanceList.addAll(instances);\n                 }\n@@ -194,9 +212,10 @@ private void doSubscribe(final URL url, final NotifyListener listener, final Set\n                     subscribeEventListener(serviceName, url, listener);\n                 }\n             } else {\n-                List<Instance> instances = new LinkedList();\n+                List<Instance> instances = new LinkedList<>();\n                 for (String serviceName : serviceNames) {\n-                    instances.addAll(namingService.getAllInstances(serviceName));\n+                    instances.addAll(namingService.getAllInstances(serviceName\n+                            , getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP)));\n                     notifySubscriber(url, listener, instances);\n                     subscribeEventListener(serviceName, url, listener);\n                 }\n@@ -275,7 +294,8 @@ private Set<String> filterServiceNames(NacosServiceName serviceName) {\n         execute(namingService -> {\n-            serviceNames.addAll(namingService.getServicesOfServer(1, Integer.MAX_VALUE).getData()\n+            serviceNames.addAll(namingService.getServicesOfServer(1, Integer.MAX_VALUE,\n+                    getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP)).getData()\n                     .stream()\n                     .map(NacosServiceName::new)\n                     .filter(serviceName::isCompatible)\n@@ -354,7 +374,8 @@ private Set<String> getAllServiceNames() {\n         execute(namingService -> {\n             int pageIndex = 1;\n-            ListView<String> listView = namingService.getServicesOfServer(pageIndex, PAGINATION_SIZE);\n+            ListView<String> listView = namingService.getServicesOfServer(pageIndex, PAGINATION_SIZE,\n+                    getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP));\n             // First page data\n             List<String> firstPageData = listView.getData();\n             // Append first page into list\n@@ -370,7 +391,8 @@ private Set<String> getAllServiceNames() {\n             }\n             // If more than 1 page\n             while (pageIndex < pageNumbers) {\n-                listView = namingService.getServicesOfServer(++pageIndex, PAGINATION_SIZE);\n+                listView = namingService.getServicesOfServer(++pageIndex, PAGINATION_SIZE,\n+                        getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP));\n                 serviceNames.addAll(listView.getData());\n             }\n@@ -473,7 +495,7 @@ private void subscribeEventListener(String serviceName, final URL url, final Not\n                 List<Instance> instances = e.getInstances();\n-                if(isServiceNamesWithCompatibleMode(url)){\n+                if (isServiceNamesWithCompatibleMode(url)) {\n                     /**\n                      * Get all instances with corresponding serviceNames to avoid instance overwrite and but with empty instance mentioned\n                      * in https://github.com/apache/dubbo/issues/5885 and https://github.com/apache/dubbo/issues/5899\n@@ -485,7 +507,9 @@ private void subscribeEventListener(String serviceName, final URL url, final Not\n                 notifySubscriber(url, listener, instances);\n             }\n         };\n-        namingService.subscribe(serviceName, eventListener);\n+        namingService.subscribe(serviceName,\n+                getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP),\n+                eventListener);\n     }\n     /**",
    "output": "Fix nacos-registry dubbo.registry.group no effect * register and subscriber with group name * polish"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/servlet/ServletHttpBinder.java b/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/servlet/ServletHttpBinder.java\n--- a/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/servlet/ServletHttpBinder.java\n+++ b/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/servlet/ServletHttpBinder.java\n@@ -28,7 +28,6 @@\n public class ServletHttpBinder implements HttpBinder {\n     @Override\n-    @Adaptive()\n     public HttpServer bind(URL url, HttpHandler handler) {\n         return new ServletHttpServer(url, handler);\n     }",
    "output": "Remove @Adaptive annotation from bind method of ServletHttpBinder class"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java b/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java\n--- a/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java\n+++ b/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/tomcat/TomcatHttpServer.java\n@@ -26,6 +26,7 @@\n import org.apache.catalina.Context;\n import org.apache.catalina.LifecycleException;\n+import org.apache.catalina.connector.Connector;\n import org.apache.catalina.startup.Tomcat;\n import java.io.File;\n@@ -49,21 +50,18 @@ public TomcatHttpServer(URL url, final HttpHandler handler) {\n         DispatcherServlet.addHttpHandler(url.getPort(), handler);\n         String baseDir = new File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath();\n         tomcat = new Tomcat();\n-        tomcat.setBaseDir(baseDir);\n-        tomcat.setPort(url.getPort());\n-        tomcat.getConnector().setProperty(\n-                \"maxThreads\", String.valueOf(url.getParameter(THREADS_KEY, DEFAULT_THREADS)));\n-//        tomcat.getConnector().setProperty(\n-//                \"minSpareThreads\", String.valueOf(url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS)));\n-\n-        tomcat.getConnector().setProperty(\n-                \"maxConnections\", String.valueOf(url.getParameter(ACCEPTS_KEY, -1)));\n-        tomcat.getConnector().setProperty(\"URIEncoding\", \"UTF-8\");\n-        tomcat.getConnector().setProperty(\"connectionTimeout\", \"60000\");\n+        Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\n+        connector.setPort(url.getPort());\n+        connector.setProperty(\"maxThreads\", String.valueOf(url.getParameter(THREADS_KEY, DEFAULT_THREADS)));\n+        connector.setProperty(\"maxConnections\", String.valueOf(url.getParameter(ACCEPTS_KEY, -1)));\n+        connector.setProperty(\"URIEncoding\", \"UTF-8\");\n+        connector.setProperty(\"connectionTimeout\", \"60000\");\n+        connector.setProperty(\"maxKeepAliveRequests\", \"-1\");\n+        tomcat.setConnector(connector);\n-        tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"-1\");\n-        tomcat.getConnector().setProtocol(\"org.apache.coyote.http11.Http11NioProtocol\");\n+        tomcat.setBaseDir(baseDir);\n+        tomcat.setPort(url.getPort());\n         Context context = tomcat.addContext(\"/\", baseDir);\n         Tomcat.addServlet(context, \"dispatcher\", new DispatcherServlet());",
    "output": "Fix tomcat9 support"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n@@ -28,6 +28,7 @@\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -61,7 +62,7 @@ public abstract class AbstractRegistryFactory implements RegistryFactory {\n      * @return all registries\n      */\n     public static Collection<Registry> getRegistries() {\n-        return Collections.unmodifiableCollection(REGISTRIES.values());\n+        return Collections.unmodifiableCollection(new LinkedList<>(REGISTRIES.values()));\n     }\n     public static Registry getRegistry(String key) {",
    "output": "Fix potential ConcurrentModificationException"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java\n@@ -25,50 +25,54 @@\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n /**\n  * Round robin load balance.\n  */\n public class RoundRobinLoadBalance extends AbstractLoadBalance {\n     public static final String NAME = \"roundrobin\";\n-\n+\n     private static final int RECYCLE_PERIOD = 60000;\n-\n+\n     protected static class WeightedRoundRobin {\n         private int weight;\n         private AtomicLong current = new AtomicLong(0);\n         private long lastUpdate;\n+\n         public int getWeight() {\n             return weight;\n         }\n+\n         public void setWeight(int weight) {\n             this.weight = weight;\n             current.set(0);\n         }\n+\n         public long increaseCurrent() {\n             return current.addAndGet(weight);\n         }\n+\n         public void sel(int total) {\n             current.addAndGet(-1 * total);\n         }\n+\n         public long getLastUpdate() {\n             return lastUpdate;\n         }\n+\n         public void setLastUpdate(long lastUpdate) {\n             this.lastUpdate = lastUpdate;\n         }\n     }\n     private ConcurrentMap<String, ConcurrentMap<String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap<String, ConcurrentMap<String, WeightedRoundRobin>>();\n-    private AtomicBoolean updateLock = new AtomicBoolean();\n-\n+\n     /**\n      * get invoker addr list cached for specified invocation\n      * <p>\n      * <b>for unit test only</b>\n-     *\n+     *\n      * @param invokers\n      * @param invocation\n      * @return\n@@ -81,7 +85,7 @@ protected <T> Collection<String> getInvokerAddrList(List<Invoker<T>> invokers, I\n         }\n         return null;\n     }\n-\n+\n     @Override\n     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n         String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n@@ -94,14 +98,12 @@ protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation\n         for (Invoker<T> invoker : invokers) {\n             String identifyString = invoker.getUrl().toIdentityString();\n             int weight = getWeight(invoker, invocation);\n-            WeightedRoundRobin weightedRoundRobin = map.get(identifyString);\n+            WeightedRoundRobin weightedRoundRobin = map.computeIfAbsent(identifyString, k -> {\n+                WeightedRoundRobin wrr = new WeightedRoundRobin();\n+                wrr.setWeight(weight);\n+                return wrr;\n+            });\n-            if (weightedRoundRobin == null) {\n-                weightedRoundRobin = new WeightedRoundRobin();\n-                weightedRoundRobin.setWeight(weight);\n-                map.putIfAbsent(identifyString, weightedRoundRobin);\n-                weightedRoundRobin = map.get(identifyString);\n-            }\n             if (weight != weightedRoundRobin.getWeight()) {\n                 //weight changed\n                 weightedRoundRobin.setWeight(weight);\n@@ -115,17 +117,8 @@ protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation\n             }\n             totalWeight += weight;\n         }\n-        if (!updateLock.get() && invokers.size() != map.size()) {\n-            if (updateLock.compareAndSet(false, true)) {\n-                try {\n-                    // copy -> modify -> update reference\n-                    ConcurrentMap<String, WeightedRoundRobin> newMap = new ConcurrentHashMap<>(map);\n-                    newMap.entrySet().removeIf(item -> now - item.getValue().getLastUpdate() > RECYCLE_PERIOD);\n-                    methodWeightMap.put(key, newMap);\n-                } finally {\n-                    updateLock.set(false);\n-                }\n-            }\n+        if (invokers.size() != map.size()) {\n+            map.entrySet().removeIf(item -> now - item.getValue().getLastUpdate() > RECYCLE_PERIOD);\n         }\n         if (selectedInvoker != null) {\n             selectedWRR.sel(totalWeight);\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcStatus.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcStatus.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcStatus.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcStatus.java\n@@ -101,13 +101,17 @@ public static boolean beginCount(URL url, String methodName, int max) {\n         if (methodStatus.active.get() == Integer.MAX_VALUE) {\n             return false;\n         }\n-        if (methodStatus.active.incrementAndGet() > max) {\n-            methodStatus.active.decrementAndGet();\n-            return false;\n-        } else {\n-            appStatus.active.incrementAndGet();\n-            return true;\n+        for (int i; ; ) {\n+            i = methodStatus.active.get();\n+            if (i + 1 > max) {\n+                return false;\n+            }\n+            if (methodStatus.active.compareAndSet(i, i + 1)) {\n+                break;\n+            }\n         }\n+        appStatus.active.incrementAndGet();\n+        return true;\n     }\n     /**",
    "output": "Fix concurrency problems in RpcStatus and RoundRobinLoadBalance"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java\n@@ -23,7 +23,6 @@\n import java.beans.BeanInfo;\n import java.beans.Introspector;\n-import java.beans.PropertyDescriptor;\n import java.lang.reflect.Array;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n@@ -1261,28 +1260,29 @@ public static <T> Set<Class<T>> findHierarchicalTypes(Class<?> sourceClass, Clas\n     }\n     /**\n-     * Get the value from the specified bean and its property.\n+     * Get the value from the specified bean and its getter method.\n      *\n-     * @param bean         the bean instance\n-     * @param propertyName the name of property\n-     * @param <T>          the type of property value\n+     * @param bean       the bean instance\n+     * @param methodName the name of getter\n+     * @param <T>        the type of property value\n      * @return\n      * @since 2.7.5\n      */\n-    public static <T> T getProperty(Object bean, String propertyName) {\n+    public static <T> T getProperty(Object bean, String methodName) {\n         Class<?> beanClass = bean.getClass();\n         BeanInfo beanInfo = null;\n         T propertyValue = null;\n+\n         try {\n             beanInfo = Introspector.getBeanInfo(beanClass);\n-            propertyValue = (T) Stream.of(beanInfo.getPropertyDescriptors())\n-                    .filter(propertyDescriptor -> propertyName.equals(propertyDescriptor.getName()))\n-                    .map(PropertyDescriptor::getReadMethod)\n+            propertyValue = (T) Stream.of(beanInfo.getMethodDescriptors())\n+                    .filter(methodDescriptor -> methodName.equals(methodDescriptor.getName()))\n                     .findFirst()\n                     .map(method -> {\n                         try {\n-                            return method.invoke(bean);\n+                            return method.getMethod().invoke(bean);\n                         } catch (Exception e) {\n+                            //ignore\n                         }\n                         return null;\n                     }).get();\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java b/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n@@ -503,7 +503,7 @@ static <C extends AbstractConfig> String getId(C config) {\n     }\n     static <C extends AbstractConfig> boolean isDefaultConfig(C config) {\n-        Boolean isDefault = getProperty(config, \"default\");\n+        Boolean isDefault = getProperty(config, \"isDefault\");\n         return isDefault == null || TRUE.equals(isDefault);\n     }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java b/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/config/context/ConfigManagerTest.java\n@@ -205,4 +205,22 @@ public void testAddConfig() {\n     public void testRefreshAll() {\n         configManager.refreshAll();\n     }\n+\n+    @Test\n+    public void testDefaultConfig() {\n+        ProviderConfig providerConfig = new ProviderConfig();\n+        providerConfig.setDefault(false);\n+        assertFalse(ConfigManager.isDefaultConfig(providerConfig));\n+\n+        ProviderConfig providerConfig1 = new ProviderConfig();\n+        assertTrue(ConfigManager.isDefaultConfig(providerConfig1));\n+\n+        ProviderConfig providerConfig3 = new ProviderConfig();\n+        providerConfig.setDefault(true);\n+        assertTrue(ConfigManager.isDefaultConfig(providerConfig3));\n+\n+        ProtocolConfig protocolConfig = new ProtocolConfig();\n+        protocolConfig.setDefault(false);\n+        assertFalse(ConfigManager.isDefaultConfig(protocolConfig));\n+    }\n }",
    "output": "Fix default config does not work as expected"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -465,26 +465,6 @@ public void setBootstrap(DubboBootstrap bootstrap) {\n         this.bootstrap = bootstrap;\n     }\n-    @SuppressWarnings(\"unused\")\n-    private final Object finalizerGuardian = new Object() {\n-        @Override\n-        protected void finalize() throws Throwable {\n-            super.finalize();\n-\n-            if (!ReferenceConfig.this.destroyed) {\n-                logger.warn(\"ReferenceConfig(\" + url + \") is not DESTROYED when FINALIZE\");\n-\n-                /* don't destroy for now\n-                try {\n-                    ReferenceConfig.this.destroy();\n-                } catch (Throwable t) {\n-                        logger.warn(\"Unexpected err when destroy invoker of ReferenceConfig(\" + url + \") in finalize method!\", t);\n-                }\n-                */\n-            }\n-        }\n-    };\n-\n     private void postProcessConfig() {\n         List<ConfigPostProcessor> configPostProcessors =ExtensionLoader.getExtensionLoader(ConfigPostProcessor.class)\n                 .getActivateExtension(URL.valueOf(\"configPostProcessor://\"), (String[]) null);",
    "output": "Remove reference destroy guardian"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/CommandHelperTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/CommandHelperTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/CommandHelperTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/CommandHelperTest.java\n@@ -22,9 +22,8 @@\n import org.apache.dubbo.qos.command.impl.Offline;\n import org.apache.dubbo.qos.command.impl.Online;\n import org.apache.dubbo.qos.command.impl.Quit;\n-\n import org.apache.dubbo.qos.command.impl.Ready;\n-\n+import org.apache.dubbo.qos.command.impl.Version;\n import org.junit.jupiter.api.Test;\n import java.util.List;\n@@ -46,7 +45,9 @@ public void testHasCommand() throws Exception {\n     @Test\n     public void testGetAllCommandClass() throws Exception {\n         List<Class<?>> classes = CommandHelper.getAllCommandClass();\n-        assertThat(classes, containsInAnyOrder(GreetingCommand.class, Help.class, Ls.class, Offline.class, Online.class, Quit.class, Ready.class));\n+        assertThat(classes,\n+                containsInAnyOrder(GreetingCommand.class, Help.class, Ls.class, Offline.class, Online.class, Quit.class,\n+                        Ready.class, Version.class));\n     }\n     @Test",
    "output": "Fix unit test for qos module"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n@@ -156,6 +156,8 @@ public class DubboBootstrap extends GenericEventListener {\n     private AtomicBoolean started = new AtomicBoolean(false);\n+    private AtomicBoolean ready = new AtomicBoolean(true);\n+\n     private AtomicBoolean destroyed = new AtomicBoolean(false);\n     private volatile ServiceInstance serviceInstance;\n@@ -737,6 +739,7 @@ private List<ServiceDiscovery> getServiceDiscoveries() {\n      */\n     public DubboBootstrap start() {\n         if (started.compareAndSet(false, true)) {\n+            ready.set(false);\n             initialize();\n             if (logger.isInfoEnabled()) {\n                 logger.info(NAME + \" is starting...\");\n@@ -753,7 +756,24 @@ public DubboBootstrap start() {\n             }\n             referServices();\n-\n+            if (asyncExportingFutures.size() > 0) {\n+                new Thread(() -> {\n+                    try {\n+                        this.awaitFinish();\n+                    } catch (Exception e) {\n+                        logger.warn(NAME + \" exportAsync occurred an exception.\");\n+                    }\n+                    ready.set(true);\n+                    if (logger.isInfoEnabled()) {\n+                        logger.info(NAME + \" is ready.\");\n+                    }\n+                }).start();\n+            } else {\n+                ready.set(true);\n+                if (logger.isInfoEnabled()) {\n+                    logger.info(NAME + \" is ready.\");\n+                }\n+            }\n             if (logger.isInfoEnabled()) {\n                 logger.info(NAME + \" has started.\");\n             }\n@@ -814,6 +834,10 @@ public boolean isStarted() {\n         return started.get();\n     }\n+    public boolean isReady() {\n+        return ready.get();\n+    }\n+\n     public DubboBootstrap stop() throws IllegalStateException {\n         destroy();\n         return this;\ndiff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Ready.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Ready.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Ready.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Ready.java\n@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.qos.command.impl;\n+\n+import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n+import org.apache.dubbo.qos.command.BaseCommand;\n+import org.apache.dubbo.qos.command.CommandContext;\n+import org.apache.dubbo.qos.command.annotation.Cmd;\n+\n+@Cmd(name = \"start\",summary = \"Judge if service has started? \")\n+public class Ready implements BaseCommand {\n+\n+    @Override\n+    public String execute(CommandContext commandContext, String[] args) {\n+        return DubboBootstrap.getInstance().isReady() ? \"true\" : \"false\";\n+    }\n+\n+}\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/CommandHelperTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/CommandHelperTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/CommandHelperTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/util/CommandHelperTest.java\n@@ -23,6 +23,8 @@\n import org.apache.dubbo.qos.command.impl.Online;\n import org.apache.dubbo.qos.command.impl.Quit;\n+import org.apache.dubbo.qos.command.impl.Ready;\n+\n import org.junit.jupiter.api.Test;\n import java.util.List;\n@@ -44,7 +46,7 @@ public void testHasCommand() throws Exception {\n     @Test\n     public void testGetAllCommandClass() throws Exception {\n         List<Class<?>> classes = CommandHelper.getAllCommandClass();\n-        assertThat(classes, containsInAnyOrder(GreetingCommand.class, Help.class, Ls.class, Offline.class, Online.class, Quit.class));\n+        assertThat(classes, containsInAnyOrder(GreetingCommand.class, Help.class, Ls.class, Offline.class, Online.class, Quit.class, Ready.class));\n     }\n     @Test",
    "output": "Use QOS command to check if app service is ready"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java\n@@ -70,8 +70,8 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L\n             if (forks <= 0 || forks >= invokers.size()) {\n                 selected = invokers;\n             } else {\n-                selected = new ArrayList<>();\n-                for (int i = 0; i < forks; i++) {\n+                selected = new ArrayList<>(forks);\n+                while (selected.size() < forks) {\n                     Invoker<T> invoker = select(loadbalance, invocation, invokers, selected);\n                     if (!selected.contains(invoker)) {\n                         //Avoid add the same invoker several times.",
    "output": "Upgrade ForkingClusterInvoker.java"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java\n@@ -86,8 +86,7 @@ protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation\n                 // Accumulate the total weight of the least active invoker\n                 totalWeight += afterWarmup;\n                 // If every invoker has the same weight?\n-                if (sameWeight && i > 0\n-                        && afterWarmup != firstWeight) {\n+                if (sameWeight && afterWarmup != firstWeight) {\n                     sameWeight = false;\n                 }\n             }",
    "output": "Fix a redundant judgment code"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ExecuteLimitFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ExecuteLimitFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ExecuteLimitFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ExecuteLimitFilter.java\n@@ -37,7 +37,7 @@\n @Activate(group = CommonConstants.PROVIDER, value = EXECUTES_KEY)\n public class ExecuteLimitFilter implements Filter, Filter.Listener {\n-    private static final String EXECUTELIMIT_FILTER_START_TIME = \"execugtelimit_filter_start_time\";\n+    private static final String EXECUTE_LIMIT_FILTER_START_TIME = \"execute_limit_filter_start_time\";\n     @Override\n     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n@@ -51,7 +51,7 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept\n                             \"\\\" /> limited.\");\n         }\n-        invocation.put(EXECUTELIMIT_FILTER_START_TIME, System.currentTimeMillis());\n+        invocation.put(EXECUTE_LIMIT_FILTER_START_TIME, System.currentTimeMillis());\n         try {\n             return invoker.invoke(invocation);\n         } catch (Throwable t) {\n@@ -80,7 +80,7 @@ public void onError(Throwable t, Invoker<?> invoker, Invocation invocation) {\n     }\n     private long getElapsed(Invocation invocation) {\n-        Object beginTime = invocation.get(EXECUTELIMIT_FILTER_START_TIME);\n+        Object beginTime = invocation.get(EXECUTE_LIMIT_FILTER_START_TIME);\n         return beginTime != null ? System.currentTimeMillis() - (Long) beginTime : 0;\n     }\n }",
    "output": "Fix bad spell: name"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/interceptors/RpcContextInterceptor.java b/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/interceptors/RpcContextInterceptor.java\n--- a/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/interceptors/RpcContextInterceptor.java\n+++ b/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/interceptors/RpcContextInterceptor.java\n@@ -16,20 +16,23 @@\n  */\n package org.apache.dubbo.rpc.protocol.grpc.interceptors;\n-import org.apache.dubbo.common.extension.Activate;\n-import org.apache.dubbo.rpc.RpcContext;\n-\n import io.grpc.CallOptions;\n import io.grpc.Channel;\n import io.grpc.ClientCall;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingServerCallListener;\n import io.grpc.Metadata;\n import io.grpc.MethodDescriptor;\n import io.grpc.ServerCall;\n import io.grpc.ServerCallHandler;\n+import org.apache.dubbo.common.extension.Activate;\n+import org.apache.dubbo.rpc.RpcContext;\n+import java.util.HashMap;\n import java.util.Map;\n import java.util.Set;\n+import static io.grpc.Metadata.ASCII_STRING_MARSHALLER;\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER;\n@@ -44,26 +47,54 @@ public class RpcContextInterceptor implements ClientInterceptor, ServerIntercept\n     @Override\n     public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {\n         RpcContext rpcContext = RpcContext.getContext();\n-        Map<String, Object> attachments = rpcContext.getObjectAttachments();\n-        if (attachments != null) {\n-            for (Map.Entry<String, Object> entry : attachments.entrySet()) {\n-                callOptions = callOptions.withOption(CallOptions.Key.create(DUBBO + entry.getKey()), entry.getValue());\n+        Map<String, Object> attachments = new HashMap<>(rpcContext.getObjectAttachments());\n+\n+        return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(next.newCall(method, callOptions)) {\n+            @Override\n+            public void start(Listener<RespT> responseListener, Metadata headers) {\n+                if (!attachments.isEmpty()) {\n+                    for (Map.Entry<String, Object> entry : attachments.entrySet()) {\n+                        // only used for string\n+                        if (entry.getValue() instanceof String) {\n+                            headers.put(Metadata.Key.of(DUBBO + entry.getKey(), ASCII_STRING_MARSHALLER), ((String) entry.getValue()));\n+                        }\n+                    }\n+                }\n+                super.start(responseListener, headers);\n             }\n-        }\n-        return next.newCall(method, callOptions);\n+        };\n     }\n     @Override\n     public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call, Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n-        RpcContext rpcContext = RpcContext.getContext();\n         Set<String> keys = headers.keys();\n+        Map<String, Object> attachments = new HashMap<>();\n+        // filter out all dubbo attachments and save in map\n         if (keys != null) {\n-            keys.stream().filter(k -> k.startsWith(DUBBO)).forEach(k -> {\n-                rpcContext.setAttachment(k.substring(DUBBO.length()),\n-                        headers.get(Metadata.Key.of(k, Metadata.ASCII_STRING_MARSHALLER)));\n-            });\n+            keys.stream().filter(k -> k.toUpperCase().startsWith(DUBBO)).forEach(k ->\n+                    attachments.put(k.substring(DUBBO.length()), headers.get(Metadata.Key.of(k, Metadata.ASCII_STRING_MARSHALLER)))\n+            );\n         }\n-        return next.startCall(call, headers);\n+\n+        return new ForwardingServerCallListener.SimpleForwardingServerCallListener<ReqT>(next.startCall(call, headers)) {\n+            @Override\n+            public void onHalfClose() {\n+                // the client completed all message sending and server will call the biz method if client is not the streaming\n+                if (call.getMethodDescriptor().getType().clientSendsOneMessage()) {\n+                    RpcContext.getContext().setObjectAttachments(attachments);\n+                }\n+                super.onHalfClose();\n+            }\n+\n+            @Override\n+            public void onMessage(ReqT message) {\n+                //server receive the request from client and call the biz method if client is streaming\n+                if (!call.getMethodDescriptor().getType().clientSendsOneMessage()) {\n+                    RpcContext.getContext().setObjectAttachments(attachments);\n+                }\n+                super.onMessage(message);\n+            }\n+        };\n     }\n }",
    "output": "Fix the bug can't get the attacthment when use grpc protocol"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Version.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Version.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Version.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Version.java\n@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.qos.command.impl;\n+\n+import org.apache.dubbo.qos.command.BaseCommand;\n+import org.apache.dubbo.qos.command.CommandContext;\n+import org.apache.dubbo.qos.command.annotation.Cmd;\n+\n+@Cmd(name = \"version\", summary = \"version command(show dubbo version)\", example = {\n+        \"version\"\n+})\n+public class Version implements BaseCommand {\n+\n+    @Override\n+    public String execute(CommandContext commandContext, String[] args) {\n+        StringBuilder versionDescBuilder = new StringBuilder();\n+        versionDescBuilder.append(\"dubbo version \\\"\");\n+        versionDescBuilder.append(org.apache.dubbo.common.Version.getVersion());\n+        versionDescBuilder.append(\"\\\"\");\n+        return versionDescBuilder.toString();\n+    }\n+\n+}",
    "output": "Add version command in qos module"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-processor/src/main/java/org/apache/dubbo/metadata/annotation/processing/rest/ServiceRestMetadataStorage.java b/dubbo-metadata/dubbo-metadata-processor/src/main/java/org/apache/dubbo/metadata/annotation/processing/rest/ServiceRestMetadataStorage.java\n--- a/dubbo-metadata/dubbo-metadata-processor/src/main/java/org/apache/dubbo/metadata/annotation/processing/rest/ServiceRestMetadataStorage.java\n+++ b/dubbo-metadata/dubbo-metadata-processor/src/main/java/org/apache/dubbo/metadata/annotation/processing/rest/ServiceRestMetadataStorage.java\n@@ -23,7 +23,6 @@\n import javax.annotation.processing.ProcessingEnvironment;\n import java.io.IOException;\n-import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;",
    "output": "Fix checkstyle issue for ServiceRestMetadataStorage.java"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n@@ -30,8 +30,6 @@\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n public class Environment extends LifecycleAdapter implements FrameworkExt {\n     public static final String NAME = \"environment\";\n@@ -42,7 +40,6 @@ public class Environment extends LifecycleAdapter implements FrameworkExt {\n     private final InmemoryConfiguration externalConfiguration;\n     private final InmemoryConfiguration appExternalConfiguration;\n-    private final ConcurrentMap<AbstractConfig, CompositeConfiguration> prefixedConfigurations = new ConcurrentHashMap<>();\n     private CompositeConfiguration globalConfiguration;\n     private Map<String, String> externalConfigurationMap = new HashMap<>();\n@@ -116,12 +113,6 @@ public void updateAppExternalConfigurationMap(Map<String, String> externalMap) {\n      * @return\n      */\n     public synchronized CompositeConfiguration getPrefixedConfiguration(AbstractConfig config) {\n-//        CompositeConfiguration prefixedConfiguration =\n-//                prefixedConfigurations.putIfAbsent(config, new CompositeConfiguration(config.getPrefix(), config.getId()));\n-//        if (prefixedConfiguration != null) {\n-//            return prefixedConfiguration;\n-//        }\n-//        prefixedConfiguration = prefixedConfigurations.get(config);\n         CompositeConfiguration prefixedConfiguration = new CompositeConfiguration(config.getPrefix(), config.getId());\n         Configuration configuration = new ConfigConfigurationAdapter(config);\n         if (this.isConfigCenterFirst()) {\ndiff --git a/dubbo-metadata/dubbo-metadata-processor/src/main/java/org/apache/dubbo/metadata/annotation/processing/rest/ServiceRestMetadataStorage.java b/dubbo-metadata/dubbo-metadata-processor/src/main/java/org/apache/dubbo/metadata/annotation/processing/rest/ServiceRestMetadataStorage.java\n--- a/dubbo-metadata/dubbo-metadata-processor/src/main/java/org/apache/dubbo/metadata/annotation/processing/rest/ServiceRestMetadataStorage.java\n+++ b/dubbo-metadata/dubbo-metadata-processor/src/main/java/org/apache/dubbo/metadata/annotation/processing/rest/ServiceRestMetadataStorage.java\n@@ -42,16 +42,13 @@ public ServiceRestMetadataStorage(ProcessingEnvironment processingEnv) {\n     }\n     public void append(Set<ServiceRestMetadata> serviceRestMetadata) throws IOException {\n-        Set<ServiceRestMetadata> allServiceRestMetadata = new LinkedHashSet<>();\n         storage.read(SERVICE_REST_METADATA_RESOURCE_PATH, reader -> {\n             Gson gson = new Gson();\n             return (List) gson.fromJson(reader, getParameterized(List.class, ServiceRestMetadata.class).getType());\n         }).ifPresent(existedMetadata -> {\n             // Add all existed ServiceRestMetadata\n-            allServiceRestMetadata.addAll(existedMetadata);\n+            serviceRestMetadata.addAll(existedMetadata);\n         });\n-        // Add all new ServiceRestMetadata\n-        allServiceRestMetadata.addAll(serviceRestMetadata);\n         write(serviceRestMetadata);\n     }",
    "output": "Remove unused variable"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n@@ -21,7 +21,6 @@\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.ConfigUtils;\n-import org.apache.dubbo.common.utils.NamedThreadFactory;\n import org.apache.dubbo.rpc.AsyncRpcResult;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n@@ -40,8 +39,6 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.rpc.Constants.ASYNC_KEY;\n@@ -54,7 +51,6 @@\n public class MergeableClusterInvoker<T> extends AbstractClusterInvoker<T> {\n     private static final Logger log = LoggerFactory.getLogger(MergeableClusterInvoker.class);\n-    private ExecutorService executor = Executors.newCachedThreadPool(new NamedThreadFactory(\"mergeable-cluster-executor\", true));\n     public MergeableClusterInvoker(Directory<T> directory) {\n         super(directory);",
    "output": "Remove useless code in MergeableClusterInvoker.java"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-grizzly/src/main/java/org/apache/dubbo/remoting/transport/grizzly/GrizzlyTransporter.java b/dubbo-remoting/dubbo-remoting-grizzly/src/main/java/org/apache/dubbo/remoting/transport/grizzly/GrizzlyTransporter.java\n--- a/dubbo-remoting/dubbo-remoting-grizzly/src/main/java/org/apache/dubbo/remoting/transport/grizzly/GrizzlyTransporter.java\n+++ b/dubbo-remoting/dubbo-remoting-grizzly/src/main/java/org/apache/dubbo/remoting/transport/grizzly/GrizzlyTransporter.java\n@@ -31,13 +31,13 @@ public class GrizzlyTransporter implements Transporter {\n     public static final String NAME = \"grizzly\";\n     @Override\n-    public RemotingServer bind(URL url, ChannelHandler listener) throws RemotingException {\n-        return new GrizzlyServer(url, listener);\n+    public RemotingServer bind(URL url, ChannelHandler handler) throws RemotingException {\n+        return new GrizzlyServer(url, handler);\n     }\n     @Override\n-    public Client connect(URL url, ChannelHandler listener) throws RemotingException {\n-        return new GrizzlyClient(url, listener);\n+    public Client connect(URL url, ChannelHandler handler) throws RemotingException {\n+        return new GrizzlyClient(url, handler);\n     }\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyTransporter.java b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyTransporter.java\n--- a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyTransporter.java\n+++ b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyTransporter.java\n@@ -28,13 +28,13 @@ public class NettyTransporter implements Transporter {\n     public static final String NAME = \"netty3\";\n     @Override\n-    public RemotingServer bind(URL url, ChannelHandler listener) throws RemotingException {\n-        return new NettyServer(url, listener);\n+    public RemotingServer bind(URL url, ChannelHandler handler) throws RemotingException {\n+        return new NettyServer(url, handler);\n     }\n     @Override\n-    public Client connect(URL url, ChannelHandler listener) throws RemotingException {\n-        return new NettyClient(url, listener);\n+    public Client connect(URL url, ChannelHandler handler) throws RemotingException {\n+        return new NettyClient(url, handler);\n     }\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyTransporter.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyTransporter.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyTransporter.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyTransporter.java\n@@ -31,13 +31,13 @@ public class NettyTransporter implements Transporter {\n     public static final String NAME = \"netty\";\n     @Override\n-    public RemotingServer bind(URL url, ChannelHandler listener) throws RemotingException {\n-        return new NettyServer(url, listener);\n+    public RemotingServer bind(URL url, ChannelHandler handler) throws RemotingException {\n+        return new NettyServer(url, handler);\n     }\n     @Override\n-    public Client connect(URL url, ChannelHandler listener) throws RemotingException {\n-        return new NettyClient(url, listener);\n+    public Client connect(URL url, ChannelHandler handler) throws RemotingException {\n+        return new NettyClient(url, handler);\n     }\n }",
    "output": "Fix variable name in NettyTransporter"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/HttpUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/HttpUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/HttpUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/HttpUtils.java\n@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (C) 2018 the original author or authors.\n+ *\n+ * Test License Header\n+ */\n+package org.apache.dubbo.common.utils;\n+\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.net.URLEncoder;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n+import static org.apache.dubbo.common.utils.StringUtils.AND;\n+import static org.apache.dubbo.common.utils.StringUtils.EQUAL;\n+import static org.apache.dubbo.common.utils.StringUtils.QUESTION_MASK;\n+import static org.apache.dubbo.common.utils.StringUtils.SLASH;\n+import static org.apache.dubbo.common.utils.StringUtils.isEmpty;\n+import static org.apache.dubbo.common.utils.StringUtils.replace;\n+\n+/**\n+ * Http Utilities class\n+ *\n+ * @since 2.7.6\n+ */\n+public abstract class HttpUtils {\n+\n+    private static final String UTF_8 = \"UTF-8\";\n+\n+    /**\n+     * HTTP GET method.\n+     */\n+    public static final String GET = \"GET\";\n+    /**\n+     * HTTP POST method.\n+     */\n+    public static final String POST = \"POST\";\n+    /**\n+     * HTTP PUT method.\n+     */\n+    public static final String PUT = \"PUT\";\n+    /**\n+     * HTTP DELETE method.\n+     */\n+    public static final String DELETE = \"DELETE\";\n+    /**\n+     * HTTP HEAD method.\n+     */\n+    public static final String HEAD = \"HEAD\";\n+    /**\n+     * HTTP OPTIONS method.\n+     */\n+    public static final String OPTIONS = \"OPTIONS\";\n+\n+    /**\n+     * The HTTP methods to support\n+     */\n+    public static final Set<String> HTTP_METHODS = unmodifiableSet(new LinkedHashSet<>(asList(\n+            GET, POST, POST, PUT, DELETE, HEAD, OPTIONS\n+    )));\n+\n+\n+    public static String buildPath(String rootPath, String... subPaths) {\n+\n+        Set<String> paths = new LinkedHashSet<>();\n+        paths.add(rootPath);\n+        paths.addAll(asList(subPaths));\n+\n+        return normalizePath(paths.stream()\n+                .filter(StringUtils::isNotEmpty)\n+                .collect(Collectors.joining(SLASH)));\n+    }\n+\n+    /**\n+     * Normalize path:\n+     * <ol>\n+     * <li>To remove query string if presents</li>\n+     * <li>To remove duplicated slash(\"/\") if exists</li>\n+     * </ol>\n+     *\n+     * @param path path to be normalized\n+     * @return a normalized path if required\n+     */\n+    public static String normalizePath(String path) {\n+        if (isEmpty(path)) {\n+            return SLASH;\n+        }\n+        String normalizedPath = path;\n+        int index = normalizedPath.indexOf(QUESTION_MASK);\n+        if (index > -1) {\n+            normalizedPath = normalizedPath.substring(0, index);\n+        }\n+        return replace(normalizedPath, \"//\", \"/\");\n+    }\n+\n+//    /**\n+//     * Get Parameters from the specified query string.\n+//     * <p>\n+//     *\n+//     * @param queryString The query string\n+//     * @return The query parameters\n+//     */\n+//    public static MultivaluedMap<String, String> getParameters(String queryString) {\n+//        return getParameters(split(queryString, AND_CHAR));\n+//    }\n+\n+//    /**\n+//     * Get Parameters from the specified pairs of name-value.\n+//     * <p>\n+//     *\n+//     * @param pairs The pairs of name-value\n+//     * @return The query parameters\n+//     */\n+//    public static MultivaluedMap<String, String> getParameters(Iterable<String> pairs) {\n+//        MultivaluedMap<String, String> parameters = new MultivaluedHashMap<>();\n+//        if (pairs != null) {\n+//            for (String pair : pairs) {\n+//                String[] nameAndValue = split(pair, EQUAL_CHAR);\n+//                String name = decode(nameAndValue[0]);\n+//                String value = nameAndValue.length < 2 ? null : nameAndValue[1];\n+//                value = decode(value);\n+//                addParam(parameters, name, value);\n+//            }\n+//        }\n+//        return parameters;\n+//    }\n+\n+//    /**\n+//     * Get Parameters from the specified pairs of name-value.\n+//     * <p>\n+//     *\n+//     * @param pairs The pairs of name-value\n+//     * @return The query parameters\n+//     */\n+//    public static MultivaluedMap<String, String> getParameters(String... pairs) {\n+//        return getParameters(asList(pairs));\n+//    }\n+\n+    // /**\n+    // * Parse a read-only {@link MultivaluedMap} of {@link HttpCookie} from {@link\n+    // HttpHeaders}\n+    // *\n+    // * @param httpHeaders {@link HttpHeaders}\n+    // * @return non-null, the key is a cookie name , the value is {@link HttpCookie}\n+    // */\n+    // public static MultivaluedMap<String, HttpCookie> parseCookies(HttpHeaders\n+    // httpHeaders) {\n+    //\n+    // String cookie = httpHeaders.getFirst(COOKIE);\n+    //\n+    // String[] cookieNameAndValues = StringUtils.delimitedListToStringArray(cookie,\n+    // SEMICOLON);\n+    //\n+    // MultivaluedMap<String, HttpCookie> cookies = new\n+    // LinkedMultiValueMap<>(cookieNameAndValues.length);\n+    //\n+    // for (String cookeNameAndValue : cookieNameAndValues) {\n+    // String[] nameAndValue =\n+    // delimitedListToStringArray(trimWhitespace(cookeNameAndValue), EQUAL);\n+    // String name = nameAndValue[0];\n+    // String value = nameAndValue.length < 2 ? null : nameAndValue[1];\n+    // HttpCookie httpCookie = new HttpCookie(name, value);\n+    // cookies.add(name, httpCookie);\n+    // }\n+    //\n+    // return cookies;\n+    // }\n+\n+    /**\n+     * To the name and value line sets\n+     *\n+     * @param nameAndValuesMap the map of name and values\n+     * @return non-null\n+     */\n+    public static Set<String> toNameAndValuesSet(\n+            Map<String, List<String>> nameAndValuesMap) {\n+        Set<String> nameAndValues = new LinkedHashSet<>();\n+        for (Map.Entry<String, List<String>> entry : nameAndValuesMap.entrySet()) {\n+            String name = entry.getKey();\n+            List<String> values = entry.getValue();\n+            for (String value : values) {\n+                String nameAndValue = name + EQUAL + value;\n+                nameAndValues.add(nameAndValue);\n+            }\n+        }\n+        return nameAndValues;\n+    }\n+\n+    public static String[] toNameAndValues(Map<String, List<String>> nameAndValuesMap) {\n+        return toNameAndValuesSet(nameAndValuesMap).toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Generate a string of query string from the specified request parameters {@link Map}\n+     *\n+     * @param params the specified request parameters {@link Map}\n+     * @return non-null\n+     */\n+    public static String toQueryString(Map<String, List<String>> params) {\n+        StringBuilder builder = new StringBuilder();\n+        for (String line : toNameAndValuesSet(params)) {\n+            builder.append(line).append(AND);\n+        }\n+        return builder.toString();\n+    }\n+\n+    /**\n+     * Decode value\n+     *\n+     * @param value the value requires to decode\n+     * @return the decoded value\n+     */\n+    public static String decode(String value) {\n+        if (value == null) {\n+            return value;\n+        }\n+        String decodedValue = value;\n+        try {\n+            decodedValue = URLDecoder.decode(value, UTF_8);\n+        } catch (UnsupportedEncodingException ex) {\n+        }\n+        return decodedValue;\n+    }\n+\n+    /**\n+     * encode value\n+     *\n+     * @param value the value requires to encode\n+     * @return the encoded value\n+     */\n+    public static String encode(String value) {\n+        String encodedValue = value;\n+        try {\n+            encodedValue = URLEncoder.encode(value, UTF_8);\n+        } catch (UnsupportedEncodingException ex) {\n+        }\n+        return encodedValue;\n+    }\n+\n+//    private static void addParam(MultivaluedMap<String, String> paramsMap, String name,\n+//                                 String value) {\n+//        String paramValue = trim(value);\n+//        if (isEmpty(paramValue)) {\n+//            paramValue = EMPTY_VALUE;\n+//        }\n+//        paramsMap.add(trim(name), paramValue);\n+//    }\n+}",
    "output": "Add HttpUtils.java file back"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -249,8 +249,8 @@ public void checkStubAndLocal(Class<?> interfaceClass) {\n     public void verifyStubAndLocal(String className, String label, Class<?> interfaceClass){\n     \tif (ConfigUtils.isNotEmpty(className)) {\n-                Class<?> localClass = ConfigUtils.isDefault(className) ?\n-                        ReflectUtils.forName(interfaceClass.getName() + label) : \t\t\tReflectUtils.forName(className);\n+            Class<?> localClass = ConfigUtils.isDefault(className) ?\n+                    ReflectUtils.forName(interfaceClass.getName() + label) : ReflectUtils.forName(className);\n                         verify(interfaceClass, localClass);\n             }\n     }",
    "output": "Remove unnecessary space"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java\n@@ -104,7 +104,13 @@ private static String exportOrUnexportCallbackService(Channel channel, URL url,\n         // add method, for verifying against method, automatic fallback (see dubbo protocol)\n         params.put(METHODS_KEY, StringUtils.join(Wrapper.getWrapper(clazz).getDeclaredMethodNames(), \",\"));\n-        Map<String, String> tmpMap = new HashMap<>(url.getParameters());\n+        Map<String, String> tmpMap = new HashMap<>();\n+        if (url != null) {\n+            Map<String, String> parameters = url.getParameters();\n+            if (parameters != null && !parameters.isEmpty()) {\n+                tmpMap.putAll(parameters);\n+            }\n+        }\n         tmpMap.putAll(params);\n         tmpMap.remove(VERSION_KEY);// doesn't need to distinguish version for callback\n         tmpMap.put(INTERFACE_KEY, clazz.getName());",
    "output": "Fix a potential NPE in CallbackServiceCodec.java"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java b/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java\n--- a/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java\n+++ b/dubbo-configcenter/dubbo-configcenter-consul/src/main/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfiguration.java\n@@ -151,7 +151,7 @@ public boolean publishConfig(String key, String group, String content) throws Un\n     @Override\n     public Object getInternalProperty(String key) {\n         logger.info(\"getting config from: \" + key);\n-        return kvClient.getValueAsString(key, Charsets.UTF_8).orElseThrow(() -> new IllegalArgumentException(key + \" does not exit.\"));\n+        return kvClient.getValueAsString(key, Charsets.UTF_8).orElse(null);\n     }\n     @Override\ndiff --git a/dubbo-configcenter/dubbo-configcenter-consul/src/test/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfigurationTest.java b/dubbo-configcenter/dubbo-configcenter-consul/src/test/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfigurationTest.java\n--- a/dubbo-configcenter/dubbo-configcenter-consul/src/test/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfigurationTest.java\n+++ b/dubbo-configcenter/dubbo-configcenter-consul/src/test/java/org/apache/dubbo/configcenter/consul/ConsulDynamicConfigurationTest.java\n@@ -71,7 +71,7 @@ public void testGetConfig() {\n         assertEquals(\"bar\", configuration.getConfig(\"foo\", \"dubbo\"));\n         // test does not block\n         assertEquals(\"bar\", configuration.getConfig(\"foo\", \"dubbo\"));\n-        Assertions.assertThrows(IllegalArgumentException.class, () -> configuration.getConfig(\"not-exist\", \"dubbo\"));\n+        Assertions.assertNull(configuration.getConfig(\"not-exist\", \"dubbo\"));\n     }\n     @Test",
    "output": "Fix consul, getproperty return null if key does not match a value"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -337,6 +337,7 @@ private T createProxy(Map<String, String> map) {\n         }\n         if (shouldCheck() && !invoker.isAvailable()) {\n+            invoker.destroy();\n             throw new IllegalStateException(\"Failed to check the status of the service \"\n                     + interfaceName\n                     + \". No provider available for the service \"",
    "output": "Fix invoker deactivation should be destroyed"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n@@ -16,7 +16,6 @@\n  */\n package org.apache.dubbo.rpc.cluster.support;\n-import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n@@ -71,7 +70,7 @@ protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, Load\n                         return invoker.invoke(invocation);\n                     } catch (RpcException e) {\n                         if (e.isNoInvokerAvailableAfterFilter()) {\n-                            log.debug(\"No available provider for service\" + directory.getUrl().getServiceKey() + \" on group \" + invoker.getUrl().getParameter(GROUP_KEY) + \", will continue to try another group.\");\n+                            log.debug(\"No available provider for service\" + getUrl().getServiceKey() + \" on group \" + invoker.getUrl().getParameter(GROUP_KEY) + \", will continue to try another group.\");\n                         } else {\n                             throw e;\n                         }\n@@ -180,11 +179,6 @@ public Class<T> getInterface() {\n         return directory.getInterface();\n     }\n-    @Override\n-    public URL getUrl() {\n-        return directory.getUrl();\n-    }\n-\n     @Override\n     public boolean isAvailable() {\n         return directory.isAvailable();",
    "output": "Fix merge does not work. * fix merge does not work"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -685,11 +685,11 @@ private Integer parsePort(String configPort) {\n     private String getValueFromConfig(ProtocolConfig protocolConfig, String key) {\n         String protocolPrefix = protocolConfig.getName().toUpperCase() + \"_\";\n-        String port = ConfigUtils.getSystemProperty(protocolPrefix + key);\n-        if (StringUtils.isEmpty(port)) {\n-            port = ConfigUtils.getSystemProperty(key);\n+        String value = ConfigUtils.getSystemProperty(protocolPrefix + key);\n+        if (StringUtils.isEmpty(value)) {\n+            value = ConfigUtils.getSystemProperty(key);\n         }\n-        return port;\n+        return value;\n     }\n     private Integer getRandomPort(String protocol) {",
    "output": "Fix variable name typo in ServiceConfig.java"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/wrapper/StubProxyFactoryWrapper.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/wrapper/StubProxyFactoryWrapper.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/wrapper/StubProxyFactoryWrapper.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/wrapper/StubProxyFactoryWrapper.java\n@@ -63,13 +63,7 @@ public void setProtocol(Protocol protocol) {\n     @Override\n     public <T> T getProxy(Invoker<T> invoker, boolean generic) throws RpcException {\n-        return proxyFactory.getProxy(invoker, generic);\n-    }\n-\n-    @Override\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n-        T proxy = proxyFactory.getProxy(invoker);\n+        T proxy = proxyFactory.getProxy(invoker, generic);\n         if (GenericService.class != invoker.getInterface()) {\n             URL url = invoker.getUrl();\n             String stub = url.getParameter(STUB_KEY, url.getParameter(LOCAL_KEY));\n@@ -111,6 +105,13 @@ public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n             }\n         }\n         return proxy;\n+\n+    }\n+\n+    @Override\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n+        return getProxy(invoker, false);\n     }\n     @Override",
    "output": "Fix stub proxy does not work cause of ProxyFactory.getProxy change"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/wrapper/StubProxyFactoryWrapper.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/wrapper/StubProxyFactoryWrapper.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/wrapper/StubProxyFactoryWrapper.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/wrapper/StubProxyFactoryWrapper.java\n@@ -63,13 +63,7 @@ public void setProtocol(Protocol protocol) {\n     @Override\n     public <T> T getProxy(Invoker<T> invoker, boolean generic) throws RpcException {\n-        return proxyFactory.getProxy(invoker, generic);\n-    }\n-\n-    @Override\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n-        T proxy = proxyFactory.getProxy(invoker);\n+        T proxy = proxyFactory.getProxy(invoker, generic);\n         if (GenericService.class != invoker.getInterface()) {\n             URL url = invoker.getUrl();\n             String stub = url.getParameter(STUB_KEY, url.getParameter(LOCAL_KEY));\n@@ -111,6 +105,13 @@ public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n             }\n         }\n         return proxy;\n+\n+    }\n+\n+    @Override\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n+        return getProxy(invoker, false);\n     }\n     @Override",
    "output": "Fix stub proxy does not work cause of ProxyFactory.getProxy change"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n@@ -52,7 +52,7 @@ public class DubboShutdownHook extends Thread {\n     /**\n      * Has it already been destroyed or not?\n      */\n-    private final AtomicBoolean destroyed = new AtomicBoolean(false);\n+    private static final AtomicBoolean destroyed = new AtomicBoolean(false);\n     private final EventDispatcher eventDispatcher = EventDispatcher.getDefaultExtension();\n@@ -111,17 +111,15 @@ public void unregister() {\n      * Destroy all the resources, including registries and protocols.\n      */\n     public void doDestroy() {\n-        if (!destroyed.compareAndSet(false, true)) {\n-            return;\n-        }\n-\n         // dispatch the DubboDestroyedEvent @since 2.7.5\n         dispatch(new DubboServiceDestroyedEvent(this));\n     }\n     public static void destroyAll() {\n-        AbstractRegistryFactory.destroyAll();\n-        destroyProtocols();\n+        if (destroyed.compareAndSet(false, true)) {\n+            AbstractRegistryFactory.destroyAll();\n+            destroyProtocols();\n+        }\n     }\n     private void dispatch(Event event) {\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n@@ -1038,6 +1038,7 @@ public void destroy() {\n         if (started.compareAndSet(true, false)\n                 && destroyed.compareAndSet(false, true)) {\n+\n             unregisterServiceInstance();\n             unexportMetadataService();\n             unexportServices();",
    "output": "Fix destroyAll called twice"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/Constants.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/Constants.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/Constants.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/Constants.java\n@@ -58,6 +58,11 @@ public interface Constants {\n      */\n     String REGISTRY_FILESAVE_SYNC_KEY = \"save.file\";\n+    /**\n+     * Whether to cache locally, default is true\n+     */\n+    String REGISTRY__LOCAL_FILE_CACHE_ENABLED = \"file.cache\";\n+\n     /**\n      * Reconnection period in milliseconds for register center\n      */\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n@@ -63,6 +63,7 @@\n import static org.apache.dubbo.common.constants.RegistryConstants.DYNAMIC_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.EMPTY_PROTOCOL;\n import static org.apache.dubbo.registry.Constants.REGISTRY_FILESAVE_SYNC_KEY;\n+import static org.apache.dubbo.registry.Constants.REGISTRY__LOCAL_FILE_CACHE_ENABLED;\n /**\n  * AbstractRegistry. (SPI, Prototype, ThreadSafe)\n@@ -82,7 +83,7 @@ public abstract class AbstractRegistry implements Registry {\n     // File cache timing writing\n     private final ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"DubboSaveRegistryCache\", true));\n     // Is it synchronized to save the file\n-    private final boolean syncSaveFile;\n+    private boolean syncSaveFile;\n     private final AtomicLong lastCacheChanged = new AtomicLong();\n     private final AtomicInteger savePropertiesRetryTimes = new AtomicInteger();\n     private final Set<URL> registered = new ConcurrentHashSet<>();\n@@ -94,24 +95,26 @@ public abstract class AbstractRegistry implements Registry {\n     public AbstractRegistry(URL url) {\n         setUrl(url);\n-        // Start file save timer\n-        syncSaveFile = url.getParameter(REGISTRY_FILESAVE_SYNC_KEY, false);\n-        String defaultFilename = System.getProperty(\"user.home\") + \"/.dubbo/dubbo-registry-\" + url.getParameter(APPLICATION_KEY) + \"-\" + url.getAddress().replaceAll(\":\", \"-\") + \".cache\";\n-        String filename = url.getParameter(FILE_KEY, defaultFilename);\n-        File file = null;\n-        if (ConfigUtils.isNotEmpty(filename)) {\n-            file = new File(filename);\n-            if (!file.exists() && file.getParentFile() != null && !file.getParentFile().exists()) {\n-                if (!file.getParentFile().mkdirs()) {\n-                    throw new IllegalArgumentException(\"Invalid registry cache file \" + file + \", cause: Failed to create directory \" + file.getParentFile() + \"!\");\n+        if (url.getParameter(REGISTRY__LOCAL_FILE_CACHE_ENABLED, true)) {\n+            // Start file save timer\n+            syncSaveFile = url.getParameter(REGISTRY_FILESAVE_SYNC_KEY, false);\n+            String defaultFilename = System.getProperty(\"user.home\") + \"/.dubbo/dubbo-registry-\" + url.getParameter(APPLICATION_KEY) + \"-\" + url.getAddress().replaceAll(\":\", \"-\") + \".cache\";\n+            String filename = url.getParameter(FILE_KEY, defaultFilename);\n+            File file = null;\n+            if (ConfigUtils.isNotEmpty(filename)) {\n+                file = new File(filename);\n+                if (!file.exists() && file.getParentFile() != null && !file.getParentFile().exists()) {\n+                    if (!file.getParentFile().mkdirs()) {\n+                        throw new IllegalArgumentException(\"Invalid registry cache file \" + file + \", cause: Failed to create directory \" + file.getParentFile() + \"!\");\n+                    }\n                 }\n             }\n+            this.file = file;\n+            // When starting the subscription center,\n+            // we need to read the local cache file for future Registry fault tolerance processing.\n+            loadProperties();\n+            notify(url.getBackupUrls());\n         }\n-        this.file = file;\n-        // When starting the subscription center,\n-        // we need to read the local cache file for future Registry fault tolerance processing.\n-        loadProperties();\n-        notify(url.getBackupUrls());\n     }\n     protected static List<URL> filterEmpty(URL url, List<URL> urls) {",
    "output": "Add a switch to turn off cache URLs locally"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcInvoker.java b/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcInvoker.java\n@@ -111,8 +111,6 @@ private int getErrorCode(Throwable e) {\n             Status status = statusException.getStatus();\n             if (status.getCode() == Status.Code.DEADLINE_EXCEEDED) {\n                 return RpcException.TIMEOUT_EXCEPTION;\n-            } else if (status.getCode() == Status.Code.DEADLINE_EXCEEDED) {\n-                //\n             }\n         }\n         return RpcException.UNKNOWN_EXCEPTION;",
    "output": "Fix Duplicate condition in 'if' statement inspection"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n@@ -507,16 +507,12 @@ private void initialize() {\n         useRegistryAsConfigCenterIfNecessary();\n-        startMetadataReport();\n-\n         loadRemoteConfigs();\n         checkGlobalConfigs();\n         initMetadataService();\n-        initMetadataServiceExporter();\n-\n         initEventListener();\n         if (logger.isInfoEnabled()) {\n@@ -527,17 +523,22 @@ private void initialize() {\n     private void checkGlobalConfigs() {\n         // check Application\n         ConfigValidationUtils.validateApplicationConfig(getApplication());\n-        // check Config Center\n-        Collection<ConfigCenterConfig> configCenters = configManager.getConfigCenters();\n-        if (CollectionUtils.isNotEmpty(configCenters)) {\n-            for (ConfigCenterConfig configCenterConfig : configCenters) {\n-                ConfigValidationUtils.validateConfigCenterConfig(configCenterConfig);\n-            }\n-        }\n+\n         // check Metadata\n         Collection<MetadataReportConfig> metadatas = configManager.getMetadataConfigs();\n-        for (MetadataReportConfig metadataReportConfig : metadatas) {\n-            ConfigValidationUtils.validateMetadataConfig(metadataReportConfig);\n+        if (CollectionUtils.isEmpty(metadatas)) {\n+            MetadataReportConfig metadataReportConfig = new MetadataReportConfig();\n+            metadataReportConfig.refresh();\n+            if (metadataReportConfig.isValid()) {\n+                configManager.addMetadataReport(metadataReportConfig);\n+                metadatas = configManager.getMetadataConfigs();\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(metadatas)) {\n+            for (MetadataReportConfig metadataReportConfig : metadatas) {\n+                metadataReportConfig.refresh();\n+                ConfigValidationUtils.validateMetadataConfig(metadataReportConfig);\n+            }\n         }\n         // check Provider\n@@ -580,11 +581,24 @@ private void checkGlobalConfigs() {\n     private void startConfigCenter() {\n         Collection<ConfigCenterConfig> configCenters = configManager.getConfigCenters();\n+        // check Config Center\n+        if (CollectionUtils.isEmpty(configCenters)) {\n+            ConfigCenterConfig configCenterConfig = new ConfigCenterConfig();\n+            configCenterConfig.refresh();\n+            if (configCenterConfig.isValid()) {\n+                configManager.addConfigCenter(configCenterConfig);\n+                configCenters = configManager.getConfigCenters();\n+            }\n+        } else {\n+            for (ConfigCenterConfig configCenterConfig : configCenters) {\n+                configCenterConfig.refresh();\n+                ConfigValidationUtils.validateConfigCenterConfig(configCenterConfig);\n+            }\n+        }\n+\n         if (CollectionUtils.isNotEmpty(configCenters)) {\n             CompositeDynamicConfiguration compositeDynamicConfiguration = new CompositeDynamicConfiguration();\n             for (ConfigCenterConfig configCenter : configCenters) {\n-                configCenter.refresh();\n-                ConfigValidationUtils.validateConfigCenterConfig(configCenter);\n                 compositeDynamicConfiguration.addConfiguration(prepareEnvironment(configCenter));\n             }\n             environment.setDynamicConfiguration(compositeDynamicConfiguration);\n@@ -695,13 +709,8 @@ private void loadRemoteConfigs() {\n      * Initialize {@link MetadataService} from {@link WritableMetadataService}'s extension\n      */\n     private void initMetadataService() {\n+        startMetadataReport();\n         this.metadataService = getExtension(getMetadataType());\n-    }\n-\n-    /**\n-     * Initialize {@link MetadataServiceExporter}\n-     */\n-    private void initMetadataServiceExporter() {\n         this.metadataServiceExporter = new ConfigurableMetadataServiceExporter(metadataService);\n     }",
    "output": "Fix config-center configured in dubbo.properties does not work"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -69,6 +69,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.MONITOR_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PROXY_CLASS_REF;\n+import static org.apache.dubbo.common.constants.CommonConstants.REMOTE_METADATA_STORAGE_TYPE;\n import static org.apache.dubbo.common.constants.CommonConstants.REVISION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SEMICOLON_SPLIT_PATTERN;\n import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n@@ -220,6 +221,10 @@ public synchronized void init() {\n         // appendParameters(map, consumer, Constants.DEFAULT_KEY);\n         AbstractConfig.appendParameters(map, consumer);\n         AbstractConfig.appendParameters(map, this);\n+        MetadataReportConfig metadataReportConfig = getMetadataReportConfig();\n+        if (metadataReportConfig != null && metadataReportConfig.isValid()) {\n+            map.putIfAbsent(METADATA_KEY, REMOTE_METADATA_STORAGE_TYPE);\n+        }\n         Map<String, AsyncMethodInfo> attributes = null;\n         if (CollectionUtils.isNotEmpty(getMethods())) {\n             attributes = new HashMap<>();\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -77,6 +77,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.MONITOR_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n import static org.apache.dubbo.common.constants.CommonConstants.REGISTER_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.REMOTE_METADATA_STORAGE_TYPE;\n import static org.apache.dubbo.common.constants.CommonConstants.REVISION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.DYNAMIC_KEY;\n@@ -343,6 +344,10 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n         AbstractConfig.appendParameters(map, provider);\n         AbstractConfig.appendParameters(map, protocolConfig);\n         AbstractConfig.appendParameters(map, this);\n+        MetadataReportConfig metadataReportConfig = getMetadataReportConfig();\n+        if (metadataReportConfig != null && metadataReportConfig.isValid()) {\n+            map.putIfAbsent(METADATA_KEY, REMOTE_METADATA_STORAGE_TYPE);\n+        }\n         if (CollectionUtils.isNotEmpty(getMethods())) {\n             for (MethodConfig method : getMethods()) {\n                 AbstractConfig.appendParameters(map, method, method.getName());",
    "output": "Fix metadata config does not take effect"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java\n@@ -21,6 +21,7 @@\n import java.math.BigInteger;\n import java.text.ParseException;\n import java.text.SimpleDateFormat;\n+import java.time.LocalDateTime;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Date;\n@@ -110,6 +111,18 @@ public static Object compatibleTypeConvert(Object value, Class<?> type) {\n                             + DATE_FORMAT + \", cause: \" + e.getMessage(), e);\n                 }\n             }\n+            if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class\n+                    || type == java.time.LocalTime.class) {\n+\n+                LocalDateTime localDateTime = LocalDateTime.parse(string);\n+                if (type == java.time.LocalDate.class) {\n+                    return localDateTime.toLocalDate();\n+                }\n+                if (type == java.time.LocalTime.class) {\n+                    return localDateTime.toLocalTime();\n+                }\n+                return localDateTime;\n+            }\n             if (type == Class.class) {\n                 try {\n                     return ReflectUtils.name2class(string);\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/CompatibleTypeUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/CompatibleTypeUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/CompatibleTypeUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/CompatibleTypeUtilsTest.java\n@@ -21,6 +21,7 @@\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.text.SimpleDateFormat;\n+import java.time.format.DateTimeFormatter;\n import java.util.ArrayList;\n import java.util.Date;\n import java.util.HashSet;\n@@ -77,6 +78,15 @@ public void testCompatibleTypeConvert() throws Exception {\n             result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11 12:24:12\", java.sql.Timestamp.class);\n             assertEquals(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format((java.sql.Timestamp) result), \"2011-12-11 12:24:12\");\n+            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11T12:24:12.047\", java.time.LocalDateTime.class);\n+            assertEquals(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\").format((java.time.LocalDateTime) result), \"2011-12-11 12:24:12\");\n+\n+            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11T12:24:12.047\", java.time.LocalTime.class);\n+            assertEquals(DateTimeFormatter.ofPattern(\"HH:mm:ss\").format((java.time.LocalTime) result), \"12:24:12\");\n+\n+            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11T12:24:12.047\", java.time.LocalDate.class);\n+            assertEquals(DateTimeFormatter.ofPattern(\"yyyy-MM-dd\").format((java.time.LocalDate) result), \"2011-12-11\");\n+\n             result = CompatibleTypeUtils.compatibleTypeConvert(\"ab\", char[].class);\n             assertEquals(2, ((char[]) result).length);\n             assertEquals('a', ((char[]) result)[0]);",
    "output": "Fix PojoUtils support localdatetime,lcaldate,localtime"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectInput.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectInput.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectInput.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectInput.java\n@@ -97,4 +97,7 @@ public <T> T readObject(Class<T> cls, Type type) throws IOException, ClassNotFou\n         return readObject(cls);\n     }\n+    public InputStream readInputStream() throws IOException {\n+        return mH2i.readInputStream();\n+    }\n }\ndiff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectOutput.java b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectOutput.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectOutput.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectOutput.java\n@@ -93,4 +93,8 @@ public void writeObject(Object obj) throws IOException {\n     public void flushBuffer() throws IOException {\n         mH2o.flushBuffer();\n     }\n+\n+    public OutputStream getOutputStream() throws IOException {\n+        return mH2o.getBytesOutputStream();\n+    }\n }",
    "output": "Add hessian stream API"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n@@ -71,8 +71,8 @@ public class NetUtils {\n     private static final Map<String, String> HOST_NAME_CACHE = new LRUCache<>(1000);\n     private static volatile InetAddress LOCAL_ADDRESS = null;\n-    private static final String SPLIT_IPV4_CHARECTER = \"\\\\.\";\n-    private static final String SPLIT_IPV6_CHARECTER = \":\";\n+    private static final String SPLIT_IPV4_CHARACTER = \"\\\\.\";\n+    private static final String SPLIT_IPV6_CHARACTER = \":\";\n     public static int getRandomPort() {\n         return RND_PORT_START + ThreadLocalRandom.current().nextInt(RND_PORT_RANGE);\n@@ -448,9 +448,9 @@ public static boolean matchIpRange(String pattern, String host, int port) throws\n         }\n         pattern = hostAndPort[0];\n-        String splitCharacter = SPLIT_IPV4_CHARECTER;\n+        String splitCharacter = SPLIT_IPV4_CHARACTER;\n         if (!isIpv4) {\n-            splitCharacter = SPLIT_IPV6_CHARECTER;\n+            splitCharacter = SPLIT_IPV6_CHARACTER;\n         }\n         String[] mask = pattern.split(splitCharacter);\n         //check format of pattern",
    "output": "Fix typo `CHARECTER` -> `CHARACTER`"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n@@ -276,7 +276,7 @@ protected void checkInvokers(List<Invoker<T>> invokers, Invocation invocation) {\n         if (CollectionUtils.isEmpty(invokers)) {\n             throw new RpcException(RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER, \"Failed to invoke the method \"\n                     + invocation.getMethodName() + \" in the service \" + getInterface().getName()\n-                    + \". No provider available for the service \" + directory.getUrl().getServiceKey()\n+                    + \". No provider available for the service \" + directory.getConsumerUrl().getServiceKey()\n                     + \" from registry \" + directory.getUrl().getAddress()\n                     + \" on the consumer \" + NetUtils.getLocalHost()\n                     + \" using the dubbo version \" + Version.getVersion()",
    "output": "Fix misuse, call getConsumerUrl"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-redis/src/main/java/org/apache/dubbo/registry/redis/RedisRegistry.java b/dubbo-registry/dubbo-registry-redis/src/main/java/org/apache/dubbo/registry/redis/RedisRegistry.java\n--- a/dubbo-registry/dubbo-registry-redis/src/main/java/org/apache/dubbo/registry/redis/RedisRegistry.java\n+++ b/dubbo-registry/dubbo-registry-redis/src/main/java/org/apache/dubbo/registry/redis/RedisRegistry.java\n@@ -35,6 +35,8 @@\n import redis.clients.jedis.Jedis;\n import redis.clients.jedis.JedisPool;\n import redis.clients.jedis.JedisPubSub;\n+import redis.clients.jedis.JedisSentinelPool;\n+import redis.clients.util.Pool;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -63,10 +65,10 @@\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.CATEGORY_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.DEFAULT_CATEGORY;\n-import static org.apache.dubbo.registry.Constants.DEFAULT_REGISTRY_RECONNECT_PERIOD;\n-import static org.apache.dubbo.registry.Constants.DEFAULT_SESSION_TIMEOUT;\n import static org.apache.dubbo.common.constants.RegistryConstants.DYNAMIC_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.EMPTY_PROTOCOL;\n+import static org.apache.dubbo.registry.Constants.DEFAULT_REGISTRY_RECONNECT_PERIOD;\n+import static org.apache.dubbo.registry.Constants.DEFAULT_SESSION_TIMEOUT;\n import static org.apache.dubbo.registry.Constants.REGISTER;\n import static org.apache.dubbo.registry.Constants.REGISTRY_RECONNECT_PERIOD_KEY;\n import static org.apache.dubbo.registry.Constants.SESSION_TIMEOUT_KEY;\n@@ -83,13 +85,15 @@ public class RedisRegistry extends FailbackRegistry {\n     private final static String DEFAULT_ROOT = \"dubbo\";\n+    private static final String REDIS_MASTER_NAME_KEY = \"master-name\";\n+\n     private final ScheduledExecutorService expireExecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"DubboRegistryExpireTimer\", true));\n     private final ScheduledFuture<?> expireFuture;\n     private final String root;\n-    private final Map<String, JedisPool> jedisPools = new ConcurrentHashMap<>();\n+    private final Map<String, Pool<Jedis>> jedisPools = new ConcurrentHashMap<>();\n     private final ConcurrentMap<String, Notifier> notifiers = new ConcurrentHashMap<>();\n@@ -147,21 +151,33 @@ public RedisRegistry(URL url) {\n         if (ArrayUtils.isNotEmpty(backups)) {\n             addresses.addAll(Arrays.asList(backups));\n         }\n-\n-        for (String address : addresses) {\n-            int i = address.indexOf(':');\n-            String host;\n-            int port;\n-            if (i > 0) {\n-                host = address.substring(0, i);\n-                port = Integer.parseInt(address.substring(i + 1));\n-            } else {\n-                host = address;\n-                port = DEFAULT_REDIS_PORT;\n+        //Redis\n+        String masterName = url.getParameter(REDIS_MASTER_NAME_KEY);\n+        if (StringUtils.isEmpty(masterName)) {\n+            //redis\n+            for (String address : addresses) {\n+                int i = address.indexOf(':');\n+                String host;\n+                int port;\n+                if (i > 0) {\n+                    host = address.substring(0, i);\n+                    port = Integer.parseInt(address.substring(i + 1));\n+                } else {\n+                    host = address;\n+                    port = DEFAULT_REDIS_PORT;\n+                }\n+                this.jedisPools.put(address, new JedisPool(config, host, port,\n+                        url.getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT), StringUtils.isEmpty(url.getPassword()) ? null : url.getPassword(),\n+                        url.getParameter(\"db.index\", 0)));\n             }\n-            this.jedisPools.put(address, new JedisPool(config, host, port,\n-                    url.getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT), StringUtils.isEmpty(url.getPassword()) ? null : url.getPassword(),\n-                    url.getParameter(\"db.index\", 0)));\n+        } else {\n+            //redis\n+            Set<String> sentinelSet = new HashSet<>(addresses);\n+            int index = url.getParameter(\"db.index\", 0);\n+            int timeout = url.getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);\n+            String password = StringUtils.isEmpty(url.getPassword()) ? null : url.getPassword();\n+            JedisSentinelPool pool = new JedisSentinelPool(masterName, sentinelSet, config, timeout, password, index);\n+            this.jedisPools.put(masterName, pool);\n         }\n         this.reconnectPeriod = url.getParameter(REGISTRY_RECONNECT_PERIOD_KEY, DEFAULT_REGISTRY_RECONNECT_PERIOD);\n@@ -185,8 +201,8 @@ public RedisRegistry(URL url) {\n     }\n     private void deferExpired() {\n-        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n-            JedisPool jedisPool = entry.getValue();\n+        for (Map.Entry<String, Pool<Jedis>> entry : jedisPools.entrySet()) {\n+            Pool<Jedis> jedisPool = entry.getValue();\n             try {\n                 try (Jedis jedis = jedisPool.getResource()) {\n                     for (URL url : new HashSet<>(getRegistered())) {\n@@ -242,7 +258,7 @@ private void clean(Jedis jedis) {\n     @Override\n     public boolean isAvailable() {\n-        for (JedisPool jedisPool : jedisPools.values()) {\n+        for (Pool<Jedis> jedisPool : jedisPools.values()) {\n             try (Jedis jedis = jedisPool.getResource()) {\n                 if (jedis.isConnected()) {\n                     return true; // At least one single machine is available.\n@@ -268,8 +284,8 @@ public void destroy() {\n         } catch (Throwable t) {\n             logger.warn(t.getMessage(), t);\n         }\n-        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n-            JedisPool jedisPool = entry.getValue();\n+        for (Map.Entry<String, Pool<Jedis>> entry : jedisPools.entrySet()) {\n+            Pool<Jedis> jedisPool = entry.getValue();\n             try {\n                 jedisPool.destroy();\n             } catch (Throwable t) {\n@@ -286,8 +302,8 @@ public void doRegister(URL url) {\n         String expire = String.valueOf(System.currentTimeMillis() + expirePeriod);\n         boolean success = false;\n         RpcException exception = null;\n-        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n-            JedisPool jedisPool = entry.getValue();\n+        for (Map.Entry<String, Pool<Jedis>> entry : jedisPools.entrySet()) {\n+            Pool<Jedis> jedisPool = entry.getValue();\n             try {\n                 try (Jedis jedis = jedisPool.getResource()) {\n                     jedis.hset(key, value, expire);\n@@ -316,8 +332,8 @@ public void doUnregister(URL url) {\n         String value = url.toFullString();\n         RpcException exception = null;\n         boolean success = false;\n-        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n-            JedisPool jedisPool = entry.getValue();\n+        for (Map.Entry<String, Pool<Jedis>> entry : jedisPools.entrySet()) {\n+            Pool<Jedis> jedisPool = entry.getValue();\n             try {\n                 try (Jedis jedis = jedisPool.getResource()) {\n                     jedis.hdel(key, value);\n@@ -354,8 +370,8 @@ public void doSubscribe(final URL url, final NotifyListener listener) {\n         }\n         boolean success = false;\n         RpcException exception = null;\n-        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n-            JedisPool jedisPool = entry.getValue();\n+        for (Map.Entry<String, Pool<Jedis>> entry : jedisPools.entrySet()) {\n+            Pool<Jedis> jedisPool = entry.getValue();\n             try {\n                 try (Jedis jedis = jedisPool.getResource()) {\n                     if (service.endsWith(ANY_VALUE)) {\n@@ -485,9 +501,9 @@ private String toCategoryPath(URL url) {\n     private class NotifySub extends JedisPubSub {\n-        private final JedisPool jedisPool;\n+        private final Pool<Jedis> jedisPool;\n-        public NotifySub(JedisPool jedisPool) {\n+        public NotifySub(Pool<Jedis> jedisPool) {\n             this.jedisPool = jedisPool;\n         }\n@@ -579,10 +595,16 @@ public void run() {\n                 try {\n                     if (!isSkip()) {\n                         try {\n-                            for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n-                                JedisPool jedisPool = entry.getValue();\n+                            for (Map.Entry<String, Pool<Jedis>> entry : jedisPools.entrySet()) {\n+                                Pool<Jedis> jedisPool = entry.getValue();\n                                 try {\n+                                    if (jedisPool.isClosed()) {\n+                                        continue;\n+                                    }\n                                     jedis = jedisPool.getResource();\n+                                    if (!jedis.isConnected()) {\n+                                        continue;\n+                                    }\n                                     try {\n                                         if (service.endsWith(ANY_VALUE)) {\n                                             if (first) {",
    "output": "Add Sentinel support for RedisRegistry"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n@@ -93,7 +93,7 @@ public static URL parseURL(String address, Map<String, String> defaults) {\n         String defaultPassword = defaults == null ? null : defaults.get(PASSWORD_KEY);\n         int defaultPort = StringUtils.parseInteger(defaults == null ? null : defaults.get(PORT_KEY));\n         String defaultPath = defaults == null ? null : defaults.get(PATH_KEY);\n-        Map<String, String> defaultParameters = defaults == null ? null : new HashMap<String, String>(defaults);\n+        Map<String, String> defaultParameters = defaults == null ? null : new HashMap<>(defaults);\n         if (defaultParameters != null) {\n             defaultParameters.remove(PROTOCOL_KEY);\n             defaultParameters.remove(USERNAME_KEY);\n@@ -110,8 +110,8 @@ public static URL parseURL(String address, Map<String, String> defaults) {\n         String host = u.getHost();\n         int port = u.getPort();\n         String path = u.getPath();\n-        Map<String, String> parameters = new HashMap<String, String>(u.getParameters());\n-        if ((protocol == null || protocol.length() == 0) && defaultProtocol != null && defaultProtocol.length() > 0) {\n+        Map<String, String> parameters = new HashMap<>(u.getParameters());\n+        if (protocol == null || protocol.length() == 0) {\n             changed = true;\n             protocol = defaultProtocol;\n         }",
    "output": "Remove duplicate code"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java\n@@ -82,7 +82,7 @@ public void destroy() {\n     public Result invoke(Invocation invocation) throws RpcException {\n         try {\n             Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());\n-            CompletableFuture<Object> future = wrapWithFuture(value, invocation);\n+\t\t\tCompletableFuture<Object> future = wrapWithFuture(value);\n             CompletableFuture<AppResponse> appResponseFuture = future.handle((obj, t) -> {\n                 AppResponse result = new AppResponse();\n                 if (t != null) {\n@@ -107,7 +107,7 @@ public Result invoke(Invocation invocation) throws RpcException {\n         }\n     }\n-    private CompletableFuture<Object> wrapWithFuture (Object value, Invocation invocation) {\n+\tprivate CompletableFuture<Object> wrapWithFuture(Object value) {\n         if (RpcContext.getContext().isAsyncStarted()) {\n             return ((AsyncContextImpl)(RpcContext.getContext().getAsyncContext())).getInternalFuture();\n         } else if (value instanceof CompletableFuture) {",
    "output": "Fix Remove unused variable parameters in AbstractProxyInvoker"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n@@ -30,10 +30,7 @@\n import java.util.Map;\n import java.util.concurrent.Callable;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n@@ -681,34 +678,9 @@ public <T> CompletableFuture<T> asyncCall(Callable<T> callable) {\n                 removeAttachment(ASYNC_KEY);\n             }\n         } catch (final RpcException e) {\n-            return new CompletableFuture<T>() {\n-                @Override\n-                public boolean cancel(boolean mayInterruptIfRunning) {\n-                    return false;\n-                }\n-\n-                @Override\n-                public boolean isCancelled() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public boolean isDone() {\n-                    return true;\n-                }\n-\n-                @Override\n-                public T get() throws InterruptedException, ExecutionException {\n-                    throw new ExecutionException(e.getCause());\n-                }\n-\n-                @Override\n-                public T get(long timeout, TimeUnit unit)\n-                        throws InterruptedException, ExecutionException,\n-                        TimeoutException {\n-                    return get();\n-                }\n-            };\n+            CompletableFuture<T> exceptionFuture = new CompletableFuture<>();\n+            exceptionFuture.completeExceptionally(e);\n+            return exceptionFuture;\n         }\n         return ((CompletableFuture<T>) getContext().getFuture());\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java\n@@ -17,12 +17,13 @@\n package org.apache.dubbo.rpc;\n import org.apache.dubbo.common.URL;\n-\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n public class RpcContextTest {\n@@ -149,10 +150,29 @@ public void testAsync() {\n         Assertions.assertTrue(rpcContext.isAsyncStarted());\n         asyncContext.write(new Object());\n-        Assertions.assertTrue(((AsyncContextImpl)asyncContext).getInternalFuture().isDone());\n+        Assertions.assertTrue(((AsyncContextImpl) asyncContext).getInternalFuture().isDone());\n         rpcContext.stopAsync();\n         Assertions.assertTrue(rpcContext.isAsyncStarted());\n     }\n+    @Test\n+    public void testAsyncCall() {\n+        CompletableFuture<String> rpcFuture = RpcContext.getContext().asyncCall(() -> {\n+            throw new NullPointerException();\n+        });\n+\n+        rpcFuture.whenComplete((rpcResult, throwable) -> {\n+            System.out.println(throwable.toString());\n+            Assertions.assertNull(rpcResult);\n+            Assertions.assertTrue(throwable instanceof RpcException);\n+            Assertions.assertTrue(throwable.getCause() instanceof NullPointerException);\n+        });\n+\n+        Assertions.assertThrows(ExecutionException.class, rpcFuture::get);\n+\n+        rpcFuture = rpcFuture.exceptionally(throwable -> \"mock success\");\n+\n+        Assertions.assertEquals(\"mock success\", rpcFuture.join());\n+    }\n }",
    "output": "Fix RpcContext.asyncCall return when throw RpcException"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/legacy/SelectTelnetHandler.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/legacy/SelectTelnetHandler.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/legacy/SelectTelnetHandler.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/legacy/SelectTelnetHandler.java\n@@ -51,7 +51,7 @@ public String telnet(Channel channel, String message) {\n         if (!StringUtils.isInteger(message) || Integer.parseInt(message) < 1 || Integer.parseInt(message) > methodList.size()) {\n             return \"Illegal index ,please input select 1~\" + methodList.size();\n         }\n-        Method method = methodList.get(Integer.parseInt(message));\n+        Method method = methodList.get(Integer.parseInt(message) - 1);\n         channel.setAttribute(SELECT_METHOD_KEY, method);\n         channel.setAttribute(SELECT_KEY, Boolean.TRUE);\n         String invokeMessage = (String) channel.getAttribute(InvokeTelnetHandler.INVOKE_MESSAGE_KEY);\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/legacy/InvokerTelnetHandlerTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/legacy/InvokerTelnetHandlerTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/legacy/InvokerTelnetHandlerTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/legacy/InvokerTelnetHandlerTest.java\n@@ -150,6 +150,8 @@ public void testInvokeOverriddenMethodBySelect() throws RemotingException {\n         result = select.telnet(mockChannel, \"1\");\n         //result dependent on method order.\n         assertTrue(result.contains(\"result: 8\") || result.contains(\"result: \\\"Dubbo\\\"\"));\n+        result = select.telnet(mockChannel, \"2\");\n+        assertTrue(result.contains(\"result: 8\") || result.contains(\"result: \\\"Dubbo\\\"\"));\n     }\n     @Test",
    "output": "Fix SelectTelnetHandler.telnet IndexOutOfBoundsException"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.constants.RemotingConstants;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;\n import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;\n@@ -52,6 +53,7 @@ public abstract class AbstractZookeeperTransporter implements ZookeeperTransport\n     @Override\n     public ZookeeperClient connect(URL url) {\n         ZookeeperClient zookeeperClient;\n+        // address format: {[username:password@]address}\n         List<String> addressList = getURLBackupAddress(url);\n         // The field define the zookeeper server , including protocol, host, port, username, password\n         if ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList)) != null && zookeeperClient.isConnected()) {\n@@ -111,8 +113,29 @@ ZookeeperClient fetchAndUpdateZookeeperClientCache(List<String> addressList) {\n     List<String> getURLBackupAddress(URL url) {\n         List<String> addressList = new ArrayList<String>();\n         addressList.add(url.getAddress());\n-\n         addressList.addAll(url.getParameter(RemotingConstants.BACKUP_KEY, Collections.EMPTY_LIST));\n+\n+        String authPrefix = null;\n+        if (StringUtils.isNotEmpty(url.getUsername())) {\n+            StringBuilder buf = new StringBuilder();\n+            buf.append(url.getUsername());\n+            if (StringUtils.isNotEmpty(url.getPassword())) {\n+                buf.append(\":\");\n+                buf.append(url.getPassword());\n+            }\n+            buf.append(\"@\");\n+            authPrefix = buf.toString();\n+        }\n+\n+        if (StringUtils.isNotEmpty(authPrefix)) {\n+            List<String> authedAddressList = new ArrayList<>(addressList.size());\n+            for (String addr : addressList) {\n+                authedAddressList.add(authPrefix + addr);\n+            }\n+            return authedAddressList;\n+        }\n+\n+\n         return addressList;\n     }\ndiff --git a/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporterTest.java b/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporterTest.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporterTest.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper/src/test/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporterTest.java\n@@ -205,4 +205,21 @@ public void testRepeatConnectForNoMatchBackUpAdd() throws Exception {\n         zkServer2.stop();\n         zkServer3.stop();\n     }\n+\n+    @Test\n+    public void testSameHostWithDifferentUser() throws Exception {\n+        int zkPort1 = NetUtils.getAvailablePort();\n+        int zkPort2 = NetUtils.getAvailablePort();\n+        try (TestingServer zkServer1 = new TestingServer(zkPort1, true)) {\n+            try (TestingServer zkServer2 = new TestingServer(zkPort2, true)) {\n+                URL url1 = URL.valueOf(\"zookeeper://us1:pw1@127.0.0.1:\" + zkPort1 + \"/path1\");\n+                URL url2 = URL.valueOf(\"zookeeper://us2:pw2@127.0.0.1:\" + zkPort1 + \"/path2\");\n+\n+                ZookeeperClient client1 = abstractZookeeperTransporter.connect(url1);\n+                ZookeeperClient client2 = abstractZookeeperTransporter.connect(url2);\n+\n+                assertThat(client1, not(client2));\n+            }\n+        }\n+    }\n }",
    "output": "Fix zk client create logic"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-http/src/main/java/org/apache/dubbo/rpc/protocol/http/JsonRemoteInvocation.java b/dubbo-rpc/dubbo-rpc-http/src/main/java/org/apache/dubbo/rpc/protocol/http/JsonRemoteInvocation.java\n--- a/dubbo-rpc/dubbo-rpc-http/src/main/java/org/apache/dubbo/rpc/protocol/http/JsonRemoteInvocation.java\n+++ b/dubbo-rpc/dubbo-rpc-http/src/main/java/org/apache/dubbo/rpc/protocol/http/JsonRemoteInvocation.java\n@@ -17,9 +17,10 @@\n package org.apache.dubbo.rpc.protocol.http;\n-import org.aopalliance.intercept.MethodInvocation;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.rpc.RpcContext;\n+\n+import org.aopalliance.intercept.MethodInvocation;\n import org.springframework.remoting.support.RemoteInvocation;\n import java.lang.reflect.InvocationTargetException;\n@@ -44,7 +45,7 @@ public JsonRemoteInvocation(MethodInvocation methodInvocation) {\n     public Object invoke(Object targetObject) throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException {\n         RpcContext context = RpcContext.getContext();\n-        context.setAttachments((Map<String, String>) getAttribute(DUBBO_ATTACHMENTS_ATTR_NAME));\n+        context.setAttachments((Map<String, Object>) getAttribute(DUBBO_ATTACHMENTS_ATTR_NAME));\n         String generic = (String) getAttribute(GENERIC_KEY);\n         if (StringUtils.isNotEmpty(generic)) {",
    "output": "Fix compile error of Jsonrpc Protocol"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n@@ -493,6 +493,7 @@ public void destroy() {\n                 }\n             }\n         }\n+        AbstractRegistryFactory.removeDestroyedRegistry(this);\n     }\n     protected boolean acceptable(URL urlToRegistry) {\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n@@ -175,6 +175,15 @@ public List<URL> lookup(URL url) {\n         }\n     };\n+    public static void removeDestroyedRegistry(Registry toRm){\n+        LOCK.lock();\n+        try {\n+            REGISTRIES.entrySet().removeIf(entry -> entry.getValue().equals(toRm));\n+        } finally {\n+            LOCK.unlock();\n+        }\n+    }\n+\n     // for unit test\n     public static void clearRegistryNotDestroy() {\n         REGISTRIES.clear();\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryFactoryTest.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryFactoryTest.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryFactoryTest.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryFactoryTest.java\n@@ -30,7 +30,6 @@\n /**\n  * AbstractRegistryFactoryTest\n- *\n  */\n public class AbstractRegistryFactoryTest {\n@@ -107,10 +106,20 @@ public void testRegistryFactoryGroupCache() throws Exception {\n     public void testDestroyAllRegistries() {\n         Registry registry1 = registryFactory.getRegistry(URL.valueOf(\"dubbo://\" + NetUtils.getLocalHost() + \":8888?group=xxx\"));\n         Registry registry2 = registryFactory.getRegistry(URL.valueOf(\"dubbo://\" + NetUtils.getLocalHost() + \":9999?group=yyy\"));\n+        Registry registry3 = new AbstractRegistry(URL.valueOf(\"dubbo://\" + NetUtils.getLocalHost() + \":2020?group=yyy\")) {\n+            @Override\n+            public boolean isAvailable() {\n+                return true;\n+            }\n+        };\n         Collection<Registry> registries = AbstractRegistryFactory.getRegistries();\n         Assertions.assertTrue(registries.contains(registry1));\n         Assertions.assertTrue(registries.contains(registry2));\n+        registry3.destroy();\n+        registries = AbstractRegistryFactory.getRegistries();\n+        Assertions.assertFalse(registries.contains(registry3));\n         AbstractRegistryFactory.destroyAll();\n+        registries = AbstractRegistryFactory.getRegistries();\n         Assertions.assertFalse(registries.contains(registry1));\n         Assertions.assertFalse(registries.contains(registry2));\n     }",
    "output": "Remove registry from factory that already destroyed. #5483"
  },
  {
    "input": "diff --git a/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/MonitorFilter.java b/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/MonitorFilter.java\n--- a/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/MonitorFilter.java\n+++ b/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/MonitorFilter.java\n@@ -83,7 +83,7 @@ public void setMonitorFactory(MonitorFactory monitorFactory) {\n     @Override\n     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n         if (invoker.getUrl().hasParameter(MONITOR_KEY)) {\n-            invocation.setAttachment(MONITOR_FILTER_START_TIME, String.valueOf(System.currentTimeMillis()));\n+            invocation.put(MONITOR_FILTER_START_TIME, System.currentTimeMillis());\n             getConcurrent(invoker, invocation).incrementAndGet(); // count up\n         }\n         return invoker.invoke(invocation); // proceed invocation chain\n@@ -98,15 +98,15 @@ private AtomicInteger getConcurrent(Invoker<?> invoker, Invocation invocation) {\n     @Override\n     public void onMessage(Result result, Invoker<?> invoker, Invocation invocation) {\n         if (invoker.getUrl().hasParameter(MONITOR_KEY)) {\n-            collect(invoker, invocation, result, RpcContext.getContext().getRemoteHost(), Long.valueOf((String) invocation.getAttachment(MONITOR_FILTER_START_TIME)), false);\n+            collect(invoker, invocation, result, RpcContext.getContext().getRemoteHost(), (long) invocation.get(MONITOR_FILTER_START_TIME), false);\n             getConcurrent(invoker, invocation).decrementAndGet(); // count down\n         }\n     }\n     @Override\n     public void onError(Throwable t, Invoker<?> invoker, Invocation invocation) {\n         if (invoker.getUrl().hasParameter(MONITOR_KEY)) {\n-            collect(invoker, invocation, null, RpcContext.getContext().getRemoteHost(), Long.valueOf((String) invocation.getAttachment(MONITOR_FILTER_START_TIME)), true);\n+            collect(invoker, invocation, null, RpcContext.getContext().getRemoteHost(), (long) invocation.get(MONITOR_FILTER_START_TIME), true);\n             getConcurrent(invoker, invocation).decrementAndGet(); // count down\n         }\n     }",
    "output": "Fix monitor filter: consumer side elapsed time is negative"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -356,7 +356,7 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n                         if (argument.getType() != null && argument.getType().length() > 0) {\n                             Method[] methods = interfaceClass.getMethods();\n                             // visit all methods\n-                            if (methods != null && methods.length > 0) {\n+                            if (methods.length > 0) {\n                                 for (int i = 0; i < methods.length; i++) {\n                                     String methodName = methods[i].getName();\n                                     // target the method, and get its signature\n@@ -636,7 +636,7 @@ private Integer findConfigedPorts(ProtocolConfig protocolConfig,\n             if (portToBind == null || portToBind == 0) {\n                 portToBind = defaultPort;\n             }\n-            if (portToBind == null || portToBind <= 0) {\n+            if (portToBind <= 0) {\n                 portToBind = getRandomPort(name);\n                 if (portToBind == null || portToBind < 0) {\n                     portToBind = getAvailablePort(defaultPort);",
    "output": "Fix useless null check in ServiceConfig"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscovery.java b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscovery.java\n@@ -110,7 +110,9 @@ private List<String> getRegisteringTags(URL url) {\n     @Override\n     public void destroy() {\n-        notifier.stop();\n+        if (notifier != null) {\n+            notifier.stop();\n+        }\n         notifier = null;\n         notifierExecutor.shutdownNow();\n         ttlScheduler.stop();\ndiff --git a/dubbo-registry/dubbo-registry-consul/src/test/java/org/apache/dubbo/registry/consul/ConsulServiceDiscoveryTest.java b/dubbo-registry/dubbo-registry-consul/src/test/java/org/apache/dubbo/registry/consul/ConsulServiceDiscoveryTest.java\n--- a/dubbo-registry/dubbo-registry-consul/src/test/java/org/apache/dubbo/registry/consul/ConsulServiceDiscoveryTest.java\n+++ b/dubbo-registry/dubbo-registry-consul/src/test/java/org/apache/dubbo/registry/consul/ConsulServiceDiscoveryTest.java\n@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.registry.consul;\n+\n+import com.pszymczyk.consul.ConsulProcess;\n+import com.pszymczyk.consul.ConsulStarterBuilder;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.registry.client.DefaultServiceInstance;\n+import org.apache.dubbo.registry.client.ServiceInstance;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.String.valueOf;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConsulServiceDiscoveryTest {\n+\n+    private static ConsulProcess consul;\n+    private URL url;\n+    static ConsulServiceDiscovery consulServiceDiscovery;\n+    private static final String SERVICE_NAME = \"A\";\n+    private static final String LOCALHOST = \"127.0.0.1\";\n+\n+    @BeforeEach\n+    public void init() throws Exception {\n+        this.consul = ConsulStarterBuilder.consulStarter()\n+                .build()\n+                .start();\n+        url = URL.valueOf(\"consul://localhost:\" + consul.getHttpPort());\n+        consulServiceDiscovery = new ConsulServiceDiscovery();\n+        Assertions.assertNull(consulServiceDiscovery.getServices());\n+        consulServiceDiscovery.initialize(url);\n+    }\n+\n+    @AfterEach\n+    public void close() {\n+        consulServiceDiscovery.destroy();\n+        consul.close();\n+    }\n+\n+    @Test\n+    public void testRegistration() throws InterruptedException{\n+        DefaultServiceInstance serviceInstance = createServiceInstance(SERVICE_NAME, LOCALHOST, 8012);\n+        consulServiceDiscovery.register(serviceInstance);\n+        Thread.sleep(5000);\n+\n+        List<ServiceInstance> serviceInstances = consulServiceDiscovery.getInstances(SERVICE_NAME);\n+        assertEquals(serviceInstances.size(), 1);\n+        assertEquals(serviceInstances.get(0).getId(), Integer.toHexString(serviceInstance.hashCode()));\n+        assertEquals(serviceInstances.get(0).getHost(), serviceInstance.getHost());\n+        assertEquals(serviceInstances.get(0).getServiceName(), serviceInstance.getServiceName());\n+        assertEquals(serviceInstances.get(0).getPort(), serviceInstance.getPort());\n+\n+        consulServiceDiscovery.unregister(serviceInstance);\n+        Thread.sleep(5000);\n+        serviceInstances = consulServiceDiscovery.getInstances(SERVICE_NAME);\n+        System.out.println(serviceInstances.size());\n+        assertTrue(serviceInstances.isEmpty());\n+    }\n+\n+    private DefaultServiceInstance createServiceInstance(String serviceName, String host, int port) {\n+        return new DefaultServiceInstance(host + \":\" + port, serviceName, host, port);\n+    }\n+\n+    @Test\n+    public void testGetInstances() throws Exception {\n+        String serviceName = \"ConsulTest77Service\";\n+        assertTrue(consulServiceDiscovery.getInstances(serviceName).isEmpty());\n+        consulServiceDiscovery.register(new DefaultServiceInstance(valueOf(System.nanoTime()), serviceName, \"127.0.0.1\", 8080));\n+        consulServiceDiscovery.register(new DefaultServiceInstance(valueOf(System.nanoTime()), serviceName, \"127.0.0.1\", 9809));\n+        Thread.sleep(5000);\n+        Assertions.assertFalse(consulServiceDiscovery.getInstances(serviceName).isEmpty());\n+        List<String> r = convertToIpPort(consulServiceDiscovery.getInstances(serviceName));\n+        assertTrue(r.contains(\"127.0.0.1:8080\"));\n+        assertTrue(r.contains(\"127.0.0.1:9809\"));\n+    }\n+\n+    private List<String> convertToIpPort(List<ServiceInstance> serviceInstances) {\n+        List<String> result = new ArrayList<>();\n+        for (ServiceInstance serviceInstance : serviceInstances) {\n+            result.add(serviceInstance.getHost() + \":\" + serviceInstance.getPort());\n+        }\n+        return result;\n+    }\n+}\n\\ No newline at end of file",
    "output": "Add consul service discovery test"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -168,9 +168,7 @@ public interface CommonConstants {\n     String REVISION_KEY = \"revision\";\n-    String METADATA_REVISION = \"metadata.revision\";\n-\n-    String METADATA_KEY = \"metadata\";\n+    String METADATA_KEY = \"metadata-type\";\n     String DEFAULT_METADATA_STORAGE_TYPE = \"local\";\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n@@ -36,6 +36,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.DUMP_DIRECTORY;\n import static org.apache.dubbo.common.constants.CommonConstants.HOST_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.METADATA_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SHUTDOWN_WAIT_KEY;\n import static org.apache.dubbo.common.constants.QosConstants.ACCEPT_FOREIGN_IP;\n import static org.apache.dubbo.common.constants.QosConstants.QOS_ENABLE;\n@@ -419,6 +420,7 @@ public boolean isValid() {\n         return !StringUtils.isEmpty(name);\n     }\n+    @Parameter(key = METADATA_KEY)\n     public String getMetadataType() {\n         return metadataType;\n     }",
    "output": "Fix specifying metadata type cannot work"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java\n@@ -111,15 +111,12 @@ public boolean shouldInit() {\n         return shouldInit;\n     }\n-    public void checkDefault() {\n-        if (consumer != null) {\n-            return;\n+    public void checkDefault() throws IllegalStateException {\n+        if (consumer == null) {\n+            consumer = ApplicationModel.getConfigManager()\n+                    .getDefaultConsumer()\n+                    .orElse(new ConsumerConfig());\n         }\n-        setConsumer(ApplicationModel.getConfigManager().getDefaultConsumer().orElseGet(() -> {\n-            ConsumerConfig consumerConfig = new ConsumerConfig();\n-            consumerConfig.refresh();\n-            return consumerConfig;\n-        }));\n     }\n     public Class<?> getActualInterface() {\n@@ -271,6 +268,8 @@ protected void computeValidRegistryIds() {\n     @Parameter(excluded = true)\n     public String getUniqueServiceName() {\n+        String group = StringUtils.isEmpty(this.group) ? consumer.getGroup() : this.group;\n+        String version = StringUtils.isEmpty(this.version) ? consumer.getVersion() : this.version;\n         return URL.buildKey(interfaceName, group, version);\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java\n@@ -197,23 +197,12 @@ protected Class getServiceClass(T ref) {\n         return ref.getClass();\n     }\n-    public void checkDefault() {\n-        createProviderIfAbsent();\n-    }\n-\n-    private void createProviderIfAbsent() {\n-        if (provider != null) {\n-            return;\n+    public void checkDefault() throws IllegalStateException {\n+        if (provider == null) {\n+            provider = ApplicationModel.getConfigManager()\n+                    .getDefaultProvider()\n+                    .orElse(new ProviderConfig());\n         }\n-        setProvider(\n-                ApplicationModel.getConfigManager()\n-                        .getDefaultProvider()\n-                        .orElseGet(() -> {\n-                            ProviderConfig providerConfig = new ProviderConfig();\n-                            providerConfig.refresh();\n-                            return providerConfig;\n-                        })\n-        );\n     }\n     public void checkProtocol() {\n@@ -248,8 +237,10 @@ private void convertProtocolIdsToProtocols() {\n                 if (protocolConfigs.isEmpty()) {\n                     protocolConfigs = new ArrayList<>(1);\n                     ProtocolConfig protocolConfig = new ProtocolConfig();\n+                    protocolConfig.setDefault(true);\n                     protocolConfig.refresh();\n                     protocolConfigs.add(protocolConfig);\n+                    ApplicationModel.getConfigManager().addProtocol(protocolConfig);\n                 }\n                 setProtocols(protocolConfigs);\n             }\n@@ -411,6 +402,8 @@ public String getPrefix() {\n     @Parameter(excluded = true)\n     public String getUniqueServiceName() {\n+        String group = StringUtils.isEmpty(this.group) ? provider.getGroup() : this.group;\n+        String version = StringUtils.isEmpty(this.version) ? provider.getVersion() : this.version;\n         return URL.buildKey(interfaceName, group, version);\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n@@ -539,6 +539,34 @@ private void checkGlobalConfigs() {\n         for (MetadataReportConfig metadataReportConfig : metadatas) {\n             ConfigValidationUtils.validateMetadataConfig(metadataReportConfig);\n         }\n+\n+        // check Provider\n+        Collection<ProviderConfig> providers = configManager.getProviders();\n+        if (CollectionUtils.isEmpty(providers)) {\n+            configManager.getDefaultProvider().orElseGet(() -> {\n+                ProviderConfig providerConfig = new ProviderConfig();\n+                configManager.addProvider(providerConfig);\n+                providerConfig.refresh();\n+                return providerConfig;\n+            });\n+        }\n+        for (ProviderConfig providerConfig : providers) {\n+            ConfigValidationUtils.validateProviderConfig(providerConfig);\n+        }\n+        // check Consumer\n+        Collection<ConsumerConfig> consumers = configManager.getConsumers();\n+        if (CollectionUtils.isEmpty(consumers)) {\n+            configManager.getDefaultConsumer().orElseGet(() -> {\n+                ConsumerConfig consumerConfig = new ConsumerConfig();\n+                configManager.addConsumer(consumerConfig);\n+                consumerConfig.refresh();\n+                return consumerConfig;\n+            });\n+        }\n+        for (ConsumerConfig consumerConfig : consumers) {\n+            ConfigValidationUtils.validateConsumerConfig(consumerConfig);\n+        }\n+\n         // check Monitor\n         ConfigValidationUtils.validateMonitorConfig(getMonitor());\n         // check Metrics",
    "output": "Fix Provider and Consumer default config do not work * fixes Provider and Consumer default config do not work * create new instance if there isn't one"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java\n@@ -93,13 +93,14 @@ protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation\n         WeightedRoundRobin selectedWRR = null;\n         for (Invoker<T> invoker : invokers) {\n             String identifyString = invoker.getUrl().toIdentityString();\n-            WeightedRoundRobin weightedRoundRobin = map.get(identifyString);\n             int weight = getWeight(invoker, invocation);\n+            WeightedRoundRobin weightedRoundRobin = map.get(identifyString);\n             if (weightedRoundRobin == null) {\n                 weightedRoundRobin = new WeightedRoundRobin();\n                 weightedRoundRobin.setWeight(weight);\n                 map.putIfAbsent(identifyString, weightedRoundRobin);\n+                weightedRoundRobin = map.get(identifyString);\n             }\n             if (weight != weightedRoundRobin.getWeight()) {\n                 //weight changed",
    "output": "Fix get weightedRoundRobin from map after putIfAbsent"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -412,6 +412,14 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n                 map.put(METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), \",\"));\n             }\n         }\n+\n+        /**\n+         * Here the token value configured by the provider is used to assign the value to ServiceConfig#token\n+         */\n+        if(ConfigUtils.isEmpty(token) && provider != null) {\n+            token = provider.getToken();\n+        }\n+\n         if (!ConfigUtils.isEmpty(token)) {\n             if (ConfigUtils.isDefault(token)) {\n                 map.put(TOKEN_KEY, UUID.randomUUID().toString());",
    "output": "Fix a bug where the provider did not correctly inject the token's UUID into the registry when the token was set to true; added the missing dubbo-remoting-etcd3 and dubbo-registry-eureka modules in dubbo-all / pom.xml"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ProtocolConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n@@ -59,6 +59,11 @@ public class ProtocolConfig extends AbstractConfig {\n      */\n     private String threadpool;\n+    /**\n+     * Thread pool name\n+     */\n+    private String threadname;\n+\n     /**\n      * Thread pool core thread size\n      */\n@@ -263,6 +268,14 @@ public void setThreadpool(String threadpool) {\n         this.threadpool = threadpool;\n     }\n+    public String getThreadname() {\n+        return threadname;\n+    }\n+\n+    public void setThreadname(String threadname) {\n+        this.threadname = threadname;\n+    }\n+\n     public Integer getCorethreads() {\n         return corethreads;\n     }\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/ProviderConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/ProviderConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/ProviderConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/ProviderConfig.java\n@@ -54,6 +54,11 @@ public class ProviderConfig extends AbstractServiceConfig {\n      */\n     private String threadpool;\n+    /**\n+     * Thread pool name\n+     */\n+    private String threadname;\n+\n     /**\n      * Thread pool size (fixed size)\n      */\n@@ -211,6 +216,14 @@ public void setThreadpool(String threadpool) {\n         this.threadpool = threadpool;\n     }\n+    public String getThreadname() {\n+        return threadname;\n+    }\n+\n+    public void setThreadname(String threadname) {\n+        this.threadname = threadname;\n+    }\n+\n     public Integer getThreads() {\n         return threads;\n     }",
    "output": "Make org.apache.dubbo.common.constants.CommonConstants.THREAD_NAME_KEY work"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java b/dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java\n--- a/dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java\n+++ b/dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java\n@@ -260,7 +260,7 @@ public boolean publishConfig(String key, String group, String content) {\n         boolean published = false;\n         String resolvedGroup = resolveGroup(group);\n         try {\n-            String value = configService.getConfig(key, resolvedGroup, -1L);\n+            String value = configService.getConfig(key, resolvedGroup, DEFAULT_TIMEOUT);\n             if (StringUtils.isNotEmpty(value)) {\n                 content = value + \",\" + content;\n             }\ndiff --git a/dubbo-configcenter/dubbo-configcenter-nacos/src/test/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfigurationTest.java b/dubbo-configcenter/dubbo-configcenter-nacos/src/test/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfigurationTest.java\n--- a/dubbo-configcenter/dubbo-configcenter-nacos/src/test/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfigurationTest.java\n+++ b/dubbo-configcenter/dubbo-configcenter-nacos/src/test/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfigurationTest.java\n@@ -36,6 +36,9 @@\n import java.util.SortedSet;\n import java.util.concurrent.CountDownLatch;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n /**\n  * Unit test for nacos config center support\n@@ -140,6 +143,16 @@ public static void setUp() {\n         }\n     }\n+    @Test\n+    public void testPublishConfig() {\n+        String key = \"user-service\";\n+        String group = \"org.apache.dubbo.service.UserService\";\n+        String content = \"test\";\n+\n+        assertTrue(config.publishConfig(key, group, content));\n+        assertEquals(\"test\", config.getProperties(key, group));\n+    }\n+\n     @AfterAll\n     public static void tearDown() {",
    "output": "Fix timeout error when publish config to nacos * Fix timeout bug when publish config to nacos * Add test case for publishConfig info"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java b/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java\n@@ -235,7 +235,7 @@ public List<T> getActivateExtension(URL url, String key, String group) {\n      * @see org.apache.dubbo.common.extension.Activate\n      */\n     public List<T> getActivateExtension(URL url, String[] values, String group) {\n-        List<T> exts = new ArrayList<>();\n+        List<T> activateExtensions = new ArrayList<>();\n         List<String> names = values == null ? new ArrayList<>(0) : Arrays.asList(values);\n         if (!names.contains(REMOVE_VALUE_PREFIX + DEFAULT_KEY)) {\n             getExtensionClasses();\n@@ -258,30 +258,30 @@ public List<T> getActivateExtension(URL url, String[] values, String group) {\n                         && !names.contains(name)\n                         && !names.contains(REMOVE_VALUE_PREFIX + name)\n                         && isActive(activateValue, url)) {\n-                    exts.add(getExtension(name));\n+                    activateExtensions.add(getExtension(name));\n                 }\n             }\n-            exts.sort(ActivateComparator.COMPARATOR);\n+            activateExtensions.sort(ActivateComparator.COMPARATOR);\n         }\n-        List<T> usrs = new ArrayList<>();\n+        List<T> loadedExtensions = new ArrayList<>();\n         for (int i = 0; i < names.size(); i++) {\n             String name = names.get(i);\n             if (!name.startsWith(REMOVE_VALUE_PREFIX)\n                     && !names.contains(REMOVE_VALUE_PREFIX + name)) {\n                 if (DEFAULT_KEY.equals(name)) {\n-                    if (!usrs.isEmpty()) {\n-                        exts.addAll(0, usrs);\n-                        usrs.clear();\n+                    if (!loadedExtensions.isEmpty()) {\n+                        activateExtensions.addAll(0, loadedExtensions);\n+                        loadedExtensions.clear();\n                     }\n                 } else {\n-                    usrs.add(getExtension(name));\n+                    loadedExtensions.add(getExtension(name));\n                 }\n             }\n         }\n-        if (!usrs.isEmpty()) {\n-            exts.addAll(usrs);\n+        if (!loadedExtensions.isEmpty()) {\n+            activateExtensions.addAll(loadedExtensions);\n         }\n-        return exts;\n+        return activateExtensions;\n     }\n     private boolean isMatchGroup(String group, String[] groups) {",
    "output": "Use more meaningful variable names"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Constants.java b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Constants.java\n--- a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Constants.java\n+++ b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Constants.java\n@@ -30,4 +30,7 @@ public interface Constants {\n     byte AVRO_SERIALIZATION_ID = 11;\n     byte GSON_SERIALIZATION_ID = 16;\n     byte PROTOBUF_JSON_SERIALIZATION_ID = 21;\n+\n+    byte PROTOBUF_SERIALIZATION_ID = 22;\n+    byte KRYO_SERIALIZATION2_ID = 25;\n }\ndiff --git a/dubbo-serialization/dubbo-serialization-kryo/src/main/java/org/apache/dubbo/common/serialize/kryo/optimized/KryoSerialization2.java b/dubbo-serialization/dubbo-serialization-kryo/src/main/java/org/apache/dubbo/common/serialize/kryo/optimized/KryoSerialization2.java\n--- a/dubbo-serialization/dubbo-serialization-kryo/src/main/java/org/apache/dubbo/common/serialize/kryo/optimized/KryoSerialization2.java\n+++ b/dubbo-serialization/dubbo-serialization-kryo/src/main/java/org/apache/dubbo/common/serialize/kryo/optimized/KryoSerialization2.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.common.serialize.kryo.optimized;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.serialize.Constants;\n import org.apache.dubbo.common.serialize.ObjectInput;\n import org.apache.dubbo.common.serialize.ObjectOutput;\n import org.apache.dubbo.common.serialize.Serialization;\n@@ -25,8 +26,6 @@\n import java.io.InputStream;\n import java.io.OutputStream;\n-import static org.apache.dubbo.common.serialize.Constants.KRYO_SERIALIZATION_ID;\n-\n /**\n  * TODO for now kryo serialization doesn't deny classes that don't implement the serializable interface\n  *\n@@ -38,7 +37,7 @@ public class KryoSerialization2 implements Serialization {\n     @Override\n     public byte getContentTypeId() {\n-        return KRYO_SERIALIZATION_ID;\n+        return Constants.KRYO_SERIALIZATION2_ID;\n     }\n     @Override\ndiff --git a/dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufSerialization.java b/dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufSerialization.java\n--- a/dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufSerialization.java\n+++ b/dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufSerialization.java\n@@ -17,15 +17,14 @@\n package org.apache.dubbo.common.serialize.protobuf.support;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.serialize.Constants;\n import org.apache.dubbo.common.serialize.ObjectInput;\n import org.apache.dubbo.common.serialize.ObjectOutput;\n import org.apache.dubbo.common.serialize.Serialization;\n import java.io.InputStream;\n import java.io.OutputStream;\n-import static org.apache.dubbo.common.serialize.Constants.PROTOBUF_JSON_SERIALIZATION_ID;\n-\n /**\n  * <p>\n  * Currently, the Dubbo protocol / framework data, such as attachments, event data, etc.,\n@@ -44,7 +43,7 @@ public class GenericProtobufSerialization implements Serialization {\n     @Override\n     public byte getContentTypeId() {\n-        return PROTOBUF_JSON_SERIALIZATION_ID;\n+        return Constants.PROTOBUF_SERIALIZATION_ID;\n     }\n     @Override",
    "output": "Remove reuse ID"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/IOUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/IOUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/IOUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/IOUtils.java\n@@ -84,12 +84,9 @@ public static long write (final InputStream input, final OutputStream output, fi\n      * @throws IOException\n      */\n     public static String read(Reader reader) throws IOException {\n-        StringWriter writer = new StringWriter();\n-        try {\n+        try (StringWriter writer = new StringWriter()) {\n             write(reader, writer);\n             return writer.getBuffer().toString();\n-        } finally {\n-            writer.close();\n         }\n     }\n@@ -101,11 +98,8 @@ public static String read(Reader reader) throws IOException {\n      * @throws IOException\n      */\n     public static long write(Writer writer, String string) throws IOException {\n-        Reader reader = new StringReader(string);\n-        try {\n+        try (Reader reader = new StringReader(string)) {\n             return write(reader, writer);\n-        } finally {\n-            reader.close();\n         }\n     }\n@@ -165,15 +159,12 @@ public static String[] readLines(File file) throws IOException {\n      */\n     public static String[] readLines(InputStream is) throws IOException {\n         List<String> lines = new ArrayList<String>();\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n-        try {\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {\n             String line;\n             while ((line = reader.readLine()) != null) {\n                 lines.add(line);\n             }\n             return lines.toArray(new String[0]);\n-        } finally {\n-            reader.close();\n         }\n     }\n@@ -185,14 +176,11 @@ public static String[] readLines(InputStream is) throws IOException {\n      * @throws IOException\n      */\n     public static void writeLines(OutputStream os, String[] lines) throws IOException {\n-        PrintWriter writer = new PrintWriter(new OutputStreamWriter(os));\n-        try {\n+        try (PrintWriter writer = new PrintWriter(new OutputStreamWriter(os))) {\n             for (String line : lines) {\n                 writer.println(line);\n             }\n             writer.flush();\n-        } finally {\n-            writer.close();\n         }\n     }",
    "output": "Change \"try\" to \"try resource\" in IOUtils.java"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/support/SerializableClassRegistry.java b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/support/SerializableClassRegistry.java\n--- a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/support/SerializableClassRegistry.java\n+++ b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/support/SerializableClassRegistry.java\n@@ -26,14 +26,14 @@\n public abstract class SerializableClassRegistry {\n-    private static final Map<Class, Object> REGISTRATIONS = new LinkedHashMap<>();\n+    private static final Map<Class<?>, Object> REGISTRATIONS = new LinkedHashMap<>();\n     /**\n      * only supposed to be called at startup time\n      *\n      * @param clazz object type\n      */\n-    public static void registerClass(Class clazz) {\n+    public static void registerClass(Class<?> clazz) {\n         registerClass(clazz, null);\n     }\n@@ -43,7 +43,7 @@ public static void registerClass(Class clazz) {\n      * @param clazz object type\n      * @param serializer object serializer\n      */\n-    public static void registerClass(Class clazz, Object serializer) {\n+    public static void registerClass(Class<?> clazz, Object serializer) {\n         if (clazz == null) {\n             throw new IllegalArgumentException(\"Class registered to kryo cannot be null!\");\n         }\n@@ -55,7 +55,7 @@ public static void registerClass(Class clazz, Object serializer) {\n      *\n      * @return class serializer\n      * */\n-    public static Map<Class, Object> getRegisteredClasses() {\n+    public static Map<Class<?>, Object> getRegisteredClasses() {\n         return REGISTRATIONS;\n     }\n }\ndiff --git a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/support/SerializationOptimizer.java b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/support/SerializationOptimizer.java\n--- a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/support/SerializationOptimizer.java\n+++ b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/support/SerializationOptimizer.java\n@@ -28,5 +28,5 @@ public interface SerializationOptimizer {\n      *\n      * @return serializable classes\n      * */\n-    Collection<Class> getSerializableClasses();\n+    Collection<Class<?>> getSerializableClasses();\n }\ndiff --git a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/support/SerializableClassRegistryTest.java b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/support/SerializableClassRegistryTest.java\n--- a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/support/SerializableClassRegistryTest.java\n+++ b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/support/SerializableClassRegistryTest.java\n@@ -32,7 +32,7 @@ public void testAddClasses() {\n         SerializableClassRegistry.registerClass(SerializablePerson.class);\n         SerializableClassRegistry.registerClass(Phone.class);\n-        Map<Class, Object> registeredClasses = SerializableClassRegistry.getRegisteredClasses();\n+        Map<Class<?>, Object> registeredClasses = SerializableClassRegistry.getRegisteredClasses();\n         assertThat(registeredClasses.size(), equalTo(2));\n     }\n }\n\\ No newline at end of file",
    "output": "Fix generic specification tips for unknown class"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/support/ProtocolUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/support/ProtocolUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/support/ProtocolUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/support/ProtocolUtils.java\n@@ -54,8 +54,7 @@ public static String serviceKey(int port, String serviceName, String serviceVers\n     }\n     public static boolean isGeneric(String generic) {\n-        return generic != null\n-                && !\"\".equals(generic)\n+        return StringUtils.isNotEmpty(generic)\n                 && (GENERIC_SERIALIZATION_DEFAULT.equalsIgnoreCase(generic)  /* Normal generalization cal */\n                 || GENERIC_SERIALIZATION_NATIVE_JAVA.equalsIgnoreCase(generic) /* Streaming generalization call supporting jdk serialization */\n                 || GENERIC_SERIALIZATION_BEAN.equalsIgnoreCase(generic)",
    "output": "Use stringutils to remove duplicate code in ProtocolUtils.java"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/CacheableRouterFactory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/CacheableRouterFactory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/CacheableRouterFactory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/CacheableRouterFactory.java\n@@ -30,8 +30,7 @@ public abstract class CacheableRouterFactory implements RouterFactory {\n     @Override\n     public Router getRouter(URL url) {\n-        routerMap.computeIfAbsent(url.getServiceKey(), k -> createRouter(url));\n-        return routerMap.get(url.getServiceKey());\n+        return routerMap.computeIfAbsent(url.getServiceKey(), k -> createRouter(url));\n     }\n     protected abstract Router createRouter(URL url);",
    "output": "Fix duplicate code in CacheableRouterFactory"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rmi/src/main/java/org/apache/dubbo/rpc/protocol/rmi/RmiProtocol.java b/dubbo-rpc/dubbo-rpc-rmi/src/main/java/org/apache/dubbo/rpc/protocol/rmi/RmiProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-rmi/src/main/java/org/apache/dubbo/rpc/protocol/rmi/RmiProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-rmi/src/main/java/org/apache/dubbo/rpc/protocol/rmi/RmiProtocol.java\n@@ -86,17 +86,17 @@ protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcExc\n           3. if the provider version is lower than v2.6.3, does not use customized RemoteInvocation.\n          */\n         if (isRelease270OrHigher(url.getParameter(RELEASE_KEY))) {\n-            rmiProxyFactoryBean.setRemoteInvocationFactory((methodInvocation) -> {\n+            rmiProxyFactoryBean.setRemoteInvocationFactory(methodInvocation -> {\n                 RemoteInvocation invocation = new RmiRemoteInvocation(methodInvocation);\n-                if (invocation != null && isGeneric) {\n+                if (isGeneric) {\n                     invocation.addAttribute(GENERIC_KEY, generic);\n                 }\n                 return invocation;\n             });\n         } else if (isRelease263OrHigher(url.getParameter(DUBBO_VERSION_KEY))) {\n-            rmiProxyFactoryBean.setRemoteInvocationFactory((methodInvocation) -> {\n+            rmiProxyFactoryBean.setRemoteInvocationFactory(methodInvocation -> {\n                 RemoteInvocation invocation = new com.alibaba.dubbo.rpc.protocol.rmi.RmiRemoteInvocation(methodInvocation);\n-                if (invocation != null && isGeneric) {\n+                if (isGeneric) {\n                     invocation.addAttribute(GENERIC_KEY, generic);\n                 }\n                 return invocation;",
    "output": "Fix useless null check in RmiProtocol"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-etcd3/src/main/java/org/apache/dubbo/registry/etcd/EtcdServiceDiscovery.java b/dubbo-registry/dubbo-registry-etcd3/src/main/java/org/apache/dubbo/registry/etcd/EtcdServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-etcd3/src/main/java/org/apache/dubbo/registry/etcd/EtcdServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-etcd3/src/main/java/org/apache/dubbo/registry/etcd/EtcdServiceDiscovery.java\n@@ -24,7 +24,6 @@\n import org.apache.dubbo.common.utils.ConcurrentHashSet;\n import org.apache.dubbo.event.EventDispatcher;\n import org.apache.dubbo.event.EventListener;\n-import org.apache.dubbo.registry.NotifyListener;\n import org.apache.dubbo.registry.client.DefaultServiceInstance;\n import org.apache.dubbo.registry.client.ServiceDiscovery;\n import org.apache.dubbo.registry.client.ServiceInstance;\n@@ -47,7 +46,6 @@\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n /**\n  * 2019-07-08\n@@ -61,8 +59,6 @@ public class EtcdServiceDiscovery implements ServiceDiscovery, EventListener<Ser\n     private final Set<String> services = new ConcurrentHashSet<>();\n     private final Map<String, ChildListener> childListenerMap = new ConcurrentHashMap<>();\n-    private final ConcurrentMap<URL, ConcurrentMap<NotifyListener, ChildListener>> etcdListeners = new ConcurrentHashMap<>();\n-\n     EtcdClient etcdClient;\n     EventDispatcher dispatcher;\n     ServiceInstance serviceInstance;",
    "output": "Remove unused variable in EtcdServiceDiscovery"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n@@ -66,6 +66,8 @@ public void init(Map<String, AsyncMethodInfo> attributes) {\n         if (attributes != null) {\n             this.methodConfigs = attributes;\n         }\n+\n+        initMethodModels();\n     }\n     /**\n@@ -126,9 +128,14 @@ public ConsumerModel(String serviceKey\n         this(serviceKey, proxyObject, serviceModel, referenceConfig);\n         this.serviceMetadata = metadata;\n+    }\n-        for (Method method : metadata.getServiceType().getMethods()) {\n-            methodModels.put(method, new ConsumerMethodModel(method));\n+    public void initMethodModels() {\n+        Class[] interfaceList = serviceMetadata.getTarget().getClass().getInterfaces();\n+        for (Class interfaceClass : interfaceList) {\n+            for (Method method : interfaceClass.getMethods()) {\n+                methodModels.put(method, new ConsumerMethodModel(method));\n+            }\n         }\n     }",
    "output": "Add back missed logic in ConsumerModel during 3.x merge"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java\n@@ -42,6 +42,8 @@ public class ThreadlessExecutor extends AbstractExecutorService {\n     private ExecutorService sharedExecutor;\n+    private boolean finished = false;\n+\n     private volatile boolean waiting = true;\n     private final Object lock = new Object();\n@@ -55,9 +57,23 @@ public boolean isWaiting() {\n     }\n     /**\n-     * Waits until there is a Runnable, then executes it and all queued Runnables after it.\n+     * Waits until there is a task, executes the task and all queued tasks (if there're any). The task is either a normal\n+     * response or a timeout response.\n      */\n     public void waitAndDrain() throws InterruptedException {\n+        /**\n+         * Usually, {@link #waitAndDrain()} will only get called once. It blocks for the response for the first time,\n+         * once the response (the task) reached and being executed waitAndDrain will return, the whole request process\n+         * then finishes. Subsequent calls on {@link #waitAndDrain()} (if there're any) should return immediately.\n+         *\n+         * There's no need to worry that {@link #finished} is not thread-safe. Checking and updating of\n+         * 'finished' only appear in waitAndDrain, since waitAndDrain is binding to one RPC call (one thread), the call\n+         * of it is totally sequential.\n+         */\n+        if (finished) {\n+            return;\n+        }\n+\n         Runnable runnable = queue.take();\n         synchronized (lock) {\n@@ -75,6 +91,8 @@ public void waitAndDrain() throws InterruptedException {\n             }\n             runnable = queue.poll();\n         }\n+        // mark the status of ThreadlessExecutor as finished.\n+        finished = true;\n     }\n     public long waitAndDrain(long timeout, TimeUnit unit) throws InterruptedException, TimeoutException {",
    "output": "Add finish status for ThreadlessExecutor to support being called multiple times"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java\n@@ -618,6 +618,9 @@ private void useRegistryAsConfigCenterIfNecessary() {\n                     cc.setNamespace(registryConfig.getGroup());\n                     cc.setUsername(registryConfig.getUsername());\n                     cc.setPassword(registryConfig.getPassword());\n+                    if (registryConfig.getTimeout() != null) {\n+                        cc.setTimeout(registryConfig.getTimeout().longValue());\n+                    }\n                     cc.setHighestPriority(false);\n                     configManager.addConfigCenter(cc);\n                 });",
    "output": "Fix configcenter use registry timeout value"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.config.ConfigurationUtils;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.logger.support.FailsafeLogger;\n import java.io.IOException;\n import java.net.Inet4Address;\n@@ -45,7 +46,14 @@\n  * IP and Port Helper for RPC\n  */\n public class NetUtils {\n-    private static final Logger logger = LoggerFactory.getLogger(NetUtils.class);\n+    private static Logger logger;\n+\n+    {\n+        logger = LoggerFactory.getLogger(NetUtils.class);\n+        if (logger instanceof FailsafeLogger) {\n+            logger = ((FailsafeLogger) logger).getLogger();\n+        }\n+    }\n     // returned port range is [30000, 39999]\n     private static final int RND_PORT_START = 30000;\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -511,6 +511,14 @@ public String toString() {\n                     if (MethodUtils.isGetter(method)) {\n                         String name = method.getName();\n                         String key = calculateAttributeFromGetter(name);\n+\n+                        try {\n+                            getClass().getDeclaredField(key);\n+                        } catch (NoSuchFieldException e) {\n+                            // ignore\n+                            continue;\n+                        }\n+\n                         Object value = method.invoke(this);\n                         if (value != null) {\n                             buf.append(\" \");",
    "output": "Fix netutils log endless recursive *, endless recursive call when NetUtils method fails. *"
  },
  {
    "input": "diff --git a/dubbo-filter/dubbo-filter-validation/src/main/java/org/apache/dubbo/validation/support/jvalidation/JValidator.java b/dubbo-filter/dubbo-filter-validation/src/main/java/org/apache/dubbo/validation/support/jvalidation/JValidator.java\n--- a/dubbo-filter/dubbo-filter-validation/src/main/java/org/apache/dubbo/validation/support/jvalidation/JValidator.java\n+++ b/dubbo-filter/dubbo-filter-validation/src/main/java/org/apache/dubbo/validation/support/jvalidation/JValidator.java\n@@ -60,7 +60,6 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Date;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n@@ -97,18 +96,6 @@ public JValidator(URL url) {\n         this.methodClassMap = new ConcurrentHashMap<>();\n     }\n-    private static boolean isPrimitives(Class<?> cls) {\n-        if (cls.isArray()) {\n-            return isPrimitive(cls.getComponentType());\n-        }\n-        return isPrimitive(cls);\n-    }\n-\n-    private static boolean isPrimitive(Class<?> cls) {\n-        return cls.isPrimitive() || cls == String.class || cls == Boolean.class || cls == Character.class\n-                || Number.class.isAssignableFrom(cls) || Date.class.isAssignableFrom(cls);\n-    }\n-\n     private static Object getMethodParameterBean(Class<?> clazz, Method method, Object[] args) {\n         if (!hasConstraintParameter(method)) {\n             return null;\n@@ -320,7 +307,7 @@ private Class methodClass(String methodName) {\n     }\n     private void validate(Set<ConstraintViolation<?>> violations, Object arg, Class<?>... groups) {\n-        if (arg != null && !isPrimitives(arg.getClass())) {\n+        if (arg != null && !ReflectUtils.isPrimitives(arg.getClass())) {\n             if (arg instanceof Object[]) {\n                 for (Object item : (Object[]) arg) {\n                     validate(violations, item, groups);",
    "output": "Use ReflectUtils#isPrimitives instead of JValidator#isPrimitives"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java\n@@ -635,23 +635,38 @@ public static String translate(String src, String from, String to) {\n      * @return string array.\n      */\n     public static String[] split(String str, char ch) {\n-        List<String> list = null;\n-        char c;\n+        if (isEmpty(str)) {\n+            return EMPTY_STRING_ARRAY;\n+        }\n+        return splitToList0(str, ch).toArray(EMPTY_STRING_ARRAY);\n+    }\n+\n+    private static List<String> splitToList0(String str, char ch) {\n+        List<String> result = new ArrayList<>();\n         int ix = 0, len = str.length();\n         for (int i = 0; i < len; i++) {\n-            c = str.charAt(i);\n-            if (c == ch) {\n-                if (list == null) {\n-                    list = new ArrayList<String>();\n-                }\n-                list.add(str.substring(ix, i));\n+            if (str.charAt(i) == ch) {\n+                result.add(str.substring(ix, i));\n                 ix = i + 1;\n             }\n         }\n-        if (ix > 0) {\n-            list.add(str.substring(ix));\n+\n+        if (ix >= 0) {\n+            result.add(str.substring(ix));\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Splits String around matches of the given character.\n+     * <p>\n+     * Note: Compare with {@link StringUtils#split(String, char)}, this method reduce memory copy.\n+     */\n+    public static List<String> splitToList(String str, char ch) {\n+        if (isEmpty(str)) {\n+            return Collections.emptyList();\n         }\n-        return list == null ? EMPTY_STRING_ARRAY : (String[]) list.toArray(EMPTY_STRING_ARRAY);\n+        return splitToList0(str, ch);\n     }\n     /**\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/StringUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/StringUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/StringUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/StringUtilsTest.java\n@@ -18,11 +18,7 @@\n import org.junit.jupiter.api.Test;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n@@ -33,9 +29,8 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.isEmptyOrNullString;\n import static org.hamcrest.Matchers.nullValue;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n public class StringUtilsTest {\n     @Test\n@@ -220,8 +215,33 @@ public void testJoin() throws Exception {\n     @Test\n     public void testSplit() throws Exception {\n-        String s = \"d,1,2,4\";\n-        assertEquals(StringUtils.split(s, ',').length, 4);\n+        String str = \"d,1,2,4\";\n+\n+        assertEquals(4, StringUtils.split(str, ',').length);\n+        assertArrayEquals(str.split(\",\"), StringUtils.split(str, ','));\n+\n+        assertEquals(1, StringUtils.split(str, 'a').length);\n+        assertArrayEquals(str.split(\"a\"), StringUtils.split(str, 'a'));\n+\n+        assertEquals(0, StringUtils.split(\"\", 'a').length);\n+        assertEquals(0, StringUtils.split(null, 'a').length);\n+\n+        System.out.println(Arrays.toString(StringUtils.split(\"boo:and:foo\", ':')));\n+        System.out.println(Arrays.toString(StringUtils.split(\"boo:and:foo\", 'o')));\n+    }\n+\n+    @Test\n+    public void testSplitToList() throws Exception {\n+        String str = \"d,1,2,4\";\n+\n+        assertEquals(4, StringUtils.splitToList(str, ',').size());\n+        assertEquals(Arrays.asList(str.split(\",\")), StringUtils.splitToList(str, ','));\n+\n+        assertEquals(1, StringUtils.splitToList(str, 'a').size());\n+        assertEquals(Arrays.asList(str.split(\"a\")), StringUtils.splitToList(str, 'a'));\n+\n+        assertEquals(0, StringUtils.splitToList(\"\", 'a').size());\n+        assertEquals(0, StringUtils.splitToList(null, 'a').size());\n     }\n     @Test",
    "output": "Fix StringUtils.split(String, char) not correct for input \"d,1,2,4\", 'a'"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/Server.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/Server.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/Server.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/Server.java\n@@ -90,8 +90,8 @@ public void start() throws Throwable {\n         ServerBootstrap serverBootstrap = new ServerBootstrap();\n         serverBootstrap.group(boss, worker);\n         serverBootstrap.channel(NioServerSocketChannel.class);\n+        serverBootstrap.option(ChannelOption.SO_REUSEADDR, true);\n         serverBootstrap.childOption(ChannelOption.TCP_NODELAY, true);\n-        serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, true);\n         serverBootstrap.childHandler(new ChannelInitializer<Channel>() {\n             @Override\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java\n@@ -98,8 +98,8 @@ protected void doOpen() throws Throwable {\n         bootstrap.group(bossGroup, workerGroup)\n                 .channel(NioServerSocketChannel.class)\n+                .option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)\n                 .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)\n-                .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)\n                 .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                 .childHandler(new ChannelInitializer<NioSocketChannel>() {\n                     @Override",
    "output": "Fix netty server Option.SO_REUSEADDR config"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java\n@@ -133,7 +133,7 @@ protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, Load\n                 method = returnType.getMethod(merger, returnType);\n             } catch (NoSuchMethodException e) {\n                 throw new RpcException(\"Can not merge result because missing method [ \" + merger + \" ] in class [ \" +\n-                        returnType.getClass().getName() + \" ]\");\n+                        returnType.getName() + \" ]\");\n             }\n             if (!Modifier.isPublic(method.getModifiers())) {\n                 method.setAccessible(true);",
    "output": "Fix get the wrong merger type in MergeableClusterInvoker.java"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java\n@@ -262,6 +262,8 @@ public interface CommonConstants {\n     String GENERIC_SERIALIZATION_PROTOBUF = \"protobuf-json\";\n+    String GENERIC_WITH_CLZ_KEY = \"generic.include.class\";\n+\n     /**\n      * The limit of callback service instances for one interface on every client\n      */\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.common.utils;\n+import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n@@ -64,6 +65,7 @@ public class PojoUtils {\n     private static final Logger logger = LoggerFactory.getLogger(PojoUtils.class);\n     private static final ConcurrentMap<String, Method> NAME_METHODS_CACHE = new ConcurrentHashMap<String, Method>();\n     private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Field>> CLASS_FIELD_CACHE = new ConcurrentHashMap<Class<?>, ConcurrentMap<String, Field>>();\n+    private static final boolean GENERIC_WITH_CLZ = Boolean.parseBoolean(ConfigUtils.getProperty(CommonConstants.GENERIC_WITH_CLZ_KEY,\"true\"));\n     public static Object[] generalize(Object[] objs) {\n         Object[] dests = new Object[objs.length];\n@@ -164,7 +166,9 @@ private static Object generalize(Object pojo, Map<Object, Object> history) {\n         }\n         Map<String, Object> map = new HashMap<String, Object>();\n         history.put(pojo, map);\n-        map.put(\"class\", pojo.getClass().getName());\n+        if (GENERIC_WITH_CLZ) {\n+            map.put(\"class\", pojo.getClass().getName());\n+        }\n         for (Method method : pojo.getClass().getMethods()) {\n             if (ReflectUtils.isBeanPropertyReadMethod(method)) {\n                 try {\n@@ -401,7 +405,9 @@ private static Object realize0(Object pojo, Class<?> type, Type genericType, fin\n                     map = (Map<Object, Object>) type.newInstance();\n                     Map<Object, Object> mapPojo = (Map<Object, Object>) pojo;\n                     map.putAll(mapPojo);\n-                    map.remove(\"class\");\n+                    if (GENERIC_WITH_CLZ) {\n+                        map.remove(\"class\");\n+                    }\n                 } catch (Exception e) {\n                     //ignore error\n                     map = (Map<Object, Object>) pojo;",
    "output": "Add switch of generic invocation with class info"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -581,4 +581,31 @@ public boolean equals(Object obj) {\n     public void addIntoConfigManager() {\n         ApplicationModel.getConfigManager().addConfig(this);\n     }\n+\n+    @Override\n+    public int hashCode() {\n+        int hashCode = 1;\n+\n+        Method[] methods = this.getClass().getMethods();\n+        for (Method method : methods) {\n+            if (MethodUtils.isGetter(method)) {\n+                Parameter parameter = method.getAnnotation(Parameter.class);\n+                if (parameter != null && parameter.excluded()) {\n+                    continue;\n+                }\n+                try {\n+                    Object value = method.invoke(this, new Object[]{});\n+                    hashCode = 31 * hashCode + value.hashCode();\n+                } catch (Exception ignored) {\n+                    //ignored\n+                }\n+            }\n+        }\n+\n+        if (hashCode == 0) {\n+            hashCode = 1;\n+        }\n+\n+        return hashCode;\n+    }\n }\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/AbstractChannelBuffer.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/AbstractChannelBuffer.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/AbstractChannelBuffer.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/AbstractChannelBuffer.java\n@@ -314,6 +314,11 @@ public boolean equals(Object o) {\n                 && ChannelBuffers.equals(this, (ChannelBuffer) o);\n     }\n+    @Override\n+    public int hashCode() {\n+        return ChannelBuffers.hasCode(this);\n+    }\n+\n     @Override\n     public int compareTo(ChannelBuffer that) {\n         return ChannelBuffers.compare(this, that);\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBuffers.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBuffers.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBuffers.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/ChannelBuffers.java\n@@ -112,6 +112,24 @@ public static boolean equals(ChannelBuffer bufferA, ChannelBuffer bufferB) {\n         return true;\n     }\n+    public static int hasCode(ChannelBuffer buffer){\n+        final int aLen = buffer.readableBytes();\n+        final int byteCount = aLen & 7;\n+\n+        int hashCode = 1;\n+        int arrayIndex = buffer.readerIndex();\n+\n+        for (int i = byteCount; i > 0; i--) {\n+            hashCode = 31 * hashCode + buffer.getByte(arrayIndex++);\n+        }\n+\n+        if (hashCode == 0) {\n+            hashCode = 1;\n+        }\n+\n+        return hashCode;\n+    }\n+\n     public static int compare(ChannelBuffer bufferA, ChannelBuffer bufferB) {\n         final int aLen = bufferA.readableBytes();\n         final int bLen = bufferB.readableBytes();\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/buffer/HeapChannelBufferTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/buffer/HeapChannelBufferTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/buffer/HeapChannelBufferTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/buffer/HeapChannelBufferTest.java\n@@ -16,7 +16,12 @@\n  */\n package org.apache.dubbo.remoting.buffer;\n+import org.hamcrest.MatcherAssert;\n import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n public class HeapChannelBufferTest extends AbstractChannelBufferTest {\n@@ -33,4 +38,19 @@ protected ChannelBuffer newBuffer(int capacity) {\n     protected ChannelBuffer[] components() {\n         return new ChannelBuffer[]{buffer};\n     }\n+\n+    @Test\n+    void testEqualsAndHashcode() {\n+        HeapChannelBuffer b1 = new HeapChannelBuffer(\"hello-world\".getBytes());\n+        HeapChannelBuffer b2 = new HeapChannelBuffer(\"hello-world\".getBytes());\n+\n+        MatcherAssert.assertThat(b1.equals(b2), is(true));\n+        MatcherAssert.assertThat(b1.hashCode(), is(b2.hashCode()));\n+\n+        b1 = new HeapChannelBuffer(\"hello-world\".getBytes());\n+        b2 = new HeapChannelBuffer(\"hello-worldd\".getBytes());\n+\n+        MatcherAssert.assertThat(b1.equals(b2), is(false));\n+        MatcherAssert.assertThat(b1.hashCode(), not(b2.hashCode()));\n+    }\n }",
    "output": "Make sure that classes that either override equals() or hashCode() also overrides the other"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java\n@@ -55,10 +55,11 @@ public class ConsistentHashLoadBalance extends AbstractLoadBalance {\n     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n         String methodName = RpcUtils.getMethodName(invocation);\n         String key = invokers.get(0).getUrl().getServiceKey() + \".\" + methodName;\n-        int identityHashCode = System.identityHashCode(invokers);\n+        // using the hashcode of list to compute the hash only pay attention to the elements in the list\n+        int invokersHashCode = invokers.hashCode();\n         ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);\n-        if (selector == null || selector.identityHashCode != identityHashCode) {\n-            selectors.put(key, new ConsistentHashSelector<T>(invokers, methodName, identityHashCode));\n+        if (selector == null || selector.identityHashCode != invokersHashCode) {\n+            selectors.put(key, new ConsistentHashSelector<T>(invokers, methodName, invokersHashCode));\n             selector = (ConsistentHashSelector<T>) selectors.get(key);\n         }\n         return selector.select(invocation);\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalanceTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalanceTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalanceTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalanceTest.java\n@@ -16,12 +16,15 @@\n  */\n package org.apache.dubbo.rpc.cluster.loadbalance;\n+import org.apache.dubbo.common.URL;\n import org.apache.dubbo.rpc.Invoker;\n-\n+import org.apache.dubbo.rpc.cluster.LoadBalance;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -51,4 +54,19 @@ public void testConsistentHashLoadBalance() {\n                 hitedInvokers.values().iterator().next().intValue(), \"the number of hited count should be the number of runs\");\n     }\n+    // https://github.com/apache/dubbo/issues/5429\n+    @Test\n+    void testNormalWhenRouterEnabled() {\n+        LoadBalance lb = getLoadBalance(ConsistentHashLoadBalance.NAME);\n+        URL url = invokers.get(0).getUrl();\n+        RouterChain<LoadBalanceBaseTest> routerChain = RouterChain.buildChain(url);\n+        Invoker<LoadBalanceBaseTest> result = lb.select(invokers, url, invocation);\n+\n+        for (int i = 0; i < 100; i++) {\n+            routerChain.setInvokers(invokers);\n+            List<Invoker<LoadBalanceBaseTest>> routeInvokers = routerChain.route(url, invocation);\n+            Invoker<LoadBalanceBaseTest> finalInvoker = lb.select(routeInvokers, url, invocation);\n+            Assertions.assertEquals(result, finalInvoker);\n+        }\n+    }\n }",
    "output": "Fix the bug, consistenthash loadbalance always construct new ConsistentHashSelector #5429"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n@@ -438,16 +438,11 @@ public static void validateProtocolConfig(ProtocolConfig config) {\n             if (DUBBO_PROTOCOL.equals(name)) {\n                 checkMultiExtension(Codec.class, CODEC_KEY, config.getCodec());\n-            }\n-            if (DUBBO_PROTOCOL.equals(name)) {\n                 checkMultiExtension(Serialization.class, SERIALIZATION_KEY, config.getSerialization());\n-            }\n-            if (DUBBO_PROTOCOL.equals(name)) {\n                 checkMultiExtension(Transporter.class, SERVER_KEY, config.getServer());\n-            }\n-            if (DUBBO_PROTOCOL.equals(name)) {\n                 checkMultiExtension(Transporter.class, CLIENT_KEY, config.getClient());\n             }\n+\n             checkMultiExtension(TelnetHandler.class, TELNET, config.getTelnet());\n             checkMultiExtension(StatusChecker.class, \"status\", config.getStatus());\n             checkExtension(Transporter.class, TRANSPORTER_KEY, config.getTransporter());",
    "output": "Remove redundant judgment"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n@@ -234,9 +234,9 @@ public List<URL> getCacheUrls(URL url) {\n         for (Map.Entry<Object, Object> entry : properties.entrySet()) {\n             String key = (String) entry.getKey();\n             String value = (String) entry.getValue();\n-            if (key != null && key.length() > 0 && key.equals(url.getServiceKey())\n+            if (StringUtils.isNotEmpty(key) && key.equals(url.getServiceKey())\n                     && (Character.isLetter(key.charAt(0)) || key.charAt(0) == '_')\n-                    && value != null && value.length() > 0) {\n+                    && StringUtils.isNotEmpty(value)) {\n                 String[] arr = value.trim().split(URL_SPLIT);\n                 List<URL> urls = new ArrayList<>();\n                 for (String u : arr) {\n@@ -252,7 +252,7 @@ public List<URL> getCacheUrls(URL url) {\n     public List<URL> lookup(URL url) {\n         List<URL> result = new ArrayList<>();\n         Map<String, List<URL>> notifiedUrls = getNotified().get(url);\n-        if (notifiedUrls != null && notifiedUrls.size() > 0) {\n+        if (CollectionUtils.isNotEmptyMap(notifiedUrls)) {\n             for (List<URL> urls : notifiedUrls.values()) {\n                 for (URL u : urls) {\n                     if (!EMPTY_PROTOCOL.equals(u.getProtocol())) {",
    "output": "Use xxUtils to simplify code"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n@@ -175,4 +175,9 @@ public List<URL> lookup(URL url) {\n         }\n     };\n+    // for unit test\n+    public static void clearRegistryNotDestroy() {\n+        REGISTRIES.clear();\n+    }\n+\n }\ndiff --git a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryStatusCheckerTest.java b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryStatusCheckerTest.java\n--- a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryStatusCheckerTest.java\n+++ b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryStatusCheckerTest.java\n@@ -22,6 +22,7 @@\n import org.apache.dubbo.registry.RegistryFactory;\n import org.apache.dubbo.registry.status.RegistryStatusChecker;\n import org.apache.dubbo.registry.support.AbstractRegistryFactory;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n@@ -45,7 +46,7 @@ public class RegistryStatusCheckerTest {\n     @BeforeEach\n     public void setUp() {\n-        AbstractRegistryFactory.destroyAll();\n+        AbstractRegistryFactory.clearRegistryNotDestroy();\n     }\n     @Test\n@@ -55,6 +56,7 @@ public void testCheckUnknown() {\n     @Test\n     public void testCheckOK() {\n+        ApplicationModel.setApplication(\"testCheckOK\");\n         ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension().getRegistry(registryUrl);\n         ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension().getRegistry(registryUrl2);\n         assertEquals(Status.Level.OK, new RegistryStatusChecker().check().getLevel());",
    "output": "Fix default registry ut failure"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java\n@@ -20,14 +20,17 @@\n import org.apache.dubbo.common.URLBuilder;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.registry.NotifyListener;\n import org.apache.dubbo.registry.Registry;\n import org.apache.dubbo.registry.RegistryFactory;\n import org.apache.dubbo.registry.RegistryService;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.locks.ReentrantLock;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n@@ -50,6 +53,8 @@ public abstract class AbstractRegistryFactory implements RegistryFactory {\n     // Registry Collection Map<RegistryAddress, Registry>\n     private static final Map<String, Registry> REGISTRIES = new HashMap<>();\n+    private static final AtomicBoolean destroyed = new AtomicBoolean(false);\n+\n     /**\n      * Get all registries\n      *\n@@ -67,6 +72,10 @@ public static Registry getRegistry(String key) {\n      * Close all created registries\n      */\n     public static void destroyAll() {\n+        if (!destroyed.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n         if (LOGGER.isInfoEnabled()) {\n             LOGGER.info(\"Close all registries \" + getRegistries());\n         }\n@@ -89,6 +98,12 @@ public static void destroyAll() {\n     @Override\n     public Registry getRegistry(URL url) {\n+        if (destroyed.get()) {\n+            LOGGER.warn(\"All registry instances have been destroyed, failed to fetch any instance. \" +\n+                    \"Usually, this means no need to try to do unnecessary redundant resource clearance, all registries has been taken care of.\");\n+            return DEFAULT_NOP_REGISTRY;\n+        }\n+\n         url = URLBuilder.from(url)\n                 .setPath(RegistryService.class.getName())\n                 .addParameter(INTERFACE_KEY, RegistryService.class.getName())\n@@ -117,4 +132,47 @@ public Registry getRegistry(URL url) {\n     protected abstract Registry createRegistry(URL url);\n+\n+    private static Registry DEFAULT_NOP_REGISTRY = new Registry() {\n+        @Override\n+        public URL getUrl() {\n+            return null;\n+        }\n+\n+        @Override\n+        public boolean isAvailable() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void destroy() {\n+\n+        }\n+\n+        @Override\n+        public void register(URL url) {\n+\n+        }\n+\n+        @Override\n+        public void unregister(URL url) {\n+\n+        }\n+\n+        @Override\n+        public void subscribe(URL url, NotifyListener listener) {\n+\n+        }\n+\n+        @Override\n+        public void unsubscribe(URL url, NotifyListener listener) {\n+\n+        }\n+\n+        @Override\n+        public List<URL> lookup(URL url) {\n+            return null;\n+        }\n+    };\n+\n }",
    "output": "Fix shutdown bug: avoid recreating registry after destroy"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n@@ -86,6 +86,8 @@ public abstract class AbstractReferenceConfig extends AbstractInterfaceConfig {\n      */\n     protected String providedBy;\n+    protected String router;\n+\n     public Boolean isCheck() {\n         return check;\n     }\n@@ -234,4 +236,13 @@ public String getProvidedBy() {\n     public void setProvidedBy(String providedBy) {\n         this.providedBy = providedBy;\n     }\n+\n+    @Parameter(key = \"router\", append = true)\n+    public String getRouter() {\n+        return router;\n+    }\n+\n+    public void setRouter(String router) {\n+        this.router = router;\n+    }\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractReferenceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractReferenceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractReferenceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractReferenceConfigTest.java\n@@ -17,24 +17,33 @@\n package org.apache.dubbo.config;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.remoting.Constants;\n-\n+import org.apache.dubbo.rpc.cluster.RouterFactory;\n+import org.apache.dubbo.rpc.cluster.router.condition.ConditionRouterFactory;\n+import org.apache.dubbo.rpc.cluster.router.condition.config.AppRouterFactory;\n+import org.apache.dubbo.rpc.cluster.router.tag.TagRouterFactory;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import static org.apache.dubbo.common.constants.CommonConstants.GENERIC_SERIALIZATION_NATIVE_JAVA;\n import static org.apache.dubbo.common.constants.CommonConstants.INVOKER_LISTENER_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.REFERENCE_FILTER_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.STUB_EVENT_KEY;\n import static org.apache.dubbo.rpc.cluster.Constants.CLUSTER_STICKY_KEY;\n+import static org.apache.dubbo.rpc.cluster.Constants.ROUTER_KEY;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.hasKey;\n import static org.hamcrest.Matchers.hasValue;\n import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n public class AbstractReferenceConfigTest {\n@@ -81,6 +90,26 @@ public void testFilter() throws Exception {\n         assertThat(parameters, hasValue(\"prefilter,mockfilter\"));\n     }\n+    @Test\n+    public void testRouter() throws Exception {\n+        ReferenceConfig referenceConfig = new ReferenceConfig();\n+        referenceConfig.setRouter(\"condition\");\n+        assertThat(referenceConfig.getRouter(), equalTo(\"condition\"));\n+        Map<String, String> parameters = new HashMap<String, String>();\n+        parameters.put(ROUTER_KEY, \"tag\");\n+        AbstractInterfaceConfig.appendParameters(parameters, referenceConfig);\n+        assertThat(parameters, hasValue(\"tag,condition\"));\n+        URL url = mock(URL.class);\n+        when(url.getParameter(ROUTER_KEY)).thenReturn(\"condition\");\n+        List<RouterFactory> routerFactories = ExtensionLoader.getExtensionLoader(RouterFactory.class).getActivateExtension(url, ROUTER_KEY);\n+        assertThat(routerFactories.stream().anyMatch(routerFactory -> routerFactory.getClass().equals(ConditionRouterFactory.class)), is(true));\n+        when(url.getParameter(ROUTER_KEY)).thenReturn(\"-tag,-app\");\n+        routerFactories = ExtensionLoader.getExtensionLoader(RouterFactory.class).getActivateExtension(url, ROUTER_KEY);\n+        assertThat(routerFactories.stream()\n+                .allMatch(routerFactory -> !routerFactory.getClass().equals(TagRouterFactory.class)\n+                        && !routerFactory.getClass().equals(AppRouterFactory.class)), is(true));\n+    }\n+\n     @Test\n     public void testListener() throws Exception {\n         ReferenceConfig referenceConfig = new ReferenceConfig();",
    "output": "Add the router key in dubbo.xsd"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -216,9 +216,9 @@ public synchronized void init() {\n             }\n         }\n         map.put(INTERFACE_KEY, interfaceName);\n-        AbstractConfig.appendParameters(map, metrics);\n-        AbstractConfig.appendParameters(map, application);\n-        AbstractConfig.appendParameters(map, module);\n+        AbstractConfig.appendParameters(map, getMetrics());\n+        AbstractConfig.appendParameters(map, getApplication());\n+        AbstractConfig.appendParameters(map, getModule());\n         // remove 'default.' prefix for configs from ConsumerConfig\n         // appendParameters(map, consumer, Constants.DEFAULT_KEY);\n         AbstractConfig.appendParameters(map, consumer);\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -326,9 +326,9 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n         map.put(SIDE_KEY, PROVIDER_SIDE);\n         ServiceConfig.appendRuntimeParameters(map);\n-        AbstractConfig.appendParameters(map, metrics);\n-        AbstractConfig.appendParameters(map, application);\n-        AbstractConfig.appendParameters(map, module);\n+        AbstractConfig.appendParameters(map, getMetrics());\n+        AbstractConfig.appendParameters(map, getApplication());\n+        AbstractConfig.appendParameters(map, getModule());\n         // remove 'default.' prefix for configs from ProviderConfig\n         // appendParameters(map, provider, Constants.DEFAULT_KEY);\n         AbstractConfig.appendParameters(map, provider);\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n@@ -254,4 +254,11 @@ public void testMock2() throws Exception {\n             service.setMock(true);\n         });\n     }\n+\n+    @Test\n+    public void testApplicationInUrl() {\n+        service.export();\n+        Assertions.assertNotNull(service.toUrl().getParameter(APPLICATION_KEY));\n+        Assertions.assertEquals(\"app\", service.toUrl().getParameter(APPLICATION_KEY));\n+    }\n }\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.config.annotation.Service;\n import org.apache.dubbo.config.spring.context.event.ServiceBeanExportedEvent;\n import org.apache.dubbo.config.spring.extension.SpringExtensionFactory;\n+import org.apache.dubbo.config.support.Parameter;\n import org.springframework.aop.support.AopUtils;\n import org.springframework.beans.factory.BeanNameAware;\n@@ -98,6 +99,7 @@ public void afterPropertiesSet() throws Exception {\n      * @return {@link ServiceBean}'s name\n      * @since 2.6.5\n      */\n+    @Parameter(excluded = true)\n     public String getBeanName() {\n         return this.beanName;\n     }",
    "output": "Fix config append lost ApplicationConfig"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Serialization.java b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Serialization.java\n--- a/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Serialization.java\n+++ b/dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/Serialization.java\n@@ -36,7 +36,9 @@\n public interface Serialization {\n     /**\n-     * Get content type unique id, recommended that custom implementations use values greater than 20.\n+     * Get content type unique id, recommended that custom implementations use values different with\n+     * any value of {@link Constants} and don't greater than ExchangeCodec.SERIALIZATION_MASK (31)\n+     * because dubbo protocol use 5 bits to record serialization ID in header.\n      *\n      * @return content type id\n      */\n@@ -71,4 +73,4 @@ public interface Serialization {\n     @Adaptive\n     ObjectInput deserialize(URL url, InputStream input) throws IOException;\n-}\n\\ No newline at end of file\n+}",
    "output": "Fix javadoc for Serialization.getContentTypeId"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufJsonObjectOutputTest.java b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufJsonObjectOutputTest.java\n--- a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufJsonObjectOutputTest.java\n+++ b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufJsonObjectOutputTest.java\n@@ -166,18 +166,18 @@ public void testWriteLong() throws IOException {\n     @Test\n-    public void testWriteMap() throws IOException {\n+    public void testWriteMap() throws IOException, ClassNotFoundException {\n         Map<String, Object> map = new HashMap<>();\n         map.put(\"key\", \"hello\");\n         map.put(\"value\", \"dubbo\");\n         this.genericProtobufObjectOutput.writeAttachments(map);\n         this.flushToInput();\n-        assertThat(genericProtobufObjectInput.readObject(Map.class), is(map));\n+        assertThat(genericProtobufObjectInput.readAttachments(), is(map));\n     }\n     @Test\n-    void testWriteMultiType() throws IOException {\n+    void testWriteMultiType() throws IOException, ClassNotFoundException {\n         long random = new Random().nextLong();\n         this.genericProtobufObjectOutput.writeLong(random);\n         Map<String, Object> map = new HashMap<>();\n@@ -192,7 +192,7 @@ void testWriteMultiType() throws IOException {\n         this.genericProtobufObjectOutput.writeShort((short) randomShort);\n         this.flushToInput();\n         assertThat(genericProtobufObjectInput.readLong(), is(random));\n-        assertThat(genericProtobufObjectInput.readObject(Map.class), is(map));\n+        assertThat(genericProtobufObjectInput.readAttachments(), is(map));\n         assertThat(genericProtobufObjectInput.readBytes(), is(bytes));\n         assertThat(genericProtobufObjectInput.readShort(), is((short) randomShort));\n     }",
    "output": "Fix protobuf serialization UT"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/AdaptiveClassCodeGeneratorTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/AdaptiveClassCodeGeneratorTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/extension/AdaptiveClassCodeGeneratorTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/extension/AdaptiveClassCodeGeneratorTest.java\n@@ -26,7 +26,7 @@\n import java.io.InputStreamReader;\n import java.net.URL;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n /**\n  * {@link AdaptiveClassCodeGenerator} Test\n@@ -42,7 +42,7 @@ public void testGenerate() throws IOException {\n         URL url = getClass().getResource(\"/org/apache/dubbo/common/extension/adaptive/HasAdaptiveExt$Adaptive\");\n         try (InputStream inputStream = url.openStream()) {\n             String content = IOUtils.read(new InputStreamReader(inputStream, \"UTF-8\"));\n-            assertEquals(content, value);\n+            assertTrue(content.contains(value));\n         }\n     }\n }",
    "output": "Fix extension adaptive unit test"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/ReflectUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/ReflectUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/ReflectUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/ReflectUtilsTest.java\n@@ -41,7 +41,6 @@\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.junit.jupiter.api.Assertions.fail;",
    "output": "Remove unused imports"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/ListenerRegistryWrapper.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/ListenerRegistryWrapper.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/ListenerRegistryWrapper.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/ListenerRegistryWrapper.java\n@@ -151,4 +151,8 @@ public void unsubscribe(URL url, NotifyListener listener) {\n     public List<URL> lookup(URL url) {\n         return registry.lookup(url);\n     }\n+\n+    public Registry getRegistry() {\n+        return registry;\n+    }\n }\ndiff --git a/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistryTestUtil.java b/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistryTestUtil.java\n--- a/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistryTestUtil.java\n+++ b/dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistryTestUtil.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.common.utils.UrlUtils;\n+import org.apache.dubbo.registry.ListenerRegistryWrapper;\n import org.apache.dubbo.registry.Registry;\n import org.apache.dubbo.registry.redis.RedisRegistry;\n import org.apache.dubbo.registry.zookeeper.ZookeeperRegistry;\n@@ -49,6 +50,9 @@\n public class MultipleRegistryTestUtil {\n     public static ZookeeperRegistry getZookeeperRegistry(Collection<Registry> registryCollection) {\n         for (Registry registry : registryCollection) {\n+            if (registry instanceof ListenerRegistryWrapper) {\n+                registry = ((ListenerRegistryWrapper) registry).getRegistry();\n+            }\n             if (registry instanceof ZookeeperRegistry) {\n                 return (ZookeeperRegistry) registry;\n             }\n@@ -58,6 +62,9 @@ public static ZookeeperRegistry getZookeeperRegistry(Collection<Registry> regist\n     public static RedisRegistry getRedisRegistry(Collection<Registry> registryCollection) {\n         for (Registry registry : registryCollection) {\n+            if (registry instanceof ListenerRegistryWrapper) {\n+                registry = ((ListenerRegistryWrapper) registry).getRegistry();\n+            }\n             if (registry instanceof RedisRegistry) {\n                 return (RedisRegistry) registry;\n             }\ndiff --git a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufJsonObjectOutputTest.java b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufJsonObjectOutputTest.java\n--- a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufJsonObjectOutputTest.java\n+++ b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufJsonObjectOutputTest.java\n@@ -167,10 +167,10 @@ public void testWriteLong() throws IOException {\n     @Test\n     public void testWriteMap() throws IOException {\n-        Map<String, String> map = new HashMap<>();\n+        Map<String, Object> map = new HashMap<>();\n         map.put(\"key\", \"hello\");\n         map.put(\"value\", \"dubbo\");\n-        this.genericProtobufObjectOutput.writeObject(map);\n+        this.genericProtobufObjectOutput.writeAttachments(map);\n         this.flushToInput();\n         assertThat(genericProtobufObjectInput.readObject(Map.class), is(map));\n     }\n@@ -180,10 +180,10 @@ public void testWriteMap() throws IOException {\n     void testWriteMultiType() throws IOException {\n         long random = new Random().nextLong();\n         this.genericProtobufObjectOutput.writeLong(random);\n-        Map<String, String> map = new HashMap<>();\n+        Map<String, Object> map = new HashMap<>();\n         map.put(\"key\", \"hello\");\n         map.put(\"value\", \"world\");\n-        this.genericProtobufObjectOutput.writeObject(map);\n+        this.genericProtobufObjectOutput.writeAttachments(map);\n         final int length = new Random().nextInt(100);\n         byte[] bytes = new byte[length];\n         new Random().nextBytes(bytes);",
    "output": "Fix UTs"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfigurationRegistrar.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfigurationRegistrar.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfigurationRegistrar.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfigurationRegistrar.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.config.AbstractConfig;\n import org.apache.dubbo.config.spring.beans.factory.annotation.DubboConfigAliasPostProcessor;\n+import org.apache.dubbo.config.spring.context.config.NamePropertyDefaultValueDubboConfigBeanCustomizer;\n import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;\n@@ -27,6 +28,7 @@\n import static com.alibaba.spring.util.AnnotatedBeanDefinitionRegistryUtils.registerBeans;\n import static com.alibaba.spring.util.BeanRegistrar.registerInfrastructureBean;\n+import static org.apache.dubbo.config.spring.context.config.NamePropertyDefaultValueDubboConfigBeanCustomizer.BEAN_NAME;\n /**\n  * Dubbo {@link AbstractConfig Config} {@link ImportBeanDefinitionRegistrar register}, which order can be configured\n@@ -55,6 +57,14 @@ public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, B\n         // Register DubboConfigAliasPostProcessor\n         registerDubboConfigAliasPostProcessor(registry);\n+\n+        // Register NamePropertyDefaultValueDubboConfigBeanCustomizer\n+        registerDubboConfigBeanCustomizers(registry);\n+\n+    }\n+\n+    private void registerDubboConfigBeanCustomizers(BeanDefinitionRegistry registry) {\n+        registerInfrastructureBean(registry, BEAN_NAME, NamePropertyDefaultValueDubboConfigBeanCustomizer.class);\n     }\n     /**\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/config/DubboConfigBeanCustomizer.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/config/DubboConfigBeanCustomizer.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/config/DubboConfigBeanCustomizer.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/config/DubboConfigBeanCustomizer.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.config.spring.beans.factory.annotation.DubboConfigBindingBeanPostProcessor;\n import org.apache.dubbo.config.spring.context.properties.DubboConfigBinder;\n+import com.alibaba.spring.context.config.ConfigurationBeanCustomizer;\n import org.springframework.context.ApplicationContext;\n import org.springframework.core.Ordered;\n@@ -35,7 +36,7 @@\n  * @see DubboConfigBindingBeanPostProcessor\n  * @since 2.6.6\n  */\n-public interface DubboConfigBeanCustomizer extends Ordered {\n+public interface DubboConfigBeanCustomizer extends ConfigurationBeanCustomizer, Ordered {\n     /**\n      * Customize {@link AbstractConfig Dubbo Config Bean}\n@@ -44,4 +45,11 @@ public interface DubboConfigBeanCustomizer extends Ordered {\n      * @param dubboConfigBean the instance of {@link AbstractConfig Dubbo Config Bean}\n      */\n     void customize(String beanName, AbstractConfig dubboConfigBean);\n+\n+    @Override\n+    default void customize(String beanName, Object configurationBean) {\n+        if (configurationBean instanceof AbstractConfig) {\n+            customize(beanName, (AbstractConfig) configurationBean);\n+        }\n+    }\n }\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationPropertyValuesAdapterTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationPropertyValuesAdapterTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationPropertyValuesAdapterTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationPropertyValuesAdapterTest.java\n@@ -67,9 +67,19 @@ public void test() {\n         DefaultConversionService conversionService = new DefaultConversionService();\n-        conversionService.addConverter((Converter<String[], String>) source -> arrayToCommaDelimitedString(source));\n-\n-        conversionService.addConverter((Converter<String[], Map<String, String>>) source -> CollectionUtils.toStringMap(source));\n+        conversionService.addConverter(new Converter<String[], String>() {\n+            @Override\n+            public String convert(String[] source) {\n+                return arrayToCommaDelimitedString(source);\n+            }\n+        });\n+\n+        conversionService.addConverter(new Converter<String[], Map<String, String>>() {\n+            @Override\n+            public Map<String, String> convert(String[] source) {\n+                return CollectionUtils.toStringMap(source);\n+            }\n+        });\n         dataBinder.setConversionService(conversionService);",
    "output": "Fix Testcases' bugs * Polish apache/dubbo#5306 : [Migration] Upgrade the @since tags in Javadoc migration cloud native to master * Polish apache/dubbo#5306 : [Migration] Upgrade the @since tags in Javadoc migration cloud native to master * Polish apache/dubbo#5309 : [ISSURE] The beans of Dubbo's Config can't be found on the ReferenceBean's initialization * Polish apache/dubbo#5312 : Resolve the demos' issues of zookeeper and nacos * Polish apache/dubbo#5313 : [Migration] migrate the code in common module from cloud-native branch to master * Polish apache/dubbo#5316 : [Refactor] Replace @EnableDubboConfigBinding Using spring-context-support * Polish apache/dubbo#5317 : [Refactor] Refactor ReferenceAnnotationBeanPostProcessor using Alibaba spring-context-suuport API * Polish apache/dubbo#5321 : Remove BeanFactoryUtils * Polish apache/dubbo#5321 : Remove AnnotatedBeanDefinitionRegistryUtils * Polish apache/dubbo#5321 : Remove AnnotationUtils * Polish apache/dubbo#5321 : Remove ClassUtils * Polish apache/dubbo#5321 : Remove BeanRegistrar * Polish apache/dubbo#5321 : Remove ObjectUtils * Polish apache/dubbo#5321 : Remove PropertySourcesUtils * Polish apache/dubbo#5325 : [Migration] To migrate dubbo-metadata-api from cloud-native branch * Polish apache/dubbo#5326 : [Migration] To migrate dubbo-metadata-processor from cloud-native branch * Polish apache/dubbo#5329 : [Feature] To add the default metadata into ServiceInstance * Polish apache/dubbo#5339 : [Refactor] Refactor the DynamicConfiguration interface * Polish bugfix * Fixes test cases * Merge remote-tracking branch 'upstream/master' into cloud-native-2.7.5 # Conflicts: # dubbo-configcenter/dubbo-configcenter-zookeeper/src/test/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfigurationTest.java # dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/DynamicConfigurationServiceNameMappingTest.java * Merge remote-tracking branch 'upstream/master' into cloud-native-2.7.5 # Conflicts: # dubbo-configcenter/dubbo-configcenter-zookeeper/src/test/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfigurationTest.java # dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/DynamicConfigurationServiceNameMappingTest.java * Fix test-cases"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscovery.java b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscovery.java\n--- a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscovery.java\n+++ b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscovery.java\n@@ -306,7 +306,7 @@ public void run() {\n         }\n         private void processService() {\n-            Response<List<HealthService>> response = getHealthServices(serviceName, -1, Integer.MAX_VALUE);\n+            Response<List<HealthService>> response = getHealthServices(serviceName, consulIndex, Integer.MAX_VALUE);\n             Long currentIndex = response.getConsulIndex();\n             if (currentIndex != null && currentIndex > consulIndex) {\n                 consulIndex = currentIndex;",
    "output": "Fix the consul always pull service list"
  },
  {
    "input": "diff --git a/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReportFactoryTest.java b/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReportFactoryTest.java\n--- a/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReportFactoryTest.java\n+++ b/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReportFactoryTest.java\n@@ -101,8 +101,10 @@ public void testGetOneMetadataReport() {\n     @Test\n     public void testGetOneMetadataReportForIpFormat() {\n-        URL url1 = URL.valueOf(\"zookeeper://\" + NetUtils.getLocalAddress().getHostName() + \":4444/org.apache.dubbo.TestService?version=1.0.0&application=vic\");\n-        URL url2 = URL.valueOf(\"zookeeper://\" + NetUtils.getLocalAddress().getHostAddress() + \":4444/org.apache.dubbo.TestService?version=1.0.0&application=vic\");\n+        String hostName = NetUtils.getLocalAddress().getHostName();\n+        String ip = NetUtils.getIpByHost(hostName);\n+        URL url1 = URL.valueOf(\"zookeeper://\" + hostName + \":4444/org.apache.dubbo.TestService?version=1.0.0&application=vic\");\n+        URL url2 = URL.valueOf(\"zookeeper://\" + ip + \":4444/org.apache.dubbo.TestService?version=1.0.0&application=vic\");\n         MetadataReport metadataReport1 = metadataReportFactory.getMetadataReport(url1);\n         MetadataReport metadataReport2 = metadataReportFactory.getMetadataReport(url2);\n         Assertions.assertEquals(metadataReport1, metadataReport2);",
    "output": "Fix unstable UT `AbstractMetadataReportFactoryTest` under multiple network adapters"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcProtocol.java b/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcProtocol.java\n@@ -93,7 +93,9 @@ protected <T> Runnable doExport(T proxiedImpl, Class<T> type, URL url) throws Rp\n         }\n         grpcServer.getRegistry().addService((BindableService) originalImpl, url.getServiceKey());\n-        grpcServer.start();\n+        if (!grpcServer.isStarted()) {\n+            grpcServer.start();\n+        }\n         return () -> grpcServer.getRegistry().removeService(url.getServiceKey());\n     }\n@@ -167,6 +169,7 @@ public class GrpcRemotingServer extends RemotingServerAdapter {\n         private Server originalServer;\n         private DubboHandlerRegistry handlerRegistry;\n+        private volatile boolean started;\n         public GrpcRemotingServer(Server server, DubboHandlerRegistry handlerRegistry) {\n             this.originalServer = server;\n@@ -176,6 +179,7 @@ public GrpcRemotingServer(Server server, DubboHandlerRegistry handlerRegistry) {\n         public void start() throws RpcException {\n             try {\n                 originalServer.start();\n+                started = true;\n             } catch (IOException e) {\n                 throw new RpcException(\"Starting gRPC server failed. \", e);\n             }\n@@ -190,6 +194,10 @@ public Object getDelegateServer() {\n             return originalServer;\n         }\n+        public boolean isStarted() {\n+            return started;\n+        }\n+\n         @Override\n         public void close() {\n             originalServer.shutdown();",
    "output": "Add start status for gRPC server"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java b/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n@@ -445,7 +445,7 @@ private <V> V read(Callable<V> callable) {\n     private static void checkDuplicate(AbstractConfig oldOne, AbstractConfig newOne) throws IllegalStateException {\n         if (oldOne != null && !oldOne.equals(newOne)) {\n             String configName = oldOne.getClass().getSimpleName();\n-            throw new IllegalStateException(\"Duplicate Config found for \" + configName + \", you should use only one unique \" + configName + \" for one application.\");\n+            logger.warn(\"Duplicate Config found for \" + configName + \", you should use only one unique \" + configName + \" for one application.\");\n         }\n     }",
    "output": "Change from throwing exception to logging warn message for duplicate configs"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcProtocol.java b/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-grpc/src/main/java/org/apache/dubbo/rpc/protocol/grpc/GrpcProtocol.java\n@@ -25,6 +25,9 @@\n import org.apache.dubbo.rpc.ProtocolServer;\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.ProviderModel;\n+import org.apache.dubbo.rpc.model.ServiceRepository;\n import org.apache.dubbo.rpc.protocol.AbstractProxyProtocol;\n import io.grpc.BindableService;\n@@ -55,7 +58,7 @@ public class GrpcProtocol extends AbstractProxyProtocol {\n     private final ConcurrentMap<String, ManagedChannel> channelMap = new ConcurrentHashMap<>();\n     @Override\n-    protected <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException {\n+    protected <T> Runnable doExport(T proxiedImpl, Class<T> type, URL url) throws RpcException {\n         String key = url.getAddress();\n         ProtocolServer protocolServer = serverMap.computeIfAbsent(key, k -> {\n             DubboHandlerRegistry registry = new DubboHandlerRegistry();\n@@ -71,7 +74,23 @@ protected <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcExcept\n         });\n         GrpcRemotingServer grpcServer = (GrpcRemotingServer) protocolServer.getRemotingServer();\n-        grpcServer.getRegistry().addService((BindableService) impl, url.getServiceKey());\n+\n+        ServiceRepository serviceRepository = ApplicationModel.getServiceRepository();\n+        ProviderModel providerModel = serviceRepository.lookupExportedService(url.getServiceKey());\n+        if (providerModel == null) {\n+            throw new IllegalStateException(\"Service \" + url.getServiceKey() + \"should have already been stored in service repository, \" +\n+                    \"but failed to find it.\");\n+        }\n+        Object originalImpl = providerModel.getServiceInstance();\n+\n+        Class<?> implClass = originalImpl.getClass();\n+        try {\n+            Method method = implClass.getDeclaredMethod(\"setProxiedImpl\", type);\n+            method.invoke(originalImpl, proxiedImpl);\n+        } catch (Exception e) {\n+            throw new IllegalStateException();\n+        }\n+        grpcServer.getRegistry().addService((BindableService) originalImpl, url.getServiceKey());\n         grpcServer.start();",
    "output": "Fix grpc impl proxy problem"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/proxy/RemoteMetadataServiceProxy.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/proxy/RemoteMetadataServiceProxy.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/proxy/RemoteMetadataServiceProxy.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/proxy/RemoteMetadataServiceProxy.java\n@@ -17,6 +17,7 @@\n import java.util.TreeSet;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n+import static org.apache.dubbo.registry.client.metadata.URLRevisionResolver.NO_REVISION;\n /**\n  * 2019-08-09\n@@ -32,7 +33,7 @@ public RemoteMetadataServiceProxy(ServiceInstance serviceInstance) {\n         this.serviceName = serviceInstance.getServiceName();\n         // this is ServiceInstance of registry(Provider)\n         this.revision = serviceInstance.getMetadata()\n-                .getOrDefault(ServiceInstanceMetadataUtils.EXPORTED_SERVICES_REVISION_PROPERTY_NAME, \"\");\n+                .getOrDefault(ServiceInstanceMetadataUtils.EXPORTED_SERVICES_REVISION_PROPERTY_NAME, NO_REVISION);\n     }\n     @Override",
    "output": "Use default revision N/A"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java\n@@ -490,12 +490,14 @@ public static void validateMethodConfig(MethodConfig config) {\n         checkMethodName(\"name\", config.getName());\n         String mock = config.getMock();\n-        if (mock.startsWith(RETURN_PREFIX) || mock.startsWith(THROW_PREFIX + \" \")) {\n-            checkLength(MOCK_KEY, mock);\n-        } else if (mock.startsWith(FAIL_PREFIX) || mock.startsWith(FORCE_PREFIX)) {\n-            checkNameHasSymbol(MOCK_KEY, mock);\n-        } else {\n-            checkName(MOCK_KEY, mock);\n+        if (StringUtils.isNotEmpty(mock)) {\n+            if (mock.startsWith(RETURN_PREFIX) || mock.startsWith(THROW_PREFIX + \" \")) {\n+                checkLength(MOCK_KEY, mock);\n+            } else if (mock.startsWith(FAIL_PREFIX) || mock.startsWith(FORCE_PREFIX)) {\n+                checkNameHasSymbol(MOCK_KEY, mock);\n+            } else {\n+                checkName(MOCK_KEY, mock);\n+            }\n         }\n     }",
    "output": "Fix potential NPE before mock check"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n@@ -145,11 +145,7 @@ static boolean isValidV4Address(InetAddress address) {\n      * @return true if it is reachable\n      */\n     static boolean isPreferIPV6Address() {\n-        boolean preferIpv6 = Boolean.getBoolean(\"java.net.preferIPv6Addresses\");\n-        if (!preferIpv6) {\n-            return false;\n-        }\n-        return false;\n+        return Boolean.getBoolean(\"java.net.preferIPv6Addresses\");\n     }\n     /**",
    "output": "Fix NetUtils.isPreferIPV6Address bug"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n@@ -184,7 +184,7 @@ public void setOnthrowMethod(Method onthrowMethod) {\n     /* *************** Start, metadata compatible **************** */\n     private ServiceMetadata serviceMetadata;\n-    private final Map<Method, ConsumerMethodModel> methodModels = new IdentityHashMap<Method, ConsumerMethodModel>();\n+    private Map<Method, ConsumerMethodModel> methodModels = new IdentityHashMap<Method, ConsumerMethodModel>();\n     public ConsumerModel(String serviceKey\n             , Object proxyObject\n@@ -201,6 +201,10 @@ public ConsumerModel(String serviceKey\n         }\n     }\n+    public ClassLoader getClassLoader() {\n+        return serviceMetadata.getServiceType().getClassLoader();\n+    }\n+\n     /**\n      * @return serviceMetadata\n      */\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java\n@@ -20,6 +20,7 @@\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n+import java.util.stream.Stream;\n import static org.apache.dubbo.common.constants.CommonConstants.$INVOKE;\n import static org.apache.dubbo.common.constants.CommonConstants.$INVOKE_ASYNC;\n@@ -46,7 +47,9 @@ public MethodDescriptor(Method method) {\n         this.returnClass = method.getReturnType();\n         this.returnTypes = ReflectUtils.getReturnTypes(method);\n         this.paramDesc = ReflectUtils.getDesc(parameterClasses);\n-        this.compatibleParamSignatures = ReflectUtils.getDescArray(method);\n+        this.compatibleParamSignatures = Stream.of(parameterClasses)\n+                .map(Class::getName)\n+                .toArray(String[]::new);\n         this.methodName = method.getName();\n         this.generic = (methodName.equals($INVOKE) || methodName.equals($INVOKE_ASYNC)) && parameterClasses.length == 3;\n     }",
    "output": "Fix how compatibleParamSignatures is generated"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractChannel.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractChannel.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractChannel.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractChannel.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.remoting.Channel;\n import org.apache.dubbo.remoting.ChannelHandler;\n import org.apache.dubbo.remoting.RemotingException;\n+import org.apache.dubbo.remoting.utils.LogUtils;\n /**\n  * AbstractChannel\n@@ -34,7 +35,7 @@ public AbstractChannel(URL url, ChannelHandler handler) {\n     public void send(Object message, boolean sent) throws RemotingException {\n         if (isClosed()) {\n             throw new RemotingException(this, \"Failed to send message \"\n-                    + (message == null ? \"\" : message.getClass().getName()) + \":\" + message\n+                    + (message == null ? \"\" : message.getClass().getName()) + \":\" + LogUtils.getRequestWithoutData(message)\n                     + \", cause: Channel closed. channel: \" + getLocalAddress() + \" -> \" + getRemoteAddress());\n         }\n     }\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/LogUtils.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/LogUtils.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/LogUtils.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/LogUtils.java\n@@ -0,0 +1,32 @@\n+package org.apache.dubbo.remoting.utils;\n+\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.remoting.exchange.Request;\n+import org.apache.dubbo.remoting.exchange.Response;\n+\n+public class LogUtils {\n+    private static Logger logger = LoggerFactory.getLogger(LogUtils.class);\n+\n+    /**\n+     * only log body in debugger mode for size & security consideration.\n+     *\n+     * @param message\n+     * @return\n+     */\n+    public static Object getRequestWithoutData(Object message) {\n+        if (logger.isDebugEnabled()) {\n+            return message;\n+        }\n+        if (message instanceof Request) {\n+            Request request = (Request) message;\n+            request.setData(null);\n+            return request;\n+        } else if (message instanceof Response) {\n+            Response response = (Response) message;\n+            response.setResult(null);\n+            return response;\n+        }\n+        return message;\n+    }\n+}\ndiff --git a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyChannel.java b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyChannel.java\n--- a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyChannel.java\n+++ b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyChannel.java\n@@ -23,6 +23,7 @@\n import org.apache.dubbo.remoting.RemotingException;\n import org.apache.dubbo.remoting.transport.AbstractChannel;\n+import org.apache.dubbo.remoting.utils.LogUtils;\n import org.jboss.netty.channel.ChannelFuture;\n import java.net.InetSocketAddress;\n@@ -109,11 +110,11 @@ public void send(Object message, boolean sent) throws RemotingException {\n                 throw cause;\n             }\n         } catch (Throwable e) {\n-            throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e);\n+            throw new RemotingException(this, \"Failed to send message \" + LogUtils.getRequestWithoutData(message) + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e);\n         }\n         if (!success) {\n-            throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress()\n+            throw new RemotingException(this, \"Failed to send message \" + LogUtils.getRequestWithoutData(message) + \" to \" + getRemoteAddress()\n                     + \"in timeout(\" + timeout + \"ms) limit\");\n         }\n     }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannel.java\n@@ -25,6 +25,7 @@\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelFuture;\n+import org.apache.dubbo.remoting.utils.LogUtils;\n import java.net.InetSocketAddress;\n import java.util.Map;\n@@ -69,11 +70,12 @@ private NettyChannel(Channel channel, URL url, ChannelHandler handler) {\n         }\n         this.channel = channel;\n     }\n+\n     /**\n      * Get dubbo channel by netty channel through channel cache.\n      * Put netty channel into it if dubbo channel don't exist in the cache.\n      *\n-     * @param ch netty channel\n+     * @param ch      netty channel\n      * @param url\n      * @param handler dubbo handler that contain netty's handler\n      * @return\n@@ -95,6 +97,7 @@ static NettyChannel getOrAddChannel(Channel ch, URL url, ChannelHandler handler)\n         }\n         return ret;\n     }\n+\n     /**\n      * Remove the inactive channel.\n      *\n@@ -145,7 +148,7 @@ public void markActive(boolean isActive) {\n      * Send message by netty and whether to wait the completion of the send.\n      *\n      * @param message message that need send.\n-     * @param sent whether to ack async-sent\n+     * @param sent    whether to ack async-sent\n      * @throws RemotingException throw RemotingException if wait until timeout or any exception thrown by method body that surrounded by try-catch.\n      */\n     @Override\n@@ -168,10 +171,10 @@ public void send(Object message, boolean sent) throws RemotingException {\n             }\n         } catch (Throwable e) {\n             removeChannelIfDisconnected(channel);\n-            throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e);\n+            throw new RemotingException(this, \"Failed to send message \" + LogUtils.getRequestWithoutData(message) + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e);\n         }\n         if (!success) {\n-            throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress()\n+            throw new RemotingException(this, \"Failed to send message \" + LogUtils.getRequestWithoutData(message) + \" to \" + getRemoteAddress()\n                     + \"in timeout(\" + timeout + \"ms) limit\");\n         }\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n@@ -262,7 +262,7 @@ Invoker<?> getInvoker(Channel channel, Invocation inv) throws RemotingException\n         if (exporter == null) {\n             throw new RemotingException(channel, \"Not found exported service: \" + serviceKey + \" in \" + exporterMap.keySet() + \", may be version or group mismatch \" +\n-                    \", channel: consumer: \" + channel.getRemoteAddress() + \" --> provider: \" + channel.getLocalAddress() + \", message:\" + inv);\n+                    \", channel: consumer: \" + channel.getRemoteAddress() + \" --> provider: \" + channel.getLocalAddress() + \", message:\" + getInvocationWithoutData(inv));\n         }\n         return exporter.getInvoker();\n@@ -667,4 +667,22 @@ private void closeReferenceCountExchangeClient(ReferenceCountExchangeClient clie\n             logger.warn(t.getMessage(), t);\n         }\n     }\n+\n+    /**\n+     * only log body in debugger mode for size & security consideration.\n+     *\n+     * @param invocation\n+     * @return\n+     */\n+    private Invocation getInvocationWithoutData(Invocation invocation) {\n+        if (logger.isDebugEnabled()) {\n+            return invocation;\n+        }\n+        if (invocation instanceof RpcInvocation) {\n+            RpcInvocation rpcInvocation = (RpcInvocation) invocation;\n+            rpcInvocation.setArguments(null);\n+            return rpcInvocation;\n+        }\n+        return invocation;\n+    }\n }",
    "output": "Remove sensitive data from log exception for dubbo protocol"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Protocol.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Protocol.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Protocol.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Protocol.java\n@@ -17,8 +17,13 @@\n package com.alibaba.dubbo.rpc;\n+import org.apache.dubbo.rpc.ProtocolServer;\n+\n import com.alibaba.dubbo.common.URL;\n+import java.util.Collections;\n+import java.util.List;\n+\n @Deprecated\n public interface Protocol extends org.apache.dubbo.rpc.Protocol {\n@@ -35,4 +40,9 @@ default <T> org.apache.dubbo.rpc.Exporter<T> export(org.apache.dubbo.rpc.Invoker\n     default <T> org.apache.dubbo.rpc.Invoker<T> refer(Class<T> aClass, org.apache.dubbo.common.URL url) throws RpcException {\n         return this.refer(aClass, new URL(url));\n     }\n+\n+    @Override\n+    default List<ProtocolServer> getServers() {\n+        return Collections.emptyList();\n+    }\n }",
    "output": "Add default implementation for alibaba pacakge compatible class"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/DubboConfigAliasPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/DubboConfigAliasPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/DubboConfigAliasPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/DubboConfigAliasPostProcessor.java\n@@ -1,74 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.config.spring.beans.factory.annotation;\n-\n-import org.apache.dubbo.config.AbstractConfig;\n-import org.apache.dubbo.config.spring.context.annotation.DubboConfigConfigurationRegistrar;\n-\n-import org.springframework.beans.BeansException;\n-import org.springframework.beans.factory.config.BeanPostProcessor;\n-import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n-import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n-import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\n-\n-import static org.apache.dubbo.config.spring.util.BeanRegistrar.hasAlias;\n-import static org.springframework.util.ObjectUtils.nullSafeEquals;\n-import static org.springframework.util.StringUtils.hasText;\n-\n-/**\n- * A Post-Processor class to set the alias of Dubbo Config bean using its {@link AbstractConfig#getId()}\n- *\n- * @since 2.7.4\n- */\n-public class DubboConfigAliasPostProcessor implements BeanDefinitionRegistryPostProcessor, BeanPostProcessor {\n-\n-    /**\n-     * The bean name of {@link DubboConfigConfigurationRegistrar}\n-     */\n-    public final static String BEAN_NAME = \"dubboConfigAliasPostProcessor\";\n-\n-    private BeanDefinitionRegistry registry;\n-\n-    @Override\n-    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n-        this.registry = registry;\n-    }\n-\n-    @Override\n-    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n-        // DO NOTHING\n-    }\n-\n-    @Override\n-    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n-        // DO NOTHING\n-        return bean;\n-    }\n-\n-    @Override\n-    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n-        if (bean instanceof AbstractConfig) {\n-            String id = ((AbstractConfig) bean).getId();\n-            if (hasText(id)                                     // id MUST be present in AbstractConfig\n-                    && !nullSafeEquals(id, beanName)            // id MUST NOT be equal to bean name\n-                    && !hasAlias(registry, beanName, id)) {     // id MUST NOT be present in AliasRegistry\n-                registry.registerAlias(beanName, id);\n-            }\n-        }\n-        return bean;\n-    }\n-}",
    "output": "Remove useless files"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -620,12 +620,11 @@ private void useRegistryForConfigIfNecessary() {\n             Environment.getInstance().getDynamicConfiguration().orElseGet(() -> {\n                 ConfigManager configManager = ConfigManager.getInstance();\n                 ConfigCenterConfig cc = configManager.getConfigCenter().orElse(new ConfigCenterConfig());\n+                if (cc.getParameters() == null) {\n+                    cc.setParameters(new HashMap<>());\n+                }\n                 if (rc.getParameters() != null) {\n-                    Map<String, String> configParams = cc.getParameters() == null ? new HashMap<>() : cc.getParameters();\n-                    configParams.putAll(rc.getParameters());\n-                    cc.setParameters(configParams);\n-                } else {\n-                    rc.setParameters(new HashMap<>());\n+                    cc.getParameters().putAll(rc.getParameters());\n                 }\n                 cc.getParameters().put(org.apache.dubbo.remoting.Constants.CLIENT_KEY,rc.getClient());\n                 cc.setProtocol(rc.getProtocol());",
    "output": "Fix parameters could be null"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -624,6 +624,8 @@ private void useRegistryForConfigIfNecessary() {\n                     Map<String, String> configParams = cc.getParameters() == null ? new HashMap<>() : cc.getParameters();\n                     configParams.putAll(rc.getParameters());\n                     cc.setParameters(configParams);\n+                } else {\n+                    rc.setParameters(new HashMap<>());\n                 }\n                 cc.getParameters().put(org.apache.dubbo.remoting.Constants.CLIENT_KEY,rc.getClient());\n                 cc.setProtocol(rc.getProtocol());",
    "output": "Fix parameters could be null"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/ProtobufUtils.java b/dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/ProtobufUtils.java\n--- a/dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/ProtobufUtils.java\n+++ b/dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/ProtobufUtils.java\n@@ -21,14 +21,21 @@\n import org.apache.dubbo.common.serialize.protobuf.support.wrapper.ThrowablePB.ThrowableProto;\n import com.google.common.base.Strings;\n+import com.google.protobuf.BoolValue;\n+import com.google.protobuf.BytesValue;\n import com.google.protobuf.CodedInputStream;\n+import com.google.protobuf.DoubleValue;\n import com.google.protobuf.Empty;\n import com.google.protobuf.ExtensionRegistryLite;\n+import com.google.protobuf.FloatValue;\n import com.google.protobuf.GeneratedMessageV3.Builder;\n+import com.google.protobuf.Int32Value;\n+import com.google.protobuf.Int64Value;\n import com.google.protobuf.InvalidProtocolBufferException;\n import com.google.protobuf.MessageLite;\n import com.google.protobuf.MessageOrBuilder;\n import com.google.protobuf.Parser;\n+import com.google.protobuf.StringValue;\n import com.google.protobuf.util.JsonFormat;\n import com.google.protobuf.util.JsonFormat.Printer;\n@@ -85,10 +92,17 @@ private static Builder getMessageBuilder(Class<?> requestType) throws Exception\n             ExtensionRegistryLite.getEmptyRegistry();\n     static {\n-        // Builtin types needed to be registered in advance\n+        // Built-in types need to be registered in advance\n         marshaller(MapValue.Map.getDefaultInstance());\n         marshaller(Empty.getDefaultInstance());\n         marshaller(ThrowableProto.getDefaultInstance());\n+        marshaller(BoolValue.getDefaultInstance());\n+        marshaller(Int32Value.getDefaultInstance());\n+        marshaller(Int64Value.getDefaultInstance());\n+        marshaller(FloatValue.getDefaultInstance());\n+        marshaller(DoubleValue.getDefaultInstance());\n+        marshaller(BytesValue.getDefaultInstance());\n+        marshaller(StringValue.getDefaultInstance());\n     }\n     public static <T extends MessageLite> void marshaller(T defaultInstance) {\n@@ -97,7 +111,7 @@ public static <T extends MessageLite> void marshaller(T defaultInstance) {\n     static void serialize(Object value, OutputStream os) throws IOException {\n         MessageLite messageLite = (MessageLite) value;\n-        messageLite.writeTo(os);\n+        messageLite.writeDelimitedTo(os);\n     }\n     @SuppressWarnings(\"unchecked\")\n@@ -170,11 +184,12 @@ public T getMessagePrototype() {\n         }\n         public T parse(InputStream stream) throws InvalidProtocolBufferException {\n-            CodedInputStream cis = CodedInputStream.newInstance(stream);\n-            // Pre-create the CodedInputStream so that we can remove the size limit restriction\n-            // when parsing.\n-            cis.setSizeLimit(Integer.MAX_VALUE);\n-            return parseFrom(cis);\n+            return parser.parseDelimitedFrom(stream, globalRegistry);\n+//            CodedInputStream cis = CodedInputStream.newInstance(stream);\n+//            // Pre-create the CodedInputStream so that we can remove the size limit restriction\n+//            // when parsing.\n+//            cis.setSizeLimit(Integer.MAX_VALUE);\n+//            return parseFrom(cis);\n         }\n         private T parseFrom(CodedInputStream stream) throws InvalidProtocolBufferException {",
    "output": "Fix protobuf serialization bug"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyHandler.java b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyHandler.java\n--- a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyHandler.java\n@@ -17,6 +17,8 @@\n package org.apache.dubbo.remoting.transport.netty;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.remoting.Channel;\n import org.apache.dubbo.remoting.ChannelHandler;\n@@ -38,6 +40,8 @@\n @Sharable\n public class NettyHandler extends SimpleChannelHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(NettyHandler.class);\n+\n     private final Map<String, Channel> channels = new ConcurrentHashMap<String, Channel>(); // <ip:port, channel>\n     private final URL url;\n@@ -70,6 +74,10 @@ public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) thr\n         } finally {\n             NettyChannel.removeChannelIfDisconnected(ctx.getChannel());\n         }\n+\n+        if (logger.isInfoEnabled()) {\n+            logger.info(\"The connection between \" + channel.getRemoteAddress() + \" and \" + channel.getLocalAddress() + \" is established\");\n+        }\n     }\n     @Override\n@@ -81,6 +89,10 @@ public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n         } finally {\n             NettyChannel.removeChannelIfDisconnected(ctx.getChannel());\n         }\n+\n+        if (logger.isInfoEnabled()) {\n+            logger.info(\"The connection between \" + channel.getRemoteAddress() + \" and \" + channel.getLocalAddress() + \" is disconnected\");\n+        }\n     }\n     @Override\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java\n@@ -60,6 +60,10 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {\n         } finally {\n             NettyChannel.removeChannelIfDisconnected(ctx.channel());\n         }\n+\n+        if (logger.isInfoEnabled()) {\n+            logger.info(\"The connection of \" + channel.getLocalAddress() + \" -> \" + channel.getRemoteAddress() + \" is established.\");\n+        }\n     }\n     @Override\n@@ -70,6 +74,10 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n         } finally {\n             NettyChannel.removeChannelIfDisconnected(ctx.channel());\n         }\n+\n+        if (logger.isInfoEnabled()) {\n+            logger.info(\"The connection of \" + channel.getLocalAddress() + \" -> \" + channel.getRemoteAddress() + \" is disconnected.\");\n+        }\n     }\n     @Override\n@@ -113,7 +121,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n     @Override\n     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n-    \t// send heartbeat when read idle.\n+        // send heartbeat when read idle.\n         if (evt instanceof IdleStateEvent) {\n             try {\n                 NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n@@ -128,7 +136,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc\n             } finally {\n                 NettyChannel.removeChannelIfDisconnected(ctx.channel());\n             }\n-       } else {\n+        } else {\n             super.userEventTriggered(ctx, evt);\n         }\n     }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java\n@@ -74,6 +74,10 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {\n         } finally {\n             NettyChannel.removeChannelIfDisconnected(ctx.channel());\n         }\n+\n+        if (logger.isInfoEnabled()) {\n+            logger.info(\"The connection of \" + channel.getRemoteAddress() + \" -> \" + channel.getLocalAddress() + \" is established.\");\n+        }\n     }\n     @Override\n@@ -85,6 +89,10 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n         } finally {\n             NettyChannel.removeChannelIfDisconnected(ctx.channel());\n         }\n+\n+        if (logger.isInfoEnabled()) {\n+            logger.info(\"The connection of \" + channel.getRemoteAddress() + \" -> \" + channel.getLocalAddress() + \" is disconnected.\");\n+        }\n     }\n     @Override",
    "output": "Add netty channel connected and disconnected log"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/service/GenericServiceTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/service/GenericServiceTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/service/GenericServiceTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/service/GenericServiceTest.java\n@@ -29,9 +29,7 @@\n import org.apache.dubbo.config.ReferenceConfig;\n import org.apache.dubbo.config.RegistryConfig;\n import org.apache.dubbo.config.ServiceConfig;\n-\n import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n import java.io.ByteArrayInputStream;\n@@ -42,21 +40,24 @@\n import java.util.Map;\n import java.util.concurrent.atomic.AtomicReference;\n-import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_NATIVE_JAVA;\n import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_BEAN;\n+import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_NATIVE_JAVA;\n /**\n  * GenericServiceTest\n  */\n-@Disabled(\"Keeps failing on Travis, but can not be reproduced locally.\")\n public class GenericServiceTest {\n+    private ApplicationConfig application = new ApplicationConfig(\"genericService-test\");\n+    private RegistryConfig registryNA = new RegistryConfig(\"N/A\");\n+    private ProtocolConfig protocolDubbo29581 = new ProtocolConfig(\"dubbo\", 29581);\n+\n     @Test\n     public void testGenericServiceException() {\n         ServiceConfig<GenericService> service = new ServiceConfig<GenericService>();\n-        service.setApplication(new ApplicationConfig(\"generic-provider\"));\n-        service.setRegistry(new RegistryConfig(\"N/A\"));\n-        service.setProtocol(new ProtocolConfig(\"dubbo\", 29581));\n+        service.setApplication(application);\n+        service.setRegistry(registryNA);\n+        service.setProtocol(protocolDubbo29581);\n         service.setInterface(DemoService.class.getName());\n         service.setRef(new GenericService() {\n@@ -77,7 +78,7 @@ public void testGenericServiceException() {\n         service.export();\n         try {\n             ReferenceConfig<DemoService> reference = new ReferenceConfig<DemoService>();\n-            reference.setApplication(new ApplicationConfig(\"generic-consumer\"));\n+            service.setApplication(application);\n             reference.setInterface(DemoService.class);\n             reference.setUrl(\"dubbo://127.0.0.1:29581?generic=true&timeout=3000\");\n             DemoService demoService = reference.get();\n@@ -108,15 +109,15 @@ public void testGenericServiceException() {\n     @Test\n     public void testGenericReferenceException() {\n         ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();\n-        service.setApplication(new ApplicationConfig(\"generic-provider\"));\n-        service.setRegistry(new RegistryConfig(\"N/A\"));\n-        service.setProtocol(new ProtocolConfig(\"dubbo\", 29581));\n+        service.setApplication(application);\n+        service.setRegistry(registryNA);\n+        service.setProtocol(protocolDubbo29581);\n         service.setInterface(DemoService.class.getName());\n         service.setRef(new DemoServiceImpl());\n         service.export();\n         try {\n             ReferenceConfig<GenericService> reference = new ReferenceConfig<GenericService>();\n-            reference.setApplication(new ApplicationConfig(\"generic-consumer\"));\n+            service.setApplication(application);\n             reference.setInterface(DemoService.class);\n             reference.setUrl(\"dubbo://127.0.0.1:29581?scope=remote&timeout=3000\");\n             reference.setGeneric(true);\n@@ -141,16 +142,16 @@ public void testGenericReferenceException() {\n     @Test\n     public void testGenericSerializationJava() throws Exception {\n         ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();\n-        service.setApplication(new ApplicationConfig(\"generic-provider\"));\n-        service.setRegistry(new RegistryConfig(\"N/A\"));\n-        service.setProtocol(new ProtocolConfig(\"dubbo\", 29581));\n+        service.setApplication(application);\n+        service.setRegistry(registryNA);\n+        service.setProtocol(protocolDubbo29581);\n         service.setInterface(DemoService.class.getName());\n         DemoServiceImpl ref = new DemoServiceImpl();\n         service.setRef(ref);\n         service.export();\n         try {\n             ReferenceConfig<GenericService> reference = new ReferenceConfig<GenericService>();\n-            reference.setApplication(new ApplicationConfig(\"generic-consumer\"));\n+            service.setApplication(application);\n             reference.setInterface(DemoService.class);\n             reference.setUrl(\"dubbo://127.0.0.1:29581?scope=remote&timeout=3000\");\n             reference.setGeneric(GENERIC_SERIALIZATION_NATIVE_JAVA);\n@@ -209,17 +210,17 @@ public void testGenericSerializationJava() throws Exception {\n     @Test\n     public void testGenericInvokeWithBeanSerialization() throws Exception {\n         ServiceConfig<DemoService> service = new ServiceConfig<DemoService>();\n-        service.setApplication(new ApplicationConfig(\"bean-provider\"));\n+        service.setApplication(application);\n+        service.setRegistry(registryNA);\n+        service.setProtocol(protocolDubbo29581);\n         service.setInterface(DemoService.class);\n-        service.setRegistry(new RegistryConfig(\"N/A\"));\n         DemoServiceImpl impl = new DemoServiceImpl();\n         service.setRef(impl);\n-        service.setProtocol(new ProtocolConfig(\"dubbo\", 29581));\n         service.export();\n         ReferenceConfig<GenericService> reference = null;\n         try {\n             reference = new ReferenceConfig<GenericService>();\n-            reference.setApplication(new ApplicationConfig(\"bean-consumer\"));\n+            service.setApplication(application);\n             reference.setInterface(DemoService.class);\n             reference.setUrl(\"dubbo://127.0.0.1:29581?scope=remote&timeout=3000\");\n             reference.setGeneric(GENERIC_SERIALIZATION_BEAN);\n@@ -248,9 +249,9 @@ public void testGenericInvokeWithBeanSerialization() throws Exception {\n     public void testGenericImplementationWithBeanSerialization() throws Exception {\n         final AtomicReference reference = new AtomicReference();\n         ServiceConfig<GenericService> service = new ServiceConfig<GenericService>();\n-        service.setApplication(new ApplicationConfig(\"bean-provider\"));\n-        service.setRegistry(new RegistryConfig(\"N/A\"));\n-        service.setProtocol(new ProtocolConfig(\"dubbo\", 29581));\n+        service.setApplication(application);\n+        service.setRegistry(registryNA);\n+        service.setProtocol(protocolDubbo29581);\n         service.setInterface(DemoService.class.getName());\n         service.setRef(new GenericService() {\n@@ -273,7 +274,7 @@ public void testGenericImplementationWithBeanSerialization() throws Exception {\n         ReferenceConfig<DemoService> ref = null;\n         try {\n             ref = new ReferenceConfig<DemoService>();\n-            ref.setApplication(new ApplicationConfig(\"bean-consumer\"));\n+            service.setApplication(application);\n             ref.setInterface(DemoService.class);\n             ref.setUrl(\"dubbo://127.0.0.1:29581?scope=remote&generic=bean&timeout=3000\");\n             DemoService demoService = ref.get();\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java\n@@ -46,7 +46,7 @@\n public class ValidationTest {\n     private ApplicationConfig application = new ApplicationConfig(\"validation-test\");\n     private RegistryConfig registryNA = new RegistryConfig(\"N/A\");\n-    private ProtocolConfig protocolDubo29582 = new ProtocolConfig(\"dubbo\", 29582);\n+    private ProtocolConfig protocolDubbo29582 = new ProtocolConfig(\"dubbo\", 29582);\n     @BeforeEach\n     public void setUp() {\n@@ -63,7 +63,7 @@ public void testValidation() {\n         ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();\n         service.setApplication(application);\n         service.setRegistry(registryNA);\n-        service.setProtocol(protocolDubo29582);\n+        service.setProtocol(protocolDubbo29582);\n         service.setInterface(ValidationService.class.getName());\n         service.setRef(new ValidationServiceImpl());\n         service.setValidation(String.valueOf(true));\n@@ -189,7 +189,7 @@ public void testProviderValidation() {\n         ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();\n         service.setApplication(application);\n         service.setRegistry(registryNA);\n-        service.setProtocol(protocolDubo29582);\n+        service.setProtocol(protocolDubbo29582);\n         service.setInterface(ValidationService.class.getName());\n         service.setRef(new ValidationServiceImpl());\n         service.setValidation(String.valueOf(true));\n@@ -254,7 +254,7 @@ public void testGenericValidation() {\n         ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();\n         service.setApplication(application);\n         service.setRegistry(registryNA);\n-        service.setProtocol(protocolDubo29582);\n+        service.setProtocol(protocolDubbo29582);\n         service.setInterface(ValidationService.class.getName());\n         service.setRef(new ValidationServiceImpl());\n         service.setValidation(String.valueOf(true));",
    "output": "Fix GenericServiceTest failing on Travis"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java\n@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.alibaba.dubbo.rpc;\n+\n+import com.alibaba.dubbo.common.Constants;\n+import com.alibaba.dubbo.common.URL;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class RpcInvocation implements Invocation, Serializable {\n+\n+    private static final long serialVersionUID = -4355285085441097045L;\n+\n+    private String methodName;\n+\n+    private Class<?>[] parameterTypes;\n+\n+    private Object[] arguments;\n+\n+    private Map<String, String> attachments;\n+\n+    private transient Invoker<?> invoker;\n+\n+    public RpcInvocation() {\n+    }\n+\n+    public RpcInvocation(Invocation invocation, Invoker<?> invoker) {\n+        this(invocation.getMethodName(), invocation.getParameterTypes(),\n+                invocation.getArguments(), new HashMap<String, String>(invocation.getAttachments()),\n+                invocation.getInvoker());\n+        if (invoker != null) {\n+            URL url = invoker.getUrl();\n+            setAttachment(Constants.PATH_KEY, url.getPath());\n+            if (url.hasParameter(Constants.INTERFACE_KEY)) {\n+                setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));\n+            }\n+            if (url.hasParameter(Constants.GROUP_KEY)) {\n+                setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));\n+            }\n+            if (url.hasParameter(Constants.VERSION_KEY)) {\n+                setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY, \"0.0.0\"));\n+            }\n+            if (url.hasParameter(Constants.TIMEOUT_KEY)) {\n+                setAttachment(Constants.TIMEOUT_KEY, url.getParameter(Constants.TIMEOUT_KEY));\n+            }\n+            if (url.hasParameter(Constants.TOKEN_KEY)) {\n+                setAttachment(Constants.TOKEN_KEY, url.getParameter(Constants.TOKEN_KEY));\n+            }\n+            if (url.hasParameter(Constants.APPLICATION_KEY)) {\n+                setAttachment(Constants.APPLICATION_KEY, url.getParameter(Constants.APPLICATION_KEY));\n+            }\n+        }\n+    }\n+\n+    public RpcInvocation(Invocation invocation) {\n+        this(invocation.getMethodName(), invocation.getParameterTypes(),\n+                invocation.getArguments(), invocation.getAttachments(), invocation.getInvoker());\n+    }\n+\n+    public RpcInvocation(Method method, Object[] arguments) {\n+        this(method.getName(), method.getParameterTypes(), arguments, null, null);\n+    }\n+\n+    public RpcInvocation(Method method, Object[] arguments, Map<String, String> attachment) {\n+        this(method.getName(), method.getParameterTypes(), arguments, attachment, null);\n+    }\n+\n+    public RpcInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {\n+        this(methodName, parameterTypes, arguments, null, null);\n+    }\n+\n+    public RpcInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments, Map<String, String> attachments) {\n+        this(methodName, parameterTypes, arguments, attachments, null);\n+    }\n+\n+    public RpcInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments, Map<String, String> attachments, Invoker<?> invoker) {\n+        this.methodName = methodName;\n+        this.parameterTypes = parameterTypes == null ? new Class<?>[0] : parameterTypes;\n+        this.arguments = arguments == null ? new Object[0] : arguments;\n+        this.attachments = attachments == null ? new HashMap<String, String>() : attachments;\n+        this.invoker = invoker;\n+    }\n+\n+    public Invoker<?> getInvoker() {\n+        return invoker;\n+    }\n+\n+    public void setInvoker(Invoker<?> invoker) {\n+        this.invoker = invoker;\n+    }\n+\n+    public String getMethodName() {\n+        return methodName;\n+    }\n+\n+    public void setMethodName(String methodName) {\n+        this.methodName = methodName;\n+    }\n+\n+    public Class<?>[] getParameterTypes() {\n+        return parameterTypes;\n+    }\n+\n+    public void setParameterTypes(Class<?>[] parameterTypes) {\n+        this.parameterTypes = parameterTypes == null ? new Class<?>[0] : parameterTypes;\n+    }\n+\n+    public Object[] getArguments() {\n+        return arguments;\n+    }\n+\n+    public void setArguments(Object[] arguments) {\n+        this.arguments = arguments == null ? new Object[0] : arguments;\n+    }\n+\n+    public Map<String, String> getAttachments() {\n+        return attachments;\n+    }\n+\n+    public void setAttachments(Map<String, String> attachments) {\n+        this.attachments = attachments == null ? new HashMap<String, String>() : attachments;\n+    }\n+\n+    public void setAttachment(String key, String value) {\n+        if (attachments == null) {\n+            attachments = new HashMap<String, String>();\n+        }\n+        attachments.put(key, value);\n+    }\n+\n+    public void setAttachmentIfAbsent(String key, String value) {\n+        if (attachments == null) {\n+            attachments = new HashMap<String, String>();\n+        }\n+        if (!attachments.containsKey(key)) {\n+            attachments.put(key, value);\n+        }\n+    }\n+\n+    public void addAttachments(Map<String, String> attachments) {\n+        if (attachments == null) {\n+            return;\n+        }\n+        if (this.attachments == null) {\n+            this.attachments = new HashMap<String, String>();\n+        }\n+        this.attachments.putAll(attachments);\n+    }\n+\n+    public void addAttachmentsIfAbsent(Map<String, String> attachments) {\n+        if (attachments == null) {\n+            return;\n+        }\n+        for (Map.Entry<String, String> entry : attachments.entrySet()) {\n+            setAttachmentIfAbsent(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public String getAttachment(String key) {\n+        if (attachments == null) {\n+            return null;\n+        }\n+        return attachments.get(key);\n+    }\n+\n+    public String getAttachment(String key, String defaultValue) {\n+        if (attachments == null) {\n+            return defaultValue;\n+        }\n+        String value = attachments.get(key);\n+        if (value == null || value.length() == 0) {\n+            return defaultValue;\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RpcInvocation [methodName=\" + methodName + \", parameterTypes=\"\n+                + Arrays.toString(parameterTypes) + \", arguments=\" + Arrays.toString(arguments)\n+                + \", attachments=\" + attachments + \"]\";\n+    }\n+\n+}",
    "output": "Add compatible com.alibaba.xxx.RpcInvocation"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/LsTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/LsTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/LsTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/LsTest.java\n@@ -72,6 +72,6 @@ public void testExecute() throws Exception {\n         Ls ls = new Ls();\n         String output = ls.execute(mock(CommandContext.class), null);\n         assertThat(output, containsString(\"org.apache.dubbo.FooService|100\"));\n-        assertThat(output, containsString(\"org.apache.dubbo.BarService| Y\"));\n+        assertThat(output, containsString(\"org.apache.dubbo.BarService\"));\n     }\n }\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/OfflineTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/OfflineTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/OfflineTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/OfflineTest.java\n@@ -24,6 +24,8 @@\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.ProviderModel;\n+import org.apache.dubbo.rpc.model.ServiceMetadata;\n+\n import org.junit.jupiter.api.Test;\n import org.mockito.Mockito;\n@@ -38,29 +40,33 @@ public class OfflineTest {\n     @Test\n     public void testExecute() throws Exception {\n         ProviderModel providerModel = mock(ProviderModel.class);\n-        when(providerModel.getServiceName()).thenReturn(\"org.apache.dubbo.BarService\");\n-        ApplicationModel.initProviderModel(\"org.apache.dubbo.BarService\", providerModel);\n+        when(providerModel.getServiceMetadata()).thenReturn(new ServiceMetadata(\"org.apache.dubbo.qos.command.impl.TestInterface2\", \"ddd\", \"1.2.3.offline\", TestInterface2.class));\n+        when(providerModel.getServiceName()).thenReturn(\"org.apache.dubbo.qos.command.impl.TestInterface2\");\n+        ApplicationModel.initProviderModel(\"org.apache.dubbo.qos.command.impl.TestInterface2\", providerModel);\n         Invoker providerInvoker = mock(Invoker.class);\n         URL registryUrl = mock(URL.class);\n         when(registryUrl.toFullString()).thenReturn(\"test://localhost:8080\");\n         URL providerUrl = mock(URL.class);\n-        when(providerUrl.getServiceKey()).thenReturn(\"org.apache.dubbo.BarService\");\n-        when(providerUrl.toFullString()).thenReturn(\"dubbo://localhost:8888/org.apache.dubbo.BarService\");\n+        String serviceKey = \"ddd/org.apache.dubbo.qos.command.impl.TestInterface2:1.2.3.offline\";\n+        when(providerUrl.getServiceKey()).thenReturn(serviceKey);\n+        when(providerUrl.toFullString()).thenReturn(\"dubbo://localhost:8888/org.apache.dubbo.qos.command.impl.TestInterface2?version=1.2.3.offline&group=ddd\");\n         when(providerInvoker.getUrl()).thenReturn(providerUrl);\n+\n         ProviderConsumerRegTable.registerProvider(providerInvoker, registryUrl, providerUrl);\n-        for (ProviderInvokerWrapper wrapper : getProviderInvoker(\"org.apache.dubbo.BarService\")) {\n+        for (ProviderInvokerWrapper wrapper : getProviderInvoker(serviceKey)) {\n             wrapper.setReg(true);\n         }\n         Registry registry = mock(Registry.class);\n         TestRegistryFactory.registry = registry;\n         Offline offline = new Offline();\n-        String output = offline.execute(mock(CommandContext.class), new String[]{\"org.apache.dubbo.BarService\"});\n+        String output = offline.execute(mock(CommandContext.class), new String[]{\"org.apache.dubbo.qos.command.impl.TestInterface2\"});\n         assertThat(output, containsString(\"OK\"));\n+\n         Mockito.verify(registry).unregister(providerUrl);\n-        for (ProviderInvokerWrapper wrapper : getProviderInvoker(\"org.apache.dubbo.BarService\")) {\n+        for (ProviderInvokerWrapper wrapper : getProviderInvoker(serviceKey)) {\n             assertThat(wrapper.isReg(), is(false));\n         }\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/OnlineTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/OnlineTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/OnlineTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/OnlineTest.java\n@@ -24,11 +24,13 @@\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n import org.apache.dubbo.rpc.model.ProviderModel;\n+import org.apache.dubbo.rpc.model.ServiceMetadata;\n+\n import org.junit.jupiter.api.Test;\n import static org.apache.dubbo.registry.support.ProviderConsumerRegTable.getProviderInvoker;\n-import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n@@ -37,25 +39,31 @@ public class OnlineTest {\n     @Test\n     public void testExecute() throws Exception {\n         ProviderModel providerModel = mock(ProviderModel.class);\n-        when(providerModel.getServiceName()).thenReturn(\"org.apache.dubbo.BarService\");\n-        ApplicationModel.initProviderModel(\"org.apache.dubbo.BarService\", providerModel);\n+        when(providerModel.getServiceMetadata()).thenReturn(new ServiceMetadata(\"org.apache.dubbo.qos.command.impl.TestInterface\", \"ddd\", \"1.2.3.online\", TestInterface.class));\n+        when(providerModel.getServiceName()).thenReturn(\"org.apache.dubbo.qos.command.impl.TestInterface\");\n+        ApplicationModel.initProviderModel(\"org.apache.dubbo.qos.command.impl.TestInterface\", providerModel);\n         Invoker providerInvoker = mock(Invoker.class);\n         URL registryUrl = mock(URL.class);\n         when(registryUrl.toFullString()).thenReturn(\"test://localhost:8080\");\n         URL providerUrl = mock(URL.class);\n-        when(providerUrl.getServiceKey()).thenReturn(\"org.apache.dubbo.BarService\");\n-        when(providerUrl.toFullString()).thenReturn(\"dubbo://localhost:8888/org.apache.dubbo.BarService\");\n+\n+        String serviceKey = \"ddd/org.apache.dubbo.qos.command.impl.TestInterface:1.2.3.online\";\n+        when(providerUrl.getServiceKey()).thenReturn(serviceKey);\n+        when(providerUrl.toFullString()).thenReturn(\"dubbo://localhost:8888/org.apache.dubbo.qos.command.impl.TestInterface?version=1.2.3.online&group=ddd\");\n         when(providerInvoker.getUrl()).thenReturn(providerUrl);\n         ProviderConsumerRegTable.registerProvider(providerInvoker, registryUrl, providerUrl);\n         Registry registry = mock(Registry.class);\n         TestRegistryFactory.registry = registry;\n+        for (ProviderInvokerWrapper wrapper : getProviderInvoker(serviceKey)) {\n+            assertTrue(!wrapper.isReg());\n+        }\n         Online online = new Online();\n-        String output = online.execute(mock(CommandContext.class), new String[]{\"org.apache.dubbo.BarService\"});\n+        String output = online.execute(mock(CommandContext.class), new String[]{\"org.apache.dubbo.qos.command.impl.TestInterface\"});\n         assertThat(output, equalTo(\"OK\"));\n-        for (ProviderInvokerWrapper wrapper : getProviderInvoker(\"org.apache.dubbo.BarService\")) {\n+        for (ProviderInvokerWrapper wrapper : getProviderInvoker(serviceKey)) {\n             assertTrue(wrapper.isReg());\n         }\n     }\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/TestInterface.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/TestInterface.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/TestInterface.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/TestInterface.java\n@@ -0,0 +1,9 @@\n+package org.apache.dubbo.qos.command.impl;\n+\n+/**\n+ * 2019-10-11\n+ */\n+public interface TestInterface {\n+\n+    String sayHello();\n+}\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/TestInterface2.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/TestInterface2.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/TestInterface2.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/TestInterface2.java\n@@ -0,0 +1,9 @@\n+package org.apache.dubbo.qos.command.impl;\n+\n+/**\n+ * 2019-10-11\n+ */\n+public interface TestInterface2 {\n+\n+    String sayHello();\n+}",
    "output": "Fix unit test for online and offline"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -624,6 +624,8 @@ private void useRegistryForConfigIfNecessary() {\n                 cc.getParameters().put(org.apache.dubbo.remoting.Constants.CLIENT_KEY,rc.getClient());\n                 cc.setProtocol(rc.getProtocol());\n                 cc.setAddress(rc.getAddress());\n+                cc.setUsername(rc.getUsername());\n+                cc.setPassword(rc.getPassword());\n                 cc.setHighestPriority(false);\n                 setConfigCenter(cc);\n                 startConfigCenter();",
    "output": "Fix username & password config in dubbo:registry"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java\n@@ -93,7 +93,8 @@ public abstract class AbstractMetadataReport implements MetadataReport {\n     public AbstractMetadataReport(URL reportServerURL) {\n         setUrl(reportServerURL);\n         // Start file save timer\n-        String filename = reportServerURL.getParameter(FILE_KEY, System.getProperty(\"user.home\") + \"/.dubbo/dubbo-metadata-\" + reportServerURL.getParameter(APPLICATION_KEY) + \"-\" + reportServerURL.getAddress() + \".cache\");\n+        String defaultFilename = System.getProperty(\"user.home\") + \"/.dubbo/dubbo-metadata-\" + reportServerURL.getParameter(APPLICATION_KEY) + \"-\" + reportServerURL.getAddress().replaceAll(\":\", \"-\") + \".cache\";\n+        String filename = reportServerURL.getParameter(FILE_KEY, defaultFilename);\n         File file = null;\n         if (ConfigUtils.isNotEmpty(filename)) {\n             file = new File(filename);\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n@@ -92,7 +92,8 @@ public AbstractRegistry(URL url) {\n         setUrl(url);\n         // Start file save timer\n         syncSaveFile = url.getParameter(REGISTRY_FILESAVE_SYNC_KEY, false);\n-        String filename = url.getParameter(FILE_KEY, System.getProperty(\"user.home\") + \"/.dubbo/dubbo-registry-\" + url.getParameter(APPLICATION_KEY) + \"-\" + url.getAddress() + \".cache\");\n+        String defaultFilename = System.getProperty(\"user.home\") + \"/.dubbo/dubbo-registry-\" + url.getParameter(APPLICATION_KEY) + \"-\" + url.getAddress().replaceAll(\":\", \"-\") + \".cache\";\n+        String filename = url.getParameter(FILE_KEY, defaultFilename);\n         File file = null;\n         if (ConfigUtils.isNotEmpty(filename)) {\n             file = new File(filename);",
    "output": "Fix cache file name issue in windows platform"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -355,13 +355,14 @@ private void init() {\n         serviceMetadata.getAttachments().putAll(map);\n-        ServiceModel serviceModel = ApplicationModel.registerServiceModel(interfaceClass);\n-        ApplicationModel.initConsumerModel(serviceMetadata.getServiceKey(), buildConsumerModel(attributes, serviceModel));\n-\n         ref = createProxy(map);\n         serviceMetadata.setTarget(ref);\n         serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);\n+\n+        ServiceModel serviceModel = ApplicationModel.registerServiceModel(interfaceClass);\n+        ApplicationModel.initConsumerModel(serviceMetadata.getServiceKey(), buildConsumerModel(attributes, serviceModel));\n+\n         initialized = true;\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -475,7 +475,12 @@ private void doExportUrls() {\n         for (ProtocolConfig protocolConfig : protocols) {\n             String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -> p + \"/\" + path).orElse(path), group, version);\n             serviceMetadata.setServiceKey(pathKey);\n-            ProviderModel providerModel = new ProviderModel(pathKey, ref, ApplicationModel.registerServiceModel(interfaceClass));\n+            ProviderModel providerModel = new ProviderModel(\n+                    pathKey,\n+                    ref,\n+                    ApplicationModel.registerServiceModel(interfaceClass),\n+                    serviceMetadata\n+            );\n             ApplicationModel.initProviderModel(pathKey, providerModel);\n             doExportUrlsFor1Protocol(protocolConfig, registryURLs);\n         }",
    "output": "Fix application models"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java\n@@ -112,7 +112,7 @@ public void testConvertMethodConfig2AsyncInfo() throws Exception{\n         methodConfig.setOninvokeMethod(\"setName\");\n         methodConfig.setOninvoke(new Person());\n-        ConsumerModel.AsyncMethodInfo methodInfo = org.apache.dubbo.config.MethodConfig.convertMethodConfig2AyncInfo(methodConfig);\n+        ConsumerModel.AsyncMethodInfo methodInfo = org.apache.dubbo.config.MethodConfig.convertMethodConfig2AsyncInfo(methodConfig);\n         assertEquals(methodInfo.getOninvokeMethod(), Person.class.getMethod(\"setName\", String.class));\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -248,7 +248,7 @@ protected static void appendAttributes(Map<String, Object> parameters, Object co\n         }\n     }\n-    protected static ConsumerModel.AsyncMethodInfo convertMethodConfig2AyncInfo(MethodConfig methodConfig) {\n+    protected static ConsumerModel.AsyncMethodInfo convertMethodConfig2AsyncInfo(MethodConfig methodConfig) {\n         if (methodConfig == null || (methodConfig.getOninvoke() == null && methodConfig.getOnreturn() == null && methodConfig.getOnthrow() == null)) {\n             return null;\n         }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -38,7 +38,6 @@\n import org.apache.dubbo.rpc.cluster.support.ClusterUtils;\n import org.apache.dubbo.rpc.cluster.support.RegistryAwareCluster;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n-import org.apache.dubbo.rpc.model.ConsumerMethodModel;\n import org.apache.dubbo.rpc.model.ConsumerModel;\n import org.apache.dubbo.rpc.model.ServiceMetadata;\n import org.apache.dubbo.rpc.model.ServiceModel;\n@@ -338,7 +337,7 @@ private void init() {\n                         map.put(methodConfig.getName() + \".retries\", \"0\");\n                     }\n                 }\n-                ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = convertMethodConfig2AsyncInfo(methodConfig);\n+                ConsumerModel.AsyncMethodInfo asyncMethodInfo = convertMethodConfig2AsyncInfo(methodConfig);\n                 if (asyncMethodInfo != null) {\n //                    consumerModel.getMethodModel(methodConfig.getName()).addAttribute(ASYNC_KEY, asyncMethodInfo);\n                     attributes.put(methodConfig.getName(), asyncMethodInfo);",
    "output": "Fix method name typo: convertMethodConfig2AsyncInfo"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationInjectedBeanPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationInjectedBeanPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationInjectedBeanPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationInjectedBeanPostProcessor.java\n@@ -65,7 +65,6 @@\n /**\n  * Abstract generic {@link BeanPostProcessor} implementation for customized annotation that annotated injected-object.\n  * <p>\n- * The source code is cloned from https://github.com/alibaba/spring-context-support/blob/1.0.2/src/main/java/com/alibaba/spring/beans/factory/annotation/AnnotationInjectedBeanPostProcessor.java\n  *\n  * @revision 2.7.3 Uses {@link AnnotationAttributes} instead of {@link Annotation}\n  * @since 2.6.6",
    "output": "Remove the useless comment"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -624,6 +624,8 @@ private void useRegistryForConfigIfNecessary() {\n                 cc.getParameters().put(org.apache.dubbo.remoting.Constants.CLIENT_KEY,rc.getClient());\n                 cc.setProtocol(rc.getProtocol());\n                 cc.setAddress(rc.getAddress());\n+                cc.setUsername(rc.getUsername());\n+                cc.setPassword(rc.getPassword());\n                 cc.setHighestPriority(false);\n                 setConfigCenter(cc);\n                 startConfigCenter();",
    "output": "Fix username & password config in dubbo:registry"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConfigUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConfigUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConfigUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConfigUtils.java\n@@ -260,7 +260,6 @@ public static Properties loadProperties(String fileName, boolean allowMultiFile,\n                 String errMsg = String.format(\"only 1 %s file is expected, but %d dubbo.properties files found on class path: %s\",\n                         fileName, list.size(), list.toString());\n                 logger.warn(errMsg);\n-                // throw new IllegalStateException(errMsg); // see http://code.alibabatech.com/jira/browse/DUBBO-133\n             }\n             // fall back to use method getResourceAsStream\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/WrapperTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/WrapperTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/WrapperTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/WrapperTest.java\n@@ -113,19 +113,13 @@ public void testNoSuchMethod() throws Exception {\n         });\n     }\n-    /**\n-     * see http://code.alibabatech.com/jira/browse/DUBBO-571\n-     */\n     @Test\n     public void test_getDeclaredMethodNames_ContainExtendsParentMethods() throws Exception {\n         assertArrayEquals(new String[]{\"hello\",}, Wrapper.getWrapper(Parent1.class).getMethodNames());\n         assertArrayEquals(new String[]{}, Wrapper.getWrapper(Son.class).getDeclaredMethodNames());\n     }\n-    /**\n-     * see http://code.alibabatech.com/jira/browse/DUBBO-571\n-     */\n     @Test\n     public void test_getMethodNames_ContainExtendsParentMethods() throws Exception {\n         assertArrayEquals(new String[]{\"hello\", \"world\"}, Wrapper.getWrapper(Son.class).getMethodNames());\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/ConfigUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/ConfigUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/ConfigUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/ConfigUtilsTest.java\n@@ -229,7 +229,7 @@ public void testLoadPropertiesOneFileNotRootPath() throws Exception {\n     }\n-    @Disabled(\"see http://code.alibabatech.com/jira/browse/DUBBO-133\")\n+    @Disabled(\"Not know why disabled, the original link explaining this was reachable.\")\n     @Test\n     public void testLoadPropertiesMultiFileNotRootPathException() throws Exception {\n         try {\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractServiceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractServiceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractServiceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractServiceConfigTest.java\n@@ -25,16 +25,15 @@\n import java.util.HashMap;\n import java.util.Map;\n+import static org.apache.dubbo.rpc.Constants.EXPORTER_LISTENER_KEY;\n+import static org.apache.dubbo.rpc.Constants.SERVICE_FILTER_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.hasEntry;\n import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-\n-import static org.apache.dubbo.rpc.Constants.SERVICE_FILTER_KEY;\n-import static org.apache.dubbo.rpc.Constants.EXPORTER_LISTENER_KEY;\n public class AbstractServiceConfigTest {\n     @Test\n@@ -75,11 +74,11 @@ public void testWeight() throws Exception {\n     @Test\n     public void testDocument() throws Exception {\n         ServiceConfig serviceConfig = new ServiceConfig();\n-        serviceConfig.setDocument(\"http://dubbo.io\");\n-        assertThat(serviceConfig.getDocument(), equalTo(\"http://dubbo.io\"));\n+        serviceConfig.setDocument(\"http://dubbo.apache.org\");\n+        assertThat(serviceConfig.getDocument(), equalTo(\"http://dubbo.apache.org\"));\n         Map<String, String> parameters = new HashMap<String, String>();\n         AbstractServiceConfig.appendParameters(parameters, serviceConfig);\n-        assertThat(parameters, hasEntry(\"document\", \"http%3A%2F%2Fdubbo.io\"));\n+        assertThat(parameters, hasEntry(\"document\", \"http%3A%2F%2Fdubbo.apache.org\"));\n     }\n     @Test\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/builders/AbstractServiceBuilderTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/builders/AbstractServiceBuilderTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/builders/AbstractServiceBuilderTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/builders/AbstractServiceBuilderTest.java\n@@ -75,8 +75,8 @@ void weight() {\n     @Test\n     void document() {\n         ServiceBuilder builder = new ServiceBuilder();\n-        builder.document(\"http://dubbo.io\");\n-        Assertions.assertEquals(\"http://dubbo.io\", builder.build().getDocument());\n+        builder.document(\"http://dubbo.apache.org\");\n+        Assertions.assertEquals(\"http://dubbo.apache.org\", builder.build().getDocument());\n     }\n     @Test\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java\n@@ -66,7 +66,7 @@ public class UrlTestBase {\n             {\"deprecated\", \"deprecated\", \"boolean\", false, true, \"\", \"\", \"\", \"\", \"\"},\n             {\"dynamic\", \"dynamic\", \"boolean\", true, false, \"\", \"\", \"\", \"\", \"\"},\n             {\"accesslog\", \"accesslog\", \"string\", \"\", \"haominTest\", \"\", \"\", \"\", \"\", \"\"},\n-            {\"document\", \"document\", \"string\", \"\", \"http://b2b-doc.alibaba-inc.com/display/RC/dubbo_devguide.htm?testquery=\", \"\", \"\", \"\", \"\", \"\"},\n+            {\"document\", \"document\", \"string\", \"\", \"http://dubbo.apache.org/zh-cn/docs/user/quick-start.html?testquery=\", \"\", \"\", \"\", \"\", \"\"},\n             {\"weight\", \"weight\", \"int\", 0, 90, \"\", \"\", \"\", \"\", \"\"},\n             //{\"filter\", \"service.filter\", \"string\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"},\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/ExchangeCodecTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/ExchangeCodecTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/ExchangeCodecTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/ExchangeCodecTest.java\n@@ -402,7 +402,6 @@ public void test_Encode_Error_Response() throws IOException {\n //        Assertions.assertEquals(response.getProtocolVersion(), obj.getVersion());\n     }\n-    // http://code.alibabatech.com/jira/browse/DUBBO-392\n     @Test\n     public void testMessageLengthGreaterThanMessageActualLength() throws Exception {\n         Channel channel = getCliendSideChannel(url);\ndiff --git a/dubbo-serialization/dubbo-serialization-gson/src/test/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectOutputTest.java b/dubbo-serialization/dubbo-serialization-gson/src/test/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectOutputTest.java\n--- a/dubbo-serialization/dubbo-serialization-gson/src/test/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectOutputTest.java\n+++ b/dubbo-serialization/dubbo-serialization-gson/src/test/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectOutputTest.java\n@@ -126,7 +126,7 @@ public void testWriteByte() throws IOException {\n     @Test\n     public void testWriteObject() throws IOException, ClassNotFoundException {\n-        Image image = new Image(\"http://dubbo.io/logo.png\", \"logo\", 300, 480, Image.Size.SMALL);\n+        Image image = new Image(\"http://dubbo.apache.org/img/dubbo_white.png\", \"logo\", 300, 480, Image.Size.SMALL);\n         this.gsonJsonObjectOutput.writeObject(image);\n         this.flushToInput();\ndiff --git a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectOutputTest.java b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectOutputTest.java\n--- a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectOutputTest.java\n+++ b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectOutputTest.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.common.serialize.fastjson;\n import org.apache.dubbo.common.serialize.model.media.Image;\n+\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n@@ -124,7 +125,7 @@ public void testWriteByte() throws IOException {\n     @Test\n     public void testWriteObject() throws IOException, ClassNotFoundException {\n-        Image image = new Image(\"http://dubbo.io/logo.png\", \"logo\", 300, 480, Image.Size.SMALL);\n+        Image image = new Image(\"http://dubbo.apache.org/img/dubbo_white.png\", \"logo\", 300, 480, Image.Size.SMALL);\n         this.fastJsonObjectOutput.writeObject(image);\n         this.flushToInput();",
    "output": "Remove or replace unreachable URL links"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotatedBeanDefinitionRegistryUtils.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotatedBeanDefinitionRegistryUtils.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotatedBeanDefinitionRegistryUtils.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotatedBeanDefinitionRegistryUtils.java\n@@ -37,7 +37,6 @@\n /**\n  * Annotated {@link BeanDefinition} Utilities\n  * <p>\n- * The source code is cloned from https://github.com/alibaba/spring-context-support/blob/1.0.2/src/main/java/com/alibaba/spring/util/AnnotatedBeanDefinitionRegistryUtils.java\n  *\n  * @since 2.6.6\n  */\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/ClassUtils.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/ClassUtils.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/ClassUtils.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/ClassUtils.java\n@@ -1,37 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.config.spring.util;\n-\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-\n-/**\n- * {@link Class} Utilities\n- * <p>\n- * The source code is cloned from\n- * https://github.com/alibaba/spring-context-support/blob/1.0.2/src/main/java/com/alibaba/spring/util/ClassUtils.java\n- *\n- * @since 2.6.6\n- */\n-public abstract class ClassUtils {\n-\n-    public static <T> Class<T> resolveGenericType(Class<?> declaredClass) {\n-        ParameterizedType parameterizedType = (ParameterizedType) declaredClass.getGenericSuperclass();\n-        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n-        return (Class<T>) actualTypeArguments[0];\n-    }\n-}\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/PropertySourcesUtils.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/PropertySourcesUtils.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/PropertySourcesUtils.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/PropertySourcesUtils.java\n@@ -32,7 +32,6 @@\n /**\n  * {@link PropertySources} Utilities\n  * <p>\n- * The source code is cloned from https://github.com/alibaba/spring-context-support/blob/1.0.2/src/main/java/com/alibaba/spring/util/PropertySourcesUtils.java\n  *\n  * @since 2.6.6\n  */",
    "output": "Remove the outdated and misleading comment"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -603,10 +603,16 @@ public void refresh() {\n             Method[] methods = getClass().getMethods();\n             for (Method method : methods) {\n                 if (MethodUtils.isSetter(method)) {\n-                    String value = StringUtils.trim(compositeConfiguration.getString(extractPropertyName(getClass(), method)));\n-                    // isTypeMatch() is called to avoid duplicate and incorrect update, for example, we have two 'setGeneric' methods in ReferenceConfig.\n-                    if (StringUtils.isNotEmpty(value) && ClassUtils.isTypeMatch(method.getParameterTypes()[0], value)) {\n-                        method.invoke(this, ClassUtils.convertPrimitive(method.getParameterTypes()[0], value));\n+                    try {\n+                        String value = StringUtils.trim(compositeConfiguration.getString(extractPropertyName(getClass(), method)));\n+                        // isTypeMatch() is called to avoid duplicate and incorrect update, for example, we have two 'setGeneric' methods in ReferenceConfig.\n+                        if (StringUtils.isNotEmpty(value) && ClassUtils.isTypeMatch(method.getParameterTypes()[0], value)) {\n+                            method.invoke(this, ClassUtils.convertPrimitive(method.getParameterTypes()[0], value));\n+                        }\n+                    } catch (NoSuchMethodException e) {\n+                        logger.info(\"Failed to override the property \" + method.getName() + \" in \" +\n+                                this.getClass().getSimpleName() +\n+                                \", please make sure every property has getter/setter method provided.\");\n                     }\n                 } else if (isParametersSetter(method)) {\n                     String value = StringUtils.trim(compositeConfiguration.getString(extractPropertyName(getClass(), method)));",
    "output": "Add back try-catch clause deleted in https://github.com/apache/dubbo/pull/4899"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java\n@@ -141,7 +141,7 @@ private void handleValue(ObjectInput in) throws IOException {\n     private void handleException(ObjectInput in) throws IOException {\n         try {\n-            Object obj = in.readObject();\n+            Object obj = in.readObject(Throwable.class);\n             if (!(obj instanceof Throwable)) {\n                 throw new IOException(\"Response data error, expect Throwable, but get \" + obj);\n             }\ndiff --git a/dubbo-serialization/dubbo-serialization-gson/src/main/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectInput.java b/dubbo-serialization/dubbo-serialization-gson/src/main/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectInput.java\n--- a/dubbo-serialization/dubbo-serialization-gson/src/main/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectInput.java\n+++ b/dubbo-serialization/dubbo-serialization-gson/src/main/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectInput.java\n@@ -90,7 +90,7 @@ public byte[] readBytes() throws IOException {\n     @Override\n     public Object readObject() throws IOException, ClassNotFoundException {\n         String json = readLine();\n-        return gson.fromJson(json, String.class);\n+        return gson.fromJson(json, Object.class);\n     }\n     @Override",
    "output": "Fix a bug in gson's deserialization feature"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n@@ -16,18 +16,19 @@\n  */\n package org.apache.dubbo.config;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.support.Parameter;\n import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.rpc.InvokerListener;\n import org.apache.dubbo.rpc.support.ProtocolUtils;\n-import static org.apache.dubbo.rpc.cluster.Constants.CLUSTER_STICKY_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n-import static org.apache.dubbo.rpc.Constants.LAZY_CONNECT_KEY;\n import static org.apache.dubbo.rpc.Constants.INVOKER_LISTENER_KEY;\n+import static org.apache.dubbo.rpc.Constants.LAZY_CONNECT_KEY;\n import static org.apache.dubbo.rpc.Constants.REFERENCE_FILTER_KEY;\n import static org.apache.dubbo.rpc.Constants.STUB_EVENT_KEY;\n+import static org.apache.dubbo.rpc.cluster.Constants.CLUSTER_STICKY_KEY;\n /**\n  * AbstractConsumerConfig\n@@ -120,7 +121,14 @@ public String getGeneric() {\n     }\n     public void setGeneric(String generic) {\n-        this.generic = generic;\n+        if (StringUtils.isEmpty(generic)) {\n+            return;\n+        }\n+        if (ProtocolUtils.isValidGenericValue(generic)) {\n+            this.generic = generic;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported generic type \" + generic);\n+        }\n     }\n     /**\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -65,34 +65,34 @@\n import static org.apache.dubbo.common.constants.CommonConstants.ANY_VALUE;\n import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;\n import static org.apache.dubbo.common.constants.CommonConstants.DUBBO;\n+import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_IP_TO_BIND;\n import static org.apache.dubbo.common.constants.CommonConstants.LOCALHOST_VALUE;\n import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.MONITOR_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n import static org.apache.dubbo.common.constants.CommonConstants.REVISION_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_IP_TO_BIND;\n+import static org.apache.dubbo.common.constants.RegistryConstants.DYNAMIC_KEY;\n+import static org.apache.dubbo.common.utils.NetUtils.getAvailablePort;\n+import static org.apache.dubbo.common.utils.NetUtils.getLocalHost;\n+import static org.apache.dubbo.common.utils.NetUtils.isInvalidLocalHost;\n+import static org.apache.dubbo.common.utils.NetUtils.isInvalidPort;\n import static org.apache.dubbo.config.Constants.DUBBO_IP_TO_REGISTRY;\n import static org.apache.dubbo.config.Constants.DUBBO_PORT_TO_BIND;\n import static org.apache.dubbo.config.Constants.DUBBO_PORT_TO_REGISTRY;\n-import static org.apache.dubbo.config.Constants.REGISTER_KEY;\n-import static org.apache.dubbo.rpc.cluster.Constants.EXPORT_KEY;\n import static org.apache.dubbo.config.Constants.MULTICAST;\n import static org.apache.dubbo.config.Constants.PROTOCOLS_SUFFIX;\n-import static org.apache.dubbo.rpc.Constants.SCOPE_KEY;\n-import static org.apache.dubbo.rpc.Constants.SCOPE_LOCAL;\n+import static org.apache.dubbo.config.Constants.REGISTER_KEY;\n import static org.apache.dubbo.config.Constants.SCOPE_NONE;\n-import static org.apache.dubbo.rpc.Constants.SCOPE_REMOTE;\n-import static org.apache.dubbo.common.constants.CommonConstants.MONITOR_KEY;\n-import static org.apache.dubbo.common.constants.RegistryConstants.DYNAMIC_KEY;\n import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;\n import static org.apache.dubbo.rpc.Constants.LOCAL_PROTOCOL;\n import static org.apache.dubbo.rpc.Constants.PROXY_KEY;\n+import static org.apache.dubbo.rpc.Constants.SCOPE_KEY;\n+import static org.apache.dubbo.rpc.Constants.SCOPE_LOCAL;\n+import static org.apache.dubbo.rpc.Constants.SCOPE_REMOTE;\n import static org.apache.dubbo.rpc.Constants.TOKEN_KEY;\n-import static org.apache.dubbo.common.utils.NetUtils.getAvailablePort;\n-import static org.apache.dubbo.common.utils.NetUtils.getLocalHost;\n-import static org.apache.dubbo.common.utils.NetUtils.isInvalidLocalHost;\n-import static org.apache.dubbo.common.utils.NetUtils.isInvalidPort;\n+import static org.apache.dubbo.rpc.cluster.Constants.EXPORT_KEY;\n /**\n  * ServiceConfig\n@@ -1016,7 +1016,7 @@ public void setGeneric(String generic) {\n         if (StringUtils.isEmpty(generic)) {\n             return;\n         }\n-        if (ProtocolUtils.isGeneric(generic)) {\n+        if (ProtocolUtils.isValidGenericValue(generic)) {\n             this.generic = generic;\n         } else {\n             throw new IllegalArgumentException(\"Unsupported generic type \" + generic);\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/builders/AbstractReferenceBuilderTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/builders/AbstractReferenceBuilderTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/builders/AbstractReferenceBuilderTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/builders/AbstractReferenceBuilderTest.java\n@@ -21,6 +21,8 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_BEAN;\n+\n class AbstractReferenceBuilderTest {\n     @Test\n@@ -53,8 +55,8 @@ void generic() {\n     @Test\n     void generic1() {\n         ReferenceBuilder builder = new ReferenceBuilder();\n-        builder.generic(\"generic\");\n-        Assertions.assertEquals(\"generic\", builder.build().getGeneric());\n+        builder.generic(GENERIC_SERIALIZATION_BEAN);\n+        Assertions.assertEquals(GENERIC_SERIALIZATION_BEAN, builder.build().getGeneric());\n     }\n     @Test\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/ProtocolUtils.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/ProtocolUtils.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/ProtocolUtils.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/ProtocolUtils.java\n@@ -21,11 +21,11 @@\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n-import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_NATIVE_JAVA;\n-import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_DEFAULT;\n+import static org.apache.dubbo.rpc.Constants.GENERIC_RAW_RETURN;\n import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_BEAN;\n+import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_DEFAULT;\n+import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_NATIVE_JAVA;\n import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_PROTOBUF;\n-import static org.apache.dubbo.rpc.Constants.GENERIC_RAW_RETURN;\n public class ProtocolUtils {\n@@ -64,6 +64,11 @@ public static boolean isGeneric(String generic) {\n     }\n+    public static boolean isValidGenericValue(String generic) {\n+        return isGeneric(generic) || Boolean.FALSE.toString().equalsIgnoreCase(generic);\n+\n+    }\n+\n     public static boolean isDefaultGenericSerialization(String generic) {\n         return isGeneric(generic)\n                 && GENERIC_SERIALIZATION_DEFAULT.equalsIgnoreCase(generic);",
    "output": "Fix set generic method error"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/TypeDefinitionBuilder.java b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/TypeDefinitionBuilder.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/TypeDefinitionBuilder.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/TypeDefinitionBuilder.java\n@@ -55,6 +55,9 @@ public static TypeDefinition build(Type type, Class<?> clazz, Map<Class<?>, Type\n             td = DefaultTypeBuilder.build(clazz, typeCache);\n             td.setTypeBuilderName(DefaultTypeBuilder.class.getName());\n         }\n+        if (clazz.equals(String.class)) {\n+            td.setProperties(null);\n+        }\n         return td;\n     }",
    "output": "Fix type definition for String class * type definition for String class * code format"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -215,7 +215,7 @@ public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcExceptio\n         ProviderInvokerWrapper<T> providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,\n                 registryUrl, registeredProviderUrl);\n         //to judge if we need to delay publish\n-        boolean register = registeredProviderUrl.getParameter(\"register\", true);\n+        boolean register = providerUrl.getParameter(REGISTER_KEY, true);\n         if (register) {\n             register(registryUrl, registeredProviderUrl);\n             providerInvokerWrapper.setReg(true);",
    "output": "Fix register config not take effect because of url simplified"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java\n@@ -484,7 +484,6 @@ public static boolean isProvider(URL url) {\n                 PROVIDERS_CATEGORY.equals(url.getParameter(CATEGORY_KEY, PROVIDERS_CATEGORY));\n     }\n-\n     /**\n      * Check if the given value matches the given pattern. The pattern supports wildcard \"*\".\n      *\ndiff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n@@ -29,6 +29,7 @@\n import org.apache.dubbo.metadata.store.MetadataReportFactory;\n import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.support.ProtocolUtils;\n import java.util.function.Supplier;\n@@ -87,6 +88,9 @@ public static MetadataReportService instance(Supplier<URL> metadataReportUrl) {\n     }\n     public void publishProvider(URL providerUrl) throws RpcException {\n+        if (!needStore(providerUrl)) {\n+            return;\n+        }\n         //first add into the list\n         // remove the individul param\n         providerUrl = providerUrl.removeParameters(PID_KEY, TIMESTAMP_KEY, Constants.BIND_IP_KEY, Constants.BIND_PORT_KEY, TIMESTAMP_KEY);\n@@ -110,10 +114,21 @@ public void publishProvider(URL providerUrl) throws RpcException {\n     }\n     public void publishConsumer(URL consumerURL) throws RpcException {\n+        if (!needStore(consumerURL)) {\n+            return;\n+        }\n         consumerURL = consumerURL.removeParameters(PID_KEY, TIMESTAMP_KEY, Constants.BIND_IP_KEY, Constants.BIND_PORT_KEY, TIMESTAMP_KEY);\n         metadataReport.storeConsumerMetadata(new MetadataIdentifier(consumerURL.getServiceInterface(),\n                 consumerURL.getParameter(VERSION_KEY), consumerURL.getParameter(GROUP_KEY), CONSUMER_SIDE,\n                 consumerURL.getParameter(APPLICATION_KEY)), consumerURL.getParameters());\n     }\n+    private boolean needStore(URL url) {\n+        if (!ProtocolUtils.isGeneric(url.getParameter(org.apache.dubbo.rpc.Constants.GENERIC_KEY))) {\n+            logger.debug(\"The metadata is ignored for this service is generic. The service is: \" + url.getParameter(INTERFACE_KEY, \"\"));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n }\ndiff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/integration/MetadataReportServiceTest.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/integration/MetadataReportServiceTest.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/integration/MetadataReportServiceTest.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/integration/MetadataReportServiceTest.java\n@@ -121,6 +121,30 @@ public void testPublishConsumer() throws InterruptedException {\n     }\n+    @Test\n+    public void testIgnorePublishProvider() throws InterruptedException {\n+        URL publishUrl = URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":4444/org.apache.dubbo.TestService?version=1.0.3&application=vicpubp&generic=true&interface=org.apache.dubbo.metadata.integration.XXXX&side=provider\");\n+        metadataReportService1.publishProvider(publishUrl);\n+        Thread.sleep(300);\n+\n+        JTestMetadataReport4Test jTestMetadataReport4Test = (JTestMetadataReport4Test) metadataReportService1.metadataReport;\n+\n+        String value = jTestMetadataReport4Test.store.get(JTestMetadataReport4Test.getProviderKey(publishUrl));\n+        Assertions.assertNull(value);\n+    }\n+\n+    @Test\n+    public void testIgnorePublishConsumer() throws InterruptedException {\n+        URL publishUrl = URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":4444/org.apache.dubbo.XXXService?version=1.0.x&application=vicpubconsumer&generic=true&side=consumer\");\n+        metadataReportService1.publishConsumer(publishUrl);\n+        Thread.sleep(300);\n+\n+        JTestMetadataReport4Test jTestMetadataReport4Test = (JTestMetadataReport4Test) metadataReportService1.metadataReport;\n+\n+        String value = jTestMetadataReport4Test.store.get(JTestMetadataReport4Test.getConsumerKey(publishUrl));\n+        Assertions.assertNull(value);\n+    }\n+\n     private FullServiceDefinition toServiceDefinition(String urlQuery) {\n         Gson gson = new Gson();\n         return gson.fromJson(urlQuery, FullServiceDefinition.class);",
    "output": "Fix generic impl does not support metadata report"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-native-thrift/src/main/java/org/apache/dubbo/rpc/protocol/nativethrift/ThriftProtocol.java b/dubbo-rpc/dubbo-rpc-native-thrift/src/main/java/org/apache/dubbo/rpc/protocol/nativethrift/ThriftProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-native-thrift/src/main/java/org/apache/dubbo/rpc/protocol/nativethrift/ThriftProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-native-thrift/src/main/java/org/apache/dubbo/rpc/protocol/nativethrift/ThriftProtocol.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.remoting.Constants;\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.protocol.AbstractProxyProtocol;\n@@ -39,8 +40,11 @@\n import java.util.HashMap;\n import java.util.Map;\n+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n+\n /**\n- *  native thrift protocol\n+ * native thrift protocol\n  */\n public class ThriftProtocol extends AbstractProxyProtocol {\n@@ -54,15 +58,19 @@ public class ThriftProtocol extends AbstractProxyProtocol {\n     private static final Map<String, TServer> serverMap = new HashMap<>();\n     private TMultiplexedProcessor processor = new TMultiplexedProcessor();\n+    public ThriftProtocol() {\n+        super(TException.class, RpcException.class);\n+    }\n+\n+    public ThriftProtocol(Class<?>... exceptions) {\n+        super(exceptions);\n+    }\n+\n     @Override\n     public int getDefaultPort() {\n         return DEFAULT_PORT;\n     }\n-    public ThriftProtocol() {\n-        super(TException.class, RpcException.class);\n-    }\n-\n     @Override\n     protected <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException {\n         return exportThreadedSelectorServer(impl, type, url);\n@@ -73,10 +81,6 @@ protected <T> T doRefer(Class<T> type, URL url) throws RpcException {\n         return doReferFrameAndCompact(type, url);\n     }\n-    public ThriftProtocol(Class<?>... exceptions) {\n-        super(exceptions);\n-    }\n-\n     private <T> Runnable exportThreadedSelectorServer(T impl, Class<T> type, URL url) throws RpcException {\n         TThreadedSelectorServer.Args tArgs = null;\n@@ -89,15 +93,22 @@ private <T> Runnable exportThreadedSelectorServer(T impl, Class<T> type, URL url\n                 Constructor constructor = clazz.getConstructor(type);\n                 try {\n                     TProcessor tprocessor = (TProcessor) constructor.newInstance(impl);\n-                    processor.registerProcessor(typeName,tprocessor);\n+                    processor.registerProcessor(typeName, tprocessor);\n-                    if(serverMap.get(url.getAddress()) == null) {\n+                    if (serverMap.get(url.getAddress()) == null) {\n                         /**Solve the problem of only 50 of the default number of concurrent connections*/\n                         TNonblockingServerSocket.NonblockingAbstractServerSocketArgs args = new TNonblockingServerSocket.NonblockingAbstractServerSocketArgs();\n                         /**1000 connections*/\n                         args.backlog(1000);\n-                        args.bindAddr(new InetSocketAddress(url.getHost(), url.getPort()));\n+\n+                        String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());\n+                        if (url.getParameter(ANYHOST_KEY, false)) {\n+                            bindIp = ANYHOST_VALUE;\n+                        }\n+                        int bindPort = url.getParameter(Constants.BIND_PORT_KEY, url.getPort());\n+                        args.bindAddr(new InetSocketAddress(bindIp, bindPort));\n+\n                         /**timeout: 10s */\n                         args.clientTimeout(10000);\n@@ -110,7 +121,7 @@ private <T> Runnable exportThreadedSelectorServer(T impl, Class<T> type, URL url\n                         tArgs.processor(processor);\n                         tArgs.transportFactory(new TFramedTransport.Factory());\n                         tArgs.protocolFactory(new TCompactProtocol.Factory());\n-                    }else{\n+                    } else {\n                         return null; // if server is starting, return and do nothing here\n                     }\n                 } catch (Exception e) {\n@@ -127,8 +138,8 @@ private <T> Runnable exportThreadedSelectorServer(T impl, Class<T> type, URL url\n             logger.error(\"Fail to create nativethrift server(\" + url + \") due to null args\");\n             throw new RpcException(\"Fail to create nativethrift server(\" + url + \") due to null args\");\n         }\n-        final TServer thriftServer =  new TThreadedSelectorServer(tArgs);\n-        serverMap.put(url.getAddress(),thriftServer);\n+        final TServer thriftServer = new TThreadedSelectorServer(tArgs);\n+        serverMap.put(url.getAddress(), thriftServer);\n         new Thread(() -> {\n             logger.info(\"Start Thrift ThreadedSelectorServer\");\n@@ -159,7 +170,7 @@ private <T> T doReferFrameAndCompact(Class<T> type, URL url) throws RpcException\n                     TSocket tSocket = new TSocket(url.getHost(), url.getPort());\n                     TTransport transport = new TFramedTransport(tSocket);\n                     TProtocol tprotocol = new TCompactProtocol(transport);\n-                    TMultiplexedProtocol protocol = new TMultiplexedProtocol(tprotocol,typeName);\n+                    TMultiplexedProtocol protocol = new TMultiplexedProtocol(tprotocol, typeName);\n                     thriftClient = (T) constructor.newInstance(protocol);\n                     transport.open();\n                     logger.info(\"nativethrift client opened for service(\" + url + \")\");",
    "output": "Fix native-thrift cannot run within docker instance #4445"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java\n@@ -48,9 +48,9 @@ protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation\n         int[] leastIndexes = new int[length];\n         // the weight of every invokers\n         int[] weights = new int[length];\n-        // The sum of the warmup weights of all the least active invokes\n+        // The sum of the warmup weights of all the least active invokers\n         int totalWeight = 0;\n-        // The weight of the first least active invoke\n+        // The weight of the first least active invoker\n         int firstWeight = 0;\n         // Every least active invoker has the same weight value?\n         boolean sameWeight = true;\n@@ -59,9 +59,9 @@ protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation\n         // Filter out all the least active invokers\n         for (int i = 0; i < length; i++) {\n             Invoker<T> invoker = invokers.get(i);\n-            // Get the active number of the invoke\n+            // Get the active number of the invoker\n             int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();\n-            // Get the weight of the invoke configuration. The default value is 100.\n+            // Get the weight of the invoker's configuration. The default value is 100.\n             int afterWarmup = getWeight(invoker, invocation);\n             // save for later use\n             weights[i] = afterWarmup;\n@@ -113,4 +113,4 @@ protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation\n         // If all invokers have the same weight value or totalWeight=0, return evenly.\n         return invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Fix some typos in LeastActiveLoadBalance"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.URLBuilder;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.StringUtils;\n@@ -29,7 +30,6 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.LinkedHashSet;\n import java.util.LinkedList;\n@@ -60,6 +60,7 @@\n import static org.apache.dubbo.common.constants.RegistryConstants.CONFIGURATORS_CATEGORY;\n import static org.apache.dubbo.common.constants.RegistryConstants.CONSUMERS_CATEGORY;\n import static org.apache.dubbo.common.constants.RegistryConstants.DEFAULT_CATEGORY;\n+import static org.apache.dubbo.common.constants.RegistryConstants.EMPTY_PROTOCOL;\n import static org.apache.dubbo.common.constants.RegistryConstants.PROVIDERS_CATEGORY;\n import static org.apache.dubbo.common.constants.RegistryConstants.ROUTERS_CATEGORY;\n import static org.apache.dubbo.registry.Constants.ADMIN_PROTOCOL;\n@@ -370,15 +371,26 @@ private List<String> doGetServiceNames(URL url) {\n         return serviceNames;\n     }\n-    private List<URL> buildURLs(URL consumerURL, Collection<Instance> instances) {\n-        if (instances.isEmpty()) {\n-            return Collections.emptyList();\n+    private List<URL> toUrlWithEmpty(URL consumerURL, Collection<Instance> instances) {\n+        List<URL> urls = buildURLs(consumerURL, instances);\n+        if (urls.size() == 0) {\n+            URL empty = URLBuilder.from(consumerURL)\n+                    .setProtocol(EMPTY_PROTOCOL)\n+                    .addParameter(CATEGORY_KEY, DEFAULT_CATEGORY)\n+                    .build();\n+            urls.add(empty);\n         }\n+        return urls;\n+    }\n+\n+    private List<URL> buildURLs(URL consumerURL, Collection<Instance> instances) {\n         List<URL> urls = new LinkedList<>();\n-        for (Instance instance : instances) {\n-            URL url = buildURL(instance);\n-            if (UrlUtils.isMatch(consumerURL, url)) {\n-                urls.add(url);\n+        if (instances != null && !instances.isEmpty()) {\n+            for (Instance instance : instances) {\n+                URL url = buildURL(instance);\n+                if (UrlUtils.isMatch(consumerURL, url)) {\n+                    urls.add(url);\n+                }\n             }\n         }\n         return urls;\n@@ -407,9 +419,11 @@ private void subscribeEventListener(String serviceName, final URL url, final Not\n      */\n     private void notifySubscriber(URL url, NotifyListener listener, Collection<Instance> instances) {\n         List<Instance> healthyInstances = new LinkedList<>(instances);\n-        // Healthy Instances\n-        filterHealthyInstances(healthyInstances);\n-        List<URL> urls = buildURLs(url, healthyInstances);\n+        if (healthyInstances.size() > 0) {\n+            // Healthy Instances\n+            filterHealthyInstances(healthyInstances);\n+        }\n+        List<URL> urls = toUrlWithEmpty(url, healthyInstances);\n         NacosRegistry.this.notify(url, listener, urls);\n     }",
    "output": "Make RegistryDirectory can refresh the invokers when providers number become 0 when using nacos registry * make RegistryDirectory can refresh the invokers when providers number become 0 when using nacos registry * make RegistryDirectory can refresh the invokers when providers number become 0 when using nacos registry * make RegistryDirectory can refresh the invokers when providers number become 0 when using nacos registry"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ConsumerContextFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ConsumerContextFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ConsumerContextFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ConsumerContextFilter.java\n@@ -49,8 +49,8 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept\n                 .setInvoker(invoker)\n                 .setInvocation(invocation)\n                 .setLocalAddress(NetUtils.getLocalHost(), 0)\n-                .setRemoteAddress(invoker.getUrl().getHost(),\n-                        invoker.getUrl().getPort())\n+                .setRemoteAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort())\n+                .setRemoteApplicationName(invoker.getUrl().getParameter(REMOTE_APPLICATION_KEY))\n                 .setAttachment(REMOTE_APPLICATION_KEY, invoker.getUrl().getParameter(APPLICATION_KEY));\n         if (invocation instanceof RpcInvocation) {\n             ((RpcInvocation) invocation).setInvoker(invoker);",
    "output": "Make remote application effect on consumer side too"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n@@ -104,7 +104,7 @@ public abstract class AbstractServiceConfig extends AbstractInterfaceConfig {\n     /**\n      * Whether to register\n      */\n-    private Boolean register = true;\n+    private Boolean register;\n     /**\n      * Warm up period\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/Constants.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/Constants.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/Constants.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/Constants.java\n@@ -114,4 +114,6 @@ public interface Constants {\n     String REGISTRIES_SUFFIX = \"dubbo.registries.\";\n     String ZOOKEEPER_PROTOCOL = \"zookeeper\";\n+\n+    String REGISTER_KEY = \"register\";\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -75,6 +75,7 @@\n import static org.apache.dubbo.config.Constants.DUBBO_IP_TO_REGISTRY;\n import static org.apache.dubbo.config.Constants.DUBBO_PORT_TO_BIND;\n import static org.apache.dubbo.config.Constants.DUBBO_PORT_TO_REGISTRY;\n+import static org.apache.dubbo.config.Constants.REGISTER_KEY;\n import static org.apache.dubbo.rpc.cluster.Constants.EXPORT_KEY;\n import static org.apache.dubbo.config.Constants.MULTICAST;\n import static org.apache.dubbo.config.Constants.PROTOCOLS_SUFFIX;\n@@ -577,9 +578,6 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n             }\n             // export to remote if the config is not local (export to local only when config is local)\n             if (!SCOPE_LOCAL.equalsIgnoreCase(scope)) {\n-                if (!isOnlyInJvm() && logger.isInfoEnabled()) {\n-                    logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url);\n-                }\n                 if (CollectionUtils.isNotEmpty(registryURLs)) {\n                     for (URL registryURL : registryURLs) {\n                         //if protocol is only injvm ,not register\n@@ -592,7 +590,11 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n                             url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());\n                         }\n                         if (logger.isInfoEnabled()) {\n-                            logger.info(\"Register dubbo service \" + interfaceClass.getName() + \" url \" + url + \" to registry \" + registryURL);\n+                            if (url.getParameter(REGISTER_KEY, true)) {\n+                                logger.info(\"Register dubbo service \" + interfaceClass.getName() + \" url \" + url + \" to registry \" + registryURL);\n+                            } else {\n+                                logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url);\n+                            }\n                         }\n                         // For providers, this is used to enable custom proxy to generate invoker\n@@ -608,6 +610,9 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n                         exporters.add(exporter);\n                     }\n                 } else {\n+                    if (logger.isInfoEnabled()) {\n+                        logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url);\n+                    }\n                     Invoker<?> invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);\n                     DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);",
    "output": "Fix protocol register set false not work"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-apollo/src/test/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfigurationTest.java b/dubbo-configcenter/dubbo-configcenter-apollo/src/test/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfigurationTest.java\n--- a/dubbo-configcenter/dubbo-configcenter-apollo/src/test/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfigurationTest.java\n+++ b/dubbo-configcenter/dubbo-configcenter-apollo/src/test/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfigurationTest.java\n@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.configcenter.support.apollo;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Properties;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.ctrip.framework.apollo.mockserver.EmbeddedApollo;\n+import com.google.common.util.concurrent.SettableFuture;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.configcenter.ConfigChangeType;\n+import org.apache.dubbo.configcenter.ConfigurationListener;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Apollo dynamic configuration mock test.\n+ * Notice: EmbeddedApollo(apollo mock server) only support < junit5, please not upgrade the junit version in this UT,\n+ * the junit version in this UT is junit4, and the dependency comes from apollo-mockserver.\n+ */\n+public class ApolloDynamicConfigurationTest {\n+    private static final String SESSION_TIMEOUT_KEY = \"session\";\n+    private static final String DEFAULT_NAMESPACE = \"dubbo\";\n+    private static ApolloDynamicConfiguration apolloDynamicConfiguration;\n+    private static URL url;\n+\n+    /**\n+     * The constant embeddedApollo.\n+     */\n+    @ClassRule\n+    public static EmbeddedApollo embeddedApollo = new EmbeddedApollo();\n+\n+    /**\n+     * Sets up.\n+     */\n+    @Before\n+    public void setUp() {\n+        String apolloUrl = System.getProperty(\"apollo.configService\");\n+        String urlForDubbo = \"apollo://\" + apolloUrl.substring(apolloUrl.lastIndexOf(\"/\") + 1) + \"/org.apache.dubbo.apollo.testService?config.namespace=dubbo\";\n+        url = URL.valueOf(urlForDubbo).addParameter(SESSION_TIMEOUT_KEY, 15000);\n+    }\n+\n+    /**\n+     * Test get rule.\n+     */\n+    @Test\n+    public void testGetRule() {\n+        String mockKey = \"mockKey1\";\n+        String mockValue = String.valueOf(new Random().nextInt());\n+        putMockRuleData(mockKey, mockValue, DEFAULT_NAMESPACE);\n+        apolloDynamicConfiguration = new ApolloDynamicConfiguration(url);\n+        assertEquals(mockValue, apolloDynamicConfiguration.getRule(mockKey, DEFAULT_NAMESPACE, 3000L));\n+\n+        mockKey = \"notExistKey\";\n+        assertNull(apolloDynamicConfiguration.getRule(mockKey, DEFAULT_NAMESPACE, 3000L));\n+    }\n+\n+    /**\n+     * Test get internal property.\n+     *\n+     * @throws InterruptedException the interrupted exception\n+     */\n+    @Test\n+    public void testGetInternalProperty() throws InterruptedException {\n+        String mockKey = \"mockKey2\";\n+        String mockValue = String.valueOf(new Random().nextInt());\n+        putMockRuleData(mockKey, mockValue, DEFAULT_NAMESPACE);\n+        TimeUnit.MILLISECONDS.sleep(1000);\n+        apolloDynamicConfiguration = new ApolloDynamicConfiguration(url);\n+        assertEquals(mockValue, apolloDynamicConfiguration.getInternalProperty(mockKey));\n+\n+        mockValue = \"mockValue2\";\n+        System.setProperty(mockKey, mockValue);\n+        assertEquals(mockValue, apolloDynamicConfiguration.getInternalProperty(mockKey));\n+\n+        mockKey = \"notExistKey\";\n+        assertNull(apolloDynamicConfiguration.getInternalProperty(mockKey));\n+    }\n+\n+    /**\n+     * Test add listener.\n+     *\n+     * @throws Exception the exception\n+     */\n+    @Test\n+    public void testAddListener() throws Exception {\n+        String mockKey = \"mockKey3\";\n+        String mockValue = String.valueOf(new Random().nextInt());\n+\n+        final SettableFuture<org.apache.dubbo.configcenter.ConfigChangeEvent> future = SettableFuture.create();\n+\n+        apolloDynamicConfiguration = new ApolloDynamicConfiguration(url);\n+\n+        apolloDynamicConfiguration.addListener(mockKey, DEFAULT_NAMESPACE, new ConfigurationListener() {\n+            @Override\n+            public void process(org.apache.dubbo.configcenter.ConfigChangeEvent event) {\n+                future.set(event);\n+            }\n+        });\n+\n+        putData(mockKey, mockValue);\n+        org.apache.dubbo.configcenter.ConfigChangeEvent result = future.get(3000, TimeUnit.MILLISECONDS);\n+        assertEquals(mockValue, result.getValue());\n+        assertEquals(mockKey, result.getKey());\n+        assertEquals(ConfigChangeType.MODIFIED, result.getChangeType());\n+    }\n+\n+    private static void putData(String key, String value) {\n+        embeddedApollo.addOrModifyProperty(DEFAULT_NAMESPACE, key, value);\n+    }\n+\n+    private static void putMockRuleData(String key, String value, String group) {\n+        String fileName = ApolloDynamicConfigurationTest.class.getResource(\"/\").getPath() + \"mockdata-\" + group + \".properties\";\n+        putMockData(key, value, fileName);\n+    }\n+\n+    private static void putMockData(String key, String value, String fileName) {\n+        Properties pro = new Properties();\n+        FileOutputStream oFile = null;\n+        try {\n+            oFile = new FileOutputStream(fileName);\n+            pro.setProperty(key, value);\n+            pro.store(oFile, \"put mock data\");\n+        } catch (IOException exx) {\n+            fail(exx.getMessage());\n+\n+        } finally {\n+            if (null != oFile) {\n+                try {\n+                    oFile.close();\n+                } catch (IOException e) {\n+                    fail(e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tear down.\n+     */\n+    @After\n+    public void tearDown() {\n+\n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Add Apollo config center mock test * add Apollo config center mock test"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -38,6 +38,7 @@\n import org.apache.dubbo.rpc.cluster.support.ClusterUtils;\n import org.apache.dubbo.rpc.cluster.support.RegistryAwareCluster;\n import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.ConsumerMethodModel;\n import org.apache.dubbo.rpc.model.ConsumerModel;\n import org.apache.dubbo.rpc.model.ServiceMetadata;\n import org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol;\n@@ -337,7 +338,11 @@ private void init() {\n                         map.put(methodConfig.getName() + \".retries\", \"0\");\n                     }\n                 }\n-                attributes.put(methodConfig.getName(), convertMethodConfig2AsyncInfo(methodConfig));\n+                ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = convertMethodConfig2AsyncInfo(methodConfig);\n+                if (asyncMethodInfo != null) {\n+//                    consumerModel.getMethodModel(methodConfig.getName()).addAttribute(ASYNC_KEY, asyncMethodInfo);\n+                    attributes.put(methodConfig.getName(), asyncMethodInfo);\n+                }\n             }\n         }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerMethodModel.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerMethodModel.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerMethodModel.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerMethodModel.java\n@@ -19,6 +19,8 @@\n import java.lang.reflect.Method;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n import static org.apache.dubbo.rpc.Constants.$INVOKE;\n@@ -33,6 +35,7 @@ public class ConsumerMethodModel {\n     private final boolean generic;\n     private final AsyncMethodInfo asyncInfo;\n+    private final ConcurrentMap<String, Object> attributeMap = new ConcurrentHashMap<>();\n     public ConsumerMethodModel(Method method, Map<String, Object> attributes) {\n@@ -48,12 +51,26 @@ public ConsumerMethodModel(Method method, Map<String, Object> attributes) {\n         } else {\n             asyncInfo = null;\n         }\n+\n     }\n     public Method getMethod() {\n         return method;\n     }\n+//    public ConcurrentMap<String, Object> getAttributeMap() {\n+//        return attributeMap;\n+//    }\n+\n+    public void addAttribute(String key, Object value) {\n+        this.attributeMap.put(key, value);\n+    }\n+\n+    public Object getAttribute(String key) {\n+        return this.attributeMap.get(key);\n+    }\n+\n+\n     public Class<?> getReturnClass() {\n         return returnClass;\n     }",
    "output": "Add Model getAttachment method back"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/MixinTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/MixinTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/MixinTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/MixinTest.java\n@@ -18,7 +18,6 @@\n import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n public class MixinTest {\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n@@ -20,7 +20,6 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n-import java.util.Objects;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java\n@@ -43,7 +43,6 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.not;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n public class MethodConfigTest {\n     @Test\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java b/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/filter/LegacyInvocation.java\n@@ -19,16 +19,15 @@\n import com.alibaba.dubbo.rpc.Invocation;\n import com.alibaba.dubbo.rpc.Invoker;\n-import org.apache.dubbo.common.Constants;\n import java.util.HashMap;\n import java.util.Map;\n-import static org.apache.dubbo.remoting.Constants.DUBBO_VERSION_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n+import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n+import static org.apache.dubbo.remoting.Constants.DUBBO_VERSION_KEY;\n import static org.apache.dubbo.rpc.Constants.TOKEN_KEY;\n /**\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n@@ -44,7 +44,6 @@\n import org.apache.dubbo.rpc.Filter;\n import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcException;\n-import org.apache.dubbo.rpc.service.GenericException;\n import org.apache.dubbo.rpc.service.GenericService;\n import org.junit.Assert;\n@@ -57,6 +56,8 @@\n import java.util.Collection;\n import java.util.List;\n+import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;\n+import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_BEAN;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n@@ -65,9 +66,6 @@\n import static org.junit.Assert.fail;\n import static org.junit.matchers.JUnitMatchers.containsString;\n-import static org.apache.dubbo.rpc.Constants.GENERIC_SERIALIZATION_BEAN;\n-import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;\n-\n /**\n  * ConfigTest\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java\n@@ -17,7 +17,6 @@\n package org.apache.dubbo.config.spring.beans.factory.annotation;\n import org.apache.dubbo.config.spring.ServiceBean;\n-import org.apache.dubbo.config.spring.api.DemoService;\n import org.apache.dubbo.config.spring.api.HelloService;\n import org.junit.Assert;\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/config/YamlPropertySourceFactory.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/config/YamlPropertySourceFactory.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/config/YamlPropertySourceFactory.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/config/YamlPropertySourceFactory.java\n@@ -30,7 +30,6 @@\n import java.io.IOException;\n import java.util.LinkedHashMap;\n import java.util.Map;\n-import java.util.Properties;\n import java.util.regex.Pattern;\n /**\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n@@ -36,7 +36,6 @@\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n-import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\n import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_CLIENT_THREADPOOL;\n import static org.apache.dubbo.common.constants.CommonConstants.THREADPOOL_KEY;\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractServer.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractServer.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractServer.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractServer.java\n@@ -35,11 +35,10 @@\n import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n-import static org.apache.dubbo.common.constants.CommonConstants.THREADS_KEY;\n-import static org.apache.dubbo.remoting.Constants.IDLE_TIMEOUT_KEY;\n-import static org.apache.dubbo.remoting.Constants.DEFAULT_IDLE_TIMEOUT;\n import static org.apache.dubbo.remoting.Constants.ACCEPTS_KEY;\n import static org.apache.dubbo.remoting.Constants.DEFAULT_ACCEPTS;\n+import static org.apache.dubbo.remoting.Constants.DEFAULT_IDLE_TIMEOUT;\n+import static org.apache.dubbo.remoting.Constants.IDLE_TIMEOUT_KEY;\n /**\n  * AbstractServer\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AppResponse.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AppResponse.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AppResponse.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AppResponse.java\n@@ -17,9 +17,6 @@\n package org.apache.dubbo.rpc;\n import java.io.Serializable;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.function.Function;\n import java.lang.reflect.Field;\n import java.util.HashMap;\n import java.util.Map;",
    "output": "Remove unused imports"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java\n@@ -39,6 +39,9 @@ public class TypeDefinition {\n     private Map<String, TypeDefinition> properties;\n     private String typeBuilderName;\n+    public TypeDefinition() {\n+    }\n+\n     public TypeDefinition(String type) {\n         this.type = type;\n     }",
    "output": "Add the no-arguments construct for TypeDefinition #4982"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/threadlocal/InternalThreadLocalTest.java\n@@ -20,7 +20,6 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n-import java.util.Objects;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n@@ -44,7 +44,6 @@\n import org.apache.dubbo.rpc.Filter;\n import org.apache.dubbo.rpc.RpcContext;\n import org.apache.dubbo.rpc.RpcException;\n-import org.apache.dubbo.rpc.service.GenericException;\n import org.apache.dubbo.rpc.service.GenericService;\n import org.junit.Assert;\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java\n@@ -17,7 +17,6 @@\n package org.apache.dubbo.config.spring.beans.factory.annotation;\n import org.apache.dubbo.config.spring.ServiceBean;\n-import org.apache.dubbo.config.spring.api.DemoService;\n import org.apache.dubbo.config.spring.api.HelloService;\n import org.junit.Assert;\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/config/YamlPropertySourceFactory.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/config/YamlPropertySourceFactory.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/config/YamlPropertySourceFactory.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/config/YamlPropertySourceFactory.java\n@@ -30,7 +30,6 @@\n import java.io.IOException;\n import java.util.LinkedHashMap;\n import java.util.Map;\n-import java.util.Properties;\n import java.util.regex.Pattern;\n /**",
    "output": "Remove unused import for unit test * clear unused import"
  },
  {
    "input": "diff --git a/dubbo-bootstrap/src/test/java/org/apache/dubbo/bootstrap/DubboServiceConsumerBootstrap.java b/dubbo-bootstrap/src/test/java/org/apache/dubbo/bootstrap/DubboServiceConsumerBootstrap.java\n--- a/dubbo-bootstrap/src/test/java/org/apache/dubbo/bootstrap/DubboServiceConsumerBootstrap.java\n+++ b/dubbo-bootstrap/src/test/java/org/apache/dubbo/bootstrap/DubboServiceConsumerBootstrap.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.dubbo.bootstrap;\n+import org.apache.dubbo.bootstrap.rest.UserService;\n+import org.apache.dubbo.config.MetadataReportConfig;\n import org.apache.dubbo.config.ReferenceConfig;\n import org.apache.dubbo.config.context.ConfigManager;\n@@ -33,7 +35,7 @@ public static void main(String[] args) throws Exception {\n                 .protocol(builder -> builder.port(20887).name(\"dubbo\"))\n                 // Zookeeper\n                 .registry(\"zookeeper\", builder -> builder.address(\"zookeeper://127.0.0.1:2181?registry.type=service&subscribed.services=dubbo-provider-demo\"))\n-//                .metadataReport(new MetadataReportConfig(\"zookeeper://127.0.0.1:2181\"))\n+                .metadataReport(new MetadataReportConfig(\"zookeeper://127.0.0.1:2181\"))\n                 // Nacos\n //                .registry(\"nacos\", builder -> builder.address(\"nacos://127.0.0.1:8848?registry.type=service&subscribed.services=dubbo-provider-demo\"))\n //                .registry(\"consul\", builder -> builder.address(\"consul://127.0.0.1:8500?registry.type=service&subscribed.services=dubbo-provider-demo\").group(\"namespace1\"))\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java\n@@ -25,7 +25,6 @@\n import org.apache.dubbo.config.ProtocolConfig;\n import org.apache.dubbo.config.ProviderConfig;\n import org.apache.dubbo.config.RegistryConfig;\n-import org.apache.dubbo.config.spring.ApplicationBean;\n import org.apache.dubbo.config.spring.ConfigCenterBean;\n import org.apache.dubbo.config.spring.ReferenceBean;\n import org.apache.dubbo.config.spring.ServiceBean;\n@@ -51,7 +50,6 @@ public class DubboNamespaceHandler extends NamespaceHandlerSupport implements Co\n     @Override\n     public void init() {\n-        registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationBean.class, true));\n         registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true));\n         registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true));\n         registerBeanDefinitionParser(\"config-center\", new DubboBeanDefinitionParser(ConfigCenterBean.class, true));\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java\n@@ -17,8 +17,6 @@\n package org.apache.dubbo.registry.client.metadata;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.config.ApplicationConfig;\n-import org.apache.dubbo.config.context.ConfigManager;\n import org.apache.dubbo.metadata.MetadataService;\n import org.apache.dubbo.metadata.WritableMetadataService;\n import org.apache.dubbo.registry.client.ServiceInstance;\n@@ -189,34 +187,22 @@ public static String getSubscribedServicesRevision(ServiceInstance serviceInstan\n      *\n      * @param registryURL the {@link URL} to connect the registry\n      * @return if not found in {@link URL#getParameters() parameters} of {@link URL registry URL}, return\n-     * {@link #getDefaultMetadataStorageType()}\n+     * {@link WritableMetadataService#DEFAULT_METADATA_STORAGE_TYPE}\n      */\n     public static String getMetadataStorageType(URL registryURL) {\n-        return registryURL.getParameter(METADATA_STORAGE_TYPE_KEY, getDefaultMetadataStorageType());\n+        return registryURL.getParameter(METADATA_STORAGE_TYPE_KEY, DEFAULT_METADATA_STORAGE_TYPE);\n     }\n     /**\n      * Get the metadata's storage type is used to which {@link WritableMetadataService} instance.\n      *\n      * @param serviceInstance the specified {@link ServiceInstance}\n      * @return if not found in {@link ServiceInstance#getMetadata() metadata} of {@link ServiceInstance}, return\n-     * {@link #getDefaultMetadataStorageType()}\n+     * {@link WritableMetadataService#DEFAULT_METADATA_STORAGE_TYPE}\n      */\n     public static String getMetadataStorageType(ServiceInstance serviceInstance) {\n         Map<String, String> metadata = serviceInstance.getMetadata();\n-        return metadata.getOrDefault(METADATA_STORAGE_TYPE_KEY, getDefaultMetadataStorageType());\n-    }\n-\n-    /**\n-     * Get the default Metadata storage type from {@link ApplicationConfig} if present, or\n-     * {@link WritableMetadataService#DEFAULT_METADATA_STORAGE_TYPE \"default\"}\n-     *\n-     * @return non-null\n-     */\n-    public static String getDefaultMetadataStorageType() {\n-        return ConfigManager.getInstance().getApplication()\n-                .map(ApplicationConfig::getMetadataType)\n-                .orElse(DEFAULT_METADATA_STORAGE_TYPE);\n+        return metadata.getOrDefault(METADATA_STORAGE_TYPE_KEY, DEFAULT_METADATA_STORAGE_TYPE);\n     }\n     /**",
    "output": "Fix conflicts after merged master"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n@@ -76,10 +76,7 @@ int getWeight(Invoker<?> invoker, Invocation invocation) {\n             long timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, 0L);\n             if (timestamp > 0L) {\n                 long uptime = System.currentTimeMillis() - timestamp;\n-                if (uptime >= Integer.MAX_VALUE) {\n-                    return weight;\n-                }\n-                else if (uptime < 0) {\n+                if (uptime < 0) {\n                     return 1;\n                 }\n                 int warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);\n@@ -90,5 +87,4 @@ else if (uptime < 0) {\n         }\n         return Math.max(weight, 0);\n     }\n-\n }\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalanceTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalanceTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalanceTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalanceTest.java\n@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.loadbalance;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcInvocation;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+\n+public class AbstractLoadBalanceTest {\n+\n+    private AbstractLoadBalance balance = new AbstractLoadBalance() {\n+        @Override\n+        protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n+            return null;\n+        }\n+    };\n+\n+    @Test\n+    public void testGetWeight() {\n+        RpcInvocation invocation = new RpcInvocation();\n+        invocation.setMethodName(\"say\");\n+\n+        Invoker invoker1 = mock(Invoker.class, Mockito.withSettings().stubOnly());\n+        URL url1 = new URL(\"\", \"\", 0, new HashMap<>());\n+        url1 = url1.addParameter(TIMESTAMP_KEY, System.currentTimeMillis() - Integer.MAX_VALUE - 1);\n+        given(invoker1.getUrl()).willReturn(url1);\n+\n+        Invoker invoker2 = mock(Invoker.class, Mockito.withSettings().stubOnly());\n+        URL url2 = new URL(\"\", \"\", 0, new HashMap<>());\n+        url2 = url2.addParameter(TIMESTAMP_KEY, System.currentTimeMillis() - 10 * 60 * 1000L - 1);\n+        given(invoker2.getUrl()).willReturn(url2);\n+\n+        Assertions.assertEquals(balance.getWeight(invoker1, invocation), balance.getWeight(invoker2, invocation));\n+    }\n+}",
    "output": "Remove useless if check of max value of Integer"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Constants.java\n@@ -89,8 +89,6 @@ public interface Constants {\n     String RUNTIME_KEY = \"runtime\";\n-    String REMOTE_TIMESTAMP_KEY = \"remote.timestamp\";\n-\n     String WARMUP_KEY = \"warmup\";\n     int DEFAULT_WARMUP = 10 * 60 * 1000;\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n@@ -24,9 +24,9 @@\n import java.util.List;\n+import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n import static org.apache.dubbo.rpc.cluster.Constants.DEFAULT_WARMUP;\n import static org.apache.dubbo.rpc.cluster.Constants.DEFAULT_WEIGHT;\n-import static org.apache.dubbo.rpc.cluster.Constants.REMOTE_TIMESTAMP_KEY;\n import static org.apache.dubbo.rpc.cluster.Constants.WARMUP_KEY;\n import static org.apache.dubbo.rpc.cluster.Constants.WEIGHT_KEY;\n@@ -73,12 +73,18 @@ public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invo\n     int getWeight(Invoker<?> invoker, Invocation invocation) {\n         int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);\n         if (weight > 0) {\n-            long timestamp = invoker.getUrl().getParameter(REMOTE_TIMESTAMP_KEY, 0L);\n+            long timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, 0L);\n             if (timestamp > 0L) {\n-                int uptime = (int) (System.currentTimeMillis() - timestamp);\n+                long uptime = System.currentTimeMillis() - timestamp;\n+                if (uptime >= Integer.MAX_VALUE) {\n+                    return weight;\n+                }\n+                else if (uptime < 0) {\n+                    return 1;\n+                }\n                 int warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);\n                 if (uptime > 0 && uptime < warmup) {\n-                    weight = calculateWarmupWeight(uptime, warmup, weight);\n+                    weight = calculateWarmupWeight((int)uptime, warmup, weight);\n                 }\n             }\n         }",
    "output": "Fix warm up issue when provider's timestamp is bigger than local machine's timestamp. * Fix warm up issue when provider's timestamp is bigger than local machine's timestamp. * Remove unused constant: `REMOTE_TIMESTAMP_KEY`"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java\n@@ -81,10 +81,16 @@ public static URL mergeUrl(URL remoteUrl, Map<String, String> localMap) {\n         if (localMap != null && localMap.size() > 0) {\n             Map<String, String> copyOfLocalMap = new HashMap<>(localMap);\n-            copyOfLocalMap.remove(GROUP_KEY);\n+\n+            if(map.containsKey(GROUP_KEY)){\n+                copyOfLocalMap.remove(GROUP_KEY);\n+            }\n+            if(map.containsKey(VERSION_KEY)){\n+                copyOfLocalMap.remove(VERSION_KEY);\n+            }\n+\n             copyOfLocalMap.remove(RELEASE_KEY);\n             copyOfLocalMap.remove(DUBBO_VERSION_KEY);\n-            copyOfLocalMap.remove(VERSION_KEY);\n             copyOfLocalMap.remove(METHODS_KEY);\n             copyOfLocalMap.remove(TIMESTAMP_KEY);\n             copyOfLocalMap.remove(TAG_KEY);\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/ClusterUtilsTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/ClusterUtilsTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/ClusterUtilsTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/ClusterUtilsTest.java\n@@ -133,8 +133,8 @@ public void testUseProviderParams() {\n         remoteURL = URL.valueOf(\"dubbo://localhost:20880/DemoService\");\n         mergedUrl = ClusterUtils.mergeUrl(remoteURL, localURL.getParameters());\n-        Assertions.assertNull(mergedUrl.getParameter(VERSION_KEY));\n-        Assertions.assertNull(mergedUrl.getParameter(GROUP_KEY));\n+        Assertions.assertEquals(mergedUrl.getParameter(VERSION_KEY),localURL.getParameter(VERSION_KEY));\n+        Assertions.assertEquals(mergedUrl.getParameter(GROUP_KEY),localURL.getParameter(GROUP_KEY));\n         Assertions.assertNull(mergedUrl.getParameter(DUBBO_VERSION_KEY));\n         Assertions.assertNull(mergedUrl.getParameter(RELEASE_KEY));\n         Assertions.assertNull(mergedUrl.getParameter(METHODS_KEY));\n@@ -147,8 +147,8 @@ public void testUseProviderParams() {\n         remoteURL = URL.valueOf(\"dubbo://localhost:20880/DemoService?key=value\");\n         mergedUrl = ClusterUtils.mergeUrl(remoteURL, localURL.getParameters());\n-        Assertions.assertNull(mergedUrl.getParameter(VERSION_KEY));\n-        Assertions.assertNull(mergedUrl.getParameter(GROUP_KEY));\n+        Assertions.assertEquals(mergedUrl.getParameter(VERSION_KEY),localURL.getParameter(VERSION_KEY));\n+        Assertions.assertEquals(mergedUrl.getParameter(GROUP_KEY),localURL.getParameter(GROUP_KEY));\n         Assertions.assertNull(mergedUrl.getParameter(DUBBO_VERSION_KEY));\n         Assertions.assertNull(mergedUrl.getParameter(RELEASE_KEY));\n         Assertions.assertNull(mergedUrl.getParameter(METHODS_KEY));",
    "output": "Fix use generic invocation via API , lost \"version\" value [#4784] * Fix use generic invocation via API , lost \"version\" value [#4784] * Modify unit test"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-multicast/src/test/java/org/apache/dubbo/registry/multicast/MulticastRegistryFactoryTest.java b/dubbo-registry/dubbo-registry-multicast/src/test/java/org/apache/dubbo/registry/multicast/MulticastRegistryFactoryTest.java\n--- a/dubbo-registry/dubbo-registry-multicast/src/test/java/org/apache/dubbo/registry/multicast/MulticastRegistryFactoryTest.java\n+++ b/dubbo-registry/dubbo-registry-multicast/src/test/java/org/apache/dubbo/registry/multicast/MulticastRegistryFactoryTest.java\n@@ -20,7 +20,9 @@\n import org.apache.dubbo.registry.Registry;\n import org.junit.jupiter.api.Test;\n-import static org.hamcrest.CoreMatchers.*;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.nullValue;\n import static org.hamcrest.MatcherAssert.assertThat;\n public class MulticastRegistryFactoryTest {\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/proxy/InvokerInvocationHandlerTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/proxy/InvokerInvocationHandlerTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/proxy/InvokerInvocationHandlerTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/proxy/InvokerInvocationHandlerTest.java\n@@ -26,7 +26,7 @@\n import java.lang.reflect.Method;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.when;\n public class InvokerInvocationHandlerTest {\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResourceTest.java b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResourceTest.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResourceTest.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResourceTest.java\n@@ -30,7 +30,8 @@\n import java.util.HashSet;\n import java.util.Set;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n public class DubboSwaggerApiListingResourceTest {\ndiff --git a/dubbo-serialization/dubbo-serialization-gson/src/test/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectOutputTest.java b/dubbo-serialization/dubbo-serialization-gson/src/test/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectOutputTest.java\n--- a/dubbo-serialization/dubbo-serialization-gson/src/test/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectOutputTest.java\n+++ b/dubbo-serialization/dubbo-serialization-gson/src/test/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectOutputTest.java\n@@ -26,7 +26,9 @@\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n-import static org.hamcrest.CoreMatchers.*;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.nullValue;\n import static org.hamcrest.MatcherAssert.assertThat;\n public class GsonJsonObjectOutputTest {",
    "output": "Use correct import"
  },
  {
    "input": "diff --git a/dubbo-bootstrap/src/test/java/org/apache/dubbo/bootstrap/DubboServiceProviderBootstrap.java b/dubbo-bootstrap/src/test/java/org/apache/dubbo/bootstrap/DubboServiceProviderBootstrap.java\n--- a/dubbo-bootstrap/src/test/java/org/apache/dubbo/bootstrap/DubboServiceProviderBootstrap.java\n+++ b/dubbo-bootstrap/src/test/java/org/apache/dubbo/bootstrap/DubboServiceProviderBootstrap.java\n@@ -19,7 +19,10 @@\n import org.apache.dubbo.bootstrap.rest.UserService;\n import org.apache.dubbo.bootstrap.rest.UserServiceImpl;\n import org.apache.dubbo.config.ProtocolConfig;\n-import org.apache.dubbo.config.builders.RegistryBuilder;\n+import org.apache.dubbo.config.RegistryConfig;\n+import org.apache.dubbo.config.ServiceConfig;\n+\n+import java.util.Arrays;\n /**\n  * Dubbo Provider Bootstrap\n@@ -29,21 +32,46 @@\n public class DubboServiceProviderBootstrap {\n     public static void main(String[] args) {\n+        multipleRegistries();\n+    }\n+\n+    private static void multipleRegistries() {\n         ProtocolConfig restProtocol = new ProtocolConfig();\n         restProtocol.setName(\"rest\");\n         restProtocol.setId(\"rest\");\n         restProtocol.setPort(-1);\n+        RegistryConfig interfaceRegistry = new RegistryConfig();\n+        interfaceRegistry.setId(\"interfaceRegistry\");\n+        interfaceRegistry.setAddress(\"zookeeper://127.0.0.1:2181\");\n+\n+        RegistryConfig serviceRegistry = new RegistryConfig();\n+        serviceRegistry.setId(\"serviceRegistry\");\n+        serviceRegistry.setAddress(\"zookeeper://127.0.0.1:2181?registry-type=service\");\n+\n+        ServiceConfig<EchoService> echoService = new ServiceConfig<>();\n+        echoService.setInterface(EchoService.class.getName());\n+        echoService.setRef(new EchoServiceImpl());\n+//        echoService.setRegistries(Arrays.asList(interfaceRegistry, serviceRegistry));\n+\n+        ServiceConfig<UserService> userService = new ServiceConfig<>();\n+        userService.setInterface(UserService.class.getName());\n+        userService.setRef(new UserServiceImpl());\n+        userService.setProtocol(restProtocol);\n+//        userService.setRegistries(Arrays.asList(interfaceRegistry, serviceRegistry));\n+\n+\n         new DubboBootstrap()\n                 .application(\"dubbo-provider-demo\")\n                 // Zookeeper in service registry type\n //                .registry(\"zookeeper\", builder -> builder.address(\"zookeeper://127.0.0.1:2181?registry-type=service\"))\n                 // Nacos\n //                .registry(\"zookeeper\", builder -> builder.address(\"nacos://127.0.0.1:8848?registry-type=service\"))\n-                .registry(RegistryBuilder.newBuilder().address(\"consul://127.0.0.1:8500?registry-type=service\").build())\n+                .registries(Arrays.asList(interfaceRegistry, serviceRegistry))\n+//                .registry(RegistryBuilder.newBuilder().address(\"consul://127.0.0.1:8500?registry-type=service\").build())\n                 .protocol(builder -> builder.port(-1).name(\"dubbo\"))\n-                .service(builder -> builder.id(\"echo\").interfaceClass(EchoService.class).ref(new EchoServiceImpl()))\n-                .service(builder -> builder.id(\"user\").interfaceClass(UserService.class).ref(new UserServiceImpl()).addProtocol(restProtocol))\n+                .service(echoService)\n+                .service(userService)\n                 .start()\n                 .await();\n     }\n@@ -59,4 +87,5 @@ private static void testDubboCallSC() {\n     private static void testDubboTansormation() {\n     }\n+\n }",
    "output": "Change demo"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n@@ -62,6 +62,10 @@ public class DubboBeanDefinitionParser implements BeanDefinitionParser {\n     private static final Logger logger = LoggerFactory.getLogger(DubboBeanDefinitionParser.class);\n     private static final Pattern GROUP_AND_VERION = Pattern.compile(\"^[\\\\-.0-9_a-zA-Z]+(\\\\:[\\\\-.0-9_a-zA-Z]+)?$\");\n+    private static final String ONRETURN = \"onreturn\";\n+    private static final String ONTHROW = \"onthrow\";\n+    private static final String ONINVOKE = \"oninvoke\";\n+    private static final String METHOD = \"Method\";\n     private final Class<?> beanClass;\n     private final boolean required;\n@@ -190,24 +194,12 @@ private static BeanDefinition parse(Element element, ParserContext parserContext\n                                         value = null;\n                                     }\n                                     reference = value;\n-                                } else if (\"onreturn\".equals(property)) {\n+                                } else if(ONRETURN.equals(property) || ONTHROW.equals(property) || ONINVOKE.equals(property)) {\n                                     int index = value.lastIndexOf(\".\");\n-                                    String returnRef = value.substring(0, index);\n-                                    String returnMethod = value.substring(index + 1);\n-                                    reference = new RuntimeBeanReference(returnRef);\n-                                    beanDefinition.getPropertyValues().addPropertyValue(\"onreturnMethod\", returnMethod);\n-                                } else if (\"onthrow\".equals(property)) {\n-                                    int index = value.lastIndexOf(\".\");\n-                                    String throwRef = value.substring(0, index);\n-                                    String throwMethod = value.substring(index + 1);\n-                                    reference = new RuntimeBeanReference(throwRef);\n-                                    beanDefinition.getPropertyValues().addPropertyValue(\"onthrowMethod\", throwMethod);\n-                                } else if (\"oninvoke\".equals(property)) {\n-                                    int index = value.lastIndexOf(\".\");\n-                                    String invokeRef = value.substring(0, index);\n-                                    String invokeRefMethod = value.substring(index + 1);\n-                                    reference = new RuntimeBeanReference(invokeRef);\n-                                    beanDefinition.getPropertyValues().addPropertyValue(\"oninvokeMethod\", invokeRefMethod);\n+                                    String ref = value.substring(0, index);\n+                                    String method = value.substring(index + 1);\n+                                    reference = new RuntimeBeanReference(ref);\n+                                    beanDefinition.getPropertyValues().addPropertyValue(property + METHOD, method);\n                                 } else {\n                                     if (\"ref\".equals(property) && parserContext.getRegistry().containsBeanDefinition(value)) {\n                                         BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);",
    "output": "Make code of process callback of method cleaner in DubboBeanDefinitionParser"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n@@ -94,7 +94,8 @@ public void publishProvider(URL providerUrl) throws RpcException {\n         try {\n             String interfaceName = providerUrl.getParameter(INTERFACE_KEY);\n             if (StringUtils.isNotEmpty(interfaceName)) {\n-                Class interfaceClass = Class.forName(interfaceName);\n+                ClassLoader classLoader = null == Thread.currentThread().getContextClassLoader() ? this.getClass().getClassLoader() : Thread.currentThread().getContextClassLoader();\n+                Class interfaceClass = Class.forName(interfaceName, true, classLoader);\n                 FullServiceDefinition fullServiceDefinition = ServiceDefinitionBuilder.buildFullDefinition(interfaceClass, providerUrl.getParameters());\n                 metadataReport.storeProviderMetadata(new MetadataIdentifier(providerUrl.getServiceInterface(),\n                         providerUrl.getParameter(VERSION_KEY), providerUrl.getParameter(GROUP_KEY),",
    "output": "Add Thread ContextClassLoader"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java\n@@ -17,16 +17,15 @@\n package org.apache.dubbo.config.spring.schema;\n import org.apache.dubbo.common.Version;\n-\n-import org.apache.dubbo.config.ApplicationConfig;\n+import org.apache.dubbo.config.ConsumerConfig;\n import org.apache.dubbo.config.MetadataReportConfig;\n+import org.apache.dubbo.config.MetricsConfig;\n import org.apache.dubbo.config.ModuleConfig;\n-import org.apache.dubbo.config.RegistryConfig;\n import org.apache.dubbo.config.MonitorConfig;\n-import org.apache.dubbo.config.MetricsConfig;\n-import org.apache.dubbo.config.ProviderConfig;\n-import org.apache.dubbo.config.ConsumerConfig;\n import org.apache.dubbo.config.ProtocolConfig;\n+import org.apache.dubbo.config.ProviderConfig;\n+import org.apache.dubbo.config.RegistryConfig;\n+import org.apache.dubbo.config.spring.ApplicationBean;\n import org.apache.dubbo.config.spring.ConfigCenterBean;\n import org.apache.dubbo.config.spring.ReferenceBean;\n import org.apache.dubbo.config.spring.ServiceBean;\n@@ -46,7 +45,7 @@ public class DubboNamespaceHandler extends NamespaceHandlerSupport {\n     @Override\n     public void init() {\n-        registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationConfig.class, true));\n+        registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationBean.class, true));\n         registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true));\n         registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true));\n         registerBeanDefinitionParser(\"config-center\", new DubboBeanDefinitionParser(ConfigCenterBean.class, true));\ndiff --git a/dubbo-configcenter/dubbo-configcenter-etcd/src/test/java/org/apache/dubbo/configcenter/support/etcd/EtcdDynamicConfigurationTest.java b/dubbo-configcenter/dubbo-configcenter-etcd/src/test/java/org/apache/dubbo/configcenter/support/etcd/EtcdDynamicConfigurationTest.java\n--- a/dubbo-configcenter/dubbo-configcenter-etcd/src/test/java/org/apache/dubbo/configcenter/support/etcd/EtcdDynamicConfigurationTest.java\n+++ b/dubbo-configcenter/dubbo-configcenter-etcd/src/test/java/org/apache/dubbo/configcenter/support/etcd/EtcdDynamicConfigurationTest.java\n@@ -58,8 +58,8 @@ public void testGetConfig() {\n         put(\"/dubbo/config/org.apache.dubbo.etcd.testService/configurators\", \"hello\");\n         put(\"/dubbo/config/test/dubbo.properties\", \"aaa=bbb\");\n-        Assert.assertEquals(\"hello\", config.getRule(\"org.apache.dubbo.etcd.testService.configurators\", DynamicConfiguration.DEFAULT_GROUP));\n-        Assert.assertEquals(\"aaa=bbb\", config.getRule(\"dubbo.properties\", \"test\"));\n+        Assert.assertEquals(\"hello\", config.getConfig(\"org.apache.dubbo.etcd.testService.configurators\", DynamicConfiguration.DEFAULT_GROUP));\n+        Assert.assertEquals(\"aaa=bbb\", config.getConfig(\"dubbo.properties\", \"test\"));\n     }\n     @Test\ndiff --git a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscoveryFactory.java b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscoveryFactory.java\n--- a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscoveryFactory.java\n+++ b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscoveryFactory.java\n@@ -17,15 +17,15 @@\n package org.apache.dubbo.registry.consul;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.registry.client.AbstractServiceDiscoveryFactory;\n import org.apache.dubbo.registry.client.ServiceDiscovery;\n-import org.apache.dubbo.registry.client.ServiceDiscoveryFactory;\n /**\n  * 2019-07-31\n  */\n-public class ConsulServiceDiscoveryFactory implements ServiceDiscoveryFactory {\n+public class ConsulServiceDiscoveryFactory extends AbstractServiceDiscoveryFactory {\n     @Override\n-    public ServiceDiscovery create(URL connectionURL) {\n+    public ServiceDiscovery createDiscovery(URL connectionURL) {\n         return new ConsulServiceDiscovery(connectionURL);\n     }\n }",
    "output": "Fix compile problem"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-multicast/src/main/java/org/apache/dubbo/registry/multicast/MulticastRegistry.java b/dubbo-registry/dubbo-registry-multicast/src/main/java/org/apache/dubbo/registry/multicast/MulticastRegistry.java\n--- a/dubbo-registry/dubbo-registry-multicast/src/main/java/org/apache/dubbo/registry/multicast/MulticastRegistry.java\n+++ b/dubbo-registry/dubbo-registry-multicast/src/main/java/org/apache/dubbo/registry/multicast/MulticastRegistry.java\n@@ -150,7 +150,7 @@ public void run() {\n     private void checkMulticastAddress(InetAddress multicastAddress) {\n         if (!multicastAddress.isMulticastAddress()) {\n             String message = \"Invalid multicast address \" + multicastAddress;\n-            if (!(multicastAddress instanceof Inet4Address)) {\n+            if (multicastAddress instanceof Inet4Address) {\n                 throw new IllegalArgumentException(message + \", \" +\n                         \"ipv4 multicast address scope: 224.0.0.0 - 239.255.255.255.\");\n             } else {",
    "output": "Fix judgment ipv4 address * Fix judgment ipv4 address"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java\n--- a/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java\n+++ b/dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java\n@@ -275,7 +275,7 @@ private NewService buildService(URL url) {\n         service.setAddress(url.getHost());\n         service.setPort(url.getPort());\n         service.setId(buildId(url));\n-        service.setName(url.getServiceInterface());\n+        service.setName(url.getServiceKey());\n         service.setCheck(buildCheck(url));\n         service.setTags(buildTags(url));\n         service.setMeta(Collections.singletonMap(URL_META_KEY, url.toFullString()));",
    "output": "Use consul with group and version"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -325,7 +325,7 @@ public void checkAndUpdateSubConfigs() {\n             generic = Boolean.FALSE.toString();\n         }\n         if (local != null) {\n-            if (\"true\".equals(local)) {\n+            if (Boolean.TRUE.toString().equals(local)) {\n                 local = interfaceName + \"Local\";\n             }\n             Class<?> localClass;\n@@ -339,7 +339,7 @@ public void checkAndUpdateSubConfigs() {\n             }\n         }\n         if (stub != null) {\n-            if (\"true\".equals(stub)) {\n+            if (Boolean.TRUE.toString().equals(stub)) {\n                 stub = interfaceName + \"Stub\";\n             }\n             Class<?> stubClass;\n@@ -482,7 +482,7 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n                 String retryKey = method.getName() + \".retry\";\n                 if (map.containsKey(retryKey)) {\n                     String retryValue = map.remove(retryKey);\n-                    if (\"false\".equals(retryValue)) {\n+                    if (Boolean.FALSE.toString().equals(retryValue)) {\n                         map.put(method.getName() + \".retries\", \"0\");\n                     }\n                 }",
    "output": "Remove some magic value * fixed typo of variable * remove magic value"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedNotifiedTask.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedNotifiedTask.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedNotifiedTask.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedNotifiedTask.java\n@@ -31,7 +31,7 @@\n  */\n public final class FailedNotifiedTask extends AbstractRetryTask {\n-    private static final String NAME = \"retry subscribe\";\n+    private static final String NAME = \"retry notify\";\n     private final NotifyListener listener;",
    "output": "Fix name type for FailedNotifiedTask"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java\n@@ -347,8 +347,17 @@ public static String replace(final String text, final String searchString, final\n         return buf.toString();\n     }\n-    public static boolean isBlank(String str) {\n-        return isEmpty(str);\n+    public static boolean isBlank(CharSequence cs) {\n+        int strLen;\n+        if (cs == null || (strLen = cs.length()) == 0) {\n+            return true;\n+        }\n+        for (int i = 0; i < strLen; i++) {\n+            if (!Character.isWhitespace(cs.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n     /**",
    "output": "Fix StringUtils#isBlank"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -682,6 +682,7 @@ private String findConfigedHosts(ProtocolConfig protocolConfig, List<URL> regist\n             if (isInvalidLocalHost(hostToBind)) {\n                 anyhost = true;\n                 try {\n+                    logger.info( \"No valid ip found from environment, try to find valid host from DNS.\");\n                     hostToBind = InetAddress.getLocalHost().getHostAddress();\n                 } catch (UnknownHostException e) {\n                     logger.warn(e.getMessage(), e);\n@@ -726,6 +727,7 @@ private String findConfigedHosts(ProtocolConfig protocolConfig, List<URL> regist\n         return hostToRegistry;\n     }\n+\n     /**\n      * Register port and bind port for the provider, can be configured separately\n      * Configuration priority: environment variable -> java system properties -> port property in protocol config file",
    "output": "Fix dubbo startup is slow * * :loud_sound: Adding logs"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n@@ -60,8 +60,6 @@ public class ZookeeperRegistry extends FailbackRegistry {\n     private final static Logger logger = LoggerFactory.getLogger(ZookeeperRegistry.class);\n-    private final static int DEFAULT_ZOOKEEPER_PORT = 2181;\n-\n     private final static String DEFAULT_ROOT = \"dubbo\";\n     private final String root;\ndiff --git a/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistryTest.java b/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistryTest.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistryTest.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistryTest.java\n@@ -55,8 +55,9 @@ public class ZookeeperRegistryTest {\n     public void setUp() throws Exception {\n         int zkServerPort = NetUtils.getAvailablePort();\n         this.zkServer = new TestingServer(zkServerPort, true);\n-        this.registryUrl = URL.valueOf(\"zookeeper://localhost:\" + zkServerPort);\n+        this.zkServer.start();\n+        this.registryUrl = URL.valueOf(\"zookeeper://localhost:\" + zkServerPort);\n         zookeeperRegistryFactory = new ZookeeperRegistryFactory();\n         zookeeperRegistryFactory.setZookeeperTransporter(new CuratorZookeeperTransporter());\n         this.zookeeperRegistry = (ZookeeperRegistry) zookeeperRegistryFactory.createRegistry(registryUrl);\ndiff --git a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n@@ -46,6 +46,7 @@\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n@@ -84,6 +85,10 @@ public void stateChanged(CuratorFramework client, ConnectionState state) {\n                 }\n             });\n             client.start();\n+            boolean connected = client.blockUntilConnected(timeout, TimeUnit.MILLISECONDS);\n+            if (!connected) {\n+                throw new IllegalStateException(\"zookeeper not connected\");\n+            }\n         } catch (Exception e) {\n             throw new IllegalStateException(e.getMessage(), e);\n         }",
    "output": "Use CountDownLatch to check zk registry if establish connection"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-protobuf-json/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufObjectInput.java b/dubbo-serialization/dubbo-serialization-protobuf-json/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufObjectInput.java\n--- a/dubbo-serialization/dubbo-serialization-protobuf-json/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufObjectInput.java\n+++ b/dubbo-serialization/dubbo-serialization-protobuf-json/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufObjectInput.java\n@@ -16,14 +16,15 @@\n  */\n package org.apache.dubbo.common.serialize.protobuf.support;\n-import com.google.common.base.Charsets;\n+import org.apache.dubbo.common.serialize.ObjectInput;\n+\n import com.google.protobuf.BoolValue;\n+import com.google.protobuf.BytesValue;\n import com.google.protobuf.DoubleValue;\n import com.google.protobuf.FloatValue;\n import com.google.protobuf.Int32Value;\n import com.google.protobuf.Int64Value;\n import com.google.protobuf.StringValue;\n-import org.apache.dubbo.common.serialize.ObjectInput;\n import java.io.BufferedReader;\n import java.io.EOFException;\n@@ -85,7 +86,7 @@ public String readUTF() throws IOException {\n     @Override\n     public byte[] readBytes() throws IOException {\n-        return readUTF().getBytes(Charsets.ISO_8859_1);\n+        return read(BytesValue.class).getValue().toByteArray();\n     }\n     @Override\ndiff --git a/dubbo-serialization/dubbo-serialization-protobuf-json/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufObjectOutput.java b/dubbo-serialization/dubbo-serialization-protobuf-json/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufObjectOutput.java\n--- a/dubbo-serialization/dubbo-serialization-protobuf-json/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufObjectOutput.java\n+++ b/dubbo-serialization/dubbo-serialization-protobuf-json/src/main/java/org/apache/dubbo/common/serialize/protobuf/support/GenericProtobufObjectOutput.java\n@@ -16,14 +16,16 @@\n  */\n package org.apache.dubbo.common.serialize.protobuf.support;\n-import com.google.common.base.Charsets;\n+import org.apache.dubbo.common.serialize.ObjectOutput;\n+\n import com.google.protobuf.BoolValue;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.BytesValue;\n import com.google.protobuf.DoubleValue;\n import com.google.protobuf.FloatValue;\n import com.google.protobuf.Int32Value;\n import com.google.protobuf.Int64Value;\n import com.google.protobuf.StringValue;\n-import org.apache.dubbo.common.serialize.ObjectOutput;\n import java.io.IOException;\n import java.io.OutputStream;\n@@ -85,12 +87,12 @@ public void writeUTF(String v) throws IOException {\n     @Override\n     public void writeBytes(byte[] b) throws IOException {\n-        writeUTF(new String(b, Charsets.ISO_8859_1));\n+        writeObject(BytesValue.newBuilder().setValue(ByteString.copyFrom(b)).build());\n     }\n     @Override\n     public void writeBytes(byte[] b, int off, int len) throws IOException {\n-        writeUTF(new String(b, off, len, Charsets.ISO_8859_1));\n+        writeObject(BytesValue.newBuilder().setValue(ByteString.copyFrom(b, off, len)).build());\n     }",
    "output": "Use standard protobuf json format to write byte[]"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -76,7 +76,7 @@ public class ReferenceConfig<T> extends AbstractReferenceConfig {\n      *\n      * <li>when the url is dubbo://224.5.6.7:1234/org.apache.dubbo.config.api.DemoService?application=dubbo-sample, then\n      * the protocol is <b>DubboProtocol</b></li>\n-     *\n+     * <p>\n      * Actuallywhen the {@link ExtensionLoader} init the {@link Protocol} instants,it will automatically wraps two\n      * layers, and eventually will get a <b>ProtocolFilterWrapper</b> or <b>ProtocolListenerWrapper</b>\n      */\n@@ -277,12 +277,11 @@ private void init() {\n         serviceMetadata.setVersion(version);\n         serviceMetadata.setGroup(group);\n         serviceMetadata.setDefaultGroup(group);\n-        serviceMetadata.setServiceType(interfaceClass);\n+        serviceMetadata.setServiceType(getActualInterface());\n         serviceMetadata.setServiceInterfaceName(interfaceName);\n-\n-        ConsumerModel consumerModel = new ConsumerModel(interfaceName, group, version, getActualInterface());\n+        ConsumerModel consumerModel = new ConsumerModel(serviceMetadata);\n         ApplicationModel.initConsumerModel(URL.buildKey(interfaceName, group, version), consumerModel);\n@@ -353,6 +352,7 @@ private Class<?> getActualInterface() {\n         }\n         return actualInterface;\n     }\n+\n     @SuppressWarnings({\"unchecked\", \"rawtypes\", \"deprecation\"})\n     private T createProxy(Map<String, String> map) {\n         if (shouldJvmRefer(map)) {\n@@ -464,7 +464,7 @@ protected boolean shouldJvmRefer(Map<String, String> map) {\n     protected boolean shouldCheck() {\n         Boolean shouldCheck = isCheck();\n-        if (shouldCheck == null && getConsumer()!= null) {\n+        if (shouldCheck == null && getConsumer() != null) {\n             shouldCheck = getConsumer().isCheck();\n         }\n         if (shouldCheck == null) {\n@@ -634,6 +634,10 @@ Invoker<?> getInvoker() {\n         return invoker;\n     }\n+    public ServiceMetadata getServiceMetadata() {\n+        return serviceMetadata;\n+    }\n+\n     @Override\n     @Parameter(excluded = true)\n     public String getPrefix() {\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -1001,6 +1001,10 @@ public List<URL> getExportedUrls() {\n         return urls;\n     }\n+    public ServiceMetadata getServiceMetadata() {\n+        return serviceMetadata;\n+    }\n+\n     /**\n      * @deprecated Replace to getProtocols()\n      */",
    "output": "Improve ReferenceConfig and ServiceConfig add getServiceMetadata method"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/io/Bytes.java b/dubbo-common/src/main/java/org/apache/dubbo/common/io/Bytes.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/io/Bytes.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/io/Bytes.java\n@@ -730,8 +730,12 @@ public static byte[] base642bytes(final String str, final int off, final int len\n             char pc = code[64];\n             if (str.charAt(off + len - 2) == pc) {\n                 size -= 2;\n+                --num;\n+                rem = 2;\n             } else if (str.charAt(off + len - 1) == pc) {\n                 size--;\n+                --num;\n+                rem = 3;\n             }\n         } else {\n             if (rem == 2) {\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/io/BytesTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/io/BytesTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/io/BytesTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/io/BytesTest.java\n@@ -90,6 +90,14 @@ public void testBase64S2b2sFailCaseLog() throws Exception {\n         assertThat(bytes2, is(out2));\n     }\n+    @Test\n+    public void testBase642bCharArrCall() {\n+        byte[] stringCall = Bytes.base642bytes(\"ZHViYm8=\", C64);\n+        byte[] charArrCall = Bytes.base642bytes(\"ZHViYm8=\", C64.toCharArray());\n+\n+        assertThat(stringCall, is(charArrCall));\n+    }\n+\n     @Test\n     public void testHex() {\n         String str = Bytes.bytes2hex(b1);",
    "output": "Fix IndexOutOfBoundsException"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-etcd3/src/main/java/org/apache/dubbo/remoting/etcd/jetcd/JEtcdClient.java b/dubbo-remoting/dubbo-remoting-etcd3/src/main/java/org/apache/dubbo/remoting/etcd/jetcd/JEtcdClient.java\n--- a/dubbo-remoting/dubbo-remoting-etcd3/src/main/java/org/apache/dubbo/remoting/etcd/jetcd/JEtcdClient.java\n+++ b/dubbo-remoting/dubbo-remoting-etcd3/src/main/java/org/apache/dubbo/remoting/etcd/jetcd/JEtcdClient.java\n@@ -447,8 +447,17 @@ protected void closeWatchRequest() {\n             if (this.watchRequest == null) {\n                 return;\n             }\n-            this.watchRequest.onCompleted();\n-            this.watchRequest = null;\n+\n+            try {\n+                WatchCancelRequest watchCancelRequest =\n+                        WatchCancelRequest.newBuilder().setWatchId(watchId).build();\n+                WatchRequest cancelRequest = WatchRequest.newBuilder()\n+                        .setCancelRequest(watchCancelRequest).build();\n+                watchRequest.onNext(cancelRequest);\n+            } finally {\n+                this.watchRequest.onCompleted();\n+                this.watchRequest = null;\n+            }\n         }\n         @Override",
    "output": "Fix bug of Etcd3Registry cancel watch #4357 * fix bug of Etcd3Registry cancel watch * optimize bugfix for etcd3 registry cancel watch"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/RegistryConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/RegistryConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/RegistryConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/RegistryConfig.java\n@@ -23,11 +23,11 @@\n import java.util.Map;\n import static org.apache.dubbo.common.constants.CommonConstants.FILE_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PASSWORD_KEY;\n-import static org.apache.dubbo.config.Constants.REGISTRIES_SUFFIX;\n+import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SHUTDOWN_WAIT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.USERNAME_KEY;\n+import static org.apache.dubbo.config.Constants.REGISTRIES_SUFFIX;\n import static org.apache.dubbo.config.Constants.ZOOKEEPER_PROTOCOL;\n import static org.apache.dubbo.registry.Constants.EXTRA_KEYS_KEY;\n@@ -182,6 +182,11 @@ public void setAddress(String address) {\n             int i = address.indexOf(\"://\");\n             if (i > 0) {\n                 this.updateIdIfAbsent(address.substring(0, i));\n+                this.updateProtocolIfAbsent(address.substring(0, i));\n+                int port = address.lastIndexOf(\":\");\n+                if (port > 0) {\n+                    this.updatePortIfAbsent(StringUtils.parseInteger(address.substring(port + 1)));\n+                }\n             }\n         }\n     }\n@@ -432,4 +437,15 @@ public boolean isValid() {\n         return !StringUtils.isEmpty(address);\n     }\n+    protected void updatePortIfAbsent(Integer value) {\n+        if (value != null && value > 0 && port == null) {\n+            this.port = value;\n+        }\n+    }\n+\n+    protected void updateProtocolIfAbsent(String value) {\n+        if (StringUtils.isNotEmpty(value) && StringUtils.isEmpty(protocol)) {\n+            this.protocol = value;\n+        }\n+    }\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/RegistryConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/RegistryConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/RegistryConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/RegistryConfigTest.java\n@@ -17,14 +17,15 @@\n package org.apache.dubbo.config;\n+import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n-import static org.apache.dubbo.config.Constants.SHUTDOWN_TIMEOUT_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.SHUTDOWN_WAIT_KEY;\n+import static org.apache.dubbo.config.Constants.SHUTDOWN_TIMEOUT_KEY;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n@@ -177,4 +178,13 @@ public void testDefault() throws Exception {\n         assertThat(registry.isDefault(), is(true));\n     }\n+    @Test\n+    public void testEquals() throws Exception {\n+        RegistryConfig registry1 = new RegistryConfig();\n+        RegistryConfig registry2 = new RegistryConfig();\n+        registry1.setAddress(\"zookeeper://127.0.0.1:2182\");\n+        registry2.setAddress(\"zookeeper://127.0.0.1:2183\");\n+        Assertions.assertNotEquals(registry1, registry2);\n+    }\n+\n }",
    "output": "Fix registryConfig equals * fixed registryConfig equals * port > 0"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java b/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java\n@@ -42,6 +42,8 @@ public final class Version {\n     // Dubbo RPC protocol version, for compatibility, it must not be between 2.0.10 ~ 2.6.2\n     public static final String DEFAULT_DUBBO_PROTOCOL_VERSION = \"2.0.2\";\n+    // version 1.0.0 represents Dubbo rpc protocol before v2.6.2\n+    public static final int LEGACY_DUBBO_PROTOCOL_VERSION = 10000; // 1.0.0\n     // Dubbo implementation version, usually is jar version.\n     private static final String VERSION = getVersion(Version.class, \"\");\n@@ -115,10 +117,17 @@ public static boolean isSupportResponseAttachment(String version) {\n     public static int getIntVersion(String version) {\n         Integer v = VERSION2INT.get(version);\n         if (v == null) {\n-            v = parseInt(version);\n-            // e.g., version number 2.6.3 will convert to 2060300\n-            if (version.split(\"\\\\.\").length == 3) {\n-                v = v * 100;\n+            try {\n+                v = parseInt(version);\n+                // e.g., version number 2.6.3 will convert to 2060300\n+                if (version.split(\"\\\\.\").length == 3) {\n+                    v = v * 100;\n+                }\n+            } catch (Exception e) {\n+                logger.warn(\"Please make sure your version value has the right format: \" +\n+                        \"\\n 1. only contains digital number: 2.0.0; \\n 2. with string suffix: 2.6.7-stable. \" +\n+                        \"\\nIf you are using Dubbo before v2.6.2, the version value is the same with the jar version.\");\n+                v = LEGACY_DUBBO_PROTOCOL_VERSION;\n             }\n             VERSION2INT.put(version, v);\n         }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/version/VersionTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/version/VersionTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/version/VersionTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/version/VersionTest.java\n@@ -34,6 +34,12 @@ public void testSupportResponseAttachment() {\n         Assertions.assertTrue(Version.isSupportResponseAttachment(\"2.0.2\"));\n         Assertions.assertTrue(Version.isSupportResponseAttachment(\"2.0.3\"));\n         Assertions.assertFalse(Version.isSupportResponseAttachment(\"2.0.0\"));\n+        Assertions.assertFalse(Version.isSupportResponseAttachment(\"1.0.0\"));\n+        Assertions.assertTrue(Version.isSupportResponseAttachment(\"2.6.6-stable\"));\n+\n+        Assertions.assertFalse(Version.isSupportResponseAttachment(\"2.0.contains\"));\n+        Assertions.assertFalse(Version.isSupportResponseAttachment(\"version.string\"));\n+        Assertions.assertFalse(Version.isSupportResponseAttachment(\"prefix2.0\"));\n     }\n     @Test",
    "output": "Make code strong, version check compatibility. Fix https://github.com/apache/dubbo/pull/4488"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java\n@@ -68,7 +68,7 @@ public class AccessLogFilter implements Filter {\n     private static final Logger logger = LoggerFactory.getLogger(AccessLogFilter.class);\n-    private static final String ACCESS_LOG_KEY = \"dubbo.accesslog\";\n+    private static final String LOG_KEY = \"dubbo.accesslog\";\n     private static final int LOG_MAX_BUFFER = 5000;\n@@ -179,7 +179,7 @@ private void processWithServiceLogger(Set<AccessLogData> logSet) {\n              iterator.hasNext();\n              iterator.remove()) {\n             AccessLogData logData = iterator.next();\n-            LoggerFactory.getLogger(ACCESS_LOG_KEY + \".\" + logData.getServiceName()).info(logData.getLogMessage());\n+            LoggerFactory.getLogger(LOG_KEY + \".\" + logData.getServiceName()).info(logData.getLogMessage());\n         }\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/AccessLogFilterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/AccessLogFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/AccessLogFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/AccessLogFilterTest.java\n@@ -16,17 +16,23 @@\n  */\n package org.apache.dubbo.rpc.filter;\n+import java.lang.reflect.Field;\n+import java.util.Map;\n+import java.util.Set;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.utils.LogUtil;\n import org.apache.dubbo.rpc.Filter;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.support.AccessLogData;\n import org.apache.dubbo.rpc.support.MockInvocation;\n import org.apache.dubbo.rpc.support.MyInvoker;\n import org.junit.jupiter.api.Test;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n /**\n  * AccessLogFilterTest.java\n@@ -48,11 +54,23 @@ public void testInvokeException() {\n     // TODO how to assert thread action\n     @Test\n-    public void testDefault() {\n+    @SuppressWarnings(\"unchecked\")\n+    public void testDefault() throws NoSuchFieldException, IllegalAccessException {\n         URL url = URL.valueOf(\"test://test:11/test?accesslog=true&group=dubbo&version=1.1\");\n         Invoker<AccessLogFilterTest> invoker = new MyInvoker<AccessLogFilterTest>(url);\n         Invocation invocation = new MockInvocation();\n+\n+        Field field = AccessLogFilter.class.getDeclaredField(\"LOG_ENTRIES\");\n+        field.setAccessible(true);\n+        assertTrue(((Map) field.get(AccessLogFilter.class)).isEmpty());\n+\n         accessLogFilter.invoke(invoker, invocation);\n+\n+        Map<String, Set<AccessLogData>> logs = (Map<String, Set<AccessLogData>>) field.get(AccessLogFilter.class);\n+        assertFalse(logs.isEmpty());\n+        assertFalse(logs.get(\"true\").isEmpty());\n+        AccessLogData log = logs.get(\"true\").iterator().next();\n+        assertEquals(\"org.apache.dubbo.rpc.support.DemoService\", log.getServiceName());\n     }\n     @Test",
    "output": "Fix bug #4374 for AccessLogFilter not working which introduced by #4038"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java\n@@ -108,12 +108,12 @@ public void testSticky() throws Exception {\n     }\n     @Test\n-    public void testConverMethodConfig2AsyncInfo() throws Exception{\n+    public void testConvertMethodConfig2AsyncInfo() throws Exception{\n         org.apache.dubbo.config.MethodConfig methodConfig = new org.apache.dubbo.config.MethodConfig();\n         methodConfig.setOninvokeMethod(\"setName\");\n         methodConfig.setOninvoke(new Person());\n-        ConsumerMethodModel.AsyncMethodInfo methodInfo = org.apache.dubbo.config.MethodConfig.convertMethodConfig2AyncInfo(methodConfig);\n+        ConsumerMethodModel.AsyncMethodInfo methodInfo = org.apache.dubbo.config.MethodConfig.convertMethodConfig2AsyncInfo(methodConfig);\n         assertEquals(methodInfo.getOninvokeMethod(), Person.class.getMethod(\"setName\", String.class));\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -249,7 +249,7 @@ protected static void appendAttributes(Map<String, Object> parameters, Object co\n         }\n     }\n-    protected static ConsumerMethodModel.AsyncMethodInfo convertMethodConfig2AyncInfo(MethodConfig methodConfig) {\n+    protected static ConsumerMethodModel.AsyncMethodInfo convertMethodConfig2AsyncInfo(MethodConfig methodConfig) {\n         if (methodConfig == null || (methodConfig.getOninvoke() == null && methodConfig.getOnreturn() == null && methodConfig.getOnthrow() == null)) {\n             return null;\n         }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -314,7 +314,7 @@ private void init() {\n                         map.put(methodConfig.getName() + \".retries\", \"0\");\n                     }\n                 }\n-                attributes.put(methodConfig.getName(), convertMethodConfig2AyncInfo(methodConfig));\n+                attributes.put(methodConfig.getName(), convertMethodConfig2AsyncInfo(methodConfig));\n             }\n         }",
    "output": "Fix convertMethodConfig2AsyncInfo spelling error"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -619,6 +619,8 @@ private void useRegistryForConfigIfNecessary() {\n             Environment.getInstance().getDynamicConfiguration().orElseGet(() -> {\n                 ConfigManager configManager = ConfigManager.getInstance();\n                 ConfigCenterConfig cc = configManager.getConfigCenter().orElse(new ConfigCenterConfig());\n+                cc.setParameters(new HashMap<>());\n+                cc.getParameters().put(org.apache.dubbo.remoting.Constants.CLIENT_KEY,rc.getClient());\n                 cc.setProtocol(rc.getProtocol());\n                 cc.setAddress(rc.getAddress());\n                 cc.setHighestPriority(false);",
    "output": "Use the correct spi ZookeeperTransporter when initialize the default ConfigCenter's zkClient"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcContext.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcContext.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcContext.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcContext.java\n@@ -35,9 +35,7 @@ private static RpcContext newInstance(org.apache.dubbo.rpc.RpcContext rpcContext\n         RpcContext copy = new RpcContext();\n         copy.getAttachments().putAll(rpcContext.getAttachments());\n         copy.get().putAll(rpcContext.get());\n-        if (rpcContext.getCompletableFuture() != null) {\n-            copy.setFuture(rpcContext.getCompletableFuture());\n-        }\n+\n         copy.setUrls(rpcContext.getUrls());\n         copy.setUrl(rpcContext.getUrl());\n         copy.setMethodName(rpcContext.getMethodName());",
    "output": "Fix RpcContext compatible problem"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -650,7 +650,7 @@ public boolean equals(Object obj) {\n         Method[] methods = this.getClass().getMethods();\n         for (Method method1 : methods) {\n-            if (MethodUtils.isGetter(method1) && ClassUtils.isPrimitive(method1.getReturnType())) {\n+            if (MethodUtils.isGetter(method1)) {\n                 Parameter parameter = method1.getAnnotation(Parameter.class);\n                 if (parameter != null && parameter.excluded()) {\n                     continue;",
    "output": "Remove duplicate code in AbstractConfig"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/AbstractPrefixConfiguration.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/AbstractPrefixConfiguration.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/AbstractPrefixConfiguration.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/AbstractPrefixConfiguration.java\n@@ -37,14 +37,14 @@ public AbstractPrefixConfiguration(String prefix, String id) {\n     @Override\n     public Object getProperty(String key, Object defaultValue) {\n         Object value = null;\n-        if (StringUtils.isNotEmpty(prefix) && StringUtils.isNotEmpty(id)) {\n-            value = getInternalProperty(prefix + id + \".\" + key);\n-        }\n-        if (value == null && StringUtils.isNotEmpty(prefix)) {\n-            value = getInternalProperty(prefix + key);\n-        }\n-\n-        if (value == null) {\n+        if (StringUtils.isNotEmpty(prefix)) {\n+            if (StringUtils.isNotEmpty(id)) {\n+                value = getInternalProperty(prefix + id + \".\" + key);\n+            }\n+            if (value == null) {\n+                value = getInternalProperty(prefix + key);\n+            }\n+        } else {\n             value = getInternalProperty(key);\n         }\n         return value != null ? value : defaultValue;\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -18,8 +18,8 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.config.CompositeConfiguration;\n+import org.apache.dubbo.common.config.Configuration;\n import org.apache.dubbo.common.config.Environment;\n-import org.apache.dubbo.common.config.InmemoryConfiguration;\n import org.apache.dubbo.common.constants.CommonConstants;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.logger.Logger;\n@@ -29,6 +29,7 @@\n import org.apache.dubbo.common.utils.MethodUtils;\n import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.config.context.ConfigConfigurationAdapter;\n import org.apache.dubbo.config.support.Parameter;\n import org.apache.dubbo.rpc.model.ConsumerMethodModel;\n@@ -548,8 +549,7 @@ public void setPrefix(String prefix) {\n     public void refresh() {\n         try {\n             CompositeConfiguration compositeConfiguration = Environment.getInstance().getConfiguration(getPrefix(), getId());\n-            InmemoryConfiguration config = new InmemoryConfiguration(getPrefix(), getId());\n-            config.addProperties(getMetaData());\n+            Configuration config = new ConfigConfigurationAdapter(this);\n             if (Environment.getInstance().isConfigCenterFirst()) {\n                 // The sequence would be: SystemConfiguration -> AppExternalConfiguration -> ExternalConfiguration -> AbstractConfig -> PropertiesConfiguration\n                 compositeConfiguration.addConfiguration(4, config);\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/context/ConfigConfigurationAdapter.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/context/ConfigConfigurationAdapter.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/context/ConfigConfigurationAdapter.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/context/ConfigConfigurationAdapter.java\n@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.config.context;\n+\n+import org.apache.dubbo.common.config.Configuration;\n+import org.apache.dubbo.config.AbstractConfig;\n+\n+import java.util.Map;\n+\n+/**\n+ * This class receives an {@link AbstractConfig} and exposes its attributes through {@link Configuration}\n+ */\n+public class ConfigConfigurationAdapter implements Configuration {\n+\n+    private Map<String, String> metaData;\n+\n+    public ConfigConfigurationAdapter(AbstractConfig config) {\n+        this.metaData = config.getMetaData();\n+    }\n+\n+    @Override\n+    public Object getInternalProperty(String key) {\n+        return metaData.get(key);\n+    }\n+\n+}\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n@@ -29,6 +29,7 @@\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n+import java.lang.reflect.Field;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n@@ -449,6 +450,37 @@ public void testRefreshById() {\n         }\n     }\n+    @Test\n+    public void testOnlyPrefixedKeyTakeEffect() {\n+        try {\n+            OverrideConfig overrideConfig = new OverrideConfig();\n+            overrideConfig.setNotConflictKey(\"value-from-config\");\n+\n+            Map<String, String> external = new HashMap<>();\n+            external.put(\"notConflictKey\", \"value-from-external\");\n+\n+            try {\n+                Map<String, String> map = new HashMap<>();\n+                map.put(\"notConflictKey\", \"value-from-env\");\n+                map.put(\"dubbo.override.notConflictKey2\", \"value-from-env\");\n+                setOsEnv(map);\n+            } catch (Exception e) {\n+                // ignore\n+                e.printStackTrace();\n+            }\n+\n+            Environment.getInstance().setExternalConfigMap(external);\n+\n+            overrideConfig.refresh();\n+\n+            Assertions.assertEquals(\"value-from-config\", overrideConfig.getNotConflictKey());\n+            Assertions.assertEquals(\"value-from-env\", overrideConfig.getNotConflictKey2());\n+        } finally {\n+            Environment.getInstance().clearExternalConfigs();\n+\n+        }\n+    }\n+\n     @Test\n     public void tetMetaData() {\n         OverrideConfig overrideConfig = new OverrideConfig();\n@@ -518,6 +550,8 @@ private static class OverrideConfig extends AbstractInterfaceConfig {\n         public String key;\n         public String useKeyAsProperty;\n         public String escape;\n+        public String notConflictKey;\n+        public String notConflictKey2;\n         public String getAddress() {\n             return address;\n@@ -570,6 +604,22 @@ public String getEscape() {\n         public void setEscape(String escape) {\n             this.escape = escape;\n         }\n+\n+        public String getNotConflictKey() {\n+            return notConflictKey;\n+        }\n+\n+        public void setNotConflictKey(String notConflictKey) {\n+            this.notConflictKey = notConflictKey;\n+        }\n+\n+        public String getNotConflictKey2() {\n+            return notConflictKey2;\n+        }\n+\n+        public void setNotConflictKey2(String notConflictKey2) {\n+            this.notConflictKey2 = notConflictKey2;\n+        }\n     }\n     private static class PropertiesConfig extends AbstractConfig {\n@@ -807,4 +857,31 @@ public void setConfigFields(String[] configFields) {\n             this.configFields = configFields;\n         }\n     }\n+\n+    protected static void setOsEnv(Map<String, String> newenv) throws Exception {\n+        try {\n+            Class<?> processEnvironmentClass = Class.forName(\"java.lang.ProcessEnvironment\");\n+            Field theEnvironmentField = processEnvironmentClass.getDeclaredField(\"theEnvironment\");\n+            theEnvironmentField.setAccessible(true);\n+            Map<String, String> env = (Map<String, String>) theEnvironmentField.get(null);\n+            env.putAll(newenv);\n+            Field theCaseInsensitiveEnvironmentField = processEnvironmentClass.getDeclaredField(\"theCaseInsensitiveEnvironment\");\n+            theCaseInsensitiveEnvironmentField.setAccessible(true);\n+            Map<String, String> cienv = (Map<String, String>) theCaseInsensitiveEnvironmentField.get(null);\n+            cienv.putAll(newenv);\n+        } catch (NoSuchFieldException e) {\n+            Class[] classes = Collections.class.getDeclaredClasses();\n+            Map<String, String> env = System.getenv();\n+            for (Class cl : classes) {\n+                if (\"java.util.Collections$UnmodifiableMap\".equals(cl.getName())) {\n+                    Field field = cl.getDeclaredField(\"m\");\n+                    field.setAccessible(true);\n+                    Object obj = field.get(env);\n+                    Map<String, String> map = (Map<String, String>) obj;\n+                    map.clear();\n+                    map.putAll(newenv);\n+                }\n+            }\n+        }\n+    }\n }",
    "output": "Use special Configuration for Configs"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/extension/support/ActivateComparator.java b/dubbo-common/src/main/java/org/apache/dubbo/common/extension/support/ActivateComparator.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/extension/support/ActivateComparator.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/extension/support/ActivateComparator.java\n@@ -82,7 +82,7 @@ public int compare(Object o1, Object o2) {\n     }\n     private Class<?> findSpi(Class clazz) {\n-        if (clazz.getInterfaces().length <= 0) {\n+        if (clazz.getInterfaces().length == 0) {\n             return null;\n         }",
    "output": "Fix length of array is never negative"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n@@ -23,20 +23,21 @@\n import org.apache.dubbo.common.utils.UrlUtils;\n import org.apache.dubbo.config.support.Parameter;\n+import java.util.HashMap;\n import java.util.Map;\n import java.util.concurrent.atomic.AtomicBoolean;\n import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;\n+import static org.apache.dubbo.config.Constants.CONFIG_CONFIGFILE_KEY;\n+import static org.apache.dubbo.config.Constants.CONFIG_ENABLE_KEY;\n+import static org.apache.dubbo.config.Constants.CONFIG_TIMEOUT_KEY;\n+import static org.apache.dubbo.config.Constants.ZOOKEEPER_PROTOCOL;\n import static org.apache.dubbo.configcenter.Constants.CONFIG_CHECK_KEY;\n import static org.apache.dubbo.configcenter.Constants.CONFIG_CLUSTER_KEY;\n import static org.apache.dubbo.configcenter.Constants.CONFIG_GROUP_KEY;\n import static org.apache.dubbo.configcenter.Constants.CONFIG_NAMESPACE_KEY;\n-import static org.apache.dubbo.config.Constants.ZOOKEEPER_PROTOCOL;\n-import static org.apache.dubbo.config.Constants.CONFIG_CONFIGFILE_KEY;\n-import static org.apache.dubbo.config.Constants.CONFIG_ENABLE_KEY;\n-import static org.apache.dubbo.config.Constants.CONFIG_TIMEOUT_KEY;\n /**\n  * ConfigCenterConfig\n@@ -90,7 +91,8 @@ public ConfigCenterConfig() {\n     }\n     public URL toUrl() {\n-        Map<String, String> map = this.getMetaData();\n+        Map<String, String> map = new HashMap<>();\n+        appendParameters(map, this);\n         if (StringUtils.isEmpty(address)) {\n             address = ANYHOST_VALUE;\n         }\n@@ -131,7 +133,7 @@ public void setAddress(String address) {\n         this.address = address;\n     }\n-    @Parameter(key = CONFIG_CLUSTER_KEY, useKeyAsProperty = false)\n+    @Parameter(key = CONFIG_CLUSTER_KEY)\n     public String getCluster() {\n         return cluster;\n     }\n@@ -140,7 +142,7 @@ public void setCluster(String cluster) {\n         this.cluster = cluster;\n     }\n-    @Parameter(key = CONFIG_NAMESPACE_KEY, useKeyAsProperty = false)\n+    @Parameter(key = CONFIG_NAMESPACE_KEY)\n     public String getNamespace() {\n         return namespace;\n     }\n@@ -149,7 +151,7 @@ public void setNamespace(String namespace) {\n         this.namespace = namespace;\n     }\n-    @Parameter(key = CONFIG_GROUP_KEY, useKeyAsProperty = false)\n+    @Parameter(key = CONFIG_GROUP_KEY)\n     public String getGroup() {\n         return group;\n     }\n@@ -158,7 +160,7 @@ public void setGroup(String group) {\n         this.group = group;\n     }\n-    @Parameter(key = CONFIG_CHECK_KEY, useKeyAsProperty = false)\n+    @Parameter(key = CONFIG_CHECK_KEY)\n     public Boolean isCheck() {\n         return check;\n     }\n@@ -167,7 +169,7 @@ public void setCheck(Boolean check) {\n         this.check = check;\n     }\n-    @Parameter(key = CONFIG_ENABLE_KEY, useKeyAsProperty = false)\n+    @Parameter(key = CONFIG_ENABLE_KEY)\n     public Boolean isHighestPriority() {\n         return highestPriority;\n     }\n@@ -192,7 +194,7 @@ public void setPassword(String password) {\n         this.password = password;\n     }\n-    @Parameter(key = CONFIG_TIMEOUT_KEY, useKeyAsProperty = false)\n+    @Parameter(key = CONFIG_TIMEOUT_KEY)\n     public Long getTimeout() {\n         return timeout;\n     }\n@@ -201,7 +203,7 @@ public void setTimeout(Long timeout) {\n         this.timeout = timeout;\n     }\n-    @Parameter(key = CONFIG_CONFIGFILE_KEY, useKeyAsProperty = false)\n+    @Parameter(key = CONFIG_CONFIGFILE_KEY)\n     public String getConfigFile() {\n         return configFile;\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java\n@@ -29,4 +29,18 @@ public void testPrefix() {\n         ConfigCenterConfig config = new ConfigCenterConfig();\n         Assertions.assertEquals(\"dubbo.config-center\", config.getPrefix());\n     }\n+\n+    @Test\n+    public void testToUrl() {\n+        ConfigCenterConfig config = new ConfigCenterConfig();\n+        config.setNamespace(\"namespace\");\n+        config.setGroup(\"group\");\n+        config.setAddress(\"zookeeper://127.0.0.1:2181\");\n+\n+        Assertions.assertEquals(\"zookeeper://127.0.0.1:2181/ConfigCenterConfig?config.check=true&\" +\n+                        \"config.config-file=dubbo.properties&config.group=group&config.highest-priority=true&\" +\n+                        \"config.namespace=namespace&config.timeout=3000\",\n+                config.toUrl().toFullString()\n+        );\n+    }\n }",
    "output": "Fix url generated from ConfigCenterConfig missed 'config.' prefix * fix url generated from ConfigCenterConfig missed 'config.' prefix * remove useKeyAsParameter=false * fix ut * remove unused imports"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/identifier/MetadataIdentifier.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/identifier/MetadataIdentifier.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/identifier/MetadataIdentifier.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/identifier/MetadataIdentifier.java\n@@ -67,7 +67,7 @@ public String getUniqueKey(KeyTypeEnum keyType) {\n     }\n     public String getIdentifierKey() {\n-        return serviceInterface + SEPARATOR + (version == null ? \"\" : version + SEPARATOR) + (group == null ? \"\" : group + SEPARATOR) + side + SEPARATOR + application;\n+        return serviceInterface + SEPARATOR + (version == null ? \"\" : version) + SEPARATOR + (group == null ? \"\" : group) + SEPARATOR + side + SEPARATOR + application;\n     }\n     private String getFilePathKey() {\ndiff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/identifier/MetadataIdentifierTest.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/identifier/MetadataIdentifierTest.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/identifier/MetadataIdentifierTest.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/identifier/MetadataIdentifierTest.java\n@@ -37,12 +37,12 @@ public void testGetUniqueKey() {\n         Assertions.assertEquals(providerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.PATH),\n                 \"metadata\" + PATH_SEPARATOR + interfaceName + PATH_SEPARATOR +\n                         (version == null ? \"\" : (version + PATH_SEPARATOR))\n-                + (group == null ? \"\" : (group + PATH_SEPARATOR)) + PROVIDER_SIDE\n+                        + (group == null ? \"\" : (group + PATH_SEPARATOR)) + PROVIDER_SIDE\n                         + PATH_SEPARATOR + application);\n         Assertions.assertEquals(providerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY),\n                 interfaceName + MetadataIdentifier.SEPARATOR +\n-                        (version == null ? \"\" : version + MetadataIdentifier.SEPARATOR)\n-                        + (group == null ? \"\" : group + MetadataIdentifier.SEPARATOR)\n+                        (version == null ? \"\" : version) + MetadataIdentifier.SEPARATOR\n+                        + (group == null ? \"\" : group) + MetadataIdentifier.SEPARATOR\n                         + PROVIDER_SIDE + MetadataIdentifier.SEPARATOR + application);\n     }\n }",
    "output": "Make metadata key contain : when version and group is empty"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n@@ -48,7 +48,7 @@ public static <T> RouterChain<T> buildChain(URL url) {\n     private RouterChain(URL url) {\n         List<RouterFactory> extensionFactories = ExtensionLoader.getExtensionLoader(RouterFactory.class)\n-                .getActivateExtension(url, (String[]) null);\n+                .getActivateExtension(url, \"router\");\n         List<Router> routers = extensionFactories.stream()\n                 .map(factory -> factory.getRouter(url))\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java\n@@ -18,6 +18,7 @@\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -75,6 +76,20 @@ public ConsumerMethodModel getMethodModel(String method) {\n         return consumerMethodModelEntry.map(Map.Entry::getValue).orElse(null);\n     }\n+    /**\n+     * @param method   metodName\n+     * @param argsType method arguments type\n+     * @return\n+     */\n+    public ConsumerMethodModel getMethodModel(String method, String[] argsType) {\n+        Optional<ConsumerMethodModel> consumerMethodModel = methodModels.entrySet().stream()\n+                .filter(entry -> entry.getKey().getName().equals(method))\n+                .map(Map.Entry::getValue).filter(methodModel ->  Arrays.equals(argsType, methodModel.getParameterTypes()))\n+                .findFirst();\n+        return consumerMethodModel.orElse(null);\n+    }\n+\n+\n     /**\n      * @return\n      */",
    "output": "Improve/consumer model * improve:get ConsumerMethodModel by method name and args type * improve:build router chain with router argument"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java\n@@ -17,7 +17,6 @@\n package org.apache.dubbo.registry.nacos;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.registry.Registry;\n import org.apache.dubbo.registry.RegistryFactory;\n import org.apache.dubbo.registry.support.AbstractRegistryFactory;",
    "output": "Remove unused imports"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/MockInvokerTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/MockInvokerTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/MockInvokerTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/MockInvokerTest.java\n@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.support;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.RpcInvocation;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.apache.dubbo.rpc.Constants.MOCK_KEY;\n+\n+public class MockInvokerTest {\n+\n+    @Test\n+    public void testParseMockValue() throws Exception {\n+        Assertions.assertNull(MockInvoker.parseMockValue(\"null\"));\n+        Assertions.assertNull(MockInvoker.parseMockValue(\"empty\"));\n+\n+        Assertions.assertTrue((Boolean) MockInvoker.parseMockValue(\"true\"));\n+        Assertions.assertFalse((Boolean) MockInvoker.parseMockValue(\"false\"));\n+\n+        Assertions.assertEquals(123, MockInvoker.parseMockValue(\"123\"));\n+        Assertions.assertEquals(\"foo\", MockInvoker.parseMockValue(\"foo\"));\n+        Assertions.assertEquals(\"foo\", MockInvoker.parseMockValue(\"\\\"foo\\\"\"));\n+        Assertions.assertEquals(\"foo\", MockInvoker.parseMockValue(\"\\'foo\\'\"));\n+\n+        Assertions.assertEquals(\n+                new HashMap<>(), MockInvoker.parseMockValue(\"{}\"));\n+        Assertions.assertEquals(\n+                new ArrayList<>(), MockInvoker.parseMockValue(\"[]\"));\n+        Assertions.assertEquals(\"foo\",\n+                MockInvoker.parseMockValue(\"foo\", new Type[]{String.class}));\n+    }\n+\n+    @Test\n+    public void testInvoke() {\n+        URL url = URL.valueOf(\"remote://1.2.3.4/\" + String.class.getName());\n+        url = url.addParameter(MOCK_KEY, \"return \");\n+        MockInvoker mockInvoker = new MockInvoker(url, String.class);\n+\n+        RpcInvocation invocation = new RpcInvocation();\n+        invocation.setMethodName(\"getSomething\");\n+        Assertions.assertEquals(new HashMap<>(),\n+                mockInvoker.invoke(invocation).getAttachments());\n+    }\n+\n+    @Test\n+    public void testInvokeThrowsRpcException1() {\n+        URL url = URL.valueOf(\"remote://1.2.3.4/\" + String.class.getName());\n+        MockInvoker mockInvoker = new MockInvoker(url, null);\n+\n+        Assertions.assertThrows(RpcException.class,\n+                () -> mockInvoker.invoke(new RpcInvocation()));\n+    }\n+\n+    @Test\n+    public void testInvokeThrowsRpcException2() {\n+        URL url = URL.valueOf(\"remote://1.2.3.4/\" + String.class.getName());\n+        url = url.addParameter(MOCK_KEY, \"fail\");\n+        MockInvoker mockInvoker = new MockInvoker(url, String.class);\n+\n+        RpcInvocation invocation = new RpcInvocation();\n+        invocation.setMethodName(\"getSomething\");\n+        Assertions.assertThrows(RpcException.class,\n+                () -> mockInvoker.invoke(invocation));\n+    }\n+\n+    @Test\n+    public void testInvokeThrowsRpcException3() {\n+        URL url = URL.valueOf(\"remote://1.2.3.4/\" + String.class.getName());\n+        url = url.addParameter(MOCK_KEY, \"throw\");\n+        MockInvoker mockInvoker = new MockInvoker(url, String.class);\n+\n+        RpcInvocation invocation = new RpcInvocation();\n+        invocation.setMethodName(\"getSomething\");\n+        Assertions.assertThrows(RpcException.class,\n+                () -> mockInvoker.invoke(invocation));\n+    }\n+\n+    @Test\n+    public void testGetThrowable() {\n+        Assertions.assertThrows(RpcException.class,\n+                () -> MockInvoker.getThrowable(\"Exception.class\"));\n+    }\n+\n+    @Test\n+    public void testGetMockObject() {\n+        Assertions.assertEquals(\"\",\n+                MockInvoker.getMockObject(\"java.lang.String\", String.class));\n+\n+        Assertions.assertThrows(IllegalStateException.class, () -> MockInvoker\n+                .getMockObject(\"true\", String.class));\n+        Assertions.assertThrows(IllegalStateException.class, () -> MockInvoker\n+                .getMockObject(\"default\", String.class));\n+        Assertions.assertThrows(IllegalStateException.class, () -> MockInvoker\n+                .getMockObject(\"java.lang.String\", Integer.class));\n+        Assertions.assertThrows(IllegalStateException.class, () -> MockInvoker\n+                .getMockObject(\"java.io.Serializable\", Serializable.class));\n+    }\n+\n+    @Test\n+    public void testNormalizeMock() {\n+        Assertions.assertNull(MockInvoker.normalizeMock(null));\n+\n+        Assertions.assertEquals(\"\", MockInvoker.normalizeMock(\"\"));\n+        Assertions.assertEquals(\"\", MockInvoker.normalizeMock(\"fail:\"));\n+        Assertions.assertEquals(\"\", MockInvoker.normalizeMock(\"force:\"));\n+        Assertions.assertEquals(\"throw\", MockInvoker.normalizeMock(\"throw\"));\n+        Assertions.assertEquals(\"default\", MockInvoker.normalizeMock(\"fail\"));\n+        Assertions.assertEquals(\"default\", MockInvoker.normalizeMock(\"force\"));\n+        Assertions.assertEquals(\"default\", MockInvoker.normalizeMock(\"true\"));\n+        Assertions.assertEquals(\"default\",\n+                MockInvoker.normalizeMock(\"default\"));\n+        Assertions.assertEquals(\"return null\",\n+                MockInvoker.normalizeMock(\"return\"));\n+        Assertions.assertEquals(\"return null\",\n+                MockInvoker.normalizeMock(\"return null\"));\n+    }\n+}",
    "output": "Add unit tests for org.apache.dubbo.rpc.support.MockInvoker These tests were written using Diffblue Cover"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n@@ -371,13 +371,25 @@ public static void setInterface(MulticastSocket multicastSocket, boolean preferI\n             while (addresses.hasMoreElements()) {\n                 InetAddress address = (InetAddress) addresses.nextElement();\n                 if (preferIpv6 && address instanceof Inet6Address) {\n-                    multicastSocket.setInterface(address);\n-                    interfaceSet = true;\n-                    break;\n+                    try {\n+                        if(address.isReachable(100)){\n+                            multicastSocket.setInterface(address);\n+                            interfaceSet = true;\n+                            break;\n+                        }\n+                    } catch (IOException e) {\n+                        // ignore\n+                    }\n                 } else if (!preferIpv6 && address instanceof Inet4Address) {\n-                    multicastSocket.setInterface(address);\n-                    interfaceSet = true;\n-                    break;\n+                    try {\n+                        if(address.isReachable(100)){\n+                            multicastSocket.setInterface(address);\n+                            interfaceSet = true;\n+                            break;\n+                        }\n+                    } catch (IOException e) {\n+                        // ignore\n+                    }\n                 }\n             }\n             if (interfaceSet) {",
    "output": "Fix MulticastSocket setInterface choose an unreachable address"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n@@ -94,7 +94,7 @@ private static BeanDefinition parse(Element element, ParserContext parserContext\n                 id = generatedBeanName + (counter++);\n             }\n         }\n-        if (id != null && id.length() > 0) {\n+        if (StringUtils.isNotEmpty(id)) {\n             if (parserContext.getRegistry().containsBeanDefinition(id)) {\n                 throw new IllegalStateException(\"Duplicate spring bean id \" + id);\n             }",
    "output": "Use StringUtils"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AsyncToSyncInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AsyncToSyncInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AsyncToSyncInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AsyncToSyncInvoker.java\n@@ -29,9 +29,6 @@\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n-import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_TIMEOUT;\n-import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\n-\n /**\n  * This class will work as a wrapper wrapping outside of each protocol invoker.\n  *",
    "output": "Remove unused imports"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java\n@@ -24,7 +24,6 @@\n import com.alibaba.nacos.api.NacosFactory;\n import com.alibaba.nacos.api.exception.NacosException;\n import com.alibaba.nacos.api.naming.NamingService;\n-import com.alibaba.nacos.client.naming.utils.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -101,7 +100,7 @@ private void setProperties(URL url, Properties properties) {\n     private void putPropertyIfAbsent(URL url, Properties properties, String propertyName) {\n         String propertyValue = url.getParameter(propertyName);\n-        if (StringUtils.isNotEmpty(propertyValue)) {\n+        if (propertyValue != null && propertyValue.trim().length() != 0) {\n             properties.setProperty(propertyName, propertyValue);\n         }\n     }",
    "output": "Fix bug about nacos * fix bug * add trim"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/TypeDefinitionBuilder.java b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/TypeDefinitionBuilder.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/TypeDefinitionBuilder.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/TypeDefinitionBuilder.java\n@@ -33,10 +33,10 @@\n public class TypeDefinitionBuilder {\n     private static final List<TypeBuilder> BUILDERS;\n-    static{\n+    static {\n         List<TypeBuilder> builders = new ArrayList<>();\n         ExtensionLoader<TypeBuilder> extensionLoader = ExtensionLoader.getExtensionLoader(TypeBuilder.class);\n-        for(String extensionName : extensionLoader.getSupportedExtensions()){\n+        for (String extensionName : extensionLoader.getSupportedExtensions()) {\n             builders.add(extensionLoader.getExtension(extensionName));\n         }\n         BUILDERS = builders;\n@@ -47,8 +47,10 @@ public static TypeDefinition build(Type type, Class<?> clazz, Map<Class<?>, Type\n         TypeDefinition td;\n         if (builder != null) {\n             td = builder.build(type, clazz, typeCache);\n+            td.setTypeBuilderName(builder.getClass().getName());\n         } else {\n             td = DefaultTypeBuilder.build(clazz, typeCache);\n+            td.setTypeBuilderName(DefaultTypeBuilder.class.getName());\n         }\n         return td;\n     }\ndiff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/MethodDefinition.java b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/MethodDefinition.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/MethodDefinition.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/MethodDefinition.java\n@@ -16,9 +16,7 @@\n  */\n package org.apache.dubbo.metadata.definition.model;\n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.List;\n import java.util.Objects;\n /**\n@@ -29,19 +27,11 @@ public class MethodDefinition {\n     private String name;\n     private String[] parameterTypes;\n     private String returnType;\n-    private List<TypeDefinition> parameters;\n     public String getName() {\n         return name;\n     }\n-    public List<TypeDefinition> getParameters() {\n-        if (parameters == null) {\n-            parameters = new ArrayList<>();\n-        }\n-        return parameters;\n-    }\n-\n     public String[] getParameterTypes() {\n         return parameterTypes;\n     }\n@@ -54,10 +44,6 @@ public void setName(String name) {\n         this.name = name;\n     }\n-    public void setParameters(List<TypeDefinition> parameters) {\n-        this.parameters = parameters;\n-    }\n-\n     public void setParameterTypes(String[] parameterTypes) {\n         this.parameterTypes = parameterTypes;\n     }\n@@ -83,13 +69,12 @@ public boolean equals(Object o) {\n         MethodDefinition that = (MethodDefinition) o;\n         return Objects.equals(getName(), that.getName()) &&\n                 Arrays.equals(getParameterTypes(), that.getParameterTypes()) &&\n-                Objects.equals(getReturnType(), that.getReturnType()) &&\n-                Objects.equals(getParameters(), that.getParameters());\n+                Objects.equals(getReturnType(), that.getReturnType());\n     }\n     @Override\n     public int hashCode() {\n-        int result = Objects.hash(getName(), getReturnType(), getParameters());\n+        int result = Objects.hash(getName(), getReturnType());\n         result = 31 * result + Arrays.hashCode(getParameterTypes());\n         return result;\n     }\ndiff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/model/TypeDefinition.java\n@@ -37,6 +37,7 @@ public class TypeDefinition {\n     private List<String> enums;\n     private String $ref;\n     private Map<String, TypeDefinition> properties;\n+    private String typeBuilderName;\n     public TypeDefinition(String type) {\n         this.type = type;\n@@ -75,6 +76,10 @@ public String getType() {\n         return type;\n     }\n+    public String getTypeBuilderName() {\n+        return typeBuilderName;\n+    }\n+\n     public void set$ref(String $ref) {\n         this.$ref = $ref;\n     }\n@@ -99,6 +104,10 @@ public void setType(String type) {\n         this.type = type;\n     }\n+    public void setTypeBuilderName(String typeBuilderName) {\n+        this.typeBuilderName = typeBuilderName;\n+    }\n+\n     @Override\n     public String toString() {\n         return \"TypeDefinition [id=\" + id + \", type=\" + type + \", properties=\" + properties + \", $ref=\" + $ref + \"]\";\ndiff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/MetadataTest.java b/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/MetadataTest.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/MetadataTest.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/MetadataTest.java\n@@ -16,6 +16,10 @@\n  */\n package org.apache.dubbo.metadata.definition;\n+import org.apache.dubbo.metadata.definition.builder.CollectionTypeBuilder;\n+import org.apache.dubbo.metadata.definition.builder.DefaultTypeBuilder;\n+import org.apache.dubbo.metadata.definition.builder.EnumTypeBuilder;\n+import org.apache.dubbo.metadata.definition.builder.MapTypeBuilder;\n import org.apache.dubbo.metadata.definition.common.ClassExtendsMap;\n import org.apache.dubbo.metadata.definition.common.ColorEnum;\n import org.apache.dubbo.metadata.definition.common.OuterClass;\n@@ -46,7 +50,7 @@ public void testInnerClassType() {\n         Assertions.assertEquals(\"org.apache.dubbo.metadata.definition.common.OuterClass$InnerClass\", td.getType());\n         Assertions.assertEquals(1, td.getProperties().size());\n         Assertions.assertNotNull(td.getProperties().get(\"name\"));\n-\n+        Assertions.assertEquals(DefaultTypeBuilder.class.getName(), td.getTypeBuilderName());\n         ServiceDefinition sd = MetadataUtils.generateMetadata(TestService.class);\n         System.out.println(\">> testInnerClassType: \" + new Gson().toJson(sd));\n@@ -73,7 +77,9 @@ public void testRawMap() {\n         Assertions.assertEquals(\"org.apache.dubbo.metadata.definition.common.ResultWithRawCollections\", td.getType());\n         Assertions.assertEquals(2, td.getProperties().size());\n         Assertions.assertEquals(\"java.util.Map\", td.getProperties().get(\"map\").getType());\n+        Assertions.assertEquals(MapTypeBuilder.class.getName(), td.getProperties().get(\"map\").getTypeBuilderName());\n         Assertions.assertEquals(\"java.util.List\", td.getProperties().get(\"list\").getType());\n+        Assertions.assertEquals(CollectionTypeBuilder.class.getName(), td.getProperties().get(\"list\").getTypeBuilderName());\n         ServiceDefinition sd = MetadataUtils.generateMetadata(TestService.class);\n         System.out.println(\">> testRawMap: \" + new Gson().toJson(sd));\n@@ -97,6 +103,7 @@ public void testEnum() {\n         System.out.println(\">> testEnum: \" + new Gson().toJson(td));\n         Assertions.assertEquals(\"org.apache.dubbo.metadata.definition.common.ColorEnum\", td.getType());\n+        Assertions.assertEquals(EnumTypeBuilder.class.getName(), td.getTypeBuilderName());\n         Assertions.assertEquals(3, td.getEnums().size());\n         Assertions.assertTrue(td.getEnums().contains(\"RED\"));\n         Assertions.assertTrue(td.getEnums().contains(\"YELLOW\"));\n@@ -124,6 +131,7 @@ public void testExtendsMap() {\n         System.out.println(\">> testExtendsMap: \" + new Gson().toJson(td));\n         Assertions.assertEquals(\"org.apache.dubbo.metadata.definition.common.ClassExtendsMap\", td.getType());\n+        Assertions.assertEquals(MapTypeBuilder.class.getName(), td.getTypeBuilderName());\n         Assertions.assertEquals(0, td.getProperties().size());\n         ServiceDefinition sd = MetadataUtils.generateMetadata(TestService.class);",
    "output": "Add TypeDefinitionBuilderName to TypeDefinition"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.registry.nacos;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.URLBuilder;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.UrlUtils;\n@@ -35,7 +36,6 @@\n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -52,13 +52,14 @@\n import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n-import static org.apache.dubbo.registry.Constants.ADMIN_PROTOCOL;\n import static org.apache.dubbo.common.constants.RegistryConstants.CATEGORY_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.CONFIGURATORS_CATEGORY;\n import static org.apache.dubbo.common.constants.RegistryConstants.CONSUMERS_CATEGORY;\n import static org.apache.dubbo.common.constants.RegistryConstants.DEFAULT_CATEGORY;\n+import static org.apache.dubbo.common.constants.RegistryConstants.EMPTY_PROTOCOL;\n import static org.apache.dubbo.common.constants.RegistryConstants.PROVIDERS_CATEGORY;\n import static org.apache.dubbo.common.constants.RegistryConstants.ROUTERS_CATEGORY;\n+import static org.apache.dubbo.registry.Constants.ADMIN_PROTOCOL;\n /**\n  * Nacos {@link Registry}\n@@ -136,7 +137,7 @@ public List<URL> lookup(final URL url) {\n             List<String> serviceNames = getServiceNames(url, null);\n             for (String serviceName : serviceNames) {\n                 List<Instance> instances = namingService.getAllInstances(serviceName);\n-                urls.addAll(buildURLs(url, instances));\n+                urls.addAll(buildURLs(url, serviceName, instances));\n             }\n         });\n         return urls;\n@@ -168,7 +169,7 @@ private void doSubscribe(final URL url, final NotifyListener listener, final Lis\n         execute(namingService -> {\n             for (String serviceName : serviceNames) {\n                 List<Instance> instances = namingService.getAllInstances(serviceName);\n-                notifySubscriber(url, listener, instances);\n+                notifySubscriber(url, serviceName, listener, instances);\n                 subscribeEventListener(serviceName, url, listener);\n             }\n         });\n@@ -332,9 +333,9 @@ private List<String> doGetServiceNames(URL url) {\n         return serviceNames;\n     }\n-    private List<URL> buildURLs(URL consumerURL, Collection<Instance> instances) {\n+    private List<URL> buildURLs(URL consumerURL, String serviceName, Collection<Instance> instances) {\n         if (instances.isEmpty()) {\n-            return Collections.emptyList();\n+            return emptyURL(consumerURL, serviceName);\n         }\n         List<URL> urls = new LinkedList<>();\n         for (Instance instance : instances) {\n@@ -352,7 +353,7 @@ private void subscribeEventListener(String serviceName, final URL url, final Not\n             EventListener eventListener = event -> {\n                 if (event instanceof NamingEvent) {\n                     NamingEvent e = (NamingEvent) event;\n-                    notifySubscriber(url, listener, e.getInstances());\n+                    notifySubscriber(url, serviceName, listener, e.getInstances());\n                 }\n             };\n             namingService.subscribe(serviceName, eventListener);\n@@ -364,14 +365,15 @@ private void subscribeEventListener(String serviceName, final URL url, final Not\n      * Notify the Healthy {@link Instance instances} to subscriber.\n      *\n      * @param url       {@link URL}\n+     * @param serviceName\n      * @param listener  {@link NotifyListener}\n      * @param instances all {@link Instance instances}\n      */\n-    private void notifySubscriber(URL url, NotifyListener listener, Collection<Instance> instances) {\n+    private void notifySubscriber(URL url, String serviceName, NotifyListener listener, Collection<Instance> instances) {\n         List<Instance> healthyInstances = new LinkedList<>(instances);\n         // Healthy Instances\n         filterHealthyInstances(healthyInstances);\n-        List<URL> urls = buildURLs(url, healthyInstances);\n+        List<URL> urls = buildURLs(url, serviceName, healthyInstances);\n         NacosRegistry.this.notify(url, listener, urls);\n     }\n@@ -397,6 +399,18 @@ private URL buildURL(Instance instance) {\n                 instance.getMetadata());\n     }\n+    private List<URL> emptyURL(URL consumerURL, String serviceName) {\n+        int i = serviceName.indexOf(SERVICE_NAME_SEPARATOR);\n+        String category = i < 0 ? serviceName : serviceName.substring(0, i);\n+        URL empty = URLBuilder.from(consumerURL)\n+                .setProtocol(EMPTY_PROTOCOL)\n+                .addParameter(CATEGORY_KEY, category)\n+                .build();\n+        List<URL> result = new ArrayList<URL>();\n+        result.add(empty);\n+        return result;\n+    }\n+\n     private Instance createInstance(URL url) {\n         // Append default category if absent\n         String category = url.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);",
    "output": "Use empty protocol for nacos registry when address list is empty"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/QosConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/QosConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/QosConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/QosConstants.java\n@@ -22,9 +22,15 @@\n  */\n public interface QosConstants {\n-    String QOS_ENABLE = \"qos-enable\";\n+    String QOS_ENABLE = \"qos.enable\";\n-    String QOS_PORT = \"qos-port\";\n+    String QOS_PORT = \"qos.port\";\n-    String ACCEPT_FOREIGN_IP = \"qos-accept-foreign-ip\";\n+    String ACCEPT_FOREIGN_IP = \"qos.accept.foreign.ip\";\n+\n+    String QOS_ENABLE_COMPATIBLE = \"qos-enable\";\n+\n+    String QOS_PORT_COMPATIBLE = \"qos-port\";\n+\n+    String ACCEPT_FOREIGN_IP_COMPATIBLE = \"qos-accept-foreign-ip\";\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n@@ -30,8 +30,11 @@\n import static org.apache.dubbo.common.constants.CommonConstants.DUMP_DIRECTORY;\n import static org.apache.dubbo.common.constants.CommonConstants.SHUTDOWN_WAIT_KEY;\n import static org.apache.dubbo.common.constants.QosConstants.ACCEPT_FOREIGN_IP;\n+import static org.apache.dubbo.common.constants.QosConstants.ACCEPT_FOREIGN_IP_COMPATIBLE;\n import static org.apache.dubbo.common.constants.QosConstants.QOS_ENABLE;\n+import static org.apache.dubbo.common.constants.QosConstants.QOS_ENABLE_COMPATIBLE;\n import static org.apache.dubbo.common.constants.QosConstants.QOS_PORT;\n+import static org.apache.dubbo.common.constants.QosConstants.QOS_PORT_COMPATIBLE;\n import static org.apache.dubbo.config.Constants.ARCHITECTURE;\n import static org.apache.dubbo.config.Constants.DEVELOPMENT_ENVIRONMENT;\n import static org.apache.dubbo.config.Constants.ENVIRONMENT;\n@@ -317,36 +320,34 @@ public void setQosAcceptForeignIp(Boolean qosAcceptForeignIp) {\n         this.qosAcceptForeignIp = qosAcceptForeignIp;\n     }\n-    @Deprecated\n-    @Parameter(key = \"qos.enable\", excluded = true)\n-    public Boolean getQosEnableDeprecated() {\n+    /**\n+     * The format is the same as the springboot, including: getQosEnableCompatible(), getQosPortCompatible(), getQosAcceptForeignIpCompatible().\n+     * @return\n+     */\n+    @Parameter(key = QOS_ENABLE_COMPATIBLE, excluded = true)\n+    public Boolean getQosEnableCompatible() {\n         return getQosEnable();\n     }\n-    @Deprecated\n-    public void setQosEnableDeprecated(Boolean qosEnable) {\n+    public void setQosEnableCompatible(Boolean qosEnable) {\n         setQosEnable(qosEnable);\n     }\n-    @Deprecated\n-    @Parameter(key = \"qos.port\", excluded = true)\n-    public Integer getQosPortDeprecated() {\n+    @Parameter(key = QOS_PORT_COMPATIBLE, excluded = true)\n+    public Integer getQosPortCompatible() {\n         return getQosPort();\n     }\n-    @Deprecated\n-    public void setQosPortDeprecated(Integer qosPort) {\n+    public void setQosPortCompatible(Integer qosPort) {\n         this.setQosPort(qosPort);\n     }\n-    @Deprecated\n-    @Parameter(key = \"qos.accept.foreign.ip\", excluded = true)\n-    public Boolean getQosAcceptForeignIpDeprecated() {\n+    @Parameter(key = ACCEPT_FOREIGN_IP_COMPATIBLE, excluded = true)\n+    public Boolean getQosAcceptForeignIpCompatible() {\n         return this.getQosAcceptForeignIp();\n     }\n-    @Deprecated\n-    public void setQosAcceptForeignIpDeprecated(Boolean qosAcceptForeignIp) {\n+    public void setQosAcceptForeignIpCompatible(Boolean qosAcceptForeignIp) {\n         this.setQosAcceptForeignIp(qosAcceptForeignIp);\n     }",
    "output": "Fix qos configuration cannot work after added 'qos-enable' style support"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/QosConstants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/QosConstants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/constants/QosConstants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/constants/QosConstants.java\n@@ -22,9 +22,15 @@\n  */\n public interface QosConstants {\n-    String QOS_ENABLE = \"qos-enable\";\n+    String QOS_ENABLE = \"qos.enable\";\n-    String QOS_PORT = \"qos-port\";\n+    String QOS_PORT = \"qos.port\";\n-    String ACCEPT_FOREIGN_IP = \"qos-accept-foreign-ip\";\n+    String ACCEPT_FOREIGN_IP = \"qos.accept.foreign.ip\";\n+\n+    String QOS_ENABLE_COMPATIBLE = \"qos-enable\";\n+\n+    String QOS_PORT_COMPATIBLE = \"qos-port\";\n+\n+    String ACCEPT_FOREIGN_IP_COMPATIBLE = \"qos-accept-foreign-ip\";\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n@@ -30,8 +30,11 @@\n import static org.apache.dubbo.common.constants.CommonConstants.DUMP_DIRECTORY;\n import static org.apache.dubbo.common.constants.CommonConstants.SHUTDOWN_WAIT_KEY;\n import static org.apache.dubbo.common.constants.QosConstants.ACCEPT_FOREIGN_IP;\n+import static org.apache.dubbo.common.constants.QosConstants.ACCEPT_FOREIGN_IP_COMPATIBLE;\n import static org.apache.dubbo.common.constants.QosConstants.QOS_ENABLE;\n+import static org.apache.dubbo.common.constants.QosConstants.QOS_ENABLE_COMPATIBLE;\n import static org.apache.dubbo.common.constants.QosConstants.QOS_PORT;\n+import static org.apache.dubbo.common.constants.QosConstants.QOS_PORT_COMPATIBLE;\n import static org.apache.dubbo.config.Constants.ARCHITECTURE;\n import static org.apache.dubbo.config.Constants.DEVELOPMENT_ENVIRONMENT;\n import static org.apache.dubbo.config.Constants.ENVIRONMENT;\n@@ -317,36 +320,34 @@ public void setQosAcceptForeignIp(Boolean qosAcceptForeignIp) {\n         this.qosAcceptForeignIp = qosAcceptForeignIp;\n     }\n-    @Deprecated\n-    @Parameter(key = \"qos.enable\", excluded = true)\n-    public Boolean getQosEnableDeprecated() {\n+    /**\n+     * The format is the same as the springboot, including: getQosEnableCompatible(), getQosPortCompatible(), getQosAcceptForeignIpCompatible().\n+     * @return\n+     */\n+    @Parameter(key = QOS_ENABLE_COMPATIBLE, excluded = true)\n+    public Boolean getQosEnableCompatible() {\n         return getQosEnable();\n     }\n-    @Deprecated\n-    public void setQosEnableDeprecated(Boolean qosEnable) {\n+    public void setQosEnableCompatible(Boolean qosEnable) {\n         setQosEnable(qosEnable);\n     }\n-    @Deprecated\n-    @Parameter(key = \"qos.port\", excluded = true)\n-    public Integer getQosPortDeprecated() {\n+    @Parameter(key = QOS_PORT_COMPATIBLE, excluded = true)\n+    public Integer getQosPortCompatible() {\n         return getQosPort();\n     }\n-    @Deprecated\n-    public void setQosPortDeprecated(Integer qosPort) {\n+    public void setQosPortCompatible(Integer qosPort) {\n         this.setQosPort(qosPort);\n     }\n-    @Deprecated\n-    @Parameter(key = \"qos.accept.foreign.ip\", excluded = true)\n-    public Boolean getQosAcceptForeignIpDeprecated() {\n+    @Parameter(key = ACCEPT_FOREIGN_IP_COMPATIBLE, excluded = true)\n+    public Boolean getQosAcceptForeignIpCompatible() {\n         return this.getQosAcceptForeignIp();\n     }\n-    @Deprecated\n-    public void setQosAcceptForeignIpDeprecated(Boolean qosAcceptForeignIp) {\n+    public void setQosAcceptForeignIpCompatible(Boolean qosAcceptForeignIp) {\n         this.setQosAcceptForeignIp(qosAcceptForeignIp);\n     }",
    "output": "Fix qos configuration cannot work after added 'qos-enable' style support"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/beanutil/JavaBeanSerializeUtil.java b/dubbo-common/src/main/java/org/apache/dubbo/common/beanutil/JavaBeanSerializeUtil.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/beanutil/JavaBeanSerializeUtil.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/beanutil/JavaBeanSerializeUtil.java\n@@ -237,12 +237,12 @@ private static void deserializeInternal(Object result, JavaBeanDescriptor beanDe\n             for (Map.Entry<Object, Object> entry : beanDescriptor) {\n                 Object key = entry.getKey();\n                 Object value = entry.getValue();\n-                if (key != null && key instanceof JavaBeanDescriptor) {\n+                if (key instanceof JavaBeanDescriptor) {\n                     JavaBeanDescriptor keyDescriptor = (JavaBeanDescriptor) entry.getKey();\n                     key = instantiateForDeserialize(keyDescriptor, loader, cache);\n                     deserializeInternal(key, keyDescriptor, loader, cache);\n                 }\n-                if (value != null && value instanceof JavaBeanDescriptor) {\n+                if (value instanceof JavaBeanDescriptor) {\n                     JavaBeanDescriptor valueDescriptor = (JavaBeanDescriptor) entry.getValue();\n                     value = instantiateForDeserialize(valueDescriptor, loader, cache);\n                     deserializeInternal(value, valueDescriptor, loader, cache);\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/json/JSONArray.java b/dubbo-common/src/main/java/org/apache/dubbo/common/json/JSONArray.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/json/JSONArray.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/json/JSONArray.java\n@@ -47,7 +47,7 @@ public Object get(int index) {\n      */\n     public boolean getBoolean(int index, boolean def) {\n         Object tmp = mArray.get(index);\n-        return tmp != null && tmp instanceof Boolean ? ((Boolean) tmp).booleanValue() : def;\n+        return tmp instanceof Boolean ? ((Boolean) tmp).booleanValue() : def;\n     }\n     /**\n@@ -59,7 +59,7 @@ public boolean getBoolean(int index, boolean def) {\n      */\n     public int getInt(int index, int def) {\n         Object tmp = mArray.get(index);\n-        return tmp != null && tmp instanceof Number ? ((Number) tmp).intValue() : def;\n+        return tmp instanceof Number ? ((Number) tmp).intValue() : def;\n     }\n     /**\n@@ -71,7 +71,7 @@ public int getInt(int index, int def) {\n      */\n     public long getLong(int index, long def) {\n         Object tmp = mArray.get(index);\n-        return tmp != null && tmp instanceof Number ? ((Number) tmp).longValue() : def;\n+        return tmp instanceof Number ? ((Number) tmp).longValue() : def;\n     }\n     /**\n@@ -83,7 +83,7 @@ public long getLong(int index, long def) {\n      */\n     public float getFloat(int index, float def) {\n         Object tmp = mArray.get(index);\n-        return tmp != null && tmp instanceof Number ? ((Number) tmp).floatValue() : def;\n+        return tmp instanceof Number ? ((Number) tmp).floatValue() : def;\n     }\n     /**\n@@ -95,7 +95,7 @@ public float getFloat(int index, float def) {\n      */\n     public double getDouble(int index, double def) {\n         Object tmp = mArray.get(index);\n-        return tmp != null && tmp instanceof Number ? ((Number) tmp).doubleValue() : def;\n+        return tmp instanceof Number ? ((Number) tmp).doubleValue() : def;\n     }\n     /**\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/json/JSONObject.java b/dubbo-common/src/main/java/org/apache/dubbo/common/json/JSONObject.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/json/JSONObject.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/json/JSONObject.java\n@@ -47,7 +47,7 @@ public Object get(String key) {\n      */\n     public boolean getBoolean(String key, boolean def) {\n         Object tmp = mMap.get(key);\n-        return tmp != null && tmp instanceof Boolean ? (Boolean) tmp : def;\n+        return tmp instanceof Boolean ? (Boolean) tmp : def;\n     }\n     /**\n@@ -59,7 +59,7 @@ public boolean getBoolean(String key, boolean def) {\n      */\n     public int getInt(String key, int def) {\n         Object tmp = mMap.get(key);\n-        return tmp != null && tmp instanceof Number ? ((Number) tmp).intValue() : def;\n+        return tmp instanceof Number ? ((Number) tmp).intValue() : def;\n     }\n     /**\n@@ -71,7 +71,7 @@ public int getInt(String key, int def) {\n      */\n     public long getLong(String key, long def) {\n         Object tmp = mMap.get(key);\n-        return tmp != null && tmp instanceof Number ? ((Number) tmp).longValue() : def;\n+        return tmp instanceof Number ? ((Number) tmp).longValue() : def;\n     }\n     /**\n@@ -83,7 +83,7 @@ public long getLong(String key, long def) {\n      */\n     public float getFloat(String key, float def) {\n         Object tmp = mMap.get(key);\n-        return tmp != null && tmp instanceof Number ? ((Number) tmp).floatValue() : def;\n+        return tmp instanceof Number ? ((Number) tmp).floatValue() : def;\n     }\n     /**\n@@ -95,7 +95,7 @@ public float getFloat(String key, float def) {\n      */\n     public double getDouble(String key, double def) {\n         Object tmp = mMap.get(key);\n-        return tmp != null && tmp instanceof Number ? ((Number) tmp).doubleValue() : def;\n+        return tmp instanceof Number ? ((Number) tmp).doubleValue() : def;\n     }\n     /**\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/ProviderInvokerWrapper.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/ProviderInvokerWrapper.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/ProviderInvokerWrapper.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/ProviderInvokerWrapper.java\n@@ -90,7 +90,7 @@ public void setReg(boolean reg) {\n     @Override\n     public boolean equals(Object o) {\n-        if (o == null || !(o instanceof ProviderInvokerWrapper)) {\n+        if (!(o instanceof ProviderInvokerWrapper)) {\n             return false;\n         }\n         ProviderInvokerWrapper other = (ProviderInvokerWrapper) o;\ndiff --git a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyHelper.java b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyHelper.java\n--- a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyHelper.java\n+++ b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyHelper.java\n@@ -27,7 +27,7 @@ final class NettyHelper {\n     public static void setNettyLoggerFactory() {\n         InternalLoggerFactory factory = InternalLoggerFactory.getDefaultFactory();\n-        if (factory == null || !(factory instanceof DubboLoggerFactory)) {\n+        if (!(factory instanceof DubboLoggerFactory)) {\n             InternalLoggerFactory.setDefaultFactory(new DubboLoggerFactory());\n         }\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/DubboTelnetDecodeTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/DubboTelnetDecodeTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/DubboTelnetDecodeTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/DubboTelnetDecodeTest.java\n@@ -452,7 +452,7 @@ private ByteBuf createDubboByteBuf() throws IOException {\n     }\n     private static boolean checkTelnetDecoded(Object msg) {\n-        if (msg != null && msg instanceof String && !msg.toString().contains(\"Unsupported command:\")) {\n+        if (msg instanceof String && !msg.toString().contains(\"Unsupported command:\")) {\n             return true;\n         }\n         return false;",
    "output": "Remove unnecessary null check before instance of"
  },
  {
    "input": "diff --git a/dubbo-filter/dubbo-filter-cache/src/main/java/org/apache/dubbo/cache/support/expiring/ExpiringMap.java b/dubbo-filter/dubbo-filter-cache/src/main/java/org/apache/dubbo/cache/support/expiring/ExpiringMap.java\n--- a/dubbo-filter/dubbo-filter-cache/src/main/java/org/apache/dubbo/cache/support/expiring/ExpiringMap.java\n+++ b/dubbo-filter/dubbo-filter-cache/src/main/java/org/apache/dubbo/cache/support/expiring/ExpiringMap.java\n@@ -22,6 +22,7 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n /**\n@@ -40,7 +41,7 @@ public class ExpiringMap<K, V> implements Map<K, V> {\n      */\n     private static final int DEFAULT_EXPIRATION_INTERVAL = 1;\n-    private static volatile int expireCount = 1;\n+    private static AtomicInteger expireCount = new AtomicInteger(1);\n     private final ConcurrentHashMap<K, ExpiryObject> delegateMap;\n@@ -263,7 +264,7 @@ public String toString() {\n         }\n         public ExpireThread() {\n-            expirerThread = new Thread(this, \"ExpiryMapExpire-\" + expireCount++);\n+            expirerThread = new Thread(this, \"ExpiryMapExpire-\" + expireCount.getAndIncrement());\n             expirerThread.setDaemon(true);\n         }",
    "output": "Fix use AtomicInteger instead of volatile to inc"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n@@ -1168,7 +1168,7 @@ public Map<String, String> toMap() {\n             map.put(USERNAME_KEY, username);\n         }\n         if (password != null) {\n-            map.put(USERNAME_KEY, password);\n+            map.put(PASSWORD_KEY, password);\n         }\n         if (host != null) {\n             map.put(HOST_KEY, host);",
    "output": "Fix org.apache.dubbo.common.URL#toMap change password key, from USERNAME_KEY to PASSWORD_KEY LGTM"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRouterRule.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRouterRule.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRouterRule.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRouterRule.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.rpc.cluster.router.tag.model;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.rpc.cluster.router.AbstractRouterRule;\n import java.util.ArrayList;\n@@ -50,7 +51,7 @@ public void init() {\n             return;\n         }\n-        tags.forEach(tag -> {\n+        tags.stream().filter(tag -> CollectionUtils.isNotEmpty(tag.getAddresses())).forEach(tag -> {\n             tagnameToAddresses.put(tag.getName(), tag.getAddresses());\n             tag.getAddresses().forEach(addr -> {\n                 List<String> tagNames = addressToTagnames.computeIfAbsent(addr, k -> new ArrayList<>());\n@@ -60,7 +61,10 @@ public void init() {\n     }\n     public List<String> getAddresses() {\n-        return tags.stream().flatMap(tag -> tag.getAddresses().stream()).collect(Collectors.toList());\n+        return tags.stream()\n+                .filter(tag -> CollectionUtils.isNotEmpty(tag.getAddresses()))\n+                .flatMap(tag -> tag.getAddresses().stream())\n+                .collect(Collectors.toList());\n     }\n     public List<String> getTagNames() {\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n@@ -19,6 +19,8 @@\n import org.apache.curator.framework.CuratorFramework;\n import org.apache.curator.framework.CuratorFrameworkFactory;\n import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRuleParser;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n@@ -63,4 +65,47 @@ public void normalTagRuleTest() {\n     private void setData(String path, String data) throws Exception {\n         client.setData().forPath(path, data.getBytes());\n     }\n+\n+    /**\n+     * TagRouterRule parse test when the tags addresses is null\n+     *\n+     * <pre>\n+     *     ~ -> null\n+     *     null -> null\n+     * </pre>\n+     */\n+    @Test\n+    public void tagRouterRuleParseTest(){\n+        String tagRouterRuleConfig = \"---\\n\" +\n+                \"force: false\\n\" +\n+                \"runtime: true\\n\" +\n+                \"enabled: false\\n\" +\n+                \"priority: 1\\n\" +\n+                \"key: demo-provider\\n\" +\n+                \"tags:\\n\" +\n+                \"  - name: tag1\\n\" +\n+                \"    addresses: null\\n\" +\n+                \"  - name: tag2\\n\" +\n+                \"    addresses: [\\\"30.5.120.37:20880\\\"]\\n\" +\n+                \"  - name: tag3\\n\" +\n+                \"    addresses: []\\n\" +\n+                \"  - name: tag4\\n\" +\n+                \"    addresses: ~\\n\" +\n+                \"...\";\n+\n+        TagRouterRule tagRouterRule = TagRuleParser.parse(tagRouterRuleConfig);\n+\n+        // assert tags\n+        assert tagRouterRule.getTagNames().contains(\"tag1\");\n+        assert tagRouterRule.getTagNames().contains(\"tag2\");\n+        assert tagRouterRule.getTagNames().contains(\"tag3\");\n+        assert tagRouterRule.getTagNames().contains(\"tag4\");\n+        // assert addresses\n+        assert tagRouterRule.getAddresses().contains(\"30.5.120.37:20880\");\n+        assert tagRouterRule.getTagnameToAddresses().get(\"tag1\")==null;\n+        assert tagRouterRule.getTagnameToAddresses().get(\"tag2\").size()==1;\n+        assert tagRouterRule.getTagnameToAddresses().get(\"tag3\")==null;\n+        assert tagRouterRule.getTagnameToAddresses().get(\"tag4\")==null;\n+        assert tagRouterRule.getAddresses().size()==1;\n+    }\n }",
    "output": "Fix NPE when the TagRouterRule addresses config is null * Fix NPE when the TagRouterRule addresses config is null * fix import * add more test"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-xml/src/main/java/org/apache/dubbo/xml/rpc/protocol/xmlrpc/XmlRpcProtocol.java b/dubbo-rpc/dubbo-rpc-xml/src/main/java/org/apache/dubbo/xml/rpc/protocol/xmlrpc/XmlRpcProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-xml/src/main/java/org/apache/dubbo/xml/rpc/protocol/xmlrpc/XmlRpcProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-xml/src/main/java/org/apache/dubbo/xml/rpc/protocol/xmlrpc/XmlRpcProtocol.java\n@@ -151,7 +151,6 @@ public void run() {\n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    @Override\n     protected <T> T doRefer(final Class<T> serviceType, URL url) throws RpcException {\n         XmlRpcProxyFactoryBean xmlRpcProxyFactoryBean = new XmlRpcProxyFactoryBean();\n         xmlRpcProxyFactoryBean.setServiceUrl(url.setProtocol(\"http\").toIdentityString());\n@@ -195,4 +194,4 @@ public void destroy() {\n             }\n         }\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Remove duplicate @Override"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -557,9 +557,9 @@ public synchronized void doOverrideIfNecessary() {\n             URL currentUrl = exporter.getInvoker().getUrl();\n             //Merged with this configuration\n             URL newUrl = getConfigedInvokerUrl(configurators, originUrl);\n+            newUrl = getConfigedInvokerUrl(providerConfigurationListener.getConfigurators(), newUrl);\n             newUrl = getConfigedInvokerUrl(serviceConfigurationListeners.get(originUrl.getServiceKey())\n                     .getConfigurators(), newUrl);\n-            newUrl = getConfigedInvokerUrl(providerConfigurationListener.getConfigurators(), newUrl);\n             if (!currentUrl.equals(newUrl)) {\n                 RegistryProtocol.this.reExport(originInvoker, newUrl);\n                 logger.info(\"exported provider url changed, origin url: \" + originUrl +",
    "output": "Fix for #4175: ServiceConfigurationListener should override ProviderConfigurationListener"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java\n@@ -35,7 +35,7 @@\n  */\n @io.netty.channel.ChannelHandler.Sharable\n public class NettyClientHandler extends ChannelDuplexHandler {\n-    private static final Logger logger = LoggerFactory.getLogger(NettyClient.class);\n+    private static final Logger logger = LoggerFactory.getLogger(NettyClientHandler.class);\n     private final URL url;",
    "output": "Change logger name"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AppResponse.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AppResponse.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AppResponse.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AppResponse.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.rpc;\n import java.io.Serializable;\n+import java.lang.reflect.Field;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.function.Function;\n@@ -64,6 +65,23 @@ public AppResponse(Throwable exception) {\n     @Override\n     public Object recreate() throws Throwable {\n         if (exception != null) {\n+            // fix issue#619\n+            try {\n+                // get Throwable class\n+                Class clazz = exception.getClass();\n+                while (!clazz.getName().equals(Throwable.class.getName())) {\n+                    clazz = clazz.getSuperclass();\n+                }\n+                // get stackTrace value\n+                Field stackTraceField = clazz.getDeclaredField(\"stackTrace\");\n+                stackTraceField.setAccessible(true);\n+                Object stackTrace = stackTraceField.get(exception);\n+                if (stackTrace == null) {\n+                    exception.setStackTrace(new StackTraceElement[0]);\n+                }\n+            } catch (Exception e) {\n+                // ignore\n+            }\n             throw exception;\n         }\n         return result;",
    "output": "Add miss-deleted snippet from #2956"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java\n@@ -278,19 +278,19 @@ private void filterServiceNames(List<String> serviceNames, URL url) {\n         final String targetServiceInterface = url.getServiceInterface();\n-        final String targetVersion = url.getParameter(VERSION_KEY);\n+        final String targetVersion = url.getParameter(VERSION_KEY,\"\");\n-        final String targetGroup = url.getParameter(GROUP_KEY);\n+        final String targetGroup = url.getParameter(GROUP_KEY,\"\");\n         filterData(serviceNames, serviceName -> {\n             // split service name to segments\n             // (required) segments[0] = category\n             // (required) segments[1] = serviceInterface\n-            // (required) segments[2] = version\n+            // (optional) segments[2] = version\n             // (optional) segments[3] = group\n             String[] segments = StringUtils.split(serviceName, SERVICE_NAME_SEPARATOR);\n             int length = segments.length;\n-            if (length < 3) { // must present 3 segments or more\n+            if (length != 4) { // must present 4 segments\n                 return false;\n             }\n@@ -311,8 +311,7 @@ private void filterServiceNames(List<String> serviceNames, URL url) {\n                 return false;\n             }\n-            String group = length > 3 ? segments[SERVICE_GROUP_INDEX] : null;\n-            // no match service group\n+            String group = segments[SERVICE_GROUP_INDEX];\n             return group == null || WILDCARD.equals(targetGroup)\n                     || StringUtils.equals(targetGroup, group);\n         });\n@@ -420,16 +419,17 @@ private String getServiceName(URL url) {\n     private String getServiceName(URL url, String category) {\n         StringBuilder serviceNameBuilder = new StringBuilder(category);\n-        appendIfPresent(serviceNameBuilder, url, INTERFACE_KEY);\n-        appendIfPresent(serviceNameBuilder, url, VERSION_KEY);\n-        appendIfPresent(serviceNameBuilder, url, GROUP_KEY);\n+        append(serviceNameBuilder, url, INTERFACE_KEY);\n+        append(serviceNameBuilder, url, VERSION_KEY);\n+        append(serviceNameBuilder, url, GROUP_KEY);\n         return serviceNameBuilder.toString();\n     }\n-    private void appendIfPresent(StringBuilder target, URL url, String parameterName) {\n+    private void append(StringBuilder target, URL url, String parameterName) {\n+        target.append(SERVICE_NAME_SEPARATOR);\n         String parameterValue = url.getParameter(parameterName);\n         if (!StringUtils.isBlank(parameterValue)) {\n-            target.append(SERVICE_NAME_SEPARATOR).append(parameterValue);\n+            target.append(parameterValue);\n         }\n     }",
    "output": "Fix for #4111 do not ignore empty value when we construct servicename"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -356,6 +356,7 @@ private T createProxy(Map<String, String> map) {\n                 logger.info(\"Using injvm service \" + interfaceClass.getName());\n             }\n         } else {\n+            urls.clear(); // reference retry init will add url to urls, lead to OOM\n             if (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.\n                 String[] us = SEMICOLON_SPLIT_PATTERN.split(url);\n                 if (us != null && us.length > 0) {",
    "output": "Fix client retry create proxy lead to OOM"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-nacos/src/test/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfigurationTest.java b/dubbo-configcenter/dubbo-configcenter-nacos/src/test/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfigurationTest.java\n--- a/dubbo-configcenter/dubbo-configcenter-nacos/src/test/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfigurationTest.java\n+++ b/dubbo-configcenter/dubbo-configcenter-nacos/src/test/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfigurationTest.java\n@@ -36,7 +36,8 @@\n /**\n  * Unit test for nacos config center support\n  */\n-@Disabled\n+//FIXME: waiting for embedded Nacos suport, then we can open the switch.\n+@Disabled(\"https://github.com/alibaba/nacos/issues/1188\")\n public class NacosDynamicConfigurationTest {\n     private static NacosDynamicConfiguration config;\ndiff --git a/dubbo-metadata-report/dubbo-metadata-report-nacos/src/test/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReportTest.java b/dubbo-metadata-report/dubbo-metadata-report-nacos/src/test/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReportTest.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-nacos/src/test/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReportTest.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-nacos/src/test/java/org/apache/dubbo/metadata/store/nacos/NacosMetadataReportTest.java\n@@ -37,7 +37,8 @@\n import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;\n import static org.apache.dubbo.common.constants.RegistryConstants.SESSION_TIMEOUT_KEY;\n-@Disabled\n+//FIXME: waiting for embedded Nacos suport, then we can open the switch.\n+@Disabled(\"https://github.com/alibaba/nacos/issues/1188\")\n public class NacosMetadataReportTest {\n     private static final String TEST_SERVICE = \"org.apache.dubbo.metadata.store.nacos.NacosMetadata4TstService\";\n     private NacosMetadataReport nacosMetadataReport;",
    "output": "Add comment for disabled Nacos test, fix this later"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java\n@@ -38,6 +38,7 @@\n import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.CATEGORY_KEY;\n+import static org.apache.dubbo.common.constants.RegistryConstants.COMPATIBLE_CONFIG_KEY;\n import static org.apache.dubbo.common.constants.RegistryConstants.DYNAMIC_KEY;\n /**\n@@ -126,6 +127,7 @@ private URL configureIfMatch(String host, URL url) {\n                     conditionKeys.add(APPLICATION_KEY);\n                     conditionKeys.add(SIDE_KEY);\n                     conditionKeys.add(CONFIG_VERSION_KEY);\n+                    conditionKeys.add(COMPATIBLE_CONFIG_KEY);\n                     for (Map.Entry<String, String> entry : configuratorUrl.getParameters().entrySet()) {\n                         String key = entry.getKey();\n                         String value = entry.getValue();",
    "output": "Remove compatible key when merging"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n@@ -58,7 +58,6 @@\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.CopyOnWriteArrayList;\n import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\n import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n@@ -544,7 +543,7 @@ private void batchClientRefIncr(List<ReferenceCountExchangeClient> referenceCoun\n      * @return\n      */\n     private List<ReferenceCountExchangeClient> buildReferenceCountExchangeClientList(URL url, int connectNum) {\n-        List<ReferenceCountExchangeClient> clients = new CopyOnWriteArrayList<>();\n+        List<ReferenceCountExchangeClient> clients = new ArrayList<>();\n         for (int i = 0; i < connectNum; i++) {\n             clients.add(buildReferenceCountExchangeClient(url));",
    "output": "Change CopyOnWriteArrayList to regular list in DubboProtocol"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n@@ -30,6 +30,7 @@\n import java.lang.reflect.Proxy;\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n@@ -542,7 +543,8 @@ private static Object newInstance(Class<?> cls) {\n                     }\n                 }\n                 constructor.setAccessible(true);\n-                return constructor.newInstance(new Object[constructor.getParameterTypes().length]);\n+                Object[] parameters = Arrays.stream(constructor.getParameterTypes()).map(PojoUtils::getDefaultValue).toArray();\n+                return constructor.newInstance(parameters);\n             } catch (InstantiationException e) {\n                 throw new RuntimeException(e.getMessage(), e);\n             } catch (IllegalAccessException e) {\n@@ -553,6 +555,21 @@ private static Object newInstance(Class<?> cls) {\n         }\n     }\n+    /**\n+     * return init value\n+     * @param parameterType\n+     * @return\n+     */\n+    private static Object getDefaultValue(Class<?> parameterType) {\n+        if (parameterType.getName().equals(\"char\")) {\n+            return Character.MIN_VALUE;\n+        }\n+        if (parameterType.getName().equals(\"bool\")) {\n+            return false;\n+        }\n+        return parameterType.isPrimitive() ? 0 : null;\n+    }\n+\n     private static Method getSetterMethod(Class<?> cls, String property, Class<?> valueCls) {\n         String name = \"set\" + property.substring(0, 1).toUpperCase() + property.substring(1);\n         Method method = NAME_METHODS_CACHE.get(cls.getName() + \".\" + name + \"(\" + valueCls.getName() + \")\");\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/model/User.java b/dubbo-common/src/test/java/org/apache/dubbo/common/model/User.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/model/User.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/model/User.java\n@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.common.model;\n+\n+import java.util.Objects;\n+\n+/**\n+ * @author: fibbery\n+ * @date: 2019-05-13 18:41\n+ * @description: this class has no nullary constructor and some field is primitive\n+ */\n+public class User {\n+    private int age;\n+\n+    private String name;\n+\n+    public User(int age, String name) {\n+        this.age = age;\n+        this.name = name;\n+    }\n+\n+    public int getAge() {\n+        return age;\n+    }\n+\n+    public void setAge(int age) {\n+        this.age = age;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"User name(%s) age(%d) \", name, age);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        User user = (User) o;\n+        if (name == null) {\n+            if (user.name != null) {\n+                return false;\n+            }\n+        } else if (!name.equals(user.name)) {\n+            return false;\n+        }\n+        return Objects.equals(age, user.age);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(age, name);\n+    }\n+}\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.model.Person;\n import org.apache.dubbo.common.model.SerializablePerson;\n+import org.apache.dubbo.common.model.User;\n import org.apache.dubbo.common.model.person.BigPerson;\n import org.apache.dubbo.common.model.person.FullAddress;\n import org.apache.dubbo.common.model.person.PersonInfo;\n@@ -132,6 +133,11 @@ public void test_pojo() throws Exception {\n         assertObject(new SerializablePerson());\n     }\n+    @Test\n+    public void test_has_no_nullary_constructor_pojo() {\n+        assertObject(new User(1,\"fibbery\"));\n+    }\n+\n     @Test\n     public void test_Map_List_pojo() throws Exception {\n         Map<String, List<Object>> map = new HashMap<String, List<Object>>();",
    "output": "Fix telnet not work in some scene"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AvailableCluster.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AvailableCluster.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AvailableCluster.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AvailableCluster.java\n@@ -16,15 +16,10 @@\n  */\n package org.apache.dubbo.rpc.cluster.support;\n-import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n-import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.cluster.Cluster;\n import org.apache.dubbo.rpc.cluster.Directory;\n-import org.apache.dubbo.rpc.cluster.LoadBalance;\n-\n-import java.util.List;\n /**\n  * AvailableCluster\n@@ -36,19 +31,7 @@ public class AvailableCluster implements Cluster {\n     @Override\n     public <T> Invoker<T> join(Directory<T> directory) throws RpcException {\n-\n-        return new AbstractClusterInvoker<T>(directory) {\n-            @Override\n-            public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n-                for (Invoker<T> invoker : invokers) {\n-                    if (invoker.isAvailable()) {\n-                        return invoker.invoke(invocation);\n-                    }\n-                }\n-                throw new RpcException(\"No provider available in \" + invokers);\n-            }\n-        };\n-\n+        return new AvailableClusterInvoker<>(directory);\n     }\n }",
    "output": "Use equal explicit class to replace anonymous class"
  },
  {
    "input": "diff --git a/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/Spring3CompatibilityTest.java b/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/Spring3CompatibilityTest.java\n--- a/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/Spring3CompatibilityTest.java\n+++ b/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/Spring3CompatibilityTest.java\n@@ -1,81 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.test;\n-\n-import org.apache.dubbo.demo.DemoService;\n-import org.apache.dubbo.test.consumer.ConsumerConfiguration;\n-import org.apache.dubbo.test.provider.ProviderConfiguration;\n-\n-import org.springframework.context.ConfigurableApplicationContext;\n-import org.springframework.context.annotation.AnnotationConfigApplicationContext;\n-import org.springframework.util.Assert;\n-\n-/**\n- * Dubbo compatibility test on Spring 3.2.x\n- *\n- * @since 2.5.8\n- */\n-public class Spring3CompatibilityTest {\n-\n-    public static void main(String[] args) {\n-\n-        ConfigurableApplicationContext provider = startupProvider();\n-\n-        ConfigurableApplicationContext consumer = startConsumer();\n-\n-        ConsumerConfiguration consumerConfiguration = consumer.getBean(ConsumerConfiguration.class);\n-\n-        DemoService demoService = consumerConfiguration.getDemoService();\n-\n-        String value = demoService.sayHello(\"Mercy\");\n-\n-        Assert.isTrue(\"DefaultDemoService - sayHell() : Mercy\".equals(value), \"Test is failed!\");\n-\n-        System.out.println(value);\n-\n-        provider.close();\n-        consumer.close();\n-\n-    }\n-\n-    private static ConfigurableApplicationContext startupProvider() {\n-\n-        ConfigurableApplicationContext context = startupApplicationContext(ProviderConfiguration.class);\n-\n-        System.out.println(\"Startup Provider ...\");\n-\n-        return context;\n-    }\n-\n-    private static ConfigurableApplicationContext startConsumer() {\n-\n-        ConfigurableApplicationContext context = startupApplicationContext(ConsumerConfiguration.class);\n-\n-        System.out.println(\"Startup Consumer ...\");\n-\n-        return context;\n-\n-    }\n-\n-    private static ConfigurableApplicationContext startupApplicationContext(Class<?>... annotatedClasses) {\n-        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n-        context.register(annotatedClasses);\n-        context.refresh();\n-        return context;\n-    }\n-\n-}\ndiff --git a/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/consumer/ConsumerConfiguration.java b/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/consumer/ConsumerConfiguration.java\n--- a/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/consumer/ConsumerConfiguration.java\n+++ b/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/consumer/ConsumerConfiguration.java\n@@ -1,46 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.test.consumer;\n-\n-import org.apache.dubbo.config.annotation.Reference;\n-import org.apache.dubbo.config.spring.context.annotation.DubboComponentScan;\n-import org.apache.dubbo.demo.DemoService;\n-\n-import org.springframework.context.annotation.Configuration;\n-import org.springframework.context.annotation.ImportResource;\n-\n-/**\n- * Consumer {@Link Configuration}\n- *\n- * @since 2.5.8\n- */\n-@Configuration\n-@ImportResource(\"META-INF/spring/dubbo-consumer.xml\")\n-@DubboComponentScan\n-public class ConsumerConfiguration {\n-\n-    @Reference(version = \"2.5.8\", url = \"dubbo://127.0.0.1:12345\")\n-    private DemoService demoService;\n-\n-    public DemoService getDemoService() {\n-        return demoService;\n-    }\n-\n-    public void setDemoService(DemoService demoService) {\n-        this.demoService = demoService;\n-    }\n-}\ndiff --git a/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/DefaultDemoService.java b/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/DefaultDemoService.java\n--- a/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/DefaultDemoService.java\n+++ b/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/DefaultDemoService.java\n@@ -1,40 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.test.provider;\n-\n-import org.apache.dubbo.config.annotation.Service;\n-import org.apache.dubbo.demo.DemoService;\n-\n-/**\n- * Default {@link DemoService} implementation\n- *\n- * @since 2.5.8\n- */\n-@Service(\n-        version = \"2.5.8\",\n-        application = \"dubbo-annotation-provider\",\n-        protocol = \"dubbo\",\n-        registry = \"my-registry\"\n-)\n-public class DefaultDemoService implements DemoService {\n-\n-    @Override\n-    public String sayHello(String name) {\n-        return \"DefaultDemoService - sayHell() : \" + name;\n-    }\n-\n-}\ndiff --git a/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/ProviderConfiguration.java b/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/ProviderConfiguration.java\n--- a/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/ProviderConfiguration.java\n+++ b/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/ProviderConfiguration.java\n@@ -1,33 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.test.provider;\n-\n-import org.apache.dubbo.config.spring.context.annotation.DubboComponentScan;\n-\n-import org.springframework.context.annotation.Configuration;\n-import org.springframework.context.annotation.ImportResource;\n-\n-/**\n- * Provider {@Link Configuration}\n- *\n- * @since 2.5.8\n- */\n-@Configuration\n-@ImportResource(\"META-INF/spring/dubbo-provider.xml\")\n-@DubboComponentScan\n-public class ProviderConfiguration {\n-}",
    "output": "Remove useless module-dubbo-test-integration"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -354,19 +354,22 @@ private T createProxy(Map<String, String> map) {\n                     }\n                 }\n             } else { // assemble URL from register center's configuration\n-                checkRegistry();\n-                List<URL> us = loadRegistries(false);\n-                if (CollectionUtils.isNotEmpty(us)) {\n-                    for (URL u : us) {\n-                        URL monitorUrl = loadMonitor(u);\n-                        if (monitorUrl != null) {\n-                            map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n+                // if protocols not injvm checkRegistry\n+                if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())){\n+                    checkRegistry();\n+                    List<URL> us = loadRegistries(false);\n+                    if (CollectionUtils.isNotEmpty(us)) {\n+                        for (URL u : us) {\n+                            URL monitorUrl = loadMonitor(u);\n+                            if (monitorUrl != null) {\n+                                map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n+                            }\n+                            urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n                         }\n-                        urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n                     }\n-                }\n-                if (urls.isEmpty()) {\n-                    throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n+                    if (urls.isEmpty()) {\n+                        throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n+                    }\n                 }\n             }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -269,9 +269,12 @@ public void checkAndUpdateSubConfigs() {\n         // Config Center should always being started first.\n         startConfigCenter();\n         checkDefault();\n-        checkApplication();\n-        checkRegistry();\n         checkProtocol();\n+        checkApplication();\n+        // if protocol is not injvm checkRegistry\n+        if (!isOnlyInJvm()) {\n+            checkRegistry();\n+        }\n         this.refresh();\n         checkMetadataReport();\n@@ -327,6 +330,15 @@ public void checkAndUpdateSubConfigs() {\n         checkMock(interfaceClass);\n     }\n+    /**\n+     * Determine if it is injvm\n+     *\n+     * @return\n+     */\n+    private boolean isOnlyInJvm() {\n+        return getProtocols().size() == 1 && Constants.LOCAL_PROTOCOL.equalsIgnoreCase(getProtocols().get(0).getName());\n+    }\n+\n     public synchronized void export() {\n         checkAndUpdateSubConfigs();\n@@ -539,11 +551,15 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n             }\n             // export to remote if the config is not local (export to local only when config is local)\n             if (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) {\n-                if (logger.isInfoEnabled()) {\n+                if (!isOnlyInJvm() && logger.isInfoEnabled()) {\n                     logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url);\n                 }\n                 if (CollectionUtils.isNotEmpty(registryURLs)) {\n                     for (URL registryURL : registryURLs) {\n+                        //if protocol is only injvm ,not register\n+                        if (Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {\n+                            continue;\n+                        }\n                         url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));\n                         URL monitorUrl = loadMonitor(registryURL);\n                         if (monitorUrl != null) {\n@@ -586,18 +602,19 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n     }\n     @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    /**\n+     * always export injvm\n+     */\n     private void exportLocal(URL url) {\n-        if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {\n-            URL local = URLBuilder.from(url)\n-                    .setProtocol(Constants.LOCAL_PROTOCOL)\n-                    .setHost(LOCALHOST_VALUE)\n-                    .setPort(0)\n-                    .build();\n-            Exporter<?> exporter = protocol.export(\n-                    proxyFactory.getInvoker(ref, (Class) interfaceClass, local));\n-            exporters.add(exporter);\n-            logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to local registry\");\n-        }\n+        URL local = URLBuilder.from(url)\n+                .setProtocol(Constants.LOCAL_PROTOCOL)\n+                .setHost(LOCALHOST_VALUE)\n+                .setPort(0)\n+                .build();\n+        Exporter<?> exporter = protocol.export(\n+                proxyFactory.getInvoker(ref, (Class) interfaceClass, local));\n+        exporters.add(exporter);\n+        logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to local registry url : \" + local);\n     }\n     private Optional<String> getContextPath(ProtocolConfig protocolConfig) {\n@@ -803,7 +820,7 @@ private void createProviderIfAbsent() {\n         if (provider != null) {\n             return;\n         }\n-        setProvider (\n+        setProvider(\n                 ConfigManager.getInstance()\n                         .getDefaultProvider()\n                         .orElseGet(() -> {\n@@ -834,15 +851,15 @@ private void convertProtocolIdsToProtocols() {\n         if (StringUtils.isEmpty(protocolIds)) {\n             if (CollectionUtils.isEmpty(protocols)) {\n-               setProtocols(\n-                       ConfigManager.getInstance().getDefaultProtocols()\n-                        .filter(CollectionUtils::isNotEmpty)\n-                        .orElseGet(() -> {\n-                            ProtocolConfig protocolConfig = new ProtocolConfig();\n-                            protocolConfig.refresh();\n-                            return new ArrayList<>(Arrays.asList(protocolConfig));\n-                        })\n-               );\n+                setProtocols(\n+                        ConfigManager.getInstance().getDefaultProtocols()\n+                                .filter(CollectionUtils::isNotEmpty)\n+                                .orElseGet(() -> {\n+                                    ProtocolConfig protocolConfig = new ProtocolConfig();\n+                                    protocolConfig.refresh();\n+                                    return new ArrayList<>(Arrays.asList(protocolConfig));\n+                                })\n+                );\n             }\n         } else {\n             String[] arr = Constants.COMMA_SPLIT_PATTERN.split(protocolIds);",
    "output": "Fix injvm export and refer * fix injvm export and refer * Add default injvm protocol is only injvm protocol don't register * Multiple protocol registry filter injvm * isOnlyJvm"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java\n@@ -128,28 +128,23 @@ static boolean isValidV4Address(InetAddress address) {\n             return false;\n         }\n         String name = address.getHostAddress();\n-        return (name != null\n+        boolean result = (name != null\n                 && IP_PATTERN.matcher(name).matches()\n                 && !Constants.ANYHOST_VALUE.equals(name)\n                 && !Constants.LOCALHOST_VALUE.equals(name));\n+        return result;\n     }\n     /**\n-     * Check if an ipv6 address is reachable.\n+     * Check if an ipv6 address\n      *\n-     * @param address the given address\n      * @return true if it is reachable\n      */\n-    static boolean isValidV6Address(Inet6Address address) {\n+    static boolean isPreferIPV6Address() {\n         boolean preferIpv6 = Boolean.getBoolean(\"java.net.preferIPv6Addresses\");\n         if (!preferIpv6) {\n             return false;\n         }\n-        try {\n-            return address.isReachable(100);\n-        } catch (IOException e) {\n-            // ignore\n-        }\n         return false;\n     }\n@@ -234,7 +229,7 @@ public static InetAddress getLocalAddress() {\n     private static Optional<InetAddress> toValidAddress(InetAddress address) {\n         if (address instanceof Inet6Address) {\n             Inet6Address v6Address = (Inet6Address) address;\n-            if (isValidV6Address(v6Address)) {\n+            if (isPreferIPV6Address()) {\n                 return Optional.ofNullable(normalizeV6Address(v6Address));\n             }\n         }\n@@ -264,12 +259,21 @@ private static InetAddress getLocalAddress0() {\n             while (interfaces.hasMoreElements()) {\n                 try {\n                     NetworkInterface network = interfaces.nextElement();\n+                    if (network.isLoopback() || network.isVirtual() || !network.isUp()) {\n+                        continue;\n+                    }\n                     Enumeration<InetAddress> addresses = network.getInetAddresses();\n                     while (addresses.hasMoreElements()) {\n                         try {\n                             Optional<InetAddress> addressOp = toValidAddress(addresses.nextElement());\n                             if (addressOp.isPresent()) {\n-                                return addressOp.get();\n+                                try {\n+                                    if(addressOp.get().isReachable(100)){\n+                                        return addressOp.get();\n+                                    }\n+                                } catch (IOException e) {\n+                                    // ignore\n+                                }\n                             }\n                         } catch (Throwable e) {\n                             logger.warn(e);\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/NetUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/NetUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/NetUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/NetUtilsTest.java\n@@ -191,7 +191,7 @@ public void testIsValidV6Address() {\n         System.setProperty(\"java.net.preferIPv6Addresses\", \"true\");\n         InetAddress address = NetUtils.getLocalAddress();\n         if (address instanceof Inet6Address) {\n-            assertThat(NetUtils.isValidV6Address((Inet6Address) address), equalTo(true));\n+            assertThat(NetUtils.isPreferIPV6Address(), equalTo(true));\n         }\n         System.setProperty(\"java.net.preferIPv6Addresses\", saved);\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java\n@@ -123,10 +123,6 @@ public class ApplicationConfig extends AbstractConfig {\n      */\n     private String shutwait;\n-\n-    private Boolean preferPublicIp;\n-\n-\n     public ApplicationConfig() {\n     }\n@@ -331,11 +327,4 @@ public boolean isValid() {\n         return !StringUtils.isEmpty(name);\n     }\n-    public Boolean getPreferPublicIp() {\n-        return preferPublicIp;\n-    }\n-\n-    public void setPreferPublicIp(Boolean preferPublicIp) {\n-        this.preferPublicIp = preferPublicIp;\n-    }\n }\n\\ No newline at end of file\ndiff --git a/dubbo-demo/dubbo-demo-api/dubbo-demo-api-provider/src/main/java/org/apache/dubbo/demo/provider/Application.java b/dubbo-demo/dubbo-demo-api/dubbo-demo-api-provider/src/main/java/org/apache/dubbo/demo/provider/Application.java\n--- a/dubbo-demo/dubbo-demo-api/dubbo-demo-api-provider/src/main/java/org/apache/dubbo/demo/provider/Application.java\n+++ b/dubbo-demo/dubbo-demo-api/dubbo-demo-api-provider/src/main/java/org/apache/dubbo/demo/provider/Application.java\n@@ -29,9 +29,10 @@ public class Application {\n      * launch the application\n      */\n     public static void main(String[] args) throws Exception {\n+        System.setProperty(\"DUBBO_IP_TO_REGISTRY\", \"4.3.2.1\");\n         ServiceConfig<DemoServiceImpl> service = new ServiceConfig<>();\n         service.setApplication(new ApplicationConfig(\"dubbo-demo-api-provider\"));\n-        service.setRegistry(new RegistryConfig(\"multicast://224.5.6.7:1234\"));\n+        service.setRegistry(new RegistryConfig(\"zookeeper://127.0.0.1:2181\"));\n         service.setInterface(DemoService.class);\n         service.setRef(new DemoServiceImpl());\n         service.export();",
    "output": "Improve NetUtils * 1. filter network interface in NetUtils 2. remove the useless attribute in ApplicationConfig * add reachable check for ipv4 * move the reachable check to outside * rename isValidV6Address to isPreferIPV6Address"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -360,6 +360,7 @@ private boolean shouldDelay() {\n         if (delay == null && provider != null) {\n             delay = provider.getDelay();\n         }\n+        this.delay = delay;\n         return delay != null && delay > 0;\n     }",
    "output": "Fix provider set delay NullPointerException * fixed provider set delay NullPointerException * add getActualDelay method * simple"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/DecodeHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/DecodeHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/DecodeHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/DecodeHandler.java\n@@ -52,7 +52,7 @@ public void received(Channel channel, Object message) throws RemotingException {\n     }\n     private void decode(Object message) {\n-        if (message != null && message instanceof Decodeable) {\n+        if (message instanceof Decodeable) {\n             try {\n                 ((Decodeable) message).decode();\n                 if (log.isDebugEnabled()) {",
    "output": "Remove unnecessary null check in conjunction with instanceof"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java\n@@ -88,7 +88,7 @@ public Result invoke(Invocation invocation) throws RpcException {\n                 if (e.isBiz()) {\n                     throw e;\n                 }\n-\n+\n                 if (logger.isWarnEnabled()) {\n                     logger.warn(\"fail-mock: \" + invocation.getMethodName() + \" fail-mock enabled , url : \" + directory.getUrl(), e);\n                 }\n@@ -105,7 +105,7 @@ private Result doMockInvoke(Invocation invocation, RpcException e) {\n         List<Invoker<T>> mockInvokers = selectMockInvoker(invocation);\n         if (CollectionUtils.isEmpty(mockInvokers)) {\n-            minvoker = (Invoker<T>) new MockInvoker(directory.getUrl());\n+            minvoker = (Invoker<T>) new MockInvoker(directory.getUrl(), directory.getInterface());\n         } else {\n             minvoker = mockInvokers.get(0);\n         }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockInvoker.java\n@@ -46,9 +46,11 @@ final public class MockInvoker<T> implements Invoker<T> {\n     private final static Map<String, Throwable> throwables = new ConcurrentHashMap<String, Throwable>();\n     private final URL url;\n+    private final Class<T> type;\n-    public MockInvoker(URL url) {\n+    public MockInvoker(URL url, Class<T> type) {\n         this.url = url;\n+        this.type = type;\n     }\n     public static Object parseMockValue(String mock) throws Exception {\n@@ -251,7 +253,6 @@ public void destroy() {\n     @Override\n     public Class<T> getInterface() {\n-        //FIXME\n-        return null;\n+        return type;\n     }\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockProtocol.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockProtocol.java\n@@ -39,6 +39,6 @@ public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n     @Override\n     public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n-        return new MockInvoker<T>(url);\n+        return new MockInvoker<>(url, type);\n     }\n }",
    "output": "Fix issue #3713: org.apache.dubbo.rpc.support.MockInvoker#getInterface should not return null"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.common.Version;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.ConfigUtils;\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.common.utils.UrlUtils;\n import org.apache.dubbo.remoting.ChannelHandler;\n@@ -35,11 +36,14 @@\n import io.netty.channel.ChannelOption;\n import io.netty.channel.nio.NioEventLoopGroup;\n import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.proxy.Socks5ProxyHandler;\n import io.netty.handler.timeout.IdleStateHandler;\n import io.netty.util.concurrent.DefaultThreadFactory;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import java.net.InetSocketAddress;\n+\n /**\n  * NettyClient.\n  */\n@@ -48,6 +52,12 @@ public class NettyClient extends AbstractClient {\n     private static final Logger logger = LoggerFactory.getLogger(NettyClient.class);\n     private static final NioEventLoopGroup nioEventLoopGroup = new NioEventLoopGroup(Constants.DEFAULT_IO_THREADS, new DefaultThreadFactory(\"NettyClientWorker\", true));\n+\n+    private static final String SOCKS_PROXY_HOST = \"socksProxyHost\";\n+\n+    private static final String SOCKS_PROXY_PORT = \"socksProxyPort\";\n+\n+    private static final String DEFAULT_SOCKS_PROXY_PORT = \"1080\";\n     private Bootstrap bootstrap;\n@@ -85,6 +95,12 @@ protected void initChannel(Channel ch) throws Exception {\n                         .addLast(\"encoder\", adapter.getEncoder())\n                         .addLast(\"client-idle-handler\", new IdleStateHandler(heartbeatInterval, 0, 0, MILLISECONDS))\n                         .addLast(\"handler\", nettyClientHandler);\n+                String socksProxyHost = ConfigUtils.getProperty(SOCKS_PROXY_HOST);\n+                if(socksProxyHost != null) {\n+                    int socksProxyPort = Integer.parseInt(ConfigUtils.getProperty(SOCKS_PROXY_PORT, DEFAULT_SOCKS_PROXY_PORT));\n+                    Socks5ProxyHandler socks5ProxyHandler = new Socks5ProxyHandler(new InetSocketAddress(socksProxyHost, socksProxyPort));\n+                    ch.pipeline().addFirst(socks5ProxyHandler);\n+                }\n             }\n         });\n     }",
    "output": "Add socks5 proxy support"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/delegate/TimestampDelegate.java b/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/delegate/TimestampDelegate.java\n--- a/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/delegate/TimestampDelegate.java\n+++ b/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/delegate/TimestampDelegate.java\n@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common.serialize.protostuff.delegate;\n+\n+import io.protostuff.Input;\n+import io.protostuff.Output;\n+import io.protostuff.Pipe;\n+import io.protostuff.WireFormat.FieldType;\n+import io.protostuff.runtime.Delegate;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+\n+/**\n+ * Custom {@link Timestamp} delegate\n+ */\n+public class TimestampDelegate implements Delegate<Timestamp> {\n+\n+    @Override\n+    public FieldType getFieldType() {\n+        return FieldType.FIXED64;\n+    }\n+\n+    @Override\n+    public Timestamp readFrom(Input input) throws IOException {\n+        return new Timestamp(input.readFixed64());\n+    }\n+\n+    @Override\n+    public void writeTo(Output output, int number, Timestamp value, boolean repeated) throws IOException {\n+        output.writeFixed64(number, value.getTime(), repeated);\n+    }\n+\n+    @Override\n+    public void transfer(Pipe pipe, Input input, Output output, int number, boolean repeated) throws IOException {\n+        output.writeFixed64(number, input.readFixed64(), repeated);\n+    }\n+\n+    @Override\n+    public Class<?> typeClass() {\n+        return Timestamp.class;\n+    }\n+}\ndiff --git a/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/utils/WrapperUtils.java b/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/utils/WrapperUtils.java\n--- a/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/utils/WrapperUtils.java\n+++ b/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/utils/WrapperUtils.java\n@@ -22,9 +22,11 @@\n import io.protostuff.runtime.DefaultIdStrategy;\n import io.protostuff.runtime.RuntimeEnv;\n+import org.apache.dubbo.common.serialize.protostuff.delegate.TimestampDelegate;\n import java.math.BigDecimal;\n import java.sql.Time;\n+import java.sql.Timestamp;\n import java.util.ArrayList;\n import java.util.BitSet;\n import java.util.Calendar;\n@@ -52,6 +54,7 @@ public class WrapperUtils {\n     static {\n         if (RuntimeEnv.ID_STRATEGY instanceof DefaultIdStrategy) {\n             ((DefaultIdStrategy) RuntimeEnv.ID_STRATEGY).registerDelegate(new TimeDelegate());\n+            ((DefaultIdStrategy) RuntimeEnv.ID_STRATEGY).registerDelegate(new TimestampDelegate());\n         }\n         WRAPPER_SET.add(Map.class);\n@@ -80,6 +83,7 @@ public class WrapperUtils {\n         WRAPPER_SET.add(Date.class);\n         WRAPPER_SET.add(Calendar.class);\n         WRAPPER_SET.add(Time.class);\n+        WRAPPER_SET.add(Timestamp.class);\n         WRAPPER_SET.add(Wrapper.class);\ndiff --git a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutputTest.java b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutputTest.java\n--- a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutputTest.java\n+++ b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutputTest.java\n@@ -16,12 +16,14 @@\n  */\n package org.apache.dubbo.common.serialize.protostuff;\n+import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.nullValue;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.sql.Timestamp;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n@@ -46,6 +48,16 @@ public void testWriteObjectNull() throws IOException, ClassNotFoundException {\n         assertThat(protostuffObjectInput.readObject(), nullValue());\n     }\n+    @Test\n+    public void testSerializeTimestamp() throws IOException, ClassNotFoundException {\n+        Timestamp originTime = new Timestamp(System.currentTimeMillis());\n+        this.protostuffObjectOutput.writeObject(originTime);\n+        this.flushToInput();\n+\n+        Timestamp serializedTime = protostuffObjectInput.readObject(Timestamp.class);\n+        assertThat(serializedTime, is(originTime));\n+    }\n+\n     private void flushToInput() throws IOException {\n         this.protostuffObjectOutput.flushBuffer();\n         this.byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());",
    "output": "Fix protostuff serialize java.sql.Timestamp * fix: #3727 * style: code tidy up * style: add apache license * fix: #3914 protostuff serialize java.sql.Timestamp"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -673,4 +673,9 @@ private void resolveFile() {\n             }\n         }\n     }\n+\n+    @Parameter(excluded = true)\n+    public String getUniqueServiceName() {\n+        return URL.buildKey(interfaceName, group, version);\n+    }\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -1022,4 +1022,9 @@ public void setProviders(List<ProviderConfig> providers) {\n     public String getPrefix() {\n         return Constants.DUBBO + \".service.\" + interfaceName;\n     }\n+\n+    @Parameter(excluded = true)\n+    public String getUniqueServiceName() {\n+        return URL.buildKey(interfaceName, group, version);\n+    }\n }",
    "output": "Add 'getUniqueServiceKey' to keep backward compatibility"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n@@ -22,6 +22,7 @@\n import org.apache.dubbo.config.support.Parameter;\n import org.apache.dubbo.rpc.ExporterListener;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n@@ -210,7 +211,7 @@ public ProtocolConfig getProtocol() {\n     }\n     public void setProtocol(ProtocolConfig protocol) {\n-        setProtocols(Arrays.asList(protocol));\n+        setProtocols(new ArrayList<>(Arrays.asList(protocol)));\n     }\n     @Parameter(excluded = true)\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProviderConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProviderConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProviderConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProviderConfig.java\n@@ -25,6 +25,7 @@\n import org.apache.dubbo.remoting.exchange.Exchanger;\n import org.apache.dubbo.remoting.telnet.TelnetHandler;\n+import java.util.ArrayList;\n import java.util.Arrays;\n /**\n@@ -157,7 +158,7 @@ public class ProviderConfig extends AbstractServiceConfig {\n     @Deprecated\n     public void setProtocol(String protocol) {\n-        this.protocols = Arrays.asList(new ProtocolConfig[]{new ProtocolConfig(protocol)});\n+        this.protocols = new ArrayList<>(Arrays.asList(new ProtocolConfig(protocol)));\n     }\n     @Parameter(excluded = true)\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -830,7 +830,7 @@ private void convertProtocolIdsToProtocols() {\n                         .orElseGet(() -> {\n                             ProtocolConfig protocolConfig = new ProtocolConfig();\n                             protocolConfig.refresh();\n-                            return Arrays.asList(protocolConfig);\n+                            return new ArrayList<>(Arrays.asList(protocolConfig));\n                         })\n                );\n             }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractServiceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractServiceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractServiceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractServiceConfigTest.java\n@@ -21,6 +21,7 @@\n import org.junit.jupiter.api.Test;\n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n@@ -110,7 +111,7 @@ public void testProtocol() throws Exception {\n         assertThat(serviceConfig.getProtocol(), nullValue());\n         serviceConfig.setProtocol(new ProtocolConfig());\n         assertThat(serviceConfig.getProtocol(), notNullValue());\n-        serviceConfig.setProtocols(Collections.singletonList(new ProtocolConfig()));\n+        serviceConfig.setProtocols(new ArrayList<>(Collections.singletonList(new ProtocolConfig())));\n         assertThat(serviceConfig.getProtocols(), hasSize(1));\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java\n@@ -28,6 +28,7 @@\n import org.apache.dubbo.config.api.DemoService;\n import org.apache.dubbo.config.provider.impl.DemoServiceImpl;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import static org.junit.jupiter.api.Assertions.fail;\n@@ -154,8 +155,8 @@ protected void initServConf() {\n         provConf.setRegistry(regConfForProvider);\n         servConf.setRegistry(regConfForService);\n-        provConf.setProtocols(Arrays.asList(new ProtocolConfig[]{protoConfForProvider}));\n-        servConf.setProtocols(Arrays.asList(new ProtocolConfig[]{protoConfForService}));\n+        provConf.setProtocols(new ArrayList<>(Arrays.asList(protoConfForProvider)));\n+        servConf.setProtocols(new ArrayList<>(Arrays.asList(protoConfForService)));\n         servConf.setMethods(Arrays.asList(new MethodConfig[]{methodConfForService}));\n         servConf.setProvider(provConf);",
    "output": "Make protocols a mutable list (a concrete ArrayList) * use ArrayList instead of Arrays.ArrayList"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryProtocolTest.java b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryProtocolTest.java\n--- a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryProtocolTest.java\n+++ b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryProtocolTest.java\n@@ -61,14 +61,14 @@ public class RegistryProtocolTest {\n     @Test\n     public void testDefaultPort() {\n-        RegistryProtocol registryProtocol = new RegistryProtocol();\n+        RegistryProtocol registryProtocol = RegistryProtocol.getRegistryProtocol();\n         assertEquals(9090, registryProtocol.getDefaultPort());\n     }\n     @Test\n     public void testExportUrlNull() {\n         Assertions.assertThrows(IllegalArgumentException.class, () -> {\n-            RegistryProtocol registryProtocol = new RegistryProtocol();\n+            RegistryProtocol registryProtocol = RegistryProtocol.getRegistryProtocol();\n             registryProtocol.setCluster(new FailfastCluster());\n             Protocol dubboProtocol = DubboProtocol.getDubboProtocol();\n@@ -81,7 +81,7 @@ public void testExportUrlNull() {\n     @Test\n     public void testExport() {\n-        RegistryProtocol registryProtocol = new RegistryProtocol();\n+        RegistryProtocol registryProtocol = RegistryProtocol.getRegistryProtocol();\n         registryProtocol.setCluster(new FailfastCluster());\n         registryProtocol.setRegistryFactory(ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension());\n@@ -165,7 +165,7 @@ public void testDestoryRegistry() {\n     @Test\n     public void testGetParamsToRegistry() {\n-        RegistryProtocol registryProtocol = new RegistryProtocol();\n+        RegistryProtocol registryProtocol = RegistryProtocol.getRegistryProtocol();\n         String[] additionalParams = new String[]{\"key1\", \"key2\"};\n         String[] registryParams = registryProtocol.getParamsToRegistry(DEFAULT_REGISTER_PROVIDER_KEYS, additionalParams);\n         String[] expectParams = ArrayUtils.addAll(DEFAULT_REGISTER_PROVIDER_KEYS, additionalParams);",
    "output": "Change tests to use singleton RegistryProtocol instead of making new instances"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n@@ -85,6 +85,9 @@ protected RpcContext initialValue() {\n     private InetSocketAddress localAddress;\n     private InetSocketAddress remoteAddress;\n+\n+    private String remoteApplicationName;\n+\n     @Deprecated\n     private List<Invoker<?>> invokers;\n     @Deprecated\n@@ -149,6 +152,7 @@ public RpcContext copyOf() {\n         copy.arguments = this.arguments;\n         copy.localAddress = this.localAddress;\n         copy.remoteAddress = this.remoteAddress;\n+        copy.remoteApplicationName = this.remoteApplicationName;\n         copy.invokers = this.invokers;\n         copy.invoker = this.invoker;\n         copy.invocation = this.invocation;\n@@ -407,6 +411,15 @@ public RpcContext setRemoteAddress(InetSocketAddress address) {\n         return this;\n     }\n+    public String getRemoteApplicationName() {\n+        return remoteApplicationName;\n+    }\n+\n+    public RpcContext setRemoteApplicationName(String remoteApplicationName) {\n+        this.remoteApplicationName = remoteApplicationName;\n+        return this;\n+    }\n+\n     /**\n      * get remote address string.\n      *\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java\n@@ -29,6 +29,8 @@\n import java.util.HashMap;\n import java.util.Map;\n+import static org.apache.dubbo.common.Constants.REMOTE_APPLICATION_KEY;\n+\n /**\n  * ContextFilter set the provider RpcContext with invoker, invocation, local port it is using and host for\n  * current execution thread.\n@@ -59,8 +61,8 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept\n                 .setInvoker(invoker)\n                 .setInvocation(invocation)\n //                .setAttachments(attachments)  // merged from dubbox\n-                .setLocalAddress(invoker.getUrl().getHost(),\n-                        invoker.getUrl().getPort());\n+                .setLocalAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort())\n+                .setRemoteApplicationName(invoker.getUrl().getParameter(REMOTE_APPLICATION_KEY));\n         // merged from dubbox\n         // we may already added some attachments into RpcContext before this filter (e.g. in rest protocol)",
    "output": "Add remoteApplicationName in RpcContext"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/config/annotation/Service.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/config/annotation/Service.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/config/annotation/Service.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/config/annotation/Service.java\n@@ -47,7 +47,7 @@\n     boolean deprecated() default false;\n-    boolean dynamic() default false;\n+    boolean dynamic() default true;\n     String accesslog() default \"\";\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n@@ -74,7 +74,7 @@ public abstract class AbstractServiceConfig extends AbstractInterfaceConfig {\n      * after the service registered,and it needs to be enabled manually; if you want to disable the service, you also need\n      * manual processing\n      */\n-    protected Boolean dynamic = false;\n+    protected Boolean dynamic = true;\n     /**\n      * Whether to use token\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/annotation/Service.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/annotation/Service.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/annotation/Service.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/annotation/Service.java\n@@ -79,9 +79,9 @@\n     boolean deprecated() default false;\n     /**\n-     * Whether the service is dynamic, default value is false\n+     * Whether the service is dynamic, default value is true\n      */\n-    boolean dynamic() default false;\n+    boolean dynamic() default true;\n     /**\n      * Access log for the service, default value is \"\"",
    "output": "Make `dynamic` default true to promise that the url will delete from zk whenever provider shutdown"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n@@ -54,7 +54,7 @@ public class ZookeeperRegistry extends FailbackRegistry {\n     private final Set<String> anyServices = new ConcurrentHashSet<>();\n-    private final ConcurrentMap<URL, ConcurrentMap<NotifyListener, ChildListener>> zkListeners = new ConcurrentHashMap<URL, ConcurrentMap<NotifyListener, ChildListener>>();\n+    private final ConcurrentMap<URL, ConcurrentMap<NotifyListener, ChildListener>> zkListeners = new ConcurrentHashMap<>();\n     private final ZookeeperClient zkClient;",
    "output": "Remove unnecessary groupId in pom.xml and replace with diamond operator"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/store/MetadataReport.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/store/MetadataReport.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/store/MetadataReport.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/store/MetadataReport.java\n@@ -26,7 +26,7 @@\n  */\n public interface MetadataReport {\n-    public static final String META_DATA_SOTRE_TAG = \".metaData\";\n+    public static final String META_DATA_STORE_TAG = \".metaData\";\n     void storeProviderMetadata(MetadataIdentifier providerMetadataIdentifier, FullServiceDefinition serviceDefinition);\ndiff --git a/dubbo-metadata-report/dubbo-metadata-report-consul/src/main/java/org/apache/dubbo/metadata/store/consul/ConsulMetadataReport.java b/dubbo-metadata-report/dubbo-metadata-report-consul/src/main/java/org/apache/dubbo/metadata/store/consul/ConsulMetadataReport.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-consul/src/main/java/org/apache/dubbo/metadata/store/consul/ConsulMetadataReport.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-consul/src/main/java/org/apache/dubbo/metadata/store/consul/ConsulMetadataReport.java\n@@ -55,7 +55,7 @@ protected void doStoreConsumerMetadata(MetadataIdentifier consumerMetadataIdenti\n     private void storeMetadata(MetadataIdentifier identifier, String v) {\n         try {\n-            client.setKVValue(identifier.getIdentifierKey() + META_DATA_SOTRE_TAG, v);\n+            client.setKVValue(identifier.getIdentifierKey() + META_DATA_STORE_TAG, v);\n         } catch (Throwable t) {\n             logger.error(\"Failed to put \" + identifier + \" to consul \" + v + \", cause: \" + t.getMessage(), t);\n             throw new RpcException(\"Failed to put \" + identifier + \" to consul \" + v + \", cause: \" + t.getMessage(), t);\ndiff --git a/dubbo-metadata-report/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java b/dubbo-metadata-report/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java\n@@ -52,7 +52,7 @@ protected void doStoreConsumerMetadata(MetadataIdentifier consumerMetadataIdenti\n     private void storeMetadata(MetadataIdentifier metadataIdentifier, String v) {\n         try (Jedis jedis = pool.getResource()) {\n-            jedis.set(metadataIdentifier.getIdentifierKey() + META_DATA_SOTRE_TAG, v);\n+            jedis.set(metadataIdentifier.getIdentifierKey() + META_DATA_STORE_TAG, v);\n         } catch (Throwable e) {\n             logger.error(\"Failed to put \" + metadataIdentifier + \" to redis \" + v + \", cause: \" + e.getMessage(), e);\n             throw new RpcException(\"Failed to put \" + metadataIdentifier + \" to redis \" + v + \", cause: \" + e.getMessage(), e);\ndiff --git a/dubbo-metadata-report/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java b/dubbo-metadata-report/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n@@ -36,7 +36,7 @@\n import java.util.Map;\n import static org.apache.dubbo.common.Constants.SYNC_REPORT_KEY;\n-import static org.apache.dubbo.metadata.store.MetadataReport.META_DATA_SOTRE_TAG;\n+import static org.apache.dubbo.metadata.store.MetadataReport.META_DATA_STORE_TAG;\n /**\n  * 2018/10/9\n@@ -81,7 +81,7 @@ private void testStoreProvider(RedisMetadataReport redisMetadataReport, String v\n         Jedis jedis = null;\n         try {\n             jedis = redisMetadataReport.pool.getResource();\n-            String keyTmp = providerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_SOTRE_TAG;\n+            String keyTmp = providerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_STORE_TAG;\n             String value = jedis.get(keyTmp);\n             if (value == null) {\n                 Thread.sleep(moreTime);\n@@ -97,7 +97,7 @@ private void testStoreProvider(RedisMetadataReport redisMetadataReport, String v\n             throw new RpcException(\"Failed to put to redis . cause: \" + e.getMessage(), e);\n         } finally {\n             if (jedis != null) {\n-                jedis.del(providerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_SOTRE_TAG);\n+                jedis.del(providerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_STORE_TAG);\n             }\n             redisMetadataReport.pool.close();\n         }\n@@ -121,7 +121,7 @@ private void testStoreConsumer(RedisMetadataReport redisMetadataReport, String v\n         Jedis jedis = null;\n         try {\n             jedis = redisMetadataReport.pool.getResource();\n-            String keyTmp = consumerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_SOTRE_TAG;\n+            String keyTmp = consumerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_STORE_TAG;\n             String value = jedis.get(keyTmp);\n             if (value == null) {\n                 Thread.sleep(moreTime);\n@@ -132,7 +132,7 @@ private void testStoreConsumer(RedisMetadataReport redisMetadataReport, String v\n             throw new RpcException(\"Failed to put to redis . cause: \" + e.getMessage(), e);\n         } finally {\n             if (jedis != null) {\n-                jedis.del(consumerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_SOTRE_TAG);\n+                jedis.del(consumerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_STORE_TAG);\n             }\n             redisMetadataReport.pool.close();\n         }",
    "output": "Fix some small problems * Format Non-standard dependency * Fixed syntax error * Fixed version error"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java\n--- a/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java\n+++ b/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistryFactory.java\n@@ -93,7 +93,6 @@ private void setProperties(URL url, Properties properties) {\n         putPropertyIfAbsent(url, properties, NAMESPACE);\n         putPropertyIfAbsent(url, properties, NACOS_NAMING_LOG_NAME);\n         putPropertyIfAbsent(url, properties, ENDPOINT);\n-        putPropertyIfAbsent(url, properties, NAMESPACE);\n         putPropertyIfAbsent(url, properties, ACCESS_KEY);\n         putPropertyIfAbsent(url, properties, SECRET_KEY);\n         putPropertyIfAbsent(url, properties, CLUSTER_NAME);",
    "output": "Remove duplicate code"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-fastjson/src/main/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectInput.java b/dubbo-serialization/dubbo-serialization-fastjson/src/main/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectInput.java\n--- a/dubbo-serialization/dubbo-serialization-fastjson/src/main/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectInput.java\n+++ b/dubbo-serialization/dubbo-serialization-fastjson/src/main/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectInput.java\n@@ -17,7 +17,6 @@\n package org.apache.dubbo.common.serialize.fastjson;\n import org.apache.dubbo.common.serialize.ObjectInput;\n-import org.apache.dubbo.common.utils.PojoUtils;\n import com.alibaba.fastjson.JSON;\n@@ -103,8 +102,8 @@ public <T> T readObject(Class<T> cls) throws IOException, ClassNotFoundException\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readObject(Class<T> cls, Type type) throws IOException, ClassNotFoundException {\n-        Object value = readObject(cls);\n-        return (T) PojoUtils.realize(value, cls, type);\n+        String json = readLine();\n+        return (T) JSON.parseObject(json, type);\n     }\n     private String readLine() throws IOException, EOFException {\ndiff --git a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectInputTest.java b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectInputTest.java\n--- a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectInputTest.java\n+++ b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fastjson/FastJsonObjectInputTest.java\n@@ -18,6 +18,10 @@\n import com.alibaba.fastjson.JSONObject;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import org.apache.dubbo.common.serialize.model.Organization;\n import org.apache.dubbo.common.serialize.model.Person;\n import org.junit.jupiter.api.Assertions;\n@@ -32,6 +36,7 @@\n import static org.hamcrest.CoreMatchers.nullValue;\n import static org.hamcrest.core.Is.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n public class FastJsonObjectInputTest {\n     private FastJsonObjectInput fastJsonObjectInput;\n@@ -151,4 +156,44 @@ public void testReadObjectWithoutClass() throws IOException, ClassNotFoundExcept\n         assertThat(readObject.getString(\"name\"), is(\"John\"));\n         assertThat(readObject.getInteger(\"age\"), is(30));\n     }\n-}\n\\ No newline at end of file\n+\n+\n+    @Test\n+    public void testReadObjectWithTowType() throws Exception {\n+        fastJsonObjectInput = new FastJsonObjectInput(new StringReader(\"[{\\\"name\\\":\\\"John\\\",\\\"age\\\":30},{\\\"name\\\":\\\"Born\\\",\\\"age\\\":24}]\"));\n+\n+        Method methodReturnType = getClass().getMethod(\"towLayer\");\n+        Type type = methodReturnType.getGenericReturnType();\n+        List<Person> o = fastJsonObjectInput.readObject(List.class, type);\n+\n+        assertTrue(o instanceof List);\n+        assertTrue(o.get(0) instanceof Person);\n+\n+        assertThat(o.size(), is(2));\n+        assertThat(o.get(1).getName(), is(\"Born\"));\n+    }\n+\n+    @Test\n+    public void testReadObjectWithThreeType() throws Exception {\n+        fastJsonObjectInput = new FastJsonObjectInput(new StringReader(\"{\\\"data\\\":[{\\\"name\\\":\\\"John\\\",\\\"age\\\":30},{\\\"name\\\":\\\"Born\\\",\\\"age\\\":24}]}\"));\n+\n+        Method methodReturnType = getClass().getMethod(\"threeLayer\");\n+        Type type = methodReturnType.getGenericReturnType();\n+        Organization<List<Person>> o = fastJsonObjectInput.readObject(Organization.class, type);\n+\n+        assertTrue(o instanceof Organization);\n+        assertTrue(o.getData() instanceof List);\n+        assertTrue(o.getData().get(0) instanceof Person);\n+\n+        assertThat(o.getData().size(), is(2));\n+        assertThat(o.getData().get(1).getName(), is(\"Born\"));\n+    }\n+\n+    public List<Person> towLayer() {\n+        return null;\n+    }\n+\n+    public Organization<List<Person>> threeLayer() {\n+        return null;\n+    }\n+}\ndiff --git a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/model/Organization.java b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/model/Organization.java\n--- a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/model/Organization.java\n+++ b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/model/Organization.java\n@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common.serialize.model;\n+\n+public class Organization<T> {\n+\n+    private T data;\n+\n+    public T getData() {\n+        return data;\n+    }\n+\n+    public void setData(T data) {\n+        this.data = data;\n+    }\n+}",
    "output": "Fix fastjson serialization with generic return type"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutput.java b/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutput.java\n--- a/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutput.java\n+++ b/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutput.java\n@@ -47,7 +47,7 @@ public void writeObject(Object obj) throws IOException {\n         byte[] classNameBytes;\n         try {\n-            if (WrapperUtils.needWrapper(obj)) {\n+            if (obj == null || WrapperUtils.needWrapper(obj)) {\n                 Schema<Wrapper> schema = RuntimeSchema.getSchema(Wrapper.class);\n                 Wrapper wrapper = new Wrapper(obj);\n                 bytes = GraphIOUtil.toByteArray(wrapper, schema, buffer);\ndiff --git a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutputTest.java b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutputTest.java\n--- a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutputTest.java\n+++ b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutputTest.java\n@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common.serialize.protostuff;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public class ProtostuffObjectOutputTest {\n+\n+    private ByteArrayOutputStream byteArrayOutputStream;\n+    private ProtostuffObjectOutput protostuffObjectOutput;\n+    private ProtostuffObjectInput protostuffObjectInput;\n+    private ByteArrayInputStream byteArrayInputStream;\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        this.byteArrayOutputStream = new ByteArrayOutputStream();\n+        this.protostuffObjectOutput = new ProtostuffObjectOutput(byteArrayOutputStream);\n+    }\n+\n+    @Test\n+    public void testWriteObjectNull() throws IOException, ClassNotFoundException {\n+        this.protostuffObjectOutput.writeObject(null);\n+        this.flushToInput();\n+\n+        assertThat(protostuffObjectInput.readObject(), nullValue());\n+    }\n+\n+    private void flushToInput() throws IOException {\n+        this.protostuffObjectOutput.flushBuffer();\n+        this.byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());\n+        this.protostuffObjectInput = new ProtostuffObjectInput(byteArrayInputStream);\n+    }\n+}",
    "output": "Fix NullPointerException when protocoluff protocol serializes an empty object * fix: #3727 * style: code tidy up * style: add apache license"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -29,6 +29,7 @@\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.common.utils.UrlUtils;\n import org.apache.dubbo.configcenter.DynamicConfiguration;\n+import org.apache.dubbo.registry.AddressListener;\n import org.apache.dubbo.registry.NotifyListener;\n import org.apache.dubbo.registry.Registry;\n import org.apache.dubbo.rpc.Invocation;\n@@ -215,6 +216,16 @@ public synchronized void notify(List<URL> urls) {\n         // providers\n         List<URL> providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());\n+        /**\n+         * 3.x added for extend URL address\n+         */\n+        ExtensionLoader<AddressListener> addressListenerExtensionLoader = ExtensionLoader.getExtensionLoader(AddressListener.class);\n+        Set<String> surpportedListeners = addressListenerExtensionLoader.getSupportedExtensions();\n+        if (surpportedListeners != null && !surpportedListeners.isEmpty()) {\n+            for (String addressListenerName : surpportedListeners) {\n+                providerURLs = addressListenerExtensionLoader.getExtension(addressListenerName).notify(providerURLs);\n+            }\n+        }\n         refreshOverrideAndInvoker(providerURLs);\n     }",
    "output": "Add AddressListener into RegistryDirectory"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -29,7 +29,6 @@\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.common.utils.UrlUtils;\n import org.apache.dubbo.configcenter.DynamicConfiguration;\n-import org.apache.dubbo.registry.AddressListener;\n import org.apache.dubbo.registry.NotifyListener;\n import org.apache.dubbo.registry.Registry;\n import org.apache.dubbo.rpc.Invocation;",
    "output": "Remove useless imports"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java\n--- a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java\n+++ b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java\n@@ -35,6 +35,8 @@\n  */\n public class CacheListener implements DataListener {\n+    private static final int MIN_PATH_DEPTH = 5;\n+\n     private Map<String, Set<ConfigurationListener>> keyListeners = new ConcurrentHashMap<>();\n     private CountDownLatch initializedLatch;\n     private String rootPath;\n@@ -89,7 +91,7 @@ public void dataChanged(String path, Object value, EventType eventType) {\n         // TODO We limit the notification of config changes to a specific path level, for example\n         //  /dubbo/config/service/configurators, other config changes not in this level will not get notified,\n         //  say /dubbo/config/dubbo.properties\n-        if (path.split(\"/\").length >= 5) {\n+        if (path.split(\"/\").length >= MIN_PATH_DEPTH) {\n             String key = pathToKey(path);\n             ConfigChangeType changeType;\n             switch (eventType) {",
    "output": "Use constant to replace magic number"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderMethodModel.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderMethodModel.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderMethodModel.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderMethodModel.java\n@@ -17,20 +17,24 @@\n package org.apache.dubbo.rpc.model;\n import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n public class ProviderMethodModel {\n     private final Method method;\n     private final String methodName;\n+    private final Class<?>[] parameterClasses;\n     private final String[] methodArgTypes;\n-\n+    private final Type[] genericParameterTypes;\n     private final ConcurrentMap<String, Object> attributeMap = new ConcurrentHashMap<>();\n     public ProviderMethodModel(Method method) {\n         this.method = method;\n         this.methodName = method.getName();\n+        this.parameterClasses = method.getParameterTypes();\n         this.methodArgTypes = getArgTypes(method);\n+        this.genericParameterTypes = method.getGenericParameterTypes();\n     }\n     public Method getMethod() {\n@@ -61,4 +65,12 @@ private static String[] getArgTypes(Method method) {\n         }\n         return methodArgTypes;\n     }\n+\n+    public Class<?>[] getParameterClasses() {\n+        return parameterClasses;\n+    }\n+\n+    public Type[] getGenericParameterTypes() {\n+        return genericParameterTypes;\n+    }\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderModel.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderModel.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderModel.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderModel.java\n@@ -74,6 +74,11 @@ public ProviderMethodModel getMethodModel(String methodName, String[] argTypes)\n         return null;\n     }\n+    public List<ProviderMethodModel> getMethodModelList(String methodName) {\n+        return methods.get(methodName);\n+    }\n+\n+\n     private void initMethod(Class<?> serviceInterfaceClass) {\n         Method[] methodsToExport = null;\n         methodsToExport = serviceInterfaceClass.getMethods();",
    "output": "Improve ProviderMethodModel add parameterClasses"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-etcd3/src/main/java/org/apache/dubbo/remoting/etcd/jetcd/JEtcdClientWrapper.java b/dubbo-remoting/dubbo-remoting-etcd3/src/main/java/org/apache/dubbo/remoting/etcd/jetcd/JEtcdClientWrapper.java\n--- a/dubbo-remoting/dubbo-remoting-etcd3/src/main/java/org/apache/dubbo/remoting/etcd/jetcd/JEtcdClientWrapper.java\n+++ b/dubbo-remoting/dubbo-remoting-etcd3/src/main/java/org/apache/dubbo/remoting/etcd/jetcd/JEtcdClientWrapper.java\n@@ -550,7 +550,7 @@ protected void doClose() {\n         try {\n             cancelKeepAlive = true;\n-            if (globalLeaseId > 0) {\n+            if (globalLeaseId != 0) {\n                 revokeLease(this.globalLeaseId);\n             }\n         } catch (Exception e) {",
    "output": "Improve the checking of lease id. #3684 It looks good"
  },
  {
    "input": "diff --git a/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/AbstractMonitorFactory.java b/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/AbstractMonitorFactory.java\n--- a/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/AbstractMonitorFactory.java\n+++ b/dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/AbstractMonitorFactory.java\n@@ -85,8 +85,8 @@ public Monitor getMonitor(URL url) {\n             final URL monitorUrl = url;\n             final CompletableFuture<Monitor> completableFuture = CompletableFuture.supplyAsync(() -> AbstractMonitorFactory.this.createMonitor(monitorUrl));\n-            completableFuture.thenRunAsync(new MonitorListener(key), executor);\n             FUTURES.put(key, completableFuture);\n+            completableFuture.thenRunAsync(new MonitorListener(key), executor);\n             return null;\n         } finally {\ndiff --git a/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/DubboMonitorTest.java b/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/DubboMonitorTest.java\n--- a/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/DubboMonitorTest.java\n+++ b/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/DubboMonitorTest.java\n@@ -61,7 +61,7 @@ public Class<MonitorService> getInterface() {\n         }\n         public URL getUrl() {\n-            return URL.valueOf(\"dubbo://127.0.0.1:7070?interval=20\");\n+            return URL.valueOf(\"dubbo://127.0.0.1:7070?interval=1000\");\n         }\n         @Override",
    "output": "Fix junit test failed"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java\n@@ -78,7 +78,7 @@ protected void doOpen() throws Throwable {\n             @Override\n             protected void initChannel(Channel ch) throws Exception {\n-                int heartbeatInterval = UrlUtils.getIdleTimeout(getUrl());\n+                int heartbeatInterval = UrlUtils.getHeartbeat(getUrl());\n                 NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this);\n                 ch.pipeline()//.addLast(\"logging\",new LoggingHandler(LogLevel.INFO))//for debug\n                         .addLast(\"decoder\", adapter.getDecoder())",
    "output": "Fix heartbeat internal"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java\n@@ -80,20 +80,20 @@ public void destroy() {\n     private void startQosServer(URL url) {\n         try {\n-            boolean qosEnable = url.getParameter(QOS_ENABLE,true);\n+            if (!hasStarted.compareAndSet(false, true)) {\n+                return;\n+            }\n+\n+            boolean qosEnable = url.getParameter(QOS_ENABLE, true);\n             if (!qosEnable) {\n                 logger.info(\"qos won't be started because it is disabled. \" +\n                         \"Please check dubbo.application.qos.enable is configured either in system property, \" +\n                         \"dubbo.properties or XML/spring-boot configuration.\");\n                 return;\n             }\n-            if (!hasStarted.compareAndSet(false, true)) {\n-                return;\n-            }\n-\n             int port = url.getParameter(QOS_PORT, QosConstants.DEFAULT_PORT);\n-            boolean acceptForeignIp = Boolean.parseBoolean(url.getParameter(ACCEPT_FOREIGN_IP,\"false\"));\n+            boolean acceptForeignIp = Boolean.parseBoolean(url.getParameter(ACCEPT_FOREIGN_IP, \"false\"));\n             Server server = Server.getInstance();\n             server.setPort(port);\n             server.setAcceptForeignIp(acceptForeignIp);\ndiff --git a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/Server.java b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/Server.java\n--- a/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/Server.java\n+++ b/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/Server.java\n@@ -82,7 +82,7 @@ public void start() throws Throwable {\n         if (!started.compareAndSet(false, true)) {\n             return;\n         }\n-        boss = new NioEventLoopGroup(0, new DefaultThreadFactory(\"qos-boss\", true));\n+        boss = new NioEventLoopGroup(1, new DefaultThreadFactory(\"qos-boss\", true));\n         worker = new NioEventLoopGroup(0, new DefaultThreadFactory(\"qos-worker\", true));\n         ServerBootstrap serverBootstrap = new ServerBootstrap();\n         serverBootstrap.group(boss, worker);",
    "output": "Fix when qos is disable,log will print every time. * fix when qos is disable,log will print every time. * change qos server boos thread number 1"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java\n@@ -76,8 +76,7 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {\n                 } else if (ProtocolUtils.isJavaGenericSerialization(generic)) {\n                     for (int i = 0; i < args.length; i++) {\n                         if (byte[].class == args[i].getClass()) {\n-                            try {\n-                                UnsafeByteArrayInputStream is = new UnsafeByteArrayInputStream((byte[]) args[i]);\n+                            try(UnsafeByteArrayInputStream is = new UnsafeByteArrayInputStream((byte[]) args[i])) {\n                                 args[i] = ExtensionLoader.getExtensionLoader(Serialization.class)\n                                         .getExtension(Constants.GENERIC_SERIALIZATION_NATIVE_JAVA)\n                                         .deserialize(null, is).readObject();\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/LogTelnetHandler.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/LogTelnetHandler.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/LogTelnetHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/LogTelnetHandler.java\n@@ -55,8 +55,7 @@ public String telnet(Channel channel, String message) {\n                 int showLogLength = Integer.parseInt(str[0]);\n                 if (file != null && file.exists()) {\n-                    try {\n-                        FileInputStream fis = new FileInputStream(file);\n+                    try(FileInputStream fis = new FileInputStream(file)) {\n                         FileChannel filechannel = fis.getChannel();\n                         size = filechannel.size();\n                         ByteBuffer bb;",
    "output": "Fix Not Properly Closed Resources"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java\n@@ -27,7 +27,6 @@\n import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.remoting.Channel;\n-import org.apache.dubbo.remoting.Codec2;\n import org.apache.dubbo.remoting.exchange.Request;\n import org.apache.dubbo.remoting.exchange.Response;\n import org.apache.dubbo.remoting.exchange.codec.ExchangeCodec;\n@@ -45,7 +44,7 @@\n /**\n  * Dubbo codec.\n  */\n-public class DubboCodec extends ExchangeCodec implements Codec2 {\n+public class DubboCodec extends ExchangeCodec {\n     public static final String NAME = \"dubbo\";\n     public static final String DUBBO_VERSION = Version.getProtocolVersion();",
    "output": "Fix DubboCodec re-implements Codec2 #2977"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java b/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/Version.java\n@@ -144,14 +144,18 @@ private static String getPrefixDigits(String v) {\n     public static String getVersion(Class<?> cls, String defaultVersion) {\n         try {\n             // find version info from MANIFEST.MF first\n-            String version = cls.getPackage().getImplementationVersion();\n-            if (!StringUtils.isEmpty(version)) {\n-                return version;\n-            }\n-\n-            version = cls.getPackage().getSpecificationVersion();\n-            if (!StringUtils.isEmpty(version)) {\n-                return version;\n+            Package pkg = cls.getPackage();\n+            String version = null;\n+            if (pkg != null) {\n+                version = pkg.getImplementationVersion();\n+                if (!StringUtils.isEmpty(version)) {\n+                    return version;\n+                }\n+\n+                version = pkg.getSpecificationVersion();\n+                if (!StringUtils.isEmpty(version)) {\n+                    return version;\n+                }\n             }\n             // guess version fro jar file name if nothing's found from MANIFEST.MF",
    "output": "Fix npe when package is null"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java\n--- a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java\n+++ b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java\n@@ -38,6 +38,8 @@\n  *\n  */\n public class CacheListener implements TreeCacheListener {\n+    private static final byte[] EMPTY_BYTES = new byte[0];\n+\n     private Map<String, Set<ConfigurationListener>> keyListeners = new ConcurrentHashMap<>();\n     private CountDownLatch initializedLatch;\n     private String rootPath;\n@@ -83,6 +85,9 @@ public void childEvent(CuratorFramework aClient, TreeCacheEvent event) throws Ex\n                     return;\n             }\n+            if (value == null) {\n+                value = EMPTY_BYTES;\n+            }\n             ConfigChangeEvent configChangeEvent = new ConfigChangeEvent(key, new String(value, StandardCharsets.UTF_8), changeType);\n             Set<ConfigurationListener> listeners = keyListeners.get(key);\n             if (CollectionUtils.isNotEmpty(listeners)) {",
    "output": "Fix issue #3533"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ServiceMetadata.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ServiceMetadata.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ServiceMetadata.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ServiceMetadata.java\n@@ -55,8 +55,12 @@ public Map<String, Object> getAttachments() {\n         return attachments;\n     }\n-    public Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n+//    public Map<String, Object> getAttributeMap() {\n+//        return attributeMap;\n+//    }\n+\n+    public Object getAttribute(String key) {\n+        return attributeMap.get(key);\n     }\n     public void addAttribute(String key, Object value) {",
    "output": "Remove getAttributeMap of ServiceMetada"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RpcContextFilter.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RpcContextFilter.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RpcContextFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RpcContextFilter.java\n@@ -18,7 +18,6 @@\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.rpc.RpcContext;\n-\n import org.jboss.resteasy.spi.ResteasyProviderFactory;\n import javax.annotation.Priority;\n@@ -29,6 +28,7 @@\n import javax.ws.rs.container.ContainerRequestContext;\n import javax.ws.rs.container.ContainerRequestFilter;\n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.util.Map;\n @Priority(Integer.MIN_VALUE + 1)\n@@ -71,14 +71,14 @@ public void filter(ClientRequestContext requestContext) throws IOException {\n         int size = 0;\n         for (Map.Entry<String, String> entry : RpcContext.getContext().getAttachments().entrySet()) {\n             String key = entry.getKey();\n-            String value = entry.getKey();\n+            String value = entry.getValue();\n             if (illegalForRest(key) || illegalForRest(value)) {\n                 throw new IllegalArgumentException(\"The attachments of \" + RpcContext.class.getSimpleName() + \" must not contain ',' or '=' when using rest protocol\");\n             }\n             // TODO for now we don't consider the differences of encoding and server limit\n             if (value != null) {\n-                size += value.getBytes(\"UTF-8\").length;\n+                size += value.getBytes(StandardCharsets.UTF_8).length;\n             }\n             if (size > MAX_HEADER_SIZE) {\n                 throw new IllegalArgumentException(\"The attachments of \" + RpcContext.class.getSimpleName() + \" is too big\");",
    "output": "Fix context filter's bug"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/common/extension/MockDispatcher.java b/dubbo-compatible/src/test/java/org/apache/dubbo/common/extension/MockDispatcher.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/common/extension/MockDispatcher.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/common/extension/MockDispatcher.java\n@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.common.extension;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.remoting.ChannelHandler;\n+import org.apache.dubbo.remoting.Dispatcher;\n+\n+public class MockDispatcher implements Dispatcher {\n+    @Override\n+    public ChannelHandler dispatch(ChannelHandler handler, URL url) {\n+        return null;\n+    }\n+}",
    "output": "Fix UT error following PR #3527"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n@@ -37,6 +37,7 @@\n import java.nio.channels.FileChannel;\n import java.nio.channels.FileLock;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n@@ -118,15 +119,15 @@ protected void setUrl(URL url) {\n     }\n     public Set<URL> getRegistered() {\n-        return registered;\n+        return Collections.unmodifiableSet(registered);\n     }\n     public Map<URL, Set<NotifyListener>> getSubscribed() {\n-        return subscribed;\n+        return Collections.unmodifiableMap(subscribed);\n     }\n     public Map<URL, Map<String, List<URL>>> getNotified() {\n-        return notified;\n+        return Collections.unmodifiableMap(notified);\n     }\n     public File getCacheFile() {\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryTest.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryTest.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryTest.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryTest.java\n@@ -96,7 +96,9 @@ public void testRegister() throws Exception {\n         abstractRegistry.register(mockUrl);\n         assert abstractRegistry.getRegistered().contains(mockUrl);\n         //test multiple urls\n-        abstractRegistry.getRegistered().clear();\n+        for (URL url : abstractRegistry.getRegistered()) {\n+            abstractRegistry.unregister(url);\n+        }\n         List<URL> urlList = getList();\n         for (URL url : urlList) {\n             abstractRegistry.register(url);\n@@ -122,14 +124,16 @@ public void testRegisterIfURLNULL() throws Exception {\n     public void testUnregister() throws Exception {\n         //test one unregister\n         URL url = new URL(\"dubbo\", \"192.168.0.1\", 2200);\n-        abstractRegistry.getRegistered().add(url);\n+        abstractRegistry.register(url);\n         abstractRegistry.unregister(url);\n         MatcherAssert.assertThat(false, Matchers.equalTo(abstractRegistry.getRegistered().contains(url)));\n         //test multiple unregisters\n-        abstractRegistry.getRegistered().clear();\n+        for (URL u : abstractRegistry.getRegistered()) {\n+            abstractRegistry.unregister(u);\n+        }\n         List<URL> urlList = getList();\n         for (URL urlSub : urlList) {\n-            abstractRegistry.getRegistered().add(urlSub);\n+            abstractRegistry.register(urlSub);\n         }\n         for (URL urlSub : urlList) {\n             abstractRegistry.unregister(urlSub);\ndiff --git a/dubbo-registry/dubbo-registry-multicast/src/test/java/org/apache/dubbo/registry/multicast/MulticastRegistryTest.java b/dubbo-registry/dubbo-registry-multicast/src/test/java/org/apache/dubbo/registry/multicast/MulticastRegistryTest.java\n--- a/dubbo-registry/dubbo-registry-multicast/src/test/java/org/apache/dubbo/registry/multicast/MulticastRegistryTest.java\n+++ b/dubbo-registry/dubbo-registry-multicast/src/test/java/org/apache/dubbo/registry/multicast/MulticastRegistryTest.java\n@@ -92,7 +92,9 @@ public void testRegister() {\n         Set<URL> registered;\n         // clear first\n         registered = registry.getRegistered();\n-        registered.clear();\n+        for (URL url : registered) {\n+            registry.unregister(url);\n+        }\n         for (int i = 0; i < 2; i++) {\n             registry.register(serviceUrl);",
    "output": "Make getRegistered return unmodifiable collection. #3106 * make getRegistered return unmodifiable collection. #3106 * fix ci failure"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/ProviderConsumerRegTable.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/ProviderConsumerRegTable.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/ProviderConsumerRegTable.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/ProviderConsumerRegTable.java\n@@ -72,9 +72,9 @@ public static <T> ProviderInvokerWrapper<T> getProviderWrapper(URL registeredPro\n             return null;\n         }\n-        for (Invoker inv : invokers.keySet()) {\n-            if (inv == invoker) {\n-                return invokers.get(inv);\n+        for (Map.Entry<Invoker, ProviderInvokerWrapper> entry : invokers.entrySet()) {\n+            if (entry.getKey() == invoker) {\n+                return entry.getValue();\n             }\n         }",
    "output": "Fix inefficient use of keySet iterator instead of entrySet iterator Fix inefficient use of keySet iterator instead of entrySet iterator"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/CollectionTypeBuilder.java b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/CollectionTypeBuilder.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/CollectionTypeBuilder.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/CollectionTypeBuilder.java\n@@ -22,6 +22,7 @@\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.text.MessageFormat;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.Map;\n@@ -48,7 +49,7 @@ public TypeDefinition build(Type type, Class<?> clazz, Map<Class<?>, TypeDefinit\n         Type[] actualTypeArgs = parameterizedType.getActualTypeArguments();\n         if (actualTypeArgs == null || actualTypeArgs.length != 1) {\n             throw new IllegalArgumentException(MessageFormat.format(\n-                    \"[ServiceDefinitionBuilder] Collection type [{0}] with unexpected amount of arguments [{1}].\" + actualTypeArgs,\n+                    \"[ServiceDefinitionBuilder] Collection type [{0}] with unexpected amount of arguments [{1}].\" + Arrays.toString(actualTypeArgs),\n                     new Object[]{type, actualTypeArgs}));\n         }\ndiff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java\n@@ -22,6 +22,7 @@\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.text.MessageFormat;\n+import java.util.Arrays;\n import java.util.Map;\n /**\n@@ -47,7 +48,7 @@ public TypeDefinition build(Type type, Class<?> clazz, Map<Class<?>, TypeDefinit\n         Type[] actualTypeArgs = parameterizedType.getActualTypeArguments();\n         if (actualTypeArgs == null || actualTypeArgs.length != 2) {\n             throw new IllegalArgumentException(MessageFormat.format(\n-                    \"[ServiceDefinitionBuilder] Map type [{0}] with unexpected amount of arguments [{1}].\" + actualTypeArgs, new Object[]{\n+                    \"[ServiceDefinitionBuilder] Map type [{0}] with unexpected amount of arguments [{1}].\" + Arrays.toString(actualTypeArgs), new Object[]{\n                             type, actualTypeArgs}));\n         }",
    "output": "Fix invocation of toString on an array Fix invocation of toString on an array"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ReferenceConfigCache.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ReferenceConfigCache.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ReferenceConfigCache.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ReferenceConfigCache.java\n@@ -39,28 +39,25 @@ public class ReferenceConfigCache {\n      * <p>\n      * key example: <code>group1/org.apache.dubbo.foo.FooService:1.0.0</code>.\n      */\n-    public static final KeyGenerator DEFAULT_KEY_GENERATOR = new KeyGenerator() {\n-        @Override\n-        public String generateKey(ReferenceConfig<?> referenceConfig) {\n-            String iName = referenceConfig.getInterface();\n-            if (StringUtils.isBlank(iName)) {\n-                Class<?> clazz = referenceConfig.getInterfaceClass();\n-                iName = clazz.getName();\n-            }\n-            if (StringUtils.isBlank(iName)) {\n-                throw new IllegalArgumentException(\"No interface info in ReferenceConfig\" + referenceConfig);\n-            }\n-\n-            StringBuilder ret = new StringBuilder();\n-            if (!StringUtils.isBlank(referenceConfig.getGroup())) {\n-                ret.append(referenceConfig.getGroup()).append(\"/\");\n-            }\n-            ret.append(iName);\n-            if (!StringUtils.isBlank(referenceConfig.getVersion())) {\n-                ret.append(\":\").append(referenceConfig.getVersion());\n-            }\n-            return ret.toString();\n+    public static final KeyGenerator DEFAULT_KEY_GENERATOR = referenceConfig -> {\n+        String iName = referenceConfig.getInterface();\n+        if (StringUtils.isBlank(iName)) {\n+            Class<?> clazz = referenceConfig.getInterfaceClass();\n+            iName = clazz.getName();\n         }\n+        if (StringUtils.isBlank(iName)) {\n+            throw new IllegalArgumentException(\"No interface info in ReferenceConfig\" + referenceConfig);\n+        }\n+\n+        StringBuilder ret = new StringBuilder();\n+        if (!StringUtils.isBlank(referenceConfig.getGroup())) {\n+            ret.append(referenceConfig.getGroup()).append(\"/\");\n+        }\n+        ret.append(iName);\n+        if (!StringUtils.isBlank(referenceConfig.getVersion())) {\n+            ret.append(\":\").append(referenceConfig.getVersion());\n+        }\n+        return ret.toString();\n     };\n     static final ConcurrentMap<String, ReferenceConfigCache> cacheHolder = new ConcurrentHashMap<String, ReferenceConfigCache>();\n     private final String name;\n@@ -115,6 +112,22 @@ public <T> T get(ReferenceConfig<T> referenceConfig) {\n         return (T) config.get();\n     }\n+    /**\n+     * Fetch cache with the specified key. The key is decided by KeyGenerator passed-in. If the default KeyGenerator is\n+     * used, then the key is in the format of <code>group/interfaceClass:version</code>\n+     *\n+     * @param key  cache key\n+     * @param type object class\n+     * @param <T>  object type\n+     * @return object from the cached ReferenceConfig\n+     * @see KeyGenerator#generateKey(ReferenceConfig)\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T get(String key, Class<T> type) {\n+        ReferenceConfig<?> config = cache.get(key);\n+        return (config != null) ? (T) config.get() : null;\n+    }\n+\n     void destroyKey(String key) {\n         ReferenceConfig<?> config = cache.remove(key);\n         if (config == null) {\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/utils/ReferenceConfigCacheTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/utils/ReferenceConfigCacheTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/utils/ReferenceConfigCacheTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/utils/ReferenceConfigCacheTest.java\n@@ -58,6 +58,14 @@ public void testGetCacheDiffReference() throws Exception {\n         assertEquals(\"1\", value);\n     }\n+    @Test\n+    public void testGetCacheWithKey() throws Exception {\n+        ReferenceConfigCache cache = ReferenceConfigCache.getCache();\n+        MockReferenceConfig config = buildMockReferenceConfig(\"FooService\", \"group1\", \"1.0.0\");\n+        String value = cache.get(config);\n+        assertEquals(value, cache.get(\"group1/FooService:1.0.0\", String.class));\n+    }\n+\n     @Test\n     public void testGetCacheDiffName() throws Exception {\n         ReferenceConfigCache cache = ReferenceConfigCache.getCache();",
    "output": "Fix issue#1293: A question for ReferenceConfigCache"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n@@ -247,7 +247,7 @@ public class Constants {\n     public static final String PROTOCOL_KEY = \"protocol\";\n-    public static final String DOBBO_PROTOCOL = DUBBO;\n+    public static final String DUBBO_PROTOCOL = DUBBO;\n     public static final String ZOOKEEPER_PROTOCOL = \"zookeeper\";\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -350,12 +350,12 @@ protected URL loadMonitor(URL registryURL) {\n                 if (getExtensionLoader(MonitorFactory.class).hasExtension(\"logstat\")) {\n                     map.put(Constants.PROTOCOL_KEY, \"logstat\");\n                 } else {\n-                    map.put(Constants.PROTOCOL_KEY, Constants.DOBBO_PROTOCOL);\n+                    map.put(Constants.PROTOCOL_KEY, Constants.DUBBO_PROTOCOL);\n                 }\n             }\n             return UrlUtils.parseURL(address, map);\n         } else if (Constants.REGISTRY_PROTOCOL.equals(monitor.getProtocol()) && registryURL != null) {\n-          return registryURL.setProtocol(Constants.DOBBO_PROTOCOL).addParameter(Constants.PROTOCOL_KEY, Constants.REGISTRY_PROTOCOL).addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map));\n+          return registryURL.setProtocol(Constants.DUBBO_PROTOCOL).addParameter(Constants.PROTOCOL_KEY, Constants.REGISTRY_PROTOCOL).addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map));\n         }\n         return null;\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProtocolConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n@@ -317,7 +317,7 @@ public String getCodec() {\n     }\n     public void setCodec(String codec) {\n-        if (Constants.DOBBO_PROTOCOL.equals(name)) {\n+        if (Constants.DUBBO_PROTOCOL.equals(name)) {\n             checkMultiExtension(Codec.class, Constants.CODEC_KEY, codec);\n         }\n         this.codec = codec;\n@@ -328,7 +328,7 @@ public String getSerialization() {\n     }\n     public void setSerialization(String serialization) {\n-        if (Constants.DOBBO_PROTOCOL.equals(name)) {\n+        if (Constants.DUBBO_PROTOCOL.equals(name)) {\n             checkMultiExtension(Serialization.class, Constants.SERIALIZATION_KEY, serialization);\n         }\n         this.serialization = serialization;\n@@ -371,7 +371,7 @@ public String getServer() {\n     }\n     public void setServer(String server) {\n-        if (Constants.DOBBO_PROTOCOL.equals(name)) {\n+        if (Constants.DUBBO_PROTOCOL.equals(name)) {\n             checkMultiExtension(Transporter.class, Constants.SERVER_KEY, server);\n         }\n         this.server = server;\n@@ -382,7 +382,7 @@ public String getClient() {\n     }\n     public void setClient(String client) {\n-        if (Constants.DOBBO_PROTOCOL.equals(name)) {\n+        if (Constants.DUBBO_PROTOCOL.equals(name)) {\n             checkMultiExtension(Transporter.class, Constants.CLIENT_KEY, client);\n         }\n         this.client = client;",
    "output": "Fix typo"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java\n@@ -61,7 +61,7 @@ public class RestProtocol extends AbstractProxyProtocol {\n     private static final int HTTPCLIENTCONNECTIONMANAGER_MAXPERROUTE = 20;\n     private static final int HTTPCLIENTCONNECTIONMANAGER_MAXTOTAL = 20;\n-    private static final int HTTPCLIENT_KEEPALIVEDURATION = 30*1000;\n+    private static final int HTTPCLIENT_KEEPALIVEDURATION = 30 * 1000;\n     private static final int HTTPCLIENTCONNECTIONMANAGER_CLOSEWAITTIME_MS = 1000;\n     private static final int HTTPCLIENTCONNECTIONMANAGER_CLOSEIDLETIME_S = 30;\n@@ -70,7 +70,7 @@ public class RestProtocol extends AbstractProxyProtocol {\n     private final RestServerFactory serverFactory = new RestServerFactory();\n     // TODO in the future maybe we can just use a single rest client and connection manager\n-    private final List<ResteasyClient> clients = Collections.synchronizedList(new LinkedList<ResteasyClient>());\n+    private final List<ResteasyClient> clients = Collections.synchronizedList(new LinkedList<>());\n     private volatile ConnectionMonitor connectionMonitor;\n@@ -136,16 +136,17 @@ public void run() {\n     @Override\n     protected <T> T doRefer(Class<T> serviceType, URL url) throws RpcException {\n-        if (connectionMonitor == null) {\n-            connectionMonitor = new ConnectionMonitor();\n-        }\n         // TODO more configs to add\n         PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();\n         // 20 is the default maxTotal of current PoolingClientConnectionManager\n         connectionManager.setMaxTotal(url.getParameter(Constants.CONNECTIONS_KEY, HTTPCLIENTCONNECTIONMANAGER_MAXTOTAL));\n         connectionManager.setDefaultMaxPerRoute(url.getParameter(Constants.CONNECTIONS_KEY, HTTPCLIENTCONNECTIONMANAGER_MAXPERROUTE));\n+        if (connectionMonitor == null) {\n+            connectionMonitor = new ConnectionMonitor();\n+            connectionMonitor.start();\n+        }\n         connectionMonitor.addConnectionManager(connectionManager);\n         RequestConfig requestConfig = RequestConfig.custom()\n                 .setConnectTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT))\n@@ -239,7 +240,7 @@ public void destroy() {\n     protected String getContextPath(URL url) {\n         String contextPath = url.getPath();\n-        return contextPath.endsWith(\"/\") ? contextPath.substring(0,contextPath.length()-1) : contextPath;\n+        return contextPath.endsWith(\"/\") ? contextPath.substring(0, contextPath.length() - 1) : contextPath;\n     }\n     protected class ConnectionMonitor extends Thread {",
    "output": "Fix connectionMonitor in RestProtocol seems not work #3237"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n@@ -31,7 +31,6 @@\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Protocol;\n import org.apache.dubbo.rpc.service.GenericService;\n-\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n@@ -40,6 +39,7 @@\n import org.mockito.Mockito;\n import java.util.Collections;\n+import java.util.concurrent.TimeUnit;\n import static org.apache.dubbo.common.Constants.GENERIC_SERIALIZATION_BEAN;\n import static org.apache.dubbo.common.Constants.GENERIC_SERIALIZATION_DEFAULT;\n@@ -52,6 +52,7 @@\n import static org.hamcrest.Matchers.hasKey;\n import static org.hamcrest.Matchers.hasSize;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.mockito.Mockito.withSettings;\n public class ServiceConfigTest {\n@@ -60,7 +61,7 @@ public class ServiceConfigTest {\n     private Exporter exporter = Mockito.mock(Exporter.class);\n     private ServiceConfig<DemoServiceImpl> service = new ServiceConfig<DemoServiceImpl>();\n     private ServiceConfig<DemoServiceImpl> service2 = new ServiceConfig<DemoServiceImpl>();\n-\n+    private ServiceConfig<DemoServiceImpl> delayService = new ServiceConfig<DemoServiceImpl>();\n     @BeforeEach\n     public void setUp() throws Exception {\n@@ -104,6 +105,14 @@ public void setUp() throws Exception {\n         service2.setMethods(Collections.singletonList(method));\n         service2.setProxy(\"testproxyfactory\");\n+        delayService.setProvider(provider);\n+        delayService.setApplication(app);\n+        delayService.setRegistry(registry);\n+        delayService.setInterface(DemoService.class);\n+        delayService.setRef(new DemoServiceImpl());\n+        delayService.setMethods(Collections.singletonList(method));\n+        delayService.setDelay(100);\n+\n         ConfigManager.getInstance().clear();\n     }\n@@ -143,6 +152,16 @@ public void testProxy() throws Exception {\n         assertEquals(2, TestProxyFactory.count); // local injvm and registry protocol, so expected is 2\n     }\n+\n+    @Test\n+    public void testDelayExport() throws Exception {\n+        delayService.export();\n+        assertTrue(delayService.getExportedUrls().isEmpty());\n+        //add 300ms to ensure that the delayService has been exported\n+        TimeUnit.MILLISECONDS.sleep(delayService.getDelay() + 300);\n+        assertThat(delayService.getExportedUrls(), hasSize(1));\n+    }\n+\n     @Test\n     @Disabled(\"cannot pass in travis\")\n     public void testUnexport() throws Exception {",
    "output": "Add delay export test case"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -29,7 +29,6 @@\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.common.utils.UrlUtils;\n import org.apache.dubbo.config.context.ConfigManager;\n-import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.config.support.Parameter;\n import org.apache.dubbo.configcenter.DynamicConfiguration;\n import org.apache.dubbo.configcenter.DynamicConfigurationFactory;\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -27,7 +27,6 @@\n import org.apache.dubbo.common.utils.ConfigUtils;\n import org.apache.dubbo.common.utils.NamedThreadFactory;\n import org.apache.dubbo.common.utils.StringUtils;\n-import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.config.annotation.Service;\n import org.apache.dubbo.config.context.ConfigManager;\n import org.apache.dubbo.config.invoker.DelegateProviderMetaDataInvoker;",
    "output": "Add checkstyle rule for redundant import * add checkstyle for redundant import and fix all issue in repo * fix git diff issue"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n@@ -436,9 +436,8 @@ public List<URL> getBackupUrls() {\n         return urls;\n     }\n-    private String appendDefaultPort(String address, int defaultPort) {\n-        if (address != null && address.length() > 0\n-                && defaultPort > 0) {\n+    static String appendDefaultPort(String address, int defaultPort) {\n+        if (address != null && address.length() > 0 && defaultPort > 0) {\n             int i = address.indexOf(':');\n             if (i < 0) {\n                 return address + \":\" + defaultPort;\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/URLTest.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import java.io.File;\n@@ -124,7 +125,7 @@ public void test_valueOf_noHost() throws Exception {\n         assertEquals(\"home/user1/router.js\", url.getPath());\n         assertEquals(0, url.getParameters().size());\n-        // Caution!!\n+        // Caution!!\n         url = URL.valueOf(\"file://home/user1/router.js\");\n         //                      ^^ only tow slash!\n         assertEquals(\"file\", url.getProtocol());\n@@ -680,4 +681,10 @@ public void testIpV6AddressWithScopeId(){\n         assertEquals(\"1.0.0\", url.getParameter(\"version\"));\n         assertEquals(\"morgan\", url.getParameter(\"application\"));\n     }\n-}\n\\ No newline at end of file\n+\n+    @Test\n+    public void testDefaultPort() {\n+        Assertions.assertEquals(\"10.20.153.10:2181\", URL.appendDefaultPort(\"10.20.153.10:0\", 2181));\n+        Assertions.assertEquals(\"10.20.153.10:2181\", URL.appendDefaultPort(\"10.20.153.10\", 2181));\n+    }\n+}\ndiff --git a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java\n@@ -79,18 +79,6 @@ public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {\n         });\n     }\n-    static String appendDefaultPort(String address) {\n-        if (address != null && address.length() > 0) {\n-            int i = address.indexOf(':');\n-            if (i < 0) {\n-                return address + \":\" + DEFAULT_ZOOKEEPER_PORT;\n-            } else if (Integer.parseInt(address.substring(i + 1)) == 0) {\n-                return address.substring(0, i + 1) + DEFAULT_ZOOKEEPER_PORT;\n-            }\n-        }\n-        return address;\n-    }\n-\n     @Override\n     public boolean isAvailable() {\n         return zkClient.isConnected();\ndiff --git a/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistryTest.java b/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistryTest.java\n--- a/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistryTest.java\n+++ b/dubbo-registry/dubbo-registry-zookeeper/src/test/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistryTest.java\n@@ -36,7 +36,9 @@\n import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n-import static org.hamcrest.CoreMatchers.*;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.CoreMatchers.not;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.mockito.Mockito.mock;\n@@ -65,12 +67,6 @@ public void tearDown() throws Exception {\n         zkServer.stop();\n     }\n-    @Test\n-    public void testDefaultPort() {\n-        Assertions.assertEquals(\"10.20.153.10:2181\", ZookeeperRegistry.appendDefaultPort(\"10.20.153.10:0\"));\n-        Assertions.assertEquals(\"10.20.153.10:2181\", ZookeeperRegistry.appendDefaultPort(\"10.20.153.10\"));\n-    }\n-\n     @Test\n     public void testAnyHost() {\n         Assertions.assertThrows(IllegalStateException.class, () -> {\n@@ -153,13 +149,8 @@ public void testStatusChecker() {\n     public void testSubscribeAnyValue() throws InterruptedException {\n         final CountDownLatch latch = new CountDownLatch(1);\n         zookeeperRegistry.register(serviceUrl);\n-        zookeeperRegistry.subscribe(anyUrl, new NotifyListener() {\n-            @Override\n-            public void notify(List<URL> urls) {\n-                latch.countDown();\n-            }\n-        });\n+        zookeeperRegistry.subscribe(anyUrl, urls -> latch.countDown());\n         zookeeperRegistry.register(serviceUrl);\n         latch.await();\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Remove duplicated unused method and move unit test"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/IOUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/IOUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/IOUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/IOUtilsTest.java\n@@ -21,8 +21,7 @@\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import org.junit.jupiter.api.support.io.TempDirectory;\n+import org.junit.jupiter.api.io.TempDir;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n@@ -38,7 +37,6 @@\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n-@ExtendWith(TempDirectory.class)\n public class IOUtilsTest {\n     private static String TEXT = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890\";\n@@ -89,7 +87,7 @@ public void testWrite5() throws Exception {\n     }\n     @Test\n-    public void testLines(@TempDirectory.TempDir Path tmpDir) throws Exception {\n+    public void testLines(@TempDir Path tmpDir) throws Exception {\n         File file = tmpDir.getFileName().toAbsolutePath().toFile();\n         IOUtils.writeLines(file, new String[]{TEXT});\n         String[] lines = IOUtils.readLines(file);\n@@ -118,7 +116,7 @@ public void testRead() throws Exception {\n     }\n     @Test\n-    public void testAppendLines(@TempDirectory.TempDir Path tmpDir) throws Exception {\n+    public void testAppendLines(@TempDir Path tmpDir) throws Exception {\n         File file = tmpDir.getFileName().toAbsolutePath().toFile();\n         IOUtils.appendLines(file, new String[]{\"a\", \"b\", \"c\"});\n         String[] lines = IOUtils.readLines(file);\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractInterfaceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractInterfaceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractInterfaceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractInterfaceConfigTest.java\n@@ -34,9 +34,7 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import org.junit.jupiter.api.support.io.TempDirectory;\n-import org.junit.jupiter.api.support.io.TempDirectory.TempDir;\n+import org.junit.jupiter.api.io.TempDir;\n import java.io.BufferedOutputStream;\n import java.io.File;\n@@ -48,7 +46,6 @@\n import java.util.List;\n import java.util.Properties;\n-@ExtendWith(TempDirectory.class)\n public class AbstractInterfaceConfigTest {\n     private static File dubboProperties;\ndiff --git a/dubbo-remoting/dubbo-remoting-p2p/src/test/java/org/apache/dubbo/remoting/p2p/support/FileNetworkerTest.java b/dubbo-remoting/dubbo-remoting-p2p/src/test/java/org/apache/dubbo/remoting/p2p/support/FileNetworkerTest.java\n--- a/dubbo-remoting/dubbo-remoting-p2p/src/test/java/org/apache/dubbo/remoting/p2p/support/FileNetworkerTest.java\n+++ b/dubbo-remoting/dubbo-remoting-p2p/src/test/java/org/apache/dubbo/remoting/p2p/support/FileNetworkerTest.java\n@@ -27,17 +27,14 @@\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import org.junit.jupiter.api.support.io.TempDirectory;\n-import org.junit.jupiter.api.support.io.TempDirectory.TempDir;\n+import org.junit.jupiter.api.io.TempDir;\n import java.nio.file.Path;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import static org.mockito.Mockito.mock;\n-@ExtendWith(TempDirectory.class)\n public class FileNetworkerTest {\n     @BeforeEach",
    "output": "Upgrade junit to 5.4.0 release version * update junit to 5.4.0 release version * remove uesles config"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java\n@@ -25,7 +25,6 @@\n import org.apache.dubbo.common.utils.ConfigUtils;\n import org.apache.dubbo.common.utils.NamedThreadFactory;\n import org.apache.dubbo.common.utils.UrlUtils;\n-import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.registry.NotifyListener;\n import org.apache.dubbo.registry.Registry;",
    "output": "Remove duplicated import"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java\n@@ -83,19 +83,11 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf input, List<Object> out\n             NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n-            Object msg;\n-\n-            int saveReaderIndex;\n-\n             try {\n                 // decode object.\n                 do {\n-                    saveReaderIndex = message.readerIndex();\n-                    try {\n-                        msg = codec.decode(channel, message);\n-                    } catch (IOException e) {\n-                        throw e;\n-                    }\n+                    int saveReaderIndex = message.readerIndex();\n+                    Object msg = codec.decode(channel, message);\n                     if (msg == Codec2.DecodeResult.NEED_MORE_INPUT) {\n                         message.readerIndex(saveReaderIndex);\n                         break;",
    "output": "Remove useless catch exception"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-api/src/main/java/org/apache/dubbo/configcenter/ConfigChangeEvent.java b/dubbo-configcenter/dubbo-configcenter-api/src/main/java/org/apache/dubbo/configcenter/ConfigChangeEvent.java\n--- a/dubbo-configcenter/dubbo-configcenter-api/src/main/java/org/apache/dubbo/configcenter/ConfigChangeEvent.java\n+++ b/dubbo-configcenter/dubbo-configcenter-api/src/main/java/org/apache/dubbo/configcenter/ConfigChangeEvent.java\n@@ -17,15 +17,15 @@\n package org.apache.dubbo.configcenter;\n /**\n- * Config change event.\n+ * Config change event, immutable.\n  *\n  * @see ConfigChangeType\n  */\n public class ConfigChangeEvent {\n-    private String key;\n+    private final String key;\n-    private String value;\n-    private ConfigChangeType changeType;\n+    private final String value;\n+    private final ConfigChangeType changeType;\n     public ConfigChangeEvent(String key, String value) {\n         this(key, value, ConfigChangeType.MODIFIED);\n@@ -41,23 +41,12 @@ public String getKey() {\n         return key;\n     }\n-    public void setKey(String key) {\n-        this.key = key;\n-    }\n-\n     public String getValue() {\n         return value;\n     }\n-    public void setValue(String value) {\n-        this.value = value;\n-    }\n-\n     public ConfigChangeType getChangeType() {\n         return changeType;\n     }\n-    public void setChangeType(ConfigChangeType changeType) {\n-        this.changeType = changeType;\n-    }\n-}\n+}\n\\ No newline at end of file",
    "output": "Make ConfigChangeEvent immutable"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DubboAppender.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DubboAppender.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DubboAppender.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DubboAppender.java\n@@ -16,17 +16,24 @@\n  */\n package org.apache.dubbo.common.utils;\n-import org.apache.log4j.ConsoleAppender;\n+import org.apache.log4j.FileAppender;\n import org.apache.log4j.spi.LoggingEvent;\n import java.util.ArrayList;\n import java.util.List;\n-public class DubboAppender extends ConsoleAppender {\n+public class DubboAppender extends FileAppender {\n+\n+    private static final String DEFAULT_FILE_NAME = \"dubbo.log\";\n+\n+    public DubboAppender() {\n+        super();\n+        setFile(DEFAULT_FILE_NAME);\n+    }\n     public static boolean available = false;\n-    public static List<Log> logList = new ArrayList<Log>();\n+    public static List<Log> logList = new ArrayList<>();\n     public static void doStart() {\n         available = true;",
    "output": "Make DubboAppender extends from FileAppender"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/generic/GenericServiceTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/generic/GenericServiceTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/generic/GenericServiceTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/generic/GenericServiceTest.java\n@@ -38,12 +38,11 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n public class GenericServiceTest {\n@@ -108,20 +107,20 @@ public void testGenericComplexCompute4FullServiceMetadata() {\n         FullServiceDefinition fullServiceDefinition = ServiceDefinitionBuilder.buildFullDefinition(DemoService.class);\n         MethodDefinition methodDefinition = getMethod(\"complexCompute\", fullServiceDefinition.getMethods());\n-        Map parm2= createComplextObject(fullServiceDefinition,var1, var2, l, var3, var4, testEnum);\n-        ComplexObject complexObject = map2bean(parm2);\n+        Map mapObject = createComplexObject(fullServiceDefinition,var1, var2, l, var3, var4, testEnum);\n+        ComplexObject complexObject = map2bean(mapObject);\n         Invoker<GenericService> invoker = protocol.refer(GenericService.class, url);\n         GenericService client = proxyFactory.getProxy(invoker, true);\n-        Object result = client.$invoke(methodDefinition.getName(), methodDefinition.getParameterTypes(), new Object[]{\"haha\", parm2});\n+        Object result = client.$invoke(methodDefinition.getName(), methodDefinition.getParameterTypes(), new Object[]{\"haha\", mapObject});\n         Assertions.assertEquals(\"haha###\" + complexObject.toString(), result);\n         Invoker<DemoService> invoker2 = protocol.refer(DemoService.class, url);\n         GenericService client2 = (GenericService) proxyFactory.getProxy(invoker2, true);\n-        Object result2 = client2.$invoke(\"complexCompute\", methodDefinition.getParameterTypes(), new Object[]{\"haha2\", parm2});\n+        Object result2 = client2.$invoke(\"complexCompute\", methodDefinition.getParameterTypes(), new Object[]{\"haha2\", mapObject});\n         Assertions.assertEquals(\"haha2###\" + complexObject.toString(), result2);\n         invoker.destroy();\n@@ -167,7 +166,7 @@ MethodDefinition getMethod(String methodName, List<MethodDefinition> list) {\n         return null;\n     }\n-    Map<String, Object> createComplextObject(FullServiceDefinition fullServiceDefinition, String var1, int var2, long l, String[] var3, List<Integer> var4, ComplexObject.TestEnum testEnum) {\n+    Map<String, Object> createComplexObject(FullServiceDefinition fullServiceDefinition, String var1, int var2, long l, String[] var3, List<Integer> var4, ComplexObject.TestEnum testEnum) {\n         List<TypeDefinition> typeDefinitions = fullServiceDefinition.getTypes();\n         TypeDefinition topTypeDefinition = null;\n         TypeDefinition innerTypeDefinition = null;\n@@ -191,7 +190,7 @@ Map<String, Object> createComplextObject(FullServiceDefinition fullServiceDefini\n         Assertions.assertEquals(topTypeDefinition.getProperties().get(\"strArrays\").getType(), \"java.lang.String[]\");\n         Assertions.assertEquals(topTypeDefinition.getProperties().get(\"innerObject3\").getType(), \"org.apache.dubbo.service.ComplexObject.InnerObject3[]\");\n         Assertions.assertEquals(topTypeDefinition.getProperties().get(\"testEnum\").getType(), \"org.apache.dubbo.service.ComplexObject.TestEnum\");\n-        Assertions.assertEquals(topTypeDefinition.getProperties().get(\"innerObject2\").getType(), \"java.util.Set<org.apache.dubbo.service.ComplexObject$InnerObject2>\");\n+        Assertions.assertEquals(topTypeDefinition.getProperties().get(\"innerObject2\").getType(), \"java.util.List<org.apache.dubbo.service.ComplexObject$InnerObject2>\");\n         Assertions.assertSame(innerTypeDefinition.getProperties().get(\"innerA\").getType(), \"java.lang.String\");\n         Assertions.assertSame(innerTypeDefinition.getProperties().get(\"innerB\").getType(), \"int\");\n@@ -216,16 +215,16 @@ Map<String, Object> createComplextObject(FullServiceDefinition fullServiceDefini\n         innerObjectMap.put(\"innerA\", var1);\n         innerObjectMap.put(\"innerB\", var2);\n-        Set<Map> innerObject2Set = new HashSet<>(4);\n-        result.put(\"innerObject2\", innerObject2Set);\n+        List<Map> innerObject2List = new ArrayList<>();\n+        result.put(\"innerObject2\", innerObject2List);\n         Map innerObject2Tmp1 = new HashMap<>(4);\n         innerObject2Tmp1.put(\"innerA2\", var1 + \"_21\");\n         innerObject2Tmp1.put(\"innerB2\", var2 + 100000);\n         Map innerObject2Tmp2 = new HashMap<>(4);\n         innerObject2Tmp2.put(\"innerA2\", var1 + \"_22\");\n         innerObject2Tmp2.put(\"innerB2\", var2 + 200000);\n-        innerObject2Set.add(innerObject2Tmp1);\n-        innerObject2Set.add(innerObject2Tmp2);\n+        innerObject2List.add(innerObject2Tmp1);\n+        innerObject2List.add(innerObject2Tmp2);\n         Map innerObject3Tmp1 = new HashMap<>(4);\n         innerObject3Tmp1.put(\"innerA3\", var1 + \"_31\");\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/service/ComplexObject.java b/dubbo-compatible/src/test/java/org/apache/dubbo/service/ComplexObject.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/service/ComplexObject.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/service/ComplexObject.java\n@@ -16,13 +16,12 @@\n  */\n package org.apache.dubbo.service;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n-import java.util.Set;\n /**\n  * ON 2018/11/5\n@@ -46,7 +45,7 @@ public ComplexObject(String var1, int var2, long l, String[] var3, List<Integer>\n         InnerObject2 io22 = new InnerObject2();\n         io22.setInnerA2(var1 + \"_22\");\n         io22.setInnerB2(var2 + 200000);\n-        this.setInnerObject2(new HashSet<InnerObject2>(Arrays.asList(io21, io22)));\n+        this.setInnerObject2(new ArrayList<>(Arrays.asList(io21, io22)));\n         InnerObject3 io31 = new InnerObject3();\n         io31.setInnerA3(var1 + \"_31\");\n@@ -61,7 +60,7 @@ public ComplexObject(String var1, int var2, long l, String[] var3, List<Integer>\n     }\n     private InnerObject innerObject;\n-    private Set<InnerObject2> innerObject2;\n+    private List<InnerObject2> innerObject2;\n     private InnerObject3[] innerObject3;\n     private String[] strArrays;\n     private List<Integer> intList;\n@@ -109,11 +108,11 @@ public void setTestEnum(TestEnum testEnum) {\n         this.testEnum = testEnum;\n     }\n-    public Set<InnerObject2> getInnerObject2() {\n+    public List<InnerObject2> getInnerObject2() {\n         return innerObject2;\n     }\n-    public void setInnerObject2(Set<InnerObject2> innerObject2) {\n+    public void setInnerObject2(List<InnerObject2> innerObject2) {\n         this.innerObject2 = innerObject2;\n     }\n@@ -225,15 +224,15 @@ public String getInnerA2() {\n             return innerA2;\n         }\n-        public void setInnerA2(String innerA) {\n+        public void setInnerA2(String innerA2) {\n             this.innerA2 = innerA2;\n         }\n         public int getInnerB2() {\n             return innerB2;\n         }\n-        public void setInnerB2(int innerB) {\n+        public void setInnerB2(int innerB2) {\n             this.innerB2 = innerB2;\n         }\ndiff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/service/ComplexObject.java b/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/service/ComplexObject.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/service/ComplexObject.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/service/ComplexObject.java\n@@ -225,15 +225,15 @@ public String getInnerA2() {\n             return innerA2;\n         }\n-        public void setInnerA2(String innerA) {\n+        public void setInnerA2(String innerA2) {\n             this.innerA2 = innerA2;\n         }\n         public int getInnerB2() {\n             return innerB2;\n         }\n-        public void setInnerB2(int innerB) {\n+        public void setInnerB2(int innerB2) {\n             this.innerB2 = innerB2;\n         }",
    "output": "Fix self assignment * Fix self assignment * Replace set with list to insure item order * Minor tweak of codestyle"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/store/test/JTestMetadataReport4Test.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/store/test/JTestMetadataReport4Test.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/store/test/JTestMetadataReport4Test.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/store/test/JTestMetadataReport4Test.java\n@@ -22,7 +22,6 @@\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.metadata.identifier.MetadataIdentifier;\n import org.apache.dubbo.metadata.support.AbstractMetadataReport;\n-import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -35,7 +34,7 @@ public class JTestMetadataReport4Test extends AbstractMetadataReport {\n     private final static Logger logger = LoggerFactory.getLogger(JTestMetadataReport4Test.class);\n-    public JTestMetadataReport4Test(URL url, ZookeeperTransporter zookeeperTransporter) {\n+    public JTestMetadataReport4Test(URL url) {\n         super(url);\n     }\ndiff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/store/test/JTestMetadataReportFactory4Test.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/store/test/JTestMetadataReportFactory4Test.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/store/test/JTestMetadataReportFactory4Test.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/store/test/JTestMetadataReportFactory4Test.java\n@@ -19,22 +19,15 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.metadata.store.MetadataReport;\n import org.apache.dubbo.metadata.support.AbstractMetadataReportFactory;\n-import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;\n /**\n  * ZookeeperRegistryFactory.\n  */\n public class JTestMetadataReportFactory4Test extends AbstractMetadataReportFactory {\n-    private ZookeeperTransporter zookeeperTransporter;\n-\n-    public void setZookeeperTransporter(ZookeeperTransporter zookeeperTransporter) {\n-        this.zookeeperTransporter = zookeeperTransporter;\n-    }\n-\n     @Override\n     public MetadataReport createMetadataReport(URL url) {\n-        return new JTestMetadataReport4Test(url, zookeeperTransporter);\n+        return new JTestMetadataReport4Test(url);\n     }\n }",
    "output": "Fix compilation error"
  },
  {
    "input": "diff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TKvTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TKvTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TKvTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TKvTest.java\n@@ -35,9 +35,9 @@ public void test1() {\n         });\n         String kv = tKv.rendering();\n-        assertThat(kv, containsString(\"ABCDEFGHIJ\\n\"));\n-        assertThat(kv, containsString(\"KLMNOPQRST\\n\"));\n-        assertThat(kv, containsString(\"UVWXYZ\\n\"));\n+        assertThat(kv, containsString(\"ABCDEFGHIJ\" + System.lineSeparator()));\n+        assertThat(kv, containsString(\"KLMNOPQRST\" + System.lineSeparator()));\n+        assertThat(kv, containsString(\"UVWXYZ\" + System.lineSeparator()));\n         tTable.addRow(\"OPTIONS\", kv);\n         String table = tTable.rendering();\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TLadderTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TLadderTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TLadderTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TLadderTest.java\n@@ -31,10 +31,10 @@ public void testRendering() throws Exception {\n         ladder.addItem(\"3\");\n         ladder.addItem(\"4\");\n         String result = ladder.rendering();\n-        String expected = \"1\\n\" +\n-                \"  `-2\\n\" +\n-                \"    `-3\\n\" +\n-                \"      `-4\\n\";\n+        String expected = \"1\" + System.lineSeparator() +\n+                \"  `-2\" + System.lineSeparator() +\n+                \"    `-3\" + System.lineSeparator() +\n+                \"      `-4\" + System.lineSeparator();\n         assertThat(result, equalTo(expected));\n         System.out.println(result);\n     }\ndiff --git a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TTableTest.java b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TTableTest.java\n--- a/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TTableTest.java\n+++ b/dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/textui/TTableTest.java\n@@ -28,11 +28,11 @@ public void test1() throws Exception {\n         table.addRow(1, \"one\", \"uno\", \"un\");\n         table.addRow(2, \"two\", \"dos\", \"deux\");\n         String result = table.rendering();\n-        String expected = \"+-+---+---+----+\\n\" +\n-                \"|1|one|uno|un  |\\n\" +\n-                \"+-+---+---+----+\\n\" +\n-                \"|2|two|dos|deux|\\n\" +\n-                \"+-+---+---+----+\\n\";\n+        String expected = \"+-+---+---+----+\" + System.lineSeparator() +\n+                \"|1|one|uno|un  |\" + System.lineSeparator() +\n+                \"+-+---+---+----+\" + System.lineSeparator() +\n+                \"|2|two|dos|deux|\" + System.lineSeparator() +\n+                \"+-+---+---+----+\" + System.lineSeparator();\n         assertThat(result, equalTo(expected));\n         System.out.println(result);\n     }\n@@ -46,9 +46,9 @@ public void test2() throws Exception {\n         });\n         table.addRow(1, \"abcde\", \"ABCDE\");\n         String result = table.rendering();\n-        String expected = \"+-+----------+----------+\\n\" +\n-                \"|1|   abcde  |     ABCDE|\\n\" +\n-                \"+-+----------+----------+\\n\";\n+        String expected = \"+-+----------+----------+\" + System.lineSeparator() +\n+                \"|1|   abcde  |     ABCDE|\" + System.lineSeparator() +\n+                \"+-+----------+----------+\" + System.lineSeparator();\n         assertThat(result, equalTo(expected));\n         System.out.println(result);\n     }",
    "output": "Fix some unit test failure"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/URL.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/URL.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/URL.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/common/URL.java\n@@ -27,6 +27,10 @@\n @Deprecated\n public class URL extends org.apache.dubbo.common.URL {\n+    protected URL() {\n+        super();\n+    }\n+\n     public URL(org.apache.dubbo.common.URL url) {\n         super(url.getProtocol(), url.getUsername(), url.getPassword(), url.getHost(), url.getPort(), url.getPath(), url.getParameters());\n     }",
    "output": "Add no-argument constructor method to URL.java * Fix NullPointerException when Hessian instantiate URL with JavaDeserializer"
  },
  {
    "input": "diff --git a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/MetricLevel.java b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/MetricLevel.java\n--- a/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/MetricLevel.java\n+++ b/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/MetricLevel.java\n@@ -31,14 +31,6 @@ public enum MetricLevel {\n     CRITICAL; // critical metrics\n-    static {\n-        for (MetricLevel level : MetricLevel.values()) {\n-            if (level.ordinal() < 0) {\n-                throw new RuntimeException(\"MetricLevel can not < 0\");\n-            }\n-        }\n-    }\n-\n     public static int getMaxValue() {\n         MetricLevel[] levels = MetricLevel.values();\n         int max = levels[0].ordinal();",
    "output": "Remove futility check code * Remove futility check code"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericFilterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericFilterTest.java\n@@ -49,7 +49,7 @@ public void testInvokeWithDefault() throws Exception {\n         RpcInvocation invocation = new RpcInvocation(Constants.$INVOKE, genericInvoke.getParameterTypes(),\n                 new Object[]{\"getPerson\", new String[]{Person.class.getCanonicalName()}, new Object[]{person}});\n-        URL url = URL.valueOf(\"test://test:11/com.alibaba.dubbo.rpc.support.DemoService?\" +\n+        URL url = URL.valueOf(\"test://test:11/org.apache.dubbo.rpc.support.DemoService?\" +\n                 \"accesslog=true&group=dubbo&version=1.1\");\n         Invoker invoker = Mockito.mock(Invoker.class);\n         when(invoker.invoke(any(Invocation.class))).thenReturn(new RpcResult(new Person(\"person\", 10)));\n@@ -76,7 +76,7 @@ public void testInvokeWithJavaException() throws Exception {\n                     new Object[]{\"getPerson\", new String[]{Person.class.getCanonicalName()}, new Object[]{person}});\n             invocation.setAttachment(Constants.GENERIC_KEY, Constants.GENERIC_SERIALIZATION_NATIVE_JAVA);\n-            URL url = URL.valueOf(\"test://test:11/com.alibaba.dubbo.rpc.support.DemoService?\" +\n+            URL url = URL.valueOf(\"test://test:11/org.apache.dubbo.rpc.support.DemoService?\" +\n                     \"accesslog=true&group=dubbo&version=1.1\");\n             Invoker invoker = Mockito.mock(Invoker.class);\n             when(invoker.invoke(any(Invocation.class))).thenReturn(new RpcResult(new Person(\"person\", 10)));\n@@ -99,7 +99,7 @@ public void testInvokeWithJavaException() throws Exception {\n         RpcInvocation invocation = new RpcInvocation(\"sayHi\", genericInvoke.getParameterTypes()\n                 , new Object[]{\"getPerson\", new String[]{Person.class.getCanonicalName()}, new Object[]{person}});\n-        URL url = URL.valueOf(\"test://test:11/com.alibaba.dubbo.rpc.support.DemoService?\" +\n+        URL url = URL.valueOf(\"test://test:11/org.apache.dubbo.rpc.support.DemoService?\" +\n                 \"accesslog=true&group=dubbo&version=1.1\");\n         Invoker invoker = Mockito.mock(Invoker.class);\n         when(invoker.invoke(any(Invocation.class))).thenReturn(new RpcResult(new Person(\"person\", 10)));\n@@ -123,7 +123,7 @@ public void testInvokeWithMethodArgumentSizeIsNot3() {\n         RpcInvocation invocation = new RpcInvocation(Constants.$INVOKE, genericInvoke.getParameterTypes()\n                 , new Object[]{\"getPerson\", new String[]{Person.class.getCanonicalName()}});\n-        URL url = URL.valueOf(\"test://test:11/com.alibaba.dubbo.rpc.support.DemoService?\" +\n+        URL url = URL.valueOf(\"test://test:11/org.apache.dubbo.rpc.support.DemoService?\" +\n                 \"accesslog=true&group=dubbo&version=1.1\");\n         Invoker invoker = Mockito.mock(Invoker.class);\n         when(invoker.invoke(any(Invocation.class))).thenReturn(new RpcResult(new Person(\"person\", 10)));\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericImplFilterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericImplFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericImplFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericImplFilterTest.java\n@@ -50,7 +50,7 @@ public void testInvoke() throws Exception {\n                 new Class[]{Person.class}, new Object[]{new Person(\"dubbo\", 10)});\n-        URL url = URL.valueOf(\"test://test:11/com.alibaba.dubbo.rpc.support.DemoService?\" +\n+        URL url = URL.valueOf(\"test://test:11/org.apache.dubbo.rpc.support.DemoService?\" +\n                 \"accesslog=true&group=dubbo&version=1.1&generic=true\");\n         Invoker invoker = Mockito.mock(Invoker.class);\n@@ -74,7 +74,7 @@ public void testInvokeWithException() throws Exception {\n         RpcInvocation invocation = new RpcInvocation(\"getPerson\",\n                 new Class[]{Person.class}, new Object[]{new Person(\"dubbo\", 10)});\n-        URL url = URL.valueOf(\"test://test:11/com.alibaba.dubbo.rpc.support.DemoService?\" +\n+        URL url = URL.valueOf(\"test://test:11/org.apache.dubbo.rpc.support.DemoService?\" +\n                 \"accesslog=true&group=dubbo&version=1.1&generic=true\");\n         Invoker invoker = Mockito.mock(Invoker.class);\n@@ -100,7 +100,7 @@ public void testInvokeWithException() throws Exception {\n         RpcInvocation invocation = new RpcInvocation(Constants.$INVOKE, genericInvoke.getParameterTypes(),\n                 new Object[]{\"getPerson\", new String[]{Person.class.getCanonicalName()}, new Object[]{person}});\n-        URL url = URL.valueOf(\"test://test:11/com.alibaba.dubbo.rpc.support.DemoService?\" +\n+        URL url = URL.valueOf(\"test://test:11/org.apache.dubbo.rpc.support.DemoService?\" +\n                 \"accesslog=true&group=dubbo&version=1.1&generic=true\");\n         Invoker invoker = Mockito.mock(Invoker.class);\n         when(invoker.invoke(any(Invocation.class))).thenReturn(new RpcResult(new Person(\"person\", 10)));",
    "output": "Fix org.apache.dubbo replace com.alibaba.dubbo org.apache.dubbo replace com.alibaba.dubbo"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-thrift/src/main/java/org/apache/dubbo/rpc/protocol/thrift/ThriftCodec.java b/dubbo-rpc/dubbo-rpc-thrift/src/main/java/org/apache/dubbo/rpc/protocol/thrift/ThriftCodec.java\n--- a/dubbo-rpc/dubbo-rpc-thrift/src/main/java/org/apache/dubbo/rpc/protocol/thrift/ThriftCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-thrift/src/main/java/org/apache/dubbo/rpc/protocol/thrift/ThriftCodec.java\n@@ -163,6 +163,7 @@ private Object decode(TProtocol protocol)\n         // version\n         String serviceName;\n+        String path;\n         long id;\n         TMessage message;\n@@ -171,6 +172,7 @@ private Object decode(TProtocol protocol)\n             protocol.readI16();\n             protocol.readByte();\n             serviceName = protocol.readString();\n+            path = protocol.readString();\n             id = protocol.readI64();\n             message = protocol.readMessageBegin();\n         } catch (TException e) {\n@@ -181,6 +183,7 @@ private Object decode(TProtocol protocol)\n             RpcInvocation result = new RpcInvocation();\n             result.setAttachment(Constants.INTERFACE_KEY, serviceName);\n+            result.setAttachment(Constants.PATH_KEY, path);\n             result.setMethodName(message.name);\n             String argsClassName = ExtensionLoader.getExtensionLoader(ClassNameGenerator.class)\n@@ -496,6 +499,8 @@ private void encodeRequest(Channel channel, ChannelBuffer buffer, Request reques\n             protocol.writeByte(VERSION);\n             // service name\n             protocol.writeString(serviceName);\n+            // path\n+            protocol.writeString(inv.getAttachment(Constants.PATH_KEY));\n             // dubbo request id\n             protocol.writeI64(request.getId());\n             protocol.getTransport().flush();\ndiff --git a/dubbo-rpc/dubbo-rpc-thrift/src/main/java/org/apache/dubbo/rpc/protocol/thrift/ThriftProtocol.java b/dubbo-rpc/dubbo-rpc-thrift/src/main/java/org/apache/dubbo/rpc/protocol/thrift/ThriftProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-thrift/src/main/java/org/apache/dubbo/rpc/protocol/thrift/ThriftProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-thrift/src/main/java/org/apache/dubbo/rpc/protocol/thrift/ThriftProtocol.java\n@@ -63,9 +63,9 @@ public CompletableFuture<Object> reply(ExchangeChannel channel, Object msg) thro\n             if (msg instanceof Invocation) {\n                 Invocation inv = (Invocation) msg;\n-                String serviceName = inv.getAttachments().get(Constants.INTERFACE_KEY);\n+                String path = inv.getAttachments().get(Constants.PATH_KEY);\n                 String serviceKey = serviceKey(channel.getLocalAddress().getPort(),\n-                        serviceName, null, null);\n+                        path, null, null);\n                 DubboExporter<?> exporter = (DubboExporter<?>) exporterMap.get(serviceKey);\n                 if (exporter == null) {\n                     throw new RemotingException(channel,\ndiff --git a/dubbo-rpc/dubbo-rpc-thrift/src/test/java/org/apache/dubbo/rpc/protocol/thrift/ThriftCodecTest.java b/dubbo-rpc/dubbo-rpc-thrift/src/test/java/org/apache/dubbo/rpc/protocol/thrift/ThriftCodecTest.java\n--- a/dubbo-rpc/dubbo-rpc-thrift/src/test/java/org/apache/dubbo/rpc/protocol/thrift/ThriftCodecTest.java\n+++ b/dubbo-rpc/dubbo-rpc-thrift/src/test/java/org/apache/dubbo/rpc/protocol/thrift/ThriftCodecTest.java\n@@ -93,6 +93,8 @@ public void testEncodeRequest() throws Exception {\n         Assertions.assertEquals(ThriftCodec.VERSION, protocol.readByte());\n         // service name\n         Assertions.assertEquals(Demo.Iface.class.getName(), protocol.readString());\n+        // path\n+        Assertions.assertEquals(Demo.Iface.class.getName(), protocol.readString());\n         // dubbo request id\n         Assertions.assertEquals(request.getId(), protocol.readI64());\n@@ -148,6 +150,8 @@ public void testDecodeReplyResponse() throws Exception {\n         protocol.writeI16(Short.MAX_VALUE);\n         protocol.writeByte(ThriftCodec.VERSION);\n         protocol.writeString(Demo.Iface.class.getName());\n+        // path\n+        protocol.writeString(Demo.Iface.class.getName());\n         protocol.writeI64(request.getId());\n         protocol.getTransport().flush();\n         headerLength = bos.size();\n@@ -221,6 +225,8 @@ public void testDecodeExceptionResponse() throws Exception {\n         protocol.writeI16(Short.MAX_VALUE);\n         protocol.writeByte(ThriftCodec.VERSION);\n         protocol.writeString(Demo.class.getName());\n+        // path\n+        protocol.writeString(Demo.class.getName());\n         protocol.writeI64(request.getId());\n         protocol.getTransport().flush();\n         headerLength = bos.size();\n@@ -396,6 +402,9 @@ public void testDecodeRequest() throws Exception {\n         protocol.writeString(\n                 ((RpcInvocation) request.getData())\n                         .getAttachment(Constants.INTERFACE_KEY));\n+        protocol.writeString(\n+                ((RpcInvocation) request.getData())\n+                        .getAttachment(Constants.PATH_KEY));\n         protocol.writeI64(request.getId());\n         protocol.getTransport().flush();\n         headerLength = bos.size();\n@@ -448,6 +457,7 @@ private Request createRequest() {\n         invocation.setParameterTypes(new Class<?>[]{String.class});\n         invocation.setAttachment(Constants.INTERFACE_KEY, Demo.Iface.class.getName());\n+        invocation.setAttachment(Constants.PATH_KEY, Demo.Iface.class.getName());\n         Request request = new Request(1L);",
    "output": "Fix thrift protocol, use path to locate exporter. * Fix thrift protocol, use path to locate exporter. * Fix UT"
  },
  {
    "input": "diff --git a/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/DubboMonitorTest.java b/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/DubboMonitorTest.java\n--- a/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/DubboMonitorTest.java\n+++ b/dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/DubboMonitorTest.java\n@@ -103,22 +103,23 @@ public void testCount() throws Exception {\n                 .addParameter(MonitorService.CONCURRENT, 1)\n                 .addParameter(MonitorService.MAX_CONCURRENT, 1);\n         monitor.collect(statistics);\n+        monitor.send();\n         while (lastStatistics == null) {\n             Thread.sleep(10);\n         }\n-        Assertions.assertEquals(lastStatistics.getParameter(MonitorService.APPLICATION), \"morgan\");\n-        Assertions.assertEquals(lastStatistics.getProtocol(), \"dubbo\");\n-        Assertions.assertEquals(lastStatistics.getHost(), \"10.20.153.10\");\n-        Assertions.assertEquals(lastStatistics.getParameter(MonitorService.APPLICATION), \"morgan\");\n-        Assertions.assertEquals(lastStatistics.getParameter(MonitorService.INTERFACE), \"MemberService\");\n-        Assertions.assertEquals(lastStatistics.getParameter(MonitorService.METHOD), \"findPerson\");\n-        Assertions.assertEquals(lastStatistics.getParameter(MonitorService.CONSUMER), \"10.20.153.11\");\n-        Assertions.assertEquals(lastStatistics.getParameter(MonitorService.SUCCESS), \"1\");\n-        Assertions.assertEquals(lastStatistics.getParameter(MonitorService.FAILURE), \"0\");\n-        Assertions.assertEquals(lastStatistics.getParameter(MonitorService.ELAPSED), \"3\");\n-        Assertions.assertEquals(lastStatistics.getParameter(MonitorService.MAX_ELAPSED), \"3\");\n-        Assertions.assertEquals(lastStatistics.getParameter(MonitorService.CONCURRENT), \"1\");\n-        Assertions.assertEquals(lastStatistics.getParameter(MonitorService.MAX_CONCURRENT), \"1\");\n+        Assertions.assertEquals(\"morgan\", lastStatistics.getParameter(MonitorService.APPLICATION));\n+        Assertions.assertEquals(\"dubbo\", lastStatistics.getProtocol());\n+        Assertions.assertEquals(\"10.20.153.10\", lastStatistics.getHost());\n+        Assertions.assertEquals(\"morgan\", lastStatistics.getParameter(MonitorService.APPLICATION));\n+        Assertions.assertEquals(\"MemberService\", lastStatistics.getParameter(MonitorService.INTERFACE));\n+        Assertions.assertEquals(\"findPerson\", lastStatistics.getParameter(MonitorService.METHOD));\n+        Assertions.assertEquals(\"10.20.153.11\", lastStatistics.getParameter(MonitorService.CONSUMER));\n+        Assertions.assertEquals(\"1\", lastStatistics.getParameter(MonitorService.SUCCESS));\n+        Assertions.assertEquals(\"0\", lastStatistics.getParameter(MonitorService.FAILURE));\n+        Assertions.assertEquals(\"3\", lastStatistics.getParameter(MonitorService.ELAPSED));\n+        Assertions.assertEquals(\"3\", lastStatistics.getParameter(MonitorService.MAX_ELAPSED));\n+        Assertions.assertEquals(\"1\", lastStatistics.getParameter(MonitorService.CONCURRENT));\n+        Assertions.assertEquals(\"1\", lastStatistics.getParameter(MonitorService.MAX_CONCURRENT));\n         monitor.destroy();\n     }",
    "output": "Fix random ut falling in DubboMonitorTest"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectInput.java b/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectInput.java\n--- a/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectInput.java\n+++ b/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectInput.java\n@@ -17,17 +17,15 @@\n package org.apache.dubbo.common.serialize.protostuff;\n-import org.apache.dubbo.common.serialize.ObjectInput;\n-import org.apache.dubbo.common.serialize.protostuff.utils.WrapperUtils;\n-\n-import io.protostuff.ProtobufIOUtil;\n+import io.protostuff.GraphIOUtil;\n import io.protostuff.Schema;\n import io.protostuff.runtime.RuntimeSchema;\n-\n import java.io.DataInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.lang.reflect.Type;\n+import org.apache.dubbo.common.serialize.ObjectInput;\n+import org.apache.dubbo.common.serialize.protostuff.utils.WrapperUtils;\n /**\n  * Protostuff object input implementation\n@@ -63,12 +61,12 @@ public Object readObject() throws IOException, ClassNotFoundException {\n         if (WrapperUtils.needWrapper(clazz)) {\n             Schema<Wrapper> schema = RuntimeSchema.getSchema(Wrapper.class);\n             Wrapper wrapper = schema.newMessage();\n-            ProtobufIOUtil.mergeFrom(bytes, wrapper, schema);\n+            GraphIOUtil.mergeFrom(bytes, wrapper, schema);\n             result = wrapper.getData();\n         } else {\n             Schema schema = RuntimeSchema.getSchema(clazz);\n             result = schema.newMessage();\n-            ProtobufIOUtil.mergeFrom(bytes, result, schema);\n+            GraphIOUtil.mergeFrom(bytes, result, schema);\n         }\n         return result;\ndiff --git a/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutput.java b/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutput.java\n--- a/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutput.java\n+++ b/dubbo-serialization/dubbo-serialization-protostuff/src/main/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffObjectOutput.java\n@@ -17,17 +17,15 @@\n package org.apache.dubbo.common.serialize.protostuff;\n-import org.apache.dubbo.common.serialize.ObjectOutput;\n-import org.apache.dubbo.common.serialize.protostuff.utils.WrapperUtils;\n-\n+import io.protostuff.GraphIOUtil;\n import io.protostuff.LinkedBuffer;\n-import io.protostuff.ProtobufIOUtil;\n import io.protostuff.Schema;\n import io.protostuff.runtime.RuntimeSchema;\n-\n import java.io.DataOutputStream;\n import java.io.IOException;\n import java.io.OutputStream;\n+import org.apache.dubbo.common.serialize.ObjectOutput;\n+import org.apache.dubbo.common.serialize.protostuff.utils.WrapperUtils;\n /**\n  * Protostuff object output implementation\n@@ -52,11 +50,11 @@ public void writeObject(Object obj) throws IOException {\n             if (WrapperUtils.needWrapper(obj)) {\n                 Schema<Wrapper> schema = RuntimeSchema.getSchema(Wrapper.class);\n                 Wrapper wrapper = new Wrapper(obj);\n-                bytes = ProtobufIOUtil.toByteArray(wrapper, schema, buffer);\n+                bytes = GraphIOUtil.toByteArray(wrapper, schema, buffer);\n                 classNameBytes = Wrapper.class.getName().getBytes();\n             } else {\n                 Schema schema = RuntimeSchema.getSchema(obj.getClass());\n-                bytes = ProtobufIOUtil.toByteArray(obj, schema, buffer);\n+                bytes = GraphIOUtil.toByteArray(obj, schema, buffer);\n                 classNameBytes = obj.getClass().getName().getBytes();\n             }\n         } finally {\ndiff --git a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffSerializationTest.java b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffSerializationTest.java\n--- a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffSerializationTest.java\n+++ b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/protostuff/ProtostuffSerializationTest.java\n@@ -25,9 +25,4 @@ public class ProtostuffSerializationTest extends AbstractSerializationTest {\n         serialization = new ProtostuffSerialization();\n     }\n-    @Override\n-    @Test\n-    public void test_LoopReference() throws Exception {\n-        // FIXME: cannot make this test pass on protostuff\n-    }\n }",
    "output": "Fix for loop reference test pass on protostuff"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -228,9 +228,9 @@ private void refreshOverrideAndInvoker(List<URL> urls) {\n     private void refreshInvoker(List<URL> invokerUrls) {\n         Assert.notNull(invokerUrls, \"invokerUrls should not be null\");\n-        if (invokerUrls.size() == 1 && invokerUrls.get(0) != null && Constants.EMPTY_PROTOCOL.equals(invokerUrls\n-                .get(0)\n-                .getProtocol())) {\n+        if (invokerUrls.size() == 1\n+                && invokerUrls.get(0) != null\n+                && Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {\n             this.forbidden = true; // Forbid to access\n             this.invokers = Collections.emptyList();\n             routerChain.setInvokers(this.invokers);\n@@ -252,8 +252,14 @@ private void refreshInvoker(List<URL> invokerUrls) {\n             }\n             Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map\n-            // state change\n-            // If the calculation is wrong, it is not processed.\n+            /**\n+             * If the calculation is wrong, it is not processed.\n+             *\n+             * 1. The protocol configured by the client is inconsistent with the protocol of the server.\n+             *    eg: consumer protocol = dubbo, provider only has other protocol services(rest).\n+             * 2. The registration center is not robust and pushes illegal specification data.\n+             *\n+             */\n             if (CollectionUtils.isEmptyMap(newUrlInvokerMap)) {\n                 logger.error(new IllegalStateException(\"urls to invokers error .invokerUrls.size :\" + invokerUrls.size() + \", invoker.size :0. urls :\" + invokerUrls\n                         .toString()));",
    "output": "Add comments, manually merge #3181"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -27,21 +27,21 @@\n import com.alibaba.dubbo.config.RegistryConfig;\n import com.alibaba.dubbo.config.ServiceConfig;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n public class ReferenceConfigTest {\n     private ApplicationConfig application = new ApplicationConfig();\n     private RegistryConfig registry = new RegistryConfig();\n     private ProtocolConfig protocol = new ProtocolConfig();\n-    @BeforeAll\n+    @BeforeEach\n     public void setUp() {\n         ConfigManager.getInstance().clear();\n     }\n-    @AfterAll\n+    @AfterEach\n     public void tearDown() {\n         ConfigManager.getInstance().clear();\n     }",
    "output": "Use beforeEach and afterEach"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java\n@@ -16,9 +16,6 @@\n  */\n package org.apache.dubbo.config.spring.beans.factory.annotation;\n-import org.apache.dubbo.common.Constants;\n-import org.apache.dubbo.common.utils.ArrayUtils;\n-import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.annotation.Reference;\n import org.apache.dubbo.config.spring.ReferenceBean;\n import org.apache.dubbo.config.spring.ServiceBean;\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationPropertyValuesAdapterTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationPropertyValuesAdapterTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationPropertyValuesAdapterTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationPropertyValuesAdapterTest.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.config.annotation.Reference;\n import org.apache.dubbo.config.spring.ReferenceBean;\n import org.apache.dubbo.config.spring.api.DemoService;\n+\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n import org.springframework.core.annotation.AnnotationUtils;",
    "output": "Remove unused import * remove not used import * remove unused import"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java\n@@ -16,7 +16,6 @@\n  */\n package org.apache.dubbo.config.spring;\n-import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.config.ConfigurationUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.config.ApplicationConfig;",
    "output": "Remove not used import"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -27,19 +27,21 @@\n import com.alibaba.dubbo.config.RegistryConfig;\n import com.alibaba.dubbo.config.ServiceConfig;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n public class ReferenceConfigTest {\n     private ApplicationConfig application = new ApplicationConfig();\n     private RegistryConfig registry = new RegistryConfig();\n     private ProtocolConfig protocol = new ProtocolConfig();\n-    @Before\n+    @BeforeAll\n     public void setUp() {\n         ConfigManager.getInstance().clear();\n     }\n-    @After\n+    @AfterAll\n     public void tearDown() {\n         ConfigManager.getInstance().clear();\n     }",
    "output": "Remove usage of classes in Junit 4"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/ConfigConditionRouterTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/ConfigConditionRouterTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/ConfigConditionRouterTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/ConfigConditionRouterTest.java\n@@ -20,10 +20,10 @@\n import org.apache.curator.framework.CuratorFrameworkFactory;\n import org.apache.curator.retry.ExponentialBackoffRetry;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n-import org.junit.Ignore;\n-@Ignore(\"FIXME This is not a formal UT\")\n+@Disabled(\"FIXME This is not a formal UT\")\n public class ConfigConditionRouterTest {\n     private static CuratorFramework client;\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n@@ -19,11 +19,11 @@\n import org.apache.curator.framework.CuratorFramework;\n import org.apache.curator.framework.CuratorFrameworkFactory;\n import org.apache.curator.retry.ExponentialBackoffRetry;\n-\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n-@Ignore(\"FIXME This is not a formal UT\")\n+@Disabled(\"FIXME This is not a formal UT\")\n public class TagRouterTest {\n     private static CuratorFramework client;\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractInterfaceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractInterfaceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractInterfaceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractInterfaceConfigTest.java\n@@ -30,6 +30,7 @@\n import org.apache.dubbo.registry.RegistryService;\n import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n@@ -62,7 +63,7 @@ public static void tearDown() {\n         System.clearProperty(Constants.DUBBO_PROPERTIES_KEY);\n     }\n-    @After\n+    @AfterEach\n     public void tearMethodAfterEachUT() {\n         ConfigManager.getInstance().clear();\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigCenterConfigTest.java\n@@ -19,13 +19,14 @@\n package org.apache.dubbo.config;\n-import junit.framework.TestCase;\n-import org.junit.Test;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n public class ConfigCenterConfigTest {\n     @Test\n     public void testPrefix() {\n         ConfigCenterConfig config = new ConfigCenterConfig();\n-        TestCase.assertEquals(\"dubbo.config-center\", config.getPrefix());\n+        Assertions.assertEquals(\"dubbo.config-center\", config.getPrefix());\n     }\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -21,17 +21,19 @@\n import org.apache.dubbo.config.context.ConfigManager;\n import org.apache.dubbo.config.provider.impl.DemoServiceImpl;\n+import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n public class ReferenceConfigTest {\n-    @Before\n+    @BeforeEach\n     public void setUp() {\n         ConfigManager.getInstance().clear();\n     }\n-    @After\n+    @AfterEach\n     public void tearDown() {\n         ConfigManager.getInstance().clear();\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java\n@@ -32,6 +32,7 @@\n import org.apache.dubbo.rpc.Protocol;\n import org.apache.dubbo.rpc.service.GenericService;\n+import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Disabled;\n@@ -106,7 +107,7 @@ public void setUp() throws Exception {\n         ConfigManager.getInstance().clear();\n     }\n-    @After\n+    @AfterEach\n     public void tearDown() {\n         ConfigManager.getInstance().clear();\n     }\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandlerTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandlerTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandlerTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandlerTest.java\n@@ -27,13 +27,13 @@\n import org.apache.dubbo.config.spring.api.DemoService;\n import org.apache.dubbo.config.spring.impl.DemoServiceImpl;\n+import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-\n import org.springframework.beans.factory.BeanCreationException;\n import org.springframework.context.support.ClassPathXmlApplicationContext;\n-import java.io.IOException;\n import java.util.Map;\n import static org.hamcrest.CoreMatchers.is;\n@@ -42,12 +42,12 @@\n import static org.hamcrest.MatcherAssert.assertThat;\n public class DubboNamespaceHandlerTest {\n-    @Before\n+    @BeforeEach\n     public void setUp() {\n         ConfigManager.getInstance().clear();\n     }\n-    @After\n+    @AfterEach\n     public void tearDown() {\n         ConfigManager.getInstance().clear();\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java\n@@ -28,7 +28,9 @@\n import org.apache.dubbo.rpc.service.GenericException;\n import org.apache.dubbo.rpc.service.GenericService;\n+import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import javax.validation.ConstraintViolation;\n@@ -46,12 +48,12 @@ public class ValidationTest {\n     private RegistryConfig registryNA = new RegistryConfig(\"N/A\");\n     private ProtocolConfig protocolDubo29582 = new ProtocolConfig(\"dubbo\", 29582);\n-    @Before\n+    @BeforeEach\n     public void setUp() {\n         ConfigManager.getInstance().clear();\n     }\n-    @After\n+    @AfterEach\n     public void tearDown() {\n         ConfigManager.getInstance().clear();\n     }",
    "output": "Remove usage of classes in Junit 4"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessorTest.java\n@@ -70,15 +70,15 @@ public void test() {\n         Map<String, ServiceBean> serviceBeansMap = beanFactory.getBeansOfType(ServiceBean.class);\n-        Assert.assertEquals(2, serviceBeansMap.size());\n+        Assertions.assertEquals(2, serviceBeansMap.size());\n         Map<String, ServiceAnnotationBeanPostProcessor> beanPostProcessorsMap =\n                 beanFactory.getBeansOfType(ServiceAnnotationBeanPostProcessor.class);\n-        Assert.assertEquals(2, beanPostProcessorsMap.size());\n+        Assertions.assertEquals(2, beanPostProcessorsMap.size());\n-        Assert.assertTrue(beanPostProcessorsMap.containsKey(\"serviceAnnotationBeanPostProcessor\"));\n-        Assert.assertTrue(beanPostProcessorsMap.containsKey(\"serviceAnnotationBeanPostProcessor2\"));\n+        Assertions.assertTrue(beanPostProcessorsMap.containsKey(\"serviceAnnotationBeanPostProcessor\"));\n+        Assertions.assertTrue(beanPostProcessorsMap.containsKey(\"serviceAnnotationBeanPostProcessor2\"));\n     }",
    "output": "Remove usage of classes in Junit 4"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcContextTest.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.rpc;\n import org.apache.dubbo.common.URL;\n+\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n@@ -145,10 +146,10 @@ public void testAsync() {\n         Assertions.assertFalse(rpcContext.isAsyncStarted());\n         AsyncContext asyncContext = RpcContext.startAsync();\n-        Assert.assertTrue(rpcContext.isAsyncStarted());\n+        Assertions.assertTrue(rpcContext.isAsyncStarted());\n         asyncContext.write(new Object());\n-        Assert.assertTrue(((AsyncContextImpl)asyncContext).getInternalFuture().isDone());\n+        Assertions.assertTrue(((AsyncContextImpl)asyncContext).getInternalFuture().isDone());\n         rpcContext.stopAsync();\n         Assertions.assertTrue(rpcContext.isAsyncStarted());",
    "output": "Remove usage of classes in Junit 4"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ShutdownTelnetHandler.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ShutdownTelnetHandler.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ShutdownTelnetHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ShutdownTelnetHandler.java\n@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.dubbo.telnet;\n+\n+import org.apache.dubbo.common.extension.Activate;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.config.DubboShutdownHook;\n+import org.apache.dubbo.remoting.Channel;\n+import org.apache.dubbo.remoting.RemotingException;\n+import org.apache.dubbo.remoting.telnet.TelnetHandler;\n+import org.apache.dubbo.remoting.telnet.support.Help;\n+\n+/**\n+ * ShutdownTelnetHandler\n+ */\n+@Activate\n+@Help(parameter = \"[-t <milliseconds>]\", summary = \"Shutdown Dubbo Application.\", detail = \"Shutdown Dubbo Application.\")\n+public class ShutdownTelnetHandler implements TelnetHandler {\n+    @Override\n+    public String telnet(Channel channel, String message) throws RemotingException {\n+\n+        int sleepMilliseconds = 0;\n+        if (StringUtils.isNotEmpty(message)) {\n+            String[] parameters = message.split(\"\\\\s+\");\n+            if (parameters.length == 2 && parameters[0].equals(\"-t\") && StringUtils.isInteger(parameters[1])) {\n+                sleepMilliseconds = Integer.parseInt(parameters[1]);\n+            } else {\n+                return \"Invalid parameter,please input like shutdown -t 10000\";\n+            }\n+        }\n+        long start = System.currentTimeMillis();\n+        if (sleepMilliseconds > 0) {\n+            try {\n+                Thread.sleep(sleepMilliseconds);\n+            } catch (InterruptedException e) {\n+                return \"Failed to invoke shutdown command, cause: \" + e.getMessage();\n+            }\n+        }\n+        StringBuilder buf = new StringBuilder();\n+        DubboShutdownHook.getDubboShutdownHook().unregister();\n+        DubboShutdownHook.getDubboShutdownHook().doDestroy();\n+        long end = System.currentTimeMillis();\n+        buf.append(\"Application has shutdown successfully\");\n+        buf.append(\"\\r\\nelapsed: \");\n+        buf.append(end - start);\n+        buf.append(\" ms.\");\n+        return buf.toString();\n+    }\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ShutdownTelnetHandlerTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ShutdownTelnetHandlerTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ShutdownTelnetHandlerTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ShutdownTelnetHandlerTest.java\n@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.protocol.dubbo.telnet;\n+\n+import org.apache.dubbo.remoting.Channel;\n+import org.apache.dubbo.remoting.RemotingException;\n+import org.apache.dubbo.remoting.telnet.TelnetHandler;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * SelectTelnetHandlerTest.java\n+ */\n+public class ShutdownTelnetHandlerTest {\n+\n+    private static TelnetHandler handler = new ShutdownTelnetHandler();\n+    private Channel mockChannel;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void testInvoke() throws RemotingException {\n+        mockChannel = mock(Channel.class);\n+        String result = handler.telnet(mockChannel, \"\");\n+        assertTrue(result.contains(\"Application has shutdown successfully\"));\n+    }\n+\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void testInvokeWithTimeParameter() throws RemotingException {\n+        mockChannel = mock(Channel.class);\n+        int sleepTime = 2000;\n+        long start = System.currentTimeMillis();\n+        String result = handler.telnet(mockChannel, \"-t \" + sleepTime);\n+        long end = System.currentTimeMillis();\n+        assertTrue(result.contains(\"Application has shutdown successfully\") && (end - start) > sleepTime);\n+    }\n+\n+\n+}",
    "output": "Add shutdown command for telnet * telnet add shutdown command * refactor rename shutDown to shutdown * remove unregister in doDestroy * unregister the ShutdownHook when the shutdown command invoked"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java\n@@ -22,7 +22,7 @@\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.support.RpcUtils;\n-import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.List;\n@@ -33,7 +33,6 @@\n /**\n  * ConsistentHashLoadBalance\n- *\n  */\n public class ConsistentHashLoadBalance extends AbstractLoadBalance {\n     public static final String NAME = \"consistenthash\";\n@@ -126,12 +125,7 @@ private byte[] md5(String value) {\n                 throw new IllegalStateException(e.getMessage(), e);\n             }\n             md5.reset();\n-            byte[] bytes;\n-            try {\n-                bytes = value.getBytes(\"UTF-8\");\n-            } catch (UnsupportedEncodingException e) {\n-                throw new IllegalStateException(e.getMessage(), e);\n-            }\n+            byte[] bytes = value.getBytes(StandardCharsets.UTF_8);\n             md5.update(bytes);\n             return md5.digest();\n         }",
    "output": "Use standardcharset.utf-8 instead of literal * use standardcharset.utf-8 instead of literal * remove unused import"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n@@ -727,7 +727,7 @@ public double getMethodParameter(String method, String key, double defaultValue)\n         String methodKey = method + \".\" + key;\n         Number n = getNumbers().get(methodKey);\n         if (n != null) {\n-            return n.intValue();\n+            return n.doubleValue();\n         }\n         String value = getMethodParameter(method, key);\n         if (StringUtils.isEmpty(value)) {\n@@ -742,7 +742,7 @@ public float getMethodParameter(String method, String key, float defaultValue) {\n         String methodKey = method + \".\" + key;\n         Number n = getNumbers().get(methodKey);\n         if (n != null) {\n-            return n.intValue();\n+            return n.floatValue();\n         }\n         String value = getMethodParameter(method, key);\n         if (StringUtils.isEmpty(value)) {\n@@ -757,7 +757,7 @@ public long getMethodParameter(String method, String key, long defaultValue) {\n         String methodKey = method + \".\" + key;\n         Number n = getNumbers().get(methodKey);\n         if (n != null) {\n-            return n.intValue();\n+            return n.longValue();\n         }\n         String value = getMethodParameter(method, key);\n         if (StringUtils.isEmpty(value)) {",
    "output": "Fix return type"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n@@ -36,7 +36,6 @@\n import java.util.Map;\n import static org.apache.dubbo.common.utils.PojoUtils.realize;\n-import static org.apache.dubbo.rpc.RpcContext.getContext;\n /**\n  * InvokeTelnetHandler\n@@ -124,7 +123,6 @@ public String telnet(Channel channel, String message) {\n                 try {\n                     Object[] array = realize(list.toArray(), invokeMethod.getParameterTypes(),\n                             invokeMethod.getGenericParameterTypes());\n-                    getContext().setLocalAddress(channel.getLocalAddress()).setRemoteAddress(channel.getRemoteAddress());\n                     long start = System.currentTimeMillis();\n                     RpcResult result = new RpcResult();\n                     try {",
    "output": "Remove getContext()"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java\n@@ -149,7 +149,7 @@ public void setSyncReport(Boolean syncReport) {\n         this.syncReport = syncReport;\n     }\n-\n+    @Override\n     @Parameter(excluded = true)\n     public String getPrefix() {\n         return StringUtils.isNotEmpty(prefix) ? prefix : (Constants.DUBBO + \".\" + PREFIX_TAG);\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n@@ -70,7 +70,7 @@ public void eventReceived(CuratorFramework client, CuratorEvent event) throws Ex\n     public static void testStartupConfig() {\n         String str = \"dubbo.registry.address=zookeeper://127.0.0.1:2181\\n\" +\n                 \"dubbo.registry.group=dubboregistrygroup1\\n\" +\n-                \"dubbo.metadatareport.address=zookeeper://127.0.0.1:2181\\n\" +\n+                \"dubbo.metadata-report.address=zookeeper://127.0.0.1:2181\\n\" +\n                 \"dubbo.protocol.port=20990\\n\" +\n                 \"dubbo.service.org.apache.dubbo.demo.DemoService.timeout=9999\\n\";",
    "output": "Fix metadata report configuration error * fix prefix * Missing '@Override' annotation"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.config;\n import org.apache.dubbo.common.config.Environment;\n+import org.apache.dubbo.common.utils.ConfigUtils;\n import org.apache.dubbo.config.api.Greeting;\n import org.apache.dubbo.config.support.Parameter;\n@@ -32,6 +33,7 @@\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Properties;\n import static org.junit.Assert.assertThat;\n@@ -346,14 +348,18 @@ public void testRefreshSystem() {\n     }\n     @Test\n-    public void testRefreshProperties() {\n+    public void testRefreshProperties() throws Exception{\n         try {\n             Environment.getInstance().setExternalConfigMap(new HashMap<>());\n             OverrideConfig overrideConfig = new OverrideConfig();\n             overrideConfig.setAddress(\"override-config://127.0.0.1:2181\");\n             overrideConfig.setProtocol(\"override-config\");\n             overrideConfig.setEscape(\"override-config://\");\n+            Properties properties = new Properties();\n+            properties.load(this.getClass().getResourceAsStream(\"/dubbo.properties\"));\n+            ConfigUtils.setProperties(properties);\n+\n             overrideConfig.refresh();\n             Assert.assertEquals(\"override-config://127.0.0.1:2181\", overrideConfig.getAddress());\n@@ -362,6 +368,7 @@ public void testRefreshProperties() {\n             Assert.assertEquals(\"properties\", overrideConfig.getUseKeyAsProperty());\n         } finally {\n             Environment.getInstance().clearExternalConfigs();\n+            ConfigUtils.setProperties(null);\n         }\n     }",
    "output": "Fix UT"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n@@ -223,7 +223,7 @@ public void testSelect_multiInvokers() throws Exception {\n     public void testCloseAvailablecheck() {\n         LoadBalance lb = mock(LoadBalance.class);\n         Map<String, String> queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));\n-        URL tmpUrl = url.clearParameters().addParameters(queryMap).removeParameter(Constants.MONITOR_KEY);\n+        URL tmpUrl = url.addParameters(queryMap).removeParameter(Constants.MONITOR_KEY);\n         given(lb.select(invokers, tmpUrl, invocation)).willReturn(invoker1);\n         initlistsize5();",
    "output": "Fix mock in UT"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -694,7 +694,7 @@ public ApplicationConfig getApplication() {\n     }\n     public void setApplication(ApplicationConfig application) {\n-        ConfigManager.getInstance().setApplication(this.application);\n+        ConfigManager.getInstance().setApplication(application);\n         this.application = application;\n     }\n@@ -739,7 +739,7 @@ public List<RegistryConfig> getRegistries() {\n     @SuppressWarnings({\"unchecked\"})\n     public void setRegistries(List<? extends RegistryConfig> registries) {\n-        ConfigManager.getInstance().addRegistries(this.registries);\n+        ConfigManager.getInstance().addRegistries((List<RegistryConfig>) registries);\n         this.registries = (List<RegistryConfig>) registries;\n     }\n@@ -757,7 +757,7 @@ public MonitorConfig getMonitor() {\n     }\n     public void setMonitor(String monitor) {\n-        this.monitor = new MonitorConfig(monitor);\n+        setMonitor(new MonitorConfig(monitor));\n     }\n     public void setMonitor(MonitorConfig monitor) {\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n@@ -200,7 +200,7 @@ public List<ProtocolConfig> getProtocols() {\n     @SuppressWarnings({\"unchecked\"})\n     public void setProtocols(List<? extends ProtocolConfig> protocols) {\n-        ConfigManager.getInstance().addProtocols(this.protocols);\n+        ConfigManager.getInstance().addProtocols((List<ProtocolConfig>) protocols);\n         this.protocols = (List<ProtocolConfig>) protocols;\n     }\n@@ -209,7 +209,7 @@ public ProtocolConfig getProtocol() {\n     }\n     public void setProtocol(ProtocolConfig protocol) {\n-        this.protocols = Arrays.asList(protocol);\n+        setProtocols(Arrays.asList(protocol));\n     }\n     @Parameter(excluded = true)\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -540,11 +540,8 @@ public ConsumerConfig getConsumer() {\n     }\n     public void setConsumer(ConsumerConfig consumer) {\n-        if (consumer == null) {\n-            return;\n-        }\n-        this.consumer = consumer;\n         ConfigManager.getInstance().addConsumer(consumer);\n+        this.consumer = consumer;\n     }\n     public String getProtocol() {",
    "output": "Fix wrong reference"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n@@ -31,7 +31,6 @@\n import org.apache.dubbo.rpc.cluster.Router;\n import org.apache.dubbo.rpc.cluster.router.AbstractRouter;\n import org.apache.dubbo.rpc.cluster.router.condition.ConditionRouter;\n-import org.apache.dubbo.rpc.cluster.router.condition.config.model.BlackWhiteListRule;\n import org.apache.dubbo.rpc.cluster.router.condition.config.model.ConditionRouterRule;\n import org.apache.dubbo.rpc.cluster.router.condition.config.model.ConditionRuleParser;\n@@ -112,15 +111,6 @@ private void generateConditions(ConditionRouterRule rule, List<ConditionRouter>\n                 ConditionRouter subRouter = new ConditionRouter(condition, rule.isForce(), rule.isEnabled());\n                 routers.add(subRouter);\n             });\n-\n-            BlackWhiteListRule blackWhiteList = rule.getBlackWhiteList();\n-            if (blackWhiteList != null && blackWhiteList.isValid()) {\n-                blackWhiteList.getConditions().forEach(condition -> {\n-                    // All sub rules have the same force, runtime value.\n-                    ConditionRouter subRouter = new ConditionRouter(condition, true, blackWhiteList.isEnabled());\n-                    routers.add(subRouter);\n-                });\n-            }\n         }\n     }\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/BlackWhiteListRule.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/BlackWhiteListRule.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/BlackWhiteListRule.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/BlackWhiteListRule.java\n@@ -1,36 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.rpc.cluster.router.condition.config.model;\n-\n-import org.apache.dubbo.rpc.cluster.router.AbstractRouterRule;\n-\n-import java.util.List;\n-\n-/**\n- *\n- */\n-public class BlackWhiteListRule extends AbstractRouterRule {\n-    private List<String> conditions;\n-\n-    public List<String> getConditions() {\n-        return conditions;\n-    }\n-\n-    public void setConditions(List<String> conditions) {\n-        this.conditions = conditions;\n-    }\n-}\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRouterRule.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRouterRule.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRouterRule.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRouterRule.java\n@@ -27,7 +27,6 @@ public class ConditionRouterRule extends AbstractRouterRule {\n     public ConditionRouterRule() {\n     }\n-    private BlackWhiteListRule blackWhiteList;\n     private List<String> conditions;\n     public List<String> getConditions() {\n@@ -37,12 +36,4 @@ public List<String> getConditions() {\n     public void setConditions(List<String> conditions) {\n         this.conditions = conditions;\n     }\n-\n-    public BlackWhiteListRule getBlackWhiteList() {\n-        return blackWhiteList;\n-    }\n-\n-    public void setBlackWhiteList(BlackWhiteListRule blackWhiteList) {\n-        this.blackWhiteList = blackWhiteList;\n-    }\n }\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRuleParser.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRuleParser.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRuleParser.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRuleParser.java\n@@ -47,10 +47,6 @@ public static ConditionRouterRule parse(String rawRule) {\n             rule.setValid(false);\n         }\n-        BlackWhiteListRule blackWhiteList = rule.getBlackWhiteList();\n-        if (blackWhiteList != null && CollectionUtils.isEmpty(blackWhiteList.getConditions())) {\n-            blackWhiteList.setValid(false);\n-        }\n         return rule;\n     }",
    "output": "Remove BlackWhiteListRule"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/ConfigConditionRouterTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/ConfigConditionRouterTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/ConfigConditionRouterTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/ConfigConditionRouterTest.java\n@@ -20,11 +20,10 @@\n import org.apache.curator.framework.CuratorFrameworkFactory;\n import org.apache.curator.retry.ExponentialBackoffRetry;\n import org.junit.Before;\n+import org.junit.Ignore;\n import org.junit.Test;\n-/**\n- * FIXME This is not a formal UT\n- */\n+@Ignore(\"FIXME This is not a formal UT\")\n public class ConfigConditionRouterTest {\n     private static CuratorFramework client;\n@@ -48,7 +47,7 @@ public void normalConditionRuleApplicationLevelTest() {\n                 \"  - method=notExitMethod => \\n\" +\n                 \"...\";\n         try {\n-            String servicePath = \"/dubbo/config/demo-consumer/routers\";\n+            String servicePath = \"/dubbo/config/demo-consumer/routers/condition\";\n             if (client.checkExists().forPath(servicePath) == null) {\n                 client.create().creatingParentsIfNeeded().forPath(servicePath);\n             }\n@@ -72,7 +71,7 @@ public void normalConditionRuleApplicationServiceLevelTest() {\n                 \"  - method=routeMethod1 => host=30.5.120.37\\n\" +\n                 \"...\";\n         try {\n-            String servicePath = \"/dubbo/config/demo-consumer/routers\";\n+            String servicePath = \"/dubbo/config/demo-consumer/routers/condition\";\n             if (client.checkExists().forPath(servicePath) == null) {\n                 client.create().creatingParentsIfNeeded().forPath(servicePath);\n             }\n@@ -97,7 +96,7 @@ public void normalConditionRuleServiceLevelTest() {\n                 \"...\";\n //        String serviceStr = \"\";\n         try {\n-            String servicePath = \"/dubbo/config/org.apache.dubbo.demo.DemoService/routers\";\n+            String servicePath = \"/dubbo/config/org.apache.dubbo.demo.DemoService/routers/condition\";\n             if (client.checkExists().forPath(servicePath) == null) {\n                 client.create().creatingParentsIfNeeded().forPath(servicePath);\n             }\n@@ -118,7 +117,7 @@ public void abnormalNoruleConditionRuleTest() {\n                 \"key: org.apache.dubbo.demo.DemoService\\n\" +\n                 \"...\";\n         try {\n-            String servicePath = \"/dubbo/config/org.apache.dubbo.demo.DemoService/routers\";\n+            String servicePath = \"/dubbo/config/org.apache.dubbo.demo.DemoService/routers/condition\";\n             if (client.checkExists().forPath(servicePath) == null) {\n                 client.create().creatingParentsIfNeeded().forPath(servicePath);\n             }\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n@@ -20,11 +20,10 @@\n import org.apache.curator.framework.CuratorFrameworkFactory;\n import org.apache.curator.retry.ExponentialBackoffRetry;\n import org.junit.Before;\n+import org.junit.Ignore;\n import org.junit.Test;\n-/**\n- * FIXME This is not a formal UT\n- */\n+@Ignore(\"FIXME This is not a formal UT\")\n public class TagRouterTest {\n     private static CuratorFramework client;\n@@ -51,7 +50,7 @@ public void normalTagRuleTest() {\n                 \"...\";\n //        String serviceStr = \"\";\n         try {\n-            String servicePath = \"/dubbo/config/demo-provider/tagrouters\";\n+            String servicePath = \"/dubbo/config/demo-provider/routers/tag\";\n             if (client.checkExists().forPath(servicePath) == null) {\n                 client.create().creatingParentsIfNeeded().forPath(servicePath);\n             }",
    "output": "Fix UT"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ConfigTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ConfigTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ConfigTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ConfigTest.java\n@@ -17,25 +17,32 @@\n package org.apache.dubbo.config;\n+import org.apache.dubbo.config.context.ConfigManager;\n import org.apache.dubbo.service.DemoService;\n import org.apache.dubbo.service.DemoServiceImpl;\n import com.alibaba.dubbo.config.ReferenceConfig;\n import com.alibaba.dubbo.config.ServiceConfig;\n+import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n public class ConfigTest {\n-\n     private com.alibaba.dubbo.config.ApplicationConfig applicationConfig = new com.alibaba.dubbo.config.ApplicationConfig(\"first-dubbo-test\");\n     private com.alibaba.dubbo.config.RegistryConfig registryConfig = new com.alibaba.dubbo.config.RegistryConfig(\"multicast://224.5.6.7:1234\");\n+    @After\n+    public void tearDown() {\n+        ConfigManager.getInstance().clear();\n+    }\n+\n     @Before\n     public void setup() {\n         // In IDE env, make sure adding the following argument to VM options\n         System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n+        ConfigManager.getInstance().clear();\n     }\n     @Test\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.config;\n+import org.apache.dubbo.config.context.ConfigManager;\n import org.apache.dubbo.service.DemoService;\n import org.apache.dubbo.service.DemoServiceImpl;\n@@ -26,13 +27,25 @@\n import com.alibaba.dubbo.config.RegistryConfig;\n import com.alibaba.dubbo.config.ServiceConfig;\n+import org.junit.After;\n+import org.junit.Before;\n import org.junit.Test;\n public class ReferenceConfigTest {\n     private ApplicationConfig application = new ApplicationConfig();\n     private RegistryConfig registry = new RegistryConfig();\n     private ProtocolConfig protocol = new ProtocolConfig();\n+    @Before\n+    public void setUp() {\n+        ConfigManager.getInstance().clear();\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        ConfigManager.getInstance().clear();\n+    }\n+\n     @Test\n     public void testInjvm() throws Exception {",
    "output": "Fix UT"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ConfigTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ConfigTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ConfigTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ConfigTest.java\n@@ -20,9 +20,7 @@\n import org.apache.dubbo.service.DemoService;\n import org.apache.dubbo.service.DemoServiceImpl;\n-import com.alibaba.dubbo.config.ApplicationConfig;\n import com.alibaba.dubbo.config.ReferenceConfig;\n-import com.alibaba.dubbo.config.RegistryConfig;\n import com.alibaba.dubbo.config.ServiceConfig;\n import org.junit.Assert;\n@@ -31,6 +29,9 @@\n public class ConfigTest {\n+    private com.alibaba.dubbo.config.ApplicationConfig applicationConfig = new com.alibaba.dubbo.config.ApplicationConfig(\"first-dubbo-test\");\n+    private com.alibaba.dubbo.config.RegistryConfig registryConfig = new com.alibaba.dubbo.config.RegistryConfig(\"multicast://224.5.6.7:1234\");\n+\n     @Before\n     public void setup() {\n         // In IDE env, make sure adding the following argument to VM options\n@@ -40,15 +41,15 @@ public void setup() {\n     @Test\n     public void testConfig() {\n         com.alibaba.dubbo.config.ServiceConfig<DemoService> service = new ServiceConfig<>();\n-        service.setApplication(new com.alibaba.dubbo.config.ApplicationConfig(\"first-dubbo-provider\"));\n-        service.setRegistry(new com.alibaba.dubbo.config.RegistryConfig(\"multicast://224.5.6.7:1234\"));\n+        service.setApplication(applicationConfig);\n+        service.setRegistry(registryConfig);\n         service.setInterface(DemoService.class);\n         service.setRef(new DemoServiceImpl());\n         service.export();\n         com.alibaba.dubbo.config.ReferenceConfig<DemoService> reference = new ReferenceConfig<>();\n-        reference.setApplication(new ApplicationConfig(\"first-dubbo-client\"));\n-        reference.setRegistry(new RegistryConfig(\"multicast://224.5.6.7:1234\"));\n+        reference.setApplication(applicationConfig);\n+        reference.setRegistry(registryConfig);\n         reference.setInterface(DemoService.class);\n         DemoService demoService = reference.get();\n         String message = demoService.sayHello(\"dubbo\");\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -29,16 +29,16 @@\n import org.junit.Test;\n public class ReferenceConfigTest {\n+    private ApplicationConfig application = new ApplicationConfig();\n+    private RegistryConfig registry = new RegistryConfig();\n+    private ProtocolConfig protocol = new ProtocolConfig();\n     @Test\n     public void testInjvm() throws Exception {\n-        ApplicationConfig application = new ApplicationConfig();\n-        application.setName(\"test-protocol-random-port\");\n-        RegistryConfig registry = new RegistryConfig();\n+        application.setName(\"test-protocol-random-port\");\n         registry.setAddress(\"multicast://224.5.6.7:1234\");\n-        ProtocolConfig protocol = new ProtocolConfig();\n         protocol.setName(\"dubbo\");\n         ServiceConfig<DemoService> demoService;",
    "output": "Fix UT"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -673,6 +673,9 @@ public ApplicationConfig getApplication() {\n     }\n     public void setApplication(ApplicationConfig application) {\n+        if (application == null) {\n+            return;\n+        }\n         application.refresh();\n         this.application = application;\n         ConfigManager.getInstance().setApplication(this.application);\n@@ -691,6 +694,9 @@ public ModuleConfig getModule() {\n     }\n     public void setModule(ModuleConfig module) {\n+        if (module == null) {\n+            return;\n+        }\n         this.module = module;\n         ConfigManager.getInstance().setModule(module);\n     }\n@@ -711,6 +717,9 @@ public List<RegistryConfig> getRegistries() {\n     @SuppressWarnings({\"unchecked\"})\n     public void setRegistries(List<? extends RegistryConfig> registries) {\n+        if (registries == null) {\n+            return;\n+        }\n         for (RegistryConfig registryConfig : registries) {\n             registryConfig.refresh();\n             if (StringUtils.isNotEmpty(registryConfig.getId())) {\n@@ -740,6 +749,9 @@ public void setMonitor(String monitor) {\n     }\n     public void setMonitor(MonitorConfig monitor) {\n+        if (monitor == null) {\n+            return;\n+        }\n         monitor.refresh();\n         this.monitor = monitor;\n         ConfigManager.getInstance().setMonitor(monitor);\n@@ -759,6 +771,9 @@ public ConfigCenterConfig getConfigCenter() {\n     }\n     public void setConfigCenter(ConfigCenterConfig configCenter) {\n+        if (configCenter == null) {\n+            return;\n+        }\n         // give jvm properties the chance to override local configs, e.g., -Ddubbo.configcenter.highestPriority\n         configCenter.refresh();\n         this.configCenter = configCenter;\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n@@ -201,6 +201,9 @@ public List<ProtocolConfig> getProtocols() {\n     @SuppressWarnings({\"unchecked\"})\n     public void setProtocols(List<? extends ProtocolConfig> protocols) {\n+        if (protocols == null) {\n+            return;\n+        }\n         for (ProtocolConfig protocolConfig : protocols) {\n             if (StringUtils.isEmpty(protocolConfig.getName())) {\n                 protocolConfig.setName(Constants.DUBBO_VERSION_KEY);\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -534,6 +534,9 @@ public ConsumerConfig getConsumer() {\n     }\n     public void setConsumer(ConsumerConfig consumer) {\n+        if (consumer == null) {\n+            return;\n+        }\n         this.consumer = consumer;\n         ConfigManager.getInstance().addConsumer(consumer);\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -920,6 +920,9 @@ public ProviderConfig getProvider() {\n     }\n     public void setProvider(ProviderConfig provider) {\n+        if (provider == null) {\n+            return;\n+        }\n         provider.refresh();\n         this.provider = provider;\n         ConfigManager.getInstance().addProvider(provider);",
    "output": "Add empty check at the start of setter"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/validation/ValidationTest.java\n@@ -23,11 +23,14 @@\n import org.apache.dubbo.config.ReferenceConfig;\n import org.apache.dubbo.config.RegistryConfig;\n import org.apache.dubbo.config.ServiceConfig;\n+import org.apache.dubbo.config.context.ConfigManager;\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.service.GenericException;\n import org.apache.dubbo.rpc.service.GenericService;\n+import org.junit.After;\n import org.junit.Assert;\n+import org.junit.Before;\n import org.junit.Test;\n import javax.validation.ConstraintViolation;\n@@ -41,20 +44,33 @@\n  * GenericServiceTest\n  */\n public class ValidationTest {\n+    private ApplicationConfig application = new ApplicationConfig(\"validation-test\");\n+    private RegistryConfig registryNA = new RegistryConfig(\"N/A\");\n+    private ProtocolConfig protocolDubo29582 = new ProtocolConfig(\"dubbo\", 29582);\n+\n+    @Before\n+    public void setUp() {\n+        ConfigManager.getInstance().clear();\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        ConfigManager.getInstance().clear();\n+    }\n     @Test\n     public void testValidation() {\n         ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();\n-        service.setApplication(new ApplicationConfig(\"validation-provider\"));\n-        service.setRegistry(new RegistryConfig(\"N/A\"));\n-        service.setProtocol(new ProtocolConfig(\"dubbo\", 29582));\n+        service.setApplication(application);\n+        service.setRegistry(registryNA);\n+        service.setProtocol(protocolDubo29582);\n         service.setInterface(ValidationService.class.getName());\n         service.setRef(new ValidationServiceImpl());\n         service.setValidation(String.valueOf(true));\n         service.export();\n         try {\n             ReferenceConfig<ValidationService> reference = new ReferenceConfig<ValidationService>();\n-            reference.setApplication(new ApplicationConfig(\"validation-consumer\"));\n+            reference.setApplication(application);\n             reference.setInterface(ValidationService.class);\n             reference.setUrl(\"dubbo://127.0.0.1:29582?scope=remote&validation=true\");\n             ValidationService validationService = reference.get();\n@@ -171,16 +187,16 @@ public void testValidation() {\n     @Test\n     public void testProviderValidation() {\n         ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();\n-        service.setApplication(new ApplicationConfig(\"validation-provider\"));\n-        service.setRegistry(new RegistryConfig(\"N/A\"));\n-        service.setProtocol(new ProtocolConfig(\"dubbo\", 29582));\n+        service.setApplication(application);\n+        service.setRegistry(registryNA);\n+        service.setProtocol(protocolDubo29582);\n         service.setInterface(ValidationService.class.getName());\n         service.setRef(new ValidationServiceImpl());\n         service.setValidation(String.valueOf(true));\n         service.export();\n         try {\n             ReferenceConfig<ValidationService> reference = new ReferenceConfig<ValidationService>();\n-            reference.setApplication(new ApplicationConfig(\"validation-consumer\"));\n+            reference.setApplication(application);\n             reference.setInterface(ValidationService.class);\n             reference.setUrl(\"dubbo://127.0.0.1:29582\");\n             ValidationService validationService = reference.get();\n@@ -236,16 +252,16 @@ public void testProviderValidation() {\n     @Test\n     public void testGenericValidation() {\n         ServiceConfig<ValidationService> service = new ServiceConfig<ValidationService>();\n-        service.setApplication(new ApplicationConfig(\"validation-provider\"));\n-        service.setRegistry(new RegistryConfig(\"N/A\"));\n-        service.setProtocol(new ProtocolConfig(\"dubbo\", 29582));\n+        service.setApplication(application);\n+        service.setRegistry(registryNA);\n+        service.setProtocol(protocolDubo29582);\n         service.setInterface(ValidationService.class.getName());\n         service.setRef(new ValidationServiceImpl());\n         service.setValidation(String.valueOf(true));\n         service.export();\n         try {\n             ReferenceConfig<GenericService> reference = new ReferenceConfig<GenericService>();\n-            reference.setApplication(new ApplicationConfig(\"validation-consumer\"));\n+            reference.setApplication(application);\n             reference.setInterface(ValidationService.class.getName());\n             reference.setUrl(\"dubbo://127.0.0.1:29582?scope=remote&validation=true&timeout=9000000\");\n             reference.setGeneric(true);",
    "output": "Fix UT"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n@@ -62,10 +62,10 @@ public class Constants {\n     public static final String CONFIG_NAMESPACE_KEY = \"config.namespace\";\n     public static final String CONFIG_GROUP_KEY = \"config.group\";\n     public static final String CONFIG_CHECK_KEY = \"config.check\";\n-    public static final String CONFIG_CONFIGFILE_KEY = \"config.configFile\";\n-    public static final String CONFIG_ENABLE_KEY = \"config.highestPriority\";\n+    public static final String CONFIG_CONFIGFILE_KEY = \"config.config-file\";\n+    public static final String CONFIG_ENABLE_KEY = \"config.highest-priority\";\n     public static final String CONFIG_TIMEOUT_KEY = \"config.timeout\";\n-    public static final String CONFIG_APPNAME_KEY = \"config.appName\";\n+    public static final String CONFIG_APPNAME_KEY = \"config.app-name\";\n     public static final String DEFAULT_CATEGORY = PROVIDERS_CATEGORY;\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n@@ -163,10 +163,12 @@ public void setDynamicConfiguration(Configuration dynamicConfiguration) {\n     // For test\n     public void clearExternalConfigs() {\n         this.externalConfigs.clear();\n+        this.externalConfigurationMap.clear();\n     }\n     // For test\n     public void clearAppExternalConfigs() {\n         this.appExternalConfigs.clear();\n+        this.appExternalConfigurationMap.clear();\n     }\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -22,6 +22,7 @@\n import org.apache.dubbo.common.config.Environment;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.utils.Assert;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.ConfigUtils;\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.common.utils.ReflectUtils;\n@@ -515,7 +516,9 @@ private void convertRegistryIdsToRegistries() {\n         if (StringUtils.isEmpty(registryIds)) {\n             if (registries == null || registries.isEmpty()) {\n-                registries = ConfigManager.getInstance().getDefaultRegistries().orElse(Arrays.asList(new RegistryConfig()));\n+                registries = ConfigManager.getInstance().getDefaultRegistries()\n+                        .filter(CollectionUtils::isNotEmpty)\n+                        .orElse(Arrays.asList(new RegistryConfig()));\n             }\n         } else {\n             String[] arr = Constants.COMMA_SPLIT_PATTERN.split(registryIds);\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -23,6 +23,7 @@\n import org.apache.dubbo.common.config.Environment;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.utils.ClassHelper;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.ConfigUtils;\n import org.apache.dubbo.common.utils.NamedThreadFactory;\n import org.apache.dubbo.common.utils.StringUtils;\n@@ -829,7 +830,9 @@ private void convertProtocolIdsToProtocols() {\n         if (StringUtils.isEmpty(protocolIds)) {\n             if (protocols == null || protocols.isEmpty()) {\n-                protocols = ConfigManager.getInstance().getDefaultProtocols().orElse(Arrays.asList(new ProtocolConfig()));\n+                protocols = ConfigManager.getInstance().getDefaultProtocols()\n+                        .filter(CollectionUtils::isNotEmpty)\n+                        .orElse(Arrays.asList(new ProtocolConfig()));\n             }\n         } else {\n             String[] arr = Constants.COMMA_SPLIT_PATTERN.split(protocolIds);\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/context/ConfigManager.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/context/ConfigManager.java\n@@ -304,4 +304,16 @@ private void checkDuplicate(AbstractConfig oldOne, AbstractConfig newOne) {\n         }\n     }\n+    // For test purpose\n+    public void clear() {\n+        this.application = null;\n+        this.configCenter = null;\n+        this.monitor = null;\n+        this.module = null;\n+        this.registries.clear();\n+        this.protocols.clear();\n+        this.providers.clear();\n+        this.consumers.clear();\n+    }\n+\n }",
    "output": "Fix bug of read config"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -291,20 +291,6 @@ private static Method getMethodByName(Class<?> clazz, String methodName) {\n         }\n     }\n-    /**\n-     * We only check boolean value at this moment.\n-     *\n-     * @param type\n-     * @param value\n-     * @return\n-     */\n-    private static boolean isTypeMatch(Class<?> type, String value) {\n-        if ((type == boolean.class || type == Boolean.class)\n-                && !(\"true\".equals(value) || \"false\".equals(value))) {\n-            return false;\n-        }\n-        return true;\n-    }\n     protected static void checkExtension(Class<?> type, String property, String value) {\n         checkName(property, value);\n@@ -565,7 +551,7 @@ public void refresh() {\n             config.addProperties(getMetaData());\n             if (Environment.getInstance().isConfigCenterFirst()) {\n                 // The sequence would be: SystemConfiguration -> ExternalConfiguration -> AppExternalConfiguration -> AbstractConfig -> PropertiesConfiguration\n-                compositeConfiguration.addConfiguration(3,config);\n+                compositeConfiguration.addConfiguration(3, config);\n             } else {\n                 // The sequence would be: SystemConfiguration -> AbstractConfig -> ExternalConfiguration -> AppExternalConfiguration -> PropertiesConfiguration\n                 compositeConfiguration.addConfiguration(1, config);",
    "output": "Remove unused code,"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java\n@@ -59,9 +59,9 @@ public class DubboConfigConfiguration {\n             @EnableDubboConfigBinding(prefix = \"dubbo.monitor\", type = MonitorConfig.class),\n             @EnableDubboConfigBinding(prefix = \"dubbo.provider\", type = ProviderConfig.class),\n             @EnableDubboConfigBinding(prefix = \"dubbo.consumer\", type = ConsumerConfig.class),\n-            @EnableDubboConfigBinding(prefix = \"dubbo.configCenter\", type = ConfigCenterBean.class),\n-            @EnableDubboConfigBinding(prefix = \"dubbo.registryData\", type = RegistryDataConfig.class),\n-            @EnableDubboConfigBinding(prefix = \"dubbo.metadataReport\", type = MetadataReportConfig.class)\n+            @EnableDubboConfigBinding(prefix = \"dubbo.config-center\", type = ConfigCenterBean.class),\n+            @EnableDubboConfigBinding(prefix = \"dubbo.registry-data\", type = RegistryDataConfig.class),\n+            @EnableDubboConfigBinding(prefix = \"dubbo.metadata-report\", type = MetadataReportConfig.class)\n     })\n     public static class Single {\n@@ -78,7 +78,7 @@ public static class Single {\n             @EnableDubboConfigBinding(prefix = \"dubbo.monitors\", type = MonitorConfig.class, multiple = true),\n             @EnableDubboConfigBinding(prefix = \"dubbo.providers\", type = ProviderConfig.class, multiple = true),\n             @EnableDubboConfigBinding(prefix = \"dubbo.consumers\", type = ConsumerConfig.class, multiple = true),\n-            @EnableDubboConfigBinding(prefix = \"dubbo.configCenters\", type = ConfigCenterBean.class, multiple = true)\n+            @EnableDubboConfigBinding(prefix = \"dubbo.config-centers\", type = ConfigCenterBean.class, multiple = true)\n     })\n     public static class Multiple {",
    "output": "Use hyphen instead of camel for prefix"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/zkclient/ZkclientZookeeperClient.java b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/zkclient/ZkclientZookeeperClient.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/zkclient/ZkclientZookeeperClient.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/zkclient/ZkclientZookeeperClient.java\n@@ -18,6 +18,8 @@\n import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.remoting.zookeeper.ChildListener;\n import org.apache.dubbo.remoting.zookeeper.StateListener;\n import org.apache.dubbo.remoting.zookeeper.support.AbstractZookeeperClient;\n@@ -32,6 +34,8 @@\n public class ZkclientZookeeperClient extends AbstractZookeeperClient<IZkChildListener> {\n+    private Logger logger = LoggerFactory.getLogger(ZkclientZookeeperClient.class);\n+\n     private final ZkClientWrapper client;\n     private volatile KeeperState state = KeeperState.SyncConnected;\n@@ -65,6 +69,7 @@ public void createPersistent(String path) {\n         try {\n             client.createPersistent(path);\n         } catch (ZkNodeExistsException e) {\n+            logger.error(\"zookeeper failed to create persistent node with \" + path + \": \", e);\n         }\n     }\n@@ -73,6 +78,7 @@ public void createEphemeral(String path) {\n         try {\n             client.createEphemeral(path);\n         } catch (ZkNodeExistsException e) {\n+            logger.error(\"zookeeper failed to create ephemeral node with \" + path + \": \", e);\n         }\n     }\n@@ -81,6 +87,8 @@ protected void createPersistent(String path, String data) {\n         try {\n             client.createPersistent(path, data);\n         } catch (ZkNodeExistsException e) {\n+            logger.error(\"zookeeper failed to create persistent node with \" +\n+                    path + \" and \" + data + \" : \", e);\n         }\n     }\n@@ -89,6 +97,8 @@ protected void createEphemeral(String path, String data) {\n         try {\n             client.createEphemeral(path, data);\n         } catch (ZkNodeExistsException e) {\n+            logger.error(\"zookeeper failed to create ephemeral node with \" +\n+                    path + \" and \" + data + \" : \", e);\n         }\n     }\n@@ -97,6 +107,7 @@ public void delete(String path) {\n         try {\n             client.delete(path);\n         } catch (ZkNoNodeException e) {\n+            logger.error(\"zookeeper failed to delete node with \" + path + \": \", e);\n         }\n     }\n@@ -105,6 +116,7 @@ public List<String> getChildren(String path) {\n         try {\n             return client.getChildren(path);\n         } catch (ZkNoNodeException e) {\n+            logger.error(\"zookeeper failed to get children node with \" + path + \": \", e);\n             return null;\n         }\n     }\n@@ -114,6 +126,7 @@ public boolean checkExists(String path) {\n         try {\n             return client.exists(path);\n         } catch (Throwable t) {\n+            logger.error(\"zookeeper failed to check node existing with \" + path + \": \", t);\n         }\n         return false;\n     }\n@@ -128,6 +141,7 @@ public String doGetContent(String path) {\n         try {\n             return client.getData(path);\n         } catch (ZkNoNodeException e) {\n+            logger.error(\"zookeeper failed to get data with \" + path + \": \", e);\n             return null;\n         }\n     }",
    "output": "Add log in ZkclientZookeeperClient.java"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboBuilder.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboBuilder.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboBuilder.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboBuilder.java\n@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.config;\n+\n+/**\n+ * TODO\n+ * Experimental, should only being used internally, will consider open to end user in the following version.\n+ */\n+public class DubboBuilder {\n+    private\n+}",
    "output": "Add DubboBuilder"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/DubboRegistryTest.java b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/DubboRegistryTest.java\n--- a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/DubboRegistryTest.java\n+++ b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/DubboRegistryTest.java\n@@ -75,39 +75,39 @@ public void setUp() {\n     @Test\n     public void testRegister() {\n         dubboRegistry.register(serviceURL);\n-        assertEquals(1, getRegistereds());\n+        assertEquals(1, getRegisteredSize());\n     }\n     @Test\n     public void testUnRegister() {\n-        assertEquals(0, getRegistereds());\n+        assertEquals(0, getRegisteredSize());\n         dubboRegistry.register(serviceURL);\n-        assertEquals(1, getRegistereds());\n+        assertEquals(1, getRegisteredSize());\n         dubboRegistry.unregister(serviceURL);\n-        assertEquals(0, getRegistereds());\n+        assertEquals(0, getRegisteredSize());\n     }\n     @Test\n     public void testSubscribe() {\n         dubboRegistry.register(serviceURL);\n-        assertEquals(1, getRegistereds());\n+        assertEquals(1, getRegisteredSize());\n         dubboRegistry.subscribe(serviceURL, notifyListener);\n-        assertEquals(1, getSubscribeds());\n+        assertEquals(1, getSubscribedSize());\n         assertEquals(1, getNotifiedListeners());\n     }\n     @Test\n     public void testUnsubscribe() {\n         dubboRegistry.subscribe(serviceURL, notifyListener);\n-        assertEquals(1, getSubscribeds());\n+        assertEquals(1, getSubscribedSize());\n         assertEquals(1, getNotifiedListeners());\n         dubboRegistry.unsubscribe(serviceURL, notifyListener);\n         assertEquals(0, getNotifiedListeners());\n     }\n     private class MockDubboRegistry extends FailbackRegistry {\n-        private volatile boolean isAvaliable = false;\n+        private volatile boolean isAvailable = false;\n         public MockDubboRegistry(URL url) {\n             super(url);\n@@ -116,13 +116,13 @@ public MockDubboRegistry(URL url) {\n         @Override\n         public void doRegister(URL url) {\n             logger.info(\"Begin to register: \" + url);\n-            isAvaliable = true;\n+            isAvailable = true;\n         }\n         @Override\n         public void doUnregister(URL url) {\n             logger.info(\"Begin to ungister: \" + url);\n-            isAvaliable = false;\n+            isAvailable = false;\n         }\n         @Override\n@@ -137,19 +137,19 @@ public void doUnsubscribe(URL url, NotifyListener listener) {\n         @Override\n         public boolean isAvailable() {\n-            return isAvaliable;\n+            return isAvailable;\n         }\n     }\n     private int getNotifiedListeners() {\n         return dubboRegistry.getSubscribed().get(serviceURL).size();\n     }\n-    private int getRegistereds() {\n+    private int getRegisteredSize() {\n         return dubboRegistry.getRegistered().size();\n     }\n-    private int getSubscribeds() {\n+    private int getSubscribedSize() {\n         return dubboRegistry.getSubscribed().size();\n     }\n }",
    "output": "Fix typo"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/AnnotationBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/AnnotationBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/AnnotationBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/AnnotationBean.java\n@@ -173,9 +173,6 @@ public Object postProcessAfterInitialization(Object bean, String beanName)\n                 if (service.module().length() > 0) {\n                     serviceConfig.setModule(applicationContext.getBean(service.module(), ModuleConfig.class));\n                 }\n-                if (service.provider().length() > 0) {\n-                    serviceConfig.setProvider(applicationContext.getBean(service.provider(), ProviderConfig.class));\n-                }\n                 if (service.protocol().length > 0) {\n                     List<ProtocolConfig> protocolConfigs = new ArrayList<ProtocolConfig>();\n                     for (String protocolId : service.protocol()) {",
    "output": "Upgrade AnnotationBean.java delete useless code"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/async/support/AsyncFor.java b/dubbo-common/src/main/java/org/apache/dubbo/common/async/support/AsyncFor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/async/support/AsyncFor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/async/support/AsyncFor.java\n@@ -1,41 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.common.async.support;\n-\n-import java.lang.annotation.Documented;\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-/**\n- * TODO This definition should better be placed in module 'dubbo-config-api', but only can be done when \"rpc\" dependencies are removed from \"dubbo-config-api\"\n- * If a method is annotated with AsyncFor, it will be treated as an async counterpart for the sync specified in value.\n- */\n-@Documented\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target({ElementType.METHOD})\n-public @interface AsyncFor {\n-\n-    /**\n-     * The original sync-style method name\n-     *\n-     * @return\n-     */\n-    String value();\n-\n-}\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/InvokerInvocationHandler.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/InvokerInvocationHandler.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/InvokerInvocationHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/InvokerInvocationHandler.java\n@@ -17,7 +17,6 @@\n package org.apache.dubbo.rpc.proxy;\n import org.apache.dubbo.common.Constants;\n-import org.apache.dubbo.common.async.support.AsyncFor;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.rpc.Invoker;\n@@ -59,22 +58,7 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl\n     }\n     private RpcInvocation createInvocation(Method method, Object[] args) {\n-        RpcInvocation invocation;\n-        if (RpcUtils.hasGeneratedFuture(method)) {\n-            AsyncFor asyncFor = method.getAnnotation(AsyncFor.class);\n-            try {\n-                Class<?> clazz = method.getDeclaringClass();\n-                Method syncMethod = clazz.getMethod(asyncFor.value(), method.getParameterTypes());\n-                invocation = new RpcInvocation(syncMethod, args);\n-                invocation.setAttachment(Constants.FUTURE_GENERATED_KEY, \"true\");\n-                invocation.setAttachment(Constants.ASYNC_KEY, \"true\");\n-                return invocation;\n-            } catch (Exception e) {\n-                logger.warn(\"Annotated method \" + method.getName() + \" with AsyncFor, but cannot find the original sync method \" + asyncFor.value());\n-            }\n-        }\n-\n-        invocation = new RpcInvocation(method, args);\n+        RpcInvocation invocation = new RpcInvocation(method, args);\n         if (RpcUtils.hasFutureReturnType(method)) {\n             invocation.setAttachment(Constants.FUTURE_RETURNTYPE_KEY, \"true\");\n             invocation.setAttachment(Constants.ASYNC_KEY, \"true\");\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java\n@@ -18,7 +18,6 @@\n import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.async.support.AsyncFor;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.common.utils.ReflectUtils;\n@@ -183,14 +182,6 @@ public static boolean isAsync(URL url, Invocation inv) {\n         return isAsync;\n     }\n-    public static boolean isGeneratedFuture(Invocation inv) {\n-        return Boolean.TRUE.toString().equals(inv.getAttachment(Constants.FUTURE_GENERATED_KEY));\n-    }\n-\n-    public static boolean hasGeneratedFuture(Method method) {\n-        return method.isAnnotationPresent(AsyncFor.class) && hasFutureReturnType(method);\n-    }\n-\n     public static boolean isFutureReturnType(Invocation inv) {\n         return Boolean.TRUE.toString().equals(inv.getAttachment(Constants.FUTURE_RETURNTYPE_KEY));\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java\n@@ -81,7 +81,7 @@ protected Result doInvoke(final Invocation invocation) throws Throwable {\n         }\n         try {\n             boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);\n-            boolean isAsyncFuture =  RpcUtils.isGeneratedFuture(inv) || RpcUtils.isFutureReturnType(inv);\n+            boolean isAsyncFuture = RpcUtils.isFutureReturnType(inv);\n             boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);\n             int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n             if (isOneway) {",
    "output": "Remove @Async from core framework"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/async/support/AsyncFor.java b/dubbo-common/src/main/java/org/apache/dubbo/common/async/support/AsyncFor.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/async/support/AsyncFor.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/async/support/AsyncFor.java\n@@ -24,11 +24,11 @@\n /**\n  * TODO This definition should better be placed in module 'dubbo-config-api', but only can be done when \"rpc\" dependencies are removed from \"dubbo-config-api\"\n- * If an interface is annotated with AsyncFor, it will be treated as an async counterpart for the sync one.\n+ * If a method is annotated with AsyncFor, it will be treated as an async counterpart for the sync specified in value.\n  */\n @Documented\n @Retention(RetentionPolicy.RUNTIME)\n-@Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE})\n+@Target({ElementType.METHOD})\n public @interface AsyncFor {\n     /**",
    "output": "Change @AsyncFor annotation from TYPE to METHOD"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/support/AbstractMetadataReportTest.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/support/AbstractMetadataReportTest.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/support/AbstractMetadataReportTest.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/support/AbstractMetadataReportTest.java\n@@ -66,7 +66,7 @@ public void testStoreProviderUsual() throws ClassNotFoundException, InterruptedE\n         String group = null;\n         String application = \"vic\";\n         MetadataIdentifier providerMetadataIdentifier = storePrivider(abstractMetadataReport, interfaceName, version, group, application);\n-        Thread.sleep(1000);\n+        Thread.sleep(1500);\n         Assert.assertNotNull(abstractMetadataReport.store.get(providerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY)));\n     }\ndiff --git a/dubbo-metadata-report/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java b/dubbo-metadata-report/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-redis/src/test/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReportTest.java\n@@ -16,15 +16,14 @@\n  */\n package org.apache.dubbo.metadata.store.redis;\n+import com.google.gson.Gson;\n import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.utils.NetUtils;\n import org.apache.dubbo.metadata.definition.ServiceDefinitionBuilder;\n import org.apache.dubbo.metadata.definition.model.FullServiceDefinition;\n import org.apache.dubbo.metadata.identifier.MetadataIdentifier;\n import org.apache.dubbo.rpc.RpcException;\n-\n-import com.google.gson.Gson;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n@@ -81,9 +80,14 @@ private void testStoreProvider(RedisMetadataReport redisMetadataReport, String v\n         MetadataIdentifier providerMetadataIdentifier = storePrivider(redisMetadataReport, interfaceName, version, group, application);\n         Jedis jedis = null;\n         try {\n-            Thread.sleep(moreTime);\n             jedis = redisMetadataReport.pool.getResource();\n-            String value = jedis.get(providerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_SOTRE_TAG);\n+            String keyTmp = providerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_SOTRE_TAG;\n+            String value = jedis.get(keyTmp);\n+            if (value == null) {\n+                Thread.sleep(moreTime);\n+                value = jedis.get(keyTmp);\n+            }\n+\n             Assert.assertNotNull(value);\n             Gson gson = new Gson();\n@@ -101,12 +105,12 @@ private void testStoreProvider(RedisMetadataReport redisMetadataReport, String v\n     @Test\n     public void testAsyncStoreConsumer() throws ClassNotFoundException {\n-        testStoreProvider(redisMetadataReport, \"1.0.0.redis.md.c1\", 3000);\n+        testStoreConsumer(redisMetadataReport, \"1.0.0.redis.md.c1\", 3000);\n     }\n     @Test\n     public void testSyncStoreConsumer() throws ClassNotFoundException {\n-        testStoreProvider(syncRedisMetadataReport, \"1.0.0.redis.md.c2\", 3);\n+        testStoreConsumer(syncRedisMetadataReport, \"1.0.0.redis.md.c2\", 3);\n     }\n     private void testStoreConsumer(RedisMetadataReport redisMetadataReport, String version, long moreTime) throws ClassNotFoundException {\n@@ -116,9 +120,13 @@ private void testStoreConsumer(RedisMetadataReport redisMetadataReport, String v\n         MetadataIdentifier consumerMetadataIdentifier = storeConsumer(redisMetadataReport, interfaceName, version, group, application);\n         Jedis jedis = null;\n         try {\n-            Thread.sleep(moreTime);\n             jedis = redisMetadataReport.pool.getResource();\n-            String value = jedis.get(consumerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_SOTRE_TAG);\n+            String keyTmp = consumerMetadataIdentifier.getUniqueKey(MetadataIdentifier.KeyTypeEnum.UNIQUE_KEY) + META_DATA_SOTRE_TAG;\n+            String value = jedis.get(keyTmp);\n+            if (value == null) {\n+                Thread.sleep(moreTime);\n+                value = jedis.get(keyTmp);\n+            }\n             Assert.assertEquals(value, \"{\\\"paramConsumerTest\\\":\\\"redisCm\\\"}\");\n         } catch (Throwable e) {\n             throw new RpcException(\"Failed to put to redis . cause: \" + e.getMessage(), e);",
    "output": "Fix async store test fail issue"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/DubboRegistryTest.java b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/DubboRegistryTest.java\n--- a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/DubboRegistryTest.java\n+++ b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/DubboRegistryTest.java\n@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.registry.dubbo;\n+\n+import org.apache.dubbo.common.Constants;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.registry.NotifyListener;\n+import org.apache.dubbo.registry.RegistryService;\n+import org.apache.dubbo.registry.support.FailbackRegistry;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcInvocation;\n+import org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.BDDMockito.mock;\n+\n+public class DubboRegistryTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DubboRegistryTest.class);\n+\n+    private DubboRegistry dubboRegistry;\n+\n+    private URL registryURL;\n+\n+    private URL serviceURL;\n+\n+    private NotifyListener notifyListener;\n+\n+    private Invoker<RegistryService> invoker;\n+\n+    private RegistryService registryService;\n+\n+    @Before\n+    public void setUp() {\n+        registryURL = new URL(Constants.REGISTRY_PROTOCOL, NetUtils.getLocalHost(), NetUtils.getAvailablePort())\n+                .addParameter(Constants.CHECK_KEY, false)\n+                .setServiceInterface(RegistryService.class.getName());\n+        serviceURL = new URL(DubboProtocol.NAME, NetUtils.getLocalHost(), NetUtils.getAvailablePort())\n+                .addParameter(Constants.CHECK_KEY, false)\n+                .setServiceInterface(RegistryService.class.getName());\n+\n+        registryService = new MockDubboRegistry(registryURL);\n+\n+        invoker = mock(Invoker.class);\n+        given(invoker.getUrl()).willReturn(serviceURL);\n+        given(invoker.getInterface()).willReturn(RegistryService.class);\n+        given(invoker.invoke(new RpcInvocation())).willReturn(null);\n+\n+        dubboRegistry = new DubboRegistry(invoker, registryService);\n+        notifyListener = mock(NotifyListener.class);\n+    }\n+\n+    @Test\n+    public void testRegister() {\n+        dubboRegistry.register(serviceURL);\n+        assertEquals(1, getRegistereds());\n+    }\n+\n+    @Test\n+    public void testUnRegister() {\n+        assertEquals(0, getRegistereds());\n+        dubboRegistry.register(serviceURL);\n+        assertEquals(1, getRegistereds());\n+        dubboRegistry.unregister(serviceURL);\n+        assertEquals(0, getRegistereds());\n+    }\n+\n+    @Test\n+    public void testSubscribe() {\n+        dubboRegistry.register(serviceURL);\n+        assertEquals(1, getRegistereds());\n+        dubboRegistry.subscribe(serviceURL, notifyListener);\n+        assertEquals(1, getSubscribeds());\n+        assertEquals(1, getNotifiedListeners());\n+    }\n+\n+    @Test\n+    public void testUnsubscribe() {\n+        dubboRegistry.subscribe(serviceURL, notifyListener);\n+        assertEquals(1, getSubscribeds());\n+        assertEquals(1, getNotifiedListeners());\n+        dubboRegistry.unsubscribe(serviceURL, notifyListener);\n+        assertEquals(0, getNotifiedListeners());\n+    }\n+\n+    private class MockDubboRegistry extends FailbackRegistry {\n+\n+        private volatile boolean isAvaliable = false;\n+\n+        public MockDubboRegistry(URL url) {\n+            super(url);\n+        }\n+\n+        @Override\n+        public void doRegister(URL url) {\n+            logger.info(\"Begin to register: \" + url);\n+            isAvaliable = true;\n+        }\n+\n+        @Override\n+        public void doUnregister(URL url) {\n+            logger.info(\"Begin to ungister: \" + url);\n+            isAvaliable = false;\n+        }\n+\n+        @Override\n+        public void doSubscribe(URL url, NotifyListener listener) {\n+            logger.info(\"Begin to subscribe: \" + url);\n+        }\n+\n+        @Override\n+        public void doUnsubscribe(URL url, NotifyListener listener) {\n+            logger.info(\"Begin to unSubscribe: \" + url);\n+        }\n+\n+        @Override\n+        public boolean isAvailable() {\n+            return isAvaliable;\n+        }\n+    }\n+\n+    private int getNotifiedListeners() {\n+        return dubboRegistry.getSubscribed().get(serviceURL).size();\n+    }\n+\n+    private int getRegistereds() {\n+        return dubboRegistry.getRegistered().size();\n+    }\n+\n+    private int getSubscribeds() {\n+        return dubboRegistry.getSubscribed().size();\n+    }\n+}",
    "output": "Add unit test to dubbo-registry/dubbo-registry-api and dubbo-registry/dubbo-registry-default * add FailedRetryTaskTest.java"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n@@ -20,8 +20,8 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.Assert;\n import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.configcenter.ConfigChangeEvent;\n import org.apache.dubbo.configcenter.ConfigChangeType;\n import org.apache.dubbo.configcenter.ConfigurationListener;\n@@ -125,12 +125,14 @@ private void generateConditions(ConditionRouterRule rule, List<ConditionRouter>\n     }\n     private synchronized void init(String ruleKey) {\n-        Assert.notEmptyString(ruleKey, \"router rule's key cannot be null\");\n-        String router = ruleKey + Constants.ROUTERS_SUFFIX;\n-        configuration.addListener(router, this);\n-        String rule = configuration.getConfig(router);\n+        if (StringUtils.isEmpty(ruleKey)) {\n+            return;\n+        }\n+        String routerKey = ruleKey + Constants.ROUTERS_SUFFIX;\n+        configuration.addListener(routerKey, this);\n+        String rule = configuration.getConfig(routerKey);\n         if (rule != null) {\n-            this.process(new ConfigChangeEvent(router, rule));\n+            this.process(new ConfigChangeEvent(routerKey, rule));\n         }\n     }\n }",
    "output": "Remove assert check to continue with execute"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java\n@@ -160,7 +160,8 @@ private void initInvokers(URL url, boolean invoker1Status, boolean invoker2Statu\n     private void initDic(URL url) {\n         // FIXME: this exposes the design flaw in RouterChain\n-        dic = new StaticDirectory<>(url, invokers);\n+        URL dicInitUrl = URL.valueOf(\"consumer://localhost:20880/org.apache.dubbo.rpc.cluster.router.file.FileRouterEngineTest?application=FileRouterEngineTest\");\n+        dic = new StaticDirectory<>(dicInitUrl, invokers);\n         dic.buildRouterChain();\n         dic.getRouterChain().initWithRouters(Arrays.asList(routerFactory.getRouter(url)));\n     }\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n@@ -20,6 +20,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Result;\n@@ -61,7 +62,7 @@ public class AbstractClusterInvokerTest {\n     AbstractClusterInvoker<IHelloService> cluster_nocheck;\n     StaticDirectory<IHelloService> dic;\n     RpcInvocation invocation = new RpcInvocation();\n-    URL url = URL.valueOf(\"registry://localhost:9090/org.apache.dubbo.rpc.cluster.support.AbstractClusterInvokerTest.IHelloService\");\n+    URL url = URL.valueOf(\"registry://localhost:9090/org.apache.dubbo.rpc.cluster.support.AbstractClusterInvokerTest.IHelloService?refer=\" + URL.encode(\"application=abstractClusterInvokerTest\"));\n     Invoker<IHelloService> invoker1;\n     Invoker<IHelloService> invoker2;\n@@ -221,8 +222,9 @@ public void testSelect_multiInvokers() throws Exception {\n     @Test\n     public void testCloseAvailablecheck() {\n         LoadBalance lb = mock(LoadBalance.class);\n-        given(lb.select(invokers, url, invocation)).willReturn(invoker1);\n-\n+        Map<String, String> queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));\n+        URL tmpUrl = url.clearParameters().addParameters(queryMap).removeParameter(Constants.MONITOR_KEY);\n+        given(lb.select(invokers, tmpUrl, invocation)).willReturn(invoker1);\n         initlistsize5();\n         Invoker sinvoker = cluster_nocheck.select(lb, invocation, invokers, selectedInvokers);",
    "output": "Fix UT"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/AppRouterFactory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/AppRouterFactory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/AppRouterFactory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/AppRouterFactory.java\n@@ -29,7 +29,7 @@\n public class AppRouterFactory implements RouterFactory {\n     public static final String NAME = \"app\";\n-    private Router router;\n+    private volatile Router router;\n     @Override\n     public Router getRouter(URL url) {\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ListenableRouter.java\n@@ -124,14 +124,13 @@ private void generateConditions(ConditionRouterRule rule, List<ConditionRouter>\n         }\n     }\n-    private void init(String ruleKey) {\n-        Assert.notEmptyString(ruleKey, \"router rule's name cannot be null\");\n+    private synchronized void init(String ruleKey) {\n+        Assert.notEmptyString(ruleKey, \"router rule's key cannot be null\");\n         String router = ruleKey + Constants.ROUTERS_SUFFIX;\n+        configuration.addListener(router, this);\n         String rule = configuration.getConfig(router);\n         if (rule != null) {\n             this.process(new ConfigChangeEvent(router, rule));\n         }\n-\n-        configuration.addListener(router, this);\n     }\n }",
    "output": "Make ListenableRouter code thread safe"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/test/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfigurationTest.java b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/test/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfigurationTest.java\n--- a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/test/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfigurationTest.java\n+++ b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/test/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfigurationTest.java\n@@ -38,7 +38,7 @@\n import java.util.concurrent.CountDownLatch;\n /**\n- *\n+ * TODO refactor using mockito\n  */\n public class ZookeeperDynamicConfigurationTest {\n     private static CuratorFramework client;\n@@ -61,6 +61,7 @@ public static void setUp() throws Exception {\n             setData(\"/dubbo/config/group*service:version/configurators\", \"The content from configurators\");\n             setData(\"/dubbo/config/appname\", \"The content from higer level node\");\n             setData(\"/dubbo/config/appname/tagrouters\", \"The content from appname tagrouters\");\n+            setData(\"/dubbo/config/never.change.DemoService/configurators\", \"Never change value from configurators\");\n         } catch (Exception e) {\n             e.printStackTrace();\n         }\n@@ -85,7 +86,7 @@ private static void setData(String path, String data) throws Exception {\n     @Test\n     public void testGetConfig() throws Exception {\n-        Assert.assertEquals(\"The content from dubbo.properties\", configuration.getConfig(\"dubbo.dubbo.properties\"));\n+        Assert.assertEquals(\"Never change value from configurators\", configuration.getConfig(\"never.change.DemoService.configurators\"));\n         Assert.assertEquals(\"The content from dubbo.properties\", configuration.getConfig(\"dubbo.properties\", \"dubbo\"));\n     }",
    "output": "Fix UT"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n--- a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n+++ b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java\n@@ -100,9 +100,14 @@ protected void initWith(URL url) {\n     @Override\n     protected String getTargetConfig(String key, String group, long timeout) {\n+        // when group is not null, we are getting startup configs from Config Center\n+        // for example, group=dubbo, key=dubbo.properties\n         if (StringUtils.isNotEmpty(group)) {\n             key = group + \"/\" + key;\n-        } else {\n+        }\n+        // when group is null, we are fetching governance rules.\n+        // for example, key=org.apache.dubbo.DemoService.configurators\n+        else {\n             int i = key.lastIndexOf(\".\");\n             key = key.substring(0, i) + \"/\" + key.substring(i + 1);\n         }",
    "output": "Add comment"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouterTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouterTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouterTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouterTest.java\n@@ -206,9 +206,9 @@ public void testRoute_ReturnEmpty() {\n     public void testRoute_ReturnAll() {\n         Router router = new ConditionRouterFactory().getRouter(getRouteUrl(\"host = \" + NetUtils.getLocalHost() + \" => \" + \" host = \" + NetUtils.getLocalHost()));\n         List<Invoker<String>> invokers = new ArrayList<Invoker<String>>();\n-        invokers.add(new MockInvoker<String>());\n-        invokers.add(new MockInvoker<String>());\n-        invokers.add(new MockInvoker<String>());\n+        invokers.add(new MockInvoker<String>(URL.valueOf(\"dubbo://\" + NetUtils.getLocalHost() + \":20880/com.foo.BarService\")));\n+        invokers.add(new MockInvoker<String>(URL.valueOf(\"dubbo://\" + NetUtils.getLocalHost() + \":20880/com.foo.BarService\")));\n+        invokers.add(new MockInvoker<String>(URL.valueOf(\"dubbo://\" + NetUtils.getLocalHost() + \":20880/com.foo.BarService\")));\n         List<Invoker<String>> filteredInvokers = router.route(invokers, URL.valueOf(\"consumer://\" + NetUtils.getLocalHost() + \"/com.foo.BarService\"), new RpcInvocation());\n         Assert.assertEquals(invokers, filteredInvokers);\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -534,7 +534,7 @@ public void refresh() {\n                     try {\n                         String value = compositeConfiguration.getString(extractPropertyName(getClass(), method));\n                         // isTypeMatch() is called to avoid duplicate and incorrect update, for example, we have two 'setGeneric' methods in ReferenceConfig.\n-                        if (value != null && ClassHelper.isTypeMatch(method.getParameterTypes()[0], value)) {\n+                        if (StringUtils.isNotEmpty(value) && ClassHelper.isTypeMatch(method.getParameterTypes()[0], value)) {\n                             method.invoke(this, ClassHelper.convertPrimitive(method.getParameterTypes()[0], value));\n                         }\n                     } catch (NoSuchMethodException e) {",
    "output": "Remove package import used by comment to pass travis"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n@@ -49,7 +49,6 @@\n import java.lang.reflect.Modifier;\n import java.util.Date;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Set;\n import java.util.regex.Pattern;",
    "output": "Remove package import used by comment to pass travis"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ExceptionFilterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ExceptionFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ExceptionFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ExceptionFilterTest.java\n@@ -28,6 +28,7 @@\n import org.apache.dubbo.rpc.support.LocalException;\n import com.alibaba.com.caucho.hessian.HessianException;\n+\n import org.junit.Assert;\n import org.junit.Test;\n import org.mockito.Mockito;\n@@ -124,6 +125,8 @@ public void testConvertToRunTimeException() {\n         Result newResult = exceptionFilter.invoke(invoker, invocation);\n+        newResult = exceptionFilter.onResponse(newResult, invoker, invocation);\n+\n         Assert.assertFalse(newResult.getException() instanceof HessianException);\n         Assert.assertEquals(newResult.getException().getClass(), RuntimeException.class);",
    "output": "Fix ut"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -538,22 +538,22 @@ public void setPrefix(String prefix) {\n     public void refresh() {\n         try {\n             CompositeConfiguration compositeConfiguration = Environment.getInstance().getConfiguration(getPrefix(), getId());\n-            InmemoryConfiguration configuration = new InmemoryConfiguration(getPrefix(), getId());\n-            configuration.addProperties(getMetaData());\n+            InmemoryConfiguration config = new InmemoryConfiguration(getPrefix(), getId());\n+            config.addProperties(getMetaData());\n             if (Environment.getInstance().isConfigCenterFirst()) {\n                 // The sequence would be: SystemConfiguration -> ExternalConfiguration -> AppExternalConfiguration -> AbstractConfig -> PropertiesConfiguration\n-                compositeConfiguration.addConfiguration(3,configuration);\n+                compositeConfiguration.addConfiguration(3,config);\n             } else {\n                 // The sequence would be: SystemConfiguration -> AbstractConfig -> ExternalConfiguration -> AppExternalConfiguration -> PropertiesConfiguration\n-                compositeConfiguration.addConfiguration(1, configuration);\n+                compositeConfiguration.addConfiguration(1, config);\n             }\n             // loop methods, get override value and set the new value back to method\n             Method[] methods = getClass().getMethods();\n             for (Method method : methods) {\n                 if (ClassHelper.isSetter(method)) {\n                     try {\n-                        String value = configuration.getString(extractPropertyName(getClass(), method));\n+                        String value = compositeConfiguration.getString(extractPropertyName(getClass(), method));\n                         // isTypeMatch() is called to avoid duplicate and incorrect update, for example, we have two 'setGeneric' methods in ReferenceConfig.\n                         if (value != null && ClassHelper.isTypeMatch(method.getParameterTypes()[0], value)) {\n                             method.invoke(this, ClassHelper.convertPrimitive(method.getParameterTypes()[0], value));",
    "output": "Fix wrong reference"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n@@ -35,7 +35,6 @@ public class Environment {\n     private Map<String, EnvironmentConfiguration> environmentConfigs = new ConcurrentHashMap<>();\n     private Map<String, InmemoryConfiguration> externalConfigs = new ConcurrentHashMap<>();\n     private Map<String, InmemoryConfiguration> appExternalConfigs = new ConcurrentHashMap<>();\n-    private Map<String, InmemoryConfiguration> appConfigs = new ConcurrentHashMap<>();\n     private Map<String, String> externalConfigurationMap = new HashMap<>();\n     private Map<String, String> appExternalConfigurationMap = new HashMap<>();\n@@ -79,10 +78,6 @@ public EnvironmentConfiguration getEnvironmentConfig(String prefix, String id) {\n         return environmentConfigs.computeIfAbsent(toKey(prefix, id), k -> new EnvironmentConfiguration(prefix, id));\n     }\n-    public InmemoryConfiguration getAppConfig(String prefix, String id) {\n-        return appConfigs.get(toKey(prefix, id));\n-    }\n-\n     public void setExternalConfigMap(Map<String, String> externalConfiguration) {\n         this.externalConfigurationMap = externalConfiguration;\n     }\n@@ -99,14 +94,6 @@ public Map<String, String> getAppExternalConfigurationMap() {\n         return appExternalConfigurationMap;\n     }\n-    public void addAppConfig(String prefix, String id, Map<String, String> properties) {\n-        appConfigs.computeIfAbsent(toKey(prefix, id), k -> {\n-            InmemoryConfiguration configuration = new InmemoryConfiguration(prefix, id);\n-            configuration.addProperties(properties);\n-            return configuration;\n-        });\n-    }\n-\n     public void updateExternalConfigurationMap(Map<String, String> externalMap) {\n         this.externalConfigurationMap.putAll(externalMap);\n     }\n@@ -124,27 +111,13 @@ public void updateAppExternalConfigurationMap(Map<String, String> externalMap) {\n      * @param id\n      * @return\n      */\n-    public Configuration getConfiguration(String prefix, String id) {\n+    public CompositeConfiguration getConfiguration(String prefix, String id) {\n         CompositeConfiguration compositeConfiguration = new CompositeConfiguration();\n-        InmemoryConfiguration appConfig = this.getAppConfig(prefix, id);\n         // Config center has the highest priority\n-        if (!configCenterFirst) {\n-            compositeConfiguration.addConfiguration(this.getSystemConfig(prefix, id));\n-            if (appConfig != null) {\n-                compositeConfiguration.addConfiguration(appConfig);\n-            }\n-            compositeConfiguration.addConfiguration(this.getAppExternalConfig(prefix, id));\n-            compositeConfiguration.addConfiguration(this.getExternalConfig(prefix, id));\n-            compositeConfiguration.addConfiguration(this.getPropertiesConfig(prefix, id));\n-        } else {\n-            compositeConfiguration.addConfiguration(this.getSystemConfig(prefix, id));\n-            compositeConfiguration.addConfiguration(this.getAppExternalConfig(prefix, id));\n-            compositeConfiguration.addConfiguration(this.getExternalConfig(prefix, id));\n-            if (appConfig != null) {\n-                compositeConfiguration.addConfiguration(appConfig);\n-            }\n-            compositeConfiguration.addConfiguration(this.getPropertiesConfig(prefix, id));\n-        }\n+        compositeConfiguration.addConfiguration(this.getSystemConfig(prefix, id));\n+        compositeConfiguration.addConfiguration(this.getAppExternalConfig(prefix, id));\n+        compositeConfiguration.addConfiguration(this.getExternalConfig(prefix, id));\n+        compositeConfiguration.addConfiguration(this.getPropertiesConfig(prefix, id));\n         return compositeConfiguration;\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -18,8 +18,9 @@\n import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.config.Configuration;\n+import org.apache.dubbo.common.config.CompositeConfiguration;\n import org.apache.dubbo.common.config.Environment;\n+import org.apache.dubbo.common.config.InmemoryConfiguration;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n@@ -536,9 +537,16 @@ public void setPrefix(String prefix) {\n      */\n     public void refresh() {\n         try {\n-            Environment env = Environment.getInstance();\n-            env.addAppConfig(getPrefix(), getId(), getMetaData());\n-            Configuration configuration = env.getConfiguration(getPrefix(), getId());\n+            CompositeConfiguration compositeConfiguration = Environment.getInstance().getConfiguration(getPrefix(), getId());\n+            InmemoryConfiguration configuration = new InmemoryConfiguration(getPrefix(), getId());\n+            configuration.addProperties(getMetaData());\n+            if (Environment.getInstance().isConfigCenterFirst()) {\n+                // The sequence would be: SystemConfiguration -> ExternalConfiguration -> AppExternalConfiguration -> AbstractConfig -> PropertiesConfiguration\n+                compositeConfiguration.addConfiguration(3,configuration);\n+            } else {\n+                // The sequence would be: SystemConfiguration -> AbstractConfig -> ExternalConfiguration -> AppExternalConfiguration -> PropertiesConfiguration\n+                compositeConfiguration.addConfiguration(1, configuration);\n+            }\n             // loop methods, get override value and set the new value back to method\n             Method[] methods = getClass().getMethods();",
    "output": "Remove appConfigs cache to support one service/reference registered more than one time (if users don't explicitly add id, cache can not work properly)"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java\n@@ -196,7 +196,7 @@ public boolean isRuntime() {\n     @Override\n     public boolean isEnabled() {\n-        return url == null ? enabled : url.getParameter(Constants.ENABLED_KEY, false);\n+        return url == null ? enabled : url.getParameter(Constants.ENABLED_KEY, true);\n     }\n     @Override",
    "output": "Make condition router enabled by default"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParserTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParserTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParserTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParserTest.java\n@@ -107,17 +107,13 @@ public void parseConfiguratorsAppMultiServicesTest() {\n         String yamlFile = streamToString(yamlStream);\n         List<URL> urls = ConfigParser.parseConfigurators(yamlFile);\n         Assert.assertNotNull(urls);\n-        Assert.assertEquals(2, urls.size());\n+        Assert.assertEquals(4, urls.size());\n         URL url = urls.get(0);\n         Assert.assertEquals(\"127.0.0.1\", url.getAddress());\n         Assert.assertEquals(\"service1\", url.getServiceInterface());\n         Assert.assertEquals(6666, url.getParameter(Constants.TIMEOUT_KEY, 0));\n         Assert.assertEquals(\"random\", url.getParameter(Constants.LOADBALANCE_KEY));\n         Assert.assertEquals(url.getParameter(Constants.APPLICATION_KEY), \"demo-consumer\");\n-\n-        List<URL> urls2 = ConfigParser.parseConfigurators(yamlFile);\n-        Assert.assertNotNull(urls2);\n-        Assert.assertEquals(0, urls2.size());\n     }",
    "output": "Fix UT"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.rpc.cluster.directory;\n+import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;",
    "output": "Fix compile error"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java\n@@ -16,7 +16,6 @@\n  */\n package org.apache.dubbo.metadata.support;\n-import com.google.gson.Gson;\n import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n@@ -27,6 +26,8 @@\n import org.apache.dubbo.metadata.identifier.MetadataIdentifier;\n import org.apache.dubbo.metadata.store.MetadataReport;\n+import com.google.gson.Gson;\n+\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n@@ -98,7 +99,7 @@ public AbstractMetadataReport(URL reportServerURL) {\n                 reportServerURL.getParameter(Constants.RETRY_PERIOD_KEY, Constants.DEFAULT_METADATA_REPORT_RETRY_PERIOD));\n         // cycle report the data switch\n         if (reportServerURL.getParameter(Constants.CYCLE_REPORT_KEY, Constants.DEFAULT_METADATA_REPORT_CYCLE_REPORT)) {\n-            ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(0, new NamedThreadFactory(\"DubboMetadataReportTimer\", true));\n+            ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"DubboMetadataReportTimer\", true));\n             scheduler.scheduleAtFixedRate(new Runnable() {\n                 @Override\n                 public void run() {",
    "output": "Fix busy loop caused by singledThreadExecutor"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -364,14 +364,14 @@ private static String extractPropertyName(Class<?> clazz, Method setter) throws\n         Method getter = null;\n         try {\n             getter = clazz.getMethod(\"get\" + propertyName);\n-            propertyName = propertyName.substring(3, 4).toLowerCase() + propertyName.substring(4);\n         } catch (NoSuchMethodException e) {\n             getter = clazz.getMethod(\"is\" + propertyName);\n-            propertyName = propertyName.substring(2, 3).toLowerCase() + propertyName.substring(3);\n         }\n         Parameter parameter = getter.getAnnotation(Parameter.class);\n         if (parameter != null && StringUtils.isNotEmpty(parameter.key()) && parameter.useKeyAsProperty()) {\n             propertyName = parameter.key();\n+        } else {\n+            propertyName = propertyName.substring(0, 1).toLowerCase() + propertyName.substring(1);\n         }\n         return propertyName;\n     }",
    "output": "Fix NPE"
  },
  {
    "input": "diff --git a/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java b/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java\n--- a/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java\n+++ b/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.demo.DemoService;\n import org.apache.dubbo.rpc.RpcContext;\n+\n import org.springframework.context.support.ClassPathXmlApplicationContext;\n public class Consumer {\n@@ -31,6 +32,7 @@ public static void main(String[] args) {\n         ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{\"META-INF/spring/dubbo-demo-consumer.xml\"});\n         context.start();\n         DemoService demoService = (DemoService) context.getBean(\"demoService\"); // get remote service proxy\n+//        DemoService demoService1 = (DemoService) context.getBean(\"demoService1\"); // get remote service proxy\n         while (true) {\n             try {\n                 Thread.sleep(1000);",
    "output": "Upgrade demo"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java\n@@ -160,7 +160,7 @@ private void initInvokers(URL url, boolean invoker1Status, boolean invoker2Statu\n     private void initDic(URL url) {\n         dic = new StaticDirectory<>(url, invokers);\n-        dic.buildRouterChain(invokers);\n+        dic.buildRouterChain();\n         dic.getRouterChain().setResidentRouters(Arrays.asList(routerFactory.getRouter(url)));\n     }\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java\n@@ -455,7 +455,7 @@ private void initlistsize5() {\n     }\n     private void initDic() {\n-        dic.buildRouterChain(invokers);\n+        dic.buildRouterChain();\n     }\n     @Test()\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvokerTest.java\n@@ -652,7 +652,7 @@ private Invoker<IHelloService> getClusterInvokerMock(URL url, Invoker<IHelloServ\n         }\n         StaticDirectory<IHelloService> dic = new StaticDirectory<IHelloService>(durl, invokers, null);\n-        dic.buildRouterChain(invokers);\n+        dic.buildRouterChain();\n         AbstractClusterInvoker<IHelloService> cluster = new AbstractClusterInvoker(dic) {\n             @Override\n             protected Result doInvoke(Invocation invocation, List invokers, LoadBalance loadbalance)",
    "output": "Fix UT compile error"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/status/ThreadPoolStatusChecker.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/status/ThreadPoolStatusChecker.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/status/ThreadPoolStatusChecker.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/status/ThreadPoolStatusChecker.java\n@@ -44,7 +44,7 @@ public Status check() {\n             String port = entry.getKey();\n             ExecutorService executor = (ExecutorService) entry.getValue();\n-            if (executor != null && executor instanceof ThreadPoolExecutor) {\n+            if (executor instanceof ThreadPoolExecutor) {\n                 ThreadPoolExecutor tp = (ThreadPoolExecutor) executor;\n                 boolean ok = tp.getActiveCount() < tp.getMaximumPoolSize() - 1;\n                 Status.Level lvl = Status.Level.OK;",
    "output": "Remove null validation because a null check is not needed before using instanceof Removing null validation because a null check is not needed before using instanceof"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java\n@@ -85,9 +85,9 @@ public void destroy() {\n         invokers.clear();\n     }\n-    public void buildRouterChain(List<Invoker<T>> groupInvokers) {\n+    public void buildRouterChain() {\n         RouterChain<T> routerChain = RouterChain.buildChain(getUrl());\n-        routerChain.notifyFullInvokers(groupInvokers, getUrl());\n+        routerChain.notifyFullInvokers(invokers, getUrl());\n         this.setRouterChain(routerChain);\n     }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -280,7 +280,7 @@ private List<Invoker<T>> toMergeInvokerList(List<Invoker<T>> invokers) {\n         } else if (groupMap.size() > 1) {\n             for (List<Invoker<T>> groupList : groupMap.values()) {\n                 StaticDirectory<T> staticDirectory = new StaticDirectory<>(groupList);\n-                staticDirectory.buildRouterChain(invokers);\n+                staticDirectory.buildRouterChain();\n                 mergedInvokers.add(cluster.join(staticDirectory));\n             }\n         } else {",
    "output": "Fix wrong invokers reference to StaticDirectory under multi-group"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java\n@@ -151,6 +151,6 @@ public void notifyFullInvokers(List<Invoker<T>> invokers, URL url) {\n     }\n     public void setFullMethodInvokers(List<Invoker<T>> fullInvokers) {\n-        this.fullInvokers = fullInvokers;\n+        this.fullInvokers = (fullInvokers == null ? Collections.emptyList() : fullInvokers);\n     }\n }\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java\n@@ -24,6 +24,7 @@\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.cluster.RouterChain;\n+import java.util.Collections;\n import java.util.List;\n /**\n@@ -101,7 +102,7 @@ protected List<Invoker<T>> doList(Invocation invocation) throws RpcException {\n                 logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t);\n             }\n         }\n-        return finalInvokers;\n+        return finalInvokers == null ? Collections.emptyList() : finalInvokers;\n     }\n }\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mock/MockInvokersSelector.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mock/MockInvokersSelector.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mock/MockInvokersSelector.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mock/MockInvokersSelector.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.RpcException;\n@@ -39,6 +40,10 @@ public class MockInvokersSelector extends AbstractRouter {\n     @Override\n     public <T> List<Invoker<T>> route(final List<Invoker<T>> invokers,\n                                       URL url, final Invocation invocation) throws RpcException {\n+        if (CollectionUtils.isEmpty(invokers)) {\n+            return invokers;\n+        }\n+\n         if (invocation.getAttachments() == null) {\n             return getNormalInvokers(invokers);\n         } else {\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -112,7 +112,7 @@ public class RegistryDirectory<T> extends AbstractDirectory<T> implements Notify\n     private volatile Set<URL> cachedInvokerUrls; // The initial value is null and the midway may be assigned to null, please use the local variable reference\n     private static final ConsumerConfigurationListener consumerConfigurationListener = new ConsumerConfigurationListener();\n-    private ServiceConfigurationListener serviceConfigurationListener;\n+    private ReferenceConfigurationListener serviceConfigurationListener;\n     public RegistryDirectory(Class<T> serviceType, URL url) {\n@@ -156,7 +156,7 @@ public void setRegistry(Registry registry) {\n     public void subscribe(URL url) {\n         setConsumerUrl(url);\n         consumerConfigurationListener.addNotifyListener(this);\n-        serviceConfigurationListener = new ServiceConfigurationListener(url);\n+        serviceConfigurationListener = new ReferenceConfigurationListener(url);\n         registry.subscribe(url, this);\n     }\n@@ -222,8 +222,8 @@ private void refreshInvoker(List<URL> invokerUrls) {\n                 .getProtocol())) {\n             this.forbidden = true; // Forbid to access\n             this.invokers = null;\n-            destroyAllInvokers(); // Close all invokers\n             routerChain.notifyFullInvokers(this.invokers, getConsumerUrl());\n+            destroyAllInvokers(); // Close all invokers\n         } else {\n             this.forbidden = false; // Allow to access\n             Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap; // local reference\n@@ -744,10 +744,10 @@ public URL getProviderUrl() {\n         }\n     }\n-    private class ServiceConfigurationListener extends AbstractConfiguratorListener {\n+    private class ReferenceConfigurationListener extends AbstractConfiguratorListener {\n         private URL url;\n-        ServiceConfigurationListener(URL url) {\n+        ReferenceConfigurationListener(URL url) {\n             this.url = url;\n             this.init();\n         }",
    "output": "Add fault tolerant code to avoid NPE"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ActiveLimitFilterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ActiveLimitFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ActiveLimitFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/ActiveLimitFilterTest.java\n@@ -25,6 +25,7 @@\n import org.apache.dubbo.rpc.support.BlockMyInvoker;\n import org.apache.dubbo.rpc.support.MockInvocation;\n import org.apache.dubbo.rpc.support.MyInvoker;\n+import org.apache.dubbo.rpc.support.RuntimeExceptionInvoker;\n import org.junit.Test;\n@@ -181,4 +182,17 @@ public void run() {\n         }\n         assertEquals(0, count.intValue());\n     }\n+\n+    @Test(expected = RuntimeException.class)\n+    public void testInvokeRuntimeException() {\n+        URL url = URL.valueOf(\"test://test:11/test?accesslog=true&group=dubbo&version=1.1&actives=0\");\n+        Invoker<ActiveLimitFilterTest> invoker = new RuntimeExceptionInvoker(url);\n+        Invocation invocation = new MockInvocation();\n+        RpcStatus count = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());\n+        int beforeExceptionActiveCount = count.getActive();\n+        activeLimitFilter.invoke(invoker, invocation);\n+        int afterExceptionActiveCount = count.getActive();\n+        assertEquals(\"After exception active count should be same\"\n+                , beforeExceptionActiveCount, afterExceptionActiveCount);\n+    }\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericFilterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/filter/GenericFilterTest.java\n@@ -85,4 +85,52 @@ public void testInvokeWithJavaException() throws Exception {\n         genericFilter.invoke(invoker, invocation);\n     }\n+    @Test\n+    public void testInvokeWithMethodNamtNot$Invoke() {\n+\n+        Method genericInvoke = GenericService.class.getMethods()[0];\n+\n+        Map<String, Object> person = new HashMap<String, Object>();\n+        person.put(\"name\", \"dubbo\");\n+        person.put(\"age\", 10);\n+\n+        RpcInvocation invocation = new RpcInvocation(\"sayHi\", genericInvoke.getParameterTypes()\n+                , new Object[]{\"getPerson\", new String[]{Person.class.getCanonicalName()}, new Object[]{person}});\n+\n+        URL url = URL.valueOf(\"test://test:11/com.alibaba.dubbo.rpc.support.DemoService?\" +\n+                \"accesslog=true&group=dubbo&version=1.1\");\n+        Invoker invoker = Mockito.mock(Invoker.class);\n+        when(invoker.invoke(any(Invocation.class))).thenReturn(new RpcResult(new Person(\"person\", 10)));\n+        when(invoker.getUrl()).thenReturn(url);\n+        when(invoker.getInterface()).thenReturn(DemoService.class);\n+\n+        Result result = genericFilter.invoke(invoker, invocation);\n+        Assert.assertEquals(Person.class, result.getValue().getClass());\n+        Assert.assertEquals(10, ((Person) (result.getValue())).getAge());\n+    }\n+\n+    @Test\n+    public void testInvokeWithMethodArgumentSizeIsNot3() {\n+\n+        Method genericInvoke = GenericService.class.getMethods()[0];\n+\n+        Map<String, Object> person = new HashMap<String, Object>();\n+        person.put(\"name\", \"dubbo\");\n+        person.put(\"age\", 10);\n+\n+        RpcInvocation invocation = new RpcInvocation(Constants.$INVOKE, genericInvoke.getParameterTypes()\n+                , new Object[]{\"getPerson\", new String[]{Person.class.getCanonicalName()}});\n+\n+        URL url = URL.valueOf(\"test://test:11/com.alibaba.dubbo.rpc.support.DemoService?\" +\n+                \"accesslog=true&group=dubbo&version=1.1\");\n+        Invoker invoker = Mockito.mock(Invoker.class);\n+        when(invoker.invoke(any(Invocation.class))).thenReturn(new RpcResult(new Person(\"person\", 10)));\n+        when(invoker.getUrl()).thenReturn(url);\n+        when(invoker.getInterface()).thenReturn(DemoService.class);\n+\n+        Result result = genericFilter.invoke(invoker, invocation);\n+        Assert.assertEquals(Person.class, result.getValue().getClass());\n+        Assert.assertEquals(10, ((Person) (result.getValue())).getAge());\n+    }\n+\n }\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RuntimeExceptionInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RuntimeExceptionInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RuntimeExceptionInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RuntimeExceptionInvoker.java\n@@ -0,0 +1,34 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.dubbo.rpc.support;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Result;\n+import org.apache.dubbo.rpc.RpcException;\n+\n+public class RuntimeExceptionInvoker extends MyInvoker {\n+\n+    public RuntimeExceptionInvoker(URL url) {\n+        super(url);\n+    }\n+\n+    public Result invoke(Invocation invocation) throws RpcException {\n+        throw new RuntimeException(\"Runtime exception\");\n+    }\n+}",
    "output": "Add UT for dubbo-rpc-api module * Added UT for dubbo-rpc-api module * Added apache license for runtime exception invoker"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcResult.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcResult.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcResult.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcResult.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.dubbo.rpc;\n+import java.lang.reflect.Field;\n+\n /**\n  * RPC Result.\n  *\n@@ -39,6 +41,23 @@ public RpcResult(Throwable exception) {\n     @Override\n     public Object recreate() throws Throwable {\n         if (exception != null) {\n+            // fix issue#619\n+            try {\n+                // get Throwable class\n+                Class clazz = exception.getClass();\n+                while (!clazz.getName().equals(Throwable.class.getName())) {\n+                    clazz = clazz.getSuperclass();\n+                }\n+                // get stackTrace value\n+                Field stackTraceField = clazz.getDeclaredField(\"stackTrace\");\n+                stackTraceField.setAccessible(true);\n+                Object stackTrace = stackTraceField.get(exception);\n+                if (stackTrace == null) {\n+                    exception.setStackTrace(new StackTraceElement[0]);\n+                }\n+            } catch (Exception e) {\n+                // ignore\n+            }\n             throw exception;\n         }\n         return result;\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcResultTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcResultTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcResultTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/RpcResultTest.java\n@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc;\n+\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.fail;\n+\n+public class RpcResultTest {\n+    @Test\n+    public void testRecreateWithNormalException() {\n+        NullPointerException npe = new NullPointerException();\n+        RpcResult rpcResult = new RpcResult(npe);\n+        try {\n+            rpcResult.recreate();\n+            fail();\n+        } catch (Throwable throwable) {\n+            StackTraceElement[] stackTrace = throwable.getStackTrace();\n+            Assert.assertNotNull(stackTrace);\n+            Assert.assertTrue(stackTrace.length > 1);\n+        }\n+    }\n+\n+    /**\n+     * please run this test in Run mode\n+     */\n+    @Test\n+    public void testRecreateWithEmptyStackTraceException() {\n+        // begin to construct a NullPointerException with empty stackTrace\n+        Throwable throwable = null;\n+        Long begin = System.currentTimeMillis();\n+        while (System.currentTimeMillis() - begin < 60000) {\n+            try {\n+                ((Object) null).getClass();\n+            } catch (Exception e) {\n+                if (e.getStackTrace().length == 0) {\n+                    throwable = e;\n+                    break;\n+                }\n+            }\n+        }\n+        /**\n+         * may be there is -XX:-OmitStackTraceInFastThrow or run in Debug mode\n+         */\n+        if (throwable == null) {\n+            System.out.println(\"###testRecreateWithEmptyStackTraceException fail to construct NPE\");\n+            return;\n+        }\n+        // end construct a NullPointerException with empty stackTrace\n+\n+        RpcResult rpcResult = new RpcResult(throwable);\n+        try {\n+            rpcResult.recreate();\n+            fail();\n+        } catch (Throwable t) {\n+            StackTraceElement[] stackTrace = t.getStackTrace();\n+            Assert.assertNotNull(stackTrace);\n+            Assert.assertTrue(stackTrace.length == 0);\n+        }\n+    }\n+}",
    "output": "Fix consumer will generate wrong stackTrace * [Dubbo-619] Fix consumer will generate wrong stackTrace when provider throws exception with empty stackTrace * add license"
  },
  {
    "input": "diff --git a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/Router.java b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/Router.java\n--- a/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/Router.java\n+++ b/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/cluster/Router.java\n@@ -21,6 +21,7 @@\n import org.apache.dubbo.rpc.Invocation;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n import java.util.List;\n import java.util.stream.Collectors;\n@@ -36,15 +37,40 @@ <T> List<com.alibaba.dubbo.rpc.Invoker<T>> route(List<com.alibaba.dubbo.rpc.Invo\n                                                      com.alibaba.dubbo.rpc.Invocation invocation)\n             throws com.alibaba.dubbo.rpc.RpcException;\n+    int compareTo(com.alibaba.dubbo.rpc.cluster.Router o);\n+\n+    // Add since 2.7.0\n     @Override\n     default <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {\n-        List<com.alibaba.dubbo.rpc.Invoker<T>> invs = invokers.stream().map(invoker ->\n-                new com.alibaba.dubbo.rpc.Invoker.CompatibleInvoker<T>(invoker)).\n+        List<com.alibaba.dubbo.rpc.Invoker<T>> invs = invokers.stream().map(invoker -> new com.alibaba.dubbo.rpc.Invoker.CompatibleInvoker<T>(invoker)).\n                 collect(Collectors.toList());\n-        List<com.alibaba.dubbo.rpc.Invoker<T>> res = this.route(invs, new com.alibaba.dubbo.common.URL(url),\n-                new com.alibaba.dubbo.rpc.Invocation.CompatibleInvocation(invocation));\n+        List<com.alibaba.dubbo.rpc.Invoker<T>> res = this.route(invs, new com.alibaba.dubbo.common.URL(url), new com.alibaba.dubbo.rpc.Invocation.CompatibleInvocation(invocation));\n         return res.stream().map(inv -> inv.getOriginal()).collect(Collectors.toList());\n     }\n+\n+    @Override\n+    default void addRouterChain(RouterChain routerChain) {\n+    }\n+\n+    @Override\n+    default boolean isRuntime() {\n+        return true;\n+    }\n+\n+    @Override\n+    default boolean isForce() {\n+        return false;\n+    }\n+\n+    @Override\n+    default int getPriority() {\n+        return 1;\n+    }\n+\n+    @Override\n+    default int compareTo(org.apache.dubbo.rpc.cluster.Router o) {\n+        return compareTo((Router) o);\n+    }\n }\ndiff --git a/dubbo-compatible/src/test/java/org/apache/dubbo/rpc/cluster/CompatibleRouter.java b/dubbo-compatible/src/test/java/org/apache/dubbo/rpc/cluster/CompatibleRouter.java\n--- a/dubbo-compatible/src/test/java/org/apache/dubbo/rpc/cluster/CompatibleRouter.java\n+++ b/dubbo-compatible/src/test/java/org/apache/dubbo/rpc/cluster/CompatibleRouter.java\n@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster;\n+\n+import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.rpc.Invocation;\n+import com.alibaba.dubbo.rpc.Invoker;\n+import com.alibaba.dubbo.rpc.RpcException;\n+import com.alibaba.dubbo.rpc.cluster.Router;\n+\n+import java.util.List;\n+\n+/**\n+ *\n+ */\n+public class CompatibleRouter implements Router {\n+    @Override\n+    public URL getUrl() {\n+        return null;\n+    }\n+\n+    @Override\n+    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {\n+        return null;\n+    }\n+\n+    @Override\n+    public int compareTo(Router o) {\n+        return 0;\n+    }\n+}",
    "output": "Make sure compatible Router works fine"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java\n@@ -131,7 +131,7 @@ private static String exportOrunexportCallbackService(Channel channel, URL url,\n      * @param url\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private static Object referOrdestroyCallbackService(Channel channel, URL url, Class<?> clazz, Invocation inv, int instid, boolean isRefer) {\n+    private static Object referOrDestroyCallbackService(Channel channel, URL url, Class<?> clazz, Invocation inv, int instid, boolean isRefer) {\n         Object proxy = null;\n         String invokerCacheKey = getServerSideCallbackInvokerCacheKey(channel, clazz.getName(), instid);\n         String proxyCacheKey = getServerSideCallbackServiceCacheKey(channel, clazz.getName(), instid);\n@@ -150,7 +150,7 @@ private static Object referOrdestroyCallbackService(Channel channel, URL url, Cl\n                     increaseInstanceCount(channel, countkey);\n                     //convert error fail fast .\n-                    //ignore concurrent problem.\n+                    //ignore concurrent problem.\n                     Set<Invoker<?>> callbackInvokers = (Set<Invoker<?>>) channel.getAttribute(Constants.CHANNEL_CALLBACK_KEY);\n                     if (callbackInvokers == null) {\n                         callbackInvokers = new ConcurrentHashSet<Invoker<?>>(1);\n@@ -280,19 +280,19 @@ public static Object decodeInvocationArgument(Channel channel, RpcInvocation inv\n                 return inObject;\n             case CallbackServiceCodec.CALLBACK_CREATE:\n                 try {\n-                    return referOrdestroyCallbackService(channel, url, pts[paraIndex], inv, Integer.parseInt(inv.getAttachment(INV_ATT_CALLBACK_KEY + paraIndex)), true);\n+                    return referOrDestroyCallbackService(channel, url, pts[paraIndex], inv, Integer.parseInt(inv.getAttachment(INV_ATT_CALLBACK_KEY + paraIndex)), true);\n                 } catch (Exception e) {\n                     logger.error(e.getMessage(), e);\n                     throw new IOException(StringUtils.toString(e));\n                 }\n             case CallbackServiceCodec.CALLBACK_DESTROY:\n                 try {\n-                    return referOrdestroyCallbackService(channel, url, pts[paraIndex], inv, Integer.parseInt(inv.getAttachment(INV_ATT_CALLBACK_KEY + paraIndex)), false);\n+                    return referOrDestroyCallbackService(channel, url, pts[paraIndex], inv, Integer.parseInt(inv.getAttachment(INV_ATT_CALLBACK_KEY + paraIndex)), false);\n                 } catch (Exception e) {\n                     throw new IOException(StringUtils.toString(e));\n                 }\n             default:\n                 return inObject;\n         }\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Fix referOrDestroyCallbackService.referOrDestroyCallbackService to Camel-case fix issues #2973"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -439,7 +439,7 @@ private void resolveAsyncInterface(Class<?> interfaceClass, Map<String, String>\n         this.asyncInterfaceClass = interfaceClass;\n         this.interfaceClass = target;\n         setInterface(this.interfaceClass.getName());\n-        map.put(Constants.INTERFACES, interfaceClass.getName());\n+        map.put(Constants.INTERFACES, asyncInterfaceClass.getName());\n     }",
    "output": "Use asyncInterfaceClass"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/AbstractConfigConditionRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/AbstractConfigConditionRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/AbstractConfigConditionRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/AbstractConfigConditionRouter.java\n@@ -79,15 +79,15 @@ public synchronized void process(ConfigChangeEvent event) {\n     @Override\n     public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {\n-        if (CollectionUtils.isEmpty(invokers) || conditionRouters.size() == 0 || !isEnabled()) {\n+        if (CollectionUtils.isEmpty(invokers) || conditionRouters.size() == 0) {\n             return invokers;\n         }\n-        if (isRuleEnabled()) {\n-            for (Router router : conditionRouters) {\n-                invokers = router.route(invokers, url, invocation);\n-            }\n+        // We will check enabled status inside each router.\n+        for (Router router : conditionRouters) {\n+            invokers = router.route(invokers, url, invocation);\n         }\n+\n         return invokers;\n     }\n@@ -129,7 +129,7 @@ private void generateConditions(ConditionRouterRule rule, List<ConditionRouter>\n                 routers.add(subRouter);\n             });\n-            BlackWhiteListRule blackWhiteList = rule.getBlackWhiteListRule();\n+            BlackWhiteListRule blackWhiteList = rule.getBlackWhiteList();\n             if (blackWhiteList != null && blackWhiteList.isValid()) {\n                 blackWhiteList.getConditions().forEach(condition -> {\n                     // All sub rules have the same force, runtime value.\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRouterRule.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRouterRule.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRouterRule.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRouterRule.java\n@@ -27,7 +27,7 @@ public class ConditionRouterRule extends AbstractRouterRule {\n     public ConditionRouterRule() {\n     }\n-    private BlackWhiteListRule blackWhiteListRule;\n+    private BlackWhiteListRule blackWhiteList;\n     private List<String> conditions;\n     public List<String> getConditions() {\n@@ -38,11 +38,11 @@ public void setConditions(List<String> conditions) {\n         this.conditions = conditions;\n     }\n-    public BlackWhiteListRule getBlackWhiteListRule() {\n-        return blackWhiteListRule;\n+    public BlackWhiteListRule getBlackWhiteList() {\n+        return blackWhiteList;\n     }\n-    public void setBlackWhiteListRule(BlackWhiteListRule blackWhiteListRule) {\n-        this.blackWhiteListRule = blackWhiteListRule;\n+    public void setBlackWhiteList(BlackWhiteListRule blackWhiteList) {\n+        this.blackWhiteList = blackWhiteList;\n     }\n }\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRuleParser.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRuleParser.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRuleParser.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRuleParser.java\n@@ -47,7 +47,7 @@ public static ConditionRouterRule parse(String rawRule) {\n             rule.setValid(false);\n         }\n-        BlackWhiteListRule blackWhiteList = rule.getBlackWhiteListRule();\n+        BlackWhiteListRule blackWhiteList = rule.getBlackWhiteList();\n         if (blackWhiteList != null && CollectionUtils.isEmpty(blackWhiteList.getConditions())) {\n             blackWhiteList.setValid(false);\n         }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/AbstractConfiguratorListener.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/AbstractConfiguratorListener.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/AbstractConfiguratorListener.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/AbstractConfiguratorListener.java\n@@ -16,17 +16,26 @@\n  */\n package org.apache.dubbo.registry.integration;\n-import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n import org.apache.dubbo.configcenter.ConfigChangeEvent;\n import org.apache.dubbo.configcenter.ConfigChangeType;\n import org.apache.dubbo.configcenter.ConfigurationListener;\n import org.apache.dubbo.rpc.cluster.configurator.parser.ConfigParser;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.common.Constants.ANYHOST_VALUE;\n+import static org.apache.dubbo.common.Constants.APP_DYNAMIC_CONFIGURATORS_CATEGORY;\n+import static org.apache.dubbo.common.Constants.CATEGORY_KEY;\n+import static org.apache.dubbo.common.Constants.CONFIGURATORS_SUFFIX;\n+import static org.apache.dubbo.common.Constants.DYNAMIC_CONFIGURATORS_CATEGORY;\n+import static org.apache.dubbo.common.Constants.EMPTY_PROTOCOL;\n /**\n  *\n@@ -44,7 +53,13 @@ public void process(ConfigChangeEvent event) {\n         List<URL> urls;\n         if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n             urls = new ArrayList<>();\n-            urls.add(new URL(Constants.EMPTY_PROTOCOL, Constants.ANYHOST_VALUE, 0));\n+            Map<String, String> map = new HashMap<>(1);\n+            if (event.getKey().endsWith(ApplicationModel.getApplication() + CONFIGURATORS_SUFFIX)) {\n+                map.put(CATEGORY_KEY, APP_DYNAMIC_CONFIGURATORS_CATEGORY);\n+            } else {\n+                map.put(CATEGORY_KEY, DYNAMIC_CONFIGURATORS_CATEGORY);\n+            }\n+            urls.add(new URL(EMPTY_PROTOCOL, ANYHOST_VALUE, 0, map));\n         } else {\n             try {\n                 // parseConfigurators will recognize app/service config automatically.\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -135,8 +135,6 @@ public RegistryDirectory(Class<T> serviceType, URL url) {\n         this.multiGroup = group != null && (\"*\".equals(group) || group.contains(\",\"));\n         String methods = queryMap.get(Constants.METHODS_KEY);\n         this.serviceMethods = methods == null ? null : Constants.COMMA_SPLIT_PATTERN.split(methods);\n-\n-        consumerConfigurationListener.addNotifyListener(this);\n     }\n     /**\n@@ -828,7 +826,6 @@ synchronized void overrideUrl() {\n         @Override\n         protected void notifyOverrides(List<URL> urls) {\n-            urls.forEach(u -> u.addParameter(CATEGORY_KEY, DYNAMIC_CONFIGURATORS_CATEGORY));\n             RegistryDirectory.this.notify(urls);\n         }\n     }\n@@ -863,7 +860,6 @@ synchronized void overrideUrl() {\n         @Override\n         protected void notifyOverrides(List<URL> urls) {\n-            urls.forEach(u -> u.addParameter(CATEGORY_KEY, APP_DYNAMIC_CONFIGURATORS_CATEGORY));\n             listeners.forEach(listener -> listener.notify(urls));\n         }\n     }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -562,7 +562,6 @@ private <T> URL overrideUrl(URL providerUrl) {\n         @Override\n         protected void notifyOverrides(List<URL> urls) {\n-            urls.forEach(u -> u.addParameter(CATEGORY_KEY, DYNAMIC_CONFIGURATORS_CATEGORY));\n             notifyListener.notify(urls);\n         }\n     }\n@@ -598,7 +597,6 @@ private <T> URL overrideUrl(URL providerUrl) {\n         @Override\n         protected void notifyOverrides(List<URL> urls) {\n-            urls.forEach(u -> u.addParameter(CATEGORY_KEY, APP_DYNAMIC_CONFIGURATORS_CATEGORY));\n             overrideListeners.values().forEach(listener -> listener.notify(urls));\n         }\n     }",
    "output": "Fix problem of governance: configurator & router"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/PropertySourcesUtils.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/PropertySourcesUtils.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/PropertySourcesUtils.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/PropertySourcesUtils.java\n@@ -55,7 +55,7 @@ public static Map<String, String> getSubProperties(Iterable<PropertySource<?>> p\n                     if (name.startsWith(normalizedPrefix)) {\n                         String subName = name.substring(normalizedPrefix.length());\n                         String value = propertyResolver.getProperty(name);\n-                        subProperties.put(subName, value);\n+                        subProperties.putIfAbsent(subName, value);\n                     }\n                 }\n             }",
    "output": "Fix issue-2948:spring boot external config invalid"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n@@ -87,6 +87,10 @@ private static boolean isMatch(Class<?>[] types, List<Object> args) {\n                 if (!ReflectUtils.isPrimitive(type)) {\n                     return false;\n                 }\n+                Class<?> boxedType = ReflectUtils.getBoxedClass(type);\n+                if (boxedType != arg.getClass()) {\n+                    return false;\n+                }\n             } else if (arg instanceof Map) {\n                 String name = (String) ((Map<?, ?>) arg).get(\"class\");\n                 Class<?> cls = arg.getClass();",
    "output": "Fix the bug of isMatch method of InvokeTelnetHandler"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.rpc.protocol.dubbo.telnet;\n import org.apache.dubbo.common.extension.Activate;\n+import org.apache.dubbo.common.utils.CompatibleTypeUtils;\n import org.apache.dubbo.common.utils.PojoUtils;\n import org.apache.dubbo.common.utils.ReflectUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n@@ -75,6 +76,14 @@ private static boolean isMatch(Class<?>[] types, List<Object> args) {\n             }\n             if (ReflectUtils.isPrimitive(arg.getClass())) {\n+                if (arg instanceof String && type.isEnum()) {\n+                    try {\n+                        CompatibleTypeUtils.compatibleTypeConvert(arg, type);\n+                    } catch (RuntimeException e) {\n+                        return false;\n+                    }\n+                    continue;\n+                }\n                 if (!ReflectUtils.isPrimitive(type)) {\n                     return false;\n                 }\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoService.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoService.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoService.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoService.java\n@@ -47,7 +47,7 @@ public interface DemoService {\n     Type enumlength(Type... types);\n-//\tType enumlength(Type type);\n+\tType getType(Type type);\n     String get(CustomArgument arg1);\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoServiceImpl.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoServiceImpl.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoServiceImpl.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoServiceImpl.java\n@@ -71,8 +71,8 @@ public Type enumlength(Type... types) {\n             return Type.Lower;\n         return types[0];\n     }\n-\n-    public Type enumlength(Type type) {\n+\n+    public Type getType(Type type) {\n         return type;\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java\n@@ -108,6 +108,23 @@ public void testInvokeByPassingNullValue() throws RemotingException {\n         }\n     }\n+    @Test\n+    public void testInvokeByPassingEnumValue() throws RemotingException {\n+        mockInvoker = mock(Invoker.class);\n+        given(mockInvoker.getInterface()).willReturn(DemoService.class);\n+        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20886/demo\"));\n+        given(mockInvoker.invoke(any(Invocation.class))).willReturn(new RpcResult(\"ok\"));\n+        mockChannel = mock(Channel.class);\n+        given(mockChannel.getAttribute(\"telnet.service\")).willReturn(null);\n+        given(mockChannel.getLocalAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:5555\"));\n+        given(mockChannel.getRemoteAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:20886\"));\n+\n+        DubboProtocol.getDubboProtocol().export(mockInvoker);\n+        String result = invoke.telnet(mockChannel, \"getType(\\\"High\\\")\");\n+        assertTrue(result.contains(\"ok\"));\n+    }\n+\n+\n     @SuppressWarnings(\"unchecked\")\n     @Test\n     public void testInvokeAutoFindMethod() throws RemotingException {",
    "output": "Fix telnet can not find method with enum type"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fst/FstObjectOutputTest.java b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fst/FstObjectOutputTest.java\n--- a/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fst/FstObjectOutputTest.java\n+++ b/dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fst/FstObjectOutputTest.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.serialize.model.AnimalEnum;\n import org.apache.dubbo.common.serialize.model.person.FullAddress;\n+import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n@@ -41,6 +42,11 @@ public void setUp() {\n         this.fstObjectOutput = new FstObjectOutput(byteArrayOutputStream);\n     }\n+    @After\n+    public void tearDown() throws IOException {\n+        new FstObjectInput(new ByteArrayInputStream(new byte[]{0}));\n+    }\n+\n     @Test\n     public void testWriteBool() throws IOException {",
    "output": "Fix test-order dependency for FstObjectInputTest"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n@@ -121,18 +121,18 @@ protected Invoker<T> select(LoadBalance loadbalance, Invocation invocation,\n         boolean sticky = invokers.get(0).getUrl()\n             .getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY);\n-        {\n-            //ignore overloaded method\n-            if (stickyInvoker != null && !invokers.contains(stickyInvoker)) {\n-                stickyInvoker = null;\n-            }\n-            //ignore concurrency problem\n-            if (sticky && stickyInvoker != null && (selected == null || !selected.contains(stickyInvoker))) {\n-                if (availablecheck && stickyInvoker.isAvailable()) {\n-                    return stickyInvoker;\n-                }\n+\n+        //ignore overloaded method\n+        if (stickyInvoker != null && !invokers.contains(stickyInvoker)) {\n+            stickyInvoker = null;\n+        }\n+        //ignore concurrency problem\n+        if (sticky && stickyInvoker != null && (selected == null || !selected.contains(stickyInvoker))) {\n+            if (availablecheck && stickyInvoker.isAvailable()) {\n+                return stickyInvoker;\n             }\n         }\n+\n         Invoker<T> invoker = doSelect(loadbalance, invocation, invokers, selected);\n         if (sticky) {\n@@ -210,19 +210,18 @@ private Invoker<T> reselect(LoadBalance loadbalance, Invocation invocation,\n         }\n         // Just pick an available invoker using loadbalance policy\n-        {\n-            if (selected != null) {\n-                for (Invoker<T> invoker : selected) {\n-                    if ((invoker.isAvailable()) // available first\n-                            && !reselectInvokers.contains(invoker)) {\n-                        reselectInvokers.add(invoker);\n-                    }\n+        if (selected != null) {\n+            for (Invoker<T> invoker : selected) {\n+                if ((invoker.isAvailable()) // available first\n+                        && !reselectInvokers.contains(invoker)) {\n+                    reselectInvokers.add(invoker);\n                 }\n             }\n-            if (!reselectInvokers.isEmpty()) {\n-                return loadbalance.select(reselectInvokers, getUrl(), invocation);\n-            }\n         }\n+        if (!reselectInvokers.isEmpty()) {\n+            return loadbalance.select(reselectInvokers, getUrl(), invocation);\n+        }\n+\n         return null;\n     }\ndiff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectoryTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectoryTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectoryTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectoryTest.java\n@@ -54,12 +54,12 @@ public void testStaticDirectory() {\n         invokers.add(invoker2);\n         invokers.add(invoker3);\n         List<Invoker<String>> filteredInvokers = router.route(invokers, URL.valueOf(\"consumer://\" + NetUtils.getLocalHost() + \"/com.foo.BarService\"), new RpcInvocation());\n-        StaticDirectory staticDirectory = new StaticDirectory(filteredInvokers);\n-        Boolean isAvailable = staticDirectory.isAvailable();\n+        StaticDirectory<String> staticDirectory = new StaticDirectory<>(filteredInvokers);\n+        boolean isAvailable = staticDirectory.isAvailable();\n         Assert.assertTrue(!isAvailable);\n-        List<Invoker> newInvokers = staticDirectory.list(new MockDirInvocation());\n+        List<Invoker<String>> newInvokers = staticDirectory.list(new MockDirInvocation());\n         Assert.assertTrue(newInvokers.size() > 0);\n         staticDirectory.destroy();\n-        Assert.assertTrue(newInvokers.size() == 0);\n+        Assert.assertEquals(0, newInvokers.size());\n     }\n }",
    "output": "Improve UT grammar and remove unnecessary braces. * Improve UT grammer, fix compiler warnings. * Remove unnecessary braces"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -74,7 +74,7 @@ public abstract class AbstractConfig implements Serializable {\n         legacyProperties.put(\"dubbo.service.url\", \"dubbo.service.address\");\n         // this is only for compatibility\n-        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());\n+        DubboShutdownHook.getDubboShutdownHook().register();\n     }\n     protected String id;\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java\n@@ -40,14 +40,17 @@ public static DubboShutdownHook getDubboShutdownHook() {\n         return dubboShutdownHook;\n     }\n+    /**\n+     * Has it already been registered or not?\n+     */\n+    private final AtomicBoolean registered = new AtomicBoolean(false);\n     /**\n      * Has it already been destroyed or not?\n      */\n-    private final AtomicBoolean destroyed;\n+    private final AtomicBoolean destroyed= new AtomicBoolean(false);\n     private DubboShutdownHook(String name) {\n         super(name);\n-        this.destroyed = new AtomicBoolean(false);\n     }\n     @Override\n@@ -58,13 +61,33 @@ public void run() {\n         doDestroy();\n     }\n+    /**\n+     * Register the ShutdownHook\n+     */\n+    public void register() {\n+        if (!registered.get() && registered.compareAndSet(false, true)) {\n+            Runtime.getRuntime().addShutdownHook(getDubboShutdownHook());\n+        }\n+    }\n+\n+    /**\n+     * Unregister the ShutdownHook\n+     */\n+    public void unregister() {\n+        if (registered.get() && registered.compareAndSet(true, false)) {\n+            Runtime.getRuntime().removeShutdownHook(getDubboShutdownHook());\n+        }\n+    }\n+\n     /**\n      * Destroy all the resources, including registries and protocols.\n      */\n     public void doDestroy() {\n         if (!destroyed.compareAndSet(false, true)) {\n             return;\n         }\n+        // unregister the shutdownHook\n+        unregister();\n         // destroy all the registries\n         AbstractRegistryFactory.destroyAll();\n         // destroy all the protocols\n@@ -88,4 +111,5 @@ private void destroyProtocols() {\n         }\n     }\n+\n }\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/extension/SpringExtensionFactory.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/extension/SpringExtensionFactory.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/extension/SpringExtensionFactory.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/extension/SpringExtensionFactory.java\n@@ -44,7 +44,7 @@ public class SpringExtensionFactory implements ExtensionFactory {\n     public static void addApplicationContext(ApplicationContext context) {\n         contexts.add(context);\n-        Runtime.getRuntime().removeShutdownHook(DubboShutdownHook.getDubboShutdownHook());\n+        DubboShutdownHook.getDubboShutdownHook().unregister();\n         BeanFactoryUtils.addApplicationListener(context, shutdownHookListener);\n     }",
    "output": "Fix DubboShutdownHook Memory Leak"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -170,6 +170,7 @@ private static void putRandomPort(String protocol, Integer port) {\n         protocol = protocol.toLowerCase();\n         if (!RANDOM_PORT_MAP.containsKey(protocol)) {\n             RANDOM_PORT_MAP.put(protocol, port);\n+            logger.warn(\"Use random available port(\" + port + \") for protocol \" + protocol);\n         }\n     }\n@@ -654,7 +655,6 @@ private Integer findConfigedPorts(ProtocolConfig protocolConfig, String name, Ma\n                     portToBind = getAvailablePort(defaultPort);\n                     putRandomPort(name, portToBind);\n                 }\n-                logger.warn(\"Use random available port(\" + portToBind + \") for protocol \" + name);\n             }\n         }",
    "output": "Remove the log to putRandomPort when one protocol use random port * optimize findConfigedPorts method of ServiceConfig to log only one time when userandom port * move the log to method putRandomPort"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n@@ -665,6 +665,7 @@ public class Constants {\n     public static final String REQUEST_TAG_KEY = \"request.tag\";\n+    public static final String TELNET = \"telnet\";\n     /*\n      * private Constants(){ }\n      */\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/TelnetHandlerAdapter.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/TelnetHandlerAdapter.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/TelnetHandlerAdapter.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/TelnetHandlerAdapter.java\n@@ -17,7 +17,9 @@\n package org.apache.dubbo.remoting.telnet.support;\n import org.apache.dubbo.common.Constants;\n+import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.remoting.Channel;\n import org.apache.dubbo.remoting.RemotingException;\n import org.apache.dubbo.remoting.telnet.TelnetHandler;\n@@ -49,14 +51,20 @@ public String telnet(Channel channel, String message) throws RemotingException {\n         }\n         if (command.length() > 0) {\n             if (extensionLoader.hasExtension(command)) {\n-                try {\n-                    String result = extensionLoader.getExtension(command).telnet(channel, message);\n-                    if (result == null) {\n-                        return null;\n+                if (commandEnabled(channel.getUrl(), command)) {\n+                    try {\n+                        String result = extensionLoader.getExtension(command).telnet(channel, message);\n+                        if (result == null) {\n+                            return null;\n+                        }\n+                        buf.append(result);\n+                    } catch (Throwable t) {\n+                        buf.append(t.getMessage());\n                     }\n-                    buf.append(result);\n-                } catch (Throwable t) {\n-                    buf.append(t.getMessage());\n+                } else {\n+                    buf.append(\"Command: \");\n+                    buf.append(command);\n+                    buf.append(\" disabled\");\n                 }\n             } else {\n                 buf.append(\"Unsupported command: \");\n@@ -72,4 +80,21 @@ public String telnet(Channel channel, String message) throws RemotingException {\n         return buf.toString();\n     }\n+    private boolean commandEnabled(URL url, String command) {\n+        boolean commandEnable = false;\n+        String supportCommands = url.getParameter(Constants.TELNET);\n+        if (StringUtils.isEmpty(supportCommands)) {\n+            commandEnable = true;\n+        } else {\n+            String[] commands = Constants.COMMA_SPLIT_PATTERN.split(supportCommands);\n+            for (String c : commands) {\n+                if (command.equals(c)) {\n+                    commandEnable = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return commandEnable;\n+    }\n+\n }",
    "output": "Make telnet config work again"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/concurrent/CompletableFutureTaskTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/concurrent/CompletableFutureTaskTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/concurrent/CompletableFutureTaskTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/concurrent/CompletableFutureTaskTest.java\n@@ -20,6 +20,8 @@\n import static org.junit.Assert.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.times;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CountDownLatch;\n@@ -94,6 +96,7 @@ public void testCustomExecutor() {\n         CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> {\n             return 0;\n         });\n-        completableFuture.thenRunAsync(mock(Runnable.class), verify(mockedExecutor));\n+        completableFuture.thenRunAsync(mock(Runnable.class), mockedExecutor);\n+        verify(mockedExecutor, times(1)).execute(any());\n     }\n }\n\\ No newline at end of file",
    "output": "Fix testCustomExecutor"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/integration/MetadataReportServiceTest.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/integration/MetadataReportServiceTest.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/integration/MetadataReportServiceTest.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/integration/MetadataReportServiceTest.java\n@@ -78,7 +78,7 @@ public void testPublishProviderContainInterface() throws InterruptedException {\n         URL publishUrl = URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":4444/org.apache.dubbo.TestService?version=1.0.3&application=vicpubp&interface=org.apache.dubbo.metadata.integration.InterfaceNameTestService\");\n         metadataReportService1.publishProvider(publishUrl);\n-        Thread.sleep(100);\n+        Thread.sleep(300);\n         Assert.assertTrue(metadataReportService1.metadataReport instanceof JTestMetadataReport4Test);\n@@ -98,7 +98,7 @@ public void testPublishConsumer() throws InterruptedException {\n         URL publishUrl = URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":4444/org.apache.dubbo.TestService?version=1.0.x&application=vicpubconsumer&side=consumer\");\n         metadataReportService1.publishConsumer(publishUrl);\n-        Thread.sleep(100);\n+        Thread.sleep(300);\n         Assert.assertTrue(metadataReportService1.metadataReport instanceof JTestMetadataReport4Test);",
    "output": "Fix unit test"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/CollectionTypeBuilder.java b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/CollectionTypeBuilder.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/CollectionTypeBuilder.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/CollectionTypeBuilder.java\n@@ -47,7 +47,6 @@ public boolean accept(Type type, Class<?> clazz) {\n     @Override\n     public TypeDefinition build(Type type, Class<?> clazz, Map<Class<?>, TypeDefinition> typeCache) {\n         if (!(type instanceof ParameterizedType)) {\n-            // class name\n             return new TypeDefinition(clazz.getName());\n         }\ndiff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/main/java/org/apache/dubbo/metadata/definition/builder/MapTypeBuilder.java\n@@ -45,7 +45,6 @@ public boolean accept(Type type, Class<?> clazz) {\n     @Override\n     public TypeDefinition build(Type type, Class<?> clazz, Map<Class<?>, TypeDefinition> typeCache) {\n         if (!(type instanceof ParameterizedType)) {\n-            // class name\n             return new TypeDefinition(clazz.getName());\n         }",
    "output": "Remove chinese comments"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java\n@@ -42,7 +42,7 @@\n  * ConditionRouter\n  *\n  */\n-public class ConditionRouter implements Router, Comparable<Router> {\n+public class ConditionRouter implements Router {\n     private static final Logger logger = LoggerFactory.getLogger(ConditionRouter.class);\n     private static Pattern ROUTE_PATTERN = Pattern.compile(\"([&!=,]*)\\\\s*([^&!=,\\\\s]+)\");\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n@@ -33,7 +33,7 @@\n /**\n  * TagRouter\n  */\n-public class TagRouter implements Router, Comparable<Router> {\n+public class TagRouter implements Router {\n     private static final Logger logger = LoggerFactory.getLogger(TagRouter.class);",
    "output": "Remove the duplicate superclass of TagRouter and ConditionRouter Remove the class ConditionRouter and TagRouter implement duplicate superclass Comparable"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/script/ScriptRouterTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/script/ScriptRouterTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/script/ScriptRouterTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/script/ScriptRouterTest.java\n@@ -17,22 +17,20 @@\n package org.apache.dubbo.rpc.cluster.router.script;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.RpcInvocation;\n import org.apache.dubbo.rpc.cluster.Router;\n import org.apache.dubbo.rpc.cluster.router.MockInvoker;\n-\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.BeforeClass;\n import org.junit.Test;\n-import javax.script.ScriptException;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n public class ScriptRouterTest {\n     private URL SCRIPT_URL = URL.valueOf(\"script://javascript?type=javascript\");\n@@ -85,5 +83,48 @@ public void testRoutePickInvokers() {\n         Assert.assertEquals(invoker3, filteredInvokers.get(1));\n     }\n-    //TODO Add tests for abnormal scene\n+    @Test\n+    public void testRouteHostFilter() {\n+    \tList<Invoker<String>> invokers = new ArrayList<Invoker<String>>();\n+    \tMockInvoker<String> invoker1 = new MockInvoker<String>(URL.valueOf(\"dubbo://10.134.108.1:20880/com.dubbo.HelloService\"));\n+    \tMockInvoker<String> invoker2 = new MockInvoker<String>(URL.valueOf(\"dubbo://10.134.108.2:20880/com.dubbo.HelloService\"));\n+    \tMockInvoker<String> invoker3 = new MockInvoker<String>(URL.valueOf(\"dubbo://10.134.108.3:20880/com.dubbo.HelloService\"));\n+        invokers.add(invoker1);\n+        invokers.add(invoker2);\n+        invokers.add(invoker3);\n+\n+        String script = \"function route(invokers, invocation, context){ \" +\n+        \t\t\"\tvar result = new java.util.ArrayList(invokers.size()); \" +\n+        \t\t\"\tvar targetHost = new java.util.ArrayList(); \" +\n+        \t\t\"\ttargetHost.add(\\\"10.134.108.2\\\"); \" +\n+        \t\t\"\tfor (var i = 0; i < invokers.length; i++) { \" +\n+        \t\t\"\t\tif(targetHost.contains(invokers[i].getUrl().getHost())){ \" +\n+        \t\t\"\t\t\tresult.add(invokers[i]); \" +\n+        \t\t\"\t\t} \" +\n+        \t\t\"\t} \" +\n+        \t\t\"\treturn result; \" +\n+        \t\t\"} \" +\n+        \t\t\"route(invokers, invocation, context) \";\n+\n+        Router router = new ScriptRouterFactory().getRouter(getRouteUrl(script));\n+        List<Invoker<String>> routeResult = router.route(invokers, invokers.get(0).getUrl(), new RpcInvocation());\n+        Assert.assertEquals(1, routeResult.size());\n+        Assert.assertEquals(invoker2,routeResult.get(0));\n+    }\n+\n+    @Test\n+    public void testRoute_throwException() {\n+    \tList<Invoker<String>> invokers = new ArrayList<Invoker<String>>();\n+    \tMockInvoker<String> invoker1 = new MockInvoker<String>(URL.valueOf(\"dubbo://10.134.108.1:20880/com.dubbo.HelloService\"));\n+    \tMockInvoker<String> invoker2 = new MockInvoker<String>(URL.valueOf(\"dubbo://10.134.108.2:20880/com.dubbo.HelloService\"));\n+    \tMockInvoker<String> invoker3 = new MockInvoker<String>(URL.valueOf(\"dubbo://10.134.108.3:20880/com.dubbo.HelloService\"));\n+        invokers.add(invoker1);\n+        invokers.add(invoker2);\n+        invokers.add(invoker3);\n+\n+        String script = \"/\";\n+        Router router = new ScriptRouterFactory().getRouter(getRouteUrl(script));\n+        List<Invoker<String>> routeResult = router.route(invokers, invokers.get(0).getUrl(), new RpcInvocation());\n+        Assert.assertEquals(3, routeResult.size());\n+    }\n }\n\\ No newline at end of file",
    "output": "Add some ScriptRoute test case * add router test case * correct an error word"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -48,7 +48,6 @@\n import java.util.Comparator;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -594,12 +593,6 @@ public List<Invoker<T>> doList(Invocation invocation) {\n             if (invokers == null) {\n                 invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);\n             }\n-            if (invokers == null) {\n-                Iterator<List<Invoker<T>>> iterator = localMethodInvokerMap.values().iterator();\n-                if (iterator.hasNext()) {\n-                    invokers = iterator.next();\n-                }\n-            }\n         }\n         return invokers == null ? new ArrayList<Invoker<T>>(0) : invokers;\n     }",
    "output": "Remove unnessesary code in RegistryDirectory#doList * remove unnessesary code * remove unused import"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java\n@@ -53,27 +53,27 @@ public FailoverClusterInvoker(Directory<T> directory) {\n     @Override\n     @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n     public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n-        List<Invoker<T>> copyinvokers = invokers;\n-        checkInvokers(copyinvokers, invocation);\n+        List<Invoker<T>> copyInvokers = invokers;\n+        checkInvokers(copyInvokers, invocation);\n         String methodName = RpcUtils.getMethodName(invocation);\n         int len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;\n         if (len <= 0) {\n             len = 1;\n         }\n         // retry loop.\n         RpcException le = null; // last exception.\n-        List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyinvokers.size()); // invoked invokers.\n+        List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyInvokers.size()); // invoked invokers.\n         Set<String> providers = new HashSet<String>(len);\n         for (int i = 0; i < len; i++) {\n             //Reselect before retry to avoid a change of candidate `invokers`.\n             //NOTE: if `invokers` changed, then `invoked` also lose accuracy.\n             if (i > 0) {\n                 checkWhetherDestroyed();\n-                copyinvokers = list(invocation);\n+                copyInvokers = list(invocation);\n                 // check again\n-                checkInvokers(copyinvokers, invocation);\n+                checkInvokers(copyInvokers, invocation);\n             }\n-            Invoker<T> invoker = select(loadbalance, invocation, copyinvokers, invoked);\n+            Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);\n             invoked.add(invoker);\n             RpcContext.getContext().setInvokers((List) invoked);\n             try {\n@@ -83,7 +83,7 @@ public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, L\n                             + \" in the service \" + getInterface().getName()\n                             + \" was successful by the provider \" + invoker.getUrl().getAddress()\n                             + \", but there have been failed providers \" + providers\n-                            + \" (\" + providers.size() + \"/\" + copyinvokers.size()\n+                            + \" (\" + providers.size() + \"/\" + copyInvokers.size()\n                             + \") from the registry \" + directory.getUrl().getAddress()\n                             + \" on the consumer \" + NetUtils.getLocalHost()\n                             + \" using the dubbo version \" + Version.getVersion() + \". Last error is: \"\n@@ -104,7 +104,7 @@ public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, L\n         throw new RpcException(le.getCode(), \"Failed to invoke the method \"\n                 + methodName + \" in the service \" + getInterface().getName()\n                 + \". Tried \" + len + \" times of the providers \" + providers\n-                + \" (\" + providers.size() + \"/\" + copyinvokers.size()\n+                + \" (\" + providers.size() + \"/\" + copyInvokers.size()\n                 + \") from the registry \" + directory.getUrl().getAddress()\n                 + \" on the consumer \" + NetUtils.getLocalHost() + \" using the dubbo version \"\n                 + Version.getVersion() + \". Last error is: \"",
    "output": "Fix typo of variable fixed type of variable"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ConfigConditionRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ConfigConditionRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ConfigConditionRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/ConfigConditionRouter.java\n@@ -76,6 +76,10 @@ public ConfigConditionRouter(DynamicConfiguration configuration, URL url) {\n     @Override\n     public synchronized void process(ConfigChangeEvent event) {\n+        if (logger.isInfoEnabled()) {\n+            logger.info(\"Notification of tag rule, change type is: \" + event.getChangeType() + \", raw rule is:\\n \" + event.getNewValue());\n+        }\n+\n         if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n             // Now, we can only recognize if it's a app level or service level change by try to match event key.\n             if (event.getKey().endsWith(this.url.getParameter(Constants.APPLICATION_KEY) + Constants.ROUTERS_SUFFIX)) {\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n@@ -100,6 +100,10 @@ private void init() {\n     @Override\n     public synchronized void process(ConfigChangeEvent event) {\n+        if (logger.isInfoEnabled()) {\n+            logger.info(\"Notification of tag rule, change type is: \" + event.getChangeType() + \", raw rule is:\\n \" + event.getNewValue());\n+        }\n+\n         try {\n             if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n                 this.tagRouterRule = null;\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java\n@@ -711,7 +711,9 @@ public Class<T> getInterface() {\n     @Override\n     public synchronized void process(ConfigChangeEvent event) {\n-        logger.info(\"Notification of overriding rule, change type is: \" + event.getChangeType() + \", raw config content is:\\n \" + event.getNewValue());\n+        if (logger.isInfoEnabled()) {\n+            logger.info(\"Notification of overriding rule, change type is: \" + event.getChangeType() + \", raw config content is:\\n \" + event.getNewValue());\n+        }\n         List<URL> urls = new ArrayList<>();\n         if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n@@ -730,7 +732,9 @@ public synchronized void process(ConfigChangeEvent event) {\n             }\n         }\n-        logger.debug(\"\");\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Successfully transformed override rule to urls, will do override now, the urls are: \" + urls);\n+        }\n         notify(urls);\n     }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -567,6 +567,10 @@ private List<URL> getMatchedUrls(List<URL> configuratorUrls, URL currentSubscrib\n         @Override\n         public synchronized void process(ConfigChangeEvent event) {\n+            if (logger.isInfoEnabled()) {\n+                logger.info(\"Notification of overriding rule, change type is: \" + event.getChangeType() + \", raw config content is:\\n \" + event.getNewValue());\n+            }\n+\n             List<URL> urls;\n             if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n                 URL originUrl = RegistryProtocol.this.getProviderUrl(originInvoker);\n@@ -588,6 +592,9 @@ public synchronized void process(ConfigChangeEvent event) {\n                     return;\n                 }\n             }\n+\n+            logger.debug(\"Successfully transformed override rule to urls, will do override now, the urls are: \" + urls);\n+\n             notify(urls);\n         }\n     }",
    "output": "Add log for rule notification"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n@@ -718,9 +718,9 @@ public class Constants {\n     public static final String MULTICAST = \"multicast\";\n-    public static final String TAG_KEY = \"tag\";\n+    public static final String TAG_KEY = \"dubbo.tag\";\n-    public static final String FORCE_USE_TAG = \"force.tag\";\n+    public static final String FORCE_USE_TAG = \"dubbo.force.tag\";\n     public static final String HOST_KEY = \"host\";\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java\n@@ -240,6 +240,7 @@ public void setSerialization(String serialization) {\n         this.serialization = serialization;\n     }\n+    @Parameter(key = \"dubbo.tag\", useKeyAsProperty = false)\n     public String getTag() {\n         return tag;\n     }",
    "output": "Add `dubbo.` prefix for tag router key"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/MetadataTest.java b/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/MetadataTest.java\n--- a/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/MetadataTest.java\n+++ b/dubbo-metadata-report/dubbo-metadata-definition/src/test/java/org/apache/dubbo/metadata/definition/MetadataTest.java\n@@ -45,7 +45,7 @@ public void testInnerClassType() {\n         TypeDefinition td = builder.build(OuterClass.InnerClass.class, OuterClass.InnerClass.class);\n         System.out.println(\">> testInnerClassType: \" + new Gson().toJson(td));\n-        TestCase.assertEquals(\"com.taobao.jaket.common.OuterClass$InnerClass\", td.getType());\n+        TestCase.assertEquals(\"org.apache.dubbo.metadata.definition.common.OuterClass$InnerClass\", td.getType());\n         TestCase.assertEquals(1, td.getProperties().size());\n         TestCase.assertNotNull(td.getProperties().get(\"name\"));\n@@ -57,7 +57,7 @@ public void testInnerClassType() {\n         TestCase.assertEquals(TestService.class.getMethods().length, sd.getMethods().size());\n         boolean containsType = false;\n         for (TypeDefinition type : sd.getTypes()) {\n-            if (type.getType().equals(\"com.taobao.jaket.common.OuterClass$InnerClass\")) {\n+            if (type.getType().equals(\"org.apache.dubbo.metadata.definition.common.OuterClass$InnerClass\")) {\n                 containsType = true;\n                 break;\n             }\n@@ -75,7 +75,7 @@ public void testRawMap() {\n         TypeDefinition td = builder.build(ResultWithRawCollections.class, ResultWithRawCollections.class);\n         System.out.println(\">> testRawMap: \" + new Gson().toJson(td));\n-        TestCase.assertEquals(\"com.taobao.jaket.common.ResultWithRawCollections\", td.getType());\n+        TestCase.assertEquals(\"org.apache.dubbo.metadata.definition.common.ResultWithRawCollections\", td.getType());\n         TestCase.assertEquals(2, td.getProperties().size());\n         TestCase.assertEquals(\"java.util.Map\", td.getProperties().get(\"map\").getType());\n         TestCase.assertEquals(\"java.util.List\", td.getProperties().get(\"list\").getType());\n@@ -88,7 +88,7 @@ public void testRawMap() {\n         TestCase.assertEquals(TestService.class.getMethods().length, sd.getMethods().size());\n         boolean containsType = false;\n         for (TypeDefinition type : sd.getTypes()) {\n-            if (type.getType().equals(\"com.taobao.jaket.common.ResultWithRawCollections\")) {\n+            if (type.getType().equals(\"org.apache.dubbo.metadata.definition.common.ResultWithRawCollections\")) {\n                 containsType = true;\n                 break;\n             }\n@@ -103,7 +103,7 @@ public void testEnum() {\n         TypeDefinition td = builder.build(ColorEnum.class, ColorEnum.class);\n         System.out.println(\">> testEnum: \" + new Gson().toJson(td));\n-        TestCase.assertEquals(\"com.taobao.jaket.common.ColorEnum\", td.getType());\n+        TestCase.assertEquals(\"org.apache.dubbo.metadata.definition.common.ColorEnum\", td.getType());\n         TestCase.assertEquals(3, td.getEnums().size());\n         TestCase.assertTrue(td.getEnums().contains(\"RED\"));\n         TestCase.assertTrue(td.getEnums().contains(\"YELLOW\"));\n@@ -117,7 +117,7 @@ public void testEnum() {\n         TestCase.assertEquals(TestService.class.getMethods().length, sd.getMethods().size());\n         boolean containsType = false;\n         for (TypeDefinition type : sd.getTypes()) {\n-            if (type.getType().equals(\"com.taobao.jaket.common.ColorEnum\")) {\n+            if (type.getType().equals(\"org.apache.dubbo.metadata.definition.common.ColorEnum\")) {\n                 containsType = true;\n                 break;\n             }\n@@ -132,7 +132,7 @@ public void testExtendsMap() {\n         TypeDefinition td = builder.build(ClassExtendsMap.class, ClassExtendsMap.class);\n         System.out.println(\">> testExtendsMap: \" + new Gson().toJson(td));\n-        TestCase.assertEquals(\"com.taobao.jaket.common.ClassExtendsMap\", td.getType());\n+        TestCase.assertEquals(\"org.apache.dubbo.metadata.definition.common.ClassExtendsMap\", td.getType());\n         TestCase.assertEquals(0, td.getProperties().size());\n         //  MetadataUtils  ServiceDefinition\n@@ -143,7 +143,7 @@ public void testExtendsMap() {\n         TestCase.assertEquals(TestService.class.getMethods().length, sd.getMethods().size());\n         boolean containsType = false;\n         for (TypeDefinition type : sd.getTypes()) {\n-            if (type.getType().equals(\"com.taobao.jaket.common.ClassExtendsMap\")) {\n+            if (type.getType().equals(\"org.apache.dubbo.metadata.definition.common.ClassExtendsMap\")) {\n                 containsType = true;\n                 break;\n             }",
    "output": "Fix unit test"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-p2p/src/test/java/org/apache/dubbo/remoting/p2p/support/FileNetworkerTest.java b/dubbo-remoting/dubbo-remoting-p2p/src/test/java/org/apache/dubbo/remoting/p2p/support/FileNetworkerTest.java\n--- a/dubbo-remoting/dubbo-remoting-p2p/src/test/java/org/apache/dubbo/remoting/p2p/support/FileNetworkerTest.java\n+++ b/dubbo-remoting/dubbo-remoting-p2p/src/test/java/org/apache/dubbo/remoting/p2p/support/FileNetworkerTest.java\n@@ -51,7 +51,7 @@ public void tearDown() throws Exception {\n     @Test\n     public void testJoin() throws RemotingException, InterruptedException, IOException {\n-        final String groupURL = \"file://\" + folder.newFile();\n+        final String groupURL = \"file:///\" + folder.newFile();\n         FileNetworker networker = new FileNetworker();\n         Group group = networker.lookup(URL.valueOf(groupURL));",
    "output": "Fix UT failed on windows with FileNetworkerTest Fix FileNetworkerTest failure"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalanceTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalanceTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalanceTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalanceTest.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.rpc.Invoker;\n import org.junit.Assert;\n+import org.junit.Ignore;\n import org.junit.Test;\n import java.lang.reflect.Field;\n@@ -29,20 +30,21 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n+@Ignore\n public class RoundRobinLoadBalanceTest extends LoadBalanceBaseTest {\n-\n+\n     private void assertStrictWRRResult(int loop, Map<Invoker, InvokeResult> resultMap) {\n         int invokeCount = 0;\n         for (InvokeResult invokeResult : resultMap.values()) {\n             int count = (int) invokeResult.getCount().get();\n             // Because it's a strictly round robin, so the abs delta should be < 10 too\n-            Assert.assertTrue(\"delta with expected count should < 10\",\n+            Assert.assertTrue(\"delta with expected count should < 10\",\n                     Math.abs(invokeResult.getExpected(loop) - count) < 10);\n             invokeCount += count;\n         }\n         Assert.assertEquals(\"select failed!\", invokeCount, loop);\n     }\n-\n+\n     @Test\n     public void testRoundRobinLoadBalanceSelect() {\n         int runs = 10000;\n@@ -96,7 +98,7 @@ public void run() {\n         }\n         assertStrictWRRResult(runs * threadNum, totalMap);\n     }\n-\n+\n     @Test\n     public void testNodeCacheShouldNotRecycle() {\n         int loop = 10000;\n@@ -105,23 +107,23 @@ public void testNodeCacheShouldNotRecycle() {\n         try {\n             Map<Invoker, InvokeResult> resultMap = getWeightedInvokeResult(loop, RoundRobinLoadBalance.NAME);\n             assertStrictWRRResult(loop, resultMap);\n-\n+\n             // inner nodes cache judgement\n             RoundRobinLoadBalance lb = (RoundRobinLoadBalance)getLoadBalance(RoundRobinLoadBalance.NAME);\n             Assert.assertEquals(weightInvokers.size(), lb.getInvokerAddrList(weightInvokers, weightTestInvocation).size());\n-\n+\n             weightInvokers.remove(weightInvokerTmp);\n-\n+\n             resultMap = getWeightedInvokeResult(loop, RoundRobinLoadBalance.NAME);\n             assertStrictWRRResult(loop, resultMap);\n-\n+\n             Assert.assertNotEquals(weightInvokers.size(), lb.getInvokerAddrList(weightInvokers, weightTestInvocation).size());\n         } finally {\n             //prevent other UT's failure\n             weightInvokers.remove(weightInvokerTmp);\n         }\n     }\n-\n+\n     @Test\n     public void testNodeCacheShouldRecycle() {\n         {\n@@ -141,28 +143,28 @@ public void testNodeCacheShouldRecycle() {\n                 Assert.assertTrue(\"getField failed\", true);\n             }\n         }\n-\n+\n         int loop = 10000;\n         //tmperately add a new invoker\n         weightInvokers.add(weightInvokerTmp);\n         try {\n             Map<Invoker, InvokeResult> resultMap = getWeightedInvokeResult(loop, RoundRobinLoadBalance.NAME);\n             assertStrictWRRResult(loop, resultMap);\n-\n+\n             // inner nodes cache judgement\n             RoundRobinLoadBalance lb = (RoundRobinLoadBalance)getLoadBalance(RoundRobinLoadBalance.NAME);\n             Assert.assertEquals(weightInvokers.size(), lb.getInvokerAddrList(weightInvokers, weightTestInvocation).size());\n-\n+\n             weightInvokers.remove(weightInvokerTmp);\n-\n+\n             resultMap = getWeightedInvokeResult(loop, RoundRobinLoadBalance.NAME);\n             assertStrictWRRResult(loop, resultMap);\n-\n+\n             Assert.assertEquals(weightInvokers.size(), lb.getInvokerAddrList(weightInvokers, weightTestInvocation).size());\n         } finally {\n             //prevent other UT's failure\n             weightInvokers.remove(weightInvokerTmp);\n         }\n     }\n-\n+\n }",
    "output": "Add Apache license"
  },
  {
    "input": "diff --git a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java\n--- a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java\n+++ b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java\n@@ -20,6 +20,7 @@\n import org.apache.curator.framework.recipes.cache.ChildData;\n import org.apache.curator.framework.recipes.cache.TreeCacheEvent;\n import org.apache.curator.framework.recipes.cache.TreeCacheListener;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.configcenter.ConfigChangeEvent;\n import org.apache.dubbo.configcenter.ConfigChangeType;\n@@ -36,7 +37,7 @@\n  *\n  */\n public class CacheListener implements TreeCacheListener {\n-    private Map<String, Set<ConfigurationListener>> listeners = new ConcurrentHashMap<>();\n+    private Map<String, Set<ConfigurationListener>> keyListeners = new ConcurrentHashMap<>();\n     private CountDownLatch initializedLatch;\n     private String rootPath;\n@@ -82,12 +83,15 @@ public void childEvent(CuratorFramework aClient, TreeCacheEvent event) throws Ex\n             }\n             ConfigChangeEvent configChangeEvent = new ConfigChangeEvent(key, new String(value, StandardCharsets.UTF_8), changeType);\n-            listeners.get(key).forEach(listener -> listener.process(configChangeEvent));\n+            Set<ConfigurationListener> listeners = keyListeners.get(key);\n+            if (CollectionUtils.isNotEmpty(listeners)) {\n+                listeners.forEach(listener -> listener.process(configChangeEvent));\n+            }\n         }\n     }\n     public void addListener(String key, ConfigurationListener configurationListener) {\n-        Set<ConfigurationListener> set = this.listeners.computeIfAbsent(key, k -> new CopyOnWriteArraySet<>());\n+        Set<ConfigurationListener> set = this.keyListeners.computeIfAbsent(key, k -> new CopyOnWriteArraySet<>());\n         set.add(configurationListener);\n     }",
    "output": "Fix NPE when no listeners registered for key"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/LoadBalanceBaseTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/LoadBalanceBaseTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/LoadBalanceBaseTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/LoadBalanceBaseTest.java\n@@ -30,6 +30,7 @@\n import org.junit.Test;\n import com.alibaba.fastjson.JSON;\n+import org.mockito.Mockito;\n import java.util.ArrayList;\n import java.util.List;\n@@ -209,10 +210,10 @@ public String toString() {\n     @Before\n     public void before() throws Exception {\n-        weightInvoker1 = mock(Invoker.class);\n-        weightInvoker2 = mock(Invoker.class);\n-        weightInvoker3 = mock(Invoker.class);\n-        weightInvokerTmp = mock(Invoker.class);\n+        weightInvoker1 = mock(Invoker.class, Mockito.withSettings().stubOnly());\n+        weightInvoker2 = mock(Invoker.class, Mockito.withSettings().stubOnly());\n+        weightInvoker3 = mock(Invoker.class, Mockito.withSettings().stubOnly());\n+        weightInvokerTmp = mock(Invoker.class, Mockito.withSettings().stubOnly());\n         weightTestInvocation = new RpcInvocation();\n         weightTestInvocation.setMethodName(\"test\");",
    "output": "Fix OOM in UT testSelectByWeight Fix OOM Exception generated during UT"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java\n@@ -232,8 +232,8 @@ private static Wrapper makeWrapper(Class<?> c) {\n                 pts.put(pn, pt);\n             }\n         }\n-        c1.append(\" throw new \" + NoSuchPropertyException.class.getName() + \"(\\\"Not found property \\\\\\\"\\\"+$2+\\\"\\\\\\\" filed or setter method in class \" + c.getName() + \".\\\"); }\");\n-        c2.append(\" throw new \" + NoSuchPropertyException.class.getName() + \"(\\\"Not found property \\\\\\\"\\\"+$2+\\\"\\\\\\\" filed or setter method in class \" + c.getName() + \".\\\"); }\");\n+        c1.append(\" throw new \" + NoSuchPropertyException.class.getName() + \"(\\\"Not found property \\\\\\\"\\\"+$2+\\\"\\\\\\\" field or setter method in class \" + c.getName() + \".\\\"); }\");\n+        c2.append(\" throw new \" + NoSuchPropertyException.class.getName() + \"(\\\"Not found property \\\\\\\"\\\"+$2+\\\"\\\\\\\" field or setter method in class \" + c.getName() + \".\\\"); }\");\n         // make class\n         long id = WRAPPER_CLASS_COUNTER.getAndIncrement();\ndiff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java\n@@ -466,7 +466,7 @@ private static Object realize0(Object pojo, Class<?> type, Type genericType, fin\n                                 try {\n                                     field.set(dest, value);\n                                 } catch (IllegalAccessException e) {\n-                                    throw new RuntimeException(\"Failed to set filed \" + name + \" of pojo \" + dest.getClass().getName() + \" : \" + e.getMessage(), e);\n+                                    throw new RuntimeException(\"Failed to set field \" + name + \" of pojo \" + dest.getClass().getName() + \" : \" + e.getMessage(), e);\n                                 }\n                             }\n                         }\n@@ -476,11 +476,11 @@ private static Object realize0(Object pojo, Class<?> type, Type genericType, fin\n                     Object message = map.get(\"message\");\n                     if (message instanceof String) {\n                         try {\n-                            Field filed = Throwable.class.getDeclaredField(\"detailMessage\");\n-                            if (!filed.isAccessible()) {\n-                                filed.setAccessible(true);\n+                            Field field = Throwable.class.getDeclaredField(\"detailMessage\");\n+                            if (!field.isAccessible()) {\n+                                field.setAccessible(true);\n                             }\n-                            filed.set(dest, message);\n+                            field.set(dest, message);\n                         } catch (Exception e) {\n                         }\n                     }\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/AnnotationBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/AnnotationBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/AnnotationBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/AnnotationBean.java\n@@ -242,7 +242,7 @@ public Object postProcessBeforeInitialization(Object bean, String beanName)\n                     }\n                 }\n             } catch (Throwable e) {\n-                logger.error(\"Failed to init remote service reference at filed \" + field.getName() + \" in class \" + bean.getClass().getName() + \", cause: \" + e.getMessage(), e);\n+                logger.error(\"Failed to init remote service reference at field \" + field.getName() + \" in class \" + bean.getClass().getName() + \", cause: \" + e.getMessage(), e);\n             }\n         }\n         return bean;",
    "output": "Fix typo of field"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java\n@@ -662,7 +662,7 @@ public <T> CompletableFuture<T> asyncCall(Callable<T> callable) {\n                     if (o instanceof CompletableFuture) {\n                         return (CompletableFuture<T>) o;\n                     }\n-                    CompletableFuture.completedFuture(o);\n+                    return CompletableFuture.completedFuture(o);\n                 } else {\n                     // The service has a normal sync method signature, should get future from RpcContext.\n                 }",
    "output": "Add missing return statement"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassHelper.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassHelper.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassHelper.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassHelper.java\n@@ -284,4 +284,19 @@ public static Object convertPrimitive(Class<?> type, String value) {\n         }\n         return value;\n     }\n+\n+    /**\n+     * We only check boolean value at this moment.\n+     *\n+     * @param type\n+     * @param value\n+     * @return\n+     */\n+    public static boolean isTypeMatch(Class<?> type, String value) {\n+        if ((type == boolean.class || type == Boolean.class)\n+                && !(\"true\".equals(value) || \"false\".equals(value))) {\n+            return false;\n+        }\n+        return true;\n+    }\n }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -495,7 +495,7 @@ public void refresh() {\n                     try {\n                         String value = compositeConfiguration.getString(extractPropertyName(getClass(), method));\n                         // isTypeMatch() is called to avoid duplicate and incorrect update, for example, we have two 'setGeneric' methods in ReferenceConfig.\n-                        if (value != null && isTypeMatch(method.getParameterTypes()[0], value)) {\n+                        if (value != null && ClassHelper.isTypeMatch(method.getParameterTypes()[0], value)) {\n                             method.invoke(this, ClassHelper.convertPrimitive(method.getParameterTypes()[0], value));\n                         }\n                     } catch (NoSuchMethodException e) {",
    "output": "Add extra type match check when override config value"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocolTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocolTest.java\n@@ -96,8 +96,8 @@ public void testDubboProtocol() throws Exception {\n     @Test\n     public void testDubboProtocolWithMina() throws Exception {\n         DemoService service = new DemoServiceImpl();\n-        protocol.export(proxy.getInvoker(service, DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:9010/\" + DemoService.class.getName()).addParameter(Constants.SERVER_KEY, \"mina\")));\n-        service = proxy.getProxy(protocol.refer(DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:9010/\" + DemoService.class.getName()).addParameter(Constants.CLIENT_KEY, \"mina\").addParameter(\"timeout\", 3000l)));\n+        protocol.export(proxy.getInvoker(service, DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:9011/\" + DemoService.class.getName()).addParameter(Constants.SERVER_KEY, \"mina\")));\n+        service = proxy.getProxy(protocol.refer(DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:9011/\" + DemoService.class.getName()).addParameter(Constants.CLIENT_KEY, \"mina\").addParameter(\"timeout\", 3000l)));\n         for (int i = 0; i < 10; i++) {\n             assertEquals(service.enumlength(new Type[]{}), Type.Lower);\n             assertEquals(service.getSize(null), -1);\n@@ -112,15 +112,15 @@ public void testDubboProtocolWithMina() throws Exception {\n             service.invoke(\"dubbo://127.0.0.1:9010/\" + DemoService.class.getName() + \"\", \"invoke\");\n         }\n-        service = proxy.getProxy(protocol.refer(DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:9010/\" + DemoService.class.getName() + \"?client=mina\").addParameter(\"timeout\", 3000l)));\n+        service = proxy.getProxy(protocol.refer(DemoService.class, URL.valueOf(\"dubbo://127.0.0.1:9011/\" + DemoService.class.getName() + \"?client=mina\").addParameter(\"timeout\", 3000l)));\n         // test netty client\n         StringBuffer buf = new StringBuffer();\n         for (int i = 0; i < 1024 * 32 + 32; i++)\n             buf.append('A');\n         System.out.println(service.stringLength(buf.toString()));\n         // cast to EchoService\n-        EchoService echo = proxy.getProxy(protocol.refer(EchoService.class, URL.valueOf(\"dubbo://127.0.0.1:9010/\" + DemoService.class.getName() + \"?client=mina\").addParameter(\"timeout\", 3000l)));\n+        EchoService echo = proxy.getProxy(protocol.refer(EchoService.class, URL.valueOf(\"dubbo://127.0.0.1:9011/\" + DemoService.class.getName() + \"?client=mina\").addParameter(\"timeout\", 3000l)));\n         for (int i = 0; i < 10; i++) {\n             assertEquals(echo.$echo(buf.toString()), buf.toString());\n             assertEquals(echo.$echo(\"test\"), \"test\");",
    "output": "Add dependency on dubbo-remoting-mina for tests in dubbo-rpc-dubbo * Adding dependency on dubbo-remoting-mina so DubboProtocolTest.testDubboProtocolWithMina is no longer flaky * Changing port number to ensure new server/client created for test"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -505,8 +505,6 @@ && isPrimitive(method.getReturnType())) {\n                     }\n                 }\n             } catch (Exception e) {\n-                System.out.println(this.getClass().getName());\n-                System.out.println(method.getName());\n                 throw new IllegalStateException(e.getMessage(), e);\n             }\n         }\ndiff --git a/dubbo-configcenter/dubbo-configcenter-apollo/src/main/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfiguration.java b/dubbo-configcenter/dubbo-configcenter-apollo/src/main/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfiguration.java\n--- a/dubbo-configcenter/dubbo-configcenter-apollo/src/main/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfiguration.java\n+++ b/dubbo-configcenter/dubbo-configcenter-apollo/src/main/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfiguration.java\n@@ -56,8 +56,6 @@ public void init() {\n         /**\n          * Instead of using Dubbo's configuration, I would suggest use the original configuration method Apollo provides.\n          */\n-//        String configEnv = env.getCompositeConf().getString(ENV_KEY);\n-//        String configCluster = env.getCompositeConf().getString(CLUSTER_KEY);\n         String configEnv = url.getParameter(Constants.CONFIG_ENV_KEY);\n         String configAddr = url.getBackupAddress();\n         String configCluster = url.getParameter(Constants.CONFIG_CLUSTER_KEY);\ndiff --git a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/archaius/sources/ZooKeeperConfigurationSource.java b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/archaius/sources/ZooKeeperConfigurationSource.java\n--- a/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/archaius/sources/ZooKeeperConfigurationSource.java\n+++ b/dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/archaius/sources/ZooKeeperConfigurationSource.java\n@@ -39,6 +39,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.Executor;\n import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n@@ -59,7 +60,7 @@ public class ZooKeeperConfigurationSource implements WatchedConfigurationSource,\n     // The final root path would be: /configRootPath/\"config\"\n     private final String configRootPath;\n     private final TreeCache treeCache;\n-    private boolean connected = false;\n+    private CountDownLatch initializedLatch = new CountDownLatch(1);\n     private final Charset charset = Charset.forName(\"UTF-8\");\n@@ -96,7 +97,7 @@ public ZooKeeperConfigurationSource(String connectString, int sessionTimeout, in\n                 new ExponentialBackoffRetry(1000, 3));\n         client.start();\n         try {\n-            connected = client.blockUntilConnected(connectTimeout, TimeUnit.MILLISECONDS);\n+            boolean connected = client.blockUntilConnected(connectTimeout, TimeUnit.MILLISECONDS);\n             if (!connected) {\n                 boolean check = Boolean.parseBoolean(System.getProperty(ARCHAIUS_CONFIG_CHECK_KEY, \"false\"));\n                 if (check) {\n@@ -138,8 +139,8 @@ public void childEvent(CuratorFramework aClient, TreeCacheEvent event)\n                 TreeCacheEvent.Type type = event.getType();\n                 ChildData data = event.getData();\n-                if (type == TreeCacheEvent.Type.INITIALIZED || type == TreeCacheEvent.Type.CONNECTION_RECONNECTED) {\n-                    connected = true;\n+                if (type == TreeCacheEvent.Type.INITIALIZED) {\n+                    initializedLatch.countDown();\n                 }\n                 // TODO, ignore other event types\n@@ -202,9 +203,10 @@ public Map<String, Object> getCurrentData() throws Exception {\n         Map<String, Object> all = new HashMap<>();\n-        if (!connected) {\n-            logger.warn(\"ConfigCenter is not connected yet, zookeeper does't support local snapshot, so there's no backup data to use!\");\n-            return all;\n+        try {\n+            initializedLatch.await();\n+        } catch (InterruptedException e) {\n+            logger.error(\"Being interrupted unexpectedly when waiting zookeeper to initialize, the config data may not ready yet, be careful!\");\n         }\n         Map<String, ChildData> dataMap = treeCache.getCurrentChildren(configRootPath);\n@@ -257,8 +259,4 @@ public void close() {\n             logger.error(\"IOException should not have been thrown.\", exc);\n         }\n     }\n-\n-    public boolean isConnected() {\n-        return connected;\n-    }\n }",
    "output": "Fix concurrent problem of zookeeper configcenter, wait to start until cache being fully populated"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java\n@@ -57,13 +57,12 @@ public URL configure(URL url) {\n          */\n         String apiVersion = configuratorUrl.getParameter(Constants.API_VERSION_KEY);\n         if (StringUtils.isNotEmpty(apiVersion)) {\n-            int configuratorPort = configuratorUrl.getPort();\n-            if (configuratorPort == 0) {\n-                configureIfMatch(NetUtils.getLocalHost(), url, configuratorUrl);\n-            } else {\n-                if (url.getPort() == configuratorPort) {\n-                    configureIfMatch(configuratorUrl.getHost(), url, configuratorUrl);\n-                }\n+            String currentSide = url.getParameter(Constants.SIDE_KEY);\n+            String configuratorSide = configuratorUrl.getParameter(Constants.SIDE_KEY);\n+            if (currentSide.equals(configuratorSide) && Constants.CONSUMER.equals(configuratorSide) && 0 == configuratorUrl.getPort()) {\n+                url = configureIfMatch(NetUtils.getLocalHost(), url);\n+            } else if (currentSide.equals(configuratorSide) && Constants.PROVIDER.equals(configuratorSide) && url.getPort() == configuratorUrl.getPort()) {\n+                url = configureIfMatch(url.getHost(), url);\n             }\n         }\n         /**\n@@ -80,21 +79,21 @@ private URL configureDeprecated(URL url) {\n         // If override url has port, means it is a provider address. We want to control a specific provider with this override url, it may take effect on the specific provider instance or on consumers holding this provider instance.\n         if (configuratorUrl.getPort() != 0) {\n             if (url.getPort() == configuratorUrl.getPort()) {\n-                return configureIfMatch(url.getHost(), url, configuratorUrl);\n+                return configureIfMatch(url.getHost(), url);\n             }\n         } else {// override url don't have a port, means the ip override url specify is a consumer address or 0.0.0.0\n             // 1.If it is a consumer ip address, the intention is to control a specific consumer instance, it must takes effect at the consumer side, any provider received this override url should ignore;\n             // 2.If the ip is 0.0.0.0, this override url can be used on consumer, and also can be used on provider\n             if (url.getParameter(Constants.SIDE_KEY, Constants.PROVIDER).equals(Constants.CONSUMER)) {\n-                return configureIfMatch(NetUtils.getLocalHost(), url, configuratorUrl);// NetUtils.getLocalHost is the ip address consumer registered to registry.\n+                return configureIfMatch(NetUtils.getLocalHost(), url);// NetUtils.getLocalHost is the ip address consumer registered to registry.\n             } else if (url.getParameter(Constants.SIDE_KEY, Constants.CONSUMER).equals(Constants.PROVIDER)) {\n-                return configureIfMatch(Constants.ANYHOST_VALUE, url, configuratorUrl);// take effect on all providers, so address must be 0.0.0.0, otherwise it won't flow to this if branch\n+                return configureIfMatch(Constants.ANYHOST_VALUE, url);// take effect on all providers, so address must be 0.0.0.0, otherwise it won't flow to this if branch\n             }\n         }\n         return url;\n     }\n-    private URL configureIfMatch(String host, URL url, URL configuratorUrl) {\n+    private URL configureIfMatch(String host, URL url) {\n         if (Constants.ANYHOST_VALUE.equals(configuratorUrl.getHost()) || host.equals(configuratorUrl.getHost())) {\n             // TODO, to support wildcards\n             String providers = configuratorUrl.getParameter(Constants.OVERRIDE_PROVIDERS_KEY);\n@@ -113,6 +112,7 @@ private URL configureIfMatch(String host, URL url, URL configuratorUrl) {\n                     conditionKeys.add(Constants.VERSION_KEY);\n                     conditionKeys.add(Constants.APPLICATION_KEY);\n                     conditionKeys.add(Constants.SIDE_KEY);\n+                    conditionKeys.add(Constants.API_VERSION_KEY);\n                     for (Map.Entry<String, String> entry : configuratorUrl.getParameters().entrySet()) {\n                         String key = entry.getKey();\n                         String value = entry.getValue();",
    "output": "Fix configurator bug"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/config/Environment.java\n@@ -29,14 +29,14 @@\n public class Environment {\n     private static final Environment INSTANCE = new Environment();\n-    private volatile Map<String, PropertiesConfiguration> propertiesConfsHolder = new ConcurrentHashMap<>();\n-    private volatile Map<String, SystemConfiguration> systemConfsHolder = new ConcurrentHashMap<>();\n-    private volatile Map<String, EnvironmentConfiguration> environmentConfsHolder = new ConcurrentHashMap<>();\n-    private volatile Map<String, InmemoryConfiguration> externalConfsHolder = new ConcurrentHashMap<>();\n-    private volatile Map<String, InmemoryConfiguration> appExternalConfsHolder = new ConcurrentHashMap<>();\n-    private volatile Map<String, CompositeConfiguration> startupCompositeConfsHolder = new ConcurrentHashMap<>();\n-\n-    private volatile boolean isConfigCenterFirst = true;\n+    private Map<String, PropertiesConfiguration> propertiesConfsHolder = new ConcurrentHashMap<>();\n+    private Map<String, SystemConfiguration> systemConfsHolder = new ConcurrentHashMap<>();\n+    private Map<String, EnvironmentConfiguration> environmentConfsHolder = new ConcurrentHashMap<>();\n+    private Map<String, InmemoryConfiguration> externalConfsHolder = new ConcurrentHashMap<>();\n+    private Map<String, InmemoryConfiguration> appExternalConfsHolder = new ConcurrentHashMap<>();\n+    private Map<String, CompositeConfiguration> startupCompositeConfsHolder = new ConcurrentHashMap<>();\n+\n+    private boolean isConfigCenterFirst = true;\n     private Map<String, String> externalConfigurationMap = new HashMap<>();\n     private Map<String, String> appExternalConfigurationMap = new HashMap<>();",
    "output": "Remove unnecessary volatile restrict"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -36,6 +36,7 @@\n import org.apache.dubbo.registry.RegistryService;\n import org.apache.dubbo.registry.integration.parser.ConfigParser;\n import org.apache.dubbo.registry.support.ProviderConsumerRegTable;\n+import org.apache.dubbo.registry.support.ProviderInvokerWrapper;\n import org.apache.dubbo.rpc.Exporter;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Protocol;\n@@ -147,6 +148,11 @@ public void register(URL registryUrl, URL registedProviderUrl) {\n         registry.register(registedProviderUrl);\n     }\n+    public void unregister(URL registryUrl, URL registedProviderUrl) {\n+        Registry registry = registryFactory.getRegistry(registryUrl);\n+        registry.unregister(registedProviderUrl);\n+    }\n+\n     @Override\n     public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {\n         URL registryUrl = getRegistryUrl(originInvoker);\n@@ -226,9 +232,13 @@ public <T> void reExport(final Invoker<T> originInvoker, URL newInvokerUrl) {\n         final URL registeredProviderUrl = getRegistedProviderUrl(newInvokerUrl, registryUrl);\n         //decide if we need to re-publish\n-        boolean shouldReregister = ProviderConsumerRegTable.getProviderWrapper(originInvoker).isReg();\n+        ProviderInvokerWrapper<T> providerInvokerWrapper = ProviderConsumerRegTable.getProviderWrapper(originInvoker);\n         ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);\n-        if (shouldReregister) {\n+        /**\n+         * Only if the new url going to Registry is different with the previous one should we do unregister and register.\n+         */\n+        if (providerInvokerWrapper.isReg() && !registeredProviderUrl.equals(providerInvokerWrapper.getProviderUrl())) {\n+            unregister(registryUrl, providerInvokerWrapper.getProviderUrl());\n             register(registryUrl, registeredProviderUrl);\n         }",
    "output": "Fix reExport, check url to registry changed before do register"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java\n@@ -49,13 +49,15 @@ public static List<URL> parseConfigurators(String rawConfig) {\n                             .stream()\n                             .map(u -> u.addParameter(Constants.CATEGORY_KEY, Constants.APP_DYNAMIC_CONFIGURATORS_CATEGORY))\n                             .map(u -> u.addParameter(Constants.ENABLED_KEY, configuratorConfig.isEnabled()))\n+                            .map(u -> u.addParameter(Constants.API_VERSION_KEY, configuratorConfig.getApiVersion()))\n                             .collect(Collectors.toList())\n             ));\n         } else { // servcie scope by default.\n             items.forEach(item -> urls.addAll(\n                     serviceItemToUrls(item, configuratorConfig.getKey())\n                             .stream()\n                             .map(u -> u.addParameter(Constants.ENABLED_KEY, configuratorConfig.isEnabled()))\n+                            .map(u -> u.addParameter(Constants.API_VERSION_KEY, configuratorConfig.getApiVersion()))\n                             .collect(Collectors.toList()))\n             );\n         }",
    "output": "Add apiVersion to override url"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java b/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java\n@@ -729,13 +729,15 @@ public class Constants {\n     public static final String CYCLE_REPORT_KEY = \"cyclereport\";\n     public static final String API_VERSION_KEY = \"apiVersion\";\n+    // package version in the manifest\n+    public static final String SPECIFICATION_VERSION_KEY = \"specVersion\";\n     public static final String OVERRIDE_PROVIDERS_KEY = \"providerAddreses\";\n     public static final String[] DEFAULT_REGISTER_PROVIDER_KEYS = {APPLICATION_KEY, CODEC_KEY, EXCHANGER_KEY, SERIALIZATION_KEY, CLUSTER_KEY, CONNECTIONS_KEY, DEPRECATED_KEY,\n-            GROUP_KEY, LOADBALANCE_KEY, MOCK_KEY, PATH_KEY, TIMEOUT_KEY, TOKEN_KEY, VERSION_KEY, WARMUP_KEY, WEIGHT_KEY, TIMESTAMP_KEY, DUBBO_VERSION_KEY};\n+            GROUP_KEY, LOADBALANCE_KEY, MOCK_KEY, PATH_KEY, TIMEOUT_KEY, TOKEN_KEY, VERSION_KEY, WARMUP_KEY, WEIGHT_KEY, TIMESTAMP_KEY, DUBBO_VERSION_KEY, SPECIFICATION_VERSION_KEY};\n-    public static final String[] DEFAULT_REGISTER_CONSUMER_KEYS = {APPLICATION_KEY, VERSION_KEY, GROUP_KEY, DUBBO_VERSION_KEY};\n+    public static final String[] DEFAULT_REGISTER_CONSUMER_KEYS = {APPLICATION_KEY, VERSION_KEY, GROUP_KEY, DUBBO_VERSION_KEY, SPECIFICATION_VERSION_KEY};\n     /*\n      * private Constants(){ }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -263,6 +263,7 @@ private void init() {\n         map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);\n         map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());\n+        map.put(Constants.SPECIFICATION_VERSION_KEY, Version.getVersion());\n         map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n         if (ConfigUtils.getPid() > 0) {\n             map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -381,6 +381,7 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n         Map<String, String> map = new HashMap<String, String>();\n         map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);\n         map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());\n+        map.put(Constants.SPECIFICATION_VERSION_KEY, Version.getVersion());\n         map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n         if (ConfigUtils.getPid() > 0) {\n             map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));",
    "output": "Add dubbo specification version into registry for ops"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java\n@@ -135,7 +135,8 @@ private static BeanDefinition parse(Element element, ParserContext parserContext\n                     && Modifier.isPublic(setter.getModifiers())\n                     && setter.getParameterTypes().length == 1) {\n                 Class<?> type = setter.getParameterTypes()[0];\n-                String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \"-\");\n+                String propertyName = name.substring(3, 4).toLowerCase() + name.substring(4);\n+                String property = StringUtils.camelToSplitName(propertyName, \"-\");\n                 props.add(property);\n                 Method getter = null;\n                 try {\n@@ -223,7 +224,7 @@ private static BeanDefinition parse(Element element, ParserContext parserContext\n                                     }\n                                     reference = new RuntimeBeanReference(value);\n                                 }\n-                                beanDefinition.getPropertyValues().addPropertyValue(property, reference);\n+                                beanDefinition.getPropertyValues().addPropertyValue(propertyName, reference);\n                             }\n                         }\n                     }",
    "output": "Fix apporiate NotWritablePropertyException . 'propertyname in java donot contain '-' but camel format'"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n@@ -118,7 +118,7 @@ public URL(String protocol, String host, int port) {\n         this(protocol, null, null, host, port, null, (Map<String, String>) null);\n     }\n-    public URL(String protocol, String host, int port, String[] pairs) { // varargs ... confilict with the following path argument, use array instead.\n+    public URL(String protocol, String host, int port, String[] pairs) { // varargs ... conflict with the following path argument, use array instead.\n         this(protocol, null, null, host, port, null, CollectionUtils.toStringMap(pairs));\n     }",
    "output": "Fix typo Fix typo confilict -> conflict"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -544,7 +544,7 @@ public void refresh() {\n                             method.invoke(this, convertPrimitive(method.getParameterTypes()[0], value));\n                         }\n                     } catch (NoSuchMethodException e) {\n-                        logger.warn(\"Failed to override the property \" + method.getName() + \" in \" + this.getClass().getSimpleName() + \", please make sure every property has a getter/setter pair.\", e);\n+                        logger.info(\"Failed to override the property \" + method.getName() + \" in \" + this.getClass().getSimpleName() + \", please make sure every property has a getter/setter pair.\");\n                     }\n                 }\n             }",
    "output": "Change log level to info"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n@@ -89,6 +89,7 @@ public void init() {\n     private DynamicConfiguration startDynamicConfiguration() {\n         // give jvm properties the chance to override local configs, e.g., -Ddubbo.configcenter.config.priority\n+\n         refresh();\n //        checkConfigCenter();\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n@@ -61,7 +61,7 @@ public static void testStartupConfig() {\n         System.out.println(str);\n         try {\n-            String path = \"/dubboregistrygroup1/config/demo-provider/dubbo.properties\";\n+            String path = \"/dubboregistrygroup1/config/dubbo/dubbo.properties\";\n             if (client.checkExists().forPath(path) == null) {\n                 client.create().creatingParentsIfNeeded().forPath(path);\n             }",
    "output": "Add pom dependency"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n@@ -57,7 +57,7 @@ public class TagRouter extends AbstractRouter implements Comparable<Router>, Con\n     private TagRouterRule tagRouterRule;\n     private String application;\n-    private AtomicBoolean isInited;\n+    private AtomicBoolean isInited = new AtomicBoolean(false);\n     public TagRouter(URL url) {\n         this(ExtensionLoader.getExtensionLoader(DynamicConfigurationFactory.class).getAdaptiveExtension().getDynamicConfiguration(url), url);",
    "output": "Fix NPE in TagRouter"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java\n@@ -47,7 +47,8 @@ public URL getUrl() {\n     @Override\n     public URL configure(URL url) {\n-        if (configuratorUrl.getHost() == null || url == null || url.getHost() == null) {\n+        // If override url is not enabled or is invalid, just return.\n+        if (!configuratorUrl.getParameter(Constants.ENABLED_KEY, true) || configuratorUrl.getHost() == null || url == null || url.getHost() == null) {\n             return url;\n         }\n         // If override url has port, means it is a provider address. We want to control a specific provider with this override url, it may take effect on the specific provider instance or on consumers holding this provider instance.",
    "output": "Add enabled=true check for override url"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/annotation/DubboConfigConfiguration.java\n@@ -19,6 +19,7 @@\n import org.apache.dubbo.config.AbstractConfig;\n import org.apache.dubbo.config.ApplicationConfig;\n import org.apache.dubbo.config.ConsumerConfig;\n+import org.apache.dubbo.config.MetadataReportConfig;\n import org.apache.dubbo.config.ModuleConfig;\n import org.apache.dubbo.config.MonitorConfig;\n import org.apache.dubbo.config.ProtocolConfig;\n@@ -56,7 +57,8 @@ public class DubboConfigConfiguration {\n             @EnableDubboConfigBinding(prefix = \"dubbo.monitor\", type = MonitorConfig.class),\n             @EnableDubboConfigBinding(prefix = \"dubbo.provider\", type = ProviderConfig.class),\n             @EnableDubboConfigBinding(prefix = \"dubbo.consumer\", type = ConsumerConfig.class),\n-            @EnableDubboConfigBinding(prefix = \"dubbo.configcenter\", type = ConfigCenterBean.class)\n+            @EnableDubboConfigBinding(prefix = \"dubbo.configcenter\", type = ConfigCenterBean.class),\n+            @EnableDubboConfigBinding(prefix = \"dubbo.metadatareport\", type = MetadataReportConfig.class)\n     })\n     public static class Single {",
    "output": "Fix :dubbo.properties cannot work on MetadataReportConfig"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java\n@@ -164,13 +164,15 @@ private static String appendService(String serviceKey) {\n         if (i > 0) {\n             sb.append(\"group=\");\n             sb.append(interfaceName.substring(0, i));\n+            sb.append(\"&\");\n             interfaceName = interfaceName.substring(i + 1);\n         }\n         int j = interfaceName.indexOf(\":\");\n         if (j > 0) {\n             sb.append(\"version=\");\n             sb.append(interfaceName.substring(j + 1));\n+            sb.append(\"&\");\n             interfaceName = interfaceName.substring(0, j);\n         }\n         sb.insert(0, interfaceName + \"?\");",
    "output": "Fix problem when parsing override rule"
  },
  {
    "input": "diff --git a/dubbo-governance/dubbo-governance-api/src/main/java/org/apache/dubbo/governance/AbstractDynamicConfiguration.java b/dubbo-governance/dubbo-governance-api/src/main/java/org/apache/dubbo/governance/AbstractDynamicConfiguration.java\n--- a/dubbo-governance/dubbo-governance-api/src/main/java/org/apache/dubbo/governance/AbstractDynamicConfiguration.java\n+++ b/dubbo-governance/dubbo-governance-api/src/main/java/org/apache/dubbo/governance/AbstractDynamicConfiguration.java\n@@ -16,7 +16,6 @@\n  */\n package org.apache.dubbo.governance;\n-import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.config.AbstractConfiguration;\n@@ -46,7 +45,7 @@ public void addListener(String key, ConfigurationListener listener) {\n     @Override\n     public String getConfig(String key) {\n-        return getConfig(key, url.getParameter(Constants.CONFIG_GROUP_KEY, DEFAULT_GROUP), null);\n+        return getConfig(key, null, null);\n     }\n     @Override\n@@ -56,7 +55,7 @@ public String getConfig(String key, String group) {\n     @Override\n     public String getConfig(String key, ConfigurationListener listener) {\n-        return getConfig(key, url.getParameter(Constants.CONFIG_GROUP_KEY, DEFAULT_GROUP), listener);\n+        return getConfig(key, null, listener);\n     }\n     @Override\ndiff --git a/dubbo-governance/dubbo-governance-apollo/src/main/java/org/apache/dubbo/governance/support/apollo/ApolloDynamicConfiguration.java b/dubbo-governance/dubbo-governance-apollo/src/main/java/org/apache/dubbo/governance/support/apollo/ApolloDynamicConfiguration.java\n--- a/dubbo-governance/dubbo-governance-apollo/src/main/java/org/apache/dubbo/governance/support/apollo/ApolloDynamicConfiguration.java\n+++ b/dubbo-governance/dubbo-governance-apollo/src/main/java/org/apache/dubbo/governance/support/apollo/ApolloDynamicConfiguration.java\n@@ -97,7 +97,7 @@ public void init() {\n      */\n     @Override\n     protected String getInternalProperty(String key, String group, long timeout) {\n-        if (DEFAULT_GROUP.equals(group)) {\n+        if (StringUtils.isNotEmpty(group) && !url.getParameter(Constants.CONFIG_GROUP_KEY, DEFAULT_GROUP).equals(group)) {\n             Config config = ConfigService.getConfig(group);\n             if (config != null) {\n                 return config.getProperty(key, null);",
    "output": "Remove default group in DynamicConfiguration API"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessor.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessor.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessor.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessor.java\n@@ -387,7 +387,7 @@ private AbstractBeanDefinition buildServiceBeanDefinition(Service service, Class\n         MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();\n-        String[] ignoreAttributeNames = of(\"provider\", \"monitor\", \"application\", \"module\", \"registry\", \"protocol\", \"interface\");\n+        String[] ignoreAttributeNames = of(\"provider\", \"monitor\", \"application\", \"module\", \"registry\", \"protocol\", \"interface\", \"interfaceName\");\n         propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames));\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n@@ -33,6 +33,7 @@\n import org.apache.dubbo.config.spring.annotation.consumer.AnnotationAction;\n import org.apache.dubbo.config.spring.api.DemoService;\n import org.apache.dubbo.config.spring.api.HelloService;\n+import org.apache.dubbo.config.spring.context.annotation.provider.ProviderConfiguration;\n import org.apache.dubbo.config.spring.filter.MockFilter;\n import org.apache.dubbo.config.spring.impl.DemoServiceImpl;\n import org.apache.dubbo.config.spring.impl.HelloServiceImpl;\n@@ -50,6 +51,7 @@\n import org.junit.Ignore;\n import org.junit.Test;\n import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.context.annotation.AnnotationConfigApplicationContext;\n import org.springframework.context.support.ClassPathXmlApplicationContext;\n import java.util.Collection;\n@@ -105,6 +107,23 @@ public void testServiceClass() {\n         }\n     }\n+    @Test\n+    public void testServiceAnnotation() {\n+        AnnotationConfigApplicationContext providerContext = new AnnotationConfigApplicationContext();\n+        providerContext.register(ProviderConfiguration.class);\n+\n+        providerContext.refresh();\n+\n+        ReferenceConfig<HelloService> reference = new ReferenceConfig<HelloService>();\n+        reference.setApplication(new ApplicationConfig(\"consumer\"));\n+        reference.setRegistry(new RegistryConfig(RegistryConfig.NO_AVAILABLE));\n+        reference.setInterface(HelloService.class);\n+        reference.setUrl(\"dubbo://127.0.0.1:12345\");\n+        String hello = reference.get().sayHello(\"hello\");\n+        assertEquals(\"Hello, hello\", hello);\n+\n+    }\n+\n     @Test\n     @SuppressWarnings(\"unchecked\")\n     public void testProviderNestedService() {\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/context/annotation/provider/HelloServiceImpl.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/context/annotation/provider/HelloServiceImpl.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/context/annotation/provider/HelloServiceImpl.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/context/annotation/provider/HelloServiceImpl.java\n@@ -24,7 +24,7 @@\n  *\n  * @since 2.5.9\n  */\n-@Service\n+@Service(interfaceName = \"org.apache.dubbo.config.spring.api.HelloService\")\n public class HelloServiceImpl implements HelloService {\n     @Override",
    "output": "Fix Invalid property 'interfaceName' of bean class [org.apache.dubbo.config.spring.ServiceBean]#2353 * add getter and setter for ServiceConfig's interfaceName property#2353 * add interfaceName to ignoreAttributeNames and change the unit test * delete the demo source code and update the unit test * unchange ServiceConfig * update unit test * update unit test"
  },
  {
    "input": "diff --git a/dubbo-filter/dubbo-filter-cache/src/test/java/org/apache/dubbo/cache/support/jcache/JCacheFactoryTest.java b/dubbo-filter/dubbo-filter-cache/src/test/java/org/apache/dubbo/cache/support/jcache/JCacheFactoryTest.java\n--- a/dubbo-filter/dubbo-filter-cache/src/test/java/org/apache/dubbo/cache/support/jcache/JCacheFactoryTest.java\n+++ b/dubbo-filter/dubbo-filter-cache/src/test/java/org/apache/dubbo/cache/support/jcache/JCacheFactoryTest.java\n@@ -38,7 +38,7 @@ public void testJCacheFactory() throws Exception {\n     @Test\n     public void testJCacheGetExpired() throws Exception {\n-        URL url = URL.valueOf(\"test://test:11/test?cache=jacache&.cache.write.expire=1\");\n+        URL url = URL.valueOf(\"test://test:12/test?cache=jacache&.cache.write.expire=1\");\n         AbstractCacheFactory cacheFactory = getCacheFactory();\n         Invocation invocation = new RpcInvocation();\n         Cache cache = cacheFactory.getCache(url, invocation);",
    "output": "Change URL so tests can run in any order"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -504,7 +504,8 @@ public String toString() {\n                 try {\n                     String name = method.getName();\n                     if ((name.startsWith(\"get\") || name.startsWith(\"is\"))\n-                            && !\"getClass\".equals(name) && !\"get\".equals(name) && !\"is\".equals(name)\n+                            && !\"get\".equals(name) && !\"is\".equals(name)\n+                            && !\"getClass\".equals(name) && !\"getObject\".equals(name)\n                             && Modifier.isPublic(method.getModifiers())\n                             && method.getParameterTypes().length == 0\n                             && isPrimitive(method.getReturnType())) {",
    "output": "Fix the bug that ReferenceBean refers service more than once when debugging. note: please visit http://t.cn/EAhta27 for more detail"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n@@ -49,6 +49,9 @@ public class ConfigCenterConfig extends AbstractConfig {\n     private String appname;\n     private String configfile = \"dubbo.properties\";\n+    private String localconfigfile;\n+\n+    private ApplicationConfig application;\n     // customized parameters\n     private Map<String, String> parameters;\n@@ -86,7 +89,11 @@ public void init() throws Exception {\n         Environment.getInstance().setDynamicConfiguration(dynamicConfiguration);\n         String configContent = dynamicConfiguration.getConfig(configfile, group);\n-        String appConfigContent = dynamicConfiguration.getConfig(configfile, appname);\n+        String appConfigContent = dynamicConfiguration.getConfig\n+                (\n+                        StringUtils.isNotEmpty(localconfigfile) ? localconfigfile : configfile,\n+                        getApplicationName()\n+                );\n         try {\n             Environment.getInstance().setConfigCenterFirst(priority);\n             Environment.getInstance().updateExternalConfigurationMap(parseProperties(configContent));\n@@ -96,6 +103,17 @@ public void init() throws Exception {\n         }\n     }\n+    private String getApplicationName() {\n+        if (application != null) {\n+            if (!application.isValid()) {\n+                throw new IllegalStateException(\n+                        \"No application config found or it's not a valid config! Please add <dubbo:application name=\\\"...\\\" /> to your spring config.\");\n+            }\n+            return application.getName();\n+        }\n+        return appname;\n+    }\n+\n     private Map<String, String> parseProperties(String content) throws IOException {\n         Map<String, String> map = new HashMap<>();\n         if (content == null) {\n@@ -216,6 +234,15 @@ public void setConfigfile(String configfile) {\n         this.configfile = configfile;\n     }\n+    @Parameter(excluded = true)\n+    public String getLocalconfigfile() {\n+        return localconfigfile;\n+    }\n+\n+    public void setLocalconfigfile(String localconfigfile) {\n+        this.localconfigfile = localconfigfile;\n+    }\n+\n     @Parameter(key = Constants.CONFIG_APPNAME_KEY)\n     public String getAppname() {\n         return appname;\n@@ -233,4 +260,12 @@ public void setParameters(Map<String, String> parameters) {\n         checkParameterName(parameters);\n         this.parameters = parameters;\n     }\n+\n+    public ApplicationConfig getApplication() {\n+        return application;\n+    }\n+\n+    public void setApplication(ApplicationConfig application) {\n+        this.application = application;\n+    }\n }\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java\n@@ -16,20 +16,53 @@\n  */\n package org.apache.dubbo.config.spring;\n+import org.apache.dubbo.config.ApplicationConfig;\n import org.apache.dubbo.config.ConfigCenterConfig;\n+import org.apache.dubbo.config.spring.extension.SpringExtensionFactory;\n+import org.springframework.beans.factory.BeanFactoryUtils;\n import org.springframework.beans.factory.DisposableBean;\n import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+\n+import java.util.Map;\n /**\n  * Since 2.7.0+, export and refer will only be executed when Spring is fully initialized, and each Config bean will get refreshed on the start of the export and refer process.\n  * So it's ok for this bean not to be the first Dubbo Config bean being initialized.\n  *\n  * If use ConfigCenterConfig directly, you should make sure ConfigCenterConfig.init() is called before actually export/refer any Dubbo service.\n  */\n-public class ConfigCenterBean extends ConfigCenterConfig implements InitializingBean, DisposableBean {\n+public class ConfigCenterBean extends ConfigCenterConfig implements InitializingBean, ApplicationContextAware, DisposableBean {\n+\n+    private transient ApplicationContext applicationContext;\n+\n+    @Override\n+    public void setApplicationContext(ApplicationContext applicationContext) {\n+        this.applicationContext = applicationContext;\n+        SpringExtensionFactory.addApplicationContext(applicationContext);\n+    }\n     @Override\n     public void afterPropertiesSet() throws Exception {\n+        if (getApplication() == null) {\n+            Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);\n+            if (applicationConfigMap != null && applicationConfigMap.size() > 0) {\n+                ApplicationConfig applicationConfig = null;\n+                for (ApplicationConfig config : applicationConfigMap.values()) {\n+                    if (config.isDefault() == null || config.isDefault()) {\n+                        if (applicationConfig != null) {\n+                            throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config);\n+                        }\n+                        applicationConfig = config;\n+                    }\n+                }\n+                if (applicationConfig != null) {\n+                    setApplication(applicationConfig);\n+                }\n+            }\n+        }\n+\n         this.init();\n     }\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java\n@@ -79,6 +79,10 @@ public boolean isSingleton() {\n     @Override\n     @SuppressWarnings({\"unchecked\"})\n     public void afterPropertiesSet() throws Exception {\n+        if (applicationContext != null) {\n+            BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConfigCenterBean.class, false, false);\n+        }\n+\n         if (getConsumer() == null) {\n             Map<String, ConsumerConfig> consumerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig.class, false, false);\n             if (consumerConfigMap != null && consumerConfigMap.size() > 0) {",
    "output": "Make ReferenceBean depend on ConfigCenterBean, so that ConfigCenterBean can always be initialized before refer"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractMethodConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractMethodConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractMethodConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractMethodConfig.java\n@@ -64,6 +64,19 @@ public abstract class AbstractMethodConfig extends AbstractConfig {\n     // customized parameters\n     protected Map<String, String> parameters;\n+    /**\n+     * forks for forking cluster\n+     */\n+    protected Integer forks;\n+\n+    public Integer getForks() {\n+        return forks;\n+    }\n+\n+    public void setForks(Integer forks) {\n+        this.forks = forks;\n+    }\n+\n     public Integer getTimeout() {\n         return timeout;\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractMethodConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractMethodConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractMethodConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractMethodConfigTest.java\n@@ -35,6 +35,13 @@ public void testTimeout() throws Exception {\n         assertThat(methodConfig.getTimeout(), equalTo(10));\n     }\n+    @Test\n+    public void testForks() throws Exception {\n+        MethodConfig methodConfig = new MethodConfig();\n+        methodConfig.setForks(10);\n+        assertThat(methodConfig.getForks(), equalTo(10));\n+    }\n+\n     @Test\n     public void testRetries() throws Exception {\n         MethodConfig methodConfig = new MethodConfig();\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n@@ -147,6 +147,20 @@ public void testToString() {\n         assertTrue(str.endsWith(\" />\"));\n     }\n+    @Test\n+    public void testForks() {\n+        ReferenceConfig<DemoService> reference = new ReferenceConfig<DemoService>();\n+        reference.setApplication(new ApplicationConfig(\"consumer\"));\n+        reference.setRegistry(new RegistryConfig(RegistryConfig.NO_AVAILABLE));\n+        reference.setInterface(DemoService.class);\n+        reference.setUrl(\"dubbo://127.0.0.1:20881\");\n+\n+        int forks = 10;\n+        reference.setForks(forks);\n+        String str = reference.toString();\n+        assertTrue(str.contains(\"forks=\\\"\" + forks + \"\\\"\"));\n+    }\n+\n     @Test\n     public void testMultiProtocol() {\n         ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(ConfigTest.class.getPackage().getName().replace('.', '/') + \"/multi-protocol.xml\");",
    "output": "Add 'forks' config into xml config * Add forks into xml config. * Add forks into xml config. * Add forks into xml config"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/identifier/MetadataIdentifier.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/identifier/MetadataIdentifier.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/identifier/MetadataIdentifier.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/identifier/MetadataIdentifier.java\n@@ -35,7 +35,7 @@ public String getFilePathKey() {\n     public String getFilePathKey(String pathTag) {\n         return toServicePath() + Constants.PATH_SEPARATOR + pathTag + Constants.PATH_SEPARATOR + (version == null ? \"\" : (version + Constants.PATH_SEPARATOR))\n-                + side + getPathSegment();\n+                + (group == null ? \"\" : (group + Constants.PATH_SEPARATOR)) + side + getPathSegment();\n     }\n     private String toServicePath() {\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n@@ -54,14 +54,14 @@ public static void main(String[] args) throws Exception {\n     public static void testStartupConfig() {\n         String str = \"dubbo.registry.address=zookeeper://127.0.0.1:2181\\n\" +\n                 \"dubbo.registry.group=dubboregistrygroup1\\n\" +\n-                \"dubbo.servicestore.address=zookeeper://127.0.0.1:2181\\n\" +\n+                \"dubbo.metadatareport.address=zookeeper://127.0.0.1:2181\\n\" +\n                 \"dubbo.protocol.port=20990\\n\" +\n                 \"dubbo.service.org.apache.dubbo.demo.DemoService.timeout=9999\\n\";\n         System.out.println(str);\n         try {\n-            String path = \"/dubboregistrygroup1/config/dubbo.properties\";\n+            String path = \"/dubbo/config/dubbo.properties\";\n             if (client.checkExists().forPath(path) == null) {\n                 client.create().creatingParentsIfNeeded().forPath(path);\n             }",
    "output": "Make demo work"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n@@ -16,14 +16,11 @@\n  */\n package org.apache.dubbo.metadata.integration;\n-import org.apache.commons.lang3.time.DateUtils;\n import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.ConcurrentHashSet;\n-import org.apache.dubbo.common.utils.NamedThreadFactory;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.metadata.definition.ServiceDefinitionBuilder;\n import org.apache.dubbo.metadata.definition.model.FullServiceDefinition;\n@@ -33,13 +30,6 @@\n import org.apache.dubbo.metadata.store.MetadataReportFactory;\n import org.apache.dubbo.rpc.RpcException;\n-import java.util.Calendar;\n-import java.util.Date;\n-import java.util.Random;\n-import java.util.Set;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n import java.util.function.Supplier;\n /**\ndiff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java\n@@ -17,7 +17,6 @@\n package org.apache.dubbo.metadata.support;\n import com.google.gson.Gson;\n-import org.apache.commons.lang3.time.DateUtils;\n import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n@@ -39,7 +38,6 @@\n import java.nio.channels.FileChannel;\n import java.nio.channels.FileLock;\n import java.util.Calendar;\n-import java.util.Date;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Properties;\n@@ -311,10 +309,13 @@ void publishAll() {\n      * @return\n      */\n     long calculateStartTime() {\n-        Date now = new Date();\n-        long nowMill = now.getTime();\n-        long today0 = DateUtils.truncate(now, Calendar.DAY_OF_MONTH).getTime();\n-        long subtract = today0 + ONE_DAY_IN_MIll - nowMill;\n+        Calendar calendar = Calendar.getInstance();\n+        long nowMill = calendar.getTimeInMillis();\n+        calendar.set(Calendar.HOUR_OF_DAY, 0);\n+        calendar.set(Calendar.MINUTE, 0);\n+        calendar.set(Calendar.SECOND, 0);\n+        calendar.set(Calendar.MILLISECOND, 0);\n+        long subtract = calendar.getTimeInMillis() + ONE_DAY_IN_MIll - nowMill;\n         Random r = new Random();\n         return subtract + (FOUR_HOURS_IN_MIll / 2) + r.nextInt(FOUR_HOURS_IN_MIll);\n     }\ndiff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/support/AbstractMetadataReportTest.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/support/AbstractMetadataReportTest.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/support/AbstractMetadataReportTest.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/test/java/org/apache/dubbo/metadata/support/AbstractMetadataReportTest.java\n@@ -27,6 +27,7 @@\n import org.junit.Before;\n import org.junit.Test;\n+import java.util.Calendar;\n import java.util.Collections;\n import java.util.Date;\n import java.util.HashMap;\n@@ -208,11 +209,12 @@ public void testPublishAll() throws ClassNotFoundException {\n     @Test\n     public void testCalculateStartTime() {\n-        for (int i = 0; i < 50; i++) {\n+        for (int i = 0; i < 300; i++) {\n             long t = abstractMetadataReport.calculateStartTime() + System.currentTimeMillis();\n-            Date date = new Date(t);\n-            Assert.assertTrue(date.getHours() >= 2);\n-            Assert.assertTrue(date.getHours() <= 6);\n+            Calendar c = Calendar.getInstance();\n+            c.setTimeInMillis(t);\n+            Assert.assertTrue(c.get(Calendar.HOUR_OF_DAY) >= 2);\n+            Assert.assertTrue(c.get(Calendar.HOUR_OF_DAY) <= 6);\n         }\n     }",
    "output": "Remove dependent and import"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java\n@@ -31,7 +31,6 @@\n import org.apache.dubbo.config.utils.ConfigConverter;\n import org.apache.dubbo.rpc.model.ConsumerMethodModel;\n-import javax.annotation.PostConstruct;\n import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n@@ -509,6 +508,7 @@ && isPrimitive(method.getReturnType())) {\n         return metaData;\n     }\n+    @Parameter(excluded = true)\n     public String getPrefix() {\n         return Constants.DUBBO + \".\" + getTagName(this.getClass());\n     }\n@@ -517,7 +517,6 @@ public String getPrefix() {\n      * TODO\n      * Currently, only support overriding of properties explicitly defined in Config class, doesn't support overriding of customized parameters stored in 'parameters'.\n      */\n-    @PostConstruct\n     public void refresh() {\n         if (init) {\n             return;\n@@ -620,6 +619,7 @@ && isPrimitive(method.getReturnType())) {\n     /**\n      * FIXME check @Parameter(required=true) and any conditions that need to match.\n      */\n+    @Parameter(excluded = true)\n     public boolean isValid() {\n         return true;\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ConfigCenterConfig.java\n@@ -25,7 +25,6 @@\n import org.apache.dubbo.governance.DynamicConfiguration;\n import org.apache.dubbo.governance.DynamicConfigurationFactory;\n-import javax.annotation.PostConstruct;\n import java.io.IOException;\n import java.io.StringReader;\n import java.util.HashMap;\n@@ -40,15 +39,15 @@ public class ConfigCenterConfig extends AbstractConfig {\n     private String address;\n     private String env;\n     private String cluster;\n-    private String namespace;\n+    private String namespace = \"dubbo\";\n     private String appnamespace;\n     private String username;\n     private String password;\n-    private long timeout;\n+    private long timeout = 3000;\n     private boolean priority;\n     private boolean check;\n-    private String dataid;\n+    private String dataid = \"dubbo.properties\";\n     // customized parameters\n     private Map<String, String> parameters;\n@@ -74,10 +73,9 @@ private URL toConfigUrl() {\n         }\n         Map<String, String> map = this.getMetaData();\n-        return new URL(\"config\", username, password, host, port, ConfigCenterConfig.class.getSimpleName(), map);\n+        return new URL(Constants.CONFIG_PROTOCOL, username, password, host, port, ConfigCenterConfig.class.getSimpleName(), map);\n     }\n-    @PostConstruct\n     public void init() throws Exception {\n         // give jvm properties the chance of overriding local configs.\n         refresh();\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/RegistryConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/RegistryConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/RegistryConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/RegistryConfig.java\n@@ -351,6 +351,7 @@ public void setAddParamKeys(String addParamKeys) {\n         this.addParamKeys = addParamKeys;\n     }\n+    @Parameter(excluded = true)\n     public boolean isValid() {\n         // empty protocol will default to 'dubbo'\n         return !StringUtils.isEmpty(address);\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ConfigCenterBean.java\n@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.config.spring;\n+\n+import org.apache.dubbo.config.ConfigCenterConfig;\n+import org.springframework.beans.factory.DisposableBean;\n+import org.springframework.beans.factory.InitializingBean;\n+\n+/**\n+ *\n+ */\n+public class ConfigCenterBean extends ConfigCenterConfig implements InitializingBean, DisposableBean {\n+\n+    @Override\n+    public void afterPropertiesSet() throws Exception {\n+        this.init();\n+    }\n+\n+    @Override\n+    public void destroy() throws Exception {\n+\n+    }\n+}\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboNamespaceHandler.java\n@@ -18,14 +18,14 @@\n import org.apache.dubbo.common.Version;\n import org.apache.dubbo.config.ApplicationConfig;\n-import org.apache.dubbo.config.ConfigCenterConfig;\n import org.apache.dubbo.config.ConsumerConfig;\n import org.apache.dubbo.config.ModuleConfig;\n import org.apache.dubbo.config.MonitorConfig;\n import org.apache.dubbo.config.ProtocolConfig;\n import org.apache.dubbo.config.ProviderConfig;\n import org.apache.dubbo.config.RegistryConfig;\n import org.apache.dubbo.config.ServiceStoreConfig;\n+import org.apache.dubbo.config.spring.ConfigCenterBean;\n import org.apache.dubbo.config.spring.ReferenceBean;\n import org.apache.dubbo.config.spring.ServiceBean;\n import org.springframework.beans.factory.xml.NamespaceHandlerSupport;\n@@ -47,7 +47,7 @@ public void init() {\n         registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true));\n         registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true));\n         registerBeanDefinitionParser(\"servicestore\", new DubboBeanDefinitionParser(ServiceStoreConfig.class, true));\n-        registerBeanDefinitionParser(\"configcenter\", new DubboBeanDefinitionParser(ConfigCenterConfig.class, true));\n+        registerBeanDefinitionParser(\"configcenter\", new DubboBeanDefinitionParser(ConfigCenterBean.class, true));\n         registerBeanDefinitionParser(\"monitor\", new DubboBeanDefinitionParser(MonitorConfig.class, true));\n         registerBeanDefinitionParser(\"provider\", new DubboBeanDefinitionParser(ProviderConfig.class, true));\n         registerBeanDefinitionParser(\"consumer\", new DubboBeanDefinitionParser(ConsumerConfig.class, true));",
    "output": "Add xml schema and spring bean support for ConfigCenterConfig"
  },
  {
    "input": "diff --git a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n--- a/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n+++ b/dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java\n@@ -57,9 +57,9 @@ public class MetadataReportService {\n     URL metadataReportUrl;\n     MetadataReportService(URL metadataReportURL) {\n-        if (Constants.SERVICE_STORE_KEY.equals(metadataReportURL.getProtocol())) {\n-            String protocol = metadataReportURL.getParameter(Constants.SERVICE_STORE_KEY, Constants.DEFAULT_DIRECTORY);\n-            metadataReportURL = metadataReportURL.setProtocol(protocol).removeParameter(Constants.SERVICE_STORE_KEY);\n+        if (Constants.METADATA_REPORT_KEY.equals(metadataReportURL.getProtocol())) {\n+            String protocol = metadataReportURL.getParameter(Constants.METADATA_REPORT_KEY, Constants.DEFAULT_DIRECTORY);\n+            metadataReportURL = metadataReportURL.setProtocol(protocol).removeParameter(Constants.METADATA_REPORT_KEY);\n         }\n         this.metadataReportUrl = metadataReportURL;\n         metadataReport = metadataReportFactory.getMetadataReport(this.metadataReportUrl);",
    "output": "Fix compiler issue"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n@@ -55,7 +55,7 @@ public AbstractDirectory(URL url, RouterChain<T> routerChain) {\n     }\n     public AbstractDirectory(URL url, URL consumerUrl, RouterChain<T> routerChain) {\n-        if (url == null)\n+        if (url == null) {\n             throw new IllegalArgumentException(\"url == null\");\n         }\n         this.url = url;",
    "output": "Fix compiler error after merge master branch"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java\n@@ -32,8 +32,6 @@\n /**\n  * Round robin load balance.\n- *\n- * @author jason\n  */\n public class RoundRobinLoadBalance extends AbstractLoadBalance {\n     public static final String NAME = \"roundrobin\";",
    "output": "Remove author info for RoundRobinLoadBalance"
  },
  {
    "input": "diff --git a/dubbo-governance/dubbo-governance-zookeeper/src/main/java/org/apache/dubbo/governance/support/archaius/sources/ZooKeeperConfigurationSource.java b/dubbo-governance/dubbo-governance-zookeeper/src/main/java/org/apache/dubbo/governance/support/archaius/sources/ZooKeeperConfigurationSource.java\n--- a/dubbo-governance/dubbo-governance-zookeeper/src/main/java/org/apache/dubbo/governance/support/archaius/sources/ZooKeeperConfigurationSource.java\n+++ b/dubbo-governance/dubbo-governance-zookeeper/src/main/java/org/apache/dubbo/governance/support/archaius/sources/ZooKeeperConfigurationSource.java\n@@ -49,7 +49,7 @@ public class ZooKeeperConfigurationSource implements WatchedConfigurationSource,\n     public static final String ARCHAIUS_SOURCE_ADDRESS_KEY = \"archaius.zk.address\";\n     public static final String ARCHAIUS_CONFIG_ROOT_PATH_KEY = \"archaius.zk.rootpath\";\n     public static final String ARCHAIUS_CONFIG_CHECK_KEY = \"archaius.zk.check\";\n-    public static final String DEFAULT_CONFIG_ROOT_PATH = \"/dubbo/config\";\n+    public static final String DEFAULT_CONFIG_ROOT_PATH = \"/dubbo\";\n     private static final Logger logger = LoggerFactory.getLogger(ZooKeeperConfigurationSource.class);\n     private Executor executor = Executors.newFixedThreadPool(1);\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java\n@@ -202,6 +202,13 @@ private <T> URL overrideUrlWithConfig(URL providerUrl) {\n         return providerUrl;\n     }\n+    /**\n+     * generate a url contains configuration items for config center.\n+     * if no configuration item found, use registry url instead.\n+     *\n+     * @param registryUrl\n+     * @return\n+     */\n     private URL getConfigUrl(URL registryUrl) {\n         Map<String, String> qs = StringUtils.parseQueryString(registryUrl.getParameterAndDecoded(REFER_KEY));\n         URL url = registryUrl\n@@ -217,6 +224,11 @@ private URL getConfigUrl(URL registryUrl) {\n         if (StringUtils.isNotEmpty(configAddress)) {\n             url = url.setAddress(configAddress);\n         }\n+\n+        String configNamespace = registryUrl.getParameter(Constants.CONFIG_NAMESPACE_KEY);\n+        if (StringUtils.isEmpty(configNamespace)) {\n+            url = url.addParameter(Constants.CONFIG_NAMESPACE_KEY, registryUrl.getParameter(Constants.GROUP_KEY, Constants.DEFAULT_PROTOCOL));\n+        }\n         return url;\n     }",
    "output": "Change the default root directory of zookeeper config center from '/dubbo/config' to '/dubbo'"
  },
  {
    "input": "diff --git a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java\n@@ -32,6 +32,7 @@\n import org.apache.dubbo.servicedata.store.ServiceStore;\n import org.apache.dubbo.servicedata.store.ServiceStoreFactory;\n+import java.util.Calendar;\n import java.util.Date;\n import java.util.Random;\n import java.util.Set;\n@@ -126,8 +127,7 @@ void publishAll() {\n     long calculateStartTime() {\n         Date now = new Date();\n         long nowMill = now.getTime();\n-        // FIXME\n-        long today0 = 0;\n+        long today0 = DateUtils.truncate(now, Calendar.DAY_OF_MONTH).getTime();\n         long subtract = today0 + ONE_DAY_IN_MIll - nowMill;\n         Random r = new Random();\n         return subtract + (FOUR_HOURS_IN_MIll / 2) + r.nextInt(FOUR_HOURS_IN_MIll);",
    "output": "Add test scope pom dependency"
  },
  {
    "input": "diff --git a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java\n@@ -32,7 +32,6 @@\n import org.apache.dubbo.servicedata.store.ServiceStore;\n import org.apache.dubbo.servicedata.store.ServiceStoreFactory;\n-import java.util.Calendar;\n import java.util.Date;\n import java.util.Random;\n import java.util.Set;\n@@ -127,7 +126,8 @@ void publishAll() {\n     long calculateStartTime() {\n         Date now = new Date();\n         long nowMill = now.getTime();\n-        long today0 = DateUtils.truncate(now, Calendar.DAY_OF_MONTH).getTime();\n+        // FIXME\n+        long today0 = 0;\n         long subtract = today0 + ONE_DAY_IN_MIll - nowMill;\n         Random r = new Random();\n         return subtract + (FOUR_HOURS_IN_MIll / 2) + r.nextInt(FOUR_HOURS_IN_MIll);",
    "output": "Add test scope pom dependency"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java\n@@ -250,16 +250,16 @@ public static URL valueOf(String url) {\n         return new URL(protocol, username, password, host, port, path, parameters);\n     }\n-    public static URL valueOf(String url, String... reserveParams){\n+    public static URL valueOf(String url, String... reserveParams) {\n         URL result = valueOf(url);\n-        if (reserveParams == null || reserveParams.length == 0){\n+        if (reserveParams == null || reserveParams.length == 0) {\n             return result;\n         }\n-        Map<String, String> newMap = new HashMap<String,String>(reserveParams.length);\n+        Map<String, String> newMap = new HashMap<String, String>(reserveParams.length);\n         Map<String, String> oldMap = result.getParameters();\n-        for(String reserveParam : reserveParams){\n+        for (String reserveParam : reserveParams) {\n             String tmp = oldMap.get(reserveParam);\n-            if(StringUtils.isNotEmpty(tmp)){\n+            if (StringUtils.isNotEmpty(tmp)) {\n                 newMap.put(reserveParam, tmp);\n             }\n         }\ndiff --git a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/integration/ServiceStoreService.java\n@@ -34,19 +34,16 @@\n import java.util.Calendar;\n import java.util.Date;\n-import java.util.HashSet;\n import java.util.Random;\n import java.util.Set;\n-import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.function.Supplier;\n import static org.apache.dubbo.common.Constants.SERVICE_DESCIPTOR_KEY;\n-/**\n- */\n+\n public class ServiceStoreService {\n     protected final Logger logger = LoggerFactory.getLogger(getClass());\ndiff --git a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/MethodDescriptor.java b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/MethodDescriptor.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/MethodDescriptor.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/MethodDescriptor.java\n@@ -1,7 +1,6 @@\n package org.apache.dubbo.servicedata.metadata;\n import java.util.Arrays;\n-import java.util.Map;\n import java.util.Objects;\n /**\ndiff --git a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/TypeDescriptor.java b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/TypeDescriptor.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/TypeDescriptor.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/TypeDescriptor.java\n@@ -1,7 +1,6 @@\n package org.apache.dubbo.servicedata.metadata;\n import java.util.HashMap;\n-import java.util.List;\n import java.util.Map;\n import java.util.Objects;\ndiff --git a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilder.java b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilder.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilder.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilder.java\n@@ -9,7 +9,6 @@\n import java.net.URL;\n import java.security.CodeSource;\n import java.security.ProtectionDomain;\n-import java.util.List;\n /**\n  * @author cvictory ON 2018/9/18",
    "output": "Fix review issue"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n@@ -276,7 +276,7 @@ protected void connect() throws RemotingException {\n             if (!isConnected()) {\n                 throw new RemotingException(this, \"Failed connect to server \" + getRemoteAddress() + \" from \" + getClass().getSimpleName() + \" \"\n                         + NetUtils.getLocalHost() + \" using dubbo version \" + Version.getVersion()\n-                        + \", cause: Connect wait timeout: \" + getTimeout() + \"ms.\");\n+                        + \", cause: Connect wait timeout: \" + getConnectTimeout() + \"ms.\");\n             } else {\n                 if (logger.isInfoEnabled()) {\n                     logger.info(\"Successed connect to server \" + getRemoteAddress() + \" from \" + getClass().getSimpleName() + \" \"\ndiff --git a/dubbo-remoting/dubbo-remoting-grizzly/src/main/java/org/apache/dubbo/remoting/transport/grizzly/GrizzlyClient.java b/dubbo-remoting/dubbo-remoting-grizzly/src/main/java/org/apache/dubbo/remoting/transport/grizzly/GrizzlyClient.java\n--- a/dubbo-remoting/dubbo-remoting-grizzly/src/main/java/org/apache/dubbo/remoting/transport/grizzly/GrizzlyClient.java\n+++ b/dubbo-remoting/dubbo-remoting-grizzly/src/main/java/org/apache/dubbo/remoting/transport/grizzly/GrizzlyClient.java\n@@ -66,7 +66,7 @@ protected void doOpen() throws Throwable {\n                 .setMaxPoolSize(Integer.MAX_VALUE)\n                 .setKeepAliveTime(60L, TimeUnit.SECONDS);\n         builder.setTcpNoDelay(true).setKeepAlive(true)\n-                .setConnectionTimeout(getTimeout())\n+                .setConnectionTimeout(getConnectTimeout())\n                 .setIOStrategy(SameThreadIOStrategy.getInstance());\n         transport = builder.build();\n         transport.setProcessor(filterChainBuilder.build());\ndiff --git a/dubbo-remoting/dubbo-remoting-mina/src/main/java/org/apache/dubbo/remoting/transport/mina/MinaClient.java b/dubbo-remoting/dubbo-remoting-mina/src/main/java/org/apache/dubbo/remoting/transport/mina/MinaClient.java\n--- a/dubbo-remoting/dubbo-remoting-mina/src/main/java/org/apache/dubbo/remoting/transport/mina/MinaClient.java\n+++ b/dubbo-remoting/dubbo-remoting-mina/src/main/java/org/apache/dubbo/remoting/transport/mina/MinaClient.java\n@@ -78,7 +78,7 @@ protected void doOpen() throws Throwable {\n             cfg.setThreadModel(ThreadModel.MANUAL);\n             cfg.getSessionConfig().setTcpNoDelay(true);\n             cfg.getSessionConfig().setKeepAlive(true);\n-            int timeout = getTimeout();\n+            int timeout = getConnectTimeout();\n             cfg.setConnectTimeout(timeout < 1000 ? 1 : timeout / 1000);\n             // set codec.\n             connector.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new MinaCodecAdapter(getCodec(), getUrl(), this)));\n@@ -135,10 +135,10 @@ public void operationComplete(IoFuture future) {\n             }\n         });\n         try {\n-            finish.await(getTimeout(), TimeUnit.MILLISECONDS);\n+            finish.await(getConnectTimeout(), TimeUnit.MILLISECONDS);\n         } catch (InterruptedException e) {\n             throw new RemotingException(this, \"client(url: \" + getUrl() + \") failed to connect to server \" + getRemoteAddress() + \" client-side timeout \"\n-                    + getTimeout() + \"ms (elapsed: \" + (System.currentTimeMillis() - start)\n+                    + getConnectTimeout() + \"ms (elapsed: \" + (System.currentTimeMillis() - start)\n                     + \"ms) from netty client \" + NetUtils.getLocalHost() + \" using dubbo version \"\n                     + Version.getVersion() + \", cause: \" + e.getMessage(), e);\n         }\ndiff --git a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyClient.java b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyClient.java\n@@ -67,7 +67,7 @@ protected void doOpen() throws Throwable {\n         // @see org.jboss.netty.channel.socket.SocketChannelConfig\n         bootstrap.setOption(\"keepAlive\", true);\n         bootstrap.setOption(\"tcpNoDelay\", true);\n-        bootstrap.setOption(\"connectTimeoutMillis\", getTimeout());\n+        bootstrap.setOption(\"connectTimeoutMillis\", getConnectTimeout());\n         final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);\n         bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n             @Override\ndiff --git a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java\n--- a/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java\n+++ b/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java\n@@ -66,10 +66,10 @@ protected void doOpen() throws Throwable {\n                 //.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout())\n                 .channel(NioSocketChannel.class);\n-        if (getTimeout() < 3000) {\n+        if (getConnectTimeout() < 3000) {\n             bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000);\n         } else {\n-            bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout());\n+            bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getConnectTimeout());\n         }\n         bootstrap.handler(new ChannelInitializer() {\n@@ -90,7 +90,7 @@ protected void doConnect() throws Throwable {\n         long start = System.currentTimeMillis();\n         ChannelFuture future = bootstrap.connect(getConnectAddress());\n         try {\n-            boolean ret = future.awaitUninterruptibly(3000, TimeUnit.MILLISECONDS);\n+            boolean ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS);\n             if (ret && future.isSuccess()) {\n                 Channel newChannel = future.channel();\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java\n@@ -148,7 +148,7 @@ protected <T> T doRefer(Class<T> serviceType, URL url) throws RpcException {\n         connectionMonitor.addConnectionManager(connectionManager);\n         RequestConfig requestConfig = RequestConfig.custom()\n-                .setConnectTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT))\n+                .setConnectTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT))\n                 .setSocketTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT))\n                 .build();",
    "output": "Fix a minor issue with doConnect not using getConnectTimeout() in NettyClient * Fixed a minor issue with doConnect not using getConnectTimeout() in NettyClient * Fixed some problems with connectTimeout, CONNECT_TIMEOUT_KEY, timeout, and TIMEOUT_KEY being used incorrectly"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/DelegateExporter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/DelegateExporter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/DelegateExporter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/DelegateExporter.java\n@@ -1,47 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.rpc.support;\n-\n-import org.apache.dubbo.rpc.Exporter;\n-import org.apache.dubbo.rpc.Invoker;\n-\n-/**\n- * DelegateExporter\n- */\n-public class DelegateExporter<T> implements Exporter<T> {\n-\n-    private final Exporter<T> exporter;\n-\n-    public DelegateExporter(Exporter<T> exporter) {\n-        if (exporter == null) {\n-            throw new IllegalArgumentException(\"exporter can not be null\");\n-        } else {\n-            this.exporter = exporter;\n-        }\n-\n-    }\n-\n-    @Override\n-    public Invoker<T> getInvoker() {\n-        return exporter.getInvoker();\n-    }\n-\n-    @Override\n-    public void unexport() {\n-        exporter.unexport();\n-    }\n-}\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/DelegateInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/DelegateInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/DelegateInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/DelegateInvoker.java\n@@ -1,61 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.rpc.support;\n-\n-import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.rpc.Invocation;\n-import org.apache.dubbo.rpc.Invoker;\n-import org.apache.dubbo.rpc.Result;\n-import org.apache.dubbo.rpc.RpcException;\n-\n-/**\n- * DelegateInvoker\n- */\n-public abstract class DelegateInvoker<T> implements Invoker<T> {\n-\n-    protected final Invoker<T> invoker;\n-\n-    public DelegateInvoker(Invoker<T> invoker) {\n-        this.invoker = invoker;\n-    }\n-\n-    @Override\n-    public Class<T> getInterface() {\n-        return invoker.getInterface();\n-    }\n-\n-    @Override\n-    public URL getUrl() {\n-        return invoker.getUrl();\n-    }\n-\n-    @Override\n-    public boolean isAvailable() {\n-        return invoker.isAvailable();\n-    }\n-\n-    @Override\n-    public Result invoke(Invocation invocation) throws RpcException {\n-        return invoker.invoke(invocation);\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        invoker.destroy();\n-    }\n-\n-}",
    "output": "Remove unuse class. remove unuse classes. readd it if it will be used again"
  },
  {
    "input": "diff --git a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilder.java b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilder.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilder.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilder.java\n@@ -49,7 +49,7 @@ public static ServiceDescriptor build(final Class<?> interfaceClass) {\n         return sd;\n     }\n-    private static String getCodeSource(Class<?> clazz) {\n+    static String getCodeSource(Class<?> clazz) {\n         ProtectionDomain protectionDomain = clazz.getProtectionDomain();\n         if (protectionDomain == null || protectionDomain.getCodeSource() == null) {\n             return null;\ndiff --git a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/TypeDescriptorBuilder.java b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/TypeDescriptorBuilder.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/TypeDescriptorBuilder.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/builder/TypeDescriptorBuilder.java\n@@ -37,7 +37,7 @@ public static TypeDescriptor build(Type type, Class<?> clazz, Map<Class<?>, Type\n         return td;\n     }\n-    private static TypeBuilder getGenericTypeBuilder(Type type, Class<?> clazz) {\n+    static TypeBuilder getGenericTypeBuilder(Type type, Class<?> clazz) {\n         for (TypeBuilder builder : builders) {\n             if (builder.accept(type, clazz)) {\n                 return builder;\n@@ -50,10 +50,6 @@ public TypeDescriptor build(Type type, Class<?> clazz) {\n         return build(type, clazz, typeCache);\n     }\n-    public List<TypeDescriptor> getTypeDescriptor() {\n-        return new ArrayList<TypeDescriptor>(typeCache.values());\n-    }\n-\n     public Map<String, TypeDescriptor> getTypeDescriptorMap() {\n         if (typeCache == null || typeCache.isEmpty()) {\n             return Collections.EMPTY_MAP;\ndiff --git a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilderTest.java b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilderTest.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilderTest.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/ServiceDescriptorBuilderTest.java\n@@ -0,0 +1,25 @@\n+package org.apache.dubbo.servicedata.metadata.builder;\n+\n+import org.apache.dubbo.servicedata.metadata.ServiceDescriptor;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * @author cvictory ON 2018/9/29\n+ */\n+public class ServiceDescriptorBuilderTest {\n+\n+    @Test\n+    public void testGetCodeSource(){\n+        String codeSource = ServiceDescriptorBuilder.getCodeSource(ServiceDescriptorBuilder.class);\n+        Assert.assertNotNull(codeSource);\n+    }\n+\n+    @Test\n+    public void testBuild(){\n+        ServiceDescriptor serviceDescriptor = ServiceDescriptorBuilder.build(TestService.class);\n+        Assert.assertNotNull(serviceDescriptor);\n+        Assert.assertTrue(serviceDescriptor.getMethodDescriptors().size() == 17);\n+        Assert.assertTrue(serviceDescriptor.getTypes().size() == 4);\n+    }\n+}\ndiff --git a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/TestService.java b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/TestService.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/TestService.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/TestService.java\n@@ -40,4 +40,6 @@ public interface TestService {\n     void testWriteComplexMap(Map<String, String> arg, Map<String, ComplexObject> complexObjects);\n     Map<String, ComplexObject> testReadComplexMap(int i);\n+\n+    void testWriteComplexObject(ComplexObject complexObject);\n }\ndiff --git a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/TypeDescriptorBuilderTest.java b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/TypeDescriptorBuilderTest.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/TypeDescriptorBuilderTest.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/TypeDescriptorBuilderTest.java\n@@ -0,0 +1,101 @@\n+package org.apache.dubbo.servicedata.metadata.builder;\n+\n+import org.apache.dubbo.servicedata.metadata.TypeDescriptor;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * @author cvictory ON 2018/9/29\n+ */\n+public class TypeDescriptorBuilderTest {\n+\n+\n+    @Test\n+    public void testStaticBuildWhenSimpleArray() throws NoSuchMethodException {\n+        Class targetClass = TestService.class;\n+        Method method = targetClass.getMethod(\"testWriteSimpleArray\", String[].class);\n+        Map<Class<?>, TypeDescriptor> cache = new HashMap<Class<?>, TypeDescriptor>();\n+        Class<?>[] paramTypes = method.getParameterTypes();\n+        Type[] genericParamTypes = method.getGenericParameterTypes();\n+\n+        TypeDescriptor td = TypeDescriptorBuilder.build(genericParamTypes[0], paramTypes[0], cache);\n+        System.out.println(td);\n+        Assert.assertNotNull(td);\n+        Assert.assertEquals(td.getType(), \"java.lang.String[]\");\n+\n+        Method readMethod = targetClass.getMethod(\"testReadSimpleArray\", int.class);\n+        Class returnType = readMethod.getReturnType();\n+        Type genericReturnType = readMethod.getGenericReturnType();\n+        TypeDescriptor rTd = TypeDescriptorBuilder.build(genericReturnType, returnType, cache);\n+        Assert.assertNotNull(rTd);\n+        Assert.assertEquals(rTd.getType(), \"java.lang.String[]\");\n+\n+        Assert.assertTrue(cache.isEmpty());\n+    }\n+\n+    @Test\n+    public void testStaticBuildWhenComplextObject() throws NoSuchMethodException {\n+\n+        Class targetClass = TestService.class;\n+        Method method = targetClass.getMethod(\"testWriteComplexObject\", ComplexObject.class);\n+        Map<Class<?>, TypeDescriptor> cache = new HashMap<Class<?>, TypeDescriptor>();\n+        Class<?>[] paramTypes = method.getParameterTypes();\n+        Type[] genericParamTypes = method.getGenericParameterTypes();\n+\n+\n+        TypeDescriptor td = TypeDescriptorBuilder.build(genericParamTypes[0], paramTypes[0], cache);\n+        Assert.assertNotNull(td);\n+        Assert.assertEquals(td.getType(), \"org.apache.dubbo.servicedata.metadata.builder.ComplexObject\");\n+        Assert.assertTrue(td.isCustom());\n+        Assert.assertTrue(td.getProperties().entrySet().size() >= 4);\n+\n+        Assert.assertTrue(cache.size() == 2);\n+        Assert.assertEquals(td, cache.get(ComplexObject.class));\n+        Assert.assertNotNull(cache.get(ComplexObject.ComplexInnerObject.class));\n+    }\n+\n+    /**\n+     * test builder and getTypeDescriptorMap method.\n+     *\n+     * @throws NoSuchMethodException\n+     */\n+    @Test\n+    public void testBuildWhenComplextObject() throws NoSuchMethodException {\n+        TypeDescriptorBuilder typeDescriptorBuilder = new TypeDescriptorBuilder();\n+\n+        Class targetClass = TestService.class;\n+        Method method = targetClass.getMethod(\"testWriteComplexObject\", ComplexObject.class);\n+        Class<?>[] paramTypes = method.getParameterTypes();\n+        Type[] genericParamTypes = method.getGenericParameterTypes();\n+\n+\n+        TypeDescriptor td = typeDescriptorBuilder.build(genericParamTypes[0], paramTypes[0]);\n+        Assert.assertNotNull(td);\n+        Assert.assertEquals(td.getType(), \"org.apache.dubbo.servicedata.metadata.builder.ComplexObject\");\n+        Assert.assertTrue(td.isCustom());\n+        Assert.assertTrue(td.getProperties().entrySet().size() >= 4);\n+\n+        Assert.assertTrue(typeDescriptorBuilder.getTypeDescriptorMap().size() == 2);\n+        Assert.assertEquals(td, typeDescriptorBuilder.getTypeDescriptorMap().get(ComplexObject.class.getName()));\n+        Assert.assertNotNull(typeDescriptorBuilder.getTypeDescriptorMap().get(ComplexObject.ComplexInnerObject.class.getName()));\n+    }\n+\n+    @Test\n+    public void testGetGenericTypeBuilder() {\n+        Assert.assertNull(TypeDescriptorBuilder.getGenericTypeBuilder(null, ComplexObject.class));\n+        Assert.assertNotNull(TypeDescriptorBuilder.getGenericTypeBuilder(null, String[].class));\n+        Assert.assertTrue(TypeDescriptorBuilder.getGenericTypeBuilder(null, String[].class) instanceof ArrayTypeBuilder);\n+        Assert.assertNotNull(TypeDescriptorBuilder.getGenericTypeBuilder(null, ArrayList.class));\n+        Assert.assertTrue(TypeDescriptorBuilder.getGenericTypeBuilder(null, ArrayList.class) instanceof CollectionTypeBuilder);\n+        Assert.assertNotNull(TypeDescriptorBuilder.getGenericTypeBuilder(null, HashMap.class));\n+        Assert.assertTrue(TypeDescriptorBuilder.getGenericTypeBuilder(null, HashMap.class) instanceof MapTypeBuilder);\n+        Assert.assertNotNull(TypeDescriptorBuilder.getGenericTypeBuilder(null, SingleEnum.class));\n+        Assert.assertTrue(TypeDescriptorBuilder.getGenericTypeBuilder(null, SingleEnum.class) instanceof EnumTypeBuilder);\n+    }\n+}",
    "output": "Add unit test"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConfigUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConfigUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConfigUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConfigUtils.java\n@@ -217,7 +217,8 @@ public static Properties loadProperties(String fileName, boolean allowMultiFile)\n      */\n     public static Properties loadProperties(String fileName, boolean allowMultiFile, boolean optional) {\n         Properties properties = new Properties();\n-        if (fileName.startsWith(\"/\")) {\n+        // add scene judgement in windows environment Fix 2557\n+        if (fileName.startsWith(\"/\") || fileName.matches(\"^[A-z]:\\\\\\\\\\\\S+$\")) {\n             try {\n                 FileInputStream input = new FileInputStream(fileName);\n                 try {\n@@ -328,4 +329,4 @@ public static int getServerShutdownTimeout() {\n         return timeout;\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Upgrade ConfigUtils.java"
  },
  {
    "input": "diff --git a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/ServiceDescriptor.java b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/ServiceDescriptor.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/ServiceDescriptor.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/metadata/ServiceDescriptor.java\n@@ -14,9 +14,13 @@ public class ServiceDescriptor {\n     private List<MethodDescriptor> methodDescriptors = new ArrayList<>();\n     /**\n      * Primitive type and String will not be stored.\n+     *\n+     * The typeDescriptor will not store\n      */\n     private Map<String, TypeDescriptor> types = new HashMap<>();\n+\n+\n     public String getName() {\n         return name;\n     }\ndiff --git a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/ArrayTypeBuilderTest.java b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/ArrayTypeBuilderTest.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/ArrayTypeBuilderTest.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/metadata/builder/ArrayTypeBuilderTest.java\n@@ -0,0 +1,36 @@\n+package org.apache.dubbo.servicedata.metadata.builder;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.lang.reflect.Array;\n+\n+/**\n+ * @author cvictory ON 2018/9/20\n+ */\n+public class ArrayTypeBuilderTest {\n+\n+    private ArrayTypeBuilder arrayTypeBuilder = new ArrayTypeBuilder();\n+\n+    @Test\n+    public void testAcceptWhenArray(){\n+        String[] param = new String[2];\n+        Class c = param.getClass();\n+        Assert.assertTrue(arrayTypeBuilder.accept(null, c));\n+    }\n+\n+    @Test\n+    public void testAcceptWhenNull(){\n+        Assert.assertFalse(arrayTypeBuilder.accept(null, null));\n+    }\n+\n+    @Test\n+    public void testAcceptWhenOtherClass(){\n+        Assert.assertFalse(arrayTypeBuilder.accept(null, Array.class));\n+    }\n+\n+//    @Test\n+//    public void testBuildWhenNotArray(){\n+//        arrayTypeBuilder.build()\n+//    }\n+}",
    "output": "Add tests"
  },
  {
    "input": "diff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java b/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java\n@@ -33,7 +33,7 @@\n import static org.junit.Assert.fail;\n import static org.junit.matchers.JUnitMatchers.containsString;\n-public abstract class AbstractSerializationPersionFailTest extends AbstractSerializationTest {\n+public abstract class AbstractSerializationPersonFailTest extends AbstractSerializationTest {\n     @Test\n     public void test_Person() throws Exception {\n         try {\ndiff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java b/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java\n@@ -27,7 +27,7 @@\n import java.util.Map;\n import java.util.Set;\n-public abstract class AbstractSerializationPersionOkTest extends AbstractSerializationTest {\n+public abstract class AbstractSerializationPersonOkTest extends AbstractSerializationTest {\n     @Test\n     public void test_Person() throws Exception {\n         assertObject(new Person());\ndiff --git a/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/Hessian2SerializationTest.java b/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/Hessian2SerializationTest.java\n--- a/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/Hessian2SerializationTest.java\n+++ b/dubbo-serialization/dubbo-serialization-hessian2/src/test/java/org/apache/dubbo/common/serialize/serialization/Hessian2SerializationTest.java\n@@ -30,7 +30,7 @@\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n-public class Hessian2SerializationTest extends AbstractSerializationPersionFailTest {\n+public class Hessian2SerializationTest extends AbstractSerializationPersonFailTest {\n     {\n         serialization = new Hessian2Serialization();\n     }\ndiff --git a/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java b/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java\n--- a/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java\n+++ b/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java\n@@ -33,7 +33,7 @@\n import static org.junit.Assert.fail;\n import static org.junit.matchers.JUnitMatchers.containsString;\n-public abstract class AbstractSerializationPersionFailTest extends AbstractSerializationTest {\n+public abstract class AbstractSerializationPersonFailTest extends AbstractSerializationTest {\n     @Test\n     public void test_Person() throws Exception {\n         try {\ndiff --git a/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java b/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java\n--- a/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java\n+++ b/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java\n@@ -27,7 +27,7 @@\n import java.util.Map;\n import java.util.Set;\n-public abstract class AbstractSerializationPersionOkTest extends AbstractSerializationTest {\n+public abstract class AbstractSerializationPersonOkTest extends AbstractSerializationTest {\n     @Test\n     public void test_Person() throws Exception {\n         assertObject(new Person());\ndiff --git a/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/CompactedJavaSerializationTest.java b/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/CompactedJavaSerializationTest.java\n--- a/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/CompactedJavaSerializationTest.java\n+++ b/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/CompactedJavaSerializationTest.java\n@@ -19,7 +19,7 @@\n import org.apache.dubbo.common.serialize.java.CompactedJavaSerialization;\n-public class CompactedJavaSerializationTest extends AbstractSerializationPersionFailTest {\n+public class CompactedJavaSerializationTest extends AbstractSerializationPersonFailTest {\n     {\n         serialization = new CompactedJavaSerialization();\n     }\ndiff --git a/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/JavaSerializationTest.java b/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/JavaSerializationTest.java\n--- a/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/JavaSerializationTest.java\n+++ b/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/JavaSerializationTest.java\n@@ -19,7 +19,7 @@\n import org.apache.dubbo.common.serialize.java.JavaSerialization;\n-public class JavaSerializationTest extends AbstractSerializationPersionFailTest {\n+public class JavaSerializationTest extends AbstractSerializationPersonFailTest {\n     {\n         serialization = new JavaSerialization();\n     }\ndiff --git a/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/NativeJavaSerializationTest.java b/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/NativeJavaSerializationTest.java\n--- a/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/NativeJavaSerializationTest.java\n+++ b/dubbo-serialization/dubbo-serialization-jdk/src/test/java/org/apache/dubbo/common/serialize/serialization/NativeJavaSerializationTest.java\n@@ -18,7 +18,7 @@\n import org.apache.dubbo.common.serialize.nativejava.NativeJavaSerialization;\n-public class NativeJavaSerializationTest extends AbstractSerializationPersionFailTest {\n+public class NativeJavaSerializationTest extends AbstractSerializationPersonFailTest {\n     {\n         serialization = new NativeJavaSerialization();\n     }\ndiff --git a/dubbo-serialization/dubbo-serialization-kryo/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java b/dubbo-serialization/dubbo-serialization-kryo/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java\n--- a/dubbo-serialization/dubbo-serialization-kryo/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java\n+++ b/dubbo-serialization/dubbo-serialization-kryo/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonFailTest.java\n@@ -33,7 +33,7 @@\n import static org.junit.Assert.fail;\n import static org.junit.matchers.JUnitMatchers.containsString;\n-public abstract class AbstractSerializationPersionFailTest extends AbstractSerializationTest {\n+public abstract class AbstractSerializationPersonFailTest extends AbstractSerializationTest {\n     @Test\n     public void test_Person() throws Exception {\n         try {\ndiff --git a/dubbo-serialization/dubbo-serialization-kryo/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java b/dubbo-serialization/dubbo-serialization-kryo/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java\n--- a/dubbo-serialization/dubbo-serialization-kryo/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java\n+++ b/dubbo-serialization/dubbo-serialization-kryo/src/test/java/org/apache/dubbo/common/serialize/serialization/AbstractSerializationPersonOkTest.java\n@@ -27,7 +27,7 @@\n import java.util.Map;\n import java.util.Set;\n-public abstract class AbstractSerializationPersionOkTest extends AbstractSerializationTest {\n+public abstract class AbstractSerializationPersonOkTest extends AbstractSerializationTest {\n     @Test\n     public void test_Person() throws Exception {\n         assertObject(new Person());",
    "output": "Fix typos in serialization unit tests"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/ConfigTest.java\n@@ -244,7 +244,7 @@ public void testDelayFixedTime() throws Exception {\n             }\n             assertNotNull(urls);\n             assertEquals(1, urls.size());\n-            assertEquals(\"dubbo://\" + NetUtils.getLocalHost() + \":20883/org.apache.dubbo.config.spring.api.DemoService\", urls.get(0).toIdentityString());\n+            assertEquals(\"dubbo://\" + NetUtils.getLocalHost() + \":20888/org.apache.dubbo.config.spring.api.DemoService\", urls.get(0).toIdentityString());\n         } finally {\n             ctx.stop();\n             ctx.close();\n@@ -262,7 +262,7 @@ public void testDelayOnInitialized() throws Exception {\n             List<URL> urls = registryService.getRegistered().get(\"org.apache.dubbo.config.spring.api.DemoService\");\n             assertNotNull(urls);\n             assertEquals(1, urls.size());\n-            assertEquals(\"dubbo://\" + NetUtils.getLocalHost() + \":20883/org.apache.dubbo.config.spring.api.DemoService\", urls.get(0).toIdentityString());\n+            assertEquals(\"dubbo://\" + NetUtils.getLocalHost() + \":20888/org.apache.dubbo.config.spring.api.DemoService\", urls.get(0).toIdentityString());\n         } finally {\n             ctx.stop();\n             ctx.close();\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ChangeTelnetHandlerTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ChangeTelnetHandlerTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ChangeTelnetHandlerTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ChangeTelnetHandlerTest.java\n@@ -64,7 +64,7 @@ public void setUp() {\n         mockChannel.removeAttribute(\"telnet.service\");\n         givenLastCall();\n         given(mockInvoker.getInterface()).willReturn(DemoService.class);\n-        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20883/demo\"));\n+        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20884/demo\"));\n     }\n     private void givenLastCall() {\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java\n@@ -57,12 +57,12 @@ public void after() {\n     public void testInvokeDefaultSService() throws RemotingException {\n         mockInvoker = mock(Invoker.class);\n         given(mockInvoker.getInterface()).willReturn(DemoService.class);\n-        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20883/demo\"));\n+        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20886/demo\"));\n         given(mockInvoker.invoke(any(Invocation.class))).willReturn(new RpcResult(\"ok\"));\n         mockChannel = mock(Channel.class);\n         given(mockChannel.getAttribute(\"telnet.service\")).willReturn(\"org.apache.dubbo.rpc.protocol.dubbo.support.DemoService\");\n         given(mockChannel.getLocalAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:5555\"));\n-        given(mockChannel.getRemoteAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:20883\"));\n+        given(mockChannel.getRemoteAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:20886\"));\n         DubboProtocol.getDubboProtocol().export(mockInvoker);\n         String result = invoke.telnet(mockChannel, \"DemoService.echo(\\\"ok\\\")\");\n@@ -74,12 +74,12 @@ public void testInvokeDefaultSService() throws RemotingException {\n     public void testInvokeByPassingNullValue() throws RemotingException {\n         mockInvoker = mock(Invoker.class);\n         given(mockInvoker.getInterface()).willReturn(DemoService.class);\n-        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20883/demo\"));\n+        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20886/demo\"));\n         given(mockInvoker.invoke(any(Invocation.class))).willReturn(new RpcResult(\"ok\"));\n         mockChannel = mock(Channel.class);\n         given(mockChannel.getAttribute(\"telnet.service\")).willReturn(\"org.apache.dubbo.rpc.protocol.dubbo.support.DemoService\");\n         given(mockChannel.getLocalAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:5555\"));\n-        given(mockChannel.getRemoteAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:20883\"));\n+        given(mockChannel.getRemoteAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:20886\"));\n         DubboProtocol.getDubboProtocol().export(mockInvoker);\n@@ -113,12 +113,12 @@ public void testInvokeByPassingNullValue() throws RemotingException {\n     public void testInvokeAutoFindMethod() throws RemotingException {\n         mockInvoker = mock(Invoker.class);\n         given(mockInvoker.getInterface()).willReturn(DemoService.class);\n-        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20883/demo\"));\n+        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20886/demo\"));\n         given(mockInvoker.invoke(any(Invocation.class))).willReturn(new RpcResult(\"ok\"));\n         mockChannel = mock(Channel.class);\n         given(mockChannel.getAttribute(\"telnet.service\")).willReturn(null);\n         given(mockChannel.getLocalAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:5555\"));\n-        given(mockChannel.getRemoteAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:20883\"));\n+        given(mockChannel.getRemoteAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:20886\"));\n         DubboProtocol.getDubboProtocol().export(mockInvoker);\n         String result = invoke.telnet(mockChannel, \"echo(\\\"ok\\\")\");",
    "output": "Change unit port"
  },
  {
    "input": "diff --git a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/support/AbstractServiceStore.java b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/support/AbstractServiceStore.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/support/AbstractServiceStore.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/support/AbstractServiceStore.java\n@@ -64,7 +64,7 @@ public abstract class AbstractServiceStore implements ServiceStore {\n     private final AtomicLong lastCacheChanged = new AtomicLong();\n     private final Set<URL> registered = new ConcurrentHashSet<URL>();\n-    private final Set<URL> failedServiceStore = new ConcurrentHashSet<URL>();\n+    final Set<URL> failedServiceStore = new ConcurrentHashSet<URL>();\n     private URL serviceStoreURL;\n     // Local disk cache file\n     private File file;\ndiff --git a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/support/AbstractServiceStoreTest.java b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/support/AbstractServiceStoreTest.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/support/AbstractServiceStoreTest.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/support/AbstractServiceStoreTest.java\n@@ -18,6 +18,7 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.utils.NetUtils;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n@@ -36,7 +37,7 @@ public class AbstractServiceStoreTest {\n     @Before\n     public void before(){\n-        url = URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":4444\");\n+        url = URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":4444/org.apache.dubbo.TestService?version=1.0.0&application=vic\");\n         abstractServiceStore = new AbstractServiceStore(url) {\n@@ -54,7 +55,27 @@ protected URL doPeekService(URL url) {\n     }\n     @Test\n-    public\n+    public void testPutUsual(){\n+        abstractServiceStore.put(url);\n+        Assert.assertNotNull(store.get(url.getServiceKey()));\n+    }\n+\n+    @Test\n+    public void testPutNoServiceKeyUrl(){\n+        URL urlTmp = URL.valueOf(\"rmi://wrongHost:90?application=vic\");\n+        abstractServiceStore.put(urlTmp);\n+        Assert.assertNull(urlTmp.getServiceKey());\n+        // key is null, will add failed list.\n+        Assert.assertFalse(abstractServiceStore.failedServiceStore.isEmpty());\n+    }\n+\n+    @Test\n+    public void testPutNotFullServiceKeyUrl(){\n+        URL urlTmp = URL.valueOf(\"rmi://wrongHost:90/org.dubbo.TestService\");\n+        abstractServiceStore.put(urlTmp);\n+        Assert.assertNotNull(store.get(urlTmp.getServiceKey()));\n+    }\n+\n }",
    "output": "Add test"
  },
  {
    "input": "diff --git a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/support/AbstractServiceStore.java b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/support/AbstractServiceStore.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/support/AbstractServiceStore.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/main/java/org/apache/dubbo/servicedata/support/AbstractServiceStore.java\n@@ -104,15 +104,6 @@ public void run() {\n         }, 100, 100, TimeUnit.MILLISECONDS);\n     }\n-    protected static List<URL> filterEmpty(URL url, List<URL> urls) {\n-        if (urls == null || urls.isEmpty()) {\n-            List<URL> result = new ArrayList<URL>(1);\n-            result.add(url.setProtocol(Constants.EMPTY_PROTOCOL));\n-            return result;\n-        }\n-        return urls;\n-    }\n-\n     public URL getUrl() {\n         return serviceStoreURL;\n     }\n@@ -240,6 +231,8 @@ public void run() {\n     public void put(URL url) {\n         try {\n+            // remove the individul param\n+            url = url.removeParameters(Constants.PID_KEY, Constants.TIMESTAMP_KEY);\n             if (logger.isInfoEnabled()) {\n                 logger.info(\"Servicestore Put: \" + url);\n             }\ndiff --git a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/support/AbstractServiceStoreTest.java b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/support/AbstractServiceStoreTest.java\n--- a/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/support/AbstractServiceStoreTest.java\n+++ b/dubbo-servicedata/dubbo-servicedata-api/src/test/java/org/apache/dubbo/servicedata/support/AbstractServiceStoreTest.java\n@@ -22,6 +22,8 @@\n import org.junit.Test;\n import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n /**\n  *\n@@ -30,6 +32,7 @@ public class AbstractServiceStoreTest {\n     private AbstractServiceStore abstractServiceStore;\n     private URL url;\n+    private Map<String, String> store = new ConcurrentHashMap<>();\n     @Before\n     public void before(){\n@@ -39,7 +42,7 @@ public void before(){\n             @Override\n             protected void doPutService(URL url) {\n-\n+                store.put(url.getServiceKey(), url.toParameterString());\n             }\n             @Override\n@@ -50,5 +53,8 @@ protected URL doPeekService(URL url) {\n     }\n+    @Test\n+    public\n+\n }\ndiff --git a/dubbo-servicedata/dubbo-servicedata-redis/src/main/java/org/apache/dubbo/servicedata/redis/RedisServiceStore.java b/dubbo-servicedata/dubbo-servicedata-redis/src/main/java/org/apache/dubbo/servicedata/redis/RedisServiceStore.java\n--- a/dubbo-servicedata/dubbo-servicedata-redis/src/main/java/org/apache/dubbo/servicedata/redis/RedisServiceStore.java\n+++ b/dubbo-servicedata/dubbo-servicedata-redis/src/main/java/org/apache/dubbo/servicedata/redis/RedisServiceStore.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.servicedata.redis;\n+import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.logger.Logger;\n import org.apache.dubbo.common.logger.LoggerFactory;\n@@ -44,7 +45,7 @@ public RedisServiceStore(URL url) {\n     @Override\n     protected void doPutService(URL url) {\n         try (Jedis jedis = pool.getResource()) {\n-            jedis.set(TAG + url.getServiceKey(), url.toParameterString());\n+            jedis.set(TAG + getProtocol(url) + \".\" + url.getServiceKey(), url.toParameterString());\n         } catch (Throwable e) {\n             logger.error(\"Failed to put \" + url + \" to redis \" + url + \", cause: \" + e.getMessage(), e);\n             throw new RpcException(\"Failed to put \" + url + \" to redis \" + getUrl() + \", cause: \" + e.getMessage(), e);\n@@ -54,13 +55,19 @@ protected void doPutService(URL url) {\n     @Override\n     protected URL doPeekService(URL url) {\n         try (Jedis jedis = pool.getResource()) {\n-            String value = jedis.get(TAG + url.getServiceKey());\n+            String value = jedis.get(TAG + getProtocol(url) + \".\" + url.getServiceKey());\n             return url.addParameterString(value);\n         } catch (Throwable e) {\n             logger.error(\"Failed to peek \" + url + \" to redis \" + url + \", cause: \" + e.getMessage(), e);\n             throw new RpcException(\"Failed to put \" + url + \" to redis \" + getUrl() + \", cause: \" + e.getMessage(), e);\n         }\n     }\n+    private String getProtocol(URL url) {\n+        String protocol = url.getParameter(Constants.SIDE_KEY);\n+        protocol = protocol == null ? url.getProtocol() : protocol;\n+        return protocol;\n+    }\n+\n }",
    "output": "Add redis service store support"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java\n@@ -79,9 +79,18 @@ public static Object compatibleTypeConvert(Object value, Class<?> type) {\n                 return new Byte(string);\n             } else if (type == Boolean.class || type == boolean.class) {\n                 return new Boolean(string);\n-            } else if (type == Date.class) {\n+            } else if (type == Date.class || type == java.sql.Date.class || type == java.sql.Timestamp.class || type == java.sql.Time.class) {\n                 try {\n-                    return new SimpleDateFormat(DATE_FORMAT).parse((String) value);\n+                    Date date = new SimpleDateFormat(DATE_FORMAT).parse((String) value);\n+                    if (type == java.sql.Date.class) {\n+                        return new java.sql.Date(date.getTime());\n+                    } else if (type == java.sql.Timestamp.class) {\n+                        return new java.sql.Timestamp(date.getTime());\n+                    } else if (type == java.sql.Time.class) {\n+                        return new java.sql.Time(date.getTime());\n+                    } else {\n+                        return date;\n+                    }\n                 } catch (ParseException e) {\n                     throw new IllegalStateException(\"Failed to parse date \" + value + \" by format \" + DATE_FORMAT + \", cause: \" + e.getMessage(), e);\n                 }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/CompatibleTypeUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/CompatibleTypeUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/CompatibleTypeUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/CompatibleTypeUtilsTest.java\n@@ -68,6 +68,15 @@ public void testCompatibleTypeConvert() throws Exception {\n             result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11 12:24:12\", Date.class);\n             assertEquals(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").parse(\"2011-12-11 12:24:12\"), (Date) result);\n+            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11 12:24:12\", java.sql.Date.class);\n+            assertEquals(new SimpleDateFormat(\"yyyy-MM-dd\").format((java.sql.Date) result), \"2011-12-11\");\n+\n+            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11 12:24:12\", java.sql.Time.class);\n+            assertEquals(new SimpleDateFormat(\"HH:mm:ss\").format((java.sql.Time) result), \"12:24:12\");\n+\n+            result = CompatibleTypeUtils.compatibleTypeConvert(\"2011-12-11 12:24:12\", java.sql.Timestamp.class);\n+            assertEquals(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format((java.sql.Timestamp) result), \"2011-12-11 12:24:12\");\n+\n             result = CompatibleTypeUtils.compatibleTypeConvert(\"ab\", char[].class);\n             assertEquals(2, ((char[]) result).length);\n             assertEquals('a', ((char[]) result)[0]);\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java\n@@ -28,8 +28,10 @@\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n+import java.text.SimpleDateFormat;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.LinkedList;\n@@ -646,6 +648,34 @@ public void testListPojoListPojo() throws Exception {\n         Assert.assertEquals(parent.getAge(), realizeParent.getAge());\n     }\n+    @Test\n+    public void testDateTimeTimestamp() throws Exception {\n+        String dateStr = \"2018-09-12\";\n+        String timeStr = \"10:12:33\";\n+        String dateTimeStr = \"2018-09-12 10:12:33\";\n+        String[] dateFormat = new String[]{\"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd\", \"HH:mm:ss\"};\n+\n+        //java.util.Date\n+        Object date = PojoUtils.realize(dateTimeStr, Date.class, (Type) Date.class);\n+        assertEquals(Date.class, date.getClass());\n+        assertEquals(dateTimeStr, new SimpleDateFormat(dateFormat[0]).format(date));\n+\n+        //java.sql.Time\n+        Object time = PojoUtils.realize(dateTimeStr, java.sql.Time.class, (Type) java.sql.Time.class);\n+        assertEquals(java.sql.Time.class, time.getClass());\n+        assertEquals(timeStr, new SimpleDateFormat(dateFormat[2]).format(time));\n+\n+        //java.sql.Date\n+        Object sqlDate = PojoUtils.realize(dateTimeStr, java.sql.Date.class, (Type) java.sql.Date.class);\n+        assertEquals(java.sql.Date.class, sqlDate.getClass());\n+        assertEquals(dateStr, new SimpleDateFormat(dateFormat[1]).format(sqlDate));\n+\n+        //java.sql.Timestamp\n+        Object timestamp = PojoUtils.realize(dateTimeStr, java.sql.Timestamp.class, (Type) java.sql.Timestamp.class);\n+        assertEquals(java.sql.Timestamp.class, timestamp.getClass());\n+        assertEquals(dateTimeStr, new SimpleDateFormat(dateFormat[0]).format(timestamp));\n+    }\n+\n     public enum Day {\n         SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY\n     }",
    "output": "Fix PojoUtil realize type convert not support subclasses of 'java.util.date' #2499 * Solve time, timestamp, SQL. Date type conversion problems * add ut"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n@@ -61,9 +61,6 @@ public abstract class AbstractReferenceConfig extends AbstractInterfaceConfig {\n     // group\n     protected String group;\n-    // enable dynamic tag\n-    protected String enabledynamictag;\n-\n     public Boolean isCheck() {\n         return check;\n     }",
    "output": "Remove useless config item in xsd"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/AbstractDynamicConfiguration.java b/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/AbstractDynamicConfiguration.java\n--- a/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/AbstractDynamicConfiguration.java\n+++ b/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/AbstractDynamicConfiguration.java\n@@ -29,7 +29,7 @@ public abstract class AbstractDynamicConfiguration<TargetConfigListener> impleme\n     /**\n      * One key can register multiple target listeners, but one target listener only maps to one configuration listener\n      */\n-    private ConcurrentMap<String, ConcurrentMap<ConfigurationListener, TargetConfigListener>> listenerToTargetListenerMap;\n+    private ConcurrentMap<String, ConcurrentMap<ConfigurationListener, TargetConfigListener>> listenerToTargetListenerMap = new ConcurrentHashMap<>();\n     public AbstractDynamicConfiguration() {\n     }\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ZKTools.java\n@@ -43,7 +43,7 @@ public static void main(String[] args) throws Exception {\n                 new ExponentialBackoffRetry(1000, 3));\n         client.start();\n-        testConsumerConfig();\n+        testProviderConfig();\n //        testPathCache();\n //        testTreeCache();\n //        testCuratorListener();",
    "output": "Fix compilation problem"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java\n@@ -82,6 +82,7 @@ public void run() {\n                     logger.warn(\"ChannelEventRunnable handle \" + state + \" operation error, channel is \" + channel\n                             + \", message is \" + message, e);\n                 }\n+                break;\n             case CAUGHT:\n                 try {\n                     handler.caught(channel, exception);",
    "output": "Fix switch-case fall through in ChannelEventRunnable"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/support/nop/NopDynamicConfiguration.java b/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/support/nop/NopDynamicConfiguration.java\n--- a/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/support/nop/NopDynamicConfiguration.java\n+++ b/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/support/nop/NopDynamicConfiguration.java\n@@ -17,19 +17,30 @@\n package org.apache.dubbo.config.dynamic.support.nop;\n import org.apache.dubbo.config.dynamic.AbstractDynamicConfiguration;\n+import org.apache.dubbo.config.dynamic.ConfigurationListener;\n /**\n  *\n  */\n public class NopDynamicConfiguration extends AbstractDynamicConfiguration {\n     @Override\n-    protected String getInternalProperty(String key, String group, long timeout) {\n+    public void init() {\n+\n+    }\n+\n+    @Override\n+    protected String getInternalProperty(String key, String group, long timeout, ConfigurationListener listener) {\n         return null;\n     }\n     @Override\n-    public void init() {\n+    protected void addTargetListener(String key, Object o) {\n+\n+    }\n+    @Override\n+    protected Object createTargetConfigListener(String key, ConfigurationListener listener) {\n+        return null;\n     }\n }",
    "output": "Fix compilation problem"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/InvokerTreeCache.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/InvokerTreeCache.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/InvokerTreeCache.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/InvokerTreeCache.java\n@@ -31,7 +31,7 @@\n  */\n public class InvokerTreeCache<T> {\n-    TreeNode<T> tree;\n+    private TreeNode<T> tree;\n     public TreeNode buildTree() {\n         tree = new TreeNode<>();\n@@ -43,7 +43,7 @@ public TreeNode buildTree() {\n     public List<Invoker<T>> getInvokers(TreeNode<T> node, URL url, Invocation invocation) {\n         // We have reached the leaf node.\n-        if (node.getChildren() == null || node.getChildren().size() == 0) {\n+        if (node.isLeaf()) {\n             return node.getInvokers();\n         }\n@@ -102,7 +102,7 @@ public List<Invoker<T>> getInvokers(TreeNode<T> node, URL url, Invocation invoca\n             String forceKey = \"force.\" + failoverNode.getConditionKey();\n             if (Boolean.valueOf(invocation.getAttachment(forceKey, url.getParameter(forceKey, \"false\")))) {\n                 /**\n-                 * This may mistakely return empty list for runtime routers\n+                 * This may mistakenly return empty list for runtime routers\n                  * see {@link org.apache.dubbo.rpc.cluster.router.tag.TagRouter.getKey()} for the workaround.\n                  */\n                 return Collections.emptyList();\ndiff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java\n@@ -132,7 +132,8 @@ public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation\n             // dynamic tag group doesn't have any item about the requested app OR it's null after filtered by dynamic tag group but force=false.\n             // check static tag\n             result = filterInvoker(invokers, invoker -> tag.equals(invoker.getUrl().getParameter(Constants.TAG_KEY)));\n-            if (CollectionUtils.isNotEmpty(result) || url.getParameter(Constants.FORCE_USE_TAG, true)) {\n+            // If there's no tagged providers that can match the value in this tag. force.tag is set by default to true, which means it will not invoker any providers without a tag unless it's explicitly allowed.\n+            if (CollectionUtils.isNotEmpty(result) || Boolean.valueOf(invocation.getAttachment(Constants.FORCE_USE_TAG, url.getParameter(Constants.FORCE_USE_TAG, \"false\")))) {\n                 return result;\n             }\n             // FAILOVER: return all Providers without any tags.",
    "output": "Fix small bugs and add comments"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/support/archaius/sources/ZooKeeperConfigurationSource.java b/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/support/archaius/sources/ZooKeeperConfigurationSource.java\n--- a/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/support/archaius/sources/ZooKeeperConfigurationSource.java\n+++ b/dubbo-config/dubbo-config-dynamic/src/main/java/org/apache/dubbo/config/dynamic/support/archaius/sources/ZooKeeperConfigurationSource.java\n@@ -117,6 +117,9 @@ public void childEvent(CuratorFramework aClient, TreeCacheEvent event)\n                 TreeCacheEvent.Type type = event.getType();\n                 ChildData data = event.getData();\n+                if (type == TreeCacheEvent.Type.INITIALIZED || type == TreeCacheEvent.Type.CONNECTION_RECONNECTED) {\n+                    connected = true;\n+                }\n                 // TODO, ignore other event types\n                 if (data == null) {",
    "output": "Upgrade config connecting status when ZK connection changes"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n--- a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java\n@@ -39,7 +39,7 @@ public void init() {\n     public void normalTagRuleTest() {\n         String serviceStr = \"---\\n\" +\n                 \"force: true\\n\" +\n-                \"runtime: false\\n\" +\n+                \"runtime: true\\n\" +\n                 \"enabled: true\\n\" +\n                 \"priority: 1\\n\" +\n                 \"key: demo-provider\\n\" +",
    "output": "Remove duplicate ut classes"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ConfigConditionRouterTest.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ConfigConditionRouterTest.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ConfigConditionRouterTest.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/ConfigConditionRouterTest.java\n@@ -1,62 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.registry;\n-\n-import org.apache.curator.framework.CuratorFramework;\n-import org.apache.curator.framework.CuratorFrameworkFactory;\n-import org.apache.curator.retry.ExponentialBackoffRetry;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-/**\n- * FIXME This is not a formal UT\n- */\n-public class ConfigConditionRouterTest {\n-    private static CuratorFramework client;\n-\n-    @Before\n-    public void init() {\n-        client = CuratorFrameworkFactory.newClient(\"127.0.0.1:2181\", 60 * 1000, 60 * 1000,\n-                new ExponentialBackoffRetry(1000, 3));\n-        client.start();\n-    }\n-\n-    @Test\n-    public void normalConditionRuleTest() {\n-        String serviceStr = \"---\\n\" +\n-                \"scope: application\\n\" +\n-                \"force: true\\n\" +\n-                \"runtime: false\\n\" +\n-                \"conditions:\\n\" +\n-                \"  - method!=sayHello =>\\n\" +\n-                \"  - method=routeMethod1 => 30.5.121.156:20880\\n\" +\n-                \"...\";\n-        try {\n-            String servicePath = \"/dubbo/config//\";\n-            if (client.checkExists().forPath(servicePath) == null) {\n-                client.create().creatingParentsIfNeeded().forPath(servicePath);\n-            }\n-            setData(servicePath, serviceStr);\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private void setData(String path, String data) throws Exception {\n-        client.setData().forPath(path, data.getBytes());\n-    }\n-}\ndiff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/TagRouterTest.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/TagRouterTest.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/TagRouterTest.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/TagRouterTest.java\n@@ -1,46 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.registry;\n-\n-import org.apache.curator.framework.CuratorFramework;\n-import org.apache.curator.framework.CuratorFrameworkFactory;\n-import org.apache.curator.retry.ExponentialBackoffRetry;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-/**\n- * FIXME This is not a formal UT\n- */\n-public class TagRouterTest {\n-    private static CuratorFramework client;\n-\n-    @Before\n-    public void init() {\n-        client = CuratorFrameworkFactory.newClient(\"127.0.0.1:2181\", 60 * 1000, 60 * 1000,\n-                new ExponentialBackoffRetry(1000, 3));\n-        client.start();\n-    }\n-\n-    @Test\n-    public void normalTagRuleTest() {\n-\n-    }\n-\n-    private void setData(String path, String data) throws Exception {\n-        client.setData().forPath(path, data.getBytes());\n-    }\n-}",
    "output": "Remove duplicate ut classes"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java\n@@ -61,6 +61,9 @@ public abstract class AbstractReferenceConfig extends AbstractInterfaceConfig {\n     // group\n     protected String group;\n+    // enable dynamic tag\n+    protected String enabledynamictag;\n+\n     public Boolean isCheck() {\n         return check;\n     }\ndiff --git a/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java b/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java\n--- a/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java\n+++ b/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java\n@@ -17,6 +17,7 @@\n package org.apache.dubbo.demo.consumer;\n import org.apache.dubbo.demo.DemoService;\n+import org.apache.dubbo.rpc.RpcContext;\n import org.springframework.context.support.ClassPathXmlApplicationContext;\n public class Consumer {\n@@ -33,8 +34,11 @@ public static void main(String[] args) {\n         while (true) {\n             try {\n                 Thread.sleep(1000);\n+                RpcContext.getContext().setAttachment(\"tag\", \"tag1\");\n                 String hello = demoService.sayHello(\"world\"); // call remote method\n                 System.out.println(hello); // get result\n+                RpcContext.getContext().setAttachment(\"tag\", \"tag3\");\n+                RpcContext.getContext().setAttachment(\"force.tag\", \"true\");\n                 String routeMethod1 = demoService.routeMethod1(); // call remote method\n                 System.out.println(routeMethod1); // get result\n             } catch (Throwable throwable) {\ndiff --git a/dubbo-demo/dubbo-demo-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java b/dubbo-demo/dubbo-demo-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java\n--- a/dubbo-demo/dubbo-demo-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java\n+++ b/dubbo-demo/dubbo-demo-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java\n@@ -32,11 +32,13 @@ public String sayHello(String name) {\n     @Override\n     public String routeMethod1() {\n+        System.out.println(\"routeMethod1 was called: \" + RpcContext.getContext().getLocalAddress());\n         return \"routeMethod1\";\n     }\n     @Override\n     public String routeMethod2() {\n+        System.out.println(\"routeMethod2 was called: \" + RpcContext.getContext().getLocalAddress());\n         return \"routeMethod2\";\n     }",
    "output": "Add demo change for tagrouter"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/io/StreamUtils.java\n@@ -98,6 +98,7 @@ public void reset() throws IOException {\n             @Override\n             public void close() throws IOException {\n+                is.close();\n             }\n         };\n     }\n@@ -199,6 +200,11 @@ public int available() throws IOException {\n                 return available;\n             }\n+\n+            @Override\n+            public void close() throws IOException {\n+                is.close();\n+            }\n         };\n     }\ndiff --git a/dubbo-common/src/test/java/org/apache/dubbo/common/io/StreamUtilsTest.java b/dubbo-common/src/test/java/org/apache/dubbo/common/io/StreamUtilsTest.java\n--- a/dubbo-common/src/test/java/org/apache/dubbo/common/io/StreamUtilsTest.java\n+++ b/dubbo-common/src/test/java/org/apache/dubbo/common/io/StreamUtilsTest.java\n@@ -79,6 +79,8 @@ public void testMarkSupportedInputStream() throws Exception {\n         is.reset();\n         assertEquals(-1, is.read());\n         assertEquals(-1, is.read());\n+\n+        is.close();\n     }\n     @Test\n@@ -118,35 +120,54 @@ public void testLimitedInputStream() throws Exception {\n     @Test(expected = IOException.class)\n     public void testMarkInputSupport() throws IOException {\n         InputStream is = StreamUtilsTest.class.getResourceAsStream(\"/StreamUtilsTest.txt\");\n-        is = StreamUtils.markSupportedInputStream(new PushbackInputStream(is), 1);\n-\n-        is.mark(1);\n-        int read = is.read();\n-        assertThat(read, is((int) '0'));\n-\n-        is.skip(1);\n-        is.read();\n+        try {\n+            is = StreamUtils.markSupportedInputStream(new PushbackInputStream(is), 1);\n+\n+            is.mark(1);\n+            int read = is.read();\n+            assertThat(read, is((int) '0'));\n+\n+            is.skip(1);\n+            is.read();\n+        } finally {\n+            if (is != null) {\n+                is.close();\n+            }\n+        }\n     }\n     @Test\n-    public void testSkipForOriginMarkSupportInput() {\n+    public void testSkipForOriginMarkSupportInput() throws IOException {\n         InputStream is = StreamUtilsTest.class.getResourceAsStream(\"/StreamUtilsTest.txt\");\n         InputStream newIs = StreamUtils.markSupportedInputStream(is, 1);\n         assertThat(newIs, is(is));\n+        is.close();\n     }\n     @Test(expected = NullPointerException.class)\n     public void testReadEmptyByteArray() throws IOException {\n         InputStream is = StreamUtilsTest.class.getResourceAsStream(\"/StreamUtilsTest.txt\");\n-        is = StreamUtils.limitedInputStream(is, 2);\n-        is.read(null, 0, 1);\n+        try {\n+            is = StreamUtils.limitedInputStream(is, 2);\n+            is.read(null, 0, 1);\n+        } finally {\n+            if (is != null) {\n+                is.close();\n+            }\n+        }\n     }\n     @Test(expected = IndexOutOfBoundsException.class)\n     public void testReadWithWrongOffset() throws IOException {\n         InputStream is = StreamUtilsTest.class.getResourceAsStream(\"/StreamUtilsTest.txt\");\n-        is = StreamUtils.limitedInputStream(is, 2);\n-        is.read(new byte[1], -1, 1);\n+        try {\n+            is = StreamUtils.limitedInputStream(is, 2);\n+            is.read(new byte[1], -1, 1);\n+        } finally {\n+            if (is != null) {\n+                is.close();\n+            }\n+        }\n     }\n }\n\\ No newline at end of file",
    "output": "Fix StreamUtils resource leak"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java\n--- a/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java\n+++ b/dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java\n@@ -29,12 +29,9 @@\n import org.apache.dubbo.rpc.Protocol;\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.RpcInvocation;\n-import org.apache.dubbo.rpc.cluster.Router;\n import org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance;\n import org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance;\n-import org.apache.dubbo.rpc.cluster.router.script.ScriptRouter;\n import org.apache.dubbo.rpc.cluster.router.script.ScriptRouterFactory;\n-\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n@@ -542,8 +539,9 @@ public void testNotifyRouterUrls() {\n                 ScriptRouterFactory.NAME).addParameter(Constants.RULE_KEY,\n                 \"function test1(){}\"));\n-        registryDirectory.notify(serviceUrls);\n-        List<Router> routers = registryDirectory.getRouters();\n+        // FIXME\n+        /*registryDirectory.notify(serviceUrls);\n+        RouterChain routerChain = registryDirectory.getRouterChain();\n         //default invocation selector\n         Assert.assertEquals(1 + 1, routers.size());\n         Assert.assertTrue(ScriptRouter.class == routers.get(1).getClass() || ScriptRouter.class == routers.get(0).getClass());\n@@ -557,7 +555,7 @@ public void testNotifyRouterUrls() {\n         serviceUrls.add(routerurl.addParameter(Constants.ROUTER_KEY, Constants.ROUTER_TYPE_CLEAR));\n         registryDirectory.notify(serviceUrls);\n         routers = registryDirectory.getRouters();\n-        Assert.assertEquals(0 + 1, routers.size());\n+        Assert.assertEquals(0 + 1, routers.size());*/\n     }\n     /**\n@@ -922,14 +920,15 @@ public void testNotifyRouterUrls_Clean() {\n         // without ROUTER_KEY, the first router should not be created.\n         serviceUrls.add(routerurl);\n         registryDirectory.notify(serviceUrls);\n-        List routers = registryDirectory.getRouters();\n+        // FIXME\n+       /* List routers = registryDirectory.getRouters();\n         Assert.assertEquals(1 + 1, routers.size());\n         serviceUrls.clear();\n         serviceUrls.add(routerurl.addParameter(Constants.ROUTER_KEY, Constants.ROUTER_TYPE_CLEAR));\n         registryDirectory.notify(serviceUrls);\n         routers = registryDirectory.getRouters();\n-        Assert.assertEquals(0 + 1, routers.size());\n+        Assert.assertEquals(0 + 1, routers.size());*/\n     }\n     /**\ndiff --git a/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/DefaultDemoService.java b/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/DefaultDemoService.java\n--- a/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/DefaultDemoService.java\n+++ b/dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/org/apache/dubbo/test/provider/DefaultDemoService.java\n@@ -37,4 +37,14 @@ public String sayHello(String name) {\n         return \"DefaultDemoService - sayHell() : \" + name;\n     }\n+    @Override\n+    public String routeMethod1() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String routeMethod2() {\n+        return null;\n+    }\n+\n }",
    "output": "Fix compilation error in UTs"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/parser/ConfigParser.java\n@@ -56,9 +56,9 @@ public static List<URL> parseConfigurators(String rawConfig) {\n     public static <T> T parseObject(String rawConfig, Class<T> clazz) {\n         Constructor constructor = new Constructor(clazz);\n-        TypeDescription carDescription = new TypeDescription(clazz);\n-        carDescription.addPropertyParameters(\"items\", ConfigItem.class);\n-        constructor.addTypeDescription(carDescription);\n+        TypeDescription itemDescription = new TypeDescription(clazz);\n+        itemDescription.addPropertyParameters(\"items\", ConfigItem.class);\n+        constructor.addTypeDescription(itemDescription);\n         Yaml yaml = new Yaml(constructor);\n         return yaml.load(rawConfig);",
    "output": "Change variable name"
  },
  {
    "input": "diff --git a/dubbo-demo/dubbo-demo-api/src/main/java/org/apache/dubbo/demo/DemoService.java b/dubbo-demo/dubbo-demo-api/src/main/java/org/apache/dubbo/demo/DemoService.java\n--- a/dubbo-demo/dubbo-demo-api/src/main/java/org/apache/dubbo/demo/DemoService.java\n+++ b/dubbo-demo/dubbo-demo-api/src/main/java/org/apache/dubbo/demo/DemoService.java\n@@ -20,4 +20,8 @@ public interface DemoService {\n     String sayHello(String name);\n+    String routeMethod1();\n+\n+    String routeMethod2();\n+\n }\n\\ No newline at end of file\ndiff --git a/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java b/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java\n--- a/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java\n+++ b/dubbo-demo/dubbo-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Consumer.java\n@@ -35,6 +35,8 @@ public static void main(String[] args) {\n                 Thread.sleep(1000);\n                 String hello = demoService.sayHello(\"world\"); // call remote method\n                 System.out.println(hello); // get result\n+                String routeMethod1 = demoService.routeMethod1(); // call remote method\n+                System.out.println(routeMethod1); // get result\n             } catch (Throwable throwable) {\n                 throwable.printStackTrace();\n             }\ndiff --git a/dubbo-demo/dubbo-demo-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java b/dubbo-demo/dubbo-demo-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java\n--- a/dubbo-demo/dubbo-demo-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java\n+++ b/dubbo-demo/dubbo-demo-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java\n@@ -30,4 +30,14 @@ public String sayHello(String name) {\n         return \"Hello \" + name + \", response from provider: \" + RpcContext.getContext().getLocalAddress();\n     }\n+    @Override\n+    public String routeMethod1() {\n+        return \"routeMethod1\";\n+    }\n+\n+    @Override\n+    public String routeMethod2() {\n+        return \"routeMethod2\";\n+    }\n+\n }",
    "output": "Add demo method"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java\n@@ -60,6 +60,19 @@ private static boolean isMatch(Class<?>[] types, List<Object> args) {\n         for (int i = 0; i < types.length; i++) {\n             Class<?> type = types[i];\n             Object arg = args.get(i);\n+\n+            if (arg == null) {\n+                // if the type is primitive, the method to invoke will cause NullPointerException definitely\n+                // so we can offer a specified error message to the invoker in advance and avoid unnecessary invoking\n+                if (type.isPrimitive()) {\n+                    throw new NullPointerException(String.format(\n+                            \"The type of No.%d parameter is primitive(%s), but the value passed is null.\", i + 1, type.getName()));\n+                }\n+\n+                // if the type is not primitive, we choose to believe what the invoker want is a null value\n+                continue;\n+            }\n+\n             if (ReflectUtils.isPrimitive(arg.getClass())) {\n                 if (!ReflectUtils.isPrimitive(type)) {\n                     return false;\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoService.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoService.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoService.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoService.java\n@@ -57,4 +57,6 @@ public interface DemoService {\n     NonSerialized returnNonSerialized();\n+    long add(int a, long b);\n+\n }\n\\ No newline at end of file\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoServiceImpl.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoServiceImpl.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoServiceImpl.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/support/DemoServiceImpl.java\n@@ -24,7 +24,6 @@\n /**\n  * DemoServiceImpl\n  */\n-\n public class DemoServiceImpl implements DemoService {\n     public DemoServiceImpl() {\n         super();\n@@ -103,4 +102,9 @@ public void nonSerializedParameter(NonSerialized ns) {\n     public NonSerialized returnNonSerialized() {\n         return new NonSerialized();\n     }\n+\n+    public long add(int a, long b) {\n+        return a + b;\n+    }\n+\n }\n\\ No newline at end of file\ndiff --git a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java\n--- a/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java\n+++ b/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokerTelnetHandlerTest.java\n@@ -33,6 +33,7 @@\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.BDDMockito.given;\n import static org.mockito.Mockito.mock;\n@@ -68,6 +69,45 @@ public void testInvokeDefaultSService() throws RemotingException {\n         assertTrue(result.contains(\"Use default service org.apache.dubbo.rpc.protocol.dubbo.support.DemoService.\\r\\n\\\"ok\\\"\\r\\n\"));\n     }\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void testInvokeByPassingNullValue() throws RemotingException {\n+        mockInvoker = mock(Invoker.class);\n+        given(mockInvoker.getInterface()).willReturn(DemoService.class);\n+        given(mockInvoker.getUrl()).willReturn(URL.valueOf(\"dubbo://127.0.0.1:20883/demo\"));\n+        given(mockInvoker.invoke(any(Invocation.class))).willReturn(new RpcResult(\"ok\"));\n+        mockChannel = mock(Channel.class);\n+        given(mockChannel.getAttribute(\"telnet.service\")).willReturn(\"org.apache.dubbo.rpc.protocol.dubbo.support.DemoService\");\n+        given(mockChannel.getLocalAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:5555\"));\n+        given(mockChannel.getRemoteAddress()).willReturn(NetUtils.toAddress(\"127.0.0.1:20883\"));\n+\n+        DubboProtocol.getDubboProtocol().export(mockInvoker);\n+\n+        // pass null value to parameter of primitive type\n+        try {\n+            invoke.telnet(mockChannel, \"DemoService.add(null, 2)\");\n+            fail(\"It should cause a NullPointerException by the above code.\");\n+        } catch (NullPointerException ex) {\n+            String message = ex.getMessage();\n+            assertEquals(\"The type of No.1 parameter is primitive(int), but the value passed is null.\", message);\n+        }\n+\n+        try {\n+            invoke.telnet(mockChannel, \"DemoService.add(1, null)\");\n+            fail(\"It should cause a NullPointerException by the above code.\");\n+        } catch (NullPointerException ex) {\n+            String message = ex.getMessage();\n+            assertEquals(\"The type of No.2 parameter is primitive(long), but the value passed is null.\", message);\n+        }\n+\n+        // pass null value to parameter of object type\n+        try {\n+            invoke.telnet(mockChannel, \"DemoService.sayHello(null)\");\n+        } catch (NullPointerException ex) {\n+            fail(\"It shouldn't cause a NullPointerException by the above code.\");\n+        }\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     @Test\n     public void testInvokeAutoFindMethod() throws RemotingException {",
    "output": "Fix telnet invoke NPE #2218 * fix issue #2218 * add some unit tests"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java\n@@ -28,6 +28,7 @@\n import org.apache.dubbo.rpc.RpcException;\n import org.apache.dubbo.rpc.cluster.Directory;\n import org.apache.dubbo.rpc.cluster.LoadBalance;\n+import org.apache.dubbo.rpc.support.RpcUtils;\n import java.util.ArrayList;\n import java.util.HashSet;\n@@ -54,7 +55,8 @@ public FailoverClusterInvoker(Directory<T> directory) {\n     public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n         List<Invoker<T>> copyinvokers = invokers;\n         checkInvokers(copyinvokers, invocation);\n-        int len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;\n+        String methodName = RpcUtils.getMethodName(invocation);\n+        int len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;\n         if (len <= 0) {\n             len = 1;\n         }\n@@ -77,7 +79,7 @@ public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, L\n             try {\n                 Result result = invoker.invoke(invocation);\n                 if (le != null && logger.isWarnEnabled()) {\n-                    logger.warn(\"Although retry the method \" + invocation.getMethodName()\n+                    logger.warn(\"Although retry the method \" + methodName\n                             + \" in the service \" + getInterface().getName()\n                             + \" was successful by the provider \" + invoker.getUrl().getAddress()\n                             + \", but there have been failed providers \" + providers\n@@ -100,7 +102,7 @@ public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, L\n             }\n         }\n         throw new RpcException(le != null ? le.getCode() : 0, \"Failed to invoke the method \"\n-                + invocation.getMethodName() + \" in the service \" + getInterface().getName()\n+                + methodName + \" in the service \" + getInterface().getName()\n                 + \". Tried \" + len + \" times of the providers \" + providers\n                 + \" (\" + providers.size() + \"/\" + copyinvokers.size()\n                 + \") from the registry \" + directory.getUrl().getAddress()",
    "output": "Fix methodName and retries in FailoverClusterInvoker"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.remoting.zookeeper.curator;\n+import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.utils.StringUtils;\n import org.apache.dubbo.remoting.zookeeper.ChildListener;\n@@ -43,10 +44,11 @@ public class CuratorZookeeperClient extends AbstractZookeeperClient<CuratorWatch\n     public CuratorZookeeperClient(URL url) {\n         super(url);\n         try {\n+            int timeout = url.getParameter(Constants.TIMEOUT_KEY, 5000);\n             CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()\n                     .connectString(url.getBackupAddress())\n                     .retryPolicy(new RetryNTimes(1, 1000))\n-                    .connectionTimeoutMs(5000);\n+                    .connectionTimeoutMs(timeout);\n             String authority = url.getAuthority();\n             if (authority != null && authority.length() > 0) {\n                 builder = builder.authorization(\"digest\", authority.getBytes());\ndiff --git a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/zkclient/ZkclientZookeeperClient.java b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/zkclient/ZkclientZookeeperClient.java\n--- a/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/zkclient/ZkclientZookeeperClient.java\n+++ b/dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/zkclient/ZkclientZookeeperClient.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.dubbo.remoting.zookeeper.zkclient;\n+import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.remoting.zookeeper.ChildListener;\n import org.apache.dubbo.remoting.zookeeper.StateListener;\n@@ -37,7 +38,8 @@ public class ZkclientZookeeperClient extends AbstractZookeeperClient<IZkChildLis\n     public ZkclientZookeeperClient(URL url) {\n         super(url);\n-        client = new ZkClientWrapper(url.getBackupAddress(), 30000);\n+        long timeout = url.getParameter(Constants.TIMEOUT_KEY, 30000L);\n+        client = new ZkClientWrapper(url.getBackupAddress(), timeout);\n         client.addListener(new IZkStateListener() {\n             @Override\n             public void handleStateChanged(KeeperState state) throws Exception {",
    "output": "Add timeout config to zookeeper client"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryTest.java b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryTest.java\n--- a/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryTest.java\n+++ b/dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryTest.java\n@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.registry.support;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.registry.NotifyListener;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * AbstractRegistryTest\n+ */\n+public class AbstractRegistryTest {\n+\n+    private URL testUrl;\n+    private NotifyListener listener;\n+    private AbstractRegistry abstractRegistry;\n+    private boolean notifySuccess;\n+\n+    @Before\n+    public void init() {\n+        URL url = URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":2233\");\n+        testUrl = URL.valueOf(\"http://1.2.3.4:9090/registry?check=false&file=N/A&interface=com.test\");\n+\n+        //init the object\n+        abstractRegistry = new AbstractRegistry(url) {\n+            @Override\n+            public boolean isAvailable() {\n+                return false;\n+            }\n+        };\n+        //init notify listener\n+        listener = urls -> notifySuccess = true;\n+        //notify flag\n+        notifySuccess = false;\n+    }\n+\n+    @Test\n+    public void registerTest() {\n+        //check parameters\n+        try {\n+            abstractRegistry.register(null);\n+            Assert.fail();\n+        } catch (Exception e) {\n+            Assert.assertTrue(e instanceof IllegalArgumentException);\n+        }\n+        // check if register successfully\n+        int beginSize = abstractRegistry.getRegistered().size();\n+        abstractRegistry.register(testUrl);\n+        Assert.assertEquals(beginSize + 1, abstractRegistry.getRegistered().size());\n+        //check register when the url is the same\n+        abstractRegistry.register(testUrl);\n+        Assert.assertEquals(beginSize + 1, abstractRegistry.getRegistered().size());\n+    }\n+\n+    @Test\n+    public void unregisterTest() {\n+        //check parameters\n+        try {\n+            abstractRegistry.unregister(null);\n+            Assert.fail();\n+        } catch (Exception e) {\n+            Assert.assertTrue(e instanceof IllegalArgumentException);\n+        }\n+        // check if unregister url successfully\n+        abstractRegistry.register(testUrl);\n+        int beginSize = abstractRegistry.getRegistered().size();\n+        abstractRegistry.unregister(testUrl);\n+        Assert.assertEquals(beginSize - 1, abstractRegistry.getRegistered().size());\n+        // check if unregister a not exist url successfully\n+        abstractRegistry.unregister(testUrl);\n+        Assert.assertEquals(beginSize - 1, abstractRegistry.getRegistered().size());\n+    }\n+\n+    @Test\n+    public void subscribeTest() {\n+        //check parameters\n+        try {\n+            abstractRegistry.subscribe(null, listener);\n+            Assert.fail();\n+        } catch (Exception e) {\n+            Assert.assertTrue(e instanceof IllegalArgumentException);\n+        }\n+        //check parameters\n+        try {\n+            abstractRegistry.subscribe(testUrl, null);\n+            Assert.fail();\n+        } catch (Exception e) {\n+            Assert.assertTrue(e instanceof IllegalArgumentException);\n+        }\n+        //check parameters\n+        try {\n+            abstractRegistry.subscribe(null, null);\n+            Assert.fail();\n+        } catch (Exception e) {\n+            Assert.assertTrue(e instanceof IllegalArgumentException);\n+        }\n+        // check if subscribe successfully\n+        abstractRegistry.subscribe(testUrl, listener);\n+        Assert.assertNotNull(abstractRegistry.getSubscribed().get(testUrl));\n+        Assert.assertTrue(abstractRegistry.getSubscribed().get(testUrl).contains(listener));\n+    }\n+\n+    @Test\n+    public void unsubscribeTest() {\n+        //check parameters\n+        try {\n+            abstractRegistry.unsubscribe(null, listener);\n+            Assert.fail();\n+        } catch (Exception e) {\n+            Assert.assertTrue(e instanceof IllegalArgumentException);\n+        }\n+        //check parameters\n+        try {\n+            abstractRegistry.unsubscribe(testUrl, null);\n+            Assert.fail();\n+        } catch (Exception e) {\n+            Assert.assertTrue(e instanceof IllegalArgumentException);\n+        }\n+        //check parameters\n+        try {\n+            abstractRegistry.unsubscribe(null, null);\n+            Assert.fail();\n+        } catch (Exception e) {\n+            Assert.assertTrue(e instanceof IllegalArgumentException);\n+        }\n+        // check if unsubscribe successfully\n+        abstractRegistry.subscribe(testUrl, listener);\n+        abstractRegistry.unsubscribe(testUrl, listener);\n+        Assert.assertFalse(abstractRegistry.getSubscribed().get(testUrl).contains(listener));\n+    }\n+\n+    @Test\n+    public void recoverTest() throws Exception {\n+        abstractRegistry.register(testUrl);\n+        abstractRegistry.subscribe(testUrl, listener);\n+        abstractRegistry.recover();\n+        // check if recover successfully\n+        Assert.assertTrue(abstractRegistry.getRegistered().contains(testUrl));\n+        Assert.assertNotNull(abstractRegistry.getSubscribed().get(testUrl));\n+        Assert.assertTrue(abstractRegistry.getSubscribed().get(testUrl).contains(listener));\n+    }\n+\n+    @Test\n+    public void notifyTest() {\n+        abstractRegistry.subscribe(testUrl, listener);\n+        List<URL> urls = new ArrayList<>();\n+        urls.add(testUrl);\n+        // check if notify successfully\n+        Assert.assertFalse(notifySuccess);\n+        abstractRegistry.notify(urls);\n+        Assert.assertTrue(notifySuccess);\n+    }\n+\n+    @Test\n+    public void notify2Test() {\n+        //check parameters\n+        try {\n+            abstractRegistry.notify(null, null, null);\n+            Assert.fail();\n+        } catch (Exception e) {\n+            Assert.assertTrue(e instanceof IllegalArgumentException);\n+        }\n+        //check parameters\n+        try {\n+            abstractRegistry.notify(testUrl, null, null);\n+            Assert.fail();\n+        } catch (Exception e) {\n+            Assert.assertTrue(e instanceof IllegalArgumentException);\n+        }\n+\n+        List<URL> urls = new ArrayList<>();\n+        urls.add(testUrl);\n+        // check if notify successfully\n+        Assert.assertFalse(notifySuccess);\n+        abstractRegistry.notify(testUrl, listener, urls);\n+        Assert.assertTrue(notifySuccess);\n+    }\n+}\n\\ No newline at end of file",
    "output": "Add Unit Test for org.apache.dubbo.registry.support.AbstractRegistry"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java\n@@ -100,9 +100,9 @@ protected void setRouters(List<Router> routers) {\n         // copy list\n         routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n         // append url router\n-        String routerkey = url.getParameter(Constants.ROUTER_KEY);\n-        if (routerkey != null && routerkey.length() > 0) {\n-            RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);\n+        String routerKey = url.getParameter(Constants.ROUTER_KEY);\n+        if (routerKey != null && routerKey.length() > 0) {\n+            RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerKey);\n             routers.add(routerFactory.getRouter(url));\n         }\n         // append mock invoker selector",
    "output": "Fix name"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java\n@@ -225,7 +225,16 @@ protected URL loadMonitor(URL registryURL) {\n         if (ConfigUtils.getPid() > 0) {\n             map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n         }\n+        //set ip\n+        String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);\n+        if (hostToRegistry == null || hostToRegistry.length() == 0) {\n+            hostToRegistry = NetUtils.getLocalHost();\n+        } else if (NetUtils.isInvalidLocalHost(hostToRegistry)) {\n+            throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + Constants.DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry);\n+        }\n+        map.put(Constants.REGISTER_IP_KEY, hostToRegistry);\n         appendParameters(map, monitor);\n+        appendParameters(map, application);\n         String address = monitor.getAddress();\n         String sysaddress = System.getProperty(\"dubbo.monitor.address\");\n         if (sysaddress != null && sysaddress.length() > 0) {",
    "output": "Fix subscription when enable monitor"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java\n@@ -75,7 +75,7 @@ public Result invoke(Invocation invocation) throws RpcException {\n             result = this.invoker.invoke(invocation);\n         } else if (value.startsWith(\"force\")) {\n             if (logger.isWarnEnabled()) {\n-                logger.info(\"force-mock: \" + invocation.getMethodName() + \" force-mock enabled , url : \" + directory.getUrl());\n+                logger.warn(\"force-mock: \" + invocation.getMethodName() + \" force-mock enabled , url : \" + directory.getUrl());\n             }\n             //force:direct mock\n             result = doMockInvoke(invocation, null);",
    "output": "Change the log level Thanks for your contribution, it looks good to me"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java\n@@ -422,6 +422,8 @@ private T createProxy(Map<String, String> map) {\n             c = true; // default true\n         }\n         if (c && !invoker.isAvailable()) {\n+            // make it possible for consumer to retry later if provider is temporarily unavailable\n+            initialized = false;\n             throw new IllegalStateException(\"Failed to check the status of the service \" + interfaceName + \". No provider available for the service \" + (group == null ? \"\" : group + \"/\") + interfaceName + (version == null ? \"\" : \":\" + version) + \" from the url \" + invoker.getUrl() + \" to the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion());\n         }\n         if (logger.isInfoEnabled()) {\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java\n@@ -59,5 +59,50 @@ public void testInjvm() throws Exception {\n             demoService.unexport();\n         }\n     }\n+    /**\n+     * unit test for dubbo-1765\n+     */\n+    @Test\n+    public void testReferenceRetry() {\n+        ApplicationConfig application = new ApplicationConfig();\n+        application.setName(\"test-reference-retry\");\n+        RegistryConfig registry = new RegistryConfig();\n+        registry.setAddress(\"multicast://224.5.6.7:1234\");\n+        ProtocolConfig protocol = new ProtocolConfig();\n+        protocol.setName(\"dubbo\");\n+        ReferenceConfig<DemoService> rc = new ReferenceConfig<DemoService>();\n+        rc.setApplication(application);\n+        rc.setRegistry(registry);\n+        rc.setInterface(DemoService.class.getName());\n+\n+        boolean success = false;\n+        DemoService demoService = null;\n+        try {\n+            demoService = rc.get();\n+            success = true;\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+        Assert.assertFalse(success);\n+        Assert.assertNull(demoService);\n+\n+        ServiceConfig<DemoService> sc = new ServiceConfig<DemoService>();\n+        sc.setInterface(DemoService.class);\n+        sc.setRef(new DemoServiceImpl());\n+        sc.setApplication(application);\n+        sc.setRegistry(registry);\n+        sc.setProtocol(protocol);\n+\n+        try {\n+            sc.export();\n+            demoService = rc.get();\n+            success = true;\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+        Assert.assertTrue(success);\n+        Assert.assertNotNull(demoService);\n+\n+    }\n }\n\\ No newline at end of file",
    "output": "Fix referenceBean initialization issue"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java\n@@ -321,8 +321,17 @@ public void disconnect() {\n     @Override\n     public void reconnect() throws RemotingException {\n-        disconnect();\n-        connect();\n+        if (!isConnected()) {\n+            connectLock.lock();\n+            try {\n+                if (!isConnected()) {\n+                    disconnect();\n+                    connect();\n+                }\n+            } finally {\n+                connectLock.unlock();\n+            }\n+        }\n     }\n     @Override",
    "output": "Fix a bug when client reconnect * Add reconnection lock to control only one thread can can reconnect method. This will avoid problem in this case: Thread A reconnecting, and success, then send msg. Thread B reconnecting but invoke disconnect. Then the Thread A will send msg fail because of Thread B's disconnecting call. * fix sth"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProtocolConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProtocolConfig.java\n@@ -54,6 +54,9 @@ public class ProtocolConfig extends AbstractConfig {\n     // thread pool\n     private String threadpool;\n+    // thread pool core thread size\n+    private Integer corethreads;\n+\n     // thread pool size (fixed size)\n     private Integer threads;\n@@ -207,6 +210,14 @@ public void setThreadpool(String threadpool) {\n         this.threadpool = threadpool;\n     }\n+    public Integer getCorethreads() {\n+        return corethreads;\n+    }\n+\n+    public void setCorethreads(Integer corethreads) {\n+        this.corethreads = corethreads;\n+    }\n+\n     public Integer getThreads() {\n         return threads;\n     }\ndiff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ProtocolConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ProtocolConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ProtocolConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ProtocolConfigTest.java\n@@ -88,6 +88,13 @@ public void testPath() throws Exception {\n         assertThat(protocol.getContextpath(), equalTo(\"path\"));\n     }\n+    @Test\n+    public void testCorethreads() throws Exception {\n+        ProtocolConfig protocol = new ProtocolConfig();\n+        protocol.setCorethreads(10);\n+        assertThat(protocol.getCorethreads(), is(10));\n+    }\n+\n     @Test\n     public void testThreads() throws Exception {\n         ProtocolConfig protocol = new ProtocolConfig();",
    "output": "Add the tag corethreads to <dubbo:protocol> in dubbo.xsd"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java\n@@ -16,11 +16,12 @@\n  */\n package org.apache.dubbo.config;\n+import junit.framework.TestCase;\n import org.apache.dubbo.common.Constants;\n import org.apache.dubbo.common.utils.ConfigUtils;\n import org.apache.dubbo.config.api.Greeting;\n import org.apache.dubbo.config.support.Parameter;\n-import junit.framework.TestCase;\n+import org.hamcrest.Matchers;\n import org.junit.Test;\n import java.lang.annotation.ElementType;\n@@ -32,6 +33,8 @@\n import java.util.Map;\n import java.util.Properties;\n+import static org.junit.Assert.assertThat;\n+\n public class AbstractConfigTest {\n     @Test\n@@ -267,8 +270,8 @@ public void appendAnnotation() throws Exception {\n         TestCase.assertEquals(2, annotationConfig.getParameters().size());\n         TestCase.assertEquals(\"v1\", annotationConfig.getParameters().get(\"k1\"));\n         TestCase.assertEquals(\"v2\", annotationConfig.getParameters().get(\"k2\"));\n-        TestCase.assertEquals(\"<dubbo:annotation filter=\\\"f1, f2\\\" listener=\\\"l1, l2\\\" />\",\n-                annotationConfig.toString());\n+        assertThat(annotationConfig.toString(), Matchers.containsString(\"filter=\\\"f1, f2\\\" \"));\n+        assertThat(annotationConfig.toString(), Matchers.containsString(\"listener=\\\"l1, l2\\\" \"));\n     }\n     private static class PropertiesConfig extends AbstractConfig {",
    "output": "Fix unit test failure"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeHandler.java\n@@ -77,7 +77,7 @@ void handlerEvent(Channel channel, Request req) throws RemotingException {\n         }\n     }\n-    void handleRequest(ExchangeChannel channel, Request req) throws RemotingException {\n+    void handleRequest(final ExchangeChannel channel, Request req) throws RemotingException {\n         Response res = new Response(req.getId(), req.getVersion());\n         if (req.isBroken()) {\n             Object data = req.getData();\n@@ -183,7 +183,7 @@ public void sent(Channel channel, Object message) throws RemotingException {\n     @Override\n     public void received(Channel channel, Object message) throws RemotingException {\n         channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());\n-        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);\n+        final ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);\n         try {\n             if (message instanceof Request) {\n                 // handle request.",
    "output": "Make channel final because of using in inner class"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocol.java b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocol.java\n@@ -97,7 +97,7 @@ public boolean isInjvmRefer(URL url) {\n         // Since injvm protocol is configured explicitly, we don't need to set any extra flag, use normal refer process.\n         if (Constants.LOCAL_PROTOCOL.toString().equals(url.getProtocol())) {\n             isJvmRefer = false;\n-        } else if (Constants.SCOPE_LOCAL.equals(scope) || (url.getParameter(\"injvm\", false))) {\n+        } else if (Constants.SCOPE_LOCAL.equals(scope) || (url.getParameter(Constants.LOCAL_PROTOCOL, false))) {\n             // if it's declared as local reference\n             // 'scope=local' is equivalent to 'injvm=true', injvm will be deprecated in the future release\n             isJvmRefer = true;\ndiff --git a/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocolTest.java b/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocolTest.java\n@@ -21,23 +21,31 @@\n import org.apache.dubbo.common.URL;\n import org.apache.dubbo.common.extension.ExtensionLoader;\n import org.apache.dubbo.rpc.Exporter;\n+import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.Protocol;\n import org.apache.dubbo.rpc.ProxyFactory;\n import org.junit.After;\n import org.junit.Test;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n /**\n  * <code>ProxiesTest</code>\n  */\n public class InjvmProtocolTest {\n+\n+    static{\n+        InjvmProtocol injvm = InjvmProtocol.getInjvmProtocol();\n+    }\n+\n     private Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n     private ProxyFactory proxy = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n     private List<Exporter<?>> exporters = new ArrayList<Exporter<?>>();\n@@ -53,11 +61,17 @@ public void after() throws Exception {\n     @Test\n     public void testLocalProtocol() throws Exception {\n         DemoService service = new DemoServiceImpl();\n-        Exporter<?> exporter = protocol.export(proxy.getInvoker(service, DemoService.class, URL.valueOf(\"injvm://127.0.0.1/TestService\").addParameter(Constants.INTERFACE_KEY, DemoService.class.getName())));\n+        Invoker<?> invoker = proxy.getInvoker(service, DemoService.class, URL.valueOf(\"injvm://127.0.0.1/TestService\").addParameter(Constants.INTERFACE_KEY, DemoService.class.getName()));\n+        assertTrue(invoker.isAvailable());\n+        Exporter<?> exporter = protocol.export(invoker);\n         exporters.add(exporter);\n         service = proxy.getProxy(protocol.refer(DemoService.class, URL.valueOf(\"injvm://127.0.0.1/TestService\").addParameter(Constants.INTERFACE_KEY, DemoService.class.getName())));\n         assertEquals(service.getSize(new String[]{\"\", \"\", \"\"}), 3);\n         service.invoke(\"injvm://127.0.0.1/TestService\", \"invoke\");\n+\n+        InjvmInvoker injvmInvoker = new InjvmInvoker(DemoService.class, URL.valueOf(\"injvm://127.0.0.1/TestService\"),null,new HashMap<String, Exporter<?>>());\n+        assertFalse(injvmInvoker.isAvailable());\n+\n     }\n     @Test\n@@ -74,6 +88,19 @@ public void testIsInjvmRefer() throws Exception {\n         url = url.addParameter(Constants.GROUP_KEY, \"*\")\n                 .addParameter(Constants.VERSION_KEY, \"*\");\n         assertTrue(InjvmProtocol.getInjvmProtocol().isInjvmRefer(url));\n+\n+        url = URL.valueOf(\"fake://127.0.0.1/TestService\").addParameter(Constants.SCOPE_KEY, Constants.SCOPE_LOCAL);\n+        assertTrue(InjvmProtocol.getInjvmProtocol().isInjvmRefer(url));\n+\n+        url = URL.valueOf(\"fake://127.0.0.1/TestService\").addParameter(Constants.LOCAL_PROTOCOL,true);\n+        assertTrue(InjvmProtocol.getInjvmProtocol().isInjvmRefer(url));\n+\n+        url = URL.valueOf(\"fake://127.0.0.1/TestService\").addParameter(Constants.SCOPE_KEY, Constants.SCOPE_REMOTE);\n+        assertFalse(InjvmProtocol.getInjvmProtocol().isInjvmRefer(url));\n+\n+        url = URL.valueOf(\"fake://127.0.0.1/TestService\").addParameter(Constants.GENERIC_KEY, true);\n+        assertFalse(InjvmProtocol.getInjvmProtocol().isInjvmRefer(url));\n+\n     }\n }\n\\ No newline at end of file\ndiff --git a/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/ProtocolTest.java b/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/ProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/ProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/ProtocolTest.java\n@@ -36,6 +36,10 @@ public String echo(String e) {\n         }\n     };\n+    static{\n+        InjvmProtocol injvm = InjvmProtocol.getInjvmProtocol();\n+    }\n+\n     ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(\"javassist\");\n     URL url = URL.valueOf(\"injvm://localhost:0/org.apache.dubbo.rpc.support.IEcho?interface=org.apache.dubbo.rpc.support.IEcho\");\n@@ -48,6 +52,8 @@ public void test_destroyWontCloseAllProtocol() throws Exception {\n         Protocol InjvmProtocol = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(\"injvm\");\n+        assertEquals(0,InjvmProtocol.getDefaultPort());\n+\n         InjvmProtocol.export(invoker);\n         Invoker<IEcho> refer = InjvmProtocol.refer(IEcho.class, url);",
    "output": "Add test cases for injvm rpc protocol"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java\n@@ -479,14 +479,14 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n         String scope = url.getParameter(Constants.SCOPE_KEY);\n         // don't export when none is configured\n-        if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) {\n+        if (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) {\n             // export to local if the config is not remote (export to remote only when config is remote)\n-            if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {\n+            if (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) {\n                 exportLocal(url);\n             }\n             // export to remote if the config is not local (export to local only when config is local)\n-            if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {\n+            if (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) {\n                 if (logger.isInfoEnabled()) {\n                     logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url);\n                 }\ndiff --git a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java\n@@ -214,7 +214,7 @@ public void afterPropertiesSet() throws Exception {\n                         registryConfigs.add(config);\n                     }\n                 }\n-                if (registryConfigs != null && !registryConfigs.isEmpty()) {\n+                if (!registryConfigs.isEmpty()) {\n                     super.setRegistries(registryConfigs);\n                 }\n             }\n@@ -248,7 +248,7 @@ public void afterPropertiesSet() throws Exception {\n                         protocolConfigs.add(config);\n                     }\n                 }\n-                if (protocolConfigs != null && !protocolConfigs.isEmpty()) {\n+                if (!protocolConfigs.isEmpty()) {\n                     super.setProtocols(protocolConfigs);\n                 }\n             }",
    "output": "Remove redundant comparison"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/IOUtilsTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/IOUtilsTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/IOUtilsTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/IOUtilsTest.java\n@@ -107,7 +107,7 @@ public void testReadLines() throws Exception {\n     public void testWriteLines() throws Exception {\n         IOUtils.writeLines(os, new String[]{TEXT});\n         ByteArrayOutputStream bos = (ByteArrayOutputStream) os;\n-        assertThat(new String(bos.toByteArray()), equalTo(TEXT + \"\\n\"));\n+        assertThat(new String(bos.toByteArray()), equalTo(TEXT + System.lineSeparator()));\n     }\n     @Test",
    "output": "Fix a failed unit test on Windows * add demo * use System.lineSeparator() * delete my demo class"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResource.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResource.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResource.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResource.java\n@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.dubbo.rpc.protocol.rest.integration.swagger;\n+\n+import com.alibaba.dubbo.config.annotation.Service;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.swagger.jaxrs.listing.BaseApiListingResource;\n+\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.UriInfo;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Application;\n+\n+@Service\n+public class DubboSwaggerApiListingResource extends BaseApiListingResource implements DubboSwaggerService {\n+\n+    @Context\n+    ServletContext context;\n+\n+    @Override\n+    public Response getListingJson(Application app, ServletConfig sc,\n+                                   HttpHeaders headers, UriInfo uriInfo)  throws JsonProcessingException {\n+        Response response =  getListingJsonResponse(app, context, sc, headers, uriInfo);\n+        response.getHeaders().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.getHeaders().add(\"Access-Control-Allow-Headers\", \"x-requested-with, ssi-token\");\n+        response.getHeaders().add(\"Access-Control-Max-Age\", \"3600\");\n+        response.getHeaders().add(\"Access-Control-Allow-Methods\",\"GET,POST,PUT,DELETE,OPTIONS\");\n+        return response;\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerService.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerService.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerService.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerService.java\n@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.dubbo.rpc.protocol.rest.integration.swagger;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+\n+import javax.servlet.ServletConfig;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Application;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.UriInfo;\n+\n+\n+@Path(\"dubbo\")\n+@Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})\n+@Produces({MediaType.APPLICATION_JSON + \"; \" + \"charset=UTF-8\", MediaType.TEXT_XML + \"; \" + \"charset=UTF-8\"})\n+public interface DubboSwaggerService {\n+\n+    @GET\n+    @Path(\"swagger\")\n+    public Response getListingJson(@Context Application app, @Context ServletConfig sc,\n+                                   @Context HttpHeaders headers, @Context UriInfo uriInfo) throws JsonProcessingException;\n+}\n\\ No newline at end of file\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/test/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResourceTest.java b/dubbo-rpc/dubbo-rpc-rest/src/test/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResourceTest.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/test/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResourceTest.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/test/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/DubboSwaggerApiListingResourceTest.java\n@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.dubbo.rpc.protocol.rest.integration.swagger;\n+\n+import io.swagger.models.Swagger;\n+import org.jboss.resteasy.spi.ResteasyUriInfo;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.ws.rs.core.Application;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriInfo;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class DubboSwaggerApiListingResourceTest {\n+\n+    private Application app;\n+    private ServletConfig sc;\n+\n+    @Test\n+    public void test() throws Exception {\n+\n+        DubboSwaggerApiListingResource resource = new  DubboSwaggerApiListingResource();\n+\n+        app = mock(Application.class);\n+        sc = mock(ServletConfig.class);\n+        Set<Class<?>> sets = new HashSet<Class<?>>();\n+        sets.add(SwaggerService.class);\n+\n+        when(sc.getServletContext()).thenReturn(mock(ServletContext.class));\n+        when(app.getClasses()).thenReturn(sets);\n+\n+        Response response = resource.getListingJson(app, sc,\n+                null, new ResteasyUriInfo(new URI(\"http://rest.test\")));\n+\n+        Assert.assertNotNull(response);\n+        Swagger swagger = (Swagger)response.getEntity();\n+        Assert.assertEquals(\"SwaggerService\",swagger.getTags().get(0).getName());\n+        Assert.assertEquals(\"/demoService/hello\",swagger.getPaths().keySet().toArray()[0].toString());\n+    }\n+\n+}\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/test/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/SwaggerService.java b/dubbo-rpc/dubbo-rpc-rest/src/test/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/SwaggerService.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/test/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/SwaggerService.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/test/java/com/alibaba/dubbo/rpc/protocol/rest/integration/swagger/SwaggerService.java\n@@ -0,0 +1,34 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.dubbo.rpc.protocol.rest.integration.swagger;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+\n+@Path(\"/demoService\")\n+@Api(value = \"SwaggerService\")\n+public interface SwaggerService {\n+    @GET\n+    @Path(\"/hello\")\n+    @ApiOperation(value = \"hello\")\n+    Integer hello(@QueryParam(\"a\") Integer a, @QueryParam(\"b\") Integer b);\n+\n+}",
    "output": "Add Swagger UI integration and fixed #1642 * update cxf version and add test cases * support jdk7 * add profile for dependency in jdk9 * modify profile location * fix jaxb version * add dependency for jdk9 * extract dependencies to dependencies bom project * add SwaggerUI Integration for Rest web service * add approved license. * remove author info * adjust dependency order * add javadoc * exclude jsr311 1.1.1 version in pom * add test cases for Swagger Integration"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/AbstractInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/AbstractInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/AbstractInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/AbstractInvoker.java\n@@ -134,16 +134,15 @@ public Result invoke(Invocation inv) throws RpcException {\n         if (attachment != null && attachment.size() > 0) {\n             invocation.addAttachmentsIfAbsent(attachment);\n         }\n-        Map<String, String> context = RpcContext.getContext().getAttachments();\n-        if (context != null) {\n+        Map<String, String> contextAttachments = RpcContext.getContext().getAttachments();\n+        if (contextAttachments != null) {\n             /**\n              * invocation.addAttachmentsIfAbsent(context){@link RpcInvocation#addAttachmentsIfAbsent(Map)}should not be used here,\n              * because the {@link RpcContext#setAttachment(String, String)} is passed in the Filter when the call is triggered\n              * by the built-in retry mechanism of the Dubbo. The attachment to update RpcContext will no longer work, which is\n              * a mistake in most cases (for example, through Filter to RpcContext output traceId and spanId and other information).\n-             * yizhenqiang 20180310\n              */\n-            invocation.addAttachments(context);\n+            invocation.addAttachments(contextAttachments);\n         }\n         if (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false)) {\n             invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());",
    "output": "Remove author info from #1453"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java\n@@ -122,19 +122,19 @@ private static void checkAndConvertImplicitConfig(MethodConfig method, Map<Strin\n         //convert onreturn methodName to Method\n         String onReturnMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_RETURN_METHOD_KEY);\n         Object onReturnMethod = attributes.get(onReturnMethodKey);\n-        if (onReturnMethod != null && onReturnMethod instanceof String) {\n+        if (onReturnMethod instanceof String) {\n             attributes.put(onReturnMethodKey, getMethodByName(method.getOnreturn().getClass(), onReturnMethod.toString()));\n         }\n         //convert onthrow methodName to Method\n         String onThrowMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_THROW_METHOD_KEY);\n         Object onThrowMethod = attributes.get(onThrowMethodKey);\n-        if (onThrowMethod != null && onThrowMethod instanceof String) {\n+        if (onThrowMethod instanceof String) {\n             attributes.put(onThrowMethodKey, getMethodByName(method.getOnthrow().getClass(), onThrowMethod.toString()));\n         }\n         //convert oninvoke methodName to Method\n         String onInvokeMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_INVOKE_METHOD_KEY);\n         Object onInvokeMethod = attributes.get(onInvokeMethodKey);\n-        if (onInvokeMethod != null && onInvokeMethod instanceof String) {\n+        if (onInvokeMethod instanceof String) {\n             attributes.put(onInvokeMethodKey, getMethodByName(method.getOninvoke().getClass(), onInvokeMethod.toString()));\n         }\n     }\n@@ -148,7 +148,7 @@ private static Method getMethodByName(Class<?> clazz, String methodName) {\n     }\n     public URL toUrl() {\n-        return urls == null || urls.isEmpty() ? null : urls.iterator().next();\n+        return urls.isEmpty() ? null : urls.iterator().next();\n     }\n     public List<URL> toUrls() {\n@@ -238,7 +238,7 @@ private void init() {\n         if (resolve != null && resolve.length() > 0) {\n             url = resolve;\n             if (logger.isWarnEnabled()) {\n-                if (resolveFile != null && resolveFile.length() > 0) {\n+                if (resolveFile != null) {\n                     logger.warn(\"Using default dubbo resolve file \" + resolveFile + \" replace \" + interfaceName + \"\" + resolve + \" to p2p invoke remote service.\");\n                 } else {\n                     logger.warn(\"Using -D\" + interfaceName + \"=\" + resolve + \" to p2p invoke remote service.\");\n@@ -385,7 +385,7 @@ private T createProxy(Map<String, String> map) {\n                         urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n                     }\n                 }\n-                if (urls == null || urls.isEmpty()) {\n+                if (urls.isEmpty()) {\n                     throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n                 }\n             }",
    "output": "Remove unnecessary null check"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/com/alibaba/dubbo/config/ProtocolConfigTest.java b/dubbo-config/dubbo-config-api/src/test/java/com/alibaba/dubbo/config/ProtocolConfigTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/com/alibaba/dubbo/config/ProtocolConfigTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/com/alibaba/dubbo/config/ProtocolConfigTest.java\n@@ -17,7 +17,6 @@\n package com.alibaba.dubbo.config;\n-import com.alibaba.dubbo.common.extension.ExtensionLoader;\n import com.alibaba.dubbo.rpc.Protocol;\n import org.junit.Test;\n import org.mockito.Mockito;\n@@ -32,15 +31,6 @@\n import static org.junit.Assert.assertThat;\n public class ProtocolConfigTest {\n-    @Test\n-    public void testDestroyAll() throws Exception {\n-        Protocol protocol = Mockito.mock(Protocol.class);\n-        MockProtocol2.delegate = protocol;\n-        ExtensionLoader<Protocol> loader = ExtensionLoader.getExtensionLoader(Protocol.class);\n-        loader.getExtension(\"mockprotocol2\");\n-        ProtocolConfig.destroyAll();\n-        Mockito.verify(protocol).destroy();\n-    }\n     @Test\n     public void testDestroy() throws Exception {",
    "output": "Fix UT failure"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/RegistryConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/RegistryConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/RegistryConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/RegistryConfig.java\n@@ -101,15 +101,6 @@ public RegistryConfig(String address, String protocol) {\n         setProtocol(protocol);\n     }\n-    public static void destroyAll() {\n-        AbstractRegistryFactory.destroyAll();\n-    }\n-\n-    @Deprecated\n-    public static void closeAll() {\n-        destroyAll();\n-    }\n-\n     public String getProtocol() {\n         return protocol;\n     }",
    "output": "Remove unused code"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/RegistryConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/RegistryConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/RegistryConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/RegistryConfig.java\n@@ -96,6 +96,11 @@ public RegistryConfig(String address) {\n         setAddress(address);\n     }\n+    public RegistryConfig(String address, String protocol) {\n+        setAddress(address);\n+        setProtocol(protocol);\n+    }\n+\n     public static void destroyAll() {\n         AbstractRegistryFactory.destroyAll();\n     }",
    "output": "Add a construtor to accept address and protocol for RegistryConfig"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n@@ -757,7 +757,7 @@ public void setInterface(Class<?> interfaceClass) {\n             throw new IllegalStateException(\"The interface class \" + interfaceClass + \" is not a interface!\");\n         }\n         this.interfaceClass = interfaceClass;\n-        setInterface(interfaceClass == null ? (String) null : interfaceClass.getName());\n+        setInterface(interfaceClass == null ? null : interfaceClass.getName());\n     }\n     public T getRef() {",
    "output": "Remove redundant cast"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/cached/CachedThreadPoolTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/cached/CachedThreadPoolTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/cached/CachedThreadPoolTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/cached/CachedThreadPoolTest.java\n@@ -66,7 +66,7 @@ public void run() {\n             }\n         });\n-        latch.await(5000, TimeUnit.MICROSECONDS);\n+        latch.await();\n         assertThat(latch.getCount(), is(0L));\n     }\ndiff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/eager/EagerThreadPoolTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/eager/EagerThreadPoolTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/eager/EagerThreadPoolTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/eager/EagerThreadPoolTest.java\n@@ -67,7 +67,7 @@ public void run() {\n             }\n         });\n-        latch.await(5000, TimeUnit.MICROSECONDS);\n+        latch.await();\n         assertThat(latch.getCount(), is(0L));\n     }\ndiff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/fixed/FixedThreadPoolTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/fixed/FixedThreadPoolTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/fixed/FixedThreadPoolTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/fixed/FixedThreadPoolTest.java\n@@ -67,7 +67,7 @@ public void run() {\n             }\n         });\n-        latch.await(5000, TimeUnit.MICROSECONDS);\n+        latch.await();\n         assertThat(latch.getCount(), is(0L));\n     }\ndiff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/limited/LimitedThreadPoolTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/limited/LimitedThreadPoolTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/limited/LimitedThreadPoolTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/threadpool/support/limited/LimitedThreadPoolTest.java\n@@ -65,7 +65,7 @@ public void run() {\n             }\n         });\n-        latch.await(5000, TimeUnit.MICROSECONDS);\n+        latch.await();\n         assertThat(latch.getCount(), is(0L));\n     }",
    "output": "Make unit test stable"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java\n@@ -664,7 +664,7 @@ private void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL reso\n             clazz.getConstructor();\n             if (name == null || name.length() == 0) {\n                 name = findAnnotationName(clazz);\n-                if (name == null || name.length() == 0) {\n+                if (name.length() == 0) {\n                     throw new IllegalStateException(\"No such extension name for the class \" + clazz.getName() + \" in the config \" + resourceURL);\n                 }\n             }",
    "output": "Remove unnecessary null check"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/WrappedChannelHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/WrappedChannelHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/WrappedChannelHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/WrappedChannelHandler.java\n@@ -59,8 +59,8 @@ public WrappedChannelHandler(ChannelHandler handler, URL url) {\n     public void close() {\n         try {\n-            if (executor instanceof ExecutorService) {\n-                ((ExecutorService) executor).shutdown();\n+            if (executor != null) {\n+                executor.shutdown();\n             }\n         } catch (Throwable t) {\n             logger.warn(\"fail to destroy thread pool of server: \" + t.getMessage(), t);",
    "output": "Remove unecessary cast"
  },
  {
    "input": "diff --git a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian1StringShortTest.java b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian1StringShortTest.java\n--- a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian1StringShortTest.java\n+++ b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian1StringShortTest.java\n@@ -44,7 +44,7 @@ public void serialize_string_short_map_then_deserialize() throws Exception {\n         stringShortMap.put(\"last\", (short)60);\n         stringShort.stringShortMap = stringShortMap;\n-        Hessian2StringShortType deserialize = baseHessionSerialize(stringShort);\n+        Hessian2StringShortType deserialize = baseHessianSerialize(stringShort);\n         assertTrue(deserialize.stringShortMap != null);\n         assertTrue(deserialize.stringShortMap.size() == 2);\n         assertTrue(deserialize.stringShortMap.get(\"last\") instanceof Short);\n@@ -61,7 +61,7 @@ public void serialize_string_byte_map_then_deserialize() throws Exception {\n         stringByteMap.put(\"last\", (byte)60);\n         stringShort.stringByteMap = stringByteMap;\n-        Hessian2StringShortType deserialize = baseHessionSerialize(stringShort);\n+        Hessian2StringShortType deserialize = baseHessianSerialize(stringShort);\n         assertTrue(deserialize.stringByteMap != null);\n         assertTrue(deserialize.stringByteMap.size() == 2);\n         assertTrue(deserialize.stringByteMap.get(\"last\") instanceof Byte);\ndiff --git a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian2EnumSetTest.java b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian2EnumSetTest.java\n--- a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian2EnumSetTest.java\n+++ b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian2EnumSetTest.java\n@@ -34,23 +34,23 @@ public class Hessian2EnumSetTest extends SerializeTestBase {\n     @Test\n     public void singleton() throws Exception {\n         EnumSet h = EnumSet.of(Type.High);\n-        EnumSet set = baseHession2Serialize(h);\n+        EnumSet set = baseHessian2Serialize(h);\n         assertTrue(Arrays.asList(set.toArray()).contains(Type.High));\n         assertFalse(Arrays.asList(set.toArray()).contains(Type.Lower));\n     }\n     @Test\n     public void set() throws Exception {\n         EnumSet<Type> types = EnumSet.of(Type.High, Type.Lower);\n-        EnumSet set = baseHession2Serialize(types);\n+        EnumSet set = baseHessian2Serialize(types);\n         assertTrue(set.contains(Type.High));\n         assertFalse(set.contains(Type.Normal));\n     }\n     @Test\n     public void none() throws Exception {\n         EnumSet<Type> types = EnumSet.noneOf(Type.class);\n-        EnumSet set = baseHession2Serialize(types);\n+        EnumSet set = baseHessian2Serialize(types);\n         TestCase.assertEquals(set, EnumSet.noneOf(Type.class));\n     }\n }\ndiff --git a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian2StringShortTest.java b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian2StringShortTest.java\n--- a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian2StringShortTest.java\n+++ b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/Hessian2StringShortTest.java\n@@ -44,7 +44,7 @@ public void serialize_string_short_map_then_deserialize() throws Exception {\n         stringShortMap.put(\"last\", (short)60);\n         stringShort.stringShortMap = stringShortMap;\n-        Hessian2StringShortType deserialize = baseHession2Serialize(stringShort);\n+        Hessian2StringShortType deserialize = baseHessian2Serialize(stringShort);\n         assertTrue(deserialize.stringShortMap != null);\n         assertTrue(deserialize.stringShortMap.size() == 2);\n         assertTrue(deserialize.stringShortMap.get(\"last\") instanceof Short);\n@@ -61,7 +61,7 @@ public void serialize_string_byte_map_then_deserialize() throws Exception {\n         stringByteMap.put(\"last\", (byte)60);\n         stringShort.stringByteMap = stringByteMap;\n-        Hessian2StringShortType deserialize = baseHession2Serialize(stringShort);\n+        Hessian2StringShortType deserialize = baseHessian2Serialize(stringShort);\n         assertTrue(deserialize.stringByteMap != null);\n         assertTrue(deserialize.stringByteMap.size() == 2);\n         assertTrue(deserialize.stringByteMap.get(\"last\") instanceof Byte);\ndiff --git a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/HessianJavaSerializeTest.java b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/HessianJavaSerializeTest.java\n--- a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/HessianJavaSerializeTest.java\n+++ b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/HessianJavaSerializeTest.java\n@@ -25,7 +25,7 @@\n import org.junit.Test;\n /**\n- * fix hession serialize bug:\n+ * fix hessian serialize bug:\n  * the filed of parent class will cover the filed of sub class\n  *\n  */\n@@ -38,7 +38,7 @@ public void testGetBaseUserName() throws Exception {\n         baseUser.setUserId(1);\n         baseUser.setUserName(\"tom\");\n-        BaseUser serializedUser = baseHessionSerialize(baseUser);\n+        BaseUser serializedUser = baseHessianSerialize(baseUser);\n         Assert.assertEquals(\"tom\", serializedUser.getUserName());\n     }\n@@ -49,7 +49,7 @@ public void testGetSubUserName() throws Exception {\n         subUser.setUserId(1);\n         subUser.setUserName(\"tom\");\n-        SubUser serializedUser = baseHessionSerialize(subUser);\n+        SubUser serializedUser = baseHessianSerialize(subUser);\n         Assert.assertEquals(\"tom\", serializedUser.getUserName());\n     }\n@@ -60,7 +60,7 @@ public void testGetGrandsonUserName() throws Exception {\n         grandsonUser.setUserId(1);\n         grandsonUser.setUserName(\"tom\");\n-        GrandsonUser serializedUser = baseHessionSerialize(grandsonUser);\n+        GrandsonUser serializedUser = baseHessianSerialize(grandsonUser);\n         Assert.assertEquals(\"tom\", serializedUser.getUserName());\n     }\ndiff --git a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/LocaleSerializerTest.java b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/LocaleSerializerTest.java\n--- a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/LocaleSerializerTest.java\n+++ b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/LocaleSerializerTest.java\n@@ -39,7 +39,7 @@ public void locale() throws IOException {\n     }\n     private void assertLocale(Locale locale) throws IOException {\n-        TestCase.assertEquals(locale, baseHession2Serialize(locale));\n-        TestCase.assertEquals(locale, baseHessionSerialize(locale));\n+        TestCase.assertEquals(locale, baseHessian2Serialize(locale));\n+        TestCase.assertEquals(locale, baseHessianSerialize(locale));\n     }\n }\n\\ No newline at end of file\ndiff --git a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/base/SerializeTestBase.java b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/base/SerializeTestBase.java\n--- a/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/base/SerializeTestBase.java\n+++ b/hessian-lite/src/test/java/com/alibaba/com/caucho/hessian/io/base/SerializeTestBase.java\n@@ -26,19 +26,19 @@\n import java.io.IOException;\n /**\n- * hession base serialize utils\n+ * hessian base serialize utils\n  *\n  */\n public class SerializeTestBase {\n     /**\n-     * hession serialize util\n+     * hessian serialize util\n      *\n      * @param data\n      * @param <T>\n      * @return\n      * @throws IOException\n      */\n-    protected <T> T baseHessionSerialize(T data) throws IOException {\n+    protected <T> T baseHessianSerialize(T data) throws IOException {\n         ByteArrayOutputStream bout = new ByteArrayOutputStream();\n         HessianOutput out = new HessianOutput(bout);\n@@ -51,14 +51,14 @@ protected <T> T baseHessionSerialize(T data) throws IOException {\n     }\n     /**\n-     * hession2 serialize util\n+     * hessian2 serialize util\n      *\n      * @param data\n      * @param <T>\n      * @return\n      * @throws IOException\n      */\n-    protected <T> T baseHession2Serialize(T data) throws IOException {\n+    protected <T> T baseHessian2Serialize(T data) throws IOException {\n         ByteArrayOutputStream bout = new ByteArrayOutputStream();\n         Hessian2Output out = new Hessian2Output(bout);",
    "output": "Fix hessian-lite spelling mistake"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/status/RegistryStatusChecker.java b/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/status/RegistryStatusChecker.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/status/RegistryStatusChecker.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/status/RegistryStatusChecker.java\n@@ -33,13 +33,13 @@ public class RegistryStatusChecker implements StatusChecker {\n     @Override\n     public Status check() {\n-        Collection<Registry> regsitries = AbstractRegistryFactory.getRegistries();\n-        if (regsitries == null || regsitries.isEmpty()) {\n+        Collection<Registry> registries = AbstractRegistryFactory.getRegistries();\n+        if (registries.isEmpty()) {\n             return new Status(Status.Level.UNKNOWN);\n         }\n         Status.Level level = Status.Level.OK;\n         StringBuilder buf = new StringBuilder();\n-        for (Registry registry : regsitries) {\n+        for (Registry registry : registries) {\n             if (buf.length() > 0) {\n                 buf.append(\",\");\n             }",
    "output": "Remove unnecessary null check and fix typo"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n@@ -338,7 +338,7 @@ public synchronized void unexport() {\n         if (unexported) {\n             return;\n         }\n-        if (exporters != null && !exporters.isEmpty()) {\n+        if (!exporters.isEmpty()) {\n             for (Exporter<?> exporter : exporters) {\n                 try {\n                     exporter.unexport();",
    "output": "Remove unnecessary null check"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractServiceConfig.java\n@@ -171,7 +171,7 @@ public ProtocolConfig getProtocol() {\n     }\n     public void setProtocol(ProtocolConfig protocol) {\n-        this.protocols = Arrays.asList(new ProtocolConfig[]{protocol});\n+        this.protocols = Arrays.asList(protocol);\n     }\n     public String getAccesslog() {",
    "output": "Remove redundant array creation"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n@@ -175,7 +175,7 @@ private static void putRandomPort(String protocol, Integer port) {\n     }\n     public URL toUrl() {\n-        return urls == null || urls.isEmpty() ? null : urls.iterator().next();\n+        return urls.isEmpty() ? null : urls.iterator().next();\n     }\n     public List<URL> toUrls() {",
    "output": "Remove unnecessary null check"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n@@ -104,7 +104,7 @@ public ServiceConfig(Service service) {\n     }\n     @Deprecated\n-    private static final List<ProtocolConfig> convertProviderToProtocol(List<ProviderConfig> providers) {\n+    private static List<ProtocolConfig> convertProviderToProtocol(List<ProviderConfig> providers) {\n         if (providers == null || providers.isEmpty()) {\n             return null;\n         }\n@@ -116,7 +116,7 @@ private static final List<ProtocolConfig> convertProviderToProtocol(List<Provide\n     }\n     @Deprecated\n-    private static final List<ProviderConfig> convertProtocolToProvider(List<ProtocolConfig> protocols) {\n+    private static List<ProviderConfig> convertProtocolToProvider(List<ProtocolConfig> protocols) {\n         if (protocols == null || protocols.isEmpty()) {\n             return null;\n         }\n@@ -128,7 +128,7 @@ private static final List<ProviderConfig> convertProtocolToProvider(List<Protoco\n     }\n     @Deprecated\n-    private static final ProtocolConfig convertProviderToProtocol(ProviderConfig provider) {\n+    private static ProtocolConfig convertProviderToProtocol(ProviderConfig provider) {\n         ProtocolConfig protocol = new ProtocolConfig();\n         protocol.setName(provider.getProtocol().getName());\n         protocol.setServer(provider.getServer());\n@@ -144,7 +144,7 @@ private static final ProtocolConfig convertProviderToProtocol(ProviderConfig pro\n     }\n     @Deprecated\n-    private static final ProviderConfig convertProtocolToProvider(ProtocolConfig protocol) {\n+    private static ProviderConfig convertProtocolToProvider(ProtocolConfig protocol) {\n         ProviderConfig provider = new ProviderConfig();\n         provider.setProtocol(protocol);\n         provider.setServer(protocol.getServer());",
    "output": "Remove redundant final modifier"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractInterfaceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractInterfaceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractInterfaceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractInterfaceConfig.java\n@@ -169,8 +169,7 @@ protected List<URL> loadRegistries(boolean provider) {\n                 if (sysaddress != null && sysaddress.length() > 0) {\n                     address = sysaddress;\n                 }\n-                if (address != null && address.length() > 0\n-                        && !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {\n+                if (address.length() > 0 && !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {\n                     Map<String, String> map = new HashMap<String, String>();\n                     appendParameters(map, application);\n                     appendParameters(map, config);",
    "output": "Remove unnecessary null check"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ExecutorUtil.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ExecutorUtil.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ExecutorUtil.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ExecutorUtil.java\n@@ -34,17 +34,17 @@ public class ExecutorUtil {\n             new LinkedBlockingQueue<Runnable>(100),\n             new NamedThreadFactory(\"Close-ExecutorService-Timer\", true));\n-    public static boolean isShutdown(Executor executor) {\n+    public static boolean isTerminated(Executor executor) {\n         if (executor instanceof ExecutorService) {\n-            if (((ExecutorService) executor).isShutdown()) {\n+            if (((ExecutorService) executor).isTerminated()) {\n                 return true;\n             }\n         }\n         return false;\n     }\n     public static void gracefulShutdown(Executor executor, int timeout) {\n-        if (!(executor instanceof ExecutorService) || isShutdown(executor)) {\n+        if (!(executor instanceof ExecutorService) || isTerminated(executor)) {\n             return;\n         }\n         final ExecutorService es = (ExecutorService) executor;\n@@ -63,13 +63,13 @@ public static void gracefulShutdown(Executor executor, int timeout) {\n             es.shutdownNow();\n             Thread.currentThread().interrupt();\n         }\n-        if (!isShutdown(es)) {\n+        if (!isTerminated(es)) {\n             newThreadToCloseExecutor(es);\n         }\n     }\n     public static void shutdownNow(Executor executor, final int timeout) {\n-        if (!(executor instanceof ExecutorService) || isShutdown(executor)) {\n+        if (!(executor instanceof ExecutorService) || isTerminated(executor)) {\n             return;\n         }\n         final ExecutorService es = (ExecutorService) executor;\n@@ -85,13 +85,13 @@ public static void shutdownNow(Executor executor, final int timeout) {\n         } catch (InterruptedException ex) {\n             Thread.currentThread().interrupt();\n         }\n-        if (!isShutdown(es)) {\n+        if (!isTerminated(es)) {\n             newThreadToCloseExecutor(es);\n         }\n     }\n     private static void newThreadToCloseExecutor(final ExecutorService es) {\n-        if (!isShutdown(es)) {\n+        if (!isTerminated(es)) {\n             shutdownExecutor.execute(new Runnable() {\n                 @Override\n                 public void run() {",
    "output": "Fix isShutdown() always return true"
  },
  {
    "input": "diff --git a/dubbo-monitor/dubbo-monitor-default/src/main/java/com/alibaba/dubbo/monitor/dubbo/DubboMonitor.java b/dubbo-monitor/dubbo-monitor-default/src/main/java/com/alibaba/dubbo/monitor/dubbo/DubboMonitor.java\n--- a/dubbo-monitor/dubbo-monitor-default/src/main/java/com/alibaba/dubbo/monitor/dubbo/DubboMonitor.java\n+++ b/dubbo-monitor/dubbo-monitor-default/src/main/java/com/alibaba/dubbo/monitor/dubbo/DubboMonitor.java\n@@ -75,9 +75,7 @@ public void run() {\n     }\n     public void send() {\n-        if (logger.isInfoEnabled()) {\n-            logger.info(\"Send statistics to monitor \" + getUrl());\n-        }\n+        logger.debug(\"Send statistics to monitor \" + getUrl());\n         String timestamp = String.valueOf(System.currentTimeMillis());\n         for (Map.Entry<Statistics, AtomicReference<long[]>> entry : statisticsMap.entrySet()) {\n             // get statistics data",
    "output": "Change monitor log level"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NetUtils.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NetUtils.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NetUtils.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NetUtils.java\n@@ -190,7 +190,7 @@ private static InetAddress getLocalAddress0() {\n                 return localAddress;\n             }\n         } catch (Throwable e) {\n-            logger.warn(\"Failed to retriving ip address, \" + e.getMessage(), e);\n+            logger.warn(\"Failed to retrieving ip address, \" + e.getMessage(), e);\n         }\n         try {\n             Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n@@ -207,17 +207,17 @@ private static InetAddress getLocalAddress0() {\n                                         return address;\n                                     }\n                                 } catch (Throwable e) {\n-                                    logger.warn(\"Failed to retriving ip address, \" + e.getMessage(), e);\n+                                    logger.warn(\"Failed to retrieving ip address, \" + e.getMessage(), e);\n                                 }\n                             }\n                         }\n                     } catch (Throwable e) {\n-                        logger.warn(\"Failed to retriving ip address, \" + e.getMessage(), e);\n+                        logger.warn(\"Failed to retrieving ip address, \" + e.getMessage(), e);\n                     }\n                 }\n             }\n         } catch (Throwable e) {\n-            logger.warn(\"Failed to retriving ip address, \" + e.getMessage(), e);\n+            logger.warn(\"Failed to retrieving ip address, \" + e.getMessage(), e);\n         }\n         logger.error(\"Could not get local host ip address, will use 127.0.0.1 instead.\");\n         return localAddress;",
    "output": "Fix typo"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ReflectUtils.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ReflectUtils.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ReflectUtils.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ReflectUtils.java\n@@ -910,6 +910,9 @@ private static Object getEmptyObject(Class<?> returnType, Map<Class<?>, Object>\n                 while (cls != null && cls != Object.class) {\n                     Field[] fields = cls.getDeclaredFields();\n                     for (Field field : fields) {\n+                        if (field.isSynthetic()) {\n+                            continue;\n+                        }\n                         Object property = getEmptyObject(field.getType(), emptyInstances, level + 1);\n                         if (property != null) {\n                             try {",
    "output": "Use jacoco instead of cobertura for coverage rate collectiong"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/logger/support/FailsafeLogger.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/logger/support/FailsafeLogger.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/logger/support/FailsafeLogger.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/logger/support/FailsafeLogger.java\n@@ -37,7 +37,7 @@ public void setLogger(Logger logger) {\n     }\n     private String appendContextMessage(String msg) {\n-        return \" [DUBBO] \" + msg + \", dubbo version: \" + Version.getVersion() + \", current host: \" + NetUtils.getLogHost();\n+        return \" [DUBBO] \" + msg + \", dubbo version: \" + Version.getVersion() + \", current host: \" + NetUtils.getLocalHost();\n     }\n     public void trace(String msg, Throwable e) {\ndiff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NetUtils.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NetUtils.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NetUtils.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NetUtils.java\n@@ -182,11 +182,6 @@ public static InetAddress getLocalAddress() {\n         return localAddress;\n     }\n-    public static String getLogHost() {\n-        InetAddress address = getLocalAddress();\n-        return address == null ? LOCALHOST : address.getHostAddress();\n-    }\n-\n     private static InetAddress getLocalAddress0() {\n         InetAddress localAddress = null;\n         try {",
    "output": "Remove the method with the same function but the different name in NetUtils"
  },
  {
    "input": "diff --git a/dubbo-demo/dubbo-demo-provider/src/main/java/com/alibaba/dubbo/demo/provider/DemoServiceImpl.java b/dubbo-demo/dubbo-demo-provider/src/main/java/com/alibaba/dubbo/demo/provider/DemoServiceImpl.java\n--- a/dubbo-demo/dubbo-demo-provider/src/main/java/com/alibaba/dubbo/demo/provider/DemoServiceImpl.java\n+++ b/dubbo-demo/dubbo-demo-provider/src/main/java/com/alibaba/dubbo/demo/provider/DemoServiceImpl.java\n@@ -26,7 +26,7 @@ public class DemoServiceImpl implements DemoService {\n     public String sayHello(String name) {\n         System.out.println(\"[\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()) + \"] Hello \" + name + \", request from consumer: \" + RpcContext.getContext().getRemoteAddress());\n-        return \"Hello \" + name + \", response form provider: \" + RpcContext.getContext().getLocalAddress();\n+        return \"Hello \" + name + \", response from provider: \" + RpcContext.getContext().getLocalAddress();\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Upgrade DemoServiceImpl.java update a little spelling error"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/integration/RegistryProtocol.java b/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/integration/RegistryProtocol.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/integration/RegistryProtocol.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/integration/RegistryProtocol.java\n@@ -305,7 +305,7 @@ private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type\n                         + \",\" + Constants.ROUTERS_CATEGORY));\n         Invoker invoker = cluster.join(directory);\n-        ProviderConsumerRegTable.registerConsuemr(invoker, url, subscribeUrl, directory);\n+        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);\n         return invoker;\n     }\n@@ -504,4 +504,4 @@ public void run() {\n             });\n         }\n     }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ProviderConsumerRegTable.java b/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ProviderConsumerRegTable.java\n--- a/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ProviderConsumerRegTable.java\n+++ b/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ProviderConsumerRegTable.java\n@@ -73,7 +73,7 @@ public static ProviderInvokerWrapper getProviderWrapper(Invoker invoker) {\n         return null;\n     }\n-    public static void registerConsuemr(Invoker invoker, URL registryUrl, URL consumerUrl, RegistryDirectory registryDirectory) {\n+    public static void registerConsumer(Invoker invoker, URL registryUrl, URL consumerUrl, RegistryDirectory registryDirectory) {\n         ConsumerInvokerWrapper wrapperInvoker = new ConsumerInvokerWrapper(invoker, registryUrl, consumerUrl, registryDirectory);\n         String serviceUniqueName = consumerUrl.getServiceKey();\n         Set<ConsumerInvokerWrapper> invokers = consumerInvokers.get(serviceUniqueName);",
    "output": "Fix typo"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java\n@@ -49,8 +49,8 @@ public class HeaderExchangeClient implements ExchangeClient {\n     private final ExchangeChannel channel;\n     // heartbeat timer\n     private ScheduledFuture<?> heartbeatTimer;\n+    // heartbeat(ms), default value is 0 , won't execute a heartbeat.\n     private int heartbeat;\n-    // heartbeat timeout (ms), default value is 0 , won't execute a heartbeat.\n     private int heartbeatTimeout;\n     public HeaderExchangeClient(Client client, boolean needHeartbeat) {\n@@ -66,7 +66,7 @@ public HeaderExchangeClient(Client client, boolean needHeartbeat) {\n             throw new IllegalStateException(\"heartbeatTimeout < heartbeatInterval * 2\");\n         }\n         if (needHeartbeat) {\n-            startHeatbeatTimer();\n+            startHeartbeatTimer();\n         }\n     }\n@@ -160,7 +160,7 @@ public boolean hasAttribute(String key) {\n         return channel.hasAttribute(key);\n     }\n-    private void startHeatbeatTimer() {\n+    private void startHeartbeatTimer() {\n         stopHeartbeatTimer();\n         if (heartbeat > 0) {\n             heartbeatTimer = scheduled.scheduleWithFixedDelay(",
    "output": "Fix heartbeat spelling error"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoaderTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoaderTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoaderTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoaderTest.java\n@@ -44,6 +44,8 @@\n import com.alibaba.dubbo.common.extensionloader.ext8_add.impl.AddExt2_ManualAdaptive;\n import com.alibaba.dubbo.common.extensionloader.ext8_add.impl.AddExt3_ManualAdaptive;\n import com.alibaba.dubbo.common.extensionloader.ext8_add.impl.AddExt4_ManualAdaptive;\n+import com.alibaba.dubbo.common.extensionloader.ext9_empty.Ext9Empty;\n+import com.alibaba.dubbo.common.extensionloader.ext9_empty.impl.Ext9EmptyImpl;\n import junit.framework.Assert;\n import org.junit.Test;\n@@ -240,6 +242,16 @@ public void test_AddExtension() throws Exception {\n         assertEquals(\"Manual1\", ExtensionLoader.getExtensionLoader(AddExt1.class).getExtensionName(AddExt1_ManualAdd1.class));\n     }\n+    @Test\n+    public void test_AddExtension_NoExtend() throws Exception {\n+//        ExtensionLoader.getExtensionLoader(Ext9Empty.class).getSupportedExtensions();\n+        ExtensionLoader.getExtensionLoader(Ext9Empty.class).addExtension(\"ext9\", Ext9EmptyImpl.class);\n+        Ext9Empty ext = ExtensionLoader.getExtensionLoader(Ext9Empty.class).getExtension(\"ext9\");\n+\n+        assertThat(ext, instanceOf(Ext9Empty.class));\n+        assertEquals(\"ext9\", ExtensionLoader.getExtensionLoader(Ext9Empty.class).getExtensionName(Ext9EmptyImpl.class));\n+    }\n+\n     @Test\n     public void test_AddExtension_ExceptionWhenExistedExtension() throws Exception {\n         SimpleExt ext = ExtensionLoader.getExtensionLoader(SimpleExt.class).getExtension(\"impl1\");\ndiff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ext9_empty/Ext9Empty.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ext9_empty/Ext9Empty.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ext9_empty/Ext9Empty.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ext9_empty/Ext9Empty.java\n@@ -0,0 +1,8 @@\n+package com.alibaba.dubbo.common.extensionloader.ext9_empty;\n+\n+import com.alibaba.dubbo.common.extension.SPI;\n+\n+@SPI\n+public interface Ext9Empty {\n+    void empty();\n+}\ndiff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ext9_empty/impl/Ext9EmptyImpl.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ext9_empty/impl/Ext9EmptyImpl.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ext9_empty/impl/Ext9EmptyImpl.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ext9_empty/impl/Ext9EmptyImpl.java\n@@ -0,0 +1,10 @@\n+package com.alibaba.dubbo.common.extensionloader.ext9_empty.impl;\n+\n+import com.alibaba.dubbo.common.extensionloader.ext9_empty.Ext9Empty;\n+\n+public class Ext9EmptyImpl implements Ext9Empty {\n+    @Override\n+    public void empty() {\n+\n+    }\n+}",
    "output": "Add unit test for ExtensionLoader"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/util/PropertySourcesUtils.java b/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/util/PropertySourcesUtils.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/util/PropertySourcesUtils.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/util/PropertySourcesUtils.java\n@@ -52,9 +52,7 @@ public static Map<String, String> getSubProperties(PropertySources propertySourc\n                     if (name.startsWith(normalizedPrefix)) {\n                         String subName = name.substring(normalizedPrefix.length());\n                         Object value = source.getProperty(name);\n-                        if (value instanceof String) {\n-                            subProperties.put(subName, String.valueOf(value));\n-                        }\n+                        subProperties.put(subName, String.valueOf(value));\n                     }\n                 }\n             }\ndiff --git a/dubbo-config/dubbo-config-spring/src/test/java/com/alibaba/dubbo/config/spring/util/PropertySourcesUtilsTest.java b/dubbo-config/dubbo-config-spring/src/test/java/com/alibaba/dubbo/config/spring/util/PropertySourcesUtilsTest.java\n--- a/dubbo-config/dubbo-config-spring/src/test/java/com/alibaba/dubbo/config/spring/util/PropertySourcesUtilsTest.java\n+++ b/dubbo-config/dubbo-config-spring/src/test/java/com/alibaba/dubbo/config/spring/util/PropertySourcesUtilsTest.java\n@@ -44,19 +44,21 @@ public void testGetSubProperties() {\n         propertySources.addFirst(propertySource);\n-        Map<String, String> result = PropertySourcesUtils.getSubProperties(propertySources, \"user\");\n+        String KEY_PREFIX = \"user\";\n+        String KEY_NAME = \"name\";\n+        String KEY_AGE = \"age\";\n+        Map<String, String> result = PropertySourcesUtils.getSubProperties(propertySources, KEY_PREFIX);\n         Assert.assertEquals(Collections.emptyMap(), result);\n-        source.put(\"user.name\", \"Mercy\");\n-        source.put(\"user.age\", \"31\");\n+        source.put(KEY_PREFIX + \".\" + KEY_NAME, \"Mercy\");\n+        source.put(KEY_PREFIX + \".\" + KEY_AGE, 31);\n         Map<String, Object> expected = new HashMap<String, Object>();\n-        expected.put(\"name\", \"Mercy\");\n-        expected.put(\"age\", \"31\");\n-\n-        result = PropertySourcesUtils.getSubProperties(propertySources, \"user\");\n+        expected.put(KEY_NAME, \"Mercy\");\n+        expected.put(KEY_AGE, \"31\");\n+        result = PropertySourcesUtils.getSubProperties(propertySources, KEY_PREFIX);\n         Assert.assertEquals(expected, result);\n         result = PropertySourcesUtils.getSubProperties(propertySources, \"\");",
    "output": "Fix number type is lost in yaml config file * #1399 fi * update test"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java b/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java\n--- a/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java\n+++ b/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java\n@@ -242,7 +242,7 @@ public void test_Async_Future() throws Exception {\n         Person ret = demoProxy.get(requestId);\n         Assert.assertEquals(null, ret);\n         Future<Person> pFuture = RpcContext.getContext().getFuture();\n-        ret = pFuture.get(1000, TimeUnit.MICROSECONDS);\n+        ret = pFuture.get(1000 * 1000, TimeUnit.MICROSECONDS);\n         Assert.assertEquals(requestId, ret.getId());\n         destroyService();\n     }\n@@ -264,8 +264,8 @@ public void test_Async_Future_Multi() throws Exception {\n         Assert.assertEquals(null, ret2);\n         Future<Person> p2Future = RpcContext.getContext().getFuture();\n-        ret = p1Future.get(1000, TimeUnit.MICROSECONDS);\n-        ret2 = p2Future.get(1000, TimeUnit.MICROSECONDS);\n+        ret = p1Future.get(1000 * 1000, TimeUnit.MICROSECONDS);\n+        ret2 = p2Future.get(1000 * 1000, TimeUnit.MICROSECONDS);\n         Assert.assertEquals(requestId1, ret.getId());\n         Assert.assertEquals(requestId2, ret.getId());\n         destroyService();\n@@ -283,7 +283,7 @@ public void test_Async_Future_Ex() throws Exception {\n             Person ret = demoProxy.get(requestId);\n             Assert.assertEquals(null, ret);\n             Future<Person> pFuture = RpcContext.getContext().getFuture();\n-            ret = pFuture.get(1000, TimeUnit.MICROSECONDS);\n+            ret = pFuture.get(1000 * 1000, TimeUnit.MICROSECONDS);\n             Assert.assertEquals(requestId, ret.getId());\n         } finally {\n             destroyService();",
    "output": "Fix time unit problem related with FutureAdapter in UT"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java b/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java\n--- a/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java\n+++ b/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java\n@@ -242,7 +242,7 @@ public void test_Async_Future() throws Exception {\n         Person ret = demoProxy.get(requestId);\n         Assert.assertEquals(null, ret);\n         Future<Person> pFuture = RpcContext.getContext().getFuture();\n-        ret = pFuture.get(1000, TimeUnit.MICROSECONDS);\n+        ret = pFuture.get(1000 * 1000, TimeUnit.MICROSECONDS);\n         Assert.assertEquals(requestId, ret.getId());\n         destroyService();\n     }\n@@ -264,8 +264,8 @@ public void test_Async_Future_Multi() throws Exception {\n         Assert.assertEquals(null, ret2);\n         Future<Person> p2Future = RpcContext.getContext().getFuture();\n-        ret = p1Future.get(1000, TimeUnit.MICROSECONDS);\n-        ret2 = p2Future.get(1000, TimeUnit.MICROSECONDS);\n+        ret = p1Future.get(1000 * 1000, TimeUnit.MICROSECONDS);\n+        ret2 = p2Future.get(1000 * 1000, TimeUnit.MICROSECONDS);\n         Assert.assertEquals(requestId1, ret.getId());\n         Assert.assertEquals(requestId2, ret.getId());\n         destroyService();",
    "output": "Fix time unit problem related with FutureAdapter in UT"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java b/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java\n--- a/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java\n+++ b/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java\n@@ -283,7 +283,7 @@ public void test_Async_Future_Ex() throws Exception {\n             Person ret = demoProxy.get(requestId);\n             Assert.assertEquals(null, ret);\n             Future<Person> pFuture = RpcContext.getContext().getFuture();\n-            ret = pFuture.get(1000, TimeUnit.MICROSECONDS);\n+            ret = pFuture.get(1000 * 1000, TimeUnit.MICROSECONDS);\n             Assert.assertEquals(requestId, ret.getId());\n         } finally {\n             destroyService();",
    "output": "Fix time unit problem in UT"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/AbstractTest.java b/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/AbstractTest.java\n--- a/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/AbstractTest.java\n+++ b/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/AbstractTest.java\n@@ -18,6 +18,7 @@\n import com.alibaba.dubbo.common.URL;\n import com.alibaba.dubbo.common.extension.ExtensionLoader;\n+import com.alibaba.dubbo.common.utils.NetUtils;\n import com.alibaba.dubbo.rpc.Invoker;\n import com.alibaba.dubbo.rpc.Protocol;\n import com.alibaba.dubbo.rpc.gen.dubbo.$__DemoStub;\n@@ -36,16 +37,19 @@\n public abstract class AbstractTest {\n-    static final int PORT = 30660;\n+    protected int PORT = NetUtils.getAvailablePort();\n     protected TServer server;\n     protected Protocol protocol;\n     protected Invoker<?> invoker;\n+    TServerTransport serverTransport;\n+\n     protected void init() throws Exception {\n-        TServerTransport serverTransport = new TServerSocket(PORT);\n+\n+        serverTransport = new TServerSocket(PORT);\n         TBinaryProtocol.Factory bFactory = new TBinaryProtocol.Factory();\n@@ -98,6 +102,15 @@ protected void destroy() throws Exception {\n             invoker = null;\n         }\n+        try{\n+            if(serverTransport != null){\n+                // release port if used\n+                serverTransport.close();\n+            }\n+        }catch (Exception e) {\n+            // ignore\n+        }\n+\n     }\n     protected TTransportFactory getTransportFactory() {\ndiff --git a/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftProtocolTest.java b/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftProtocolTest.java\n--- a/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftProtocolTest.java\n+++ b/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftProtocolTest.java\n@@ -17,6 +17,7 @@\n package com.alibaba.dubbo.rpc.protocol.thrift;\n import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.common.utils.NetUtils;\n import com.alibaba.dubbo.rpc.Invoker;\n import com.alibaba.dubbo.rpc.gen.dubbo.Demo;\n@@ -25,7 +26,7 @@\n public class ThriftProtocolTest extends AbstractTest {\n-    public static final int DEFAULT_PORT = 30660;\n+    public final int DEFAULT_PORT = NetUtils.getAvailablePort();\n     private ThriftProtocol protocol;",
    "output": "Fix travis-ci failed because of test cases"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java\n@@ -304,7 +304,7 @@ private void init() {\n         appendParameters(map, module);\n         appendParameters(map, consumer, Constants.DEFAULT_KEY);\n         appendParameters(map, this);\n-        String prifix = StringUtils.getServiceKey(map);\n+        String prefix = StringUtils.getServiceKey(map);\n         if (methods != null && methods.size() > 0) {\n             for (MethodConfig method : methods) {\n                 appendParameters(map, method, method.getName());\n@@ -315,7 +315,7 @@ private void init() {\n                         map.put(method.getName() + \".retries\", \"0\");\n                     }\n                 }\n-                appendAttributes(attributes, method, prifix + \".\" + method.getName());\n+                appendAttributes(attributes, method, prefix + \".\" + method.getName());\n                 checkAndConvertImplicitConfig(method, map, attributes);\n             }\n         }\n@@ -473,7 +473,7 @@ public void setInterface(Class<?> interfaceClass) {\n             throw new IllegalStateException(\"The interface class \" + interfaceClass + \" is not a interface!\");\n         }\n         this.interfaceClass = interfaceClass;\n-        setInterface(interfaceClass == null ? (String) null : interfaceClass.getName());\n+        setInterface(interfaceClass == null ? null : interfaceClass.getName());\n     }\n     public void setInterface(String interfaceName) {",
    "output": "Fix typo #1260"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/compiler/support/JdkCompiler.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/compiler/support/JdkCompiler.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/compiler/support/JdkCompiler.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/compiler/support/JdkCompiler.java\n@@ -67,6 +67,8 @@ public class JdkCompiler extends AbstractCompiler {\n     public JdkCompiler() {\n         options = new ArrayList<String>();\n+        options.add(\"-source\");\n+        options.add(\"1.6\");\n         options.add(\"-target\");\n         options.add(\"1.6\");\n         StandardJavaFileManager manager = compiler.getStandardFileManager(diagnosticCollector, null, null);\n@@ -101,8 +103,8 @@ public Class<?> doCompile(String name, String sourceCode) throws Throwable {\n         javaFileManager.putFileForInput(StandardLocation.SOURCE_PATH, packageName,\n                 className + ClassUtils.JAVA_EXTENSION, javaFileObject);\n         Boolean result = compiler.getTask(null, javaFileManager, diagnosticCollector, options,\n-                null, Arrays.asList(new JavaFileObject[]{javaFileObject})).call();\n-        if (result == null || !result.booleanValue()) {\n+                null, Arrays.asList(javaFileObject)).call();\n+        if (result == null || !result) {\n             throw new IllegalStateException(\"Compilation failed. class: \" + name + \", diagnostics: \" + diagnosticCollector);\n         }\n         return classLoader.loadClass(name);",
    "output": "Add \"source\" configuration to JdkCompiler"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/URLTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/URLTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/URLTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/URLTest.java\n@@ -43,7 +43,7 @@ public void test_valueOf_noProtocolAndHost() throws Exception {\n         assertNull(url.getUsername());\n         assertNull(url.getPassword());\n         assertNull(url.getHost());\n-        assertEquals(12, url.getPort());\n+        assertEquals(0, url.getPort());\n         assertEquals(\"context/path\", url.getPath());\n         assertEquals(2, url.getParameters().size());\n         assertEquals(\"1.0.0\", url.getParameter(\"version\"));\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/test/java/com/alibaba/dubbo/remoting/codec/ExchangeCodecTest.java b/dubbo-remoting/dubbo-remoting-api/src/test/java/com/alibaba/dubbo/remoting/codec/ExchangeCodecTest.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/test/java/com/alibaba/dubbo/remoting/codec/ExchangeCodecTest.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/test/java/com/alibaba/dubbo/remoting/codec/ExchangeCodecTest.java\n@@ -119,7 +119,7 @@ public void test_Decode_Error_MagicNum() throws IOException {\n     @Test\n     public void test_Decode_Error_Length() throws IOException {\n-        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, 0x20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, 0x02, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n         Person person = new Person();\n         byte[] request = getRequestBytes(person, header);\n@@ -135,7 +135,7 @@ public void test_Decode_Error_Length() throws IOException {\n     @Test\n     public void test_Decode_Error_Response_Object() throws IOException {\n         //00000010-response/oneway/hearbeat=true |20-stats=ok|id=0|length=0\n-        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, 0x20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, 0x02, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n         Person person = new Person();\n         byte[] request = getRequestBytes(person, header);\n         //bad object\n@@ -208,7 +208,7 @@ public void test_Decode_Return_Response_Error() throws IOException {\n     @Test\n     public void test_Decode_Return_Request_Event_Object() throws IOException {\n         //|10011111|20-stats=ok|id=0|length=0\n-        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, (byte) 0xff, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, (byte) 0xe2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n         Person person = new Person();\n         byte[] request = getRequestBytes(person, header);\n@@ -223,7 +223,7 @@ public void test_Decode_Return_Request_Event_Object() throws IOException {\n     @Test\n     public void test_Decode_Return_Request_Event_String() throws IOException {\n         //|10011111|20-stats=ok|id=0|length=0\n-        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, (byte) 0xff, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, (byte) 0xe2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n         String event = Request.READONLY_EVENT;\n         byte[] request = getRequestBytes(event, header);\n@@ -238,7 +238,7 @@ public void test_Decode_Return_Request_Event_String() throws IOException {\n     @Test\n     public void test_Decode_Return_Request_Heartbeat_Object() throws IOException {\n         //|10011111|20-stats=ok|id=0|length=0\n-        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, (byte) 0xff, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, (byte) 0xe2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n         byte[] request = getRequestBytes(null, header);\n         Request obj = (Request) decode(request);\n         Assert.assertEquals(null, obj.getData());\n@@ -251,7 +251,7 @@ public void test_Decode_Return_Request_Heartbeat_Object() throws IOException {\n     @Test\n     public void test_Decode_Return_Request_Object() throws IOException {\n         //|10011111|20-stats=ok|id=0|length=0\n-        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, (byte) 0xdf, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, (byte) 0xe2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n         Person person = new Person();\n         byte[] request = getRequestBytes(person, header);\n@@ -266,7 +266,7 @@ public void test_Decode_Return_Request_Object() throws IOException {\n     @Test\n     public void test_Decode_Error_Request_Object() throws IOException {\n         //00000010-response/oneway/hearbeat=true |20-stats=ok|id=0|length=0\n-        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, (byte) 0xdf, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, (byte) 0xe2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n         Person person = new Person();\n         byte[] request = getRequestBytes(person, header);\n         //bad object\n@@ -281,7 +281,7 @@ public void test_Decode_Error_Request_Object() throws IOException {\n     @Test\n     public void test_Header_Response_NoSerializationFlag() throws IOException {\n         //00000010-response/oneway/hearbeat=false/noset |20-stats=ok|id=0|length=0\n-        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, (byte) 0x02, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n         Person person = new Person();\n         byte[] request = getRequestBytes(person, header);\n@@ -294,7 +294,7 @@ public void test_Header_Response_NoSerializationFlag() throws IOException {\n     @Test\n     public void test_Header_Response_Heartbeat() throws IOException {\n         //00000010-response/oneway/hearbeat=true |20-stats=ok|id=0|length=0\n-        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, 0x20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+        byte[] header = new byte[]{MAGIC_HIGH, MAGIC_LOW, 0x02, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n         Person person = new Person();\n         byte[] request = getRequestBytes(person, header);",
    "output": "Fix UT"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-thrift/src/main/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftProtocol.java b/dubbo-rpc/dubbo-rpc-thrift/src/main/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-thrift/src/main/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-thrift/src/main/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftProtocol.java\n@@ -19,6 +19,7 @@\n import com.alibaba.dubbo.common.Constants;\n import com.alibaba.dubbo.common.URL;\n import com.alibaba.dubbo.common.extension.ExtensionLoader;\n+import com.alibaba.dubbo.common.utils.ConfigUtils;\n import com.alibaba.dubbo.remoting.Channel;\n import com.alibaba.dubbo.remoting.RemotingException;\n import com.alibaba.dubbo.remoting.Transporter;\n@@ -137,7 +138,7 @@ public void destroy() {\n                     if (logger.isInfoEnabled()) {\n                         logger.info(\"Close dubbo server: \" + server.getLocalAddress());\n                     }\n-                    server.close(getServerShutdownTimeout());\n+                    server.close(ConfigUtils.getServerShutdownTimeout());\n                 } catch (Throwable t) {\n                     logger.warn(t.getMessage(), t);\n                 }",
    "output": "Fix compilation error"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ApplicationConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ApplicationConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ApplicationConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ApplicationConfig.java\n@@ -207,7 +207,7 @@ public void setDefault(Boolean isDefault) {\n         this.isDefault = isDefault;\n     }\n-    @Parameter(key = \"dump.directory\")\n+    @Parameter(key = Constants.DUMP_DIRECTORY)\n     public String getDumpDirectory() {\n         return dumpDirectory;\n     }\n@@ -216,7 +216,7 @@ public void setDumpDirectory(String dumpDirectory) {\n         this.dumpDirectory = dumpDirectory;\n     }\n-    @Parameter(key = \"qos.enable\")\n+    @Parameter(key = Constants.QOS_ENABLE)\n     public Boolean getQosEnable() {\n         return qosEnable;\n     }\n@@ -225,7 +225,7 @@ public void setQosEnable(Boolean qosEnable) {\n         this.qosEnable = qosEnable;\n     }\n-    @Parameter(key = \"qos.port\")\n+    @Parameter(key = Constants.QOS_PORT)\n     public Integer getQosPort() {\n         return qosPort;\n     }\n@@ -234,7 +234,7 @@ public void setQosPort(Integer qosPort) {\n         this.qosPort = qosPort;\n     }\n-    @Parameter(key = \"qos.accept.foreign.ip\")\n+    @Parameter(key = Constants.ACCEPT_FOREIGN_IP)\n     public Boolean getQosAcceptForeignIp() {\n         return qosAcceptForeignIp;\n     }",
    "output": "Use constants to replace literal"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/Version.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/Version.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/Version.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/Version.java\n@@ -31,10 +31,9 @@\n  */\n public final class Version {\n+    private static final String DEFAULT_DUBBO_VERSION = \"2.0.0\";\n     private static final Logger logger = LoggerFactory.getLogger(Version.class);\n-    private static final String VERSION = getVersion(Version.class, \"2.0.0\");\n-    private static final boolean INTERNAL = hasResource(\"com/alibaba/dubbo/registry/internal/RemoteRegistry.class\");\n-    private static final boolean COMPATIBLE = hasResource(\"com/taobao/remoting/impl/ConnectionRequest.class\");\n+    private static final String VERSION = getVersion(Version.class, DEFAULT_DUBBO_VERSION);\n     static {\n         // check if there's duplicated jar\n@@ -48,13 +47,6 @@ public static String getVersion() {\n         return VERSION;\n     }\n-    public static boolean isInternalVersion() {\n-        return INTERNAL;\n-    }\n-\n-    public static boolean isCompatibleVersion() {\n-        return COMPATIBLE;\n-    }\n     private static boolean hasResource(String path) {\n         try {\ndiff --git a/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboProtocol.java b/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboProtocol.java\n@@ -18,7 +18,6 @@\n import com.alibaba.dubbo.common.Constants;\n import com.alibaba.dubbo.common.URL;\n-import com.alibaba.dubbo.common.Version;\n import com.alibaba.dubbo.common.extension.ExtensionLoader;\n import com.alibaba.dubbo.common.utils.NetUtils;\n import com.alibaba.dubbo.common.utils.StringUtils;\n@@ -342,8 +341,6 @@ private ExchangeClient initClient(URL url) {\n         // client type setting.\n         String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));\n-        String version = url.getParameter(Constants.DUBBO_VERSION_KEY);\n-        boolean compatible = (version != null && version.startsWith(\"1.0.\"));\n         url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n         // enable heartbeat by default\n         url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\ndiff --git a/dubbo-rpc/dubbo-rpc-rmi/src/main/java/com/alibaba/dubbo/rpc/protocol/rmi/RmiProtocol.java b/dubbo-rpc/dubbo-rpc-rmi/src/main/java/com/alibaba/dubbo/rpc/protocol/rmi/RmiProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-rmi/src/main/java/com/alibaba/dubbo/rpc/protocol/rmi/RmiProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-rmi/src/main/java/com/alibaba/dubbo/rpc/protocol/rmi/RmiProtocol.java\n@@ -16,9 +16,12 @@\n  */\n package com.alibaba.dubbo.rpc.protocol.rmi;\n+import com.alibaba.dubbo.common.Constants;\n import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.common.Version;\n import com.alibaba.dubbo.rpc.RpcException;\n import com.alibaba.dubbo.rpc.protocol.AbstractProxyProtocol;\n+\n import org.aopalliance.intercept.MethodInvocation;\n import org.springframework.remoting.RemoteAccessException;\n import org.springframework.remoting.rmi.RmiProxyFactoryBean;\n@@ -71,11 +74,14 @@ public void run() {\n     protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcException {\n         final RmiProxyFactoryBean rmiProxyFactoryBean = new RmiProxyFactoryBean();\n         // RMI needs extra parameter since it uses customized remote invocation object\n-        rmiProxyFactoryBean.setRemoteInvocationFactory(new RemoteInvocationFactory() {\n-            public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {\n-                return new RmiRemoteInvocation(methodInvocation);\n-            }\n-        });\n+        if (url.getParameter(Constants.DUBBO_VERSION_KEY, Version.getVersion()).equals(Version.getVersion())) {\n+            // Check dubbo version on provider, this feature only support\n+            rmiProxyFactoryBean.setRemoteInvocationFactory(new RemoteInvocationFactory() {\n+                public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {\n+                    return new RmiRemoteInvocation(methodInvocation);\n+                }\n+            });\n+        }\n         rmiProxyFactoryBean.setServiceUrl(url.toIdentityString());\n         rmiProxyFactoryBean.setServiceInterface(serviceType);\n         rmiProxyFactoryBean.setCacheStub(true);",
    "output": "Fix rmi compatible problem"
  },
  {
    "input": "diff --git a/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/validation/ValidationConsumer.java b/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/validation/ValidationConsumer.java\n--- a/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/validation/ValidationConsumer.java\n+++ b/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/validation/ValidationConsumer.java\n@@ -18,7 +18,6 @@\n import com.alibaba.dubbo.examples.validation.api.ValidationParameter;\n import com.alibaba.dubbo.examples.validation.api.ValidationService;\n-import com.alibaba.dubbo.rpc.RpcException;\n import org.springframework.context.support.ClassPathXmlApplicationContext;\n@@ -54,8 +53,8 @@ public static void main(String[] args) throws Exception {\n             parameter = new ValidationParameter();\n             validationService.save(parameter);\n             System.err.println(\"Validation Save ERROR\");\n-        } catch (RpcException e) {\n-            ConstraintViolationException ve = (ConstraintViolationException) e.getCause();\n+        } catch (Exception e) {\n+            ConstraintViolationException ve = (ConstraintViolationException) e;\n             Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();\n             System.out.println(violations);\n         }\n@@ -68,8 +67,8 @@ public static void main(String[] args) throws Exception {\n         try {\n             validationService.delete(0, \"abc\");\n             System.err.println(\"Validation Delete ERROR\");\n-        } catch (RpcException e) {\n-            ConstraintViolationException ve = (ConstraintViolationException) e.getCause();\n+        } catch (Exception e) {\n+            ConstraintViolationException ve = (ConstraintViolationException) e;\n             Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();\n             System.out.println(violations);\n         }\ndiff --git a/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/validation/ValidationProvider.java b/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/validation/ValidationProvider.java\n--- a/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/validation/ValidationProvider.java\n+++ b/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/validation/ValidationProvider.java\n@@ -24,6 +24,7 @@\n public class ValidationProvider {\n     public static void main(String[] args) throws Exception {\n+        System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n         String config = ValidationProvider.class.getPackage().getName().replace('.', '/') + \"/validation-provider.xml\";\n         ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(config);\n         context.start();",
    "output": "Add unit test for validation feature"
  },
  {
    "input": "diff --git a/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/web/util/ContextUtil.java b/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/web/util/ContextUtil.java\n--- a/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/web/util/ContextUtil.java\n+++ b/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/web/util/ContextUtil.java\n@@ -1,38 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.alibaba.dubbo.governance.web.util;\n-\n-import java.util.Map;\n-\n-/**\n- * TODO Comment of ContextUtil\n- *\n- */\n-public class ContextUtil {\n-\n-    private ContextUtil(Map<String, Object> c) {\n-    }\n-\n-    public static Object get(Map<String, Object> context, Object key, Object defaultv) {\n-        Object res = context.get(key);\n-        if (res == null) {\n-            res = defaultv;\n-        }\n-        return res;\n-    }\n-}\n-\ndiff --git a/dubbo-admin/src/test/java/com/alibaba/dubbo/registry/common/domain/PageListTest.java b/dubbo-admin/src/test/java/com/alibaba/dubbo/registry/common/domain/PageListTest.java\n--- a/dubbo-admin/src/test/java/com/alibaba/dubbo/registry/common/domain/PageListTest.java\n+++ b/dubbo-admin/src/test/java/com/alibaba/dubbo/registry/common/domain/PageListTest.java\n@@ -1,41 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.alibaba.dubbo.registry.common.domain;\n-\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-/**\n- * TODO Comment of PageListTest\n- *\n- */\n-public class PageListTest {\n-\n-    @Test\n-    public void testGetPageCount() {\n-        //int start, int limit, int total, List<T> list\n-        PageList<Object> pl = new PageList<Object>(0, 100, 52, null);\n-        Assert.assertEquals(1, pl.getPageCount());\n-\n-        pl = new PageList<Object>(0, -100, -3, null);\n-        Assert.assertEquals(1, pl.getPageCount());\n-\n-        pl = new PageList<Object>(0, 30, 100, null);\n-        Assert.assertEquals(4, pl.getPageCount());\n-    }\n-\n-}",
    "output": "Remove dubbo-admin, why it appears?"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractServiceConfig.java\n@@ -70,6 +70,9 @@ public abstract class AbstractServiceConfig extends AbstractInterfaceConfig {\n     // warm up period\n     private Integer warmup;\n+    // serialization\n+    private String serialization;\n+\n     public String getVersion() {\n         return version;\n     }\n@@ -226,4 +229,13 @@ public Integer getWarmup() {\n     public void setWarmup(Integer warmup) {\n         this.warmup = warmup;\n     }\n+\n+    public String getSerialization() {\n+        return serialization;\n+    }\n+\n+    public void setSerialization(String serialization) {\n+        this.serialization = serialization;\n+    }\n+\n }\n\\ No newline at end of file\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ProviderConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ProviderConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ProviderConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ProviderConfig.java\n@@ -67,9 +67,6 @@ public class ProviderConfig extends AbstractServiceConfig {\n     // protocol codec\n     private String codec;\n-    // serialization\n-    private String serialization;\n-\n     // charset\n     private String charset;\n@@ -216,14 +213,6 @@ public void setCodec(String codec) {\n         this.codec = codec;\n     }\n-    public String getSerialization() {\n-        return serialization;\n-    }\n-\n-    public void setSerialization(String serialization) {\n-        this.serialization = serialization;\n-    }\n-\n     public String getCharset() {\n         return charset;\n     }",
    "output": "Add service level `serialization` config"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/SunHttpServer.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/SunHttpServer.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/SunHttpServer.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/SunHttpServer.java\n@@ -1,41 +0,0 @@\n-/**\n- * Copyright 1999-2014 dangdang.com.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.alibaba.dubbo.rpc.protocol.rest;\n-\n-import com.alibaba.dubbo.common.URL;\n-import org.jboss.resteasy.plugins.server.sun.http.SunHttpJaxrsServer;\n-import org.jboss.resteasy.spi.ResteasyDeployment;\n-\n-/**\n- * @author lishen\n- */\n-public class SunHttpServer extends BaseRestServer {\n-\n-    private final SunHttpJaxrsServer server = new SunHttpJaxrsServer();\n-\n-    protected void doStart(URL url) {\n-        server.setPort(url.getPort());\n-        server.start();\n-    }\n-\n-    public void stop() {\n-        server.stop();\n-    }\n-\n-    protected ResteasyDeployment getDeployment() {\n-        return server.getDeployment();\n-    }\n-}\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/TjwsServer.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/TjwsServer.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/TjwsServer.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/TjwsServer.java\n@@ -1,45 +0,0 @@\n-/**\n- * Copyright 1999-2014 dangdang.com.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.alibaba.dubbo.rpc.protocol.rest;\n-\n-import com.alibaba.dubbo.common.URL;\n-import org.jboss.resteasy.spi.ResteasyDeployment;\n-\n-/**\n- * @author lishen\n- */\n-public class TjwsServer extends BaseRestServer {\n-\n-//    private final TJWSEmbeddedJaxrsServer server = new TJWSEmbeddedJaxrsServer();\n-\n-    protected void doStart(URL url) {\n-        throw new UnsupportedOperationException(\"TJWS server is now unsupported\");\n-//        server.setPort(url.getPort());\n-//        // below config is useless due to a resteasy bug\n-////        server.setKeepAlive(false);\n-//        server.start();\n-    }\n-\n-    protected ResteasyDeployment getDeployment() {\n-        throw new UnsupportedOperationException(\"TJWS server is now unsupported\");\n-//        return server.getDeployment();\n-    }\n-\n-    public void stop() {\n-        throw new UnsupportedOperationException(\"TJWS server is now unsupported\");\n-//        server.stop();\n-    }\n-}\ndiff --git a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/UndertowServer.java b/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/UndertowServer.java\n--- a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/UndertowServer.java\n+++ b/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/UndertowServer.java\n@@ -1,68 +0,0 @@\n-/**\n- * Copyright 1999-2014 dangdang.com.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.alibaba.dubbo.rpc.protocol.rest;\n-\n-//import com.alibaba.dubbo.common.URL;\n-//import com.alibaba.dubbo.common.utils.StringUtils;\n-//import io.undertow.Undertow;\n-//import io.undertow.servlet.api.DeploymentInfo;\n-//import org.jboss.resteasy.plugins.server.undertow.UndertowJaxrsServer;\n-//import org.jboss.resteasy.spi.ResteasyDeployment;\n-\n-/**\n- * TODO this impl hasn't been well tested, and we can consider move undertow to a general remoting-http impl in the future\n- *\n- * @author lishen\n- */\n-public class UndertowServer /*implements RestServer*/ {\n-\n-//    // Note that UndertowJaxrsServer doesn't implement EmbeddedJaxrsServer\n-//\n-//    private final ResteasyDeployment deployment = new ResteasyDeployment();\n-//\n-//    private final UndertowJaxrsServer server = new UndertowJaxrsServer();\n-//\n-//    public void start(URL url) {\n-//        deployment.start();\n-//        DeploymentInfo deploymentInfo = server.undertowDeployment(deployment);\n-//        deploymentInfo.setContextPath(\"/\");\n-//        deploymentInfo.setDeploymentName(\"dubbo-rest\");\n-//        deploymentInfo.setClassLoader(Thread.currentThread().getContextClassLoader());\n-//        server.deploy(deploymentInfo);\n-//        server.start(Undertow.builder().addHttpListener(url.getPort(), url.getHost()));\n-//    }\n-//\n-//    public void deploy(Class resourceDef, Object resourceInstance, String contextPath) {\n-//        if (StringUtils.isEmpty(contextPath)) {\n-//            deployment.getRegistry().addResourceFactory(new DubboResourceFactory(resourceInstance, resourceDef));\n-//        } else {\n-//            deployment.getRegistry().addResourceFactory(new DubboResourceFactory(resourceInstance, resourceDef), contextPath);\n-//        }\n-//    }\n-//\n-//    public void undeploy(Class resourceDef) {\n-//        deployment.getRegistry().removeRegistrations(resourceDef);\n-//    }\n-//\n-//    public void deploy(Class resourceDef, Object resourceInstance) {\n-//        deploy(resourceDef, resourceInstance, \"/\");\n-//    }\n-//\n-//    public void stop() {\n-//        deployment.stop();\n-//        server.stop();\n-//    }\n-}",
    "output": "Remove useless container integration"
  },
  {
    "input": "diff --git a/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/web/common/interceptor/LocaleValve.java b/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/web/common/interceptor/LocaleValve.java\n--- a/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/web/common/interceptor/LocaleValve.java\n+++ b/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/web/common/interceptor/LocaleValve.java\n@@ -73,7 +73,7 @@ public void invoke(PipelineContext pipelineContext) throws Exception {\n             }\n         }\n         if (locale == null || \"\".equals(locale)) {\n-            locale = \"zh\";\n+            locale = \"en\";\n         }\n         Locale newLocale = Locale.SIMPLIFIED_CHINESE;",
    "output": "Change default locale from zh to en"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n@@ -403,7 +403,7 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n                                             if (argtypes[argument.getIndex()].getName().equals(argument.getType())) {\n                                                 appendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n                                             } else {\n-                                                throw new IllegalArgumentException(\"argument config error : the index attribute and type attirbute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n+                                                throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n                                             }\n                                         } else {\n                                             // multiple callbacks in the method\n@@ -412,7 +412,7 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r\n                                                 if (argclazz.getName().equals(argument.getType())) {\n                                                     appendParameters(map, argument, method.getName() + \".\" + j);\n                                                     if (argument.getIndex() != -1 && argument.getIndex() != j) {\n-                                                        throw new IllegalArgumentException(\"argument config error : the index attribute and type attirbute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n+                                                        throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n                                                     }\n                                                 }\n                                             }",
    "output": "Fix typo"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java\n@@ -706,7 +706,7 @@ private T createAdaptiveExtension() {\n         try {\n             return injectExtension((T) getAdaptiveExtensionClass().newInstance());\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Can not create adaptive extenstion \" + type + \", cause: \" + e.getMessage(), e);\n+            throw new IllegalStateException(\"Can not create adaptive extension \" + type + \", cause: \" + e.getMessage(), e);\n         }\n     }\ndiff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoader_Adaptive_Test.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoader_Adaptive_Test.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoader_Adaptive_Test.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoader_Adaptive_Test.java\n@@ -148,7 +148,7 @@ public void test_getAdaptiveExtension_ExceptionWhenNoAdaptiveMethodOnInterface()\n             fail();\n         } catch (IllegalStateException expected) {\n             assertThat(expected.getMessage(),\n-                    allOf(containsString(\"Can not create adaptive extenstion interface com.alibaba.dubbo.common.extensionloader.ext5.NoAdaptiveMethodExt\"),\n+                    allOf(containsString(\"Can not create adaptive extension interface com.alibaba.dubbo.common.extensionloader.ext5.NoAdaptiveMethodExt\"),\n                             containsString(\"No adaptive method on extension com.alibaba.dubbo.common.extensionloader.ext5.NoAdaptiveMethodExt, refuse to create the adaptive class\")));\n         }\n         // report same error when get is invoked for multiple times\n@@ -157,7 +157,7 @@ public void test_getAdaptiveExtension_ExceptionWhenNoAdaptiveMethodOnInterface()\n             fail();\n         } catch (IllegalStateException expected) {\n             assertThat(expected.getMessage(),\n-                    allOf(containsString(\"Can not create adaptive extenstion interface com.alibaba.dubbo.common.extensionloader.ext5.NoAdaptiveMethodExt\"),\n+                    allOf(containsString(\"Can not create adaptive extension interface com.alibaba.dubbo.common.extensionloader.ext5.NoAdaptiveMethodExt\"),\n                             containsString(\"No adaptive method on extension com.alibaba.dubbo.common.extensionloader.ext5.NoAdaptiveMethodExt, refuse to create the adaptive class\")));\n         }\n     }",
    "output": "Fix typo"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/ServiceBean.java b/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/ServiceBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/ServiceBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/ServiceBean.java\n@@ -73,13 +73,13 @@ public void setApplicationContext(ApplicationContext applicationContext) {\n         if (applicationContext != null) {\n             SPRING_CONTEXT = applicationContext;\n             try {\n-                Method method = applicationContext.getClass().getMethod(\"addApplicationListener\", new Class<?>[]{ApplicationListener.class}); // Spring2.0.1\n+                Method method = applicationContext.getClass().getMethod(\"addApplicationListener\", new Class<?>[]{ApplicationListener.class}); // backward compatibility to spring 2.0.1\n                 method.invoke(applicationContext, new Object[]{this});\n                 supportedApplicationListener = true;\n             } catch (Throwable t) {\n                 if (applicationContext instanceof AbstractApplicationContext) {\n                     try {\n-                        Method method = AbstractApplicationContext.class.getDeclaredMethod(\"addListener\", new Class<?>[]{ApplicationListener.class}); // compatible with Spring2.0.1\n+                        Method method = AbstractApplicationContext.class.getDeclaredMethod(\"addListener\", new Class<?>[]{ApplicationListener.class}); // backward compatibility to spring 2.0.1\n                         if (!method.isAccessible()) {\n                             method.setAccessible(true);\n                         }",
    "output": "Change comment to english"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoader_Adaptive_Test.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoader_Adaptive_Test.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoader_Adaptive_Test.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/extensionloader/ExtensionLoader_Adaptive_Test.java\n@@ -188,7 +188,7 @@ public void test_getAdaptiveExtension_ExceptionWhenNoUrlAttribute() throws Excep\n             ExtensionLoader.getExtensionLoader(NoUrlParamExt.class).getAdaptiveExtension();\n             fail();\n         } catch (Exception expected) {\n-            assertThat(expected.getMessage(), containsString(\"fail to create adative class for interface \"));\n+            assertThat(expected.getMessage(), containsString(\"fail to create adaptive class for interface \"));\n             assertThat(expected.getMessage(), containsString(\": not found url parameter or url attribute in parameters of method \"));\n         }\n     }",
    "output": "Fix unit test failure"
  },
  {
    "input": "diff --git a/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/annotation/AnnotationConsumer.java b/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/annotation/AnnotationConsumer.java\n--- a/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/annotation/AnnotationConsumer.java\n+++ b/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/annotation/AnnotationConsumer.java\n@@ -15,9 +15,13 @@\n  */\n package com.alibaba.dubbo.examples.annotation;\n+import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;\n import com.alibaba.dubbo.examples.annotation.action.AnnotationAction;\n-import org.springframework.context.support.ClassPathXmlApplicationContext;\n+import org.springframework.context.annotation.AnnotationConfigApplicationContext;\n+import org.springframework.context.annotation.ComponentScan;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.PropertySource;\n /**\n  * CallbackConsumer\n@@ -27,13 +31,20 @@\n public class AnnotationConsumer {\n     public static void main(String[] args) throws Exception {\n-        String config = AnnotationConsumer.class.getPackage().getName().replace('.', '/') + \"/annotation-consumer.xml\";\n-        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(config);\n+        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConsumerConfiguration.class);\n         context.start();\n         final AnnotationAction annotationAction = (AnnotationAction) context.getBean(\"annotationAction\");\n         String hello = annotationAction.doSayHello(\"world\");\n         System.out.println(\"result :\" + hello);\n         System.in.read();\n     }\n+    @Configuration\n+    @EnableDubbo(scanBasePackages = \"com.alibaba.dubbo.examples.annotation.action\", multipleConfig = true)\n+    @PropertySource(\"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-consumer.properties\")\n+    @ComponentScan(value = {\"com.alibaba.dubbo.examples.annotation.action\"})\n+    static public class ConsumerConfiguration {\n+\n+    }\n+\n }\ndiff --git a/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/annotation/AnnotationProvider.java b/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/annotation/AnnotationProvider.java\n--- a/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/annotation/AnnotationProvider.java\n+++ b/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/annotation/AnnotationProvider.java\n@@ -15,7 +15,13 @@\n  */\n package com.alibaba.dubbo.examples.annotation;\n-import org.springframework.context.support.ClassPathXmlApplicationContext;\n+import com.alibaba.dubbo.config.ProviderConfig;\n+import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;\n+\n+import org.springframework.context.annotation.AnnotationConfigApplicationContext;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.PropertySource;\n /**\n  * MergeProvider\n@@ -25,10 +31,22 @@\n public class AnnotationProvider {\n     public static void main(String[] args) throws Exception {\n-        String config = AnnotationProvider.class.getPackage().getName().replace('.', '/') + \"/annotation-provider.xml\";\n-        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(config);\n+        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class);\n         context.start();\n         System.in.read();\n     }\n+    @Configuration\n+    @EnableDubbo(scanBasePackages = \"com.alibaba.dubbo.examples.annotation.impl\", multipleConfig = true)\n+    @PropertySource(\"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-provider.properties\")\n+//    @ComponentScan(value = {\"com.alibaba.dubbo.examples.annotation.impl\"})\n+    static public class ProviderConfiguration {\n+        @Bean\n+        public ProviderConfig providerConfig() {\n+            ProviderConfig providerConfig = new ProviderConfig();\n+            providerConfig.setTimeout(1000);\n+            return providerConfig;\n+        }\n+    }\n+\n }",
    "output": "Upgrade annotation demo"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/router/file/FileRouterFactory.java b/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/router/file/FileRouterFactory.java\n--- a/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/router/file/FileRouterFactory.java\n+++ b/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/router/file/FileRouterFactory.java\n@@ -50,7 +50,9 @@ public Router getRouter(URL url) {\n                 }\n             }\n             String rule = IOUtils.read(new FileReader(new File(url.getAbsolutePath())));\n-            URL script = url.setProtocol(protocol).addParameter(Constants.TYPE_KEY, type).addParameterAndEncoded(Constants.RULE_KEY, rule);\n+\n+            boolean runtime = url.getParameter(Constants.RUNTIME_KEY, false);\n+            URL script = url.setProtocol(protocol).addParameter(Constants.TYPE_KEY, type).addParameter(Constants.RUNTIME_KEY, runtime).addParameterAndEncoded(Constants.RULE_KEY, rule);\n             return routerFactory.getRouter(script);\n         } catch (IOException e) {\ndiff --git a/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java b/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java\n--- a/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java\n+++ b/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/router/file/FileRouterEngineTest.java\n@@ -15,6 +15,7 @@\n  */\n package com.alibaba.dubbo.rpc.cluster.router.file;\n+import com.alibaba.dubbo.common.Constants;\n import com.alibaba.dubbo.common.URL;\n import com.alibaba.dubbo.common.extension.ExtensionLoader;\n import com.alibaba.dubbo.rpc.Invocation;\n@@ -132,6 +133,7 @@ public void testRouteByMethodName() {\n     private URL initUrl(String filename) {\n         filename = getClass().getClassLoader().getResource(getClass().getPackage().getName().replace('.', '/') + \"/\" + filename).toString();\n         URL url = URL.valueOf(filename);\n+        url = url.addParameter(Constants.RUNTIME_KEY, true);\n         return url;\n     }",
    "output": "Fix unit test: add runtime=true key to url"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NamedThreadFactory.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NamedThreadFactory.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NamedThreadFactory.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NamedThreadFactory.java\n@@ -31,7 +31,7 @@ public class NamedThreadFactory implements ThreadFactory {\n     private final String mPrefix;\n-    private final boolean mDaemo;\n+    private final boolean mDaemon;\n     private final ThreadGroup mGroup;\n@@ -43,17 +43,17 @@ public NamedThreadFactory(String prefix) {\n         this(prefix, false);\n     }\n-    public NamedThreadFactory(String prefix, boolean daemo) {\n+    public NamedThreadFactory(String prefix, boolean daemon) {\n         mPrefix = prefix + \"-thread-\";\n-        mDaemo = daemo;\n+        mDaemon = daemon;\n         SecurityManager s = System.getSecurityManager();\n         mGroup = (s == null) ? Thread.currentThread().getThreadGroup() : s.getThreadGroup();\n     }\n     public Thread newThread(Runnable runnable) {\n         String name = mPrefix + mThreadNum.getAndIncrement();\n         Thread ret = new Thread(mGroup, runnable, name, 0);\n-        ret.setDaemon(mDaemo);\n+        ret.setDaemon(mDaemon);\n         return ret;\n     }",
    "output": "Fix typo in NamedThreadFactory: mDeamo"
  },
  {
    "input": "diff --git a/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/SimpleMonitorService.java b/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/SimpleMonitorService.java\n--- a/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/SimpleMonitorService.java\n+++ b/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/SimpleMonitorService.java\n@@ -67,7 +67,6 @@ public class SimpleMonitorService implements MonitorService {\n     private static final String[] types = {SUCCESS, FAILURE, ELAPSED, CONCURRENT, MAX_ELAPSED, MAX_CONCURRENT};\n     private static final String POISON_PROTOCOL = \"poison\";\n-    private static SimpleMonitorService INSTANCE = null;\n     // \n     private final ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"DubboMonitorTimer\", true));\n     // \n@@ -107,11 +106,8 @@ public void run() {\n                 }\n             }\n         }, 1, 300, TimeUnit.SECONDS);\n-        INSTANCE = this;\n-    }\n-\n-    public static SimpleMonitorService getInstance() {\n-        return INSTANCE;\n+        statisticsDirectory = ConfigUtils.getProperty(\"dubbo.statistics.directory\");\n+        chartsDirectory = ConfigUtils.getProperty(\"dubbo.charts.directory\");\n     }\n     private static void createChart(String key, String service, String method, String date, String[] types, Map<String, long[]> data, double[] summary, String path) {\n@@ -181,26 +177,6 @@ private static String toDisplayDate(String date) {\n         }\n     }\n-    public String getStatisticsDirectory() {\n-        return statisticsDirectory;\n-    }\n-\n-    public void setStatisticsDirectory(String statistics) {\n-        if (statistics != null) {\n-            this.statisticsDirectory = statistics;\n-        }\n-    }\n-\n-    public String getChartsDirectory() {\n-        return chartsDirectory;\n-    }\n-\n-    public void setChartsDirectory(String charts) {\n-        if (charts != null) {\n-            this.chartsDirectory = charts;\n-        }\n-    }\n-\n     public void close() {\n         try {\n             running = false;\ndiff --git a/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/pages/ChartsPageHandler.java b/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/pages/ChartsPageHandler.java\n--- a/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/pages/ChartsPageHandler.java\n+++ b/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/pages/ChartsPageHandler.java\n@@ -16,10 +16,10 @@\n package com.alibaba.dubbo.monitor.simple.pages;\n import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.common.utils.ConfigUtils;\n import com.alibaba.dubbo.container.page.Page;\n import com.alibaba.dubbo.container.page.PageHandler;\n import com.alibaba.dubbo.monitor.MonitorService;\n-import com.alibaba.dubbo.monitor.simple.SimpleMonitorService;\n import java.io.File;\n import java.text.SimpleDateFormat;\n@@ -44,7 +44,7 @@ public Page handle(URL url) {\n             date = new SimpleDateFormat(\"yyyyMMdd\").format(new Date());\n         }\n         List<List<String>> rows = new ArrayList<List<String>>();\n-        String directory = SimpleMonitorService.getInstance().getChartsDirectory();\n+        String directory = ConfigUtils.getProperty(\"dubbo.charts.directory\");\n         File chartsDir = new File(directory);\n         String filename = directory + \"/\" + date + \"/\" + service;\n         File serviceDir = new File(filename);\ndiff --git a/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/pages/StatisticsPageHandler.java b/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/pages/StatisticsPageHandler.java\n--- a/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/pages/StatisticsPageHandler.java\n+++ b/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/pages/StatisticsPageHandler.java\n@@ -16,11 +16,11 @@\n package com.alibaba.dubbo.monitor.simple.pages;\n import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.common.utils.ConfigUtils;\n import com.alibaba.dubbo.container.page.Page;\n import com.alibaba.dubbo.container.page.PageHandler;\n import com.alibaba.dubbo.monitor.MonitorService;\n import com.alibaba.dubbo.monitor.simple.CountUtils;\n-import com.alibaba.dubbo.monitor.simple.SimpleMonitorService;\n import java.io.File;\n import java.text.SimpleDateFormat;\n@@ -48,7 +48,7 @@ public Page handle(URL url) {\n         }\n         String expand = url.getParameter(\"expand\");\n         List<List<String>> rows = new ArrayList<List<String>>();\n-        String directory = SimpleMonitorService.getInstance().getStatisticsDirectory();\n+        String directory = ConfigUtils.getProperty(\"dubbo.statistics.directory\");\n         String filename = directory + \"/\" + date + \"/\" + service;\n         File serviceDir = new File(filename);\n         if (serviceDir.exists()) {",
    "output": "remove unreasonable instance getter in SimpleMonitorService"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/AnnotationBean.java b/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/AnnotationBean.java\n--- a/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/AnnotationBean.java\n+++ b/dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/AnnotationBean.java\n@@ -57,6 +57,7 @@\n  * @author william.liangf\n  * @export\n  */\n+@Deprecated\n public class AnnotationBean extends AbstractConfig implements DisposableBean, BeanFactoryPostProcessor, BeanPostProcessor, ApplicationContextAware {\n     private static final long serialVersionUID = -7582802454287589552L;",
    "output": "Upgrade version to 2.5.7"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/proxy/AbstractProxyInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/proxy/AbstractProxyInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/proxy/AbstractProxyInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/proxy/AbstractProxyInvoker.java\n@@ -81,8 +81,8 @@ public Result invoke(Invocation invocation) throws RpcException {\n     @Override\n     public String toString() {\n-        return getInterface() + \" -> \" + getUrl() == null ? \" \" : getUrl().toString();\n+        return getInterface() + \" -> \" + (getUrl() == null ? \" \" : getUrl().toString());\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Fix(abstractproxyinvoker):fix NPE problem NPE bug fixed"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/test/java/com/alibaba/dubbo/config/validation/ValidationTest.java b/dubbo-config/dubbo-config-api/src/test/java/com/alibaba/dubbo/config/validation/ValidationTest.java\n--- a/dubbo-config/dubbo-config-api/src/test/java/com/alibaba/dubbo/config/validation/ValidationTest.java\n+++ b/dubbo-config/dubbo-config-api/src/test/java/com/alibaba/dubbo/config/validation/ValidationTest.java\n@@ -89,6 +89,7 @@ public void testValidation() {\n                 } catch (RpcException e) {\n                     ConstraintViolationException ve = (ConstraintViolationException) e.getCause();\n                     Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();\n+                    Assert.assertTrue(violations.size() == 3);\n                     Assert.assertNotNull(violations);\n                 }\ndiff --git a/dubbo-filter/dubbo-filter-validation/src/main/java/com/alibaba/dubbo/validation/support/jvalidation/JValidator.java b/dubbo-filter/dubbo-filter-validation/src/main/java/com/alibaba/dubbo/validation/support/jvalidation/JValidator.java\n--- a/dubbo-filter/dubbo-filter-validation/src/main/java/com/alibaba/dubbo/validation/support/jvalidation/JValidator.java\n+++ b/dubbo-filter/dubbo-filter-validation/src/main/java/com/alibaba/dubbo/validation/support/jvalidation/JValidator.java\n@@ -231,7 +231,7 @@ else if (memberValue instanceof ArrayMemberValue) {\n     }\n     public void validate(String methodName, Class<?>[] parameterTypes, Object[] arguments) throws Exception {\n-        String methodClassName = clazz.getName() + \"_\" + toUpperMethoName(methodName);\n+        String methodClassName = clazz.getName() + \"$\" + toUpperMethoName(methodName);\n         Class<?> methodClass = null;\n         try {\n             methodClass = Class.forName(methodClassName, false, Thread.currentThread().getContextClassLoader());",
    "output": "Fix(beanvalidation): close #787"
  },
  {
    "input": "diff --git a/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/service/impl/OverrideServiceImpl.java b/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/service/impl/OverrideServiceImpl.java\n--- a/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/service/impl/OverrideServiceImpl.java\n+++ b/dubbo-admin/src/main/java/com/alibaba/dubbo/governance/service/impl/OverrideServiceImpl.java\n@@ -75,7 +75,7 @@ public void enableOverride(Long id) {\n             return;\n         }\n-        URL newOverride = oldOverride.addParameter(\"enabled\", \"enabled\");\n+        URL newOverride = oldOverride.addParameter(\"enabled\", true);\n         registryService.unregister(oldOverride);\n         registryService.register(newOverride);",
    "output": "Upgrade OverrideServiceImpl.java fix the bug: cant enable override"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/PortTelnetHandlerTest.java b/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/PortTelnetHandlerTest.java\n--- a/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/PortTelnetHandlerTest.java\n+++ b/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/PortTelnetHandlerTest.java\n@@ -59,6 +59,11 @@ public void after() {\n         ProtocolUtils.closeAll();\n     }\n+    /**\n+     * NATserver channel.getRemoteAddress()NAT\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testListClient() throws Exception {\n         ExchangeClient client1 = Exchangers.connect(\"dubbo://127.0.0.1:20887/demo\");\n@@ -70,8 +75,8 @@ public void testListClient() throws Exception {\n         System.out.printf(\"Result: %s %n\", result);\n         System.out.printf(\"Client 1 Address %s %n\", client1Addr);\n         System.out.printf(\"Client 2 Address %s %n\", client2Addr);\n-        assertTrue(result.contains(client1Addr));\n-        assertTrue(result.contains(client2Addr));\n+        assertTrue(result.contains(String.valueOf(client1.getLocalAddress().getPort())));\n+        assertTrue(result.contains(String.valueOf(client2.getLocalAddress().getPort())));\n     }",
    "output": "Fix unit test PortTelnetHandlerTest"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/com/alibaba/dubbo/rpc/filter/ActiveLimitFilterTest.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/com/alibaba/dubbo/rpc/filter/ActiveLimitFilterTest.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/com/alibaba/dubbo/rpc/filter/ActiveLimitFilterTest.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/com/alibaba/dubbo/rpc/filter/ActiveLimitFilterTest.java\n@@ -20,11 +20,14 @@\n import com.alibaba.dubbo.rpc.Invocation;\n import com.alibaba.dubbo.rpc.Invoker;\n import com.alibaba.dubbo.rpc.RpcException;\n+import com.alibaba.dubbo.rpc.support.BlockMyInvoker;\n import com.alibaba.dubbo.rpc.support.MockInvocation;\n import com.alibaba.dubbo.rpc.support.MyInvoker;\n import org.junit.Test;\n+import java.util.concurrent.CountDownLatch;\n+\n import static org.junit.Assert.assertNotSame;\n /**\n@@ -56,12 +59,18 @@ public void testInvokeLessActives() {\n     @Test\n     public void testInvokeGreaterActives() {\n         URL url = URL.valueOf(\"test://test:11/test?accesslog=true&group=dubbo&version=1.1&actives=1&timeout=1\");\n-        final Invoker<ActiveLimitFilterTest> invoker = new MyInvoker<ActiveLimitFilterTest>(url);\n+        final Invoker<ActiveLimitFilterTest> invoker = new BlockMyInvoker<ActiveLimitFilterTest>(url, 100);\n         final Invocation invocation = new MockInvocation();\n+        final CountDownLatch latch = new CountDownLatch(1);\n         for (int i = 0; i < 100; i++) {\n             Thread thread = new Thread(new Runnable() {\n                 public void run() {\n+                    try {\n+                        latch.await();\n+                    } catch (InterruptedException e) {\n+                        e.printStackTrace();\n+                    }\n                     for (int i = 0; i < 100; i++) {\n                         try {\n                             activeLimitFilter.invoke(invoker, invocation);\n@@ -73,6 +82,8 @@ public void run() {\n             });\n             thread.start();\n         }\n+        latch.countDown();\n+\n         try {\n             Thread.sleep(1000);\n         } catch (InterruptedException e) {\ndiff --git a/dubbo-rpc/dubbo-rpc-api/src/test/java/com/alibaba/dubbo/rpc/support/BlockMyInvoker.java b/dubbo-rpc/dubbo-rpc-api/src/test/java/com/alibaba/dubbo/rpc/support/BlockMyInvoker.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/test/java/com/alibaba/dubbo/rpc/support/BlockMyInvoker.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/test/java/com/alibaba/dubbo/rpc/support/BlockMyInvoker.java\n@@ -0,0 +1,51 @@\n+package com.alibaba.dubbo.rpc.support;\n+\n+import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.rpc.Invocation;\n+import com.alibaba.dubbo.rpc.Result;\n+import com.alibaba.dubbo.rpc.RpcException;\n+import com.alibaba.dubbo.rpc.RpcResult;\n+\n+/**\n+ * @author ken.lj\n+ * @date 2017/10/24\n+ */\n+public class BlockMyInvoker<T> extends MyInvoker<T> {\n+\n+    private long blockTime = 100;\n+\n+    public BlockMyInvoker(URL url, long blockTime) {\n+        super(url);\n+        this.blockTime = blockTime;\n+    }\n+\n+    public BlockMyInvoker(URL url, boolean hasException, long blockTime) {\n+        super(url, hasException);\n+        this.blockTime = blockTime;\n+    }\n+\n+    @Override\n+    public Result invoke(Invocation invocation) throws RpcException {\n+        RpcResult result = new RpcResult();\n+        if (hasException == false) {\n+            try {\n+                Thread.sleep(blockTime);\n+            } catch (InterruptedException e) {\n+            }\n+            result.setValue(\"alibaba\");\n+            return result;\n+        } else {\n+            result.setException(new RuntimeException(\"mocked exception\"));\n+            return result;\n+        }\n+\n+    }\n+\n+    public long getBlockTime() {\n+        return blockTime;\n+    }\n+\n+    public void setBlockTime(long blockTime) {\n+        this.blockTime = blockTime;\n+    }\n+}",
    "output": "Fix unix test unstable in different env"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java b/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n--- a/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n+++ b/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\n@@ -48,7 +48,7 @@ public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invo\n     protected int getWeight(Invoker<?> invoker, Invocation invocation) {\n         int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\n         if (weight > 0) {\n-            long timestamp = invoker.getUrl().getParameter(Constants.TIMESTAMP_KEY, 0L);\n+            long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);\n             if (timestamp > 0L) {\n                 int uptime = (int) (System.currentTimeMillis() - timestamp);\n                 int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);\ndiff --git a/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/ClusterUtils.java b/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/ClusterUtils.java\n--- a/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/ClusterUtils.java\n+++ b/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/ClusterUtils.java\n@@ -80,6 +80,8 @@ public static URL mergeUrl(URL remoteUrl, Map<String, String> localMap) {\n             if (methods != null && methods.length() > 0) {\n                 map.put(Constants.METHODS_KEY, methods);\n             }\n+            // providertimestamp\n+            map.put(Constants.REMOTE_TIMESTAMP_KEY, remoteMap.get(Constants.TIMESTAMP_KEY));\n             // filterlistener\n             String remoteFilter = remoteMap.get(Constants.REFERENCE_FILTER_KEY);\n             String localFilter = localMap.get(Constants.REFERENCE_FILTER_KEY);\ndiff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/Constants.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/Constants.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/Constants.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/Constants.java\n@@ -296,6 +296,8 @@ public class Constants {\n     public static final String TIMESTAMP_KEY = \"timestamp\";\n+    public static final String REMOTE_TIMESTAMP_KEY = \"remote.timestamp\";\n+\n     public static final String WARMUP_KEY = \"warmup\";\n     public static final int DEFAULT_WARMUP = 10 * 60 * 1000;",
    "output": "Fix warmup timestamp bug, add 'remote.timestamp' key to url on consumer side"
  },
  {
    "input": "diff --git a/hessian-lite/src/main/java/com/alibaba/com/caucho/hessian/io/java8/LocalDateTimeHandle.java b/hessian-lite/src/main/java/com/alibaba/com/caucho/hessian/io/java8/LocalDateTimeHandle.java\n--- a/hessian-lite/src/main/java/com/alibaba/com/caucho/hessian/io/java8/LocalDateTimeHandle.java\n+++ b/hessian-lite/src/main/java/com/alibaba/com/caucho/hessian/io/java8/LocalDateTimeHandle.java\n@@ -4,7 +4,6 @@\n import java.io.Serializable;\n import java.lang.reflect.Method;\n-import java.time.LocalDateTime;\n @SuppressWarnings(\"unchecked\")\n public class LocalDateTimeHandle implements HessianHandle, Serializable {",
    "output": "Fix java8 compilation issue"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/logger/slf4j/Slf4jLogger.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/logger/slf4j/Slf4jLogger.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/logger/slf4j/Slf4jLogger.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/logger/slf4j/Slf4jLogger.java\n@@ -1,76 +1,148 @@\n package com.alibaba.dubbo.common.logger.slf4j;\n import com.alibaba.dubbo.common.logger.Logger;\n+import com.alibaba.dubbo.common.logger.support.FailsafeLogger;\n+\n+import org.slf4j.spi.LocationAwareLogger;\n import java.io.Serializable;\n public class Slf4jLogger implements Logger, Serializable {\n     private static final long serialVersionUID = 1L;\n+    private static final String FQCN = FailsafeLogger.class.getName();\n+\n     private final org.slf4j.Logger logger;\n+    private final LocationAwareLogger locationAwareLogger;\n+\n     public Slf4jLogger(org.slf4j.Logger logger) {\n+        if (logger instanceof LocationAwareLogger) {\n+            locationAwareLogger = (LocationAwareLogger) logger;\n+        } else {\n+            locationAwareLogger = null;\n+        }\n         this.logger = logger;\n     }\n     public void trace(String msg) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n+            return;\n+        }\n         logger.trace(msg);\n     }\n     public void trace(Throwable e) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n+            return;\n+        }\n         logger.trace(e.getMessage(), e);\n     }\n     public void trace(String msg, Throwable e) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n+            return;\n+        }\n         logger.trace(msg, e);\n     }\n     public void debug(String msg) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n+            return;\n+        }\n         logger.debug(msg);\n     }\n     public void debug(Throwable e) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n+            return;\n+        }\n         logger.debug(e.getMessage(), e);\n     }\n     public void debug(String msg, Throwable e) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n+            return;\n+        }\n         logger.debug(msg, e);\n     }\n     public void info(String msg) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n+            return;\n+        }\n         logger.info(msg);\n     }\n     public void info(Throwable e) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n+            return;\n+        }\n         logger.info(e.getMessage(), e);\n     }\n     public void info(String msg, Throwable e) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n+            return;\n+        }\n         logger.info(msg, e);\n     }\n     public void warn(String msg) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n+            return;\n+        }\n         logger.warn(msg);\n     }\n     public void warn(Throwable e) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n+            return;\n+        }\n         logger.warn(e.getMessage(), e);\n     }\n     public void warn(String msg, Throwable e) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n+            return;\n+        }\n         logger.warn(msg, e);\n     }\n     public void error(String msg) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n+            return;\n+        }\n         logger.error(msg);\n     }\n     public void error(Throwable e) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n+            return;\n+        }\n         logger.error(e.getMessage(), e);\n     }\n     public void error(String msg, Throwable e) {\n+        if (locationAwareLogger != null) {\n+            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n+            return;\n+        }\n         logger.error(msg, e);\n     }\n@@ -94,4 +166,4 @@ public boolean isErrorEnabled() {\n         return logger.isErrorEnabled();\n     }\n-}\n+}\n\\ No newline at end of file",
    "output": "Make Slf4jLogger location aware"
  },
  {
    "input": "diff --git a/dubbo-container/dubbo-container-api/src/main/java/com/alibaba/dubbo/container/Main.java b/dubbo-container/dubbo-container-api/src/main/java/com/alibaba/dubbo/container/Main.java\n--- a/dubbo-container/dubbo-container-api/src/main/java/com/alibaba/dubbo/container/Main.java\n+++ b/dubbo-container/dubbo-container-api/src/main/java/com/alibaba/dubbo/container/Main.java\n@@ -26,6 +26,8 @@\n import java.util.Arrays;\n import java.util.Date;\n import java.util.List;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n /**\n  * Main. (API, Static, ThreadSafe)\n@@ -42,7 +44,9 @@ public class Main {\n     private static final ExtensionLoader<Container> loader = ExtensionLoader.getExtensionLoader(Container.class);\n-    private static volatile boolean running = true;\n+    private static final ReentrantLock LOCK = new ReentrantLock();\n+\n+    private static final Condition STOP = LOCK.newCondition();\n     public static void main(String[] args) {\n         try {\n@@ -67,9 +71,11 @@ public void run() {\n                             } catch (Throwable t) {\n                                 logger.error(t.getMessage(), t);\n                             }\n-                            synchronized (Main.class) {\n-                                running = false;\n-                                Main.class.notify();\n+                            try {\n+                                LOCK.lock();\n+                                STOP.signal();\n+                            } finally {\n+                                LOCK.unlock();\n                             }\n                         }\n                     }\n@@ -86,13 +92,13 @@ public void run() {\n             logger.error(e.getMessage(), e);\n             System.exit(1);\n         }\n-        synchronized (Main.class) {\n-            while (running) {\n-                try {\n-                    Main.class.wait();\n-                } catch (Throwable e) {\n-                }\n-            }\n+        try {\n+            LOCK.lock();\n+            STOP.await();\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Dubbo service server stopped, interrupted by other thread!\", e);\n+        } finally {\n+            LOCK.unlock();\n         }\n     }",
    "output": "change Main.class wait/notify to lock/condition"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java\n@@ -750,7 +750,7 @@ private String createAdaptiveExtensionClassCode() {\n         codeBuidler.append(\"package \" + type.getPackage().getName() + \";\");\n         codeBuidler.append(\"\\nimport \" + ExtensionLoader.class.getName() + \";\");\n-        codeBuidler.append(\"\\npublic class \" + type.getSimpleName() + \"$Adpative\" + \" implements \" + type.getCanonicalName() + \" {\");\n+        codeBuidler.append(\"\\npublic class \" + type.getSimpleName() + \"$Adaptive\" + \" implements \" + type.getCanonicalName() + \" {\");\n         for (Method method : methods) {\n             Class<?> rt = method.getReturnType();",
    "output": "Fix misspell of 'adaptive' in ExtensionLoader"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/ExecuteLimitFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/ExecuteLimitFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/ExecuteLimitFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/ExecuteLimitFilter.java\n@@ -55,20 +55,20 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept\n             }\n         }\n         long begin = System.currentTimeMillis();\n-        boolean isException = false;\n+        boolean isSuccess = true;\n         RpcStatus.beginCount(url, methodName);\n         try {\n             Result result = invoker.invoke(invocation);\n             return result;\n         } catch (Throwable t) {\n-            isException = true;\n+            isSuccess = false;\n             if (t instanceof RuntimeException) {\n                 throw (RuntimeException) t;\n             } else {\n                 throw new RpcException(\"unexpected exception when ExecuteLimitFilter\", t);\n             }\n         } finally {\n-            RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, isException);\n+            RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, isSuccess);\n             if(acquireResult) {\n                 executesLimit.release();\n             }",
    "output": "Fix count reverse problem(failure counted as success) in ExecuteLimitFilter"
  },
  {
    "input": "diff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/all/AllChannelHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/all/AllChannelHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/all/AllChannelHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/all/AllChannelHandler.java\n@@ -15,8 +15,6 @@\n  */\n package com.alibaba.dubbo.remoting.transport.dispatcher.all;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.RejectedExecutionException;\n import com.alibaba.dubbo.common.URL;\n import com.alibaba.dubbo.remoting.Channel;\n import com.alibaba.dubbo.remoting.ChannelHandler;\n@@ -29,6 +27,7 @@\n import com.alibaba.dubbo.remoting.transport.dispatcher.WrappedChannelHandler;\n import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.RejectedExecutionException;\n public class AllChannelHandler extends WrappedChannelHandler {\n@@ -59,7 +58,8 @@ public void received(Channel channel, Object message) throws RemotingException {\n         try {\n             cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));\n         } catch (Throwable t) {\n-        \t//fix \n+            //TODO \n+            //fix \n         \tif(message instanceof Request && t instanceof RejectedExecutionException){\n         \t\tRequest request = (Request)message;\n         \t\tif(request.isTwoWay()){\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/execution/ExecutionChannelHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/execution/ExecutionChannelHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/execution/ExecutionChannelHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/execution/ExecutionChannelHandler.java\n@@ -15,8 +15,6 @@\n  */\n package com.alibaba.dubbo.remoting.transport.dispatcher.execution;\n-import java.util.concurrent.RejectedExecutionException;\n-\n import com.alibaba.dubbo.common.URL;\n import com.alibaba.dubbo.remoting.Channel;\n import com.alibaba.dubbo.remoting.ChannelHandler;\n@@ -28,6 +26,8 @@\n import com.alibaba.dubbo.remoting.transport.dispatcher.ChannelEventRunnable.ChannelState;\n import com.alibaba.dubbo.remoting.transport.dispatcher.WrappedChannelHandler;\n+import java.util.concurrent.RejectedExecutionException;\n+\n public class ExecutionChannelHandler extends WrappedChannelHandler {\n     public ExecutionChannelHandler(ChannelHandler handler, URL url) {\n@@ -46,7 +46,8 @@ public void received(Channel channel, Object message) throws RemotingException {\n     \ttry {\n             executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));\n         } catch (Throwable t) {\n-        \t//fix \n+            //TODO \n+            //fix \n         \tif(message instanceof Request &&\n         \t\t\tt instanceof RejectedExecutionException){\n         \t\tRequest request = (Request)message;\ndiff --git a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/message/MessageOnlyChannelHandler.java b/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/message/MessageOnlyChannelHandler.java\n--- a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/message/MessageOnlyChannelHandler.java\n+++ b/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/message/MessageOnlyChannelHandler.java\n@@ -15,16 +15,11 @@\n  */\n package com.alibaba.dubbo.remoting.transport.dispatcher.message;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.RejectedExecutionException;\n-\n import com.alibaba.dubbo.common.URL;\n import com.alibaba.dubbo.remoting.Channel;\n import com.alibaba.dubbo.remoting.ChannelHandler;\n import com.alibaba.dubbo.remoting.ExecutionException;\n import com.alibaba.dubbo.remoting.RemotingException;\n-import com.alibaba.dubbo.remoting.exchange.Request;\n-import com.alibaba.dubbo.remoting.exchange.Response;\n import com.alibaba.dubbo.remoting.transport.dispatcher.ChannelEventRunnable;\n import com.alibaba.dubbo.remoting.transport.dispatcher.ChannelEventRunnable.ChannelState;\n import com.alibaba.dubbo.remoting.transport.dispatcher.WrappedChannelHandler;\n@@ -45,18 +40,6 @@ public void received(Channel channel, Object message) throws RemotingException {\n         try {\n             cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));\n         } catch (Throwable t) {\n-        \t//fix \n-        \tif(message instanceof Request && t instanceof RejectedExecutionException){\n-        \t\tRequest request = (Request)message;\n-        \t\tif(request.isTwoWay()){\n-        \t\t\tString msg = \"Server side(\" + url.getIp() + \",\" + url.getPort() + \") threadpool is exhausted ,detail msg:\" + t.getMessage();\n-        \t\t\tResponse response = new Response(request.getId(), request.getVersion());\n-        \t\t\tresponse.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);\n-        \t\t\tresponse.setErrorMessage(msg);\n-        \t\t\tchannel.send(response);\n-        \t\t\treturn;\n-        \t\t}\n-        \t}\n             throw new ExecutionException(message, channel, getClass() + \" error when process received event .\", t);\n         }\n     }",
    "output": "Add todo tag for AllChannelHandler"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/TimeoutFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/TimeoutFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/TimeoutFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/TimeoutFilter.java\n@@ -46,7 +46,7 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept\n                 \"timeout\", Integer.MAX_VALUE)) {\n             if (logger.isWarnEnabled()) {\n                 logger.warn(\"invoke time out. method: \" + invocation.getMethodName()\n-                        + \"arguments: \" + Arrays.toString(invocation.getArguments()) + \" , url is \"\n+                        + \" arguments: \" + Arrays.toString(invocation.getArguments()) + \" , url is \"\n                         + invoker.getUrl() + \", invoke elapsed \" + elapsed + \" ms.\");\n             }\n         }",
    "output": "Fix add space , optimize log output"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/serialize/support/json/FastJsonObjectOutput.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/serialize/support/json/FastJsonObjectOutput.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/serialize/support/json/FastJsonObjectOutput.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/serialize/support/json/FastJsonObjectOutput.java\n@@ -89,6 +89,7 @@ public void writeObject(Object obj) throws IOException {\n         serializer.config(SerializerFeature.WriteEnumUsingToString, true);\n         serializer.write(obj);\n         out.writeTo(writer);\n+        out.close(); // for reuse SerializeWriter buf\n         writer.println();\n         writer.flush();\n     }",
    "output": "Upgrade for fastjson * close SerializeWriter for reuse SerializeWriter buf * update fastjson version"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-redis/src/main/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocol.java b/dubbo-rpc/dubbo-rpc-redis/src/main/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-redis/src/main/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-redis/src/main/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocol.java\n@@ -1,12 +1,12 @@\n /*\n  * Copyright 1999-2012 Alibaba Group.\n- *\n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -30,7 +30,7 @@\n import com.alibaba.dubbo.rpc.protocol.AbstractInvoker;\n import com.alibaba.dubbo.rpc.protocol.AbstractProtocol;\n-import org.apache.commons.pool2.impl.GenericObjectPoolConfig;\n+import org.apache.commons.pool.impl.GenericObjectPool;\n import redis.clients.jedis.Jedis;\n import redis.clients.jedis.JedisPool;\n import redis.clients.jedis.exceptions.JedisConnectionException;\n@@ -67,24 +67,24 @@ private Serialization getSerialization(URL url) {\n     public <T> Invoker<T> refer(final Class<T> type, final URL url) throws RpcException {\n         try {\n-            GenericObjectPoolConfig config = new GenericObjectPoolConfig();\n-            config.setTestOnBorrow(url.getParameter(\"test.on.borrow\", true));\n-            config.setTestOnReturn(url.getParameter(\"test.on.return\", false));\n-            config.setTestWhileIdle(url.getParameter(\"test.while.idle\", false));\n+            GenericObjectPool.Config config = new GenericObjectPool.Config();\n+            config.testOnBorrow = url.getParameter(\"test.on.borrow\", true);\n+            config.testOnReturn = url.getParameter(\"test.on.return\", false);\n+            config.testWhileIdle = url.getParameter(\"test.while.idle\", false);\n             if (url.getParameter(\"max.idle\", 0) > 0)\n-                config.setMaxIdle(url.getParameter(\"max.idle\", 0));\n+                config.maxIdle = url.getParameter(\"max.idle\", 0);\n             if (url.getParameter(\"min.idle\", 0) > 0)\n-                config.setMinIdle(url.getParameter(\"min.idle\", 0));\n-            if (url.getParameter(\"max.total\", 0) > 0)\n-                config.setMaxTotal(url.getParameter(\"max.total\", 0));\n+                config.minIdle = url.getParameter(\"min.idle\", 0);\n+            if (url.getParameter(\"max.active\", 0) > 0)\n+                config.maxActive = url.getParameter(\"max.active\", 0);\n             if (url.getParameter(\"max.wait\", 0) > 0)\n-                config.setMaxWaitMillis(url.getParameter(\"max.wait\", 0));\n+                config.maxWait = url.getParameter(\"max.wait\", 0);\n             if (url.getParameter(\"num.tests.per.eviction.run\", 0) > 0)\n-                config.setNumTestsPerEvictionRun(url.getParameter(\"num.tests.per.eviction.run\", 0));\n+                config.numTestsPerEvictionRun = url.getParameter(\"num.tests.per.eviction.run\", 0);\n             if (url.getParameter(\"time.between.eviction.runs.millis\", 0) > 0)\n-                config.setTimeBetweenEvictionRunsMillis(url.getParameter(\"time.between.eviction.runs.millis\", 0));\n+                config.timeBetweenEvictionRunsMillis = url.getParameter(\"time.between.eviction.runs.millis\", 0);\n             if (url.getParameter(\"min.evictable.idle.time.millis\", 0) > 0)\n-                config.setMinEvictableIdleTimeMillis(url.getParameter(\"min.evictable.idle.time.millis\", 0));\n+                config.minEvictableIdleTimeMillis = url.getParameter(\"min.evictable.idle.time.millis\", 0);\n             final JedisPool jedisPool = new JedisPool(config, url.getHost(), url.getPort(DEFAULT_PORT),\n                     url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));\n             final int expiry = url.getParameter(\"expiry\", 0);",
    "output": "Fix compilation error after merge 'dependency upgrade branch'"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-redis/src/main/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocol.java b/dubbo-rpc/dubbo-rpc-redis/src/main/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-redis/src/main/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-redis/src/main/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocol.java\n@@ -30,7 +30,7 @@\n import com.alibaba.dubbo.rpc.protocol.AbstractInvoker;\n import com.alibaba.dubbo.rpc.protocol.AbstractProtocol;\n-import org.apache.commons.pool.impl.GenericObjectPool;\n+import org.apache.commons.pool2.impl.GenericObjectPoolConfig;\n import redis.clients.jedis.Jedis;\n import redis.clients.jedis.JedisPool;\n import redis.clients.jedis.exceptions.JedisConnectionException;\n@@ -67,24 +67,24 @@ private Serialization getSerialization(URL url) {\n     public <T> Invoker<T> refer(final Class<T> type, final URL url) throws RpcException {\n         try {\n-            GenericObjectPool.Config config = new GenericObjectPool.Config();\n-            config.testOnBorrow = url.getParameter(\"test.on.borrow\", true);\n-            config.testOnReturn = url.getParameter(\"test.on.return\", false);\n-            config.testWhileIdle = url.getParameter(\"test.while.idle\", false);\n+            GenericObjectPoolConfig config = new GenericObjectPoolConfig();\n+            config.setTestOnBorrow(url.getParameter(\"test.on.borrow\", true));\n+            config.setTestOnReturn(url.getParameter(\"test.on.return\", false));\n+            config.setTestWhileIdle(url.getParameter(\"test.while.idle\", false));\n             if (url.getParameter(\"max.idle\", 0) > 0)\n-                config.maxIdle = url.getParameter(\"max.idle\", 0);\n+                config.setMaxIdle(url.getParameter(\"max.idle\", 0));\n             if (url.getParameter(\"min.idle\", 0) > 0)\n-                config.minIdle = url.getParameter(\"min.idle\", 0);\n-            if (url.getParameter(\"max.active\", 0) > 0)\n-                config.maxActive = url.getParameter(\"max.active\", 0);\n+                config.setMinIdle(url.getParameter(\"min.idle\", 0));\n+            if (url.getParameter(\"max.total\", 0) > 0)\n+                config.setMaxTotal(url.getParameter(\"max.total\", 0));\n             if (url.getParameter(\"max.wait\", 0) > 0)\n-                config.maxWait = url.getParameter(\"max.wait\", 0);\n+                config.setMaxWaitMillis(url.getParameter(\"max.wait\", 0));\n             if (url.getParameter(\"num.tests.per.eviction.run\", 0) > 0)\n-                config.numTestsPerEvictionRun = url.getParameter(\"num.tests.per.eviction.run\", 0);\n+                config.setNumTestsPerEvictionRun(url.getParameter(\"num.tests.per.eviction.run\", 0));\n             if (url.getParameter(\"time.between.eviction.runs.millis\", 0) > 0)\n-                config.timeBetweenEvictionRunsMillis = url.getParameter(\"time.between.eviction.runs.millis\", 0);\n+                config.setTimeBetweenEvictionRunsMillis(url.getParameter(\"time.between.eviction.runs.millis\", 0));\n             if (url.getParameter(\"min.evictable.idle.time.millis\", 0) > 0)\n-                config.minEvictableIdleTimeMillis = url.getParameter(\"min.evictable.idle.time.millis\", 0);\n+                config.setMinEvictableIdleTimeMillis(url.getParameter(\"min.evictable.idle.time.millis\", 0));\n             final JedisPool jedisPool = new JedisPool(config, url.getHost(), url.getPort(DEFAULT_PORT),\n                     url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));\n             final int expiry = url.getParameter(\"expiry\", 0);",
    "output": "Fix compilation error after merge 'dependency upgrade branch'"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/AbstractClusterInvoker.java b/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/AbstractClusterInvoker.java\n@@ -212,7 +212,7 @@ private Invoker<T> reselect(LoadBalance loadbalance,Invocation invocation,\n     public Result invoke(final Invocation invocation) throws RpcException {\n-        checkWheatherDestoried();\n+        checkWhetherDestroyed();\n         LoadBalance loadbalance;\n@@ -227,7 +227,7 @@ public Result invoke(final Invocation invocation) throws RpcException {\n         return doInvoke(invocation, invokers, loadbalance);\n     }\n-    protected void checkWheatherDestoried() {\n+    protected void checkWhetherDestroyed() {\n         if(destroyed){\n             throw new RpcException(\"Rpc cluster invoker for \" + getInterface() + \" on consumer \" + NetUtils.getLocalHost()\ndiff --git a/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/FailoverClusterInvoker.java b/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/FailoverClusterInvoker.java\n--- a/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/FailoverClusterInvoker.java\n+++ b/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/FailoverClusterInvoker.java\n@@ -65,7 +65,7 @@ public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, L\n         \t//invoker.\n         \t//invokedinvoker\n         \tif (i > 0) {\n-        \t\tcheckWheatherDestoried();\n+        \t\tcheckWhetherDestroyed();\n         \t\tcopyinvokers = list(invocation);\n         \t\t//\n         \t\tcheckInvokers(copyinvokers, invocation);",
    "output": "Fix typo of method"
  },
  {
    "input": "diff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/URLTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/URLTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/URLTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/URLTest.java\n@@ -623,4 +623,10 @@ public void test_Localhost() throws Exception {\n         assertTrue(url.isLocalHost());\n     }\n+    @Test\n+    public void test_Path() throws Exception {\n+        URL url = new URL(\"dubbo\", \"localhost\", 20880, \"////path\");\n+        assertEquals(\"path\", url.getPath());\n+    }\n+\n }\n\\ No newline at end of file",
    "output": "Add unit test for parsing path"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/AtomicPositiveInteger.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/AtomicPositiveInteger.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/AtomicPositiveInteger.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/AtomicPositiveInteger.java\n@@ -167,20 +167,16 @@ public String toString() {\n     public int hashCode() {\n         final int prime = 31;\n         int result = 1;\n-        result = prime * result + ((i == null) ? 0 : i.hashCode());\n+        result = prime * result + i.hashCode();\n         return result;\n     }\n     @Override\n     public boolean equals(Object obj) {\n         if (this == obj) return true;\n-        if (obj == null) return false;\n-        if (getClass() != obj.getClass()) return false;\n+        if (!(obj instanceof AtomicPositiveInteger)) return false;\n         AtomicPositiveInteger other = (AtomicPositiveInteger) obj;\n-        if (i == null) {\n-            if (other.i != null) return false;\n-        } else if (!i.equals(other.i)) return false;\n-        return true;\n+        return i.intValue() == other.i.intValue();\n     }\n }\n\\ No newline at end of file\ndiff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/AtomicPositiveIntegerTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/AtomicPositiveIntegerTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/AtomicPositiveIntegerTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/AtomicPositiveIntegerTest.java\n@@ -1,18 +1,18 @@\n-/*\n- * Copyright 1999-2011 Alibaba Group.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n+/*\n+ * Copyright 1999-2011 Alibaba Group.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.alibaba.dubbo.common.utils;\n import static org.hamcrest.CoreMatchers.allOf;\n@@ -158,4 +158,10 @@ public void test_addAndGet() throws Exception {\n         assertEquals(2, get);\n         assertEquals(2, i3.get());\n     }\n+\n+    @Test\n+    public void test_equals() {\n+        assertEquals(new AtomicPositiveInteger(), new AtomicPositiveInteger());\n+        assertEquals(new AtomicPositiveInteger(1), new AtomicPositiveInteger(1));\n+    }\n }\n\\ No newline at end of file",
    "output": "Fix hashCode & equals implementation for AtomicPositiveInteger"
  },
  {
    "input": "diff --git a/dubbo-registry/dubbo-registry-default/src/test/java/com/alibaba/dubbo/registry/dubbo/RegistryDirectoryTest.java b/dubbo-registry/dubbo-registry-default/src/test/java/com/alibaba/dubbo/registry/dubbo/RegistryDirectoryTest.java\n--- a/dubbo-registry/dubbo-registry-default/src/test/java/com/alibaba/dubbo/registry/dubbo/RegistryDirectoryTest.java\n+++ b/dubbo-registry/dubbo-registry-default/src/test/java/com/alibaba/dubbo/registry/dubbo/RegistryDirectoryTest.java\n@@ -550,12 +550,12 @@ public void testNotifyRouterUrls() {\n         List<Router> routers = registryDirectory.getRouters();\n         //default invocation selector\n         Assert.assertEquals(1+1, routers.size());\n-        Assert.assertEquals(ScriptRouter.class, routers.get(1).getClass());\n+        Assert.assertTrue(ScriptRouter.class == routers.get(1).getClass() || ScriptRouter.class == routers.get(0).getClass());\n         registryDirectory.notify(new ArrayList<URL>());\n         routers = registryDirectory.getRouters();\n         Assert.assertEquals(1 + 1, routers.size());\n-        Assert.assertEquals(ScriptRouter.class, routers.get(1).getClass());\n+        Assert.assertTrue(ScriptRouter.class == routers.get(1).getClass() || ScriptRouter.class == routers.get(0).getClass());\n         serviceUrls.clear();\n         serviceUrls.add(routerurl.addParameter(Constants.ROUTER_KEY, Constants.ROUTER_TYPE_CLEAR));",
    "output": "Fix UT failure for com.alibaba.dubbo.registry.dubbo.RegistryDirectoryTest#testNotifyRouterUrls"
  },
  {
    "input": "diff --git a/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/support/Menu.java b/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/support/Menu.java\n--- a/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/support/Menu.java\n+++ b/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/support/Menu.java\n@@ -31,7 +31,9 @@ public class Menu {\n     public Menu() {}\n     public Menu( Map<String, List<String>> menus ) {\n-        this.menus.putAll( menus );\n+        for (String key : menus.keySet()) {\n+            this.menus.put(key, new ArrayList<String>(menus.get(key)));\n+        }\n     }\n     public void putMenuItem( String menu, String item ) {\ndiff --git a/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/support/MergeableClusterInvokerTest.java b/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/support/MergeableClusterInvokerTest.java\n--- a/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/support/MergeableClusterInvokerTest.java\n+++ b/dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/support/MergeableClusterInvokerTest.java\n@@ -22,6 +22,7 @@\n import com.alibaba.dubbo.rpc.Result;\n import com.alibaba.dubbo.rpc.RpcResult;\n import com.alibaba.dubbo.rpc.cluster.Directory;\n+import junit.framework.TestCase;\n import org.easymock.EasyMock;\n import org.junit.Assert;\n import org.junit.Before;\n@@ -31,6 +32,8 @@\n import java.lang.reflect.Method;\n import java.lang.reflect.Proxy;\n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -46,44 +49,23 @@ public class MergeableClusterInvokerTest {\n     private Invocation invocation = EasyMock.createMock( Invocation.class );\n     private MergeableClusterInvoker<MenuService> mergeableClusterInvoker;\n-\n+\n+    private String[] list1 = {\"10\", \"11\", \"12\"};\n+    private String[] list2 = {\"20\", \"21\", \"22\"};\n+    private String[] list3 = {\"23\", \"24\", \"25\"};\n+    private String[] list4 = {\"30\", \"31\", \"32\"};\n+\n     private Map<String, List<String>> firstMenuMap = new HashMap<String, List<String>>() {\n         {\n-            put( \"1\", new ArrayList<String>() {\n-                {\n-                    add( \"10\" );\n-                    add( \"11\" );\n-                    add( \"12\" );\n-                }\n-            } );\n-            put( \"2\", new ArrayList<String>() {\n-\n-                {\n-                    add( \"20\" );\n-                    add( \"21\" );\n-                    add( \"22\" );\n-                }\n-            } );\n+            put( \"1\", Arrays.asList(list1));\n+            put( \"2\", Arrays.asList(list2));\n         }\n     };\n+\n     private Map<String, List<String>> secondMenuMap = new HashMap<String, List<String>>() {\n         {\n-            put( \"2\", new ArrayList<String>() {\n-\n-                {\n-                    add( \"23\" );\n-                    add( \"24\" );\n-                    add( \"25\" );\n-                }\n-            } );\n-            put( \"3\", new ArrayList<String>() {\n-\n-                {\n-                    add( \"30\" );\n-                    add( \"31\" );\n-                    add( \"32\" );\n-                }\n-            } );\n+            put( \"2\", Arrays.asList(list3));\n+            put( \"3\", Arrays.asList(list4));\n         }\n     };\n@@ -170,8 +152,16 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl\n         Map<String, List<String>> expected = new HashMap<String, List<String>>();\n         merge( expected, firstMenuMap );\n         merge( expected, secondMenuMap );\n-        Assert.assertEquals( expected, menu.getMenus() );\n-\n+        TestCase.assertEquals(expected.keySet(), menu.getMenus().keySet());\n+        for (String key : expected.keySet()) {\n+            // FIXME: cannot guarantee the sequence of the merge result, check implementation in\n+            // MergeableClusterInvoker#invoke\n+            List<String> values1 = new ArrayList<String>(expected.get(key));\n+            List<String> values2 = new ArrayList<String>(menu.getMenus().get(key));\n+            Collections.sort(values1);\n+            Collections.sort(values2);\n+            TestCase.assertEquals(values1, values2);\n+        }\n     }\n     @Test\n@@ -235,7 +225,7 @@ static void merge( Map<String, List<String>> first, Map<String, List<String>> se\n             if ( value != null ) {\n                 value.addAll( entry.getValue() );\n             } else {\n-                first.put( entry.getKey(), entry.getValue() );\n+                first.put( entry.getKey(), new ArrayList<String>(entry.getValue()) );\n             }\n         }\n     }",
    "output": "Fix unit test issue in MergeableClusterInvokerTest"
  },
  {
    "input": "diff --git a/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/CountUtils.java b/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/CountUtils.java\n--- a/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/CountUtils.java\n+++ b/dubbo-simple/dubbo-monitor-simple/src/main/java/com/alibaba/dubbo/monitor/simple/CountUtils.java\n@@ -46,11 +46,11 @@ public static long sum(File file) {\n     }\n     public static long max(File file) {\n-        return calc(file, SUM);\n+        return calc(file, MAX);\n     }\n     public static long avg(File file) {\n-        return calc(file, SUM);\n+        return calc(file, AVG);\n     }\n     private static long calc(File file, int op) {\n@@ -90,4 +90,4 @@ private static long calc(File file, int op) {\n         return 0;\n     }\n-}\n\\ No newline at end of file\n+}",
    "output": "Upgrade CountUtils.java update monitor count op code"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/compiler/support/JavassistCompiler.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/compiler/support/JavassistCompiler.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/compiler/support/JavassistCompiler.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/compiler/support/JavassistCompiler.java\n@@ -120,7 +120,7 @@ public Class<?> doCompile(String name, String source) throws Throwable {\n                 }\n             }\n         }\n-        return cls.toClass(ClassHelper.getCallerClassLoader(getClass()), null);\n+        return cls.toClass(ClassHelper.getCallerClassLoader(getClass()), JavassistCompiler.class.getProtectionDomain());\n     }\n }",
    "output": "Add ProtectionDomain for dynamicly created class"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/GenericFilter.java b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/GenericFilter.java\n--- a/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/GenericFilter.java\n+++ b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/GenericFilter.java\n@@ -52,7 +52,7 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {\n         if (inv.getMethodName().equals(Constants.$INVOKE)\n                 && inv.getArguments() != null\n                 && inv.getArguments().length == 3\n-                && ! invoker.getUrl().getParameter(Constants.GENERIC_KEY, false)) {\n+                && ! ProtocolUtils.isGeneric(invoker.getUrl().getParameter(Constants.GENERIC_KEY))) {\n             String name = ((String) inv.getArguments()[0]).trim();\n             String[] types = (String[]) inv.getArguments()[1];\n             Object[] args = (Object[]) inv.getArguments()[2];",
    "output": "Fix bug"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/beanutil/JavaBeanSerializeUtil.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/beanutil/JavaBeanSerializeUtil.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/beanutil/JavaBeanSerializeUtil.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/beanutil/JavaBeanSerializeUtil.java\n@@ -101,7 +101,7 @@ private static void serializeInternal(JavaBeanDescriptor descriptor, Object obj,\n             for (int i = 0; i < len; i++) {\n                 Object item = Array.get(obj, i);\n                 if (item == null) {\n-                    descriptor.setProperty(i++, null);\n+                    descriptor.setProperty(i, null);\n                 } else {\n                     JavaBeanDescriptor itemDescriptor = createDescriptorIfAbsent(item, accessor, cache);\n                     descriptor.setProperty(i, itemDescriptor);\ndiff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/beanutil/JavaBeanSerializeUtilTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/beanutil/JavaBeanSerializeUtilTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/beanutil/JavaBeanSerializeUtilTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/beanutil/JavaBeanSerializeUtilTest.java\n@@ -79,6 +79,19 @@ public void testSerialize_Array() throws Exception {\n                                 ((JavaBeanDescriptor) descriptor.getProperty(i)).getPrimitiveProperty());\n         }\n+        Integer[] integers = new Integer[]{1, 2, 3, 4, null, null, null};\n+        descriptor = JavaBeanSerializeUtil.serialize(integers, JavaBeanAccessor.METHOD);\n+        Assert.assertTrue(descriptor.isArrayType());\n+        Assert.assertEquals(Integer.class.getName(), descriptor.getClassName());\n+        Assert.assertEquals(integers.length, descriptor.propertySize());\n+        for(int i = 0; i < integers.length; i++) {\n+            if (integers[i] == null) {\n+                Assert.assertTrue(integers[i] == descriptor.getProperty(i));\n+            } else {\n+                Assert.assertEquals(integers[i], ((JavaBeanDescriptor)descriptor.getProperty(i)).getPrimitiveProperty());\n+            }\n+        }\n+\n         int[][] second = {{1, 2}, {3, 4}};\n         descriptor = JavaBeanSerializeUtil.serialize(second, JavaBeanAccessor.METHOD);\n         Assert.assertTrue(descriptor.isArrayType());",
    "output": "Fix bug"
  },
  {
    "input": "diff --git a/dubbo-container/dubbo-container-logback/src/main/java/com/alibaba/dubbo/container/logback/LogbackContainer.java b/dubbo-container/dubbo-container-logback/src/main/java/com/alibaba/dubbo/container/logback/LogbackContainer.java\n--- a/dubbo-container/dubbo-container-logback/src/main/java/com/alibaba/dubbo/container/logback/LogbackContainer.java\n+++ b/dubbo-container/dubbo-container-logback/src/main/java/com/alibaba/dubbo/container/logback/LogbackContainer.java\n@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 1999-2012 Alibaba Group.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.dubbo.container.logback;\n+\n+import org.slf4j.LoggerFactory;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.Logger;\n+import ch.qos.logback.classic.LoggerContext;\n+import ch.qos.logback.classic.encoder.PatternLayoutEncoder;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.rolling.RollingFileAppender;\n+import ch.qos.logback.core.rolling.TimeBasedRollingPolicy;\n+\n+import com.alibaba.dubbo.common.utils.ConfigUtils;\n+import com.alibaba.dubbo.common.utils.StringUtils;\n+import com.alibaba.dubbo.container.Container;\n+\n+/**\n+ * LogbackContainer. (SPI, Singleton, ThreadSafe)\n+ *\n+ * @author {@link \"mailto:qq55355383@gmail.com\" \"yi.tong\"}\n+ * @date May 30, 2012\n+ */\n+public class LogbackContainer implements Container {\n+\n+\tpublic static final String LOGBACK_FILE = \"dubbo.logback.file\";\n+\n+\tpublic static final String LOGBACK_LEVEL = \"dubbo.logback.level\";\n+\n+\tpublic static final String LOGBACK_MAX_HISTORY = \"dubbo.logback.maxhistory\";\n+\n+\tpublic static final String DEFAULT_LOGBACK_LEVEL = \"ERROR\";\n+\n+\tpublic void start() {\n+\t\tString file = ConfigUtils.getProperty(LOGBACK_FILE);\n+\t\tif (file != null && file.length() > 0) {\n+\t\t\tString level = ConfigUtils.getProperty(LOGBACK_LEVEL);\n+\t\t\tif (level == null || level.length() == 0) {\n+\t\t\t\tlevel = DEFAULT_LOGBACK_LEVEL;\n+\t\t\t}\n+\t\t\t// maxHistory=0 Infinite history\n+\t\t\tint maxHistory = StringUtils.parseInteger(ConfigUtils.getProperty(LOGBACK_MAX_HISTORY));\n+\n+\t\t\tdoInitializer(file, level, maxHistory);\n+\t\t}\n+\t}\n+\n+\tpublic void stop() {\n+\t}\n+\n+\t/**\n+\t * Initializer logback\n+\t *\n+\t * @param file\n+\t * @param level\n+\t * @param maxHistory\n+\t */\n+\tprivate void doInitializer(String file, String level, int maxHistory) {\n+\t\tLoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();\n+\t\tLogger rootLogger = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);\n+\t\trootLogger.detachAndStopAllAppenders();\n+\n+\t\t// appender\n+\t\tRollingFileAppender<ILoggingEvent> fileAppender = new RollingFileAppender<ILoggingEvent>();\n+\t\tfileAppender.setContext(loggerContext);\n+\t\tfileAppender.setName(\"application\");\n+\t\tfileAppender.setFile(file);\n+\t\tfileAppender.setAppend(true);\n+\n+\t\t// policy\n+\t\tTimeBasedRollingPolicy<ILoggingEvent> policy = new TimeBasedRollingPolicy<ILoggingEvent>();\n+\t\tpolicy.setContext(loggerContext);\n+\t\tpolicy.setMaxHistory(maxHistory);\n+\t\tpolicy.setFileNamePattern(file + \".%d{yyyy-MM-dd}\");\n+\t\tpolicy.setParent(fileAppender);\n+\t\tpolicy.start();\n+\t\tfileAppender.setRollingPolicy(policy);\n+\n+\t\t// encoder\n+\t\tPatternLayoutEncoder encoder = new PatternLayoutEncoder();\n+\t\tencoder.setContext(loggerContext);\n+\t\tencoder.setPattern(\"%date [%thread] %-5level %logger (%file:%line\\\\) - %msg%n\");\n+\t\tencoder.start();\n+\t\tfileAppender.setEncoder(encoder);\n+\n+\t\tfileAppender.start();\n+\n+\t\trootLogger.addAppender(fileAppender);\n+\t\trootLogger.setLevel(Level.toLevel(level));\n+\t\trootLogger.setAdditive(false);\n+\t}\n+\n+}\n\\ No newline at end of file\ndiff --git a/dubbo-container/dubbo-container-logback/src/test/java/com/alibaba/dubbo/container/logback/LogbackContainerTest.java b/dubbo-container/dubbo-container-logback/src/test/java/com/alibaba/dubbo/container/logback/LogbackContainerTest.java\n--- a/dubbo-container/dubbo-container-logback/src/test/java/com/alibaba/dubbo/container/logback/LogbackContainerTest.java\n+++ b/dubbo-container/dubbo-container-logback/src/test/java/com/alibaba/dubbo/container/logback/LogbackContainerTest.java\n@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 1999-2011 Alibaba Group.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.dubbo.container.logback;\n+\n+import org.junit.Test;\n+\n+import com.alibaba.dubbo.common.extension.ExtensionLoader;\n+import com.alibaba.dubbo.common.logger.Logger;\n+import com.alibaba.dubbo.common.logger.LoggerFactory;\n+import com.alibaba.dubbo.container.Container;\n+\n+/**\n+ * StandaloneContainerTest\n+ *\n+ * @author {@link \"mailto:qq55355383@gmail.com\" \"yi.tong\"}\n+ * @date May 30, 2012\n+ */\n+public class LogbackContainerTest {\n+\n+\tprivate static final Logger logger = LoggerFactory.getLogger(LogbackContainerTest.class);\n+\n+\t@Test\n+\tpublic void testContainer() {\n+\t\tLogbackContainer container = (LogbackContainer) ExtensionLoader.getExtensionLoader(Container.class)\n+\t\t\t\t.getExtension(\"logback\");\n+\t\tcontainer.start();\n+\n+\t\tlogger.debug(\"Test debug:\" + this.getClass().getName());\n+\t\tlogger.warn(\"Test warn:\" + this.getClass().getName());\n+\t\tlogger.info(\"Test info:\" + this.getClass().getName());\n+\t\tlogger.error(\"Test error:\" + this.getClass().getName());\n+\n+\t\tcontainer.stop();\n+\t}\n+\n+}\n\\ No newline at end of file",
    "output": "Add logback container"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/PortTelnetHandlerTest.java b/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/PortTelnetHandlerTest.java\n--- a/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/PortTelnetHandlerTest.java\n+++ b/dubbo-rpc/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/PortTelnetHandlerTest.java\n@@ -19,11 +19,14 @@\n import static org.junit.Assert.assertTrue;\n import org.easymock.EasyMock;\n+import org.easymock.IAnswer;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.common.logger.Logger;\n+import com.alibaba.dubbo.common.logger.LoggerFactory;\n import com.alibaba.dubbo.remoting.RemotingException;\n import com.alibaba.dubbo.remoting.exchange.ExchangeClient;\n import com.alibaba.dubbo.remoting.exchange.Exchangers;\n@@ -60,12 +63,18 @@ public void after() {\n     }\n     @Test\n-    public void testListClient() throws RemotingException {\n+    public void testListClient() throws Exception {\n         ExchangeClient client1 = Exchangers.connect(\"dubbo://127.0.0.1:20887/demo\");\n         ExchangeClient client2 = Exchangers.connect(\"dubbo://127.0.0.1:20887/demo\");\n+        Thread.sleep(5000);\n         String result = port.telnet(null, \"-l 20887\");\n-        assertTrue(result.contains(client1.getLocalAddress().toString()));\n-        assertTrue(result.contains(client2.getLocalAddress().toString()));\n+        String client1Addr = client1.getLocalAddress().toString();\n+        String client2Addr = client2.getLocalAddress().toString();\n+        System.out.printf(\"Result: %s %n\", result);\n+        System.out.printf(\"Client 1 Address %s %n\", client1Addr);\n+        System.out.printf(\"Client 2 Address %s %n\", client2Addr);\n+        assertTrue(result.contains(client1Addr));\n+        assertTrue(result.contains(client2Addr));\n     }",
    "output": "Fix test case"
  },
  {
    "input": "diff --git a/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftCodecTest.java b/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftCodecTest.java\n--- a/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftCodecTest.java\n+++ b/dubbo-rpc/dubbo-rpc-thrift/src/test/java/com/alibaba/dubbo/rpc/protocol/thrift/ThriftCodecTest.java\n@@ -22,8 +22,7 @@\n import com.alibaba.dubbo.rpc.RpcException;\n import com.alibaba.dubbo.rpc.RpcInvocation;\n import com.alibaba.dubbo.rpc.RpcResult;\n-import com.alibaba.dubbo.rpc.gen.dubbo.$__DemoStub;\n-import com.alibaba.dubbo.rpc.gen.dubbo.Demo;\n+import com.alibaba.dubbo.rpc.gen.thrift.Demo;\n import com.alibaba.dubbo.rpc.protocol.thrift.io.RandomAccessByteArrayOutputStream;\n import org.apache.thrift.TApplicationException;\n import org.apache.thrift.protocol.TBinaryProtocol;\n@@ -44,6 +43,7 @@\n public class ThriftCodecTest {\n     private ThriftCodec codec = new ThriftCodec();\n+    private Channel channel = new MockedChannel(URL.valueOf(\"thrift://127.0.0.1\"));\n     @Test\n     public void testEncodeRequest() throws Exception {\n@@ -52,7 +52,7 @@ public void testEncodeRequest() throws Exception {\n         ByteArrayOutputStream output = new ByteArrayOutputStream( 1024 );\n-        codec.encode( ( Channel ) null, output, request );\n+        codec.encode( channel, output, request );\n         byte[] bytes = output.toByteArray();\n@@ -82,7 +82,7 @@ public void testEncodeRequest() throws Exception {\n         // version\n         Assert.assertEquals( ThriftCodec.VERSION, protocol.readByte() );\n         // service name\n-        Assert.assertEquals( Demo.class.getName(), protocol.readString() );\n+        Assert.assertEquals( Demo.Iface.class.getName(), protocol.readString() );\n         // dubbo request id\n         Assert.assertEquals( request.getId(), protocol.readI64() );\n@@ -94,7 +94,7 @@ public void testEncodeRequest() throws Exception {\n         TMessage message = protocol.readMessageBegin();\n-        $__DemoStub.echoString_args args = new $__DemoStub.echoString_args();\n+        Demo.echoString_args args = new Demo.echoString_args();\n         args.read( protocol );\n@@ -111,7 +111,7 @@ public void testEncodeRequest() throws Exception {\n     @Test\n     public void testDecodeReplyResponse() throws Exception {\n-        URL url = URL.valueOf( ThriftProtocol.NAME + \"://127.0.0.1:40880/\" + Demo.class.getName() );\n+        URL url = URL.valueOf( ThriftProtocol.NAME + \"://127.0.0.1:40880/\" + Demo.Iface.class.getName() );\n         Channel channel = new MockedChannel( url );\n@@ -123,7 +123,7 @@ public void testDecodeReplyResponse() throws Exception {\n         TMessage message = new TMessage( \"echoString\", TMessageType.REPLY, ThriftCodec.getSeqId() );\n-        $__DemoStub.echoString_result methodResult = new $__DemoStub.echoString_result();\n+        Demo.echoString_result methodResult = new Demo.echoString_result();\n         methodResult.success = \"Hello, World!\";\n@@ -137,7 +137,7 @@ public void testDecodeReplyResponse() throws Exception {\n         protocol.writeI32( Integer.MAX_VALUE );\n         protocol.writeI16( Short.MAX_VALUE );\n         protocol.writeByte( ThriftCodec.VERSION );\n-        protocol.writeString( Demo.class.getName() );\n+        protocol.writeString( Demo.Iface.class.getName() );\n         protocol.writeI64( request.getId() );\n         protocol.getTransport().flush();\n         headerLength = bos.size();\n@@ -254,7 +254,7 @@ public void testDecodeExceptionResponse() throws Exception {\n     @Test\n     public void testEncodeReplyResponse() throws Exception {\n-        URL url = URL.valueOf( ThriftProtocol.NAME + \"://127.0.0.1:40880/\" + Demo.class.getName() );\n+        URL url = URL.valueOf( ThriftProtocol.NAME + \"://127.0.0.1:40880/\" + Demo.Iface.class.getName() );\n         Channel channel = new MockedChannel( url );\n@@ -269,7 +269,7 @@ public void testEncodeReplyResponse() throws Exception {\n         RandomAccessByteArrayOutputStream bos = new RandomAccessByteArrayOutputStream( 1024 );\n         ThriftCodec.RequestData rd = ThriftCodec.RequestData.create(\n-                ThriftCodec.getSeqId(), Demo.class.getName(), \"echoString\" );\n+                ThriftCodec.getSeqId(), Demo.Iface.class.getName(), \"echoString\" );\n         ThriftCodec.cachedRequest.putIfAbsent( request.getId(), rd );\n         codec.encode( channel, bos, response );\n@@ -290,7 +290,7 @@ public void testEncodeReplyResponse() throws Exception {\n         int headerLength = protocol.readI16();\n         Assert.assertEquals( ThriftCodec.VERSION, protocol.readByte() );\n-        Assert.assertEquals( Demo.class.getName(), protocol.readString() );\n+        Assert.assertEquals( Demo.Iface.class.getName(), protocol.readString() );\n         Assert.assertEquals( request.getId(), protocol.readI64() );\n         if ( bis.markSupported() ) {\n@@ -302,7 +302,7 @@ public void testEncodeReplyResponse() throws Exception {\n         Assert.assertEquals( \"echoString\", message.name );\n         Assert.assertEquals( TMessageType.REPLY, message.type );\n         Assert.assertEquals( ThriftCodec.getSeqId(), message.seqid );\n-        $__DemoStub.echoString_result result = new $__DemoStub.echoString_result();\n+        Demo.echoString_result result = new Demo.echoString_result();\n         result.read( protocol );\n         protocol.readMessageEnd();\n@@ -312,7 +312,7 @@ public void testEncodeReplyResponse() throws Exception {\n     @Test\n     public void testEncodeExceptionResponse() throws Exception {\n-        URL url = URL.valueOf( ThriftProtocol.NAME + \"://127.0.0.1:40880/\" + Demo.class.getName() );\n+        URL url = URL.valueOf( ThriftProtocol.NAME + \"://127.0.0.1:40880/\" + Demo.Iface.class.getName() );\n         Channel channel = new MockedChannel( url );\n@@ -328,7 +328,7 @@ public void testEncodeExceptionResponse() throws Exception {\n         RandomAccessByteArrayOutputStream bos = new RandomAccessByteArrayOutputStream( 1024 );\n         ThriftCodec.RequestData rd = ThriftCodec.RequestData.create(\n-                ThriftCodec.getSeqId(), Demo.class.getName(), \"echoString\" );\n+                ThriftCodec.getSeqId(), Demo.Iface.class.getName(), \"echoString\" );\n         ThriftCodec.cachedRequest.put( request.getId(), rd );\n         codec.encode( channel, bos, response );\n@@ -348,7 +348,7 @@ public void testEncodeExceptionResponse() throws Exception {\n         int headerLength = protocol.readI16();\n         Assert.assertEquals( ThriftCodec.VERSION, protocol.readByte() );\n-        Assert.assertEquals( Demo.class.getName(), protocol.readString() );\n+        Assert.assertEquals( Demo.Iface.class.getName(), protocol.readString() );\n         Assert.assertEquals( request.getId(), protocol.readI64() );\n         if ( bis.markSupported() ) {\n@@ -390,7 +390,7 @@ public void testDecodeRequest() throws Exception {\n         protocol.getTransport().flush();\n         headerLength = bos.size();\n-        $__DemoStub.echoString_args args = new $__DemoStub.echoString_args(  );\n+        Demo.echoString_args args = new Demo.echoString_args(  );\n         args.setArg( \"Hell, World!\" );\n         TMessage message = new TMessage( \"echoString\", TMessageType.CALL, ThriftCodec.getSeqId() );\n@@ -437,7 +437,7 @@ private Request createRequest() {\n         invocation.setParameterTypes( new Class<?>[]{ String.class } );\n-        invocation.setAttachment( Constants.INTERFACE_KEY, Demo.class.getName() );\n+        invocation.setAttachment( Constants.INTERFACE_KEY, Demo.Iface.class.getName() );\n         Request request = new Request( 1L );",
    "output": "Fix test case"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java\n@@ -124,6 +124,17 @@ public static List<String> join(Map<String, String> map, String separator) {\n \t\treturn list;\n \t}\n+\tpublic static String join(List<String> list, String separator) {\n+\t    StringBuilder sb = new StringBuilder();\n+        for(String ele : list) {\n+            if(sb.length() > 0) {\n+                sb.append(separator);\n+            }\n+            sb.append(ele);\n+        }\n+        return sb.toString();\n+\t}\n+\n \tpublic static boolean mapEquals(Map<?, ?> map1, Map<?, ?> map2) {\n \t\tif (map1 == null && map2 == null) {\n \t\t\treturn true;\ndiff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java\n@@ -124,7 +124,19 @@ public void test_joinAll() throws Exception {\n         assertEquals(expected, output);\n     }\n-\n+\n+    @Test\n+    public void test_joinList() throws Exception {\n+        List<String> list = Arrays.asList();\n+        assertEquals(\"\", CollectionUtils.join(list, \"/\"));\n+\n+        list = Arrays.asList(\"x\");\n+        assertEquals(\"x\", CollectionUtils.join(list, \"-\"));\n+\n+        list = Arrays.asList(\"a\", \"b\");\n+        assertEquals(\"a/b\", CollectionUtils.join(list, \"/\"));\n+    }\n+\n     @Test\n     public void test_mapEquals() throws Exception {\n         assertTrue(CollectionUtils.mapEquals(null, null));",
    "output": "Add util method"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java\n@@ -124,17 +124,6 @@ public static List<String> join(Map<String, String> map, String separator) {\n \t\treturn list;\n \t}\n-\tpublic static String join(List<String> list, String separator) {\n-\t    StringBuilder sb = new StringBuilder();\n-        for(String ele : list) {\n-            if(sb.length() > 0) {\n-                sb.append(separator);\n-            }\n-            sb.append(ele);\n-        }\n-        return sb.toString();\n-\t}\n-\n \tpublic static boolean mapEquals(Map<?, ?> map1, Map<?, ?> map2) {\n \t\tif (map1 == null && map2 == null) {\n \t\t\treturn true;\ndiff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java\n@@ -124,19 +124,7 @@ public void test_joinAll() throws Exception {\n         assertEquals(expected, output);\n     }\n-\n-    @Test\n-    public void test_joinList() throws Exception {\n-        List<String> list = Arrays.asList();\n-        assertEquals(\"\", CollectionUtils.join(list, \"/\"));\n-\n-        list = Arrays.asList(\"x\");\n-        assertEquals(\"x\", CollectionUtils.join(list, \"-\"));\n-\n-        list = Arrays.asList(\"a\", \"b\");\n-        assertEquals(\"a/b\", CollectionUtils.join(list, \"/\"));\n-    }\n-\n+\n     @Test\n     public void test_mapEquals() throws Exception {\n         assertTrue(CollectionUtils.mapEquals(null, null));",
    "output": "Add util method"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/CollectionUtils.java\n@@ -124,6 +124,17 @@ public static List<String> join(Map<String, String> map, String separator) {\n \t\treturn list;\n \t}\n+\tpublic static String join(List<String> list, String separator) {\n+\t    StringBuilder sb = new StringBuilder();\n+        for(String ele : list) {\n+            if(sb.length() > 0) {\n+                sb.append(separator);\n+            }\n+            sb.append(ele);\n+        }\n+        return sb.toString();\n+\t}\n+\n \tpublic static boolean mapEquals(Map<?, ?> map1, Map<?, ?> map2) {\n \t\tif (map1 == null && map2 == null) {\n \t\t\treturn true;\ndiff --git a/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java b/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java\n--- a/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java\n+++ b/dubbo-common/src/test/java/com/alibaba/dubbo/common/utils/CollectionUtilsTest.java\n@@ -124,7 +124,19 @@ public void test_joinAll() throws Exception {\n         assertEquals(expected, output);\n     }\n-\n+\n+    @Test\n+    public void test_joinList() throws Exception {\n+        List<String> list = Arrays.asList();\n+        assertEquals(\"\", CollectionUtils.join(list, \"/\"));\n+\n+        list = Arrays.asList(\"x\");\n+        assertEquals(\"x\", CollectionUtils.join(list, \"-\"));\n+\n+        list = Arrays.asList(\"a\", \"b\");\n+        assertEquals(\"a/b\", CollectionUtils.join(list, \"/\"));\n+    }\n+\n     @Test\n     public void test_mapEquals() throws Exception {\n         assertTrue(CollectionUtils.mapEquals(null, null));",
    "output": "Add util method"
  },
  {
    "input": "diff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/LocalServiceStore.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/LocalServiceStore.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/LocalServiceStore.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/LocalServiceStore.java\n@@ -17,13 +17,12 @@\n package com.alibaba.dubbo.config;\n import com.alibaba.dubbo.common.Constants;\n-import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.common.extension.ExtensionLoader;\n import com.alibaba.dubbo.common.utils.StringUtils;\n-import com.alibaba.dubbo.rpc.Exporter;\n+import com.alibaba.dubbo.rpc.Protocol;\n+import com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol;\n import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n /**\n  * @author <a href=\"mailto:gang.lvg@alibaba-inc.com\">kimi</a>\n@@ -36,31 +35,16 @@ public static LocalServiceStore getInstance() {\n         return INSTANCE;\n     }\n-    private LocalServiceStore() {\n-    }\n+    private Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class)\n+            .getExtension(Constants.LOCAL_PROTOCOL);\n-    private ConcurrentMap<String, Exporter<?>> exportMap =\n-            new ConcurrentHashMap<String, Exporter<?>>();\n-\n-    public void register(URL url, Exporter<?> exporter) {\n-        if (url != null && exporter != null) {\n-            exportMap.putIfAbsent(url.getServiceKey(), exporter);\n-        }\n+    private LocalServiceStore() {\n     }\n     public boolean isRegistered(String key) {\n-        return StringUtils.isNotEmpty(key) && exportMap.containsKey(key);\n-    }\n-\n-    public void unregister(URL url) {\n-        if (url != null) {\n-            Exporter<?> exporter = exportMap.get(url.getServiceKey());\n-            if (exporter != null) {\n-                try {\n-                    exporter.unexport();\n-                } catch (Throwable e) { /* ignore */ }\n-            }\n-        }\n+        return StringUtils.isNotEmpty(key)\n+                && protocol instanceof InjvmProtocol\n+                && ((InjvmProtocol)protocol).isExported(key);\n     }\n     public static String serviceKey(Map<String, String> map) {\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java\n@@ -487,4 +487,9 @@ public void setConsumer(ConsumerConfig consumer) {\n         this.consumer = consumer;\n     }\n+    // just for test\n+    Invoker<?> getInvoker() {\n+        return invoker;\n+    }\n+\n }\n\\ No newline at end of file\ndiff --git a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n@@ -239,8 +239,6 @@ public synchronized void unexport() {\n     \t\tfor (Exporter<?> exporter : exporters) {\n     \t\t\ttry {\n                     exporter.unexport();\n-                    LocalServiceStore.getInstance().unregister(\n-                            exporter.getInvoker().getUrl());\n                 } catch (Throwable t) {\n                     logger.warn(\"unexpected err when unexport\" + exporter, t);\n                 }\n@@ -439,7 +437,6 @@ private void exportLocal(URL url) {\n                     .setPort(0);\n             Exporter<?> exporter = protocol.export(\n                     proxyFactory.getInvoker(ref, (Class) interfaceClass, local));\n-            LocalServiceStore.getInstance().register(url, exporter);\n         }\n     }\ndiff --git a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmProtocol.java b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmProtocol.java\n--- a/dubbo-rpc/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmProtocol.java\n+++ b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmProtocol.java\n@@ -46,4 +46,7 @@ public <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {\n         return new InjvmInvoker<T>(serviceType, url, url.getServiceKey(), exporterMap);\n     }\n+    public boolean isExported(String key) {\n+        return exporterMap != null && exporterMap.containsKey(key);\n+    }\n }\n\\ No newline at end of file",
    "output": "Fix bug"
  },
  {
    "input": "diff --git a/dubbo-registry/src/main/java/com/alibaba/dubbo/registry/support/RegistryDirectory.java b/dubbo-registry/src/main/java/com/alibaba/dubbo/registry/support/RegistryDirectory.java\n--- a/dubbo-registry/src/main/java/com/alibaba/dubbo/registry/support/RegistryDirectory.java\n+++ b/dubbo-registry/src/main/java/com/alibaba/dubbo/registry/support/RegistryDirectory.java\n@@ -104,7 +104,7 @@ public RegistryDirectory(Class<T> serviceType, URL url) {\n         this.serviceKey = url.getServiceKey();\n         this.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(RpcConstants.REFER_KEY));\n         this.directoryUrl = url.removeParameter(RpcConstants.REFER_KEY).addParameters(queryMap);\n-        String group = directoryUrl.getParameter( Constants.GROUP_KEY );\n+        String group = directoryUrl.getParameter( Constants.GROUP_KEY, \"\" );\n         this.multiGroup = \"*\".equals(group) || group.contains( \",\" );\n     }",
    "output": "Fix NPE"
  },
  {
    "input": "diff --git a/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/ListTelnetHandlerTest.java b/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/ListTelnetHandlerTest.java\n--- a/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/ListTelnetHandlerTest.java\n+++ b/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/ListTelnetHandlerTest.java\n@@ -67,6 +67,8 @@ public static void setUp() {\n         }\n         detailMethods = buf.toString();\n         methodsName = buf2.toString();\n+\n+        ProtocolUtils.closeAll();\n     }\n     @After",
    "output": "Upgrade test case"
  },
  {
    "input": "diff --git a/dubbo-config/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java b/dubbo-config/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n--- a/dubbo-config/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n+++ b/dubbo-config/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java\n@@ -394,7 +394,6 @@ private void doExportUrls() {\n                 }\n             }\n             if (\"injvm\".equals(protocolConfig.getName())) {\n-                protocolConfig.setPort(0);\n                 protocolConfig.setRegister(false);\n                 map.put(\"notify\", \"false\");\n             }\ndiff --git a/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmProtocol.java b/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmProtocol.java\n--- a/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmProtocol.java\n+++ b/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmProtocol.java\n@@ -15,12 +15,12 @@\n  */\n package com.alibaba.dubbo.rpc.protocol.injvm;\n-import com.alibaba.dubbo.common.Extension;\n-import com.alibaba.dubbo.common.URL;\n-import com.alibaba.dubbo.rpc.Exporter;\n-import com.alibaba.dubbo.rpc.Invoker;\n-import com.alibaba.dubbo.rpc.Protocol;\n-import com.alibaba.dubbo.rpc.RpcException;\n+import com.alibaba.dubbo.common.Extension;\n+import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.rpc.Exporter;\n+import com.alibaba.dubbo.rpc.Invoker;\n+import com.alibaba.dubbo.rpc.Protocol;\n+import com.alibaba.dubbo.rpc.RpcException;\n import com.alibaba.dubbo.rpc.protocol.AbstractProtocol;\n /**\n@@ -40,8 +40,8 @@ public int getDefaultPort() {\n         return DEFAULT_PORT;\n     }\n-    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n-        return new InjvmExporter<T>(invoker, serviceKey(invoker.getUrl()), exporterMap);\n+    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n+        return new InjvmExporter<T>(invoker, serviceKey(invoker.getUrl().setPort(DEFAULT_PORT)), exporterMap);\n     }\n     public <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {",
    "output": "Fix DUBBO-49 bug"
  },
  {
    "input": "diff --git a/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/ChangeTelnetHandlerTest.java b/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/ChangeTelnetHandlerTest.java\n--- a/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/ChangeTelnetHandlerTest.java\n+++ b/dubbo-rpc-default/src/test/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/ChangeTelnetHandlerTest.java\n@@ -0,0 +1,120 @@\n+/*\n+ * Copyright 1999-2101 Alibaba Group.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.dubbo.rpc.protocol.dubbo.telnet;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.easymock.EasyMock;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.remoting.Channel;\n+import com.alibaba.dubbo.remoting.RemotingException;\n+import com.alibaba.dubbo.remoting.telnet.TelnetHandler;\n+import com.alibaba.dubbo.rpc.Invoker;\n+import com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol;\n+import com.alibaba.dubbo.rpc.protocol.dubbo.support.DemoService;\n+\n+/**\n+ * ChangeTelnetHandlerTest.java\n+ *\n+ * @author tony.chenl\n+ */\n+public class ChangeTelnetHandlerTest {\n+\n+    private static TelnetHandler change = new ChangeTelnetHandler();\n+    private Channel              mockChannel;\n+    private Invoker<DemoService> mockInvoker;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Before\n+    public void setUp() {\n+        mockChannel = EasyMock.createMock(Channel.class);\n+        mockInvoker = EasyMock.createMock(Invoker.class);\n+        EasyMock.expect(mockChannel.getAttribute(\"telnet.service\")).andReturn(\"com.alibaba.dubbo.rpc.protocol.dubbo.support.DemoService\").anyTimes();\n+        mockChannel.setAttribute(\"telnet.service\", \"DemoService\");\n+        EasyMock.expectLastCall().anyTimes();\n+        mockChannel.setAttribute(\"telnet.service\", \"com.alibaba.dubbo.rpc.protocol.dubbo.support.DemoService\");\n+        EasyMock.expectLastCall().anyTimes();\n+        mockChannel.setAttribute(\"telnet.service\", \"demo\");\n+        EasyMock.expectLastCall().anyTimes();\n+        mockChannel.removeAttribute(\"telnet.service\");\n+        EasyMock.expectLastCall().anyTimes();\n+        EasyMock.expect(mockInvoker.getInterface()).andReturn(DemoService.class).anyTimes();\n+        EasyMock.expect(mockInvoker.getUrl()).andReturn(URL.valueOf(\"dubbo://127.0.0.1:20880/demo\")).anyTimes();\n+        EasyMock.replay(mockChannel, mockInvoker);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+\n+    }\n+\n+    @After\n+    public void after() {\n+        EasyMock.reset(mockChannel, mockInvoker);\n+        DubboProtocol.getDubboProtocol().destroy();\n+    }\n+\n+    @Test\n+    public void testChangeSimpleName() throws RemotingException {\n+        DubboProtocol.getDubboProtocol().export(mockInvoker);\n+        String result = change.telnet(mockChannel, \"DemoService\");\n+        assertEquals(\"Used the DemoService as default.\\r\\nYou can cancel default service by command: cd /\", result);\n+    }\n+\n+    @Test\n+    public void testChangeName() throws RemotingException {\n+        DubboProtocol.getDubboProtocol().export(mockInvoker);\n+        String result = change.telnet(mockChannel, \"com.alibaba.dubbo.rpc.protocol.dubbo.support.DemoService\");\n+        assertEquals(\"Used the com.alibaba.dubbo.rpc.protocol.dubbo.support.DemoService as default.\\r\\nYou can cancel default service by command: cd /\",\n+                     result);\n+    }\n+\n+    @Test\n+    public void testChangePath() throws RemotingException {\n+        DubboProtocol.getDubboProtocol().export(mockInvoker);\n+        String result = change.telnet(mockChannel, \"demo\");\n+        assertEquals(\"Used the demo as default.\\r\\nYou can cancel default service by command: cd /\", result);\n+    }\n+\n+    @Test\n+    public void testChangeMessageNull() throws RemotingException {\n+        String result = change.telnet(mockChannel, null);\n+        assertEquals(\"Please input service name, eg: \\r\\ncd XxxService\\r\\ncd com.xxx.XxxService\", result);\n+    }\n+\n+    @Test\n+    public void testChangeServiceNotExport() throws RemotingException {\n+        String result = change.telnet(mockChannel, \"demo\");\n+        assertEquals(\"No such service demo\", result);\n+    }\n+\n+    @Test\n+    public void testChangeCancel() throws RemotingException {\n+        String result = change.telnet(mockChannel, \"..\");\n+        assertEquals(\"Cancelled default service com.alibaba.dubbo.rpc.protocol.dubbo.support.DemoService.\", result);\n+    }\n+\n+    @Test\n+    public void testChangeCancel2() throws RemotingException {\n+        String result = change.telnet(mockChannel, \"/\");\n+        assertEquals(\"Cancelled default service com.alibaba.dubbo.rpc.protocol.dubbo.support.DemoService.\", result);\n+    }\n+}",
    "output": "Add changetelnethandler test"
  },
  {
    "input": "diff --git a/dubbo-remoting-netty/src/main/java/com/alibaba/dubbo/remoting/transport/netty/NettyClient.java b/dubbo-remoting-netty/src/main/java/com/alibaba/dubbo/remoting/transport/netty/NettyClient.java\n--- a/dubbo-remoting-netty/src/main/java/com/alibaba/dubbo/remoting/transport/netty/NettyClient.java\n+++ b/dubbo-remoting-netty/src/main/java/com/alibaba/dubbo/remoting/transport/netty/NettyClient.java\n@@ -123,7 +123,7 @@ protected void doConnect() throws Throwable {\n             } else if (future.getCause() != null) {\n                 throw future.getCause();\n             } else {\n-                throw new RemotingException(this, \"Faild to connect to server \" + getRemoteAddress() + \", the future was not completed within the specified time limit, please check the timeout [\"+ getConnectTimeout() +\"] config .\");\n+                throw new RemotingException(this, \"Failed to connect to server \" + getRemoteAddress() + \", the future was not completed within the specified time limit, please check the timeout [\"+ getConnectTimeout() +\"] config .\");\n             }\n         }catch (InterruptedException e) {",
    "output": "Fix misspelling"
  },
  {
    "input": "diff --git a/dubbo-registry-default/src/test/java/com/alibaba/dubbo/registry/dubbo/RegistryDirectoryTest.java b/dubbo-registry-default/src/test/java/com/alibaba/dubbo/registry/dubbo/RegistryDirectoryTest.java\n--- a/dubbo-registry-default/src/test/java/com/alibaba/dubbo/registry/dubbo/RegistryDirectoryTest.java\n+++ b/dubbo-registry-default/src/test/java/com/alibaba/dubbo/registry/dubbo/RegistryDirectoryTest.java\n@@ -15,32 +15,35 @@\n  */\n package com.alibaba.dubbo.registry.dubbo;\n-import static org.junit.Assert.fail;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-\n-import junit.framework.Assert;\n-\n-import org.junit.Test;\n-\n-import com.alibaba.dubbo.common.Constants;\n-import com.alibaba.dubbo.common.ExtensionLoader;\n-import com.alibaba.dubbo.common.URL;\n-import com.alibaba.dubbo.registry.RegistryFactory;\n-import com.alibaba.dubbo.registry.support.RegistryDirectory;\n-import com.alibaba.dubbo.registry.support.SimpleRegistryExporter;\n-import com.alibaba.dubbo.rpc.Invoker;\n-import com.alibaba.dubbo.rpc.Protocol;\n-import com.alibaba.dubbo.rpc.RpcConstants;\n-import com.alibaba.dubbo.rpc.RpcException;\n-import com.alibaba.dubbo.rpc.RpcInvocation;\n-import com.alibaba.dubbo.rpc.cluster.Router;\n-import com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance;\n-import com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance;\n-import com.alibaba.dubbo.rpc.cluster.router.ScriptRouter;\n-import com.alibaba.dubbo.rpc.cluster.router.ScriptRouterFactory;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.script.ScriptEngineManager;\n+\n+import junit.framework.Assert;\n+\n+import org.junit.Test;\n+\n+import com.alibaba.dubbo.common.Constants;\n+import com.alibaba.dubbo.common.ExtensionLoader;\n+import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.common.utils.NetUtils;\n+import com.alibaba.dubbo.registry.RegistryFactory;\n+import com.alibaba.dubbo.registry.support.RegistryDirectory;\n+import com.alibaba.dubbo.registry.support.SimpleRegistryExporter;\n+import com.alibaba.dubbo.rpc.Invoker;\n+import com.alibaba.dubbo.rpc.Protocol;\n+import com.alibaba.dubbo.rpc.RpcConstants;\n+import com.alibaba.dubbo.rpc.RpcException;\n+import com.alibaba.dubbo.rpc.RpcInvocation;\n+import com.alibaba.dubbo.rpc.cluster.Router;\n+import com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance;\n+import com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance;\n+import com.alibaba.dubbo.rpc.cluster.router.ScriptRouter;\n+import com.alibaba.dubbo.rpc.cluster.router.ScriptRouterFactory;\n @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n public class RegistryDirectoryTest {\n@@ -51,14 +54,14 @@ public class RegistryDirectoryTest {\n         SimpleRegistryExporter.exportIfAbsent(9092);\n         SimpleRegistryExporter.exportIfAbsent(9093);\n     }\n-    public static URL  REGURL= URL.valueOf(\"dubbo://0.0.0.0:9090/\"+service + \"?callbacks=100\");\n-    public static URL  SERVICEURL= URL.valueOf(\"dubbo://0.0.0.0:9091/\"+service + \"?callbacks=100\");\n-    public static URL  SERVICEURL2= URL.valueOf(\"dubbo://0.0.0.0:9092/\"+service + \"?callbacks=100\");\n-    public static URL  SERVICEURL3= URL.valueOf(\"dubbo://0.0.0.0:9093/\"+service + \"?callbacks=100\");\n-    public static URL  SERVICEURL_DUBBO_NOPATH= URL.valueOf(\"dubbo://0.0.0.0:9092\" + \"?callbacks=100\");\n+    public static URL  REGURL= URL.valueOf(\"dubbo://\"+NetUtils.getLocalHost()+\":9090/\"+service + \"?callbacks=100\");\n+    public static URL  SERVICEURL= URL.valueOf(\"dubbo://\"+NetUtils.getLocalHost()+\":9091/\"+service + \"?callbacks=100\");\n+    public static URL  SERVICEURL2= URL.valueOf(\"dubbo://\"+NetUtils.getLocalHost()+\":9092/\"+service + \"?callbacks=100\");\n+    public static URL  SERVICEURL3= URL.valueOf(\"dubbo://\"+NetUtils.getLocalHost()+\":9093/\"+service + \"?callbacks=100\");\n+    public static URL  SERVICEURL_DUBBO_NOPATH= URL.valueOf(\"dubbo://\"+NetUtils.getLocalHost()+\":9092\" + \"?callbacks=100\");\n-    public static URL  ROUTERURL= URL.valueOf(RpcConstants.ROUTE_PROTOCOL + \"://0.0.0.0:9096/\");\n-    public static URL  ROUTERURL2= URL.valueOf(RpcConstants.ROUTE_PROTOCOL + \"://0.0.0.0:9097/\");\n+    public static URL  ROUTERURL= URL.valueOf(RpcConstants.ROUTE_PROTOCOL + \"://\"+NetUtils.getLocalHost()+\":9096/\");\n+    public static URL  ROUTERURL2= URL.valueOf(RpcConstants.ROUTE_PROTOCOL + \"://\"+NetUtils.getLocalHost()+\":9097/\");\n     List invokers = null;\n@@ -283,8 +286,13 @@ public void testDestroy(){\n         //List<U> urls = mockRegistry.getSubscribedUrls();\n         RpcInvocation inv = new RpcInvocation();\n-        invokers = registryDirectory.list(inv);\n-        Assert.assertEquals(0, invokers.size());\n+        try {\n+            invokers = registryDirectory.list(inv);\n+            fail();\n+        } catch (RpcException e) {\n+            Assert.assertTrue(e.getMessage().contains(\"already destroyed\"));\n+        }\n+\n     }\n     @Test\n@@ -303,7 +311,7 @@ public void testDubbo1UrlWithGenericInvocation(){\n         invokers = registryDirectory.list(invocation);\n         Assert.assertEquals(1, invokers.size());\n-        Assert.assertEquals(\"dubbo://0.0.0.0:9092/com.alibaba.dubbo.demo.DemoService?callbacks=100&check=false&methods=getXXX1,getXXX2,getXXX3\", invokers.get(0).toString());\n+        Assert.assertEquals(\"dubbo://\"+NetUtils.getLocalHost()+\":9092/com.alibaba.dubbo.demo.DemoService?callbacks=100&check=false&methods=getXXX1,getXXX2,getXXX3\", invokers.get(0).toString());\n     }\n@@ -359,14 +367,17 @@ public void testEmptyNotifyCauseForbidden(){\n         Assert.assertEquals(2, invokers.size());\n     }\n-\n+\n+    private static boolean isScriptUnsupported = new ScriptEngineManager().getEngineByName(\"javascript\") == null;\n     /**\n      * 1. notify twice, the second time notified router rules should completely replace the former one.\n      * 2. notify with no router url, do nothing to current routers\n      * 3. notify with only one router url, with router=clean, clear all current routers\n      */\n     @Test\n-    public void testNotifyRouterUrls(){\n+    public void testNotifyRouterUrls(){\n+        if (isScriptUnsupported) return;\n+\n         List<URL> serviceUrls = new ArrayList<URL> ();\n         // without ROUTER_KEY, the first router should not be created.",
    "output": "Upgrade test case"
  },
  {
    "input": "diff --git a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ReflectUtils.java b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ReflectUtils.java\n--- a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ReflectUtils.java\n+++ b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/ReflectUtils.java\n@@ -23,6 +23,8 @@\n import java.security.ProtectionDomain;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n@@ -107,6 +109,8 @@ public final class ReflectUtils {\n \tpublic static final Pattern SETTER_METHOD_DESC_PATTERN = Pattern.compile(\"set([A-Z][_a-zA-Z0-9]*)\\\\((\" + DESC_REGEX + \")\\\\)V\");\n \tpublic static final Pattern IS_HAS_CAN_METHOD_DESC_PATTERN = Pattern.compile(\"(?:is|has|can)([A-Z][_a-zA-Z0-9]*)\\\\(\\\\)Z\");\n+\n+\tprivate static final ConcurrentMap<String, Class<?>[]>  DESC_CLASSARRAY_CACHE = new ConcurrentHashMap<String, Class<?>[]>();\n \t/**\n \t * is compatible.\n@@ -668,7 +672,12 @@ public static Class<?> desc2class(ClassLoader cl, String desc) throws ClassNotFo\n \t */\n \tpublic static Class<?>[] desc2classArray(String desc) throws ClassNotFoundException\n \t{\n-\t\treturn desc2classArray(ClassHelper.getClassLoader(), desc);\n+\t    Class<?>[] ret = DESC_CLASSARRAY_CACHE.get(desc);\n+\t    if (ret == null){\n+\t        ret = desc2classArray(ClassHelper.getClassLoader(), desc);\n+\t        DESC_CLASSARRAY_CACHE.put(desc, ret);\n+\t    }\n+\t\treturn ret;\n \t}\n \t/**",
    "output": "Add cache for ReflectUtils DUBBO-13"
  },
  {
    "input": "diff --git a/dubbo-monitor/src/main/java/com/alibaba/dubbo/monitor/filter/MonitorFilter.java b/dubbo-monitor/src/main/java/com/alibaba/dubbo/monitor/filter/MonitorFilter.java\n--- a/dubbo-monitor/src/main/java/com/alibaba/dubbo/monitor/filter/MonitorFilter.java\n+++ b/dubbo-monitor/src/main/java/com/alibaba/dubbo/monitor/filter/MonitorFilter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 1999-2011 Alibaba Group.\n+ * Copyright 1999-2101 Alibaba Group.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -22,6 +22,8 @@\n import com.alibaba.dubbo.common.Constants;\n import com.alibaba.dubbo.common.Extension;\n import com.alibaba.dubbo.common.URL;\n+import com.alibaba.dubbo.common.logger.Logger;\n+import com.alibaba.dubbo.common.logger.LoggerFactory;\n import com.alibaba.dubbo.common.utils.NetUtils;\n import com.alibaba.dubbo.monitor.Monitor;\n import com.alibaba.dubbo.monitor.MonitorFactory;\n@@ -40,6 +42,8 @@\n  */\n @Extension(\"monitor\")\n public class MonitorFilter implements Filter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MonitorFilter.class);\n     private final ConcurrentMap<String, AtomicInteger> concurrents = new ConcurrentHashMap<String, AtomicInteger>();\n@@ -72,38 +76,42 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept\n     // \n     private void collect(Invoker<?> invoker, Invocation invocation, RpcContext context, long start, boolean error) {\n-        // ----  ----\n-        long elapsed = System.currentTimeMillis() - start; // \n-        int concurrent = getConcurrent(invoker, invocation).get(); // \n-        String application = invoker.getUrl().getParameter(Constants.APPLICATION_KEY);\n-        String service = invoker.getInterface().getName(); // \n-        String method = invocation.getMethodName(); // \n-        URL url = URL.valueOf(invoker.getUrl().getParameterAndDecoded(Constants.MONITOR_KEY));\n-        Monitor monitor = monitorFactory.getMonitor(url);\n-        // ----  ----\n-        String server = context.getLocalAddressString(); // \n-        if (invoker.getUrl().getAddress().equals(server)) {\n-            monitor.count(new URL(invoker.getUrl().getProtocol(), NetUtils.getLocalHost(), context.getLocalPort())\n-                    .addParameters(MonitorService.APPLICATION, application,\n-                            MonitorService.INTERFACE, service,\n-                            MonitorService.METHOD, method,\n-                            MonitorService.CLIENT, context.getRemoteHost(),\n-                            error ? MonitorService.FAILURE : MonitorService.SUCCESS, String.valueOf(1),\n-                            MonitorService.ELAPSED, String.valueOf(elapsed),\n-                            MonitorService.CONCURRENT, String.valueOf(concurrent)));\n-        }\n-        // ----  ----\n-        context = RpcContext.getContext(); // invoke()context\n-        server = context.getRemoteAddressString(); // \n-        if (invoker.getUrl().getAddress().equals(server)) {\n-            monitor.count(new URL(invoker.getUrl().getProtocol(), NetUtils.getLocalHost(), 0)\n-                    .addParameters(MonitorService.APPLICATION, application,\n-                            MonitorService.INTERFACE, service,\n-                            MonitorService.METHOD, method,\n-                            MonitorService.SERVER, server,\n-                            error ? MonitorService.FAILURE : MonitorService.SUCCESS, String.valueOf(1),\n-                            MonitorService.ELAPSED, String.valueOf(elapsed),\n-                            MonitorService.CONCURRENT, String.valueOf(concurrent)));\n+        try {\n+            // ----  ----\n+            long elapsed = System.currentTimeMillis() - start; // \n+            int concurrent = getConcurrent(invoker, invocation).get(); // \n+            String application = invoker.getUrl().getParameter(Constants.APPLICATION_KEY);\n+            String service = invoker.getInterface().getName(); // \n+            String method = invocation.getMethodName(); // \n+            URL url = URL.valueOf(invoker.getUrl().getParameterAndDecoded(Constants.MONITOR_KEY));\n+            Monitor monitor = monitorFactory.getMonitor(url);\n+            // ----  ----\n+            String server = context.getLocalAddressString(); // \n+            if (invoker.getUrl().getAddress().equals(server)) {\n+                monitor.count(new URL(invoker.getUrl().getProtocol(), NetUtils.getLocalHost(), context.getLocalPort())\n+                        .addParameters(MonitorService.APPLICATION, application,\n+                                MonitorService.INTERFACE, service,\n+                                MonitorService.METHOD, method,\n+                                MonitorService.CLIENT, context.getRemoteHost(),\n+                                error ? MonitorService.FAILURE : MonitorService.SUCCESS, String.valueOf(1),\n+                                MonitorService.ELAPSED, String.valueOf(elapsed),\n+                                MonitorService.CONCURRENT, String.valueOf(concurrent)));\n+            }\n+            // ----  ----\n+            context = RpcContext.getContext(); // invoke()context\n+            server = context.getRemoteAddressString(); // \n+            if (invoker.getUrl().getAddress().equals(server)) {\n+                monitor.count(new URL(invoker.getUrl().getProtocol(), NetUtils.getLocalHost(), 0)\n+                        .addParameters(MonitorService.APPLICATION, application,\n+                                MonitorService.INTERFACE, service,\n+                                MonitorService.METHOD, method,\n+                                MonitorService.SERVER, server,\n+                                error ? MonitorService.FAILURE : MonitorService.SUCCESS, String.valueOf(1),\n+                                MonitorService.ELAPSED, String.valueOf(elapsed),\n+                                MonitorService.CONCURRENT, String.valueOf(concurrent)));\n+            }\n+        } catch (Throwable t) {\n+            logger.error(\"Failed to monitor count service \" + invoker.getUrl() + \", cause: \" + t.getMessage(), t);\n         }\n     }",
    "output": "Fix monitor bug."
  },
  {
    "input": "diff --git a/dubbo-config/src/main/java/com/alibaba/dubbo/config/AbstractConfig.java b/dubbo-config/src/main/java/com/alibaba/dubbo/config/AbstractConfig.java\n--- a/dubbo-config/src/main/java/com/alibaba/dubbo/config/AbstractConfig.java\n+++ b/dubbo-config/src/main/java/com/alibaba/dubbo/config/AbstractConfig.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 1999-2011 Alibaba Group.\n+ * Copyright 1999-2101 Alibaba Group.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -108,9 +108,12 @@ protected static String convertMonitor(String monitor, URL registry) {\n                 version = monitor.substring(i + 1);\n             } else {\n                 group = monitor;\n-                version = \"0.0.0\";\n+                version = null;\n             }\n-            monitor = registry.setProtocol(\"dubbo\").addParameter(Constants.MONITOR_KEY, registry.getProtocol()).addParameterAndEncoded(RpcConstants.REFER_KEY, \"group=\" + group + \"&version=\" + version + \"&interface=\" + MonitorService.class.getName()).toFullString();\n+            monitor = registry.setProtocol(\"dubbo\").addParameter(Constants.MONITOR_KEY, registry.getProtocol())\n+                    .addParameterAndEncoded(RpcConstants.REFER_KEY, \"group=\" + group\n+                    + (version == null || version.length() == 0 ? \"\" : \"&version=\" + version)\n+                    + \"&interface=\" + MonitorService.class.getName()).toFullString();\n         }\n         try {\n             return URLEncoder.encode(monitor, \"UTF-8\");",
    "output": "Fix monitor bug."
  },
  {
    "input": "diff --git a/dubbo-monitor/src/main/java/com/alibaba/dubbo/monitor/support/dubbo/DubboMonitor.java b/dubbo-monitor/src/main/java/com/alibaba/dubbo/monitor/support/dubbo/DubboMonitor.java\n--- a/dubbo-monitor/src/main/java/com/alibaba/dubbo/monitor/support/dubbo/DubboMonitor.java\n+++ b/dubbo-monitor/src/main/java/com/alibaba/dubbo/monitor/support/dubbo/DubboMonitor.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 1999-2011 Alibaba Group.\n+ * Copyright 1999-2101 Alibaba Group.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -96,17 +96,16 @@ public void send() {\n             long maxConcurrent = numbers[9];\n             // \n-            URL url = statistics.getUrl();\n-            url.addParameter(MonitorService.SUCCESS, success);\n-            url.addParameter(MonitorService.FAILURE, failure);\n-            url.addParameter(MonitorService.INPUT, input);\n-            url.addParameter(MonitorService.OUTPUT, output);\n-            url.addParameter(MonitorService.ELAPSED, elapsed);\n-            url.addParameter(MonitorService.CONCURRENT, concurrent);\n-            url.addParameter(MonitorService.MAX_INPUT, maxInput);\n-            url.addParameter(MonitorService.MAX_OUTPUT, maxOutput);\n-            url.addParameter(MonitorService.MAX_ELAPSED, maxElapsed);\n-            url.addParameter(MonitorService.MAX_CONCURRENT, maxConcurrent);\n+            URL url = statistics.getUrl().addParameter(MonitorService.SUCCESS, success)\n+                    .addParameter(MonitorService.FAILURE, failure)\n+                    .addParameter(MonitorService.INPUT, input)\n+                    .addParameter(MonitorService.OUTPUT, output)\n+                    .addParameter(MonitorService.ELAPSED, elapsed)\n+                    .addParameter(MonitorService.CONCURRENT, concurrent)\n+                    .addParameter(MonitorService.MAX_INPUT, maxInput)\n+                    .addParameter(MonitorService.MAX_OUTPUT, maxOutput)\n+                    .addParameter(MonitorService.MAX_ELAPSED, maxElapsed)\n+                    .addParameter(MonitorService.MAX_CONCURRENT, maxConcurrent);\n             monitorService.count(url);\n             // ",
    "output": "Fix monitor bug."
  }
]